diff -Nur libmovtar-0.1.3-old/rtjpeg/RTjpeg.c libmovtar-0.1.3/rtjpeg/RTjpeg.c
--- libmovtar-0.1.3-old/rtjpeg/RTjpeg.c	2008-04-04 16:55:08.000000000 +0300
+++ libmovtar-0.1.3/rtjpeg/RTjpeg.c	2008-01-19 12:44:14.000000000 +0200
@@ -1,11 +1,14 @@
-/* 
+/*
    RTjpeg (C) Justin Schoeman 1998 (justin@suntiger.ee.up.ac.za)
-   
+
    With modifications by:
    (c) 1998, 1999 by Joerg Walter <trouble@moes.pmnet.uni-oldenburg.de>
    and
    (c) 1999 by Wim Taymans <wim.taymans@tvd.be>
 
+   Modified for transcode (warning cleanup) by Andrew Church
+   <achurch@achurch.org>
+
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -19,20 +22,21 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-    
+
 */
 
+#include "RTjpeg.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include "RTjpeg.h"
-
-#undef MMX
 
 #ifdef MMX
 #include "mmx.h"
 #endif
 
+//#define SHOWBLOCK 1
+#define BETTERCOMPRESSION 1
+
 static const unsigned char RTjpeg_ZZ[64]={
 0,
 8, 1,
@@ -50,27 +54,28 @@
 62, 55,
 63 };
 
-static const __u64 RTjpeg_aan_tab[64]={
-4294967296ULL, 5957222912ULL, 5611718144ULL, 5050464768ULL, 4294967296ULL, 3374581504ULL, 2324432128ULL, 1184891264ULL, 
-5957222912ULL, 8263040512ULL, 7783580160ULL, 7005009920ULL, 5957222912ULL, 4680582144ULL, 3224107520ULL, 1643641088ULL, 
-5611718144ULL, 7783580160ULL, 7331904512ULL, 6598688768ULL, 5611718144ULL, 4408998912ULL, 3036936960ULL, 1548224000ULL, 
-5050464768ULL, 7005009920ULL, 6598688768ULL, 5938608128ULL, 5050464768ULL, 3968072960ULL, 2733115392ULL, 1393296000ULL, 
-4294967296ULL, 5957222912ULL, 5611718144ULL, 5050464768ULL, 4294967296ULL, 3374581504ULL, 2324432128ULL, 1184891264ULL, 
-3374581504ULL, 4680582144ULL, 4408998912ULL, 3968072960ULL, 3374581504ULL, 2651326208ULL, 1826357504ULL, 931136000ULL, 
-2324432128ULL, 3224107520ULL, 3036936960ULL, 2733115392ULL, 2324432128ULL, 1826357504ULL, 1258030336ULL, 641204288ULL, 
-1184891264ULL, 1643641088ULL, 1548224000ULL, 1393296000ULL, 1184891264ULL, 931136000ULL, 641204288ULL, 326894240ULL, 
+static const uint64_t RTjpeg_aan_tab[64]={
+4294967296ULL, 5957222912ULL, 5611718144ULL, 5050464768ULL, 4294967296ULL, 3374581504ULL, 2324432128ULL, 1184891264ULL,
+5957222912ULL, 8263040512ULL, 7783580160ULL, 7005009920ULL, 5957222912ULL, 4680582144ULL, 3224107520ULL, 1643641088ULL,
+5611718144ULL, 7783580160ULL, 7331904512ULL, 6598688768ULL, 5611718144ULL, 4408998912ULL, 3036936960ULL, 1548224000ULL,
+5050464768ULL, 7005009920ULL, 6598688768ULL, 5938608128ULL, 5050464768ULL, 3968072960ULL, 2733115392ULL, 1393296000ULL,
+4294967296ULL, 5957222912ULL, 5611718144ULL, 5050464768ULL, 4294967296ULL, 3374581504ULL, 2324432128ULL, 1184891264ULL,
+3374581504ULL, 4680582144ULL, 4408998912ULL, 3968072960ULL, 3374581504ULL, 2651326208ULL, 1826357504ULL, 931136000ULL,
+2324432128ULL, 3224107520ULL, 3036936960ULL, 2733115392ULL, 2324432128ULL, 1826357504ULL, 1258030336ULL, 641204288ULL,
+1184891264ULL, 1643641088ULL, 1548224000ULL, 1393296000ULL, 1184891264ULL, 931136000ULL, 641204288ULL, 326894240ULL,
 };
 
 #ifndef MMX
-static __s32 RTjpeg_ws[64+31];
+static int32_t RTjpeg_ws[64+31];
 #endif
-__u8 RTjpeg_alldata[2*64+4*64+4*64+4*64+4*64+32];
+uint8_t RTjpeg_alldata[2*64+4*64+4*64+4*64+4*64+32];
 
-__s16 *RTjpeg_block;
-__s32 *RTjpeg_lqt;
-__s32 *RTjpeg_cqt;
-__u32 *RTjpeg_liqt;
-__u32 *RTjpeg_ciqt;
+int16_t *block; // rh
+int16_t *RTjpeg_block;
+int32_t *RTjpeg_lqt;
+int32_t *RTjpeg_cqt;
+uint32_t *RTjpeg_liqt;
+uint32_t *RTjpeg_ciqt;
 
 unsigned char RTjpeg_lb8;
 unsigned char RTjpeg_cb8;
@@ -78,14 +83,14 @@
 int RTjpeg_Ywidth, RTjpeg_Cwidth;
 int RTjpeg_Ysize, RTjpeg_Csize;
 
-__s16 *RTjpeg_old=NULL;
+int16_t *RTjpeg_old=NULL;
 
 #ifdef MMX
 mmx_t RTjpeg_lmask;
 mmx_t RTjpeg_cmask;
 #else
-__u16 RTjpeg_lmask;
-__u16 RTjpeg_cmask;
+uint16_t RTjpeg_lmask;
+uint16_t RTjpeg_cmask;
 #endif
 int RTjpeg_mtest=0;
 
@@ -111,82 +116,411 @@
     99,  99,  99,  99,  99,  99,  99,  99
  };
 
+#ifdef BETTERCOMPRESSION
+
+/*--------------------------------------------------*/
+/*  better encoding, but needs a lot more cpu time  */
+/*  seems to be more effective than old method +lzo */
+/*  with this encoding lzo isn't efficient anymore  */
+/*  there is still more potential for better        */
+/*  encoding but that would need even more cputime  */
+/*  anyway your mileage may vary                    */
+/*                                                  */
+/*  written by Martin BIELY and Roman HOCHLEITNER   */
+/*--------------------------------------------------*/
+
+/* +++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* Block to Stream (encoding)                         */
+/*                                                    */
+
+static int RTjpeg_b2s(int16_t *data, int8_t *strm, uint8_t bt8)
+{
+ register int ci, co=1;
+ register int16_t ZZvalue;
+ register unsigned char bitten;
+ register unsigned char bitoff;
+
+#ifdef SHOWBLOCK
+
+  int ii;
+  for (ii=0; ii < 64; ii++) {
+    fprintf(stderr, "%d ", data[RTjpeg_ZZ[ii]]);
+  }
+  fprintf(stderr, "\n\n");
+
+#endif
+
+// *strm++ = 0x10;
+// *strm   = 0x00;
+//
+// return 2;
+
+ // first byte allways written
+strm[0]=
+      (uint8_t)(data[RTjpeg_ZZ[0]]>254) ? 254:((data[RTjpeg_ZZ[0]]<0)?0:data[RTjpeg_ZZ[0]]);
+
+
+ ci=63;
+ while (data[RTjpeg_ZZ[ci]]==0 && ci>0) ci--;
+
+ bitten = ((unsigned char)ci) << 2;
+
+ if (ci==0) {
+   strm[1]= bitten;
+   co = 2;
+   return (int)co;
+ }
+
+ /* bitoff=0 because the high 6bit contain first non zero position */
+ bitoff = 0;
+ co = 1;
+
+ for(; ci>0; ci--) {
+
+   ZZvalue = data[RTjpeg_ZZ[ci]];
+
+   switch(ZZvalue) {
+   case 0:
+	break;
+   case 1:
+        bitten |= (0x01<<bitoff);
+	break;
+   case -1:
+        bitten |= (0x03<<bitoff);
+	break;
+   default:
+        bitten |= (0x02<<bitoff);
+	goto HERZWEH;
+	break;
+   }
+
+   if( bitoff == 0 ) {
+      strm[co]= bitten;
+      bitten = 0;
+      bitoff = 8;
+      co++;
+   } /* "fall through" */
+   bitoff-=2;
+
+ }
+
+ /* ci must be 0 */
+ if(bitoff != 6) {
+
+      strm[co]= bitten;
+      co++;
+
+ }
+ goto BAUCHWEH;
+
+HERZWEH:
+/* ci cannot be 0 */
+/* correct bitoff to nibble boundaries */
+
+ switch(bitoff){
+ case 4:
+ case 6:
+   bitoff = 0;
+   break;
+ case 2:
+ case 0:
+   strm[co]= bitten;
+   bitoff = 4;
+   co++;
+   bitten = 0; // clear half nibble values in bitten
+   break;
+ default:
+   break;
+ }
+
+ for(; ci>0; ci--) {
+
+   ZZvalue = data[RTjpeg_ZZ[ci]];
+
+   if( (ZZvalue > 7) || (ZZvalue < -7) ) {
+        bitten |= (0x08<<bitoff);
+	goto HIRNWEH;
+   }
+
+   bitten |= (ZZvalue&0xf)<<bitoff;
+
+   if( bitoff == 0 ) {
+      strm[co]= bitten;
+      bitten = 0;
+      bitoff = 8;
+      co++;
+   } /* "fall thru" */
+   bitoff-=4;
+ }
+
+ /* ci must be 0 */
+ if( bitoff == 0 ) {
+    strm[co]= bitten;
+    co++;
+ }
+ goto BAUCHWEH;
+
+HIRNWEH:
+
+ strm[co]= bitten;
+ co++;
+
+
+ /* bitting is over now we bite */
+ for(; ci>0; ci--) {
+
+   ZZvalue = data[RTjpeg_ZZ[ci]];
+
+   if(ZZvalue>0)
+   {
+     strm[co++]=(int8_t)(ZZvalue>127)?127:ZZvalue;
+   }
+   else
+   {
+     strm[co++]=(int8_t)(ZZvalue<-128)?-128:ZZvalue;
+   }
+
+ }
+
+
+BAUCHWEH:
+  /* we gotoo much now we are ill */
+#ifdef SHOWBLOCK
+{
+int i;
+fprintf(stderr, "\nco = '%d'\n", co);
+ for (i=0; i < co+2; i++) {
+   fprintf(stderr, "%d ", strm[i]);
+ }
+fprintf(stderr, "\n\n");
+}
+#endif
+
+ return (int)co;
+}
 
-static __s8 clip_lut[1024];
-#define CLIP(i) ((clip_lut+384)[ (i)])
+/* +++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* Stream to Block  (decoding)                        */
+/*                                                    */
 
-void idct_dbl_init (void)
+static int RTjpeg_s2b(int16_t *data, int8_t *strm, uint8_t bt8, uint32_t *qtbl)
 {
-    int i;
+ int ci;
+ register int co;
+ register int i;
+ register unsigned char bitten;
+ register unsigned char bitoff;
+
+ /* first byte always read */
+ i=RTjpeg_ZZ[0];
+ data[i]=((uint8_t)strm[0])*qtbl[i];
+
+ /* we start at the behind */
+
+ bitten = ((unsigned char)strm[1]) >> 2;
+ co = 63;
+ for(; co > bitten; co--) {
+
+   data[RTjpeg_ZZ[co]] = 0;
+
+ }
+
+ if (co==0) {
+   ci = 2;
+   goto AUTOBAHN;
+ }
+
+ /* we have to read the last 2 bits of the second byte */
+ ci=1;
+ bitoff = 0;
+
+ for(; co>0; co--) {
+
+  bitten  = ((unsigned char)strm[ci]) >> bitoff;
+  bitten &= 0x03;
+
+  i=RTjpeg_ZZ[co];
+
+  switch( bitten ) {
+  case 0x03:
+    data[i]= -qtbl[i];
+    break;
+  case 0x02:
+    goto FUSSWEG;
+    break;
+  case 0x01:
+    data[i]= qtbl[i];
+    break;
+  case 0x00:
+    data[i]= 0;
+    break;
+  default:
+    break;
+
+  }
 
-    printf("idct_dbl_init called !\n");
-    for (i = -384; i < 640; i++)
-	clip_lut[i+384] = (i < 0) ? 0 : ((i > 255) ? 255 : i);
+  if( bitoff == 0 ) {
+    bitoff = 8;
+    ci++;
+  }
+  bitoff -= 2;
+ }
+ /* co is 0 now */
+ /* data is written properly */
+
+ /* if bitoff!=6 then ci is the index, but should be the byte count, so we increment by 1 */
+ if (bitoff!=6) ci++;
+
+ goto AUTOBAHN;
+
+
+FUSSWEG:
+/* correct bitoff to nibble */
+ switch(bitoff){
+ case 4:
+ case 6:
+   bitoff = 0;
+   break;
+ case 2:
+ case 0:
+   /* we have to read from the next byte */
+   ci++;
+   bitoff = 4;
+   break;
+ default:
+   break;
+ }
+
+ for(; co>0; co--) {
+
+  bitten  = ((unsigned char)strm[ci]) >> bitoff;
+  bitten &= 0x0f;
+
+  i=RTjpeg_ZZ[co];
+
+  if( bitten == 0x08 ) {
+    goto STRASSE;
+  }
+
+  /* the compiler cannot do sign extension for signed nibbles */
+  if( bitten & 0x08 ) {
+    bitten |= 0xf0;
+  }
+  /* the unsigned char bitten now is a valid signed char */
+
+  data[i]=((signed char)bitten)*qtbl[i];
+
+  if( bitoff == 0 ) {
+    bitoff = 8;
+    ci++;
+  }
+  bitoff -= 4;
+ }
+ /* co is 0 */
+
+ /* if bitoff!=4 then ci is the index, but should be the byte count, so we increment by 1 */
+ if (bitoff!=4) ci++;
+
+ goto AUTOBAHN;
+
+STRASSE:
+  ci++;
+
+ for(; co>0; co--) {
+  i=RTjpeg_ZZ[co];
+  data[i]=strm[ci++]*qtbl[i];
+ }
+
+ /* ci now is the count, because it points to next element => no incrementing */
+
+AUTOBAHN:
+
+#ifdef SHOWBLOCK
+fprintf(stderr, "\nci = '%d'\n", ci);
+ for (i=0; i < 64; i++) {
+   fprintf(stderr, "%d ", data[RTjpeg_ZZ[i]]);
+ }
+fprintf(stderr, "\n\n");
+#endif
+
+ return ci;
 }
- 
-int RTjpeg_b2s(__s16 *data, __s8 *strm, __u8 bt8)
+
+#else
+
+static int RTjpeg_b2s(int16_t *data, int8_t *strm, uint8_t bt8)
 {
  register int ci, co=1, tmp;
- register __s16 ZZvalue;
+ register int16_t ZZvalue;
+
+#ifdef SHOWBLOCK
+
+  int ii;
+  for (ii=0; ii < 64; ii++) {
+    fprintf(stderr, "%d ", data[RTjpeg_ZZ[ii]]);
+  }
+  fprintf(stderr, "\n\n");
+
+#endif
+
+ (uint8_t)strm[0]=(uint8_t)(data[RTjpeg_ZZ[0]]>254) ? 254:((data[RTjpeg_ZZ[0]]<0)?0:data[RTjpeg_ZZ[0]]);
 
- strm[0]=(__u8)(data[RTjpeg_ZZ[0]]>254) ? 254:((data[RTjpeg_ZZ[0]]<0)?0:data[RTjpeg_ZZ[0]]);
- 
- for(ci=1; ci<=bt8; ci++) 
+ for(ci=1; ci<=bt8; ci++)
  {
 	ZZvalue = data[RTjpeg_ZZ[ci]];
 
-   if(ZZvalue>0) 
+   if(ZZvalue>0)
 	{
-     strm[co++]=(__s8)(ZZvalue>127)?127:ZZvalue;
-   } 
-	else 
+     strm[co++]=(int8_t)(ZZvalue>127)?127:ZZvalue;
+   }
+	else
 	{
-     strm[co++]=(__s8)(ZZvalue<-128)?-128:ZZvalue;
+     strm[co++]=(int8_t)(ZZvalue<-128)?-128:ZZvalue;
    }
  }
 
- for(; ci<64; ci++) 
+ for(; ci<64; ci++)
  {
   ZZvalue = data[RTjpeg_ZZ[ci]];
 
   if(ZZvalue>0)
   {
-   strm[co++]=(__s8)(ZZvalue>63)?63:ZZvalue;
-  } 
+   strm[co++]=(int8_t)(ZZvalue>63)?63:ZZvalue;
+  }
   else if(ZZvalue<0)
   {
-   strm[co++]=(__s8)(ZZvalue<-64)?-64:ZZvalue;
-  } 
+   strm[co++]=(int8_t)(ZZvalue<-64)?-64:ZZvalue;
+  }
   else /* compress zeros */
   {
    tmp=ci;
    do
    {
     ci++;
-   } 
+   }
 	while((ci<64)&&(data[RTjpeg_ZZ[ci]]==0));
 
-   strm[co++]=(__s8)(63+(ci-tmp));
+   strm[co++]=(int8_t)(63+(ci-tmp));
    ci--;
   }
  }
  return (int)co;
 }
 
-int RTjpeg_s2b(__s16 *data, __s8 *strm, __u8 bt8, __u32 *qtbl)
+static int RTjpeg_s2b(int16_t *data, int8_t *strm, uint8_t bt8, uint32_t *qtbl)
 {
  int ci=1, co=1, tmp;
  register int i;
 
  i=RTjpeg_ZZ[0];
- data[i]=((__u8)strm[0])*qtbl[i];
+ data[i]=((uint8_t)strm[0])*qtbl[i];
 
  for(co=1; co<=bt8; co++)
  {
   i=RTjpeg_ZZ[co];
   data[i]=strm[ci++]*qtbl[i];
  }
- 
+
  for(; co<64; co++)
  {
   if(strm[ci]>63)
@@ -203,70 +537,71 @@
  }
  return (int)ci;
 }
+#endif
 
 #if defined(MMX)
-void RTjpeg_quant_init(void)
+static void RTjpeg_quant_init(void)
 {
  int i;
- __s16 *qtbl;
- 
- qtbl=(__s16 *)RTjpeg_lqt;
- for(i=0; i<64; i++)qtbl[i]=(__s16)RTjpeg_lqt[i];
+ int16_t *qtbl;
 
- qtbl=(__s16 *)RTjpeg_cqt;
- for(i=0; i<64; i++)qtbl[i]=(__s16)RTjpeg_cqt[i];
+ qtbl=(int16_t *)RTjpeg_lqt;
+ for(i=0; i<64; i++)qtbl[i]=(int16_t)RTjpeg_lqt[i];
+
+ qtbl=(int16_t *)RTjpeg_cqt;
+ for(i=0; i<64; i++)qtbl[i]=(int16_t)RTjpeg_cqt[i];
 }
 
 static mmx_t RTjpeg_ones=(mmx_t)(long long)0x0001000100010001LL;
 static mmx_t RTjpeg_half=(mmx_t)(long long)0x7fff7fff7fff7fffLL;
 
-void RTjpeg_quant(__s16 *block, __s32 *qtbl)
+static void RTjpeg_quant(int16_t *block, int32_t *qtbl)
 {
  int i;
  mmx_t *bl, *ql;
- 
+
  ql=(mmx_t *)qtbl;
  bl=(mmx_t *)block;
- 
+
  movq_m2r(RTjpeg_ones, mm6);
  movq_m2r(RTjpeg_half, mm7);
 
- for(i=16; i; i--) 
+ for(i=16; i; i--)
  {
   movq_m2r(*(ql++), mm0); /* quant vals (4) */
   movq_m2r(*bl, mm2); /* block vals (4) */
   movq_r2r(mm0, mm1);
   movq_r2r(mm2, mm3);
-  
+
   punpcklwd_r2r(mm6, mm0); /*           1 qb 1 qa */
   punpckhwd_r2r(mm6, mm1); /* 1 qd 1 qc */
-  
+
   punpcklwd_r2r(mm7, mm2); /*                   32767 bb 32767 ba */
   punpckhwd_r2r(mm7, mm3); /* 32767 bd 32767 bc */
-  
+
   pmaddwd_r2r(mm2, mm0); /*                         32767+bb*qb 32767+ba*qa */
   pmaddwd_r2r(mm3, mm1); /* 32767+bd*qd 32767+bc*qc */
-  
+
   psrad_i2r(16, mm0);
   psrad_i2r(16, mm1);
-  
+
   packssdw_r2r(mm1, mm0);
-  
+
   movq_r2m(mm0, *(bl++));
-  
+
  }
 }
 #else
-void RTjpeg_quant_init(void)
+static void RTjpeg_quant_init(void)
 {
 }
 
-void RTjpeg_quant(__s16 *block, __s32 *qtbl)
+static void RTjpeg_quant(int16_t *block, int32_t *qtbl)
 {
  int i;
- 
+
  for(i=0; i<64; i++)
-   block[i]=(__s16)((block[i]*qtbl[i]+32767)>>16);
+   block[i]=(int16_t)((block[i]*qtbl[i]+32767)>>16);
 }
 #endif
 
@@ -282,36 +617,36 @@
 
 #else
 
-#define FIX_0_382683433  ((__s32)   98)		/* FIX(0.382683433) */
-#define FIX_0_541196100  ((__s32)  139)		/* FIX(0.541196100) */
-#define FIX_0_707106781  ((__s32)  181)		/* FIX(0.707106781) */
-#define FIX_1_306562965  ((__s32)  334)		/* FIX(1.306562965) */
+#define FIX_0_382683433  ((int32_t)   98)		/* FIX(0.382683433) */
+#define FIX_0_541196100  ((int32_t)  139)		/* FIX(0.541196100) */
+#define FIX_0_707106781  ((int32_t)  181)		/* FIX(0.707106781) */
+#define FIX_1_306562965  ((int32_t)  334)		/* FIX(1.306562965) */
 
-#define DESCALE10(x) (__s16)( ((x)+128) >> 8)
-#define DESCALE20(x)  (__s16)(((x)+32768) >> 16)
-#define D_MULTIPLY(var,const)  ((__s32) ((var) * (const)))
+#define DESCALE10(x) (int16_t)( ((x)+128) >> 8)
+#define DESCALE20(x)  (int16_t)(((x)+32768) >> 16)
+#define D_MULTIPLY(var,const)  ((int32_t) ((var) * (const)))
 #endif
 
-void RTjpeg_dct_init(void)
+static void RTjpeg_dct_init(void)
 {
  int i;
- 
+
  for(i=0; i<64; i++)
  {
-  RTjpeg_lqt[i]=(((__u64)RTjpeg_lqt[i]<<32)/RTjpeg_aan_tab[i]);
-  RTjpeg_cqt[i]=(((__u64)RTjpeg_cqt[i]<<32)/RTjpeg_aan_tab[i]);
+  RTjpeg_lqt[i]=(((uint64_t)RTjpeg_lqt[i]<<32)/RTjpeg_aan_tab[i]);
+  RTjpeg_cqt[i]=(((uint64_t)RTjpeg_cqt[i]<<32)/RTjpeg_aan_tab[i]);
  }
 }
 
-void RTjpeg_dctY(__u8 *idata, __s16 *odata, int rskip)
+static void RTjpeg_dctY(uint8_t *idata, int16_t *odata, int rskip)
 {
 #ifndef MMX
-  __s32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
-  __s32 tmp10, tmp11, tmp12, tmp13;
-  __s32 z1, z2, z3, z4, z5, z11, z13;
-  __u8 *idataptr;
-  __s16 *odataptr;
-  __s32 *wsptr;
+  int32_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+  int32_t tmp10, tmp11, tmp12, tmp13;
+  int32_t z1, z2, z3, z4, z5, z11, z13;
+  uint8_t *idataptr;
+  int16_t *odataptr;
+  int32_t *wsptr;
   int ctr;
 
   idataptr = idata;
@@ -325,19 +660,19 @@
     tmp5 = idataptr[2] - idataptr[5];
     tmp3 = idataptr[3] + idataptr[4];
     tmp4 = idataptr[3] - idataptr[4];
-    
+
     tmp10 = (tmp0 + tmp3);	/* phase 2 */
     tmp13 = tmp0 - tmp3;
     tmp11 = (tmp1 + tmp2);
     tmp12 = tmp1 - tmp2;
-    
+
     wsptr[0] = (tmp10 + tmp11)<<8; /* phase 3 */
     wsptr[4] = (tmp10 - tmp11)<<8;
-    
+
     z1 = D_MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */
     wsptr[2] = (tmp13<<8) + z1;	/* phase 5 */
     wsptr[6] = (tmp13<<8) - z1;
-    
+
     tmp10 = tmp4 + tmp5;	/* phase 2 */
     tmp11 = tmp5 + tmp6;
     tmp12 = tmp6 + tmp7;
@@ -370,15 +705,15 @@
     tmp5 = wsptr[16] - wsptr[40];
     tmp3 = wsptr[24] + wsptr[32];
     tmp4 = wsptr[24] - wsptr[32];
-    
+
     tmp10 = tmp0 + tmp3;	/* phase 2 */
     tmp13 = tmp0 - tmp3;
     tmp11 = tmp1 + tmp2;
     tmp12 = tmp1 - tmp2;
-    
+
     odataptr[0] = DESCALE10(tmp10 + tmp11); /* phase 3 */
     odataptr[32] = DESCALE10(tmp10 - tmp11);
-    
+
     z1 = D_MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */
     odataptr[16] = DESCALE20((tmp13<<8) + z1); /* phase 5 */
     odataptr[48] = DESCALE20((tmp13<<8) - z1);
@@ -403,9 +738,8 @@
     odataptr++;			/* advance pointer to next column */
     wsptr++;
   }
-
 #else
-  mmx_t tmp6, tmp7;
+  volatile mmx_t tmp6, tmp7;
   register mmx_t *dataptr = (mmx_t *)odata;
   mmx_t *idata2 = (mmx_t *)idata;
 
@@ -414,85 +748,85 @@
    movq_m2r(RTjpeg_zero, mm2);
 
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+1));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+2));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+3));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+4));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+5));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+6));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+7));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+8));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+9));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+10));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+11));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+12));
 
 	punpckhbw_r2r(mm2, mm1);
 	movq_r2m(mm1, *(dataptr+13));
-	
+
 	idata2 += rskip;
 
-	movq_m2r(*idata2, mm0);		 
-	movq_r2r(mm0, mm1);		 			
+	movq_m2r(*idata2, mm0);
+	movq_r2r(mm0, mm1);
 
 	punpcklbw_r2r(mm2, mm0);
 	movq_r2m(mm0, *(dataptr+14));
@@ -505,15 +839,15 @@
 	movq_m2r(*(dataptr+9), mm7);		 	// m03:m02|m01:m00 - first line (line 4)and copy into m5
 
 	movq_m2r(*(dataptr+13), mm6);	    	// m23:m22|m21:m20 - third line (line 6)and copy into m2
-	movq_r2r(mm7, mm5);		 			
+	movq_r2r(mm7, mm5);
 
 	punpcklwd_m2r(*(dataptr+11), mm7); 	// m11:m01|m10:m00 - interleave first and second lines
-	movq_r2r(mm6, mm2);						 
+	movq_r2r(mm6, mm2);
 
 	punpcklwd_m2r(*(dataptr+15), mm6);  // m31:m21|m30:m20 - interleave third and fourth lines
 	movq_r2r(mm7, mm1);
 
-	movq_m2r(*(dataptr+11), mm3);	      // m13:m13|m11:m10 - second line	 
+	movq_m2r(*(dataptr+11), mm3);	      // m13:m13|m11:m10 - second line
 	punpckldq_r2r(mm6, mm7);				// m30:m20|m10:m00 - interleave to produce result 1
 
 	movq_m2r(*(dataptr+15), mm0);	      // m13:m13|m11:m10 - fourth line
@@ -521,7 +855,7 @@
 
 	movq_r2m(mm7,*(dataptr+9));			// write result 1
 	punpckhwd_r2r(mm3, mm5);				// m13:m03|m12:m02 - interleave first and second lines
-	
+
 	movq_r2m(mm1,*(dataptr+11));			// write result 2
 	punpckhwd_r2r(mm0, mm2);				// m33:m23|m32:m22 - interleave third and fourth lines
 
@@ -547,7 +881,7 @@
 	movq_r2r(mm0, mm4);
 
 	//
-	movq_m2r(*(dataptr+8), mm1);			// n03:n02|n01:n00 - first line 
+	movq_m2r(*(dataptr+8), mm1);			// n03:n02|n01:n00 - first line
 	punpckldq_r2r(mm2, mm0);				// m30:m20|m10:m00 - interleave to produce first result
 
 	movq_m2r(*(dataptr+12), mm3);			// n23:n22|n21:n20 - third line
@@ -662,14 +996,14 @@
    movq_r2r(mm0, mm3);
 
 	psllw_i2r(2, mm6);			// m8 * 2^2
-	paddw_r2r(mm1, mm0);		
+	paddw_r2r(mm1, mm0);
 
 	pmulhw_m2r(RTjpeg_C4, mm6);			// z1
-	psubw_r2r(mm1, mm3);		
+	psubw_r2r(mm1, mm3);
 
    movq_r2m(mm0, *dataptr);
    movq_r2r(mm7, mm0);
-   
+
     /* Odd part */
    movq_r2m(mm3, *(dataptr+8));
 	paddw_r2r(mm5, mm4);						// tmp10
@@ -691,7 +1025,7 @@
 	psubw_r2r(mm2, mm1);						// tmp10 - tmp12
 	psllw_i2r(2, mm4);			// m8 * 2^2
 
-	movq_m2r(RTjpeg_C2mC6, mm0);		
+	movq_m2r(RTjpeg_C2mC6, mm0);
 	psllw_i2r(2, mm1);
 
 	pmulhw_m2r(RTjpeg_C6, mm1);			// z5
@@ -791,7 +1125,7 @@
 
    movq_r2m(mm0, *(dataptr+1)); 			//save y0
 	movq_r2r(mm7, mm0);						// copy tmp13
-  
+
 	/* odd part */
 
    movq_r2m(mm3, *(dataptr+9)); 			//save y4
@@ -818,14 +1152,14 @@
 	psllw_i2r(2, mm1);			// shift (tmp10-tmp12)
 
 	pmulhw_m2r(RTjpeg_C6, mm1);    		// z5
-	psllw_i2r(2, mm5);			// prepare for multiply 
+	psllw_i2r(2, mm5);			// prepare for multiply
 
 	pmulhw_r2r(mm0, mm4);					// multiply by converted real
 
 	/* stage 5 */
 
 	pmulhw_m2r(RTjpeg_C4, mm5);			// z3
-	psllw_i2r(2, mm2);			// prepare for multiply 
+	psllw_i2r(2, mm2);			// prepare for multiply
 
 	pmulhw_m2r(RTjpeg_C2pC6, mm2);		// multiply
 	movq_r2r(mm3, mm0);						// copy tmp7
@@ -851,7 +1185,7 @@
 
    movq_r2m(mm6, *(dataptr+3)); 			//save y1
 	psubw_r2r(mm2, mm0);						// y7
-	
+
 /************************************************************************************************
 					Start of Transpose
 ************************************************************************************************/
@@ -896,9 +1230,9 @@
 	punpcklwd_m2r(*(dataptr+7), mm2);  	// m31:m21|m30:m20 - interleave third and fourth lines
 	movq_r2r(mm0, mm4);						// copy first intermediate result
 
-	
 
-	movq_m2r(*(dataptr+8), mm1);			// n03:n02|n01:n00 - first line 
+
+	movq_m2r(*(dataptr+8), mm1);			// n03:n02|n01:n00 - first line
 	punpckldq_r2r(mm2, mm0);				// m30:m20|m10:m00 - interleave to produce first result
 
 	movq_m2r(*(dataptr+12), mm3);			// n23:n22|n21:n20 - third line
@@ -925,7 +1259,7 @@
 	movq_r2r(mm1, mm4);						// copy second intermediate result
 
 	movq_r2m(mm6, *(dataptr+12));			// write result 3 out
-	punpckldq_r2r(mm3, mm1);				// 
+	punpckldq_r2r(mm3, mm1);				//
 
 	punpckhwd_m2r(*(dataptr+14), mm0);  // n33:n23|n32:n22 - interleave third and fourth lines
 	movq_r2r(mm2, mm6);						// copy second intermediate result
@@ -952,7 +1286,7 @@
 
 	punpcklwd_m2r(*(dataptr+2), mm0);  	// m11:m01|m10:m00 - interleave first and second lines
 	movq_r2r(mm7, mm4);						// copy third line
-	
+
 	punpcklwd_m2r(*(dataptr+6), mm7);  	// m31:m21|m30:m20 - interleave third and fourth lines
 	movq_r2r(mm0, mm1);						// copy first intermediate result
 
@@ -1012,14 +1346,14 @@
    movq_r2r(mm0, mm3);
 
 	psllw_i2r(2, mm6);			// m8 * 2^2
-	paddw_r2r(mm1, mm0);		
+	paddw_r2r(mm1, mm0);
 
 	pmulhw_m2r(RTjpeg_C4, mm6);			// z1
-	psubw_r2r(mm1, mm3);		
+	psubw_r2r(mm1, mm3);
 
    movq_r2m(mm0, *dataptr);
    movq_r2r(mm7, mm0);
-   
+
     /* Odd part */
    movq_r2m(mm3, *(dataptr+8));
 	paddw_r2r(mm5, mm4);						// tmp10
@@ -1140,7 +1474,7 @@
 
    movq_r2m(mm0, *(dataptr+1)); 			//save y0
 	movq_r2r(mm7, mm0);						// copy tmp13
-  
+
 	/* odd part */
 
    movq_r2m(mm3, *(dataptr+9)); 			//save y4
@@ -1167,14 +1501,14 @@
 	psllw_i2r(2, mm1);			// shift (tmp10-tmp12)
 
 	pmulhw_m2r(RTjpeg_C6, mm1);    		// z5
-	psllw_i2r(2, mm5);			// prepare for multiply 
+	psllw_i2r(2, mm5);			// prepare for multiply
 
 	pmulhw_r2r(mm0, mm4);					// multiply by converted real
 
 	/* stage 5 */
 
 	pmulhw_m2r(RTjpeg_C4, mm5);			// z3
-	psllw_i2r(2, mm2);			// prepare for multiply 
+	psllw_i2r(2, mm2);			// prepare for multiply
 
 	pmulhw_m2r(RTjpeg_C2pC6, mm2);		// multiply
 	movq_r2r(mm3, mm0);						// copy tmp7
@@ -1197,44 +1531,42 @@
 	paddw_r2r(mm4, mm3);						// y5
 
    movq_r2m(mm5, *(dataptr+7)); 			//save y3
-	psubw_r2r(mm2, mm0);						// yè=z11 - z4
+	psubw_r2r(mm2, mm0);						// y7=z11 - z4
 
    movq_r2m(mm3, *(dataptr+11)); 		//save y5
 
    movq_r2m(mm6, *(dataptr+3)); 			//save y1
 
    movq_r2m(mm0, *(dataptr+15)); 		//save y7
-	
+
 
 #endif
 }
 
-#define FIX_1_082392200  ((__s32)  277)		/* FIX(1.082392200) */
-#define FIX_1_414213562  ((__s32)  362)		/* FIX(1.414213562) */
-#define FIX_1_847759065  ((__s32)  473)		/* FIX(1.847759065) */
-#define FIX_2_613125930  ((__s32)  669)		/* FIX(2.613125930) */
+#define FIX_1_082392200  ((int32_t)  277)		/* FIX(1.082392200) */
+#define FIX_1_414213562  ((int32_t)  362)		/* FIX(1.414213562) */
+#define FIX_1_847759065  ((int32_t)  473)		/* FIX(1.847759065) */
+#define FIX_2_613125930  ((int32_t)  669)		/* FIX(2.613125930) */
 
-#define DESCALE(x) (__s16)( ((x)+4) >> 3)
+#define DESCALE(x) (int16_t)( ((x)+4) >> 3)
 
 /* clip yuv to 16..235 (should be 16..240 for cr/cb but ... */
 
 #define RL(x) ((x)>235) ? 235 : (((x)<16) ? 16 : (x))
-#define MULTIPLY(var,const)  (((__s32) ((var) * (const)) + 128)>>8)
+#define MULTIPLY(var,const)  (((int32_t) ((var) * (const)) + 128)>>8)
 
-void RTjpeg_idct_init(void)
+static void RTjpeg_idct_init(void)
 {
  int i;
- 
- idct_dbl_init();
 
  for(i=0; i<64; i++)
  {
-  RTjpeg_liqt[i]=((__u64)RTjpeg_liqt[i]*RTjpeg_aan_tab[i])>>32;
-  RTjpeg_ciqt[i]=((__u64)RTjpeg_ciqt[i]*RTjpeg_aan_tab[i])>>32;
+  RTjpeg_liqt[i]=((uint64_t)RTjpeg_liqt[i]*RTjpeg_aan_tab[i])>>32;
+  RTjpeg_ciqt[i]=((uint64_t)RTjpeg_ciqt[i]*RTjpeg_aan_tab[i])>>32;
  }
 }
 
-void RTjpeg_idct(__u8 *odata, __s16 *data, int rskip)
+static void RTjpeg_idct(uint8_t *odata, int16_t *data, int rskip)
 {
 #ifdef MMX
 
@@ -1268,7 +1600,7 @@
 
 	paddw_r2r(mm0, mm1);				// z13 = tmp6 + tmp5;
 
-	psubw_r2r(mm0, mm2);				// z10 = tmp6 - tmp5   
+	psubw_r2r(mm0, mm2);				// z10 = tmp6 - tmp5
 
 	psllw_i2r(2, mm2);				// shift z10
 	movq_r2r(mm2, mm0); 				// copy z10
@@ -1289,7 +1621,7 @@
  	movq_r2r(mm5, mm7);				//	copy z12
 
 	pmulhw_m2r(fix_108n184, mm5); //	MULT(z12, (FIX_1_08-FIX_1_84)) //- z5; /* 2*(c2-c6) */ even part
-	paddw_r2r(mm1, mm3);				// tmp7 = z11 + z13;	
+	paddw_r2r(mm1, mm3);				// tmp7 = z11 + z13;
 
 	//ok
 
@@ -1314,36 +1646,36 @@
 
 	movq_r2m(mm1, *(wsptr));		// save tmp13 in workspace
 	psllw_i2r(2, mm5);	// shift tmp1-tmp3
-    
+
 	movq_m2r(*(idata), mm7); 		// load idata[DCTSIZE*0]
 
 	pmulhw_m2r(fix_141, mm5);		// MULTIPLY(tmp1 - tmp3, FIX_1_414213562)
 	paddw_r2r(mm6, mm0);				// tmp4 = tmp10 + tmp5;
 
 	movq_m2r(*(idata+8), mm4); 	// load idata[DCTSIZE*4]
-	
+
 	psubw_r2r(mm1, mm5);				// tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
 
 	movq_r2m(mm0, *(wsptr+4));		// save tmp4 in workspace
 	movq_r2r(mm7, mm1);			 	// copy tmp0	/* phase 3 */
 
 	movq_r2m(mm5, *(wsptr+2));		// save tmp12 in workspace
-	psubw_r2r(mm4, mm1);				// tmp11 = tmp0 - tmp2; 
+	psubw_r2r(mm4, mm1);				// tmp11 = tmp0 - tmp2;
 
 	paddw_r2r(mm4, mm7);				// tmp10 = tmp0 + tmp2;
    movq_r2r(mm1, mm5);				// copy tmp11
-	
+
 	paddw_m2r(*(wsptr+2), mm1);	// tmp1 = tmp11 + tmp12;
 	movq_r2r(mm7, mm4);				// copy tmp10		/* phase 2 */
 
-	paddw_m2r(*(wsptr), mm7);		// tmp0 = tmp10 + tmp13;	
+	paddw_m2r(*(wsptr), mm7);		// tmp0 = tmp10 + tmp13;
 
 	psubw_m2r(*(wsptr), mm4);		// tmp3 = tmp10 - tmp13;
 	movq_r2r(mm7, mm0);				//	copy tmp0
 
 	psubw_m2r(*(wsptr+2), mm5);	// tmp2 = tmp11 - tmp12;
 	paddw_r2r(mm3, mm7);				//	wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
-	
+
 	psubw_r2r(mm3, mm0);				// wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
 
 	movq_r2m(mm7, *(wsptr));		//	wsptr[DCTSIZE*0]
@@ -1363,17 +1695,17 @@
 
 	psubw_m2r(*(wsptr+4), mm1); 	// wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
 
-	movq_r2m(mm4, *(wsptr+8));		
+	movq_r2m(mm4, *(wsptr+8));
 	movq_r2r(mm5, mm7);				// copy tmp2
 
 	paddw_r2r(mm6, mm5);				// wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5)
 
-	movq_r2m(mm1, *(wsptr+6));	
+	movq_r2m(mm1, *(wsptr+6));
 	psubw_r2r(mm6, mm7);				//	wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
 
-	movq_r2m(mm5, *(wsptr+4));	
+	movq_r2m(mm5, *(wsptr+4));
 
-	movq_r2m(mm7, *(wsptr+10));		
+	movq_r2m(mm7, *(wsptr+10));
 
 	//ok
 
@@ -1395,7 +1727,7 @@
 	movq_m2r(*(idata+14),	mm4);		// load idata[DCTSIZE*7]
 	paddw_r2r(mm0, mm1);				//	z13 = tmp6 + tmp5;
 
-	psubw_r2r(mm0, mm2);				//	z10 = tmp6 - tmp5   
+	psubw_r2r(mm0, mm2);				//	z10 = tmp6 - tmp5
 
 	psllw_i2r(2, mm2);				//	shift z10
 	movq_r2r(mm2, mm0);				//	copy z10
@@ -1416,7 +1748,7 @@
  	movq_r2r(mm5, mm7);				// copy z12
 
 	pmulhw_m2r(fix_108n184, mm5);	// MULT(z12, (FIX_1_08-FIX_1_84)) //- z5; /* 2*(c2-c6) */ even part
-	paddw_r2r(mm1, mm3);				// tmp7 = z11 + z13;	
+	paddw_r2r(mm1, mm3);				// tmp7 = z11 + z13;
 
 	//ok
 
@@ -1441,36 +1773,36 @@
 
 	movq_r2m(mm1, *(wsptr));		// save tmp13 in workspace
 	psllw_i2r(2, mm5); 				// shift tmp1-tmp3
-    
+
 	movq_m2r(*(idata), mm7);		// load idata[DCTSIZE*0]
 	paddw_r2r(mm6, mm0);				// tmp4 = tmp10 + tmp5;
 
 	pmulhw_m2r(fix_141, mm5);		// MULTIPLY(tmp1 - tmp3, FIX_1_414213562)
 
 	movq_m2r(*(idata+8), mm4);    // load idata[DCTSIZE*4]
-	
+
 	psubw_r2r(mm1, mm5);				// tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
 
 	movq_r2m(mm0, *(wsptr+4));		// save tmp4 in workspace
 	movq_r2r(mm7, mm1);				// copy tmp0	/* phase 3 */
 
 	movq_r2m(mm5, *(wsptr+2));		// save tmp12 in workspace
-	psubw_r2r(mm4, mm1);				// tmp11 = tmp0 - tmp2; 
+	psubw_r2r(mm4, mm1);				// tmp11 = tmp0 - tmp2;
 
 	paddw_r2r(mm4, mm7);				// tmp10 = tmp0 + tmp2;
    movq_r2r(mm1, mm5);				// copy tmp11
-	
+
 	paddw_m2r(*(wsptr+2), mm1);	// tmp1 = tmp11 + tmp12;
 	movq_r2r(mm7, mm4);				// copy tmp10		/* phase 2 */
 
-	paddw_m2r(*(wsptr), mm7);		// tmp0 = tmp10 + tmp13;	
+	paddw_m2r(*(wsptr), mm7);		// tmp0 = tmp10 + tmp13;
 
 	psubw_m2r(*(wsptr), mm4);		// tmp3 = tmp10 - tmp13;
 	movq_r2r(mm7, mm0);				// copy tmp0
 
 	psubw_m2r(*(wsptr+2), mm5);	// tmp2 = tmp11 - tmp12;
 	paddw_r2r(mm3, mm7);				// wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
-	
+
 	psubw_r2r(mm3, mm0);				// wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
 
 	movq_r2m(mm7, *(wsptr));		// wsptr[DCTSIZE*0]
@@ -1490,15 +1822,15 @@
 
 	psubw_m2r(*(wsptr+4), mm1);	// wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
 
-	movq_r2m(mm4, *(wsptr+8));		
+	movq_r2m(mm4, *(wsptr+8));
 	movq_r2r(mm5, mm7);				// copy tmp2
 
 	paddw_r2r(mm6, mm5);				// wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5)
 
-	movq_r2m(mm1, *(wsptr+6));		
+	movq_r2m(mm1, *(wsptr+6));
 	psubw_r2r(mm6, mm7);				// wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
 
-	movq_r2m(mm5, *(wsptr+4));	
+	movq_r2m(mm5, *(wsptr+4));
 
 	movq_r2m(mm7, *(wsptr+10));
 
@@ -1521,7 +1853,7 @@
 
 	movq_m2r(*(wsptr+1),	mm1);		// wsptr[0,4],[0,5],[0,6],[0,7]
 	movq_r2r(mm0, mm2);
-	
+
 	movq_m2r(*(wsptr+2), mm3);		// wsptr[1,0],[1,1],[1,2],[1,3]
 	paddw_r2r(mm1, mm0);				// wsptr[0,tmp10],[xxx],[0,tmp13],[xxx]
 
@@ -1530,7 +1862,7 @@
 
 	movq_r2r(mm0, mm6);
 	movq_r2r(mm3, mm5);
-	
+
 	paddw_r2r(mm4, mm3);				// wsptr[1,tmp10],[xxx],[1,tmp13],[xxx]
 	movq_r2r(mm2, mm1);
 
@@ -1552,7 +1884,7 @@
 	movq_m2r(*(wsptr+5), mm5);		// wsptr[2,4],[2,5],[2,6],[2,7]
 	punpckldq_r2r(mm2, mm1);		// wsptr[0,tmp11],[1,tmp11],[0,tmp14],[1,tmp14]
 
-	
+
 	paddw_r2r(mm5, mm3);				// wsptr[2,tmp10],[xxx],[2,tmp13],[xxx]
 	movq_r2r(mm6, mm2);
 
@@ -1561,13 +1893,13 @@
 
 	movq_r2r(mm3, mm5);
 	punpcklwd_r2r(mm6, mm3);		// wsptr[2,tmp10],[3,tmp10],[xxx],[xxx]
-	
+
 	psubw_r2r(mm7, mm2);				// wsptr[3,tmp11],[xxx],[3,tmp14],[xxx]
 	punpckhwd_r2r(mm6, mm5);		// wsptr[2,tmp13],[3,tmp13],[xxx],[xxx]
 
 	movq_r2r(mm4, mm7);
 	punpckldq_r2r(mm5, mm3);		// wsptr[2,tmp10],[3,tmp10],[2,tmp13],[3,tmp13]
-						 
+
 	punpcklwd_r2r(mm2, mm4);		// wsptr[2,tmp11],[3,tmp11],[xxx],[xxx]
 
 	punpckhwd_r2r(mm2, mm7);		// wsptr[2,tmp14],[3,tmp14],[xxx],[xxx]
@@ -1628,7 +1960,7 @@
 	movq_r2m(mm0, *(wsptr));		// save tmp0
 	paddw_r2r(mm4, mm2);				// wsptr[xxx],[0,z11],[xxx],[0,z13]
 
-	
+
 //Continue with z10 --- z13
 	movq_m2r(*(wsptr+2), mm6);		// wsptr[1,0],[1,1],[1,2],[1,3]
 	psubw_r2r(mm4, mm3);				// wsptr[xxx],[0,z12],[xxx],[0,z10]
@@ -1641,11 +1973,11 @@
 
 	punpckhdq_r2r(mm4, mm0);		// wsptr[1,6],[1,7],[1,2],[1,3]
 	movq_r2r(mm6, mm1);
-	
+
 //Save tmp2 and tmp3 in wsptr
 	paddw_r2r(mm0, mm6);				// wsptr[xxx],[1,z11],[xxx],[1,z13]
 	movq_r2r(mm2, mm4);
-	
+
 //Continue with z10 --- z13
 	movq_r2m(mm5, *(wsptr+2));		// save tmp2
 	punpcklwd_r2r(mm6, mm2);		// wsptr[xxx],[xxx],[0,z11],[1,z11]
@@ -1673,7 +2005,7 @@
 
 	punpckhdq_r2r(mm4, mm7);		// wsptr[2,6],[2,7],[2,2],[2,3]
 	movq_r2r(mm6, mm2);
-	
+
 	movq_m2r(*(wsptr+7), mm4);	// wsptr[3,4],[3,5],[3,6],[3,7]
 	paddw_r2r(mm7, mm6);				// wsptr[xxx],[2,z11],[xxx],[2,z13]
 
@@ -1735,7 +2067,7 @@
 //	 tmp22 = MULTIPLY(z10,(FIX_1_847759065 - FIX_2_613125930)) /* -2*(c2+c6) */
 //			+ MULTIPLY(z12, FIX_1_847759065); /* 2*c2 */
 	movq_r2r(mm2, mm4);				// final1
-  
+
 	pmulhw_m2r(fix_184n261, mm0);
 	paddw_r2r(mm5, mm2);				// tmp0+tmp7,final1
 
@@ -1777,9 +2109,9 @@
 	psraw_i2r(3, mm0);				// outptr[0,1],[1,1],[2,1],[3,1]
 
 	psraw_i2r(3, mm6);				// outptr[0,6],[1,6],[2,6],[3,6]
-	
+
 	packuswb_r2r(mm4, mm0);			// out[0,1],[1,1],[2,1],[3,1],[0,7],[1,7],[2,7],[3,7]
-	
+
 	movq_m2r(*(wsptr+2), mm5);		// tmp2,final3
 	packuswb_r2r(mm6, mm2);			// out[0,0],[1,0],[2,0],[3,0],[0,6],[1,6],[2,6],[3,6]
 
@@ -1832,7 +2164,7 @@
 	punpckhbw_r2r(mm6, mm7);		// out[0,4],[0,5],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]
 
 	punpcklwd_r2r(mm5, mm2);		// out[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3]
-	
+
 	// add			ecx, output_col
 
 	movq_r2r(mm7, mm6);
@@ -1842,19 +2174,19 @@
 	punpcklwd_r2r(mm4, mm6);		// out[0,4],[0,5],[0,6],[0,7],[1,4],[1,5],[1,6],[1,7]
 
 	// mov			idata, [dataptr]
-	
+
 	punpckldq_r2r(mm6, mm2);		// out[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7]
 
 	// add		 	dataptr, 4
-	 
+
 	movq_r2r(mm1, mm3);
 
-	// add			idata, output_col 
-	
+	// add			idata, output_col
+
 	punpckhwd_r2r(mm4, mm7);		// out[2,4],[2,5],[2,6],[2,7],[3,4],[3,5],[3,6],[3,7]
-	
+
 	movq_r2m(mm2, *(dataptr));
-	
+
 	punpckhdq_r2r(mm6, mm0);		// out[1,0],[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]
 
 	dataptr += rskip;
@@ -1862,7 +2194,7 @@
 
 	punpckldq_r2r(mm7, mm1);		// out[2,0],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[2,7]
 	punpckhdq_r2r(mm7, mm3);		// out[3,0],[3,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7]
-	
+
 	dataptr += rskip;
 	movq_r2m(mm1, *(dataptr));
 
@@ -1883,7 +2215,7 @@
 
 	movq_m2r(*(wsptr+1), mm1);		// wsptr[0,4],[0,5],[0,6],[0,7]
 	movq_r2r(mm0, mm2);
-	
+
 	movq_m2r(*(wsptr+2), mm3);		// wsptr[1,0],[1,1],[1,2],[1,3]
 	paddw_r2r(mm1, mm0);				// wsptr[0,tmp10],[xxx],[0,tmp13],[xxx]
 
@@ -1892,7 +2224,7 @@
 
 	movq_r2r(mm0, mm6);
 	movq_r2r(mm3, mm5);
-	
+
 	paddw_r2r(mm4, mm3);				// wsptr[1,tmp10],[xxx],[1,tmp13],[xxx]
 	movq_r2r(mm2, mm1);
 
@@ -1922,7 +2254,7 @@
 
 	movq_r2r(mm3, mm5);
 	punpcklwd_r2r(mm6, mm3);		// wsptr[2,tmp10],[3,tmp10],[xxx],[xxx]
-	
+
 	psubw_r2r(mm7, mm2);				// wsptr[3,tmp11],[xxx],[3,tmp14],[xxx]
 	punpckhwd_r2r(mm6, mm5);		// wsptr[2,tmp13],[3,tmp13],[xxx],[xxx]
 
@@ -1989,7 +2321,7 @@
 	movq_r2m(mm0, *(wsptr));		// save tmp0
 	paddw_r2r(mm4, mm2);				// wsptr[xxx],[0,z11],[xxx],[0,z13]
 
-	
+
 //Continue with z10 --- z13
 	movq_m2r(*(wsptr+2), mm6);		// wsptr[1,0],[1,1],[1,2],[1,3]
 	psubw_r2r(mm4, mm3);				// wsptr[xxx],[0,z12],[xxx],[0,z10]
@@ -2002,11 +2334,11 @@
 
 	punpckhdq_r2r(mm4, mm0);		// wsptr[1,6],[1,7],[1,2],[1,3]
 	movq_r2r(mm6, mm1);
-	
+
 //Save tmp2 and tmp3 in wsptr
 	paddw_r2r(mm0, mm6);				// wsptr[xxx],[1,z11],[xxx],[1,z13]
 	movq_r2r(mm2, mm4);
-	
+
 //Continue with z10 --- z13
 	movq_r2m(mm5, *(wsptr+2));		// save tmp2
 	punpcklwd_r2r(mm6, mm2);		// wsptr[xxx],[xxx],[0,z11],[1,z11]
@@ -2034,7 +2366,7 @@
 
 	punpckhdq_r2r(mm4, mm7);		// wsptr[2,6],[2,7],[2,2],[2,3]
 	movq_r2r(mm6, mm2);
-	
+
 	movq_m2r(*(wsptr+7), mm4);	// wsptr[3,4],[3,5],[3,6],[3,7]
 	paddw_r2r(mm7, mm6);				// wsptr[xxx],[2,z11],[xxx],[2,z13]
 
@@ -2096,7 +2428,7 @@
 //	 tmp22 = MULTIPLY(z10,(FIX_1_847759065 - FIX_2_613125930)) /* -2*(c2+c6) */
 //			+ MULTIPLY(z12, FIX_1_847759065); /* 2*c2 */
 	movq_r2r(mm2, mm4);				// final1
-  
+
 	pmulhw_m2r(fix_184n261, mm0);
 	paddw_r2r(mm5, mm2);				// tmp0+tmp7,final1
 
@@ -2137,9 +2469,9 @@
 	psraw_i2r(3, mm0);				// outptr[0,1],[1,1],[2,1],[3,1]
 
 	psraw_i2r(3, mm6);				// outptr[0,6],[1,6],[2,6],[3,6]
-	
+
 	packuswb_r2r(mm4, mm0);			// out[0,1],[1,1],[2,1],[3,1],[0,7],[1,7],[2,7],[3,7]
-	
+
 	movq_m2r(*(wsptr+2), mm5);		// tmp2,final3
 	packuswb_r2r(mm6, mm2);			// out[0,0],[1,0],[2,0],[3,0],[0,6],[1,6],[2,6],[3,6]
 
@@ -2178,7 +2510,7 @@
    movq_r2m(mm4, *dummy);
 	fprintf(stderr, "3+4 %016llx\n", dummy);
 	*/
-	
+
 
 	packuswb_r2r(mm4, mm5);			// out[0,2],[1,2],[2,2],[3,2],[0,4],[1,4],[2,4],[3,4]
 
@@ -2192,11 +2524,11 @@
 	movq_r2r(mm2, mm1);
 
 	punpcklbw_r2r(mm6, mm5);		// out[0,2],[0,3],[1,2],[1,3],[2,2],[2,3],[3,2],[3,3]
-	
+
 	punpckhbw_r2r(mm6, mm7);		// out[0,4],[0,5],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]
 
 	punpcklwd_r2r(mm5, mm2);		// out[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3]
-	
+
 	movq_r2r(mm7, mm6);
 	punpckhwd_r2r(mm5, mm1);		// out[2,0],[2,1],[2,2],[2,3],[3,0],[3,1],[3,2],[3,3]
 
@@ -2208,7 +2540,7 @@
 	movq_r2r(mm1, mm3);
 
 	punpckhwd_r2r(mm4, mm7);		// out[2,4],[2,5],[2,6],[2,7],[3,4],[3,5],[3,6],[3,7]
-	
+
 	dataptr += rskip;
 	movq_r2m(mm2, *(dataptr));
 
@@ -2218,7 +2550,7 @@
 	movq_r2m(mm0, *(dataptr));
 
 	punpckldq_r2r(mm7, mm1);		// out[2,0],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[2,7]
-	
+
 	punpckhdq_r2r(mm7, mm3);		// out[3,0],[3,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7]
 
 	dataptr += rskip;
@@ -2228,22 +2560,20 @@
 	movq_r2m(mm3, *(dataptr));
 
 #else
-
-#if 0 
-  __s32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
-  __s32 tmp10, tmp11, tmp12, tmp13;
-  __s32 z5, z10, z11, z12, z13;
-  __s16 *inptr;
-  __s32 *wsptr;
-  __u8 *outptr;
+  int32_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+  int32_t tmp10, tmp11, tmp12, tmp13;
+  int32_t z5, z10, z11, z12, z13;
+  int16_t *inptr;
+  int32_t *wsptr;
+  uint8_t *outptr;
   int ctr;
-  __s32 dcval;
-  __s32 workspace[64];
+  int32_t dcval;
+  int32_t workspace[64];
 
   inptr = data;
   wsptr = workspace;
   for (ctr = 8; ctr > 0; ctr--) {
-    
+
     if ((inptr[8] | inptr[16] | inptr[24] |
 	 inptr[32] | inptr[40] | inptr[48] | inptr[56]) == 0) {
       dcval = inptr[0];
@@ -2255,12 +2585,12 @@
       wsptr[40] = dcval;
       wsptr[48] = dcval;
       wsptr[56] = dcval;
-      
-      inptr++;	
+
+      inptr++;
       wsptr++;
       continue;
-    } 
-    
+    }
+
     tmp0 = inptr[0];
     tmp1 = inptr[16];
     tmp2 = inptr[32];
@@ -2276,7 +2606,7 @@
     tmp3 = tmp10 - tmp13;
     tmp1 = tmp11 + tmp12;
     tmp2 = tmp11 - tmp12;
-    
+
     tmp4 = inptr[8];
     tmp5 = inptr[24];
     tmp6 = inptr[40];
@@ -2298,14 +2628,14 @@
     tmp5 = tmp11 - tmp6;
     tmp4 = tmp10 + tmp5;
 
-    wsptr[0] = (__s32) (tmp0 + tmp7);
-    wsptr[56] = (__s32) (tmp0 - tmp7);
-    wsptr[8] = (__s32) (tmp1 + tmp6);
-    wsptr[48] = (__s32) (tmp1 - tmp6);
-    wsptr[16] = (__s32) (tmp2 + tmp5);
-    wsptr[40] = (__s32) (tmp2 - tmp5);
-    wsptr[32] = (__s32) (tmp3 + tmp4);
-    wsptr[24] = (__s32) (tmp3 - tmp4);
+    wsptr[0] = (int32_t) (tmp0 + tmp7);
+    wsptr[56] = (int32_t) (tmp0 - tmp7);
+    wsptr[8] = (int32_t) (tmp1 + tmp6);
+    wsptr[48] = (int32_t) (tmp1 - tmp6);
+    wsptr[16] = (int32_t) (tmp2 + tmp5);
+    wsptr[40] = (int32_t) (tmp2 - tmp5);
+    wsptr[32] = (int32_t) (tmp3 + tmp4);
+    wsptr[24] = (int32_t) (tmp3 - tmp4);
 
     inptr++;
     wsptr++;
@@ -2353,143 +2683,6 @@
 
     wsptr += 8;
   }
-#else
-#define DW1 1.387040   /* sqrt(2)*cos(1*pi/16) */
-#define DW2 1.306563   /* sqrt(2)*cos(2*pi/16) */
-#define DW3 1.175876   /* sqrt(2)*cos(3*pi/16) */
-#define DW5 0.785695   /* sqrt(2)*cos(5*pi/16) */
-#define DW6 0.541196   /* sqrt(2)*cos(6*pi/16) */
-#define DW7 0.275899   /* sqrt(2)*cos(7*pi/16) */
-
-#define IW1 2841 /* 2048*sqrt (2)*cos (1*pi/16) */
-#define IW2 2676 /* 2048*sqrt (2)*cos (2*pi/16) */
-#define IW3 2408 /* 2048*sqrt (2)*cos (3*pi/16) */
-#define IW5 1609 /* 2048*sqrt (2)*cos (5*pi/16) */
-#define IW6 1108 /* 2048*sqrt (2)*cos (6*pi/16) */
-#define IW7 565  /* 2048*sqrt (2)*cos (7*pi/16) */
-
-  /****************************************************************
-   ***************** FLOAT IMPLEMENTATION *************************
-   ****************************************************************/
-
-  int i;
-    double dblock[64];
-    double * db = dblock;
-    __s16 * b = data;
-
-    //printf("FLOAT IDCT called !\n");
-
-    for (i = 0; i < 8; i++, db += 8, b += 8) {
-	double x0, x1, x2, x3, x4, x5, x6, x7, x8, x9;
-
-	/* first stage */
-	x8 = DW7 * (b[1] + b[7]);
-	x9 = DW3 * (b[5] + b[3]);
-	x1 = DW6 * (b[2] + b[6]);
-	x4 = x8 + (DW1 - DW7) * b[1];
-	x5 = x8 - (DW1 + DW7) * b[7];
-	x6 = x9 - (DW3 - DW5) * b[5];
-	x7 = x9 - (DW3 + DW5) * b[3];
- 
-	/* second stage */
-	x8 = b[0] + b[4];
-	x0 = b[0] - b[4];
-	x2 = x1 - (DW2 + DW6) * b[6];
-	x3 = x1 + (DW2 - DW6) * b[2];
-	x1 = x4 + x6;
-	x4 = x4 - x6;
-	x6 = x5 + x7;
-	x5 = x5 - x7;
- 
-	/* third stage */
-	x7 = x8 + x3;
-	x8 = x8 - x3;
-	x3 = x0 + x2;
-	x0 = x0 - x2;
-	x2 = 0.70703125 * (x4 + x5);
-	x4 = 0.70703125 * (x4 - x5);
- 
-	/* fourth stage */
-	db[0] = (x7 + x1);
-	db[7] = (x7 - x1);
-	db[3] = (x8 + x6);
-	db[4] = (x8 - x6);
-	db[1] = (x3 + x2);
-	db[6] = (x3 - x2);
-	db[2] = (x0 + x4);
-	db[5] = (x0 - x4);
-
-	// 38 + 8 = 46
-    }
-
-    db = dblock;
-    b = data;
-
-    for (i = 0; i < 8; i++, b++, db++) {
-      double x0, x1, x2, x3, x4, x5, x6, x7, x8, x9;
-
-      /* first stage */
-      x8 = DW7 * (db[8*1] + db[8*7]);
-      x9 = DW3 * (db[8*5] + db[8*3]);
-      x1 = DW6 * (db[8*2] + db[8*6]);
-      x4 = (x8 + (DW1 - DW7) * db[8*1]);
-      x5 = (x8 - (DW1 + DW7) * db[8*7]);
-      x6 = (x9 - (DW3 - DW5) * db[8*5]);
-      x7 = (x9 - (DW3 + DW5) * db[8*3]);
- 
-      /* second stage */
-      x8 = db[8*0] + db[8*4];
-      x0 = db[8*0] - db[8*4];
-      x2 = (x1 - (DW2 + DW6) * db[8*6]);
-      x3 = (x1 + (DW2 - DW6) * db[8*2]);
-      x1 = x4 + x6;
-      x4 -= x6;
-      x6 = x5 + x7;
-      x5 -= x7;
- 
-      /* third stage */
-      x7 = x8 + x3;
-      x8 -= x3;
-      x3 = x0 + x2;
-      x0 -= x2;
-      x2 = 0.70703125 * (x4 + x5);
-      x4 = 0.70703125 * (x4 - x5);
- 
-      /* fourth stage */
-      b[8*0] = (x7 + x1) * 0.125 + 0.5;
-      b[8*1] = (x3 + x2) * 0.125 + 0.5;
-      b[8*2] = (x0 + x4) * 0.125 + 0.5;
-      b[8*3] = (x8 + x6) * 0.125 + 0.5;
-      b[8*4] = (x8 - x6) * 0.125 + 0.5;
-      b[8*5] = (x0 - x4) * 0.125 + 0.5;
-      b[8*6] = (x3 - x2) * 0.125 + 0.5;
-      b[8*7] = (x7 - x1) * 0.125 + 0.5;
-
-      // 38+16 = 54
-    }
-
-    i = 8;
-    do 
-      {
-	odata[0] = CLIP (data[0]); /* was: idata<->block, odata<->dest */
-	odata[1] = CLIP (data[1]);
-	odata[2] = CLIP (data[2]);
-	odata[3] = CLIP (data[3]);
-	odata[4] = CLIP (data[4]);
-	odata[5] = CLIP (data[5]);
-	odata[6] = CLIP (data[6]);
-	odata[7] = CLIP (data[7]);
-
-	odata += rskip; //stride;
-	data += 8;
-    } while (--i);
-
-#endif
-
-
-
-
-
 #endif
 }
 /*
@@ -2510,24 +2703,24 @@
 
 */
 
-void RTjpeg_init_data(void)
+static void RTjpeg_init_data(void)
 {
  unsigned long dptr;
- 
+
  dptr=(unsigned long)&(RTjpeg_alldata[0]);
  dptr+=32;
  dptr=dptr>>5;
  dptr=dptr<<5; /* cache align data */
- 
- RTjpeg_block=(__s16 *)dptr;
- dptr+=sizeof(__s16)*64;
- RTjpeg_lqt=(__s32 *)dptr;
- dptr+=sizeof(__s32)*64;
- RTjpeg_cqt=(__s32 *)dptr;
- dptr+=sizeof(__s32)*64;
- RTjpeg_liqt=(__u32 *)dptr;
- dptr+=sizeof(__u32)*64;
- RTjpeg_ciqt=(__u32 *)dptr;
+
+ RTjpeg_block=(int16_t *)dptr;
+ dptr+=sizeof(int16_t)*64;
+ RTjpeg_lqt=(int32_t *)dptr;
+ dptr+=sizeof(int32_t)*64;
+ RTjpeg_cqt=(int32_t *)dptr;
+ dptr+=sizeof(int32_t)*64;
+ RTjpeg_liqt=(uint32_t *)dptr;
+ dptr+=sizeof(uint32_t)*64;
+ RTjpeg_ciqt=(uint32_t *)dptr;
 }
 
 /*
@@ -2541,25 +2734,25 @@
        Q -> quality factor (192=best, 32=worst)
 */
 
-void RTjpeg_init_Q(__u8 Q)
+void RTjpeg_init_Q(uint8_t Q)
 {
  int i;
- __u64 qual;
- 
- qual=(__u64)Q<<(32-7); /* 32 bit FP, 255=2, 0=0 */
+ uint64_t qual;
+
+ qual=(uint64_t)Q<<(32-7); /* 32 bit FP, 255=2, 0=0 */
 
  for(i=0; i<64; i++)
  {
-  RTjpeg_lqt[i]=(__s32)((qual/((__u64)RTjpeg_lum_quant_tbl[i]<<16))>>3);
+  RTjpeg_lqt[i]=(int32_t)((qual/((uint64_t)RTjpeg_lum_quant_tbl[i]<<16))>>3);
   if(RTjpeg_lqt[i]==0)RTjpeg_lqt[i]=1;
-  RTjpeg_cqt[i]=(__s32)((qual/((__u64)RTjpeg_chrom_quant_tbl[i]<<16))>>3);
+  RTjpeg_cqt[i]=(int32_t)((qual/((uint64_t)RTjpeg_chrom_quant_tbl[i]<<16))>>3);
   if(RTjpeg_cqt[i]==0)RTjpeg_cqt[i]=1;
   RTjpeg_liqt[i]=(1<<16)/(RTjpeg_lqt[i]<<3);
   RTjpeg_ciqt[i]=(1<<16)/(RTjpeg_cqt[i]<<3);
   RTjpeg_lqt[i]=((1<<16)/RTjpeg_liqt[i])>>3;
   RTjpeg_cqt[i]=((1<<16)/RTjpeg_ciqt[i])>>3;
  }
- 
+
  RTjpeg_lb8=0;
  while(RTjpeg_liqt[RTjpeg_ZZ[++RTjpeg_lb8]]<=8);
  RTjpeg_lb8--;
@@ -2578,21 +2771,21 @@
 
 Initialise compression.
 
-Input: buf -> pointer to 128 ints for quant values store to pass back to 
+Input: buf -> pointer to 128 ints for quant values store to pass back to
                 init_decompress.
        width -> width of image
        height -> height of image
        Q -> quality factor (192=best, 32=worst)
-       
+
 */
 
-void RTjpeg_init_compress(__u32 *buf, int width, int height, __u8 Q)
+void RTjpeg_init_compress(uint32_t *buf, int width, int height, uint8_t Q)
 {
  int i;
- __u64 qual;
- 
+ uint64_t qual;
+
  RTjpeg_init_data();
- 
+
  RTjpeg_width=width;
  RTjpeg_height=height;
  RTjpeg_Ywidth = RTjpeg_width>>3;
@@ -2600,27 +2793,27 @@
  RTjpeg_Cwidth = RTjpeg_width>>4;
  RTjpeg_Csize= (width>>1) * height;
 
- qual=(__u64)Q<<(32-7); /* 32 bit FP, 255=2, 0=0 */
+ qual=(uint64_t)Q<<(32-7); /* 32 bit FP, 255=2, 0=0 */
 
  for(i=0; i<64; i++)
  {
-  RTjpeg_lqt[i]=(__s32)((qual/((__u64)RTjpeg_lum_quant_tbl[i]<<16))>>3);
+  RTjpeg_lqt[i]=(int32_t)((qual/((uint64_t)RTjpeg_lum_quant_tbl[i]<<16))>>3);
   if(RTjpeg_lqt[i]==0)RTjpeg_lqt[i]=1;
-  RTjpeg_cqt[i]=(__s32)((qual/((__u64)RTjpeg_chrom_quant_tbl[i]<<16))>>3);
+  RTjpeg_cqt[i]=(int32_t)((qual/((uint64_t)RTjpeg_chrom_quant_tbl[i]<<16))>>3);
   if(RTjpeg_cqt[i]==0)RTjpeg_cqt[i]=1;
   RTjpeg_liqt[i]=(1<<16)/(RTjpeg_lqt[i]<<3);
   RTjpeg_ciqt[i]=(1<<16)/(RTjpeg_cqt[i]<<3);
   RTjpeg_lqt[i]=((1<<16)/RTjpeg_liqt[i])>>3;
   RTjpeg_cqt[i]=((1<<16)/RTjpeg_ciqt[i])>>3;
  }
- 
+
  RTjpeg_lb8=0;
  while(RTjpeg_liqt[RTjpeg_ZZ[++RTjpeg_lb8]]<=8);
  RTjpeg_lb8--;
  RTjpeg_cb8=0;
  while(RTjpeg_ciqt[RTjpeg_ZZ[++RTjpeg_cb8]]<=8);
  RTjpeg_cb8--;
- 
+
  RTjpeg_dct_init();
  RTjpeg_quant_init();
 
@@ -2630,12 +2823,12 @@
   buf[64+i]=RTjpeg_ciqt[i];
 }
 
-void RTjpeg_init_decompress(__u32 *buf, int width, int height)
+void RTjpeg_init_decompress(uint32_t *buf, int width, int height)
 {
  int i;
 
  RTjpeg_init_data();
- 
+
  RTjpeg_width=width;
  RTjpeg_height=height;
  RTjpeg_Ywidth = RTjpeg_width>>3;
@@ -2661,12 +2854,12 @@
 // RTjpeg_color_init();
 }
 
-int RTjpeg_compressYUV420(__s8 *sp, unsigned char *bp)
+int RTjpeg_compressYUV420(int8_t *sp, unsigned char *bp)
 {
- __s8 * sb;
- register __s8 * bp1 = bp + (RTjpeg_width<<3);
- register __s8 * bp2 = bp + RTjpeg_Ysize;
- register __s8 * bp3 = bp2 + (RTjpeg_Csize>>1);
+ int8_t * sb;
+ register int8_t * bp1 = bp + (RTjpeg_width<<3);
+ register int8_t * bp2 = bp + RTjpeg_Ysize;
+ register int8_t * bp3 = bp2 + (RTjpeg_Csize>>1);
  register int i, j, k;
 
 #ifdef MMX
@@ -2707,7 +2900,7 @@
   bp1+=RTjpeg_width<<4;
   bp2+=RTjpeg_width<<2;
   bp3+=RTjpeg_width<<2;
-			 
+
  }
 #ifdef MMX
  emms();
@@ -2715,11 +2908,11 @@
  return (sp-sb);
 }
 
-int RTjpeg_compressYUV422(__s8 *sp, unsigned char *bp)
+int RTjpeg_compressYUV422(int8_t *sp, unsigned char *bp)
 {
- __s8 * sb;
- register __s8 * bp2 = bp + RTjpeg_Ysize;
- register __s8 * bp3 = bp2 + RTjpeg_Csize;
+ int8_t * sb;
+ register int8_t * bp2 = bp + RTjpeg_Ysize;
+ register int8_t * bp3 = bp2 + RTjpeg_Csize;
  register int i, j, k;
 
 #ifdef MMX
@@ -2751,7 +2944,7 @@
   bp+=RTjpeg_width<<3;
   bp2+=RTjpeg_width<<2;
   bp3+=RTjpeg_width<<2;
-			 
+
  }
 #ifdef MMX
  emms();
@@ -2759,15 +2952,15 @@
  return (sp-sb);
 }
 
-int RTjpeg_compress8(__s8 *sp, unsigned char *bp)
+int RTjpeg_compress8(int8_t *sp, unsigned char *bp)
 {
- __s8 * sb;
+ int8_t * sb;
  int i, j;
 
 #ifdef MMX
  emms();
 #endif
- 
+
  sb=sp;
 /* Y */
  for(i=0; i<RTjpeg_height; i+=8)
@@ -2787,10 +2980,10 @@
  return (sp-sb);
 }
 
-void RTjpeg_decompressYUV422(__s8 *sp, __u8 *bp)
+void RTjpeg_decompressYUV422(int8_t *sp, uint8_t *bp)
 {
- register __s8 * bp2 = bp + RTjpeg_Ysize;
- register __s8 * bp3 = bp2 + (RTjpeg_Csize);
+ register int8_t * bp2 = bp + RTjpeg_Ysize;
+ register int8_t * bp3 = bp2 + (RTjpeg_Csize);
  int i, j,k;
 
 #ifdef MMX
@@ -2803,28 +2996,28 @@
   for(k=0, j=0; j<RTjpeg_width; j+=16, k+=8) {
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp+j, RTjpeg_block, RTjpeg_width);
    }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp+j+8, RTjpeg_block, RTjpeg_width);
    }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_cb8, RTjpeg_ciqt);
     RTjpeg_idct(bp2+k, RTjpeg_block, RTjpeg_width>>1);
-   } 
+   }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_cb8, RTjpeg_ciqt);
     RTjpeg_idct(bp3+k, RTjpeg_block, RTjpeg_width>>1);
-   } 
+   }
   }
   bp+=RTjpeg_width<<3;
   bp2+=RTjpeg_width<<2;
@@ -2835,11 +3028,11 @@
 #endif
 }
 
-void RTjpeg_decompressYUV420(__s8 *sp, __u8 *bp)
+void RTjpeg_decompressYUV420(int8_t *sp, uint8_t *bp)
 {
- register __s8 * bp1 = bp + (RTjpeg_width<<3);
- register __s8 * bp2 = bp + RTjpeg_Ysize;
- register __s8 * bp3 = bp2 + (RTjpeg_Csize>>1);
+ register int8_t * bp1 = bp + (RTjpeg_width<<3);
+ register int8_t * bp2 = bp + RTjpeg_Ysize;
+ register int8_t * bp3 = bp2 + (RTjpeg_Csize>>1);
  int i, j,k;
 
 #ifdef MMX
@@ -2852,40 +3045,40 @@
   for(k=0, j=0; j<RTjpeg_width; j+=16, k+=8) {
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp+j, RTjpeg_block, RTjpeg_width);
    }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp+j+8, RTjpeg_block, RTjpeg_width);
    }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp1+j, RTjpeg_block, RTjpeg_width);
    }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp1+j+8, RTjpeg_block, RTjpeg_width);
    }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_cb8, RTjpeg_ciqt);
     RTjpeg_idct(bp2+k, RTjpeg_block, RTjpeg_width>>1);
-   } 
+   }
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_cb8, RTjpeg_ciqt);
     RTjpeg_idct(bp3+k, RTjpeg_block, RTjpeg_width>>1);
-   } 
+   }
   }
   bp+=RTjpeg_width<<4;
   bp1+=RTjpeg_width<<4;
@@ -2897,7 +3090,7 @@
 #endif
 }
 
-void RTjpeg_decompress8(__s8 *sp, __u8 *bp)
+void RTjpeg_decompress8(int8_t *sp, uint8_t *bp)
 {
  int i, j;
 
@@ -2911,7 +3104,7 @@
   for(j=0; j<RTjpeg_width; j+=8)
    if(*sp==-1)sp++;
    else
-   { 
+   {
     sp+=RTjpeg_s2b(RTjpeg_block, sp, RTjpeg_lb8, RTjpeg_liqt);
     RTjpeg_idct(bp+j, RTjpeg_block, RTjpeg_width);
    }
@@ -2936,7 +3129,7 @@
   tmp=(unsigned long)RTjpeg_old;
   tmp+=32;
   tmp=tmp>>5;
-  RTjpeg_old=(__s16 *)(tmp<<5);
+  RTjpeg_old=(int16_t *)(tmp<<5);
  }
  if (!RTjpeg_old)
  {
@@ -2948,18 +3141,18 @@
 
 #ifdef MMX
 
-int RTjpeg_bcomp(__s16 *old, mmx_t *mask)
+static int RTjpeg_bcomp(int16_t *old, mmx_t *mask)
 {
  int i;
  mmx_t *mold=(mmx_t *)old;
  mmx_t *mblock=(mmx_t *)RTjpeg_block;
- mmx_t result;
+ volatile mmx_t result;
  static mmx_t neg=(mmx_t)(unsigned long long)0xffffffffffffffffULL;
- 
+
  movq_m2r(*mask, mm7);
  movq_m2r(neg, mm6);
  pxor_r2r(mm5, mm5);
- 
+
  for(i=0; i<8; i++)
  {
   movq_m2r(*(mblock++), mm0);
@@ -2982,19 +3175,18 @@
   			por_r2r(mm3, mm5);
  }
  movq_r2m(mm5, result);
- 
+
  if(result.q)
  {
-  if(!RTjpeg_mtest)
-   for(i=0; i<16; i++)((__u64 *)old)[i]=((__u64 *)RTjpeg_block)[i];
+//  if(!RTjpeg_mtest)
+//   for(i=0; i<16; i++)((uint64_t *)old)[i]=((uint64_t *)RTjpeg_block)[i];
   return 0;
  }
-// printf(".");
  return 1;
 }
 
 #else
-int RTjpeg_bcomp(__s16 *old, __u16 *mask)
+static int RTjpeg_bcomp(int16_t *old, uint16_t *mask)
 {
  int i;
 
@@ -3002,7 +3194,7 @@
   if(abs(old[i]-RTjpeg_block[i])>*mask)
   {
    if(!RTjpeg_mtest)
-    for(i=0; i<16; i++)((__u64 *)old)[i]=((__u64 *)RTjpeg_block)[i];
+    for(i=0; i<16; i++)((uint64_t *)old)[i]=((uint64_t *)RTjpeg_block)[i];
    return 0;
   }
  return 1;
@@ -3014,24 +3206,24 @@
  RTjpeg_mtest=i;
 }
 
-int RTjpeg_mcompressYUV420(__s8 *sp, unsigned char *bp, __u16 lmask, __u16 cmask)
+int RTjpeg_mcompressYUV420(int8_t *sp, unsigned char *bp, uint16_t lmask, uint16_t cmask)
 {
- __s8 * sb;
- __s16 *block;
- register __s8 * bp1 = bp + (RTjpeg_width<<3);
- register __s8 * bp2 = bp + RTjpeg_Ysize;
- register __s8 * bp3 = bp2 + (RTjpeg_Csize>>1);
+ int8_t * sb;
+//rh int16_t *block;
+ register int8_t * bp1 = bp + (RTjpeg_width<<3);
+ register int8_t * bp2 = bp + RTjpeg_Ysize;
+ register int8_t * bp3 = bp2 + (RTjpeg_Csize>>1);
  register int i, j, k;
 
 #ifdef MMX
  emms();
- RTjpeg_lmask=(mmx_t)(((__u64)lmask<<48)|((__u64)lmask<<32)|((__u64)lmask<<16)|lmask);
- RTjpeg_cmask=(mmx_t)(((__u64)cmask<<48)|((__u64)cmask<<32)|((__u64)cmask<<16)|cmask);
+ RTjpeg_lmask=(mmx_t)(((uint64_t)lmask<<48)|((uint64_t)lmask<<32)|((uint64_t)lmask<<16)|lmask);
+ RTjpeg_cmask=(mmx_t)(((uint64_t)cmask<<48)|((uint64_t)cmask<<32)|((uint64_t)cmask<<16)|cmask);
 #else
  RTjpeg_lmask=lmask;
  RTjpeg_cmask=cmask;
 #endif
- 
+
  sb=sp;
  block=RTjpeg_old;
 /* Y */
@@ -3043,8 +3235,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
 
@@ -3052,8 +3244,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
 
@@ -3061,8 +3253,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
 
@@ -3070,8 +3262,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
 
@@ -3079,8 +3271,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_cqt);
    if(RTjpeg_bcomp(block, &RTjpeg_cmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_cb8);
    block+=64;
 
@@ -3088,8 +3280,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_cqt);
    if(RTjpeg_bcomp(block, &RTjpeg_cmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_cb8);
    block+=64;
   }
@@ -3097,7 +3289,7 @@
   bp1+=RTjpeg_width<<4;
   bp2+=RTjpeg_width<<2;
   bp3+=RTjpeg_width<<2;
-			 
+
  }
 #ifdef MMX
  emms();
@@ -3106,23 +3298,23 @@
 }
 
 
-int RTjpeg_mcompressYUV422(__s8 *sp, unsigned char *bp, __u16 lmask, __u16 cmask)
+int RTjpeg_mcompressYUV422(int8_t *sp, unsigned char *bp, uint16_t lmask, uint16_t cmask)
 {
- __s8 * sb;
- __s16 *block;
- register __s8 * bp2;
- register __s8 * bp3;
+ int8_t * sb;
+ int16_t *block;
+ register int8_t * bp2;
+ register int8_t * bp3;
  register int i, j, k;
 
 #ifdef MMX
  emms();
- RTjpeg_lmask=(mmx_t)(((__u64)lmask<<48)|((__u64)lmask<<32)|((__u64)lmask<<16)|lmask);
- RTjpeg_cmask=(mmx_t)(((__u64)cmask<<48)|((__u64)cmask<<32)|((__u64)cmask<<16)|cmask);
+ RTjpeg_lmask=(mmx_t)(((uint64_t)lmask<<48)|((uint64_t)lmask<<32)|((uint64_t)lmask<<16)|lmask);
+ RTjpeg_cmask=(mmx_t)(((uint64_t)cmask<<48)|((uint64_t)cmask<<32)|((uint64_t)cmask<<16)|cmask);
 #else
  RTjpeg_lmask=lmask;
  RTjpeg_cmask=cmask;
 #endif
- 
+
  bp = bp - RTjpeg_width*0;
  bp2 = bp + RTjpeg_Ysize-RTjpeg_width*0;
  bp3 = bp2 + RTjpeg_Csize;
@@ -3138,8 +3330,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
 
@@ -3147,8 +3339,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
 
@@ -3156,8 +3348,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_cqt);
    if(RTjpeg_bcomp(block, &RTjpeg_cmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_cb8);
    block+=64;
 
@@ -3165,8 +3357,8 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_cqt);
    if(RTjpeg_bcomp(block, &RTjpeg_cmask))
    {
-    *((__u8 *)sp++)=255;
-   } 
+    *((uint8_t *)sp++)=255;
+   }
 	else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_cb8);
    block+=64;
 
@@ -3175,27 +3367,26 @@
   bp2+=RTjpeg_width<<2;
   bp3+=RTjpeg_width<<2;
  }
- printf ("%d\n", block - RTjpeg_old);
 #ifdef MMX
  emms();
 #endif
  return (sp-sb);
 }
 
-int RTjpeg_mcompress8(__s8 *sp, unsigned char *bp, __u16 lmask)
+int RTjpeg_mcompress8(int8_t *sp, unsigned char *bp, uint16_t lmask)
 {
- __s8 * sb;
- __s16 *block;
+ int8_t * sb;
+ int16_t *block;
  int i, j;
 
 #ifdef MMX
  emms();
- RTjpeg_lmask=(mmx_t)(((__u64)lmask<<48)|((__u64)lmask<<32)|((__u64)lmask<<16)|lmask);
+ RTjpeg_lmask=(mmx_t)(((uint64_t)lmask<<48)|((uint64_t)lmask<<32)|((uint64_t)lmask<<16)|lmask);
 #else
  RTjpeg_lmask=lmask;
 #endif
 
- 
+
  sb=sp;
  block=RTjpeg_old;
 /* Y */
@@ -3207,8 +3398,7 @@
    RTjpeg_quant(RTjpeg_block, RTjpeg_lqt);
    if(RTjpeg_bcomp(block, &RTjpeg_lmask))
    {
-    *((__u8 *)sp++)=255;
-//    printf("* %d ", sp[-1]);
+    *((uint8_t *)sp++)=255;
    } else sp+=RTjpeg_b2s(RTjpeg_block, sp, RTjpeg_lb8);
    block+=64;
   }
@@ -3220,9 +3410,11 @@
  return (sp-sb);
 }
 
-void RTjpeg_color_init(void)
+#if 0  /* unused --AC */
+static void RTjpeg_color_init(void)
 {
-}  
+}
+#endif
 
 #define KcrR 76284
 #define KcrG 53281
@@ -3230,21 +3422,21 @@
 #define KcbB 132252
 #define Ky 76284
 
-void RTjpeg_yuv422rgb(__u8 *buf, __u8 *rgb, int stride)
+void RTjpeg_yuv422rgb(uint8_t *buf, uint8_t *rgb, int stride)
 {
  int tmp;
  int i, j;
- __s32 y, crR, crG, cbG, cbB;
- __u8 *bufcr, *bufcb, *bufy, *bufoute;
+ int32_t y, crR, crG, cbG, cbB;
+ uint8_t *bufcr, *bufcb, *bufy, *bufoute;
  int yskip;
- 
+
  yskip=RTjpeg_width;
- 
+
  bufcb=&buf[RTjpeg_width*RTjpeg_height];
  bufcr=&buf[RTjpeg_width*RTjpeg_height+(RTjpeg_width*RTjpeg_height)/2];
  bufy=&buf[0];
  bufoute=rgb;
- 
+
  for(i=0; i<(RTjpeg_height); i++)
  {
   for(j=0; j<RTjpeg_width; j+=2)
@@ -3253,9 +3445,9 @@
    crG=(*(bufcr++)-128)*KcrG;
    cbG=(*bufcb-128)*KcbG;
    cbB=(*(bufcb++)-128)*KcbB;
-  
+
    y=(bufy[j]-16)*Ky;
-   
+
    tmp=(y+crR)>>16;
    *(bufoute++)=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y-crG-cbG)>>16;
@@ -3278,27 +3470,27 @@
 }
 
 
-void RTjpeg_yuv420rgb(__u8 *buf, __u8 *rgb, int stride)
+void RTjpeg_yuv420rgb(uint8_t *buf, uint8_t *rgb, int stride)
 {
  int tmp;
  int i, j;
- __s32 y, crR, crG, cbG, cbB;
- __u8 *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
+ int32_t y, crR, crG, cbG, cbB;
+ uint8_t *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
  int oskip, yskip;
- 
+
  if(stride==0)
  	oskip=RTjpeg_width*3;
  else
  	oskip=2*stride-RTjpeg_width*3;
- 
+
  yskip=RTjpeg_width;
- 
+
  bufcb=&buf[RTjpeg_width*RTjpeg_height];
  bufcr=&buf[RTjpeg_width*RTjpeg_height+(RTjpeg_width*RTjpeg_height)/4];
  bufy=&buf[0];
  bufoute=rgb;
  bufouto=rgb+RTjpeg_width*3;
- 
+
  for(i=0; i<(RTjpeg_height>>1); i++)
  {
   for(j=0; j<RTjpeg_width; j+=2)
@@ -3307,9 +3499,9 @@
    crG=(*(bufcr++)-128)*KcrG;
    cbG=(*bufcb-128)*KcbG;
    cbB=(*(bufcb++)-128)*KcbB;
-  
+
    y=(bufy[j]-16)*Ky;
-   
+
    tmp=(y+crR)>>16;
    *(bufoute++)=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y-crG-cbG)>>16;
@@ -3343,7 +3535,7 @@
    *(bufouto++)=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y+cbB)>>16;
    *(bufouto++)=(tmp>255)?255:((tmp<0)?0:tmp);
-   
+
   }
   bufoute+=oskip;
   bufouto+=oskip;
@@ -3352,26 +3544,26 @@
 }
 
 
-void RTjpeg_yuvrgb32(__u8 *buf, __u8 *rgb, int stride)
+void RTjpeg_yuvrgb32(uint8_t *buf, uint8_t *rgb, int stride)
 {
  int tmp;
  int i, j;
- __s32 y, crR, crG, cbG, cbB;
- __u8 *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
+ int32_t y, crR, crG, cbG, cbB;
+ uint8_t *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
  int oskip, yskip;
- 
+
  if(stride==0)
  	oskip=RTjpeg_width*4;
  else
  	oskip = 2*stride-RTjpeg_width*4;
  yskip=RTjpeg_width;
- 
+
  bufcb=&buf[RTjpeg_width*RTjpeg_height];
  bufcr=&buf[RTjpeg_width*RTjpeg_height+(RTjpeg_width*RTjpeg_height)/2];
  bufy=&buf[0];
  bufoute=rgb;
  bufouto=rgb+RTjpeg_width*4;
- 
+
  for(i=0; i<(RTjpeg_height>>1); i++)
  {
   for(j=0; j<RTjpeg_width; j+=2)
@@ -3380,9 +3572,9 @@
    crG=(*(bufcr++)-128)*KcrG;
    cbG=(*bufcb-128)*KcbG;
    cbB=(*(bufcb++)-128)*KcbB;
-  
+
    y=(bufy[j]-16)*Ky;
-   
+
    tmp=(y+cbB)>>16;
    *(bufoute++)=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y-crG-cbG)>>16;
@@ -3420,7 +3612,7 @@
    tmp=(y+crR)>>16;
    *(bufouto++)=(tmp>255)?255:((tmp<0)?0:tmp);
    bufouto++;
-   
+
   }
   bufoute+=oskip;
   bufouto+=oskip;
@@ -3428,27 +3620,27 @@
  }
 }
 
-void RTjpeg_yuvrgb24(__u8 *buf, __u8 *rgb, int stride)
+void RTjpeg_yuvrgb24(uint8_t *buf, uint8_t *rgb, int stride)
 {
  int tmp;
  int i, j;
- __s32 y, crR, crG, cbG, cbB;
- __u8 *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
+ int32_t y, crR, crG, cbG, cbB;
+ uint8_t *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
  int oskip, yskip;
- 
+
  if(stride==0)
  	oskip=RTjpeg_width*3;
  else
  	oskip=2*stride - RTjpeg_width*3;
- 	
+
  yskip=RTjpeg_width;
- 
+
  bufcb=&buf[RTjpeg_width*RTjpeg_height];
  bufcr=&buf[RTjpeg_width*RTjpeg_height+(RTjpeg_width*RTjpeg_height)/4];
  bufy=&buf[0];
  bufoute=rgb;
  bufouto=rgb+RTjpeg_width*3;
- 
+
  for(i=0; i<(RTjpeg_height>>1); i++)
  {
   for(j=0; j<RTjpeg_width; j+=2)
@@ -3457,9 +3649,9 @@
    crG=(*(bufcr++)-128)*KcrG;
    cbG=(*bufcb-128)*KcbG;
    cbB=(*(bufcb++)-128)*KcbB;
-  
+
    y=(bufy[j]-16)*Ky;
-   
+
    tmp=(y+cbB)>>16;
    *(bufoute++)=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y-crG-cbG)>>16;
@@ -3493,7 +3685,7 @@
    *(bufouto++)=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y+crR)>>16;
    *(bufouto++)=(tmp>255)?255:((tmp<0)?0:tmp);
-   
+
   }
   bufoute+=oskip;
   bufouto+=oskip;
@@ -3501,28 +3693,28 @@
  }
 }
 
-void RTjpeg_yuvrgb16(__u8 *buf, __u8 *rgb, int stride)
+void RTjpeg_yuvrgb16(uint8_t *buf, uint8_t *rgb, int stride)
 {
  int tmp;
  int i, j;
- __s32 y, crR, crG, cbG, cbB;
- __u8 *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
+ int32_t y, crR, crG, cbG, cbB;
+ uint8_t *bufcr, *bufcb, *bufy, *bufoute, *bufouto;
  int oskip, yskip;
  unsigned char r, g, b;
- 
+
  if(stride==0)
  	oskip=RTjpeg_width*2;
  else
  	oskip=2*stride-RTjpeg_width*2;
- 	
+
  yskip=RTjpeg_width;
- 
+
  bufcb=&buf[RTjpeg_width*RTjpeg_height];
  bufcr=&buf[RTjpeg_width*RTjpeg_height+(RTjpeg_width*RTjpeg_height)/4];
  bufy=&buf[0];
  bufoute=rgb;
  bufouto=rgb+RTjpeg_width*2;
- 
+
  for(i=0; i<(RTjpeg_height>>1); i++)
  {
   for(j=0; j<RTjpeg_width; j+=2)
@@ -3531,9 +3723,9 @@
    crG=(*(bufcr++)-128)*KcrG;
    cbG=(*bufcb-128)*KcbG;
    cbB=(*(bufcb++)-128)*KcbB;
-  
+
    y=(bufy[j]-16)*Ky;
-   
+
    tmp=(y+cbB)>>16;
    b=(tmp>255)?255:((tmp<0)?0:tmp);
    tmp=(y-crG-cbG)>>16;
@@ -3545,7 +3737,7 @@
    tmp|=(int)(((int)r >> 3) << 11);
    *(bufoute++)=tmp&0xff;
    *(bufoute++)=tmp>>8;
-   
+
 
    y=(bufy[j+1]-16)*Ky;
 
@@ -3598,7 +3790,7 @@
 
 /* fix stride */
 
-void RTjpeg_yuvrgb8(__u8 *buf, __u8 *rgb, int stride)
+void RTjpeg_yuvrgb8(uint8_t *buf, uint8_t *rgb, int stride)
 {
  bcopy(buf, rgb, RTjpeg_width*RTjpeg_height);
 }
diff -Nur libmovtar-0.1.3-old/rtjpeg/RTjpeg.h libmovtar-0.1.3/rtjpeg/RTjpeg.h
--- libmovtar-0.1.3-old/rtjpeg/RTjpeg.h	2008-04-04 16:55:08.000000000 +0300
+++ libmovtar-0.1.3/rtjpeg/RTjpeg.h	2008-01-19 12:44:14.000000000 +0200
@@ -1,6 +1,6 @@
-/* 
+/*
    RTjpeg (C) Justin Schoeman 1998 (justin@suntiger.ee.up.ac.za)
-   
+
    With modifications by:
    (c) 1998, 1999 by Joerg Walter <trouble@moes.pmnet.uni-oldenburg.de>
    and
@@ -19,44 +19,36 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-    
-*/
 
-#ifndef __RTjpeg_h__
-#define __RTjpeg_h__
+*/
 
-#ifndef _I386_TYPES_H
-typedef unsigned char __u8;
-typedef unsigned short __u16;
-typedef unsigned long __u32;
-typedef unsigned long long __u64;
-typedef signed char __s8;
-typedef signed short __s16;
-typedef signed long __s32;
+#ifdef HAVE_CONFIG_H
+# include "config.h"
 #endif
 
-extern void RTjpeg_init_Q(__u8 Q);
-extern void RTjpeg_init_compress(long unsigned int *buf, int width, int height, __u8 Q);
-extern void RTjpeg_init_decompress(long unsigned int *buf, int width, int height);
-extern int RTjpeg_compressYUV420(__s8 *sp, unsigned char *bp);
-extern int RTjpeg_compressYUV422(__s8 *sp, unsigned char *bp);
-extern void RTjpeg_decompressYUV420(__s8 *sp, __u8 *bp);
-extern void RTjpeg_decompressYUV422(__s8 *sp, __u8 *bp);
-extern int RTjpeg_compress8(__s8 *sp, unsigned char *bp);
-extern void RTjpeg_decompress8(__s8 *sp, __u8 *bp);
+#include <stdint.h>
+
+extern void RTjpeg_init_Q(uint8_t Q);
+extern void RTjpeg_init_compress(uint32_t *buf, int width, int height, uint8_t Q);
+extern void RTjpeg_init_decompress(uint32_t *buf, int width, int height);
+extern int RTjpeg_compressYUV420(int8_t *sp, unsigned char *bp);
+extern int RTjpeg_compressYUV422(int8_t *sp, unsigned char *bp);
+extern void RTjpeg_decompressYUV420(int8_t *sp, uint8_t *bp);
+extern void RTjpeg_decompressYUV422(int8_t *sp, uint8_t *bp);
+extern int RTjpeg_compress8(int8_t *sp, unsigned char *bp);
+extern void RTjpeg_decompress8(int8_t *sp, uint8_t *bp);
 
 extern void RTjpeg_init_mcompress(void);
-extern int RTjpeg_mcompressYUV420(__s8 *sp, unsigned char *bp, __u16 lmask, __u16 cmask);
-extern int RTjpeg_mcompressYUV422(__s8 *sp, unsigned char *bp, __u16 lmask, __u16 cmask);
-extern int RTjpeg_mcompress8(__s8 *sp, unsigned char *bp, __u16 lmask);
+extern int RTjpeg_mcompressYUV420(int8_t *sp, unsigned char *bp, uint16_t lmask, uint16_t cmask);
+extern int RTjpeg_mcompressYUV422(int8_t *sp, unsigned char *bp, uint16_t lmask, uint16_t cmask);
+extern int RTjpeg_mcompress8(int8_t *sp, unsigned char *bp, uint16_t lmask);
 extern void RTjpeg_set_test(int i);
 
-extern void RTjpeg_yuv420rgb(__u8 *buf, __u8 *rgb, int stride);
-extern void RTjpeg_yuv422rgb(__u8 *buf, __u8 *rgb, int stride);
-extern void RTjpeg_yuvrgb8(__u8 *buf, __u8 *rgb, int stride);
-extern void RTjpeg_yuvrgb16(__u8 *buf, __u8 *rgb, int stride);
-extern void RTjpeg_yuvrgb24(__u8 *buf, __u8 *rgb, int stride);
-extern void RTjpeg_yuvrgb32(__u8 *buf, __u8 *rgb, int stride);
-		  
+extern void RTjpeg_yuv420rgb(uint8_t *buf, uint8_t *rgb, int stride);
+extern void RTjpeg_yuv422rgb(uint8_t *buf, uint8_t *rgb, int stride);
+extern void RTjpeg_yuvrgb8(uint8_t *buf, uint8_t *rgb, int stride);
+extern void RTjpeg_yuvrgb16(uint8_t *buf, uint8_t *rgb, int stride);
+extern void RTjpeg_yuvrgb24(uint8_t *buf, uint8_t *rgb, int stride);
+extern void RTjpeg_yuvrgb32(uint8_t *buf, uint8_t *rgb, int stride);
+
 
-#endif /* __RTjpeg_h__ */
