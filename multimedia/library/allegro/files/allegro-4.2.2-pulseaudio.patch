diff -up allegro-4.2.2/src/unix/alsa9.c.pulse allegro-4.2.2/src/unix/alsa9.c
--- allegro-4.2.2/src/unix/alsa9.c.pulse	2006-03-18 16:05:34.000000000 +0100
+++ allegro-4.2.2/src/unix/alsa9.c	2008-01-21 20:01:18.000000000 +0100
@@ -81,7 +81,7 @@ static double alsa_mixer_allegro_ratio =
 
 static snd_pcm_t *pcm_handle;
 static unsigned char *alsa_bufdata;
-static int alsa_bits, alsa_signed, alsa_stereo;
+static int alsa_bits, alsa_signed, alsa_stereo, alsa_format;
 static unsigned int alsa_rate;
 static unsigned int alsa_fragments;
 static int alsa_sample_size;
@@ -292,7 +292,6 @@ static int alsa_init(int input, int voic
 {
    int ret = 0;
    char tmp1[128], tmp2[128];
-   int format = 0;
    unsigned int numfrags = 0;
    snd_pcm_uframes_t fragsize;
 
@@ -354,29 +353,14 @@ static int alsa_init(int input, int voic
    alsa_stereo = (_sound_stereo) ? 1 : 0;
    alsa_rate = (_sound_freq > 0) ? _sound_freq : 44100;
    alsa_signed = 0;
+   alsa_format = (alsa_bits == 16) ? SND_PCM_FORMAT_U16_NE : SND_PCM_FORMAT_U8;
+   alsa_sample_size = (alsa_bits / 8) * (alsa_stereo ? 2 : 1);
 
-   format = ((alsa_bits == 16) ? SND_PCM_FORMAT_U16_NE : SND_PCM_FORMAT_U8);
-
-   switch (format) {
-
-      case SND_PCM_FORMAT_U8:
-	 alsa_bits = 8;
-	 break;
-
-      case SND_PCM_FORMAT_U16_NE:
-	 if (sizeof(short) != 2) {
-	    ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unsupported sample format"));
-	    goto Error;
-	 }
-	 break;
-
-      default:
-	 ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unsupported sample format"));
-	 goto Error;
+   if (alsa_format == SND_PCM_FORMAT_U16_NE && sizeof(short) != 2) {
+      ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unsupported sample format"));
+      goto Error;
    }
 
-   alsa_sample_size = (alsa_bits / 8) * (alsa_stereo ? 2 : 1);
-
    if (fragsize == 0) {
       unsigned int size = alsa_rate * ALSA_DEFAULT_BUFFER_MS / 1000 / numfrags;
       fragsize = 1;
@@ -389,7 +373,12 @@ static int alsa_init(int input, int voic
 
    ALSA9_CHECK(snd_pcm_hw_params_any(pcm_handle, hwparams));
    ALSA9_CHECK(snd_pcm_hw_params_set_access(pcm_handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED));
-   ALSA9_CHECK(snd_pcm_hw_params_set_format(pcm_handle, hwparams, format));
+   if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, alsa_format) < 0) {
+      /* Try again with signed samples (needed atleast for pulseaudio) */
+      alsa_format = (alsa_bits == 16) ? SND_PCM_FORMAT_S16_NE : SND_PCM_FORMAT_S8;
+      alsa_signed = 1;
+      ALSA9_CHECK(snd_pcm_hw_params_set_format(pcm_handle, hwparams, alsa_format));
+   }
    ALSA9_CHECK(snd_pcm_hw_params_set_channels(pcm_handle, hwparams, alsa_stereo + 1));
 
    ALSA9_CHECK(snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &alsa_rate, NULL));
