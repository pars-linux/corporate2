diff -r 8fe44c79dfd1 -r 0c159bd1d600 .hgtags
--- a/.hgtags	Tue Oct 26 19:49:55 2010 -0700
+++ b/.hgtags	Thu Dec 02 20:33:03 2010 -0500
@@ -42,11 +42,10 @@
 3596945fe21ef9974367519ec72d872e4435041f FENNEC_1_0_BUILD1
 3596945fe21ef9974367519ec72d872e4435041f FENNEC_1_0_RELEASE
 f029575f82e4303241c14630c80a8fc05a997ac7 UPDATE_PACKAGING_R11
-dae5f89c4a2274c1a6346b61c360d6a4a10dbcbc FIREFOX_3_6_11_BUILD1
-dae5f89c4a2274c1a6346b61c360d6a4a10dbcbc FIREFOX_3_6_11_RELEASE
-053f07027a388956453f296f40ae44e9656637a7 FIREFOX_3_6_11_BUILD2
-dae5f89c4a2274c1a6346b61c360d6a4a10dbcbc FIREFOX_3_6_11_RELEASE
-053f07027a388956453f296f40ae44e9656637a7 FIREFOX_3_6_11_RELEASE
-2cfbdde7750842780becbf46101be9927f919370 FIREFOX_3_6_11_BUILD3
-053f07027a388956453f296f40ae44e9656637a7 FIREFOX_3_6_11_RELEASE
-2cfbdde7750842780becbf46101be9927f919370 FIREFOX_3_6_11_RELEASE
+af7a49ca89b2e5f34cbc774c6249f08a20a58ad5 FIREFOX_3_6_13_RELEASE
+af7a49ca89b2e5f34cbc774c6249f08a20a58ad5 FIREFOX_3_6_13_BUILD1
+af7a49ca89b2e5f34cbc774c6249f08a20a58ad5 THUNDERBIRD_3_1_7_BUILD1
+af7a49ca89b2e5f34cbc774c6249f08a20a58ad5 THUNDERBIRD_3_1_7_RELEASE
+af7a49ca89b2e5f34cbc774c6249f08a20a58ad5 FIREFOX_3_6_13_RELEASE
+426f09f86038b5ba6de15cf4933b54d61fb432ec FIREFOX_3_6_13_RELEASE
+426f09f86038b5ba6de15cf4933b54d61fb432ec FIREFOX_3_6_13_BUILD2
diff -r 8fe44c79dfd1 -r 0c159bd1d600 Makefile.in
--- a/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -179,7 +179,7 @@
 EXTRA_BUILDID := -$(MOZ_SYMBOLS_EXTRA_BUILDID)
 endif
 
-SYMBOL_INDEX_NAME = \
+export SYMBOL_INDEX_NAME = \
   $(MOZ_APP_NAME)-$(MOZ_APP_VERSION)-$(OS_ARCH)-$(BUILDID)$(EXTRA_BUILDID)-symbols.txt
 
 buildsymbols:
diff -r 8fe44c79dfd1 -r 0c159bd1d600 browser/components/nsBrowserContentHandler.js
--- a/browser/components/nsBrowserContentHandler.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/browser/components/nsBrowserContentHandler.js	Thu Dec 02 20:33:03 2010 -0500
@@ -817,8 +817,7 @@
     }
   },
 
-  // XXX localize me... how?
-  helpInfo : "Usage: firefox [-flags] [<url>]\n",
+  helpInfo : "",
 
   /* nsIFactory */
   createInstance: function dch_CI(outer, iid) {
diff -r 8fe44c79dfd1 -r 0c159bd1d600 browser/components/privatebrowsing/src/nsPrivateBrowsingService.js
--- a/browser/components/privatebrowsing/src/nsPrivateBrowsingService.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/browser/components/privatebrowsing/src/nsPrivateBrowsingService.js	Thu Dec 02 20:33:03 2010 -0500
@@ -88,6 +88,9 @@
   this._obs.addObserver(this, "private-browsing", true);
   this._obs.addObserver(this, "command-line-startup", true);
   this._obs.addObserver(this, "sessionstore-browser-state-restored", true);
+
+  // List of nsIXULWindows we are going to be closing during the transition
+  this._windowsToClose = [];
 }
 
 PrivateBrowsingService.prototype = {
@@ -130,9 +133,6 @@
   // List of view source window URIs for restoring later
   _viewSrcURLs: [],
 
-  // List of nsIXULWindows we are going to be closing during the transition
-  _windowsToClose: [],
-
   // XPCOM registration
   classDescription: "PrivateBrowsing Service",
   contractID: "@mozilla.org/privatebrowsing;1",
diff -r 8fe44c79dfd1 -r 0c159bd1d600 browser/config/version.txt
--- a/browser/config/version.txt	Tue Oct 26 19:49:55 2010 -0700
+++ b/browser/config/version.txt	Thu Dec 02 20:33:03 2010 -0500
@@ -1,1 +1,1 @@
-3.6.12
+3.6.13
diff -r 8fe44c79dfd1 -r 0c159bd1d600 browser/locales/en-US/chrome/browser-region/region.properties
--- a/browser/locales/en-US/chrome/browser-region/region.properties	Tue Oct 26 19:49:55 2010 -0700
+++ b/browser/locales/en-US/chrome/browser-region/region.properties	Thu Dec 02 20:33:03 2010 -0500
@@ -7,12 +7,10 @@
 
 # This is the default set of web based feed handlers shown in the reader
 # selection UI
-browser.contentHandlers.types.0.title=Bloglines
-browser.contentHandlers.types.0.uri=http://www.bloglines.com/login?r=/sub/%s
+browser.contentHandlers.types.0.title=Google
+browser.contentHandlers.types.0.uri=http://fusion.google.com/add?feedurl=%s
 browser.contentHandlers.types.1.title=My Yahoo
 browser.contentHandlers.types.1.uri=http://add.my.yahoo.com/rss?url=%s
-browser.contentHandlers.types.2.title=Google
-browser.contentHandlers.types.2.uri=http://fusion.google.com/add?feedurl=%s
 
 # Keyword URL (for location bar searches)
 keyword.URL=http://www.google.com/search?ie=UTF-8&oe=UTF-8&sourceid=navclient&gfns=1&q=
diff -r 8fe44c79dfd1 -r 0c159bd1d600 caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/caps/src/nsScriptSecurityManager.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -794,13 +794,13 @@
     {
         nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
         nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
-        const nsIID* objIID;
+        const nsIID* objIID = nsnull;
         rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
-        if (NS_SUCCEEDED(rv))
+        if (NS_SUCCEEDED(rv) && wrapper)
             rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
-        if (NS_SUCCEEDED(rv))
+        if (NS_SUCCEEDED(rv) && interfaceInfo)
             rv = interfaceInfo->GetIIDShared(&objIID);
-        if (NS_SUCCEEDED(rv))
+        if (NS_SUCCEEDED(rv) && objIID)
         {
             switch (aAction)
             {
diff -r 8fe44c79dfd1 -r 0c159bd1d600 config/autoconf.mk.in
--- a/config/autoconf.mk.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/config/autoconf.mk.in	Thu Dec 02 20:33:03 2010 -0500
@@ -466,6 +466,8 @@
 
 QCMS_LIBS	= @QCMS_LIBS@
 
+MOZ_OTS_LIBS = @MOZ_OTS_LIBS@
+
 MOZ_NATIVE_SQLITE = @MOZ_NATIVE_SQLITE@
 SQLITE_CFLAGS     = @SQLITE_CFLAGS@
 SQLITE_LIBS       = @SQLITE_LIBS@
diff -r 8fe44c79dfd1 -r 0c159bd1d600 config/milestone.txt
--- a/config/milestone.txt	Tue Oct 26 19:49:55 2010 -0700
+++ b/config/milestone.txt	Thu Dec 02 20:33:03 2010 -0500
@@ -10,4 +10,4 @@
 # hardcoded milestones in the tree from these two files.
 #--------------------------------------------------------
 
-1.9.2.12
+1.9.2.13
diff -r 8fe44c79dfd1 -r 0c159bd1d600 configure.in
--- a/configure.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/configure.in	Thu Dec 02 20:33:03 2010 -0500
@@ -7993,6 +7993,12 @@
 AC_SUBST(QCMS_LIBS)
 
 dnl ========================================================
+dnl OTS
+dnl ========================================================
+MOZ_OTS_LIBS='$(DEPTH)/gfx/ots/src/$(LIB_PREFIX)mozots.$(LIB_SUFFIX)'
+AC_SUBST(MOZ_OTS_LIBS)
+
+dnl ========================================================
 dnl disable xul
 dnl ========================================================
 MOZ_ARG_DISABLE_BOOL(xul,
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/public/Makefile.in
--- a/content/base/public/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/public/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -57,6 +57,7 @@
 nsIDocument.h \
 nsIDocumentObserver.h \
 nsIMutationObserver.h \
+nsIMutationObserver2.h \
 nsINameSpaceManager.h \
 nsINode.h \
 nsINodeInfo.h \
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/public/nsIMutationObserver2.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/public/nsIMutationObserver2.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * Mounir Lamouri <mounir.lamouri@mozilla.com> (Original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsIMutationObserver2_h___
+#define nsIMutationObserver2_h___
+
+#include "nsIMutationObserver.h"
+
+class nsIContent;
+class nsINode;
+
+#define NS_IMUTATION_OBSERVER_2_IID \
+{0x61ac1cfd, 0xf3ef, 0x4408, \
+  {0x8a, 0x72, 0xee, 0xf0, 0x41, 0xbe, 0xc7, 0xe9 } }
+
+/**
+ * Mutation observer interface 2 is adding AttributeChildRemoved to
+ * nsIMutationObserver.
+ *
+ * @see nsIMutationObserver.
+ */
+class nsIMutationObserver2 : public nsIMutationObserver
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMUTATION_OBSERVER_2_IID)
+
+  /**
+   * Notification that an attribute's child has been removed.
+   *
+   * @param aContainer The attribute that had its child removed.
+   * @param aChild     The child that was removed.
+   *
+   * @note Attributes can't have more than one child so it will be always the
+   *       first one being removed.
+   */
+  virtual void AttributeChildRemoved(nsINode* aAttribute,
+                                     nsIContent* aChild) = 0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsIMutationObserver2, NS_IMUTATION_OBSERVER_2_IID)
+
+#define NS_DECL_NSIMUTATIONOBSERVER2_ATTRIBUTECHILDREMOVED                \
+    virtual void AttributeChildRemoved(nsINode* aAttribute,               \
+                                       nsIContent* aChild);
+
+#define NS_DECL_NSIMUTATIONOBSERVER2                                      \
+    NS_DECL_NSIMUTATIONOBSERVER                                           \
+    NS_DECL_NSIMUTATIONOBSERVER2_ATTRIBUTECHILDREMOVED
+
+#define NS_IMPL_NSIMUTATIONOBSERVER2_CONTENT(_class)                      \
+NS_IMPL_NSIMUTATIONOBSERVER_CONTENT(_class)                               \
+void                                                                      \
+_class::AttributeChildRemoved(nsINode* aAttribute, nsIContent *aChild)    \
+{                                                                         \
+}
+
+
+#endif /* nsIMutationObserver2_h___ */
+
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsDOMAttribute.cpp
--- a/content/base/src/nsDOMAttribute.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsDOMAttribute.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -733,6 +733,11 @@
   if (guard.Mutated(0) && mChild != child) {
     return NS_OK;
   }
+
+  if (aNotify) {
+    nsNodeUtils::AttributeChildRemoved(this, mChild);
+  }
+
   NS_RELEASE(mChild);
   static_cast<nsTextNode*>(child.get())->UnbindFromAttribute();
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsDocument.cpp
--- a/content/base/src/nsDocument.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsDocument.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -2253,76 +2253,6 @@
 
   mChannel = aChannel;
 
-  nsresult rv = CheckFrameOptions();
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
-
-// Check if X-Frame-Options permits this document to be loaded as a subdocument.
-nsresult nsDocument::CheckFrameOptions()
-{
-  nsAutoString xfoHeaderValue;
-  this->GetHeaderData(nsGkAtoms::headerXFO, xfoHeaderValue);
-
-  // return early if header does not have one of the two values with meaning
-  if (!xfoHeaderValue.LowerCaseEqualsLiteral("deny") &&
-      !xfoHeaderValue.LowerCaseEqualsLiteral("sameorigin"))
-    return NS_OK;
-
-  nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
-
-  if (docShell) {
-    PRBool framingAllowed = true;
-
-    // We need to check the location of this window and the location of the top
-    // window, if we're not the top.  X-F-O: SAMEORIGIN requires that the
-    // document must be same-origin with top window.  X-F-O: DENY requires that
-    // the document must never be framed.
-    nsCOMPtr<nsIDOMWindow> thisWindow = do_GetInterface(docShell);
-    nsCOMPtr<nsIDOMWindow> topWindow;
-    thisWindow->GetTop(getter_AddRefs(topWindow));
-
-    // if the document is in the top window, it's not in a frame.
-    if (thisWindow == topWindow)
-      return NS_OK;
-
-    // If the value of the header is DENY, then the document
-    // should never be permitted to load as a subdocument.
-    if (xfoHeaderValue.LowerCaseEqualsLiteral("deny")) {
-      framingAllowed = false;
-    }
-
-    else if (xfoHeaderValue.LowerCaseEqualsLiteral("sameorigin")) {
-      // If the X-Frame-Options value is SAMEORIGIN, then the top frame in the
-      // parent chain must be from the same origin as this document.
-      nsCOMPtr<nsIURI> uri = static_cast<nsIDocument*>(this)->GetDocumentURI();
-      nsCOMPtr<nsIDOMDocument> topDOMDoc;
-      topWindow->GetDocument(getter_AddRefs(topDOMDoc));
-      nsCOMPtr<nsIDocument> topDoc = do_QueryInterface(topDOMDoc);
-      if (topDoc) {
-        nsCOMPtr<nsIURI> topUri = topDoc->GetDocumentURI();
-        nsresult rv = nsContentUtils::GetSecurityManager()->
-          CheckSameOriginURI(uri, topUri, PR_TRUE);
-
-        if (NS_FAILED(rv)) {
-          framingAllowed = false;
-        }
-      }
-    }
-
-    if (!framingAllowed) {
-      // cancel the load and display about:blank
-      mChannel->Cancel(NS_BINDING_ABORTED);
-      nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(docShell));
-      if (webNav) {
-        webNav->LoadURI(NS_LITERAL_STRING("about:blank").get(),
-                        0, nsnull, nsnull, nsnull);
-      }
-      return NS_ERROR_CONTENT_BLOCKED;
-    }
-  }
-
   return NS_OK;
 }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsNodeIterator.cpp
--- a/content/base/src/nsNodeIterator.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsNodeIterator.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -217,7 +217,7 @@
 // QueryInterface implementation for nsNodeIterator
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeIterator)
     NS_INTERFACE_MAP_ENTRY(nsIDOMNodeIterator)
-    NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+    NS_INTERFACE_MAP_ENTRY(nsIMutationObserver2)
     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNodeIterator)
     NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeIterator)
 NS_INTERFACE_MAP_END
@@ -366,3 +366,11 @@
     mPointer.AdjustAfterRemoval(mRoot, container, aChild, aIndexInContainer);
     mWorkingPointer.AdjustAfterRemoval(mRoot, container, aChild, aIndexInContainer);
 }
+
+void nsNodeIterator::AttributeChildRemoved(nsINode* aAttribute,
+                                           nsIContent* aChild)
+{
+  mPointer.AdjustAfterRemoval(mRoot, aAttribute, aChild, 0);
+  mWorkingPointer.AdjustAfterRemoval(mRoot, aAttribute, aChild, 0);
+}
+
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsNodeIterator.h
--- a/content/base/src/nsNodeIterator.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsNodeIterator.h	Thu Dec 02 20:33:03 2010 -0500
@@ -55,7 +55,7 @@
 
 class nsNodeIterator : public nsIDOMNodeIterator,
                        public nsTraversal,
-                       public nsStubMutationObserver
+                       public nsStubMutationObserver2
 {
 public:
     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
@@ -69,6 +69,7 @@
 
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
+    NS_DECL_NSIMUTATIONOBSERVER2_ATTRIBUTECHILDREMOVED
 
     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsNodeIterator, nsIDOMNodeIterator)
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsNodeUtils.cpp
--- a/content/base/src/nsNodeUtils.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsNodeUtils.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -40,6 +40,7 @@
 #include "nsINode.h"
 #include "nsIContent.h"
 #include "nsIMutationObserver.h"
+#include "nsIMutationObserver2.h"
 #include "nsIDocument.h"
 #include "nsIDOMUserDataHandler.h"
 #include "nsIEventListenerManager.h"
@@ -61,6 +62,8 @@
 
 // This macro expects the ownerDocument of content_ to be in scope as
 // |nsIDocument* doc|
+// NOTE: AttributeChildRemoved doesn't use this macro but has a very similar use.
+// If you change how this macro behave please update AttributeChildRemoved.
 #define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)      \
   PR_BEGIN_MACRO                                                  \
   nsINode* node = content_;                                       \
@@ -82,7 +85,6 @@
   } while (node);                                                 \
   PR_END_MACRO
 
-
 void
 nsNodeUtils::CharacterDataWillChange(nsIContent* aContent,
                                      CharacterDataChangeInfo* aInfo)
@@ -185,6 +187,32 @@
 }
 
 void
+nsNodeUtils::AttributeChildRemoved(nsINode* aAttribute,
+                                   nsIContent* aChild)
+{
+  NS_PRECONDITION(aAttribute->IsNodeOfType(nsINode::eATTRIBUTE),
+                  "container must be a nsIAttribute");
+
+  // This is a variant of IMPL_MUTATION_NOTIFICATION.
+  do {
+    nsINode::nsSlots* slots = aAttribute->GetExistingSlots();
+    if (slots && !slots->mMutationObservers.IsEmpty()) {
+      // This is a variant of NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS.
+      nsTObserverArray<nsIMutationObserver*>::ForwardIterator iter_ =
+        slots->mMutationObservers;
+      nsCOMPtr<nsIMutationObserver2> obs_;
+      while (iter_.HasMore()) {
+        obs_ = do_QueryInterface(iter_.GetNext());
+        if (obs_) {
+          obs_->AttributeChildRemoved(aAttribute, aChild);
+        }
+      }
+    }
+    aAttribute = aAttribute->GetNodeParent();
+  } while (aAttribute);
+}
+
+void
 nsNodeUtils::ParentChainChanged(nsIContent *aContent)
 {
   // No need to notify observers on the parents since their parent
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsNodeUtils.h
--- a/content/base/src/nsNodeUtils.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsNodeUtils.h	Thu Dec 02 20:33:03 2010 -0500
@@ -130,6 +130,15 @@
   static void ContentRemoved(nsINode* aContainer,
                              nsIContent* aChild,
                              PRInt32 aIndexInContainer);
+
+  /**
+   * Send AttributeChildRemoved notifications to nsIMutationObservers.
+   * @param aAttribute Attribute from which the child has been removed.
+   * @param aChild     Removed child.
+   * @see nsIMutationObserver2::AttributeChildRemoved.
+   */
+  static void AttributeChildRemoved(nsINode* aAttribute, nsIContent* aChild);
+
   /**
    * Send ParentChainChanged notifications to nsIMutationObservers
    * @param aContent  The piece of content that had its parent changed.
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsStubMutationObserver.cpp
--- a/content/base/src/nsStubMutationObserver.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsStubMutationObserver.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -46,3 +46,6 @@
 
 NS_IMPL_NSIMUTATIONOBSERVER_CORE_STUB(nsStubMutationObserver)
 NS_IMPL_NSIMUTATIONOBSERVER_CONTENT(nsStubMutationObserver)
+
+NS_IMPL_NSIMUTATIONOBSERVER_CORE_STUB(nsStubMutationObserver2)
+NS_IMPL_NSIMUTATIONOBSERVER2_CONTENT(nsStubMutationObserver2)
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsStubMutationObserver.h
--- a/content/base/src/nsStubMutationObserver.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsStubMutationObserver.h	Thu Dec 02 20:33:03 2010 -0500
@@ -46,6 +46,7 @@
 #define nsStubMutationObserver_h_
 
 #include "nsIMutationObserver.h"
+#include "nsIMutationObserver2.h"
 
 /**
  * There are two advantages to inheriting from nsStubMutationObserver
@@ -62,4 +63,8 @@
   NS_DECL_NSIMUTATIONOBSERVER
 };
 
+class nsStubMutationObserver2 : public nsIMutationObserver2 {
+  NS_DECL_NSIMUTATIONOBSERVER2
+};
+
 #endif /* !defined(nsStubMutationObserver_h_) */
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/src/nsXMLHttpRequest.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -2760,9 +2760,11 @@
   if (!privileged) {
     // Check for dangerous headers
     const char *kInvalidHeaders[] = {
-      "accept-charset", "accept-encoding", "connection", "content-length",
-      "content-transfer-encoding", "date", "expect", "host", "keep-alive",
-      "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"
+      "accept-charset", "accept-encoding", "access-control-request-headers",
+      "access-control-request-method", "connection", "content-length",
+      "cookie", "cookie2", "content-transfer-encoding", "date", "expect",
+      "host", "keep-alive", "origin", "referer", "te", "trailer",
+      "transfer-encoding", "upgrade", "user-agent", "via"
     };
     PRUint32 i;
     for (i = 0; i < NS_ARRAY_LENGTH(kInvalidHeaders); ++i) {
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/test/Makefile.in
--- a/content/base/test/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/test/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -85,7 +85,7 @@
 		test_bug276037-2.xhtml \
 		test_bug298064.html \
 		bug298064-subframe.html \
-		test_bug308484.html \
+		test_xhr_forbidden_headers.html \
 		test_bug311681.xml \
 		test_bug322317.html \
 		test_bug330925.xhtml \
@@ -350,5 +350,12 @@
 # test_bug444546.html \
 # bug444546.sjs \
 
+_BROWSER_TEST_FILES = \
+		browser_bug593387.js \
+		$(NULL)
+
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
+
+libs:: $(_BROWSER_TEST_FILES)
+	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/test/browser_bug593387.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/browser_bug593387.js	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,61 @@
+/*
+ * Test for bug 593387
+ * Loads a chrome document in a content docshell and then inserts a
+ * X-Frame-Options: DENY iframe into the document and verifies that the document
+ * loads. The policy we are enforcing is outlined here:
+ * https://bugzilla.mozilla.org/show_bug.cgi?id=593387#c17
+*/
+var newBrowser;
+
+function test() {
+  waitForExplicitFinish();
+
+  var newTab = gBrowser.addTab();
+  gBrowser.selectedTab = newTab;
+  newBrowser = gBrowser.getBrowserForTab(newTab);
+  //alert(newBrowser.contentWindow);
+
+  newBrowser.addEventListener("load", testXFOFrameInChrome, true);
+  newBrowser.contentWindow.location = "chrome://global/content/mozilla.xhtml";
+}
+
+function testXFOFrameInChrome() {
+  newBrowser.removeEventListener("load", testXFOFrameInChrome, true);
+
+  // Insert an iframe that specifies "X-Frame-Options: DENY" and verify
+  // that it loads, since the top context is chrome
+  var frame = newBrowser.contentDocument.createElement("iframe");
+  frame.src = "http://localhost:8888/tests/content/base/test/file_x-frame-options_page.sjs?testid=deny&xfo=deny";
+  frame.addEventListener("load", function() {
+    // Test that the frame loaded
+    var test = this.contentDocument.getElementById("test");
+    is(test.tagName, "H1", "wrong element type");
+    is(test.textContent, "deny", "wrong textContent");
+    
+    // Run next test (try the same with a content top-level context)
+    newBrowser.addEventListener("load", testXFOFrameInContent, true);
+    newBrowser.contentWindow.location = "http://example.com/";  
+  }, true);
+
+  newBrowser.contentDocument.body.appendChild(frame);
+}
+
+function testXFOFrameInContent() {
+  newBrowser.removeEventListener("load", testXFOFrameInContent, true);
+
+  // Insert an iframe that specifies "X-Frame-Options: DENY" and verify that it
+  // is blocked from loading since the top browsing context is another site
+  var frame = newBrowser.contentDocument.createElement("iframe");
+  frame.src = "http://localhost:8888/tests/content/base/test/file_x-frame-options_page.sjs?testid=deny&xfo=deny";
+  frame.addEventListener("load", function() {
+    // Test that the frame DID NOT load
+    var test = this.contentDocument.getElementById("test");
+    is(test, undefined, "should be about:blank");
+
+    // Finalize the test
+    gBrowser.removeCurrentTab();
+    finish();
+  }, true);
+
+  newBrowser.contentDocument.body.appendChild(frame);
+}
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/test/test_bug308484.html
--- a/content/base/test/test_bug308484.html	Tue Oct 26 19:49:55 2010 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-<!DOCTYPE HTML>
-<html>
-<!--
-https://bugzilla.mozilla.org/show_bug.cgi?id=308484
--->
-<head>
-  <title>Test for Bug 308484</title>
-  <script type="text/javascript" src="/MochiKit/packed.js"></script>
-  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
-  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
-</head>
-<body>
-<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=308484">Mozilla Bug 308484</a>
-<p id="display"></p>
-<div id="content" style="display: none">
-  
-</div>
-<pre id="test">
-<script class="testbody" type="text/javascript">
-
-/** Test for Bug 308484 **/
-
-var headers = [
-  "aCCept-chaRset",
-  "acCePt-eNcoDing",
-  "coNnEctIon",
-  "coNtEnt-LEngth",
-  "cOntEnt-tRAnsFer-enCoDiNg",
-  "DATE",
-  "exPeCt",
-  "hOSt",
-  "keep-alive",
-  "reFERer",
-  "te",
-  "trAiLer",
-  "trANsfEr-eNcoDiNg",
-  "uPGraDe",
-  "viA",
-  "pRoxy-",
-  "sEc-",
-  "proxy-fOobar",
-  "sec-bAZbOx"
-];
-var i, request;
-
-// Try setting headers in unprivileged context
-request = new XMLHttpRequest();
-request.open("GET", window.location.href);
-for (i = 0; i < headers.length; i++)
-  request.setRequestHeader(headers[i], "test" + i);
-
-// Read out headers
-netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect UniversalBrowserWrite");
-var channel = request.channel.QueryInterface(Components.interfaces.nsIHttpChannel);
-for (i = 0; i < headers.length; i++) {
-  // Retrieving Content-Length will throw an exception
-  var value = null;
-  try {
-    value = channel.getRequestHeader(headers[i]);
-  }
-  catch(e) {}
-
-  isnot(value, "test" + i, "Setting " + headers[i] + " header in unprivileged context");
-}
-
-// Try setting headers in privileged context
-request = new XMLHttpRequest();
-request.open("GET", window.location.href);
-for (i = 0; i < headers.length; i++)
-  request.setRequestHeader(headers[i], "test" + i);
-
-// Read out headers
-var channel = request.channel.QueryInterface(Components.interfaces.nsIHttpChannel);
-for (i = 0; i < headers.length; i++) {
-  var value = channel.getRequestHeader(headers[i]);
-  is(value, "test" + i, "Setting " + headers[i] + " header in privileged context");
-}
-</script>
-</pre>
-</body>
-</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/test/test_x-frame-options.html
--- a/content/base/test/test_x-frame-options.html	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/base/test/test_x-frame-options.html	Thu Dec 02 20:33:03 2010 -0500
@@ -35,7 +35,44 @@
     is(test != null, testExpectedResults[t], "test "+t);
   }
 
-  SimpleTest.finish();
+  // call tests to check principal comparison, e.g. a document can open a window
+  // to a data: or javascript: document which frames an
+  // X-Frame-Options: SAMEORIGIN document and the frame should load
+  testFrameInJSURI();
+}
+
+// test that a document can be framed under a javascript: URL opened by the
+// same site as the frame
+var testFrameInJSURI = function() {
+  var html = '<iframe id="sameorigin3" src="http://localhost:8888/tests/content/base/test/file_x-frame-options_page.sjs?testid=sameorigin3&xfo=sameorigin"></iframe>';
+  var win = window.open();
+  win.onload = function() {
+    var test = win.document.getElementById("sameorigin3")
+              .contentDocument.getElementById("test");
+    ok(test != null, "frame under javascript: URL should have loaded.");
+    win.close();
+
+    // run last test
+    testFrameInDataURI();
+   }
+  win.location.href = "javascript:document.write('"+html+"');document.close();";
+}
+
+// test that a document can be framed under a data: URL opened by the
+// same site as the frame
+var testFrameInDataURI = function() {
+  var html = '<iframe id="sameorigin4" src="http://localhost:8888/tests/content/base/test/file_x-frame-options_page.sjs?testid=sameorigin4&xfo=sameorigin"></iframe>';
+  var win = window.open();
+  win.onload = function() {
+    var test = win.document.getElementById("sameorigin4")
+              .contentDocument.getElementById("test");
+    ok(test != null, "frame under data: URL should have loaded.");
+    win.close();
+
+    // finalize test
+    SimpleTest.finish();
+   }
+  win.location.href = "data:text/html,"+html;
 }
 
 SimpleTest.waitForExplicitFinish();
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/base/test/test_xhr_forbidden_headers.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_xhr_forbidden_headers.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,87 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=308484
+-->
+<head>
+  <title>Test for Bug 308484</title>
+  <script type="text/javascript" src="/MochiKit/packed.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=308484">Mozilla Bug 308484</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 308484 **/
+
+var headers = [
+  "aCCept-chaRset",
+  "acCePt-eNcoDing",
+  "aCcEsS-cOnTrOl-ReQuEsT-mEtHoD",
+  "aCcEsS-cOnTrOl-ReQuEsT-hEaDeRs",
+  "coNnEctIon",
+  "coNtEnt-LEngth",
+  "CoOKIe",
+  "cOOkiE2",
+  "cOntEnt-tRAnsFer-enCoDiNg",
+  "DATE",
+  "exPeCt",
+  "hOSt",
+  "keep-alive",
+  "oRiGiN",
+  "reFERer",
+  "te",
+  "trAiLer",
+  "trANsfEr-eNcoDiNg",
+  "uPGraDe",
+  "user-AGENT",
+  "viA",
+  "pRoxy-",
+  "sEc-",
+  "proxy-fOobar",
+  "sec-bAZbOx"
+];
+var i, request;
+
+// Try setting headers in unprivileged context
+request = new XMLHttpRequest();
+request.open("GET", window.location.href);
+for (i = 0; i < headers.length; i++)
+  request.setRequestHeader(headers[i], "test" + i);
+
+// Read out headers
+netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect UniversalBrowserWrite");
+var channel = request.channel.QueryInterface(Components.interfaces.nsIHttpChannel);
+for (i = 0; i < headers.length; i++) {
+  // Retrieving Content-Length will throw an exception
+  var value = null;
+  try {
+    value = channel.getRequestHeader(headers[i]);
+  }
+  catch(e) {}
+
+  isnot(value, "test" + i, "Setting " + headers[i] + " header in unprivileged context");
+}
+
+// Try setting headers in privileged context
+request = new XMLHttpRequest();
+request.open("GET", window.location.href);
+for (i = 0; i < headers.length; i++)
+  request.setRequestHeader(headers[i], "test" + i);
+
+// Read out headers
+var channel = request.channel.QueryInterface(Components.interfaces.nsIHttpChannel);
+for (i = 0; i < headers.length; i++) {
+  var value = channel.getRequestHeader(headers[i]);
+  is(value, "test" + i, "Setting " + headers[i] + " header in privileged context");
+}
+</script>
+</pre>
+</body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/html/content/crashtests/604807.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/html/content/crashtests/604807.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<script>
+try {
+  var selectElem = document.createElementNS("http://www.w3.org/1999/xhtml", "select");
+  selectElem.QueryInterface(Components.interfaces.nsISelectElement);
+  selectElem.getOptionIndex(null, 0, true);
+} catch (e) {
+}
+</script>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/html/content/crashtests/crashtests.list
--- a/content/html/content/crashtests/crashtests.list	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/html/content/crashtests/crashtests.list	Thu Dec 02 20:33:03 2010 -0500
@@ -10,3 +10,4 @@
 load 451123-1.html
 load 453406-1.html
 load 504183-1.html
+load 604807.html
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/html/content/public/nsISelectElement.idl
--- a/content/html/content/public/nsISelectElement.idl	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/html/content/public/nsISelectElement.idl	Thu Dec 02 20:33:03 2010 -0500
@@ -48,7 +48,7 @@
  * OPTIONs within a SELECT element.
  */
 
-[scriptable, uuid(35bd8ed5-5f34-4126-8c4f-38ba01681836)]
+[noscript, uuid(35bd8ed5-5f34-4126-8c4f-38ba01681836)]
 interface nsISelectElement : nsISupports
 {
 
@@ -62,9 +62,9 @@
    * @param aContentIndex the index where the options are being added within the
    *        parent (if the parent is an optgroup, the index within the optgroup)
    */
-  [noscript] void willAddOptions(in nsIContent aOptions,
-                                 in nsIContent aParent,
-                                 in long aContentIndex);
+  void willAddOptions(in nsIContent aOptions,
+                      in nsIContent aParent,
+                      in long aContentIndex);
 
   /**
    * To be called when stuff is removed under a child of the select--but
@@ -74,8 +74,8 @@
    * @param aContentIndex the index of the option(s) within the parent (if the
    *        parent is an optgroup, the index within the optgroup)
    */
-  [noscript] void willRemoveOptions(in nsIContent aParent,
-                                    in long aContentIndex);
+  void willRemoveOptions(in nsIContent aParent,
+                         in long aContentIndex);
 
   /**
    * Checks whether an option is disabled (even if it's part of an optgroup)
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/html/document/src/nsHTMLFragmentContentSink.cpp
--- a/content/html/document/src/nsHTMLFragmentContentSink.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/html/document/src/nsHTMLFragmentContentSink.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1105,10 +1105,11 @@
 
     // Check if this is an allowed attribute, or a style attribute in case
     // we've been asked to allow style attributes, or an HTML5 data-*
-    // attribute.
+    // attribute, or an attribute which begins with "_".
     if ((!sAllowedAttributes || !sAllowedAttributes->GetEntry(keyAtom)) &&
         (!mProcessStyle || keyAtom != nsGkAtoms::style) &&
-        !StringBeginsWith(key, NS_LITERAL_STRING("data-"))) {
+        !(StringBeginsWith(key, NS_LITERAL_STRING("data-")) ||
+          StringBeginsWith(key, NS_LITERAL_STRING("_")))) {
       continue;
     }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/svg/content/src/nsSVGPathElement.cpp
--- a/content/svg/content/src/nsSVGPathElement.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/svg/content/src/nsSVGPathElement.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -953,9 +953,11 @@
       if (aMarks->Length())
         aMarks->ElementAt(aMarks->Length() - 1).angle = prevAngle;
     } else {
-      aMarks->ElementAt(aMarks->Length() - 1).angle =
-        nsSVGUtils::AngleBisect(prevAngle, startAngle);
-      prevAngle = endAngle;
+      if (aMarks->Length()) {
+        aMarks->ElementAt(aMarks->Length() - 1).angle =
+          nsSVGUtils::AngleBisect(prevAngle, startAngle);
+        prevAngle = endAngle;
+      }
     }
 
     aMarks->AppendElement(nsSVGMark(x, y, 0));
diff -r 8fe44c79dfd1 -r 0c159bd1d600 content/xul/templates/src/nsXULTreeBuilder.cpp
--- a/content/xul/templates/src/nsXULTreeBuilder.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/content/xul/templates/src/nsXULTreeBuilder.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -522,14 +522,12 @@
 
     nsTreeRows::iterator iter = mRows[aIndex];
 
-    if (iter->mContainerType == nsTreeRows::eContainerType_Unknown) {
-        PRBool isContainer;
-        iter->mMatch->mResult->GetIsContainer(&isContainer);
+    PRBool isContainer;
+    iter->mMatch->mResult->GetIsContainer(&isContainer);
 
-        iter->mContainerType = isContainer
-            ? nsTreeRows::eContainerType_Container
-            : nsTreeRows::eContainerType_Noncontainer;
-    }
+    iter->mContainerType = isContainer
+        ? nsTreeRows::eContainerType_Container
+        : nsTreeRows::eContainerType_Noncontainer;
 
     *aResult = (iter->mContainerType == nsTreeRows::eContainerType_Container);
     return NS_OK;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 docshell/base/nsDSURIContentListener.cpp
--- a/docshell/base/nsDSURIContentListener.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/docshell/base/nsDSURIContentListener.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -46,6 +46,10 @@
 #include "nsIWebNavigationInfo.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsAutoPtr.h"
+#include "nsIHttpChannel.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsNetError.h"
+#include "nsPIDOMWindow.h"
 
 //*****************************************************************************
 //***    nsDSURIContentListener: Object Management
@@ -117,8 +121,15 @@
     nsresult rv;
     NS_ENSURE_ARG_POINTER(aContentHandler);
     NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
-    if(aAbortProcess)
-        *aAbortProcess = PR_FALSE;
+
+    // Check whether X-Frame-Options permits us to load this content in an
+    // iframe
+    if (!CheckFrameOptions(request)) {
+        *aAbortProcess = PR_TRUE;
+        return NS_OK;
+    }
+
+    *aAbortProcess = PR_FALSE;
 
     // determine if the channel has just been retargeted to us...
     nsLoadFlags loadFlags = 0;
@@ -268,3 +279,123 @@
     }
     return NS_OK;
 }
+
+// Check if X-Frame-Options permits this document to be loaded as a subdocument.
+bool nsDSURIContentListener::CheckFrameOptions(nsIRequest* request)
+{
+    nsCAutoString xfoHeaderValue;
+
+    nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(request);
+    if (!httpChannel) {
+        return true;
+    }
+
+    httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("X-Frame-Options"),
+                                   xfoHeaderValue);
+
+    // return early if header does not have one of the two values with meaning
+    if (!xfoHeaderValue.LowerCaseEqualsLiteral("deny") &&
+        !xfoHeaderValue.LowerCaseEqualsLiteral("sameorigin"))
+        return true;
+
+    if (mDocShell) {
+        // We need to check the location of this window and the location of the top
+        // window, if we're not the top.  X-F-O: SAMEORIGIN requires that the
+        // document must be same-origin with top window.  X-F-O: DENY requires that
+        // the document must never be framed.
+        nsCOMPtr<nsIDOMWindow> thisWindow = do_GetInterface(static_cast<nsIDocShell*>(mDocShell));
+        // If we don't have DOMWindow there is no risk of clickjacking
+        if (!thisWindow)
+            return true;
+
+        nsCOMPtr<nsIDOMWindow> topWindow;
+        thisWindow->GetTop(getter_AddRefs(topWindow));
+
+        // if the document is in the top window, it's not in a frame.
+        if (thisWindow == topWindow)
+            return true;
+
+        // Find the top docshell in our parent chain that doesn't have the system
+        // principal and use it for the principal comparison.  Finding the top
+        // content-type docshell doesn't work because some chrome documents are
+        // loaded in content docshells (see bug 593387).
+        nsCOMPtr<nsIDocShellTreeItem> thisDocShellItem(do_QueryInterface(
+                                                       static_cast<nsIDocShell*> (mDocShell)));
+        nsCOMPtr<nsIDocShellTreeItem> parentDocShellItem,
+                                      curDocShellItem = thisDocShellItem;
+        nsCOMPtr<nsIDocument> topDoc;
+        nsCOMPtr<nsPIDOMWindow> parentWin;
+        nsresult rv;
+        nsCOMPtr<nsIScriptSecurityManager> ssm =
+            do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+        if (!ssm)
+            return false;
+
+        // Traverse up the parent chain to the top docshell that doesn't have
+        // a system principal
+        while (NS_SUCCEEDED(curDocShellItem->GetParent(getter_AddRefs(parentDocShellItem))) &&
+               parentDocShellItem) {
+            PRBool system = PR_FALSE;
+            parentWin = do_GetInterface(parentDocShellItem);
+            if (parentWin) {
+                topDoc = do_QueryInterface(parentWin->GetExtantDocument());
+                if (topDoc) {
+                    if (NS_SUCCEEDED(ssm->IsSystemPrincipal(topDoc->NodePrincipal(),
+                                                            &system)) && system) {
+                        break;
+                    }
+                }
+                else
+                    return false;
+            }
+            else
+                return false;
+
+            curDocShellItem = parentDocShellItem;
+        }
+
+        // If this document has the top non-SystemPrincipal docshell it is not being
+        // framed or it is being framed by a chrome document, which we allow.
+        if (curDocShellItem == thisDocShellItem)
+            return true;
+
+        // If the X-Frame-Options value is SAMEORIGIN, then the top frame in the
+        // parent chain must be from the same origin as this document.
+        if (xfoHeaderValue.LowerCaseEqualsLiteral("sameorigin")) {
+            nsCOMPtr<nsIURI> uri;
+            httpChannel->GetURI(getter_AddRefs(uri));
+            parentWin = do_GetInterface(curDocShellItem);
+            if (parentWin) {
+                topDoc = do_QueryInterface(parentWin->GetExtantDocument());
+                if (topDoc) {
+                    nsCOMPtr<nsIURI> topUri;
+                    topDoc->NodePrincipal()->GetURI(getter_AddRefs(topUri));
+                    if (NS_SUCCEEDED(ssm->CheckSameOriginURI(uri, topUri, PR_TRUE)))
+                        return true;
+                }
+                else
+                    return false;
+            }
+            else
+                return false;
+        }
+
+        else {
+            // If the value of the header is DENY, then the document
+            // should never be permitted to load as a subdocument.
+            NS_ASSERTION(xfoHeaderValue.LowerCaseEqualsLiteral("deny"),
+                         "How did we get here with some random header value?");
+        }
+
+        // cancel the load and display about:blank
+        httpChannel->Cancel(NS_BINDING_ABORTED);
+        nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(static_cast<nsIDocShell*>(mDocShell)));
+        if (webNav) {
+            webNav->LoadURI(NS_LITERAL_STRING("about:blank").get(),
+                            0, nsnull, nsnull, nsnull);
+        }
+        return false;
+    }
+
+    return true;
+}
diff -r 8fe44c79dfd1 -r 0c159bd1d600 docshell/base/nsDSURIContentListener.h
--- a/docshell/base/nsDSURIContentListener.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/docshell/base/nsDSURIContentListener.h	Thu Dec 02 20:33:03 2010 -0500
@@ -68,6 +68,10 @@
         mDocShell = nsnull;
     }
 
+    // Determine if X-Frame-Options allows content to be framed
+    // as a subdocument
+    bool CheckFrameOptions(nsIRequest* request);
+
 protected:
     nsDocShell*                      mDocShell;
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/dom/base/nsGlobalWindow.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -213,6 +213,8 @@
 static PRLogModuleInfo* gDOMLeakPRLog;
 #endif
 
+static const char kStorageEnabled[] = "dom.storage.enabled";
+
 nsIDOMStorageList *nsGlobalWindow::sGlobalStorageList  = nsnull;
 
 static nsIEntropyCollector *gEntropyCollector          = nsnull;
@@ -7195,6 +7197,12 @@
   nsIDocShell* docShell = GetDocShell();
 
   if (!principal || !docShell) {
+    *aSessionStorage = nsnull;
+    return NS_OK;
+  }
+
+  if (!nsContentUtils::GetBoolPref(kStorageEnabled)) {
+    *aSessionStorage = nsnull;
     return NS_OK;
   }
 
@@ -7216,6 +7224,11 @@
   NS_ENSURE_ARG_POINTER(aGlobalStorage);
 
 #ifdef MOZ_STORAGE
+  if (!nsContentUtils::GetBoolPref(kStorageEnabled)) {
+    *aGlobalStorage = nsnull;
+    return NS_OK;
+  }
+
   if (!sGlobalStorageList) {
     nsresult rv = NS_NewDOMStorageList(&sGlobalStorageList);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -7237,6 +7250,11 @@
 
   NS_ENSURE_ARG(aLocalStorage);
 
+  if (!nsContentUtils::GetBoolPref(kStorageEnabled)) {
+    *aLocalStorage = nsnull;
+    return NS_OK;
+  }
+
   if (!mLocalStorage) {
     *aLocalStorage = nsnull;
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 dom/plugins/PluginInstanceChild.h
--- a/dom/plugins/PluginInstanceChild.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/dom/plugins/PluginInstanceChild.h	Thu Dec 02 20:33:03 2010 -0500
@@ -52,6 +52,7 @@
 #include "ChildAsyncCall.h"
 #include "nsRect.h"
 #include "nsTHashtable.h"
+#include "mozilla/PaintTracker.h"
 
 namespace mozilla {
 namespace plugins {
@@ -92,6 +93,7 @@
     virtual bool
     AnswerPaint(const NPRemoteEvent& event, int16_t* handled)
     {
+        PaintTracker pt;
         return AnswerNPP_HandleEvent(event, handled);
     }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 dom/src/geolocation/nsGeolocation.cpp
--- a/dom/src/geolocation/nsGeolocation.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/dom/src/geolocation/nsGeolocation.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -926,7 +926,7 @@
 nsGeolocation::ClearWatch(PRInt32 aWatchId)
 {
   PRUint32 count = mWatchingCallbacks.Length();
-  if (aWatchId < 0 || count == 0 || aWatchId > count)
+  if (aWatchId < 0 || count == 0 || PRUint32(aWatchId) >= count)
     return NS_OK;
 
   mWatchingCallbacks[aWatchId]->MarkCleared();
diff -r 8fe44c79dfd1 -r 0c159bd1d600 dom/tests/mochitest/localstorage/Makefile.in
--- a/dom/tests/mochitest/localstorage/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/dom/tests/mochitest/localstorage/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -68,6 +68,7 @@
     test_localStorageBase.html \
     test_localStorageBasePrivateBrowsing.html \
     test_localStorageBaseSessionOnly.html \
+    test_localStorageEnablePref.html \
     test_localStorageOriginsEquals.html \
     test_localStorageOriginsDiff.html \
     test_localStorageOriginsPortDiffs.html \
diff -r 8fe44c79dfd1 -r 0c159bd1d600 dom/tests/mochitest/localstorage/test_localStorageEnablePref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/mochitest/localstorage/test_localStorageEnablePref.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,85 @@
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>localStorage enable preference test</title>
+
+<script type="text/javascript" src="/MochiKit/packed.js"></script>
+<script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+<link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+
+<script type="text/javascript">
+
+function setDOMStorageEnabled(enabled)
+{
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+
+  var prefs = Components.classes["@mozilla.org/preferences-service;1"]
+              .getService(Components.interfaces.nsIPrefBranch);
+  prefs.setBoolPref("dom.storage.enabled", enabled);
+}
+
+function checkException(func, exc)
+{
+  var exceptionThrew = false;
+  try {
+    func();
+  }
+  catch (ex) {
+    exceptionThrew = true;
+    is(ex.name, exc, "Expected "+exc+" exception");
+  }
+  ok(exceptionThrew, "Exception "+exc+" threw");
+}
+
+function startTest()
+{
+  setDOMStorageEnabled(true);
+
+  is(typeof(window.localStorage), "object", "Storage is present");
+  var storage = window.localStorage;
+
+  setDOMStorageEnabled(false);
+
+  is(window.localStorage, null, "Storage is null");
+
+  checkException(function() {storage.setItem("test", "value");}, "NS_ERROR_DOM_SECURITY_ERR");
+
+  setDOMStorageEnabled(true);
+
+  is(typeof(window.localStorage), "object", "Storage is present again");
+  storage.setItem("test", "value");
+  ok(storage.getItem("test"), "value", "value can be set");
+}
+
+function cleanup()
+{
+  setDOMStorageEnabled(true);
+  window.localStorage.clear();
+  SimpleTest.finish();
+}
+
+function doTest()
+{
+  try
+  {
+    startTest();
+  }
+  catch(exc)
+  {
+    ok(false, exc+" was threw during the test")
+  }
+  finally
+  {
+    cleanup();
+  }
+}
+
+SimpleTest.waitForExplicitFinish();
+
+</script>
+
+</head>
+
+<body onload="doTest();">
+
+</body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 editor/libeditor/html/tests/test_bug520189.html
--- a/editor/libeditor/html/tests/test_bug520189.html	Tue Oct 26 19:49:55 2010 -0700
+++ b/editor/libeditor/html/tests/test_bug520189.html	Thu Dec 02 20:33:03 2010 -0500
@@ -56,6 +56,8 @@
   <div id="nn" contenteditable="true"></div>
   <iframe id="oo" src="about:blank"></iframe>
   <div id="pp" contenteditable="true"></div>
+  <iframe id="qq" src="about:blank"></iframe>
+  <div id="rr" contenteditable="true"></div>
 </div>
 <pre id="test">
 <script type="application/javascript">
@@ -83,6 +85,7 @@
 const validImgSrc2Payload = "foo<img src=\"javascript:void('bar');\">baz";
 const validImgSrc3Payload = "foo<img src=\"file:///bar.png\">baz";
 const validDataFooPayload = "foo<span data-bar=\"value\">baz</span>";
+const validDataFoo2Payload = "foo<span _bar=\"value\">baz</span>";
 
 var tests = [
   {
@@ -373,6 +376,19 @@
     payload: validDataFooPayload,
     rootElement: function() document.getElementById("pp"),
     checkResult: function(html) isnot(html.indexOf("bar"), -1, "Should have retained the data-bar attribute")
+  },
+  {
+    id: "qq",
+    isIFrame: true,
+    payload: validDataFoo2Payload,
+    rootElement: function() document.getElementById("qq").contentDocument.documentElement,
+    checkResult: function(html) isnot(html.indexOf("bar"), -1, "Should have retained the _bar attribute")
+  },
+  {
+    id: "rr",
+    payload: validDataFoo2Payload,
+    rootElement: function() document.getElementById("rr"),
+    checkResult: function(html) isnot(html.indexOf("bar"), -1, "Should have retained the _bar attribute")
   }
 ];
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/Makefile.in
--- a/gfx/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -48,7 +48,7 @@
 DIRS		= cairo
 endif
 
-DIRS		+= thebes public idl src qcms
+DIRS		+= ots/src thebes public idl src qcms
 
 ifdef MOZ_IPC
 DIRS		+= ipc
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/LICENSE
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/LICENSE	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,27 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/include/opentype-sanitiser.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/include/opentype-sanitiser.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,186 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OPENTYPE_SANITISER_H_
+#define OPENTYPE_SANITISER_H_
+
+#if defined(_MSC_VER)
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+#include <Winsock2.h>  // for htons/ntohs
+#undef min
+#undef max
+#else
+#include <arpa/inet.h>
+#include <stdint.h>
+#endif
+
+#include <algorithm>  // for std::min
+#include <cassert>
+#include <cstring>
+
+namespace ots {
+
+// -----------------------------------------------------------------------------
+// This is an interface for an abstract stream class which is used for writing
+// the serialised results out.
+// -----------------------------------------------------------------------------
+class OTSStream {
+ public:
+  OTSStream() {
+    ResetChecksum();
+  }
+
+  virtual ~OTSStream() {}
+
+  // This should be implemented to perform the actual write.
+  virtual bool WriteRaw(const void *data, size_t length) = 0;
+
+  bool Write(const void *data, size_t length) {
+    if (!length) return false;
+
+    const size_t orig_length = length;
+    size_t offset = 0;
+    if (chksum_buffer_offset_) {
+      const size_t l =
+        std::min(length, static_cast<size_t>(4) - chksum_buffer_offset_);
+      std::memcpy(chksum_buffer_ + chksum_buffer_offset_, data, l);
+      chksum_buffer_offset_ += l;
+      offset += l;
+      length -= l;
+    }
+
+    if (chksum_buffer_offset_ == 4) {
+      // TODO(yusukes): This cast breaks the strict-aliasing rule.
+      chksum_ += ntohl(*reinterpret_cast<const uint32_t*>(chksum_buffer_));
+      chksum_buffer_offset_ = 0;
+    }
+
+    while (length >= 4) {
+      chksum_ += ntohl(*reinterpret_cast<const uint32_t*>(
+          reinterpret_cast<const uint8_t*>(data) + offset));
+      length -= 4;
+      offset += 4;
+    }
+
+    if (length) {
+      if (chksum_buffer_offset_ != 0) return false;  // not reached
+      if (length > 4) return false;  // not reached
+      std::memcpy(chksum_buffer_,
+             reinterpret_cast<const uint8_t*>(data) + offset, length);
+      chksum_buffer_offset_ = length;
+    }
+
+    return WriteRaw(data, orig_length);
+  }
+
+  virtual bool Seek(off_t position) = 0;
+  virtual off_t Tell() const = 0;
+
+  virtual bool Pad(size_t bytes) {
+    static const uint32_t kZero = 0;
+    while (bytes >= 4) {
+      if (!WriteTag(kZero)) return false;
+      bytes -= 4;
+    }
+    while (bytes) {
+      static const uint8_t kZerob = 0;
+      if (!Write(&kZerob, 1)) return false;
+      bytes--;
+    }
+    return true;
+  }
+
+  bool WriteU16(uint16_t v) {
+    v = htons(v);
+    return Write(&v, sizeof(v));
+  }
+
+  bool WriteS16(int16_t v) {
+    v = htons(v);
+    return Write(&v, sizeof(v));
+  }
+
+  bool WriteU32(uint32_t v) {
+    v = htonl(v);
+    return Write(&v, sizeof(v));
+  }
+
+  bool WriteS32(int32_t v) {
+    v = htonl(v);
+    return Write(&v, sizeof(v));
+  }
+
+  bool WriteR64(uint64_t v) {
+    return Write(&v, sizeof(v));
+  }
+
+  bool WriteTag(uint32_t v) {
+    return Write(&v, sizeof(v));
+  }
+
+  void ResetChecksum() {
+    chksum_ = 0;
+    chksum_buffer_offset_ = 0;
+  }
+
+  uint32_t chksum() const {
+    assert(chksum_buffer_offset_ == 0);
+    return chksum_;
+  }
+
+  struct ChecksumState {
+    uint32_t chksum;
+    uint8_t chksum_buffer[4];
+    unsigned chksum_buffer_offset;
+  };
+
+  ChecksumState SaveChecksumState() const {
+    ChecksumState s;
+    s.chksum = chksum_;
+    s.chksum_buffer_offset = chksum_buffer_offset_;
+    std::memcpy(s.chksum_buffer, chksum_buffer_, 4);
+
+    return s;
+  }
+
+  void RestoreChecksum(const ChecksumState &s) {
+    assert(chksum_buffer_offset_ == 0);
+    chksum_ += s.chksum;
+    chksum_buffer_offset_ = s.chksum_buffer_offset;
+    std::memcpy(chksum_buffer_, s.chksum_buffer, 4);
+  }
+
+ protected:
+  uint32_t chksum_;
+  uint8_t chksum_buffer_[4];
+  unsigned chksum_buffer_offset_;
+};
+
+// -----------------------------------------------------------------------------
+// Process a given OpenType file and write out a sanitised version
+//   output: a pointer to an object implementing the OTSStream interface. The
+//     sanitisied output will be written to this. In the even of a failure,
+//     partial output may have been written.
+//   input: the OpenType file
+//   length: the size, in bytes, of |input|
+//   preserve_otl_tables: whether to preserve OpenType Layout tables
+//                        (GDEF/GPOS/GSUB) without verification
+// -----------------------------------------------------------------------------
+bool Process(OTSStream *output, const uint8_t *input, size_t length,
+             bool preserve_otl_tables = false);
+
+// Force to disable debug output even when the library is compiled with
+// -DOTS_DEBUG.
+void DisableDebugOutput();
+
+}  // namespace ots
+
+#endif  // OPENTYPE_SANITISER_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/include/ots-memory-stream.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/include/ots-memory-stream.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,105 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_MEMORY_STREAM_H_
+#define OTS_MEMORY_STREAM_H_
+
+#include <cstring>
+#include <limits>
+
+#include "opentype-sanitiser.h"
+
+namespace ots {
+
+class MemoryStream : public OTSStream {
+ public:
+  MemoryStream(void *ptr, size_t length)
+      : ptr_(ptr), length_(length), off_(0) {
+  }
+
+  bool WriteRaw(const void *data, size_t length) {
+    if ((off_ + length > length_) ||
+        (length > std::numeric_limits<size_t>::max() - off_)) {
+      return false;
+    }
+    std::memcpy(static_cast<char*>(ptr_) + off_, data, length);
+    off_ += length;
+    return true;
+  }
+
+  bool Seek(off_t position) {
+    if (position < 0) return false;
+    if (static_cast<size_t>(position) > length_) return false;
+    off_ = position;
+    return true;
+  }
+
+  off_t Tell() const {
+    return off_;
+  }
+
+ private:
+  void* const ptr_;
+  size_t length_;
+  off_t off_;
+};
+
+class ExpandingMemoryStream : public OTSStream {
+ public:
+  ExpandingMemoryStream(size_t initial, size_t limit)
+      : length_(initial), limit_(limit), off_(0) {
+    ptr_ = new uint8_t[length_];
+  }
+
+  ~ExpandingMemoryStream() {
+    delete[] static_cast<uint8_t*>(ptr_);
+  }
+
+  void* get() const {
+    return ptr_;
+  }
+
+  bool WriteRaw(const void *data, size_t length) {
+    if ((off_ + length > length_) ||
+        (length > std::numeric_limits<size_t>::max() - off_)) {
+      if (length_ == limit_)
+        return false;
+      size_t new_length = (length_ + 1) * 2;
+      if (new_length < length_)
+        return false;
+      if (new_length > limit_)
+        new_length = limit_;
+      uint8_t* new_buf = new uint8_t[new_length];
+      memcpy(new_buf, ptr_, length_);
+      length_ = new_length;
+      delete[] static_cast<uint8_t*>(ptr_);
+      ptr_ = new_buf;
+      return WriteRaw(data, length);
+    }
+    std::memcpy(static_cast<char*>(ptr_) + off_, data, length);
+    off_ += length;
+    return true;
+  }
+
+  bool Seek(off_t position) {
+    if (position < 0) return false;
+    if (static_cast<size_t>(position) > length_) return false;
+    off_ = position;
+    return true;
+  }
+
+  off_t Tell() const {
+    return off_;
+  }
+
+ private:
+  void* ptr_;
+  size_t length_;
+  const size_t limit_;
+  off_t off_;
+};
+
+}  // namespace ots
+
+#endif  // OTS_MEMORY_STREAM_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/Makefile.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,88 @@
+#
+# Copyright (C) 2010  Mozilla Foundation
+#
+#  This is used to integrate the OTS library with the Mozilla build.
+#
+# Permission is hereby granted, without written agreement and without
+# license or royalty fees, to use, copy, modify, and distribute this
+# software and its documentation for any purpose, provided that the
+# above copyright notice and the following two paragraphs appear in
+# all copies of this software.
+#
+# IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+# IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+# DAMAGE.
+#
+# THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+# ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+#
+# Mozilla author(s): Jonathan Kew
+#
+
+
+DEPTH     = ../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH     = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+ifndef MOZ_ENABLE_LIBXUL
+VISIBILITY_FLAGS =
+endif
+
+MODULE         = ots
+LIBRARY_NAME   = mozots
+LIBXUL_LIBRARY = 1
+
+CSRCS =   \
+  $(NULL)
+
+CPPSRCS	= \
+  cff.cc  \
+  cff_type2_charstring.cc \
+  cmap.cc \
+  cvt.cc  \
+  fpgm.cc \
+  gasp.cc \
+  glyf.cc \
+  hdmx.cc \
+  head.cc \
+  hhea.cc \
+  hmtx.cc \
+  kern.cc \
+  loca.cc \
+  ltsh.cc \
+  maxp.cc \
+  name.cc \
+  os2.cc  \
+  ots.cc  \
+  post.cc \
+  prep.cc \
+  vdmx.cc \
+  vorg.cc \
+  gdef.cc \
+  gpos.cc \
+  gsub.cc \
+  $(NULL)
+
+EXPORTS = \
+  ../include/opentype-sanitiser.h \
+  ../include/ots-memory-stream.h  \
+  $(NULL)
+
+LOCAL_INCLUDES  += -I$(srcdir) 
+
+FORCE_STATIC_LIB = 1
+# This library is used by other shared libs in a static build
+FORCE_USE_PIC = 1
+
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DPACKAGE_VERSION="\"moz\""
+DEFINES += -DPACKAGE_BUGREPORT="\"http://bugzilla.mozilla.org/\""
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cff.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cff.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,1003 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cff.h"
+
+#include <cstring>
+#include <utility>  // std::pair
+#include <vector>
+
+#include "cff_type2_charstring.h"
+
+// CFF - PostScript font program (Compact Font Format) table
+// http://www.microsoft.com/opentype/otspec/cff.htm
+// http://www.microsoft.com/opentype/otspec/5176.CFF.pdf
+
+namespace {
+
+enum DICT_OPERAND_TYPE {
+  DICT_OPERAND_INTEGER,
+  DICT_OPERAND_REAL,
+  DICT_OPERATOR
+};
+
+enum DICT_DATA_TYPE {
+  DICT_DATA_TOPLEVEL,
+  DICT_DATA_FDARRAY
+};
+
+// see Appendix. A
+const size_t kNStdString = 390;
+
+bool ReadOffset(ots::Buffer *table, uint8_t off_size, uint32_t *offset) {
+  if (off_size > 4) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t tmp32 = 0;
+  for (unsigned i = 0; i < off_size; ++i) {
+    uint8_t tmp8 = 0;
+    if (!table->ReadU8(&tmp8)) {
+      return OTS_FAILURE();
+    }
+    tmp32 <<= 8;
+    tmp32 += tmp8;
+  }
+  *offset = tmp32;
+  return true;
+}
+
+bool ParseIndex(ots::Buffer *table, ots::CFFIndex *index) {
+  index->off_size = 0;
+  index->offsets.clear();
+
+  if (!table->ReadU16(&(index->count))) {
+    return OTS_FAILURE();
+  }
+  if (index->count == 0) {
+    // An empty INDEX.
+    index->offset_to_next = table->offset() + sizeof(index->count);
+    return true;
+  }
+
+  if (!table->ReadU8(&(index->off_size))) {
+    return OTS_FAILURE();
+  }
+  if ((index->off_size == 0) ||
+      (index->off_size > 4)) {
+    return OTS_FAILURE();
+  }
+
+  const size_t array_size = (index->count + 1) * index->off_size;
+  // less than ((64k + 1) * 4), thus does not overflow.
+  const size_t object_data_offset = table->offset() + array_size;
+  // does not overflow too, since offset() <= 1GB.
+
+  if (object_data_offset >= table->length()) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i <= index->count; ++i) {  // '<=' is not a typo.
+    uint32_t rel_offset = 0;
+    if (!ReadOffset(table, index->off_size, &rel_offset)) {
+      return OTS_FAILURE();
+    }
+    if (rel_offset < 1) {
+      return OTS_FAILURE();
+    }
+    if (i == 0 && rel_offset != 1) {
+      return OTS_FAILURE();
+    }
+
+    if (rel_offset > table->length()) {
+      return OTS_FAILURE();
+    }
+
+    // does not underflow.
+    if (object_data_offset > table->length() - (rel_offset - 1)) {
+      return OTS_FAILURE();
+    }
+
+    index->offsets.push_back(
+        object_data_offset + (rel_offset - 1));  // less than length(), 1GB.
+  }
+
+  for (unsigned i = 1; i < index->offsets.size(); ++i) {
+    if (index->offsets[i] <= index->offsets[i - 1]) {
+      return OTS_FAILURE();
+    }
+  }
+
+  index->offset_to_next = index->offsets.back();
+  return true;
+}
+
+bool ParseNameData(
+    ots::Buffer *table, const ots::CFFIndex &index, std::string* out_name) {
+  uint8_t name[256] = {0};
+  if (index.offsets.size() == 0) {  // just in case.
+    return OTS_FAILURE();
+  }
+  for (unsigned i = 1; i < index.offsets.size(); ++i) {
+    const size_t length = index.offsets[i] - index.offsets[i - 1];
+    // font names should be no longer than 127 characters.
+    if (length > 127) {
+      return OTS_FAILURE();
+    }
+
+    table->set_offset(index.offsets[i - 1]);
+    if (!table->Read(name, length)) {
+      return OTS_FAILURE();
+    }
+
+    for (size_t j = 0; j < length; ++j) {
+      // setting the first byte to NUL is allowed.
+      if (j == 0 && name[j] == 0) continue;
+      // non-ASCII characters are not recommended (except the first character).
+      if (name[j] < 33 || name[j] > 126) {
+        return OTS_FAILURE();
+      }
+      // [, ], ... are not allowed.
+      if (std::strchr("[](){}<>/% ", name[j])) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  *out_name = reinterpret_cast<char *>(name);
+  return true;
+}
+
+bool CheckOffset(const std::pair<uint32_t, DICT_OPERAND_TYPE>& operand,
+                 size_t table_length) {
+  if (operand.second != DICT_OPERAND_INTEGER) {
+    return OTS_FAILURE();
+  }
+  if (operand.first >= table_length) {
+    return OTS_FAILURE();
+  }
+  return true;
+}
+
+bool CheckSid(const std::pair<uint32_t, DICT_OPERAND_TYPE>& operand,
+              size_t sid_max) {
+  if (operand.second != DICT_OPERAND_INTEGER) {
+    return OTS_FAILURE();
+  }
+  if (operand.first > sid_max) {
+    return OTS_FAILURE();
+  }
+  return true;
+}
+
+bool ParseDictDataBcd(
+    ots::Buffer *table,
+    std::vector<std::pair<uint32_t, DICT_OPERAND_TYPE> > *operands) {
+  bool read_decimal_point = false;
+  bool read_e = false;
+
+  uint8_t nibble = 0;
+  size_t count = 0;
+  while (true) {
+    if (!table->ReadU8(&nibble)) {
+      return OTS_FAILURE();
+    }
+    if ((nibble & 0xf0) == 0xf0) {
+      if ((nibble & 0xf) == 0xf) {
+        // TODO(yusukes): would be better to store actual double value,
+        // rather than the dummy integer.
+        operands->push_back(std::make_pair(0, DICT_OPERAND_REAL));
+        return true;
+      }
+      return OTS_FAILURE();
+    }
+    if ((nibble & 0x0f) == 0x0f) {
+      operands->push_back(std::make_pair(0, DICT_OPERAND_REAL));
+      return true;
+    }
+
+    // check number format
+    uint8_t nibbles[2];
+    nibbles[0] = (nibble & 0xf0) >> 8;
+    nibbles[1] = (nibble & 0x0f);
+    for (unsigned i = 0; i < 2; ++i) {
+      if (nibbles[i] == 0xd) {  // reserved number
+        return OTS_FAILURE();
+      }
+      if ((nibbles[i] == 0xe) &&  // minus
+          ((count > 0) || (i > 0))) {
+        return OTS_FAILURE();  // minus sign should be the first character.
+      }
+      if (nibbles[i] == 0xa) {  // decimal point
+        if (!read_decimal_point) {
+          read_decimal_point = true;
+        } else {
+          return OTS_FAILURE();  // two or more points.
+        }
+      }
+      if ((nibbles[i] == 0xb) ||  // E+
+          (nibbles[i] == 0xc)) {  // E-
+        if (!read_e) {
+          read_e = true;
+        } else {
+          return OTS_FAILURE();  // two or more E's.
+        }
+      }
+    }
+    ++count;
+  }
+}
+
+bool ParseDictDataEscapedOperator(
+    ots::Buffer *table,
+    std::vector<std::pair<uint32_t, DICT_OPERAND_TYPE> > *operands) {
+  uint8_t op = 0;
+  if (!table->ReadU8(&op)) {
+    return OTS_FAILURE();
+  }
+
+  if ((op <= 14) ||
+      (op >= 17 && op <= 23) ||
+      (op >= 30 && op <= 38)) {
+    operands->push_back(std::make_pair((12U << 8) + op, DICT_OPERATOR));
+    return true;
+  }
+
+  // reserved area.
+  return OTS_FAILURE();
+}
+
+bool ParseDictDataNumber(
+    ots::Buffer *table, uint8_t b0,
+    std::vector<std::pair<uint32_t, DICT_OPERAND_TYPE> > *operands) {
+  uint8_t b1 = 0;
+  uint8_t b2 = 0;
+  uint8_t b3 = 0;
+  uint8_t b4 = 0;
+
+  switch (b0) {
+    case 28:  // shortint
+      if (!table->ReadU8(&b1) ||
+          !table->ReadU8(&b2)) {
+        return OTS_FAILURE();
+      }
+      operands->push_back(std::make_pair((b1 << 8) + b2, DICT_OPERAND_INTEGER));
+      return true;
+
+    case 29:  // longint
+      if (!table->ReadU8(&b1) ||
+          !table->ReadU8(&b2) ||
+          !table->ReadU8(&b3) ||
+          !table->ReadU8(&b4)) {
+        return OTS_FAILURE();
+      }
+      operands->push_back(std::make_pair(
+          (b1 << 24) + (b2 << 16) + (b3 << 8) + b4, DICT_OPERAND_INTEGER));
+      return true;
+
+    case 30:  // binary coded decimal
+      return ParseDictDataBcd(table, operands);
+
+    default:
+      break;
+  }
+
+  uint32_t result;
+  if (b0 >=32 && b0 <=246) {
+    result = b0 - 139;
+  } else if (b0 >=247 && b0 <= 250) {
+    if (!table->ReadU8(&b1)) {
+      return OTS_FAILURE();
+    }
+    result = (b0 - 247) * 256 + b1 + 108;
+  } else if (b0 >= 251 && b0 <= 254) {
+    if (!table->ReadU8(&b1)) {
+      return OTS_FAILURE();
+    }
+    result = -(b0 - 251) * 256 + b1 - 108;
+  } else {
+    return OTS_FAILURE();
+  }
+
+  operands->push_back(std::make_pair(result, DICT_OPERAND_INTEGER));
+  return true;
+}
+
+bool ParseDictDataReadNext(
+    ots::Buffer *table,
+    std::vector<std::pair<uint32_t, DICT_OPERAND_TYPE> > *operands) {
+  uint8_t op = 0;
+  if (!table->ReadU8(&op)) {
+    return OTS_FAILURE();
+  }
+  if (op <= 21) {
+    if (op == 12) {
+      return ParseDictDataEscapedOperator(table, operands);
+    }
+    operands->push_back(std::make_pair(op, DICT_OPERATOR));
+    return true;
+  } else if (op <= 27 || op == 31 || op == 255) {
+    // reserved area.
+    return OTS_FAILURE();
+  }
+
+  return ParseDictDataNumber(table, op, operands);
+}
+
+bool ParsePrivateDictData(
+    const uint8_t *data,
+    size_t table_length, size_t offset, size_t dict_length,
+    DICT_DATA_TYPE type, ots::OpenTypeCFF *out_cff) {
+  ots::Buffer table(data + offset, dict_length);
+  std::vector<std::pair<uint32_t, DICT_OPERAND_TYPE> > operands;
+
+  // Since a Private DICT for FDArray might not have a Local Subr (e.g. Hiragino
+  // Kaku Gothic Std W8), we create an empty Local Subr here to match the size
+  // of FDArray the size of |local_subrs_per_font|.
+  if (type == DICT_DATA_FDARRAY) {
+    out_cff->local_subrs_per_font.push_back(new ots::CFFIndex);
+  }
+
+  while (table.offset() < dict_length) {
+    if (!ParseDictDataReadNext(&table, &operands)) {
+      return OTS_FAILURE();
+    }
+    if (operands.empty()) {
+      return OTS_FAILURE();
+    }
+    if (operands.size() > 48) {
+      // An operator may be preceded by up to a maximum of 48 operands.
+      return OTS_FAILURE();
+    }
+    if (operands.back().second != DICT_OPERATOR) {
+      continue;
+    }
+
+    // got operator
+    const uint32_t op = operands.back().first;
+    operands.pop_back();
+
+    switch (op) {
+      // array
+      case 6:  // BlueValues
+      case 7:  // OtherBlues
+      case 8:  // FamilyBlues
+      case 9:  // FamilyOtherBlues
+      case (12U << 8) + 12:  // StemSnapH (delta)
+      case (12U << 8) + 13:  // StemSnapV (delta)
+        if (operands.empty()) {
+          return OTS_FAILURE();
+        }
+        break;
+
+      // number
+      case 10:  // StdHW
+      case 11:  // StdVW
+      case 20:  // defaultWidthX
+      case 21:  // nominalWidthX
+      case (12U << 8) + 9:   // BlueScale
+      case (12U << 8) + 10:  // BlueShift
+      case (12U << 8) + 11:  // BlueFuzz
+      case (12U << 8) + 17:  // LanguageGroup
+      case (12U << 8) + 18:  // ExpansionFactor
+      case (12U << 8) + 19:  // initialRandomSeed
+        if (operands.size() != 1) {
+          return OTS_FAILURE();
+        }
+        break;
+
+      // Local Subrs INDEX, offset(self)
+      case 19: {
+        if (operands.size() != 1) {
+          return OTS_FAILURE();
+        }
+        if (operands.back().second != DICT_OPERAND_INTEGER) {
+          return OTS_FAILURE();
+        }
+        if (operands.back().first >= 1024 * 1024 * 1024) {
+          return OTS_FAILURE();
+        }
+        if (operands.back().first + offset >= table_length) {
+          return OTS_FAILURE();
+        }
+        // parse "16. Local Subrs INDEX"
+        ots::Buffer table(data, table_length);
+        table.set_offset(operands.back().first + offset);
+        ots::CFFIndex *local_subrs_index = NULL;
+        if (type == DICT_DATA_FDARRAY) {
+          if (out_cff->local_subrs_per_font.empty()) {
+            return OTS_FAILURE();  // not reached.
+          }
+          local_subrs_index = out_cff->local_subrs_per_font.back();
+        } else if (type == DICT_DATA_TOPLEVEL) {
+          if (out_cff->local_subrs) {
+            return OTS_FAILURE();  // two or more local_subrs?
+          }
+          local_subrs_index = new ots::CFFIndex;
+          out_cff->local_subrs = local_subrs_index;
+        }
+        if (!ParseIndex(&table, local_subrs_index)) {
+          return OTS_FAILURE();
+        }
+        break;
+      }
+
+      // boolean
+      case (12U << 8) + 14:  // ForceBold
+        if (operands.size() != 1) {
+          return OTS_FAILURE();
+        }
+        if (operands.back().second != DICT_OPERAND_INTEGER) {
+          return OTS_FAILURE();
+        }
+        if (operands.back().first >= 2) {
+          return OTS_FAILURE();
+        }
+        break;
+
+      default:
+        return OTS_FAILURE();
+    }
+    operands.clear();
+  }
+
+  return true;
+}
+
+bool ParseDictData(const uint8_t *data, size_t table_length,
+                   const ots::CFFIndex &index, size_t sid_max,
+                   DICT_DATA_TYPE type, ots::OpenTypeCFF *out_cff) {
+  for (unsigned i = 1; i < index.offsets.size(); ++i) {
+    if (type == DICT_DATA_TOPLEVEL) {
+      out_cff->char_strings_array.push_back(new ots::CFFIndex);
+    }
+    size_t dict_length = index.offsets[i] - index.offsets[i - 1];
+    ots::Buffer table(data + index.offsets[i - 1], dict_length);
+
+    std::vector<std::pair<uint32_t, DICT_OPERAND_TYPE> > operands;
+
+    bool have_ros = false;
+    size_t glyphs = 0;
+    size_t charset_offset = 0;
+
+    while (table.offset() < dict_length) {
+      if (!ParseDictDataReadNext(&table, &operands)) {
+        return OTS_FAILURE();
+      }
+      if (operands.empty()) {
+        return OTS_FAILURE();
+      }
+      if (operands.size() > 48) {
+        // An operator may be preceded by up to a maximum of 48 operands.
+        return OTS_FAILURE();
+      }
+      if (operands.back().second != DICT_OPERATOR) continue;
+
+      // got operator
+      const uint32_t op = operands.back().first;
+      operands.pop_back();
+
+      switch (op) {
+        // SID
+        case 0:   // version
+        case 1:   // Notice
+        case 2:   // Copyright
+        case 3:   // FullName
+        case 4:   // FamilyName
+        case (12U << 8) + 0:   // Copyright
+        case (12U << 8) + 21:  // PostScript
+        case (12U << 8) + 22:  // BaseFontName
+        case (12U << 8) + 38:  // FontName
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (!CheckSid(operands.back(), sid_max)) {
+            return OTS_FAILURE();
+          }
+          break;
+
+        // array
+        case 5:   // FontBBox
+        case 14:  // XUID
+        case (12U << 8) + 7:   // FontMatrix
+        case (12U << 8) + 23:  // BaseFontBlend (delta)
+          if (operands.empty()) {
+            return OTS_FAILURE();
+          }
+          break;
+
+        // number
+        case 13:  // UniqueID
+        case (12U << 8) + 2:   // ItalicAngle
+        case (12U << 8) + 3:   // UnderlinePosition
+        case (12U << 8) + 4:   // UnderlineThickness
+        case (12U << 8) + 5:   // PaintType
+        case (12U << 8) + 8:   // StrokeWidth
+        case (12U << 8) + 20:  // SyntheticBase
+        case (12U << 8) + 31:  // CIDFontVersion
+        case (12U << 8) + 32:  // CIDFontRevision
+        case (12U << 8) + 33:  // CIDFontType
+        case (12U << 8) + 34:  // CIDCount
+        case (12U << 8) + 35:  // UIDBase
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          break;
+        case (12U << 8) + 6:   // CharstringType
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if(operands.back().second != DICT_OPERAND_INTEGER) {
+            return OTS_FAILURE();
+          }
+          if (operands.back().first != 2) {
+            // We only support the "Type 2 Charstring Format."
+            // TODO(yusukes): Support Type 1 format? Is that still in use?
+            return OTS_FAILURE();
+          }
+          break;
+
+        // boolean
+        case (12U << 8) + 1:   // isFixedPitch
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (operands.back().second != DICT_OPERAND_INTEGER) {
+            return OTS_FAILURE();
+          }
+          if (operands.back().first >= 2) {
+            return OTS_FAILURE();
+          }
+          break;
+
+        // offset(0)
+        case 15:  // charset
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (operands.back().first <= 2) {
+            // predefined charset, ISOAdobe, Expert or ExpertSubset, is used.
+            break;
+          }
+          if (!CheckOffset(operands.back(), table_length)) {
+            return OTS_FAILURE();
+          }
+          if (charset_offset) {
+            return OTS_FAILURE();  // multiple charset tables?
+          }
+          charset_offset = operands.back().first;
+          break;
+
+        case 16: {  // Encoding
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (operands.back().first <= 1) {
+            break;  // predefined encoding, "Standard" or "Expert", is used.
+          }
+          if (!CheckOffset(operands.back(), table_length)) {
+            return OTS_FAILURE();
+          }
+
+          // parse sub dictionary INDEX.
+          ots::Buffer table(data, table_length);
+          table.set_offset(operands.back().first);
+          uint8_t format = 0;
+          if (!table.ReadU8(&format)) {
+            return OTS_FAILURE();
+          }
+          if (format & 0x80) {
+            // supplemental encoding is not supported at the moment.
+            return OTS_FAILURE();
+          }
+          // TODO(yusukes): support & parse supplemental encoding tables.
+          break;
+        }
+
+        case 17: {  // CharStrings
+          if (type != DICT_DATA_TOPLEVEL) {
+            return OTS_FAILURE();
+          }
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (!CheckOffset(operands.back(), table_length)) {
+            return OTS_FAILURE();
+          }
+          // parse "14. CharStrings INDEX"
+          ots::Buffer table(data, table_length);
+          table.set_offset(operands.back().first);
+          ots::CFFIndex *charstring_index = out_cff->char_strings_array.back();
+          if (!ParseIndex(&table, charstring_index)) {
+            return OTS_FAILURE();
+          }
+          if (charstring_index->count < 2) {
+            return OTS_FAILURE();
+          }
+          if (glyphs) {
+            return OTS_FAILURE();  // multiple charstring tables?
+          }
+          glyphs = charstring_index->count;
+          break;
+        }
+
+        case (12U << 8) + 36: {  // FDArray
+          if (type != DICT_DATA_TOPLEVEL) {
+            return OTS_FAILURE();
+          }
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (!CheckOffset(operands.back(), table_length)) {
+            return OTS_FAILURE();
+          }
+
+          // parse sub dictionary INDEX.
+          ots::Buffer table(data, table_length);
+          table.set_offset(operands.back().first);
+          ots::CFFIndex sub_dict_index;
+          if (!ParseIndex(&table, &sub_dict_index)) {
+            return OTS_FAILURE();
+          }
+          if (!ParseDictData(data, table_length,
+                             sub_dict_index, sid_max, DICT_DATA_FDARRAY,
+                             out_cff)) {
+            return OTS_FAILURE();
+          }
+          if (out_cff->font_dict_length != 0) {
+            return OTS_FAILURE();  // two or more FDArray found.
+          }
+          out_cff->font_dict_length = sub_dict_index.count;
+          break;
+        }
+
+        case (12U << 8) + 37: {  // FDSelect
+          if (type != DICT_DATA_TOPLEVEL) {
+            return OTS_FAILURE();
+          }
+          if (operands.size() != 1) {
+            return OTS_FAILURE();
+          }
+          if (!CheckOffset(operands.back(), table_length)) {
+            return OTS_FAILURE();
+          }
+
+          // parse FDSelect data structure
+          ots::Buffer table(data, table_length);
+          table.set_offset(operands.back().first);
+          uint8_t format = 0;
+          if (!table.ReadU8(&format)) {
+            return OTS_FAILURE();
+          }
+          if (format == 0) {
+            for (size_t j = 0; j < glyphs; ++j) {
+              uint8_t fd_index = 0;
+              if (!table.ReadU8(&fd_index)) {
+                return OTS_FAILURE();
+              }
+              (out_cff->fd_select)[j] = fd_index;
+            }
+          } else if (format == 3) {
+            uint16_t n_ranges = 0;
+            if (!table.ReadU16(&n_ranges)) {
+              return OTS_FAILURE();
+            }
+            if (n_ranges == 0) {
+              return OTS_FAILURE();
+            }
+
+            uint16_t last_gid = 0;
+            uint8_t fd_index = 0;
+            for (unsigned j = 0; j < n_ranges; ++j) {
+              uint16_t first = 0;  // GID
+              if (!table.ReadU16(&first)) {
+                return OTS_FAILURE();
+              }
+
+              // Sanity checks.
+              if ((j == 0) && (first != 0)) {
+                return OTS_FAILURE();
+              }
+              if ((j != 0) && (last_gid >= first)) {
+                return OTS_FAILURE();  // not increasing order.
+              }
+
+              // Copy the mapping to |out_cff->fd_select|.
+              if (j != 0) {
+                for (uint16_t k = last_gid; k < first; ++k) {
+                  if (!out_cff->fd_select.insert(
+                          std::make_pair(k, fd_index)).second) {
+                    return OTS_FAILURE();
+                  }
+                }
+              }
+
+              if (!table.ReadU8(&fd_index)) {
+                return OTS_FAILURE();
+              }
+              last_gid = first;
+              // TODO(yusukes): check GID?
+            }
+            uint16_t sentinel = 0;
+            if (!table.ReadU16(&sentinel)) {
+              return OTS_FAILURE();
+            }
+            if (last_gid >= sentinel) {
+              return OTS_FAILURE();
+            }
+            for (uint16_t k = last_gid; k < sentinel; ++k) {
+              if (!out_cff->fd_select.insert(
+                      std::make_pair(k, fd_index)).second) {
+                return OTS_FAILURE();
+              }
+            }
+          } else {
+            // unknown format
+            return OTS_FAILURE();
+          }
+          break;
+        }
+
+        // Private DICT (2 * number)
+        case 18: {
+          if (operands.size() != 2) {
+            return OTS_FAILURE();
+          }
+          if (operands.back().second != DICT_OPERAND_INTEGER) {
+            return OTS_FAILURE();
+          }
+          const uint32_t private_offset = operands.back().first;
+          operands.pop_back();
+          if (operands.back().second != DICT_OPERAND_INTEGER) {
+            return OTS_FAILURE();
+          }
+          const uint32_t private_length = operands.back().first;
+          if (private_offset >= table_length) {
+            return OTS_FAILURE();
+          }
+          if (private_length >= table_length) {
+            return OTS_FAILURE();
+          }
+          if (private_length + private_offset > table_length) {
+            // does not overflow since table_length < 1GB
+            return OTS_FAILURE();
+          }
+          // parse "15. Private DICT Data"
+          if (!ParsePrivateDictData(data, table_length,
+                                    private_offset, private_length,
+                                    type, out_cff)) {
+            return OTS_FAILURE();
+          }
+          break;
+        }
+
+        // ROS
+        case (12U << 8) + 30:
+          if (type != DICT_DATA_TOPLEVEL) {
+            return OTS_FAILURE();
+          }
+          if (operands.size() != 3) {
+            return OTS_FAILURE();
+          }
+          // check SIDs
+          operands.pop_back();  // ignore the first number.
+          if (!CheckSid(operands.back(), sid_max)) {
+            return OTS_FAILURE();
+          }
+          operands.pop_back();
+          if (!CheckSid(operands.back(), sid_max)) {
+            return OTS_FAILURE();
+          }
+          if (have_ros) {
+            return OTS_FAILURE();  // multiple ROS tables?
+          }
+          have_ros = true;
+          break;
+
+        default:
+          return OTS_FAILURE();
+      }
+      operands.clear();
+    }
+
+    // parse "13. Charsets"
+    if (charset_offset) {
+      ots::Buffer table(data, table_length);
+      table.set_offset(charset_offset);
+      uint8_t format = 0;
+      if (!table.ReadU8(&format)) {
+        return OTS_FAILURE();
+      }
+      switch (format) {
+        case 0:
+          for (unsigned j = 1 /* .notdef is omitted */; j < glyphs; ++j) {
+            uint16_t sid = 0;
+            if (!table.ReadU16(&sid)) {
+              return OTS_FAILURE();
+            }
+            if (!have_ros && (sid > sid_max)) {
+              return OTS_FAILURE();
+            }
+            // TODO(yusukes): check CIDs when have_ros is true.
+          }
+          break;
+
+        case 1:
+        case 2: {
+          uint32_t total = 1;  // .notdef is omitted.
+          while (total < glyphs) {
+            uint16_t sid = 0;
+            if (!table.ReadU16(&sid)) {
+              return OTS_FAILURE();
+            }
+            if (!have_ros && (sid > sid_max)) {
+              return OTS_FAILURE();
+            }
+            // TODO(yusukes): check CIDs when have_ros is true.
+
+            if (format == 1) {
+              uint8_t left = 0;
+              if (!table.ReadU8(&left)) {
+                return OTS_FAILURE();
+              }
+              total += (left + 1);
+            } else {
+              uint16_t left = 0;
+              if (!table.ReadU16(&left)) {
+                return OTS_FAILURE();
+              }
+              total += (left + 1);
+            }
+          }
+          break;
+        }
+
+        default:
+          return OTS_FAILURE();
+      }
+    }
+  }
+  return true;
+}
+
+}  // namespace
+
+namespace ots {
+
+bool ots_cff_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  file->cff = new OpenTypeCFF;
+  file->cff->data = data;
+  file->cff->length = length;
+  file->cff->font_dict_length = 0;
+  file->cff->local_subrs = NULL;
+
+  // parse "6. Header" in the Adobe Compact Font Format Specification
+  uint8_t major = 0;
+  uint8_t minor = 0;
+  uint8_t hdr_size = 0;
+  uint8_t off_size = 0;
+  if (!table.ReadU8(&major)) {
+    return OTS_FAILURE();
+  }
+  if (!table.ReadU8(&minor)) {
+    return OTS_FAILURE();
+  }
+  if (!table.ReadU8(&hdr_size)) {
+    return OTS_FAILURE();
+  }
+  if (!table.ReadU8(&off_size)) {
+    return OTS_FAILURE();
+  }
+  if ((off_size == 0) || (off_size > 4)) {
+    return OTS_FAILURE();
+  }
+
+  if ((major != 1) ||
+      (minor != 0) ||
+      (hdr_size != 4)) {
+    return OTS_FAILURE();
+  }
+  if (hdr_size >= length) {
+    return OTS_FAILURE();
+  }
+
+  // parse "7. Name INDEX"
+  table.set_offset(hdr_size);
+  CFFIndex name_index;
+  if (!ParseIndex(&table, &name_index)) {
+    return OTS_FAILURE();
+  }
+  if (!ParseNameData(&table, name_index, &(file->cff->name))) {
+    return OTS_FAILURE();
+  }
+
+  // parse "8. Top DICT INDEX"
+  table.set_offset(name_index.offset_to_next);
+  CFFIndex top_dict_index;
+  if (!ParseIndex(&table, &top_dict_index)) {
+    return OTS_FAILURE();
+  }
+  if (name_index.count != top_dict_index.count) {
+    return OTS_FAILURE();
+  }
+
+  // parse "10. String INDEX"
+  table.set_offset(top_dict_index.offset_to_next);
+  CFFIndex string_index;
+  if (!ParseIndex(&table, &string_index)) {
+    return OTS_FAILURE();
+  }
+  if (string_index.count >= 65000 - kNStdString) {
+    return OTS_FAILURE();
+  }
+
+  const size_t sid_max = string_index.count + kNStdString;
+  // string_index.count == 0 is allowed.
+
+  // parse "9. Top DICT Data"
+  if (!ParseDictData(data, length, top_dict_index,
+                     sid_max, DICT_DATA_TOPLEVEL, file->cff)) {
+    return OTS_FAILURE();
+  }
+
+  // parse "16. Global Subrs INDEX"
+  table.set_offset(string_index.offset_to_next);
+  CFFIndex global_subrs_index;
+  if (!ParseIndex(&table, &global_subrs_index)) {
+    return OTS_FAILURE();
+  }
+
+  // Check if all fd_index in FDSelect are valid.
+  std::map<uint16_t, uint8_t>::const_iterator iter;
+  std::map<uint16_t, uint8_t>::const_iterator end = file->cff->fd_select.end();
+  for (iter = file->cff->fd_select.begin(); iter != end; ++iter) {
+    if (iter->second >= file->cff->font_dict_length) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // Check if all charstrings (font hinting code for each glyph) are valid.
+  for (size_t i = 0; i < file->cff->char_strings_array.size(); ++i) {
+    if (!ValidateType2CharStringIndex(*(file->cff->char_strings_array.at(i)),
+                                      global_subrs_index,
+                                      file->cff->fd_select,
+                                      file->cff->local_subrs_per_font,
+                                      file->cff->local_subrs,
+                                      &table)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+bool ots_cff_should_serialise(OpenTypeFile *file) {
+  return file->cff;
+}
+
+bool ots_cff_serialise(OTSStream *out, OpenTypeFile *file) {
+  // TODO(yusukes): would be better to transcode the data,
+  //                rather than simple memcpy.
+  if (!out->Write(file->cff->data, file->cff->length)) {
+    return OTS_FAILURE();
+  }
+  return true;
+}
+
+void ots_cff_free(OpenTypeFile *file) {
+  if (file->cff) {
+    for (size_t i = 0; i < file->cff->char_strings_array.size(); ++i) {
+      delete (file->cff->char_strings_array)[i];
+    }
+    for (size_t i = 0; i < file->cff->local_subrs_per_font.size(); ++i) {
+      delete (file->cff->local_subrs_per_font)[i];
+    }
+    delete file->cff->local_subrs;
+    delete file->cff;
+  }
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cff.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cff.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,46 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_CFF_H_
+#define OTS_CFF_H_
+
+#include "ots.h"
+
+#include <map>
+#include <string>
+#include <vector>
+
+namespace ots {
+
+struct CFFIndex {
+  CFFIndex()
+      : count(0), off_size(0), offset_to_next(0) {}
+  uint16_t count;
+  uint8_t off_size;
+  std::vector<uint32_t> offsets;
+  uint32_t offset_to_next;
+};
+
+struct OpenTypeCFF {
+  const uint8_t *data;
+  size_t length;
+  // Name INDEX. This name is used in name.cc as a postscript font name.
+  std::string name;
+
+  // The number of fonts the file has.
+  size_t font_dict_length;
+  // A map from glyph # to font #.
+  std::map<uint16_t, uint8_t> fd_select;
+
+  // A list of char strings.
+  std::vector<CFFIndex *> char_strings_array;
+  // A list of Local Subrs associated with FDArrays. Can be empty.
+  std::vector<CFFIndex *> local_subrs_per_font;
+  // A Local Subrs associated with Top DICT. Can be NULL.
+  CFFIndex *local_subrs;
+};
+
+}  // namespace ots
+
+#endif  // OTS_CFF_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cff_type2_charstring.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cff_type2_charstring.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,889 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// A parser for the Type 2 Charstring Format.
+// http://www.adobe.com/devnet/font/pdfs/5177.Type2.pdf
+
+#include "cff_type2_charstring.h"
+
+#include <climits>
+#include <cstdio>
+#include <cstring>
+#include <stack>
+#include <string>
+#include <utility>
+
+namespace {
+
+// Type 2 Charstring Implementation Limits. See Appendix. B in Adobe Technical
+// Note #5177.
+const int32_t kMaxSubrsCount = 65536;
+const size_t kMaxCharStringLength = 65535;
+const size_t kMaxArgumentStack = 48;
+const size_t kMaxNumberOfStemHints = 96;
+const size_t kMaxSubrNesting = 10;
+
+// |dummy_result| should be a huge positive integer so callsubr and callgsubr
+// will fail with the dummy value.
+const int32_t dummy_result = INT_MAX;
+
+bool ExecuteType2CharString(size_t call_depth,
+                            const ots::CFFIndex& global_subrs_index,
+                            const ots::CFFIndex& local_subrs_index,
+                            ots::Buffer *cff_table,
+                            ots::Buffer *char_string,
+                            std::stack<int32_t> *argument_stack,
+                            bool *out_found_endchar,
+                            bool *out_found_width,
+                            size_t *in_out_num_stems);
+
+// Converts |op| to a string and returns it.
+const char *Type2CharStringOperatorToString(ots::Type2CharStringOperator op) {
+  switch (op) {
+  case ots::kHStem:
+    return "HStem";
+  case ots::kVStem:
+    return "VStem";
+  case ots::kVMoveTo:
+    return "VMoveTo";
+  case ots::kRLineTo:
+    return "RLineTo";
+  case ots::kHLineTo:
+    return "HLineTo";
+  case ots::kVLineTo:
+    return "VLineTo";
+  case ots::kRRCurveTo:
+    return "RRCurveTo";
+  case ots::kCallSubr:
+    return "CallSubr";
+  case ots::kReturn:
+    return "Return";
+  case ots::kEndChar:
+    return "EndChar";
+  case ots::kHStemHm:
+    return "HStemHm";
+  case ots::kHintMask:
+    return "HintMask";
+  case ots::kCntrMask:
+    return "CntrMask";
+  case ots::kRMoveTo:
+    return "RMoveTo";
+  case ots::kHMoveTo:
+    return "HMoveTo";
+  case ots::kVStemHm:
+    return "VStemHm";
+  case ots::kRCurveLine:
+    return "RCurveLine";
+  case ots::kRLineCurve:
+    return "RLineCurve";
+  case ots::kVVCurveTo:
+    return "VVCurveTo";
+  case ots::kHHCurveTo:
+    return "HHCurveTo";
+  case ots::kCallGSubr:
+    return "CallGSubr";
+  case ots::kVHCurveTo:
+    return "VHCurveTo";
+  case ots::kHVCurveTo:
+    return "HVCurveTo";
+  case ots::kAnd:
+    return "And";
+  case ots::kOr:
+    return "Or";
+  case ots::kNot:
+    return "Not";
+  case ots::kAbs:
+    return "Abs";
+  case ots::kAdd:
+    return "Add";
+  case ots::kSub:
+    return "Sub";
+  case ots::kDiv:
+    return "Div";
+  case ots::kNeg:
+    return "Neg";
+  case ots::kEq:
+    return "Eq";
+  case ots::kDrop:
+    return "Drop";
+  case ots::kPut:
+    return "Put";
+  case ots::kGet:
+    return "Get";
+  case ots::kIfElse:
+    return "IfElse";
+  case ots::kRandom:
+    return "Random";
+  case ots::kMul:
+    return "Mul";
+  case ots::kSqrt:
+    return "Sqrt";
+  case ots::kDup:
+    return "Dup";
+  case ots::kExch:
+    return "Exch";
+  case ots::kIndex:
+    return "Index";
+  case ots::kRoll:
+    return "Roll";
+  case ots::kHFlex:
+    return "HFlex";
+  case ots::kFlex:
+    return "Flex";
+  case ots::kHFlex1:
+    return "HFlex1";
+  case ots::kFlex1:
+    return "Flex1";
+  }
+
+  return "UNKNOWN";
+}
+
+// Read one or more bytes from the |char_string| buffer and stores the number
+// read on |out_number|. If the number read is an operator (ex 'vstem'), sets
+// true on |out_is_operator|. Returns true if the function read a number.
+bool ReadNextNumberFromType2CharString(ots::Buffer *char_string,
+                                       int32_t *out_number,
+                                       bool *out_is_operator) {
+  uint8_t v = 0;
+  if (!char_string->ReadU8(&v)) {
+    return OTS_FAILURE();
+  }
+  *out_is_operator = false;
+
+  // The conversion algorithm is described in Adobe Technical Note #5177, page
+  // 13, Table 1.
+  if (v <= 11) {
+    *out_number = v;
+    *out_is_operator = true;
+  } else if (v == 12) {
+    uint16_t result = (v << 8);
+    if (!char_string->ReadU8(&v)) {
+      return OTS_FAILURE();
+    }
+    result += v;
+    *out_number = result;
+    *out_is_operator = true;
+  } else if (v <= 27) {
+    // Special handling for v==19 and v==20 are implemented in
+    // ExecuteType2CharStringOperator().
+    *out_number = v;
+    *out_is_operator = true;
+  } else if (v == 28) {
+    if (!char_string->ReadU8(&v)) {
+      return OTS_FAILURE();
+    }
+    uint16_t result = (v << 8);
+    if (!char_string->ReadU8(&v)) {
+      return OTS_FAILURE();
+    }
+    result += v;
+    *out_number = result;
+  } else if (v <= 31) {
+    *out_number = v;
+    *out_is_operator = true;
+  } else if (v <= 246) {
+    *out_number = static_cast<int32_t>(v) - 139;
+  } else if (v <= 250) {
+    uint8_t w = 0;
+    if (!char_string->ReadU8(&w)) {
+      return OTS_FAILURE();
+    }
+    *out_number = ((static_cast<int32_t>(v) - 247) * 256) +
+        static_cast<int32_t>(w) + 108;
+  } else if (v <= 254) {
+    uint8_t w = 0;
+    if (!char_string->ReadU8(&w)) {
+      return OTS_FAILURE();
+    }
+    *out_number = -((static_cast<int32_t>(v) - 251) * 256) -
+        static_cast<int32_t>(w) - 108;
+  } else if (v == 255) {
+    // TODO(yusukes): We should not skip the 4 bytes. Note that when v is 255,
+    // we should treat the following 4-bytes as a 16.16 fixed-point number
+    // rather than 32bit signed int.
+    if (!char_string->Skip(4)) {
+      return OTS_FAILURE();
+    }
+    *out_number = dummy_result;
+  } else {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+// Executes |op| and updates |argument_stack|. Returns true if the execution
+// succeeds. If the |op| is kCallSubr or kCallGSubr, the function recursively
+// calls ExecuteType2CharString() function. The arguments other than |op| and
+// |argument_stack| are passed for that reason.
+bool ExecuteType2CharStringOperator(int32_t op,
+                                    size_t call_depth,
+                                    const ots::CFFIndex& global_subrs_index,
+                                    const ots::CFFIndex& local_subrs_index,
+                                    ots::Buffer *cff_table,
+                                    ots::Buffer *char_string,
+                                    std::stack<int32_t> *argument_stack,
+                                    bool *out_found_endchar,
+                                    bool *in_out_found_width,
+                                    size_t *in_out_num_stems) {
+  const size_t stack_size = argument_stack->size();
+
+  switch (op) {
+  case ots::kCallSubr:
+  case ots::kCallGSubr: {
+    const ots::CFFIndex& subrs_index =
+        (op == ots::kCallSubr ? local_subrs_index : global_subrs_index);
+
+    if (stack_size < 1) {
+      return OTS_FAILURE();
+    }
+    int32_t subr_number = argument_stack->top();
+    argument_stack->pop();
+    if (subr_number == dummy_result) {
+      // For safety, we allow subr calls only with immediate subr numbers for
+      // now. For example, we allow "123 callgsubr", but does not allow "100 12
+      // add callgsubr". Please note that arithmetic and conditional operators
+      // always push the |dummy_result| in this implementation.
+      return OTS_FAILURE();
+    }
+
+    // See Adobe Technical Note #5176 (CFF), "16. Local/GlobalSubrs INDEXes."
+    int32_t bias = 32768;
+    if (subrs_index.count < 1240) {
+      bias = 107;
+    } else if (subrs_index.count < 33900) {
+      bias = 1131;
+    }
+    subr_number += bias;
+
+    // Sanity checks of |subr_number|.
+    if (subr_number < 0) {
+      return OTS_FAILURE();
+    }
+    if (subr_number >= kMaxSubrsCount) {
+      return OTS_FAILURE();
+    }
+    if (subrs_index.offsets.size() <= static_cast<size_t>(subr_number + 1)) {
+      return OTS_FAILURE();  // The number is out-of-bounds.
+    }
+
+    // Prepare ots::Buffer where we're going to jump.
+    const size_t length =
+      subrs_index.offsets[subr_number + 1] - subrs_index.offsets[subr_number];
+    if (length > kMaxCharStringLength) {
+      return OTS_FAILURE();
+    }
+    const size_t offset = subrs_index.offsets[subr_number];
+    cff_table->set_offset(offset);
+    if (!cff_table->Skip(length)) {
+      return OTS_FAILURE();
+    }
+    ots::Buffer char_string_to_jump(cff_table->buffer() + offset, length);
+
+    return ExecuteType2CharString(call_depth + 1,
+                                  global_subrs_index,
+                                  local_subrs_index,
+                                  cff_table,
+                                  &char_string_to_jump,
+                                  argument_stack,
+                                  out_found_endchar,
+                                  in_out_found_width,
+                                  in_out_num_stems);
+  }
+
+  case ots::kReturn:
+    return true;
+
+  case ots::kEndChar:
+    *out_found_endchar = true;
+    *in_out_found_width = true;  // just in case.
+    return true;
+
+  case ots::kHStem:
+  case ots::kVStem:
+  case ots::kHStemHm:
+  case ots::kVStemHm: {
+    bool successful = false;
+    if (stack_size < 2) {
+      return OTS_FAILURE();
+    }
+    if ((stack_size % 2) == 0) {
+      successful = true;
+    } else if ((!(*in_out_found_width)) && (((stack_size - 1) % 2) == 0)) {
+      // The -1 is for "width" argument. For details, see Adobe Technical Note
+      // #5177, page 16, note 4.
+      successful = true;
+    }
+    (*in_out_num_stems) += (stack_size / 2);
+    if ((*in_out_num_stems) > kMaxNumberOfStemHints) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    *in_out_found_width = true;  // always set true since "w" might be 0 byte.
+    return successful ? true : OTS_FAILURE();
+  }
+
+  case ots::kRMoveTo: {
+    bool successful = false;
+    if (stack_size == 2) {
+      successful = true;
+    } else if ((!(*in_out_found_width)) && (stack_size - 1 == 2)) {
+      successful = true;
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    *in_out_found_width = true;
+    return successful ? true : OTS_FAILURE();
+  }
+
+  case ots::kVMoveTo:
+  case ots::kHMoveTo: {
+    bool successful = false;
+    if (stack_size == 1) {
+      successful = true;
+    } else if ((!(*in_out_found_width)) && (stack_size - 1 == 1)) {
+      successful = true;
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    *in_out_found_width = true;
+    return successful ? true : OTS_FAILURE();
+  }
+
+  case ots::kHintMask:
+  case ots::kCntrMask: {
+    bool successful = false;
+    if (stack_size == 0) {
+      successful = true;
+    } else if ((!(*in_out_found_width)) && (stack_size == 1)) {
+      // A number for "width" is found.
+      successful = true;
+    } else if ((!(*in_out_found_width)) ||  // in this case, any sizes are ok.
+               ((stack_size % 2) == 0)) {
+      // The numbers are vstem definition.
+      // See Adobe Technical Note #5177, page 24, hintmask.
+      (*in_out_num_stems) += (stack_size / 2);
+      if ((*in_out_num_stems) > kMaxNumberOfStemHints) {
+        return OTS_FAILURE();
+      }
+      successful = true;
+    }
+    if (!successful) {
+       return OTS_FAILURE();
+    }
+
+    if ((*in_out_num_stems) == 0) {
+      return OTS_FAILURE();
+    }
+    const size_t mask_bytes = (*in_out_num_stems + 7) / 8;
+    if (!char_string->Skip(mask_bytes)) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    *in_out_found_width = true;
+    return true;
+  }
+
+  case ots::kRLineTo:
+    if (!(*in_out_found_width)) {
+      // The first stack-clearing operator should be one of hstem, hstemhm,
+      // vstem, vstemhm, cntrmask, hintmask, hmoveto, vmoveto, rmoveto, or
+      // endchar. For details, see Adobe Technical Note #5177, page 16, note 4.
+      return OTS_FAILURE();
+    }
+    if (stack_size < 2) {
+      return OTS_FAILURE();
+    }
+    if ((stack_size % 2) != 0) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kHLineTo:
+  case ots::kVLineTo:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 1) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kRRCurveTo:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 6) {
+      return OTS_FAILURE();
+    }
+    if ((stack_size % 6) != 0) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kRCurveLine:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 8) {
+      return OTS_FAILURE();
+    }
+    if (((stack_size - 2) % 6) != 0) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kRLineCurve:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 8) {
+      return OTS_FAILURE();
+    }
+    if (((stack_size - 6) % 2) != 0) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kVVCurveTo:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 4) {
+      return OTS_FAILURE();
+    }
+    if (((stack_size % 4) != 0) &&
+        (((stack_size - 1) % 4) != 0)) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kHHCurveTo: {
+    bool successful = false;
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 4) {
+      return OTS_FAILURE();
+    }
+    if ((stack_size % 4) == 0) {
+      // {dxa dxb dyb dxc}+
+      successful = true;
+    } else if (((stack_size - 1) % 4) == 0) {
+      // dy1? {dxa dxb dyb dxc}+
+      successful = true;
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return successful ? true : OTS_FAILURE();
+  }
+
+  case ots::kVHCurveTo:
+  case ots::kHVCurveTo: {
+    bool successful = false;
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size < 4) {
+      return OTS_FAILURE();
+    }
+    if (((stack_size - 4) % 8) == 0) {
+      // dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}*
+      successful = true;
+    } else if ((stack_size >= 5) &&
+               ((stack_size - 5) % 8) == 0) {
+      // dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf
+      successful = true;
+    } else if ((stack_size >= 8) &&
+               ((stack_size - 8) % 8) == 0) {
+      // {dxa dxb dyb dyc dyd dxe dye dxf}+
+      successful = true;
+    } else if ((stack_size >= 9) &&
+               ((stack_size - 9) % 8) == 0) {
+      // {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf?
+      successful = true;
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return successful ? true : OTS_FAILURE();
+  }
+
+  case ots::kAnd:
+  case ots::kOr:
+  case ots::kEq:
+  case ots::kAdd:
+  case ots::kSub:
+    if (stack_size < 2) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kNot:
+  case ots::kAbs:
+  case ots::kNeg:
+    if (stack_size < 1) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kDiv:
+    // TODO(yusukes): Should detect div-by-zero errors.
+    if (stack_size < 2) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kDrop:
+    if (stack_size < 1) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    return true;
+
+  case ots::kPut:
+  case ots::kGet:
+  case ots::kIndex:
+    // For now, just call OTS_FAILURE since there is no way to check whether the
+    // index argument, |i|, is out-of-bounds or not. Fortunately, no OpenType
+    // fonts I have (except malicious ones!) use the operators.
+    // TODO(yusukes): Implement them in a secure way.
+    return OTS_FAILURE();
+
+  case ots::kRoll:
+    // Likewise, just call OTS_FAILURE for kRoll since there is no way to check
+    // whether |N| is smaller than the current stack depth or not.
+    // TODO(yusukes): Implement them in a secure way.
+    return OTS_FAILURE();
+
+  case ots::kRandom:
+    // For now, we don't handle the 'random' operator since the operator makes
+    // it hard to analyze hinting code statically.
+    return OTS_FAILURE();
+
+  case ots::kIfElse:
+    if (stack_size < 4) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kMul:
+    // TODO(yusukes): Should detect overflows.
+    if (stack_size < 2) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kSqrt:
+    // TODO(yusukes): Should check if the argument is negative.
+    if (stack_size < 1) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kDup:
+    if (stack_size < 1) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    argument_stack->push(dummy_result);
+    if (argument_stack->size() > kMaxArgumentStack) {
+      return OTS_FAILURE();
+    }
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kExch:
+    if (stack_size < 2) {
+      return OTS_FAILURE();
+    }
+    argument_stack->pop();
+    argument_stack->pop();
+    argument_stack->push(dummy_result);
+    argument_stack->push(dummy_result);
+    // TODO(yusukes): Implement this. We should push a real value for all
+    // arithmetic and conditional operations.
+    return true;
+
+  case ots::kHFlex:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size != 7) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kFlex:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size != 13) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kHFlex1:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size != 9) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+
+  case ots::kFlex1:
+    if (!(*in_out_found_width)) {
+      return OTS_FAILURE();
+    }
+    if (stack_size != 11) {
+      return OTS_FAILURE();
+    }
+    while (!argument_stack->empty())
+      argument_stack->pop();
+    return true;
+  }
+
+  OTS_WARNING("Undefined operator: %d (0x%x)", op, op);
+  return OTS_FAILURE();
+}
+
+// Executes |char_string| and updates |argument_stack|.
+//
+// call_depth: The current call depth. Initial value is zero.
+// global_subrs_index: Global subroutines.
+// local_subrs_index: Local subroutines for the current glyph.
+// cff_table: A whole CFF table which contains all global and local subroutines.
+// char_string: A charstring we'll execute. |char_string| can be a main routine
+//              in CharString INDEX, or a subroutine in GlobalSubr/LocalSubr.
+// argument_stack: The stack which an operator in |char_string| operates.
+// out_found_endchar: true is set if |char_string| contains 'endchar'.
+// in_out_found_width: true is set if |char_string| contains 'width' byte (which
+//                     is 0 or 1 byte.)
+// in_out_num_stems: total number of hstems and vstems processed so far.
+bool ExecuteType2CharString(size_t call_depth,
+                            const ots::CFFIndex& global_subrs_index,
+                            const ots::CFFIndex& local_subrs_index,
+                            ots::Buffer *cff_table,
+                            ots::Buffer *char_string,
+                            std::stack<int32_t> *argument_stack,
+                            bool *out_found_endchar,
+                            bool *in_out_found_width,
+                            size_t *in_out_num_stems) {
+  if (call_depth > kMaxSubrNesting) {
+    return OTS_FAILURE();
+  }
+  *out_found_endchar = false;
+
+  const size_t length = char_string->length();
+  while (char_string->offset() < length) {
+    int32_t operator_or_operand = 0;
+    bool is_operator = false;
+    if (!ReadNextNumberFromType2CharString(char_string,
+                                           &operator_or_operand,
+                                           &is_operator)) {
+      return OTS_FAILURE();
+    }
+
+    /*
+      You can dump all operators and operands (except mask bytes for hintmask
+      and cntrmask) by the following code:
+
+      if (!is_operator) {
+        std::fprintf(stderr, "#%d# ", operator_or_operand);
+      } else {
+        std::fprintf(stderr, "#%s#\n",
+           Type2CharStringOperatorToString(
+               Type2CharStringOperator(operator_or_operand)),
+           operator_or_operand);
+      }
+    */
+
+    if (!is_operator) {
+      argument_stack->push(operator_or_operand);
+      if (argument_stack->size() > kMaxArgumentStack) {
+        return OTS_FAILURE();
+      }
+      continue;
+    }
+
+    // An operator is found. Execute it.
+    if (!ExecuteType2CharStringOperator(operator_or_operand,
+                                        call_depth,
+                                        global_subrs_index,
+                                        local_subrs_index,
+                                        cff_table,
+                                        char_string,
+                                        argument_stack,
+                                        out_found_endchar,
+                                        in_out_found_width,
+                                        in_out_num_stems)) {
+      return OTS_FAILURE();
+    }
+    if (*out_found_endchar) {
+      return true;
+    }
+    if (operator_or_operand == ots::kReturn) {
+      return true;
+    }
+  }
+
+  // No endchar operator is found.
+  return OTS_FAILURE();
+}
+
+// Selects a set of subroutings for |glyph_index| from |cff| and sets it on
+// |out_local_subrs_to_use|. Returns true on success.
+bool SelectLocalSubr(const std::map<uint16_t, uint8_t> &fd_select,
+                     const std::vector<ots::CFFIndex *> &local_subrs_per_font,
+                     const ots::CFFIndex *local_subrs,
+                     uint16_t glyph_index,  // 0-origin
+                     const ots::CFFIndex **out_local_subrs_to_use) {
+  *out_local_subrs_to_use = NULL;
+
+  // First, find local subrs from |local_subrs_per_font|.
+  if ((fd_select.size() > 0) &&
+      (!local_subrs_per_font.empty())) {
+    // Look up FDArray index for the glyph.
+    std::map<uint16_t, uint8_t>::const_iterator iter =
+        fd_select.find(glyph_index);
+    if (iter == fd_select.end()) {
+      return OTS_FAILURE();
+    }
+    const uint8_t fd_index = iter->second;
+    if (fd_index >= local_subrs_per_font.size()) {
+      return OTS_FAILURE();
+    }
+    *out_local_subrs_to_use = local_subrs_per_font.at(fd_index);
+  } else if (local_subrs) {
+    // Second, try to use |local_subrs|. Most Latin fonts don't have FDSelect
+    // entries. If The font has a local subrs index associated with the Top
+    // DICT (not FDArrays), use it.
+    *out_local_subrs_to_use = local_subrs;
+  } else {
+    // Just return NULL.
+    *out_local_subrs_to_use = NULL;
+  }
+
+  return true;
+}
+
+}  // namespace
+
+namespace ots {
+
+bool ValidateType2CharStringIndex(
+    const CFFIndex& char_strings_index,
+    const CFFIndex& global_subrs_index,
+    const std::map<uint16_t, uint8_t> &fd_select,
+    const std::vector<CFFIndex *> &local_subrs_per_font,
+    const CFFIndex *local_subrs,
+    Buffer* cff_table) {
+  if (char_strings_index.offsets.size() == 0) {
+    return OTS_FAILURE();  // no charstring.
+  }
+
+  // For each glyph, validate the corresponding charstring.
+  for (unsigned i = 1; i < char_strings_index.offsets.size(); ++i) {
+    // Prepare a Buffer object, |char_string|, which contains the charstring
+    // for the |i|-th glyph.
+    const size_t length =
+      char_strings_index.offsets[i] - char_strings_index.offsets[i - 1];
+    if (length > kMaxCharStringLength) {
+      return OTS_FAILURE();
+    }
+    const size_t offset = char_strings_index.offsets[i - 1];
+    cff_table->set_offset(offset);
+    if (!cff_table->Skip(length)) {
+      return OTS_FAILURE();
+    }
+    Buffer char_string(cff_table->buffer() + offset, length);
+
+    // Get a local subrs for the glyph.
+    const unsigned glyph_index = i - 1;  // index in the map is 0-origin.
+    const CFFIndex *local_subrs_to_use = NULL;
+    if (!SelectLocalSubr(fd_select,
+                         local_subrs_per_font,
+                         local_subrs,
+                         glyph_index,
+                         &local_subrs_to_use)) {
+      return OTS_FAILURE();
+    }
+    // If |local_subrs_to_use| is still NULL, use an empty one.
+    CFFIndex default_empty_subrs;
+    if (!local_subrs_to_use){
+      local_subrs_to_use = &default_empty_subrs;
+    }
+
+    // Check a charstring for the |i|-th glyph.
+    std::stack<int32_t> argument_stack;
+    bool found_endchar = false;
+    bool found_width = false;
+    size_t num_stems = 0;
+    if (!ExecuteType2CharString(0 /* initial call_depth is zero */,
+                                global_subrs_index, *local_subrs_to_use,
+                                cff_table, &char_string, &argument_stack,
+                                &found_endchar, &found_width, &num_stems)) {
+      return OTS_FAILURE();
+    }
+    if (!found_endchar) {
+      return OTS_FAILURE();
+    }
+  }
+  return true;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cff_type2_charstring.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cff_type2_charstring.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,100 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_CFF_TYPE2_CHARSTRING_H_
+#define OTS_CFF_TYPE2_CHARSTRING_H_
+
+#include "cff.h"
+#include "ots.h"
+
+#include <map>
+#include <vector>
+
+namespace ots {
+
+// Validates all charstrings in |char_strings_index|. Charstring is a small
+// language for font hinting defined in Adobe Technical Note #5177.
+// http://www.adobe.com/devnet/font/pdfs/5177.Type2.pdf
+//
+// The validation will fail if one of the following conditions is met:
+//  1. The code uses more than 48 values of argument stack.
+//  2. The code uses deeply nested subroutine calls (more than 10 levels.)
+//  3. The code passes invalid number of operands to an operator.
+//  4. The code calls an undefined global or local subroutine.
+//  5. The code uses one of the following operators that are unlikely used in
+//     an ordinary fonts, and could be dangerous: random, put, get, index, roll.
+//
+// Arguments:
+//  global_subrs_index: Global subroutines which could be called by a charstring
+//                      in |char_strings_index|.
+//  fd_select: A map from glyph # to font #.
+//  local_subrs_per_font: A list of Local Subrs associated with FDArrays. Can be
+//                        empty.
+//  local_subrs: A Local Subrs associated with Top DICT. Can be NULL.
+//  cff_table: A buffer which contains actual byte code of charstring, global
+//             subroutines and local subroutines.
+bool ValidateType2CharStringIndex(
+    const CFFIndex &char_strings_index,
+    const CFFIndex &global_subrs_index,
+    const std::map<uint16_t, uint8_t> &fd_select,
+    const std::vector<CFFIndex *> &local_subrs_per_font,
+    const CFFIndex *local_subrs,
+    Buffer *cff_table);
+
+// The list of Operators. See Appendix. A in Adobe Technical Note #5177.
+enum Type2CharStringOperator {
+  kHStem = 1,
+  kVStem = 3,
+  kVMoveTo = 4,
+  kRLineTo = 5,
+  kHLineTo = 6,
+  kVLineTo = 7,
+  kRRCurveTo = 8,
+  kCallSubr = 10,
+  kReturn = 11,
+  kEndChar = 14,
+  kHStemHm = 18,
+  kHintMask = 19,
+  kCntrMask = 20,
+  kRMoveTo = 21,
+  kHMoveTo = 22,
+  kVStemHm = 23,
+  kRCurveLine = 24,
+  kRLineCurve = 25,
+  kVVCurveTo = 26,
+  kHHCurveTo = 27,
+  kCallGSubr = 29,
+  kVHCurveTo = 30,
+  kHVCurveTo = 31,
+  kAnd = (12 << 8) + 3,
+  kOr = (12 << 8) + 4,
+  kNot = (12 << 8) + 5,
+  kAbs = (12 << 8) + 9,
+  kAdd = (12 << 8) + 10,
+  kSub = (12 << 8) + 11,
+  kDiv = (12 << 8) + 12,
+  kNeg = (12 << 8) + 14,
+  kEq = (12 << 8) + 15,
+  kDrop = (12 << 8) + 18,
+  kPut = (12 << 8) + 20,
+  kGet = (12 << 8) + 21,
+  kIfElse = (12 << 8) + 22,
+  kRandom = (12 << 8) + 23,
+  kMul = (12 << 8) + 24,
+  kSqrt = (12 << 8) + 26,
+  kDup = (12 << 8) + 27,
+  kExch = (12 << 8) + 28,
+  kIndex = (12 << 8) + 29,
+  kRoll = (12 << 8) + 30,
+  kHFlex = (12 << 8) + 34,
+  kFlex = (12 << 8) + 35,
+  kHFlex1 = (12 << 8) + 36,
+  kFlex1 = (12 << 8) + 37
+  // Operators that are obsoleted or undocumented, such as 'blend', will be
+  // rejected.
+};
+
+}  // namespace ots
+
+#endif  // OTS_CFF_TYPE2_CHARSTRING_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cmap.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cmap.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,963 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cmap.h"
+
+#include <set>
+#include <utility>
+#include <vector>
+
+#include "maxp.h"
+#include "os2.h"
+
+// cmap - Character To Glyph Index Mapping Table
+// http://www.microsoft.com/opentype/otspec/cmap.htm
+
+namespace {
+
+struct CMAPSubtableHeader {
+  uint16_t platform;
+  uint16_t encoding;
+  uint32_t offset;
+  uint16_t format;
+  uint32_t length;
+};
+
+struct Subtable314Range {
+  uint16_t start_range;
+  uint16_t end_range;
+  int16_t id_delta;
+  uint16_t id_range_offset;
+  uint32_t id_range_offset_offset;
+};
+
+// The maximum number of groups in format 12 or 13 subtables.
+// Note: 0xFFFF is the maximum number of glyphs in a single font file.
+const unsigned kMaxCMAPGroups = 0xFFFF;
+
+// Glyph array size for the Mac Roman (format 0) table.
+const size_t kFormat0ArraySize = 256;
+
+// The upper limit of the Unicode code point.
+const uint32_t kUnicodeUpperLimit = 0x10FFFF;
+
+// Parses either 3.0.4 or 3.1.4 tables.
+bool Parse3x4(ots::OpenTypeFile *file, int encoding,
+              const uint8_t *data, size_t length, uint16_t num_glyphs) {
+  ots::Buffer subtable(data, length);
+
+  // 3.0.4 or 3.1.4 subtables are complex and, rather than expanding the
+  // whole thing and recompacting it, we validate it and include it verbatim
+  // in the output.
+
+  if (!file->os2) {
+    return OTS_FAILURE();
+  }
+
+  if (!subtable.Skip(4)) {
+    return OTS_FAILURE();
+  }
+  uint16_t language = 0;
+  if (!subtable.ReadU16(&language)) {
+    return OTS_FAILURE();
+  }
+  if (language) {
+    // Platform ID 3 (windows) subtables should have language '0'.
+    return OTS_FAILURE();
+  }
+
+  uint16_t segcountx2, search_range, entry_selector, range_shift;
+  segcountx2 = search_range = entry_selector = range_shift = 0;
+  if (!subtable.ReadU16(&segcountx2) ||
+      !subtable.ReadU16(&search_range) ||
+      !subtable.ReadU16(&entry_selector) ||
+      !subtable.ReadU16(&range_shift)) {
+    return OTS_FAILURE();
+  }
+
+  if (segcountx2 & 1 || search_range & 1) {
+    return OTS_FAILURE();
+  }
+  const uint16_t segcount = segcountx2 >> 1;
+  // There must be at least one segment according the spec.
+  if (segcount < 1) {
+    return OTS_FAILURE();
+  }
+
+  // log2segcount is the maximal x s.t. 2^x < segcount
+  unsigned log2segcount = 0;
+  while (1u << (log2segcount + 1) <= segcount) {
+    log2segcount++;
+  }
+
+  const uint16_t expected_search_range = 2 * 1u << log2segcount;
+  if (expected_search_range != search_range) {
+    return OTS_FAILURE();
+  }
+
+  if (entry_selector != log2segcount) {
+    return OTS_FAILURE();
+  }
+
+  const uint16_t expected_range_shift = segcountx2 - search_range;
+  if (range_shift != expected_range_shift) {
+    return OTS_FAILURE();
+  }
+
+  std::vector<Subtable314Range> ranges(segcount);
+
+  for (unsigned i = 0; i < segcount; ++i) {
+    if (!subtable.ReadU16(&ranges[i].end_range)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  uint16_t padding;
+  if (!subtable.ReadU16(&padding)) {
+    return OTS_FAILURE();
+  }
+  if (padding) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < segcount; ++i) {
+    if (!subtable.ReadU16(&ranges[i].start_range)) {
+      return OTS_FAILURE();
+    }
+  }
+  for (unsigned i = 0; i < segcount; ++i) {
+    if (!subtable.ReadS16(&ranges[i].id_delta)) {
+      return OTS_FAILURE();
+    }
+  }
+  for (unsigned i = 0; i < segcount; ++i) {
+    ranges[i].id_range_offset_offset = subtable.offset();
+    if (!subtable.ReadU16(&ranges[i].id_range_offset)) {
+      return OTS_FAILURE();
+    }
+
+    if (ranges[i].id_range_offset & 1) {
+      // Some font generators seem to put 65535 on id_range_offset
+      // for 0xFFFF-0xFFFF range.
+      // (e.g., many fonts in http://www.princexml.com/fonts/)
+      if (i == segcount - 1u) {
+        OTS_WARNING("bad id_range_offset");
+        ranges[i].id_range_offset = 0;
+        // The id_range_offset value in the transcoded font will not change
+        // since this table is not actually "transcoded" yet.
+      } else {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  // ranges must be ascending order, based on the end_code. Ranges may not
+  // overlap.
+  for (unsigned i = 1; i < segcount; ++i) {
+    if ((i == segcount - 1u) &&
+        (ranges[i - 1].start_range == 0xffff) &&
+        (ranges[i - 1].end_range == 0xffff) &&
+        (ranges[i].start_range == 0xffff) &&
+        (ranges[i].end_range == 0xffff)) {
+      // Some fonts (e.g., Germania.ttf) have multiple 0xffff terminators.
+      // We'll accept them as an exception.
+      OTS_WARNING("multiple 0xffff terminators found");
+      continue;
+    }
+
+    // Note: some Linux fonts (e.g., LucidaSansOblique.ttf, bsmi00lp.ttf) have
+    // unsorted table...
+    if (ranges[i].end_range <= ranges[i - 1].end_range) {
+      return OTS_FAILURE();
+    }
+    if (ranges[i].start_range <= ranges[i - 1].end_range) {
+      return OTS_FAILURE();
+    }
+
+    // On many fonts, the value of {first, last}_char_index are incorrect.
+    // Fix them.
+    if (file->os2->first_char_index != 0xFFFF &&
+        ranges[i].start_range != 0xFFFF &&
+        file->os2->first_char_index > ranges[i].start_range) {
+      file->os2->first_char_index = ranges[i].start_range;
+    }
+    if (file->os2->last_char_index != 0xFFFF &&
+        ranges[i].end_range != 0xFFFF &&
+        file->os2->last_char_index < ranges[i].end_range) {
+      file->os2->last_char_index = ranges[i].end_range;
+    }
+  }
+
+  // The last range must end at 0xffff
+  if (ranges[segcount - 1].end_range != 0xffff) {
+    return OTS_FAILURE();
+  }
+
+  // A format 4 CMAP subtable is complex. To be safe we simulate a lookup of
+  // each code-point defined in the table and make sure that they are all valid
+  // glyphs and that we don't access anything out-of-bounds.
+  for (unsigned i = 1; i < segcount; ++i) {
+    for (unsigned cp = ranges[i].start_range; cp <= ranges[i].end_range; ++cp) {
+      const uint16_t code_point = cp;
+      if (ranges[i].id_range_offset == 0) {
+        // this is explictly allowed to overflow in the spec
+        const uint16_t glyph = code_point + ranges[i].id_delta;
+        if (glyph >= num_glyphs) {
+          return OTS_FAILURE();
+        }
+      } else {
+        const uint16_t range_delta = code_point - ranges[i].start_range;
+        // this might seem odd, but it's true. The offset is relative to the
+        // location of the offset value itself.
+        const uint32_t glyph_id_offset = ranges[i].id_range_offset_offset +
+                                         ranges[i].id_range_offset +
+                                         range_delta * 2;
+        // We need to be able to access a 16-bit value from this offset
+        if (glyph_id_offset + 1 >= length) {
+          return OTS_FAILURE();
+        }
+        uint16_t glyph;
+        memcpy(&glyph, data + glyph_id_offset, 2);
+        glyph = ntohs(glyph);
+        if (glyph >= num_glyphs) {
+          return OTS_FAILURE();
+        }
+      }
+    }
+  }
+
+  // We accept the table.
+  // TODO(yusukes): transcode the subtable.
+  if (encoding == 0) {
+    file->cmap->subtable_3_0_4_data = data;
+    file->cmap->subtable_3_0_4_length = length;
+  } else if (encoding == 1) {
+    file->cmap->subtable_3_1_4_data = data;
+    file->cmap->subtable_3_1_4_length = length;
+  } else {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+bool Parse31012(ots::OpenTypeFile *file,
+                const uint8_t *data, size_t length, uint16_t num_glyphs) {
+  ots::Buffer subtable(data, length);
+
+  // Format 12 tables are simple. We parse these and fully serialise them
+  // later.
+
+  if (!subtable.Skip(8)) {
+    return OTS_FAILURE();
+  }
+  uint32_t language = 0;
+  if (!subtable.ReadU32(&language)) {
+    return OTS_FAILURE();
+  }
+  if (language) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t num_groups = 0;
+  if (!subtable.ReadU32(&num_groups)) {
+    return OTS_FAILURE();
+  }
+  if (num_groups == 0 || num_groups > kMaxCMAPGroups) {
+    return OTS_FAILURE();
+  }
+
+  std::vector<ots::OpenTypeCMAPSubtableRange> &groups
+      = file->cmap->subtable_3_10_12;
+  groups.resize(num_groups);
+
+  for (unsigned i = 0; i < num_groups; ++i) {
+    if (!subtable.ReadU32(&groups[i].start_range) ||
+        !subtable.ReadU32(&groups[i].end_range) ||
+        !subtable.ReadU32(&groups[i].start_glyph_id)) {
+      return OTS_FAILURE();
+    }
+
+    if (groups[i].start_range > kUnicodeUpperLimit ||
+        groups[i].end_range > kUnicodeUpperLimit ||
+        groups[i].start_glyph_id > 0xFFFF) {
+      return OTS_FAILURE();
+    }
+
+    // [0xD800, 0xDFFF] are surrogate code points.
+    if (groups[i].start_range >= 0xD800 &&
+        groups[i].start_range <= 0xDFFF) {
+      return OTS_FAILURE();
+    }
+    if (groups[i].end_range >= 0xD800 &&
+        groups[i].end_range <= 0xDFFF) {
+      return OTS_FAILURE();
+    }
+    if (groups[i].start_range < 0xD800 &&
+        groups[i].end_range > 0xDFFF) {
+      return OTS_FAILURE();
+    }
+
+    // We assert that the glyph value is within range. Because of the range
+    // limits, above, we don't need to worry about overflow.
+    if (groups[i].end_range < groups[i].start_range) {
+      return OTS_FAILURE();
+    }
+    if ((groups[i].end_range - groups[i].start_range) +
+        groups[i].start_glyph_id > num_glyphs) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // the groups must be sorted by start code and may not overlap
+  for (unsigned i = 1; i < num_groups; ++i) {
+    if (groups[i].start_range <= groups[i - 1].start_range) {
+      return OTS_FAILURE();
+    }
+    if (groups[i].start_range <= groups[i - 1].end_range) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+bool Parse31013(ots::OpenTypeFile *file,
+                const uint8_t *data, size_t length, uint16_t num_glyphs) {
+  ots::Buffer subtable(data, length);
+
+  // Format 13 tables are simple. We parse these and fully serialise them
+  // later.
+
+  if (!subtable.Skip(8)) {
+    return OTS_FAILURE();
+  }
+  uint16_t language = 0;
+  if (!subtable.ReadU16(&language)) {
+    return OTS_FAILURE();
+  }
+  if (language) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t num_groups = 0;
+  if (!subtable.ReadU32(&num_groups)) {
+    return OTS_FAILURE();
+  }
+
+  // We limit the number of groups in the same way as in 3.10.12 tables. See
+  // the comment there in
+  if (num_groups == 0 || num_groups > kMaxCMAPGroups) {
+    return OTS_FAILURE();
+  }
+
+  std::vector<ots::OpenTypeCMAPSubtableRange> &groups
+      = file->cmap->subtable_3_10_13;
+  groups.resize(num_groups);
+
+  for (unsigned i = 0; i < num_groups; ++i) {
+    if (!subtable.ReadU32(&groups[i].start_range) ||
+        !subtable.ReadU32(&groups[i].end_range) ||
+        !subtable.ReadU32(&groups[i].start_glyph_id)) {
+      return OTS_FAILURE();
+    }
+
+    // We conservatively limit all of the values to protect some parsers from
+    // overflows
+    if (groups[i].start_range > kUnicodeUpperLimit ||
+        groups[i].end_range > kUnicodeUpperLimit ||
+        groups[i].start_glyph_id > 0xFFFF) {
+      return OTS_FAILURE();
+    }
+
+    if (groups[i].start_glyph_id >= num_glyphs) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // the groups must be sorted by start code and may not overlap
+  for (unsigned i = 1; i < num_groups; ++i) {
+    if (groups[i].start_range <= groups[i - 1].start_range) {
+      return OTS_FAILURE();
+    }
+    if (groups[i].start_range <= groups[i - 1].end_range) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+// Parses 0.5.14 tables.
+bool Parse0514(ots::OpenTypeFile *file,
+               const uint8_t *data, size_t length, uint16_t num_glyphs) {
+  ots::Buffer subtable(data, length);
+
+  // Format 14 subtables are a bit complex, so rather than rebuilding the
+  // entire thing, we validate it and then include it verbatim in the output.
+
+  const off_t offset_var_selector_records = 10;
+  const size_t size_of_var_selector_record = 11;
+
+  if (!subtable.Skip(6)) { // skip format and length
+    return OTS_FAILURE();
+  }
+  uint32_t num_var_selector_records = 0;
+  if (!subtable.ReadU32(&num_var_selector_records)) {
+    return OTS_FAILURE();
+  }
+  if ((length - offset_var_selector_records) / size_of_var_selector_record <
+      num_var_selector_records) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t prev_var_selector = 0;
+  for (uint32_t i = 0; i < num_var_selector_records; i++) {
+    uint32_t var_selector = 0, def_uvs_offset = 0, non_def_uvs_offset = 0;
+    if (!subtable.ReadU24(&var_selector) ||
+        !subtable.ReadU32(&def_uvs_offset) ||
+        !subtable.ReadU32(&non_def_uvs_offset)) {
+      return OTS_FAILURE();
+    }
+    if (var_selector <= prev_var_selector ||
+        var_selector > kUnicodeUpperLimit ||
+        def_uvs_offset > length - 4 ||
+        non_def_uvs_offset > length - 4) {
+      return OTS_FAILURE();
+    }
+    prev_var_selector = var_selector;
+
+    if (def_uvs_offset) {
+      ots::Buffer uvs_table(data + def_uvs_offset, length - def_uvs_offset);
+      uint32_t num_unicode_value_ranges = 0;
+      if (!uvs_table.ReadU32(&num_unicode_value_ranges)) {
+        return OTS_FAILURE();
+      }
+
+      uint32_t prev_end_unicode = 0;
+      for (uint32_t j = 0; j < num_unicode_value_ranges; j++) {
+        uint32_t start_unicode = 0, end_unicode;
+        uint8_t additional = 0;
+        if (!uvs_table.ReadU24(&start_unicode) ||
+            !uvs_table.ReadU8(&additional)) {
+          return OTS_FAILURE();
+        }
+        end_unicode = start_unicode + additional;
+        if ((j > 0 && start_unicode <= prev_end_unicode) ||
+            end_unicode > kUnicodeUpperLimit) {
+          return OTS_FAILURE();
+        }
+        prev_end_unicode = end_unicode;
+      }
+    }
+
+    if (non_def_uvs_offset) {
+      ots::Buffer uvs_table(data + non_def_uvs_offset,
+                            length - non_def_uvs_offset);
+      uint32_t num_uvs_mappings = 0;
+      if (!uvs_table.ReadU32(&num_uvs_mappings)) {
+        return OTS_FAILURE();
+      }
+
+      uint32_t prev_unicode = 0;
+      for (uint32_t j = 0; j < num_uvs_mappings; j++) {
+        uint32_t unicode_value = 0;
+        if (!uvs_table.ReadU24(&unicode_value)) {
+          return OTS_FAILURE();
+        }
+        if ((j > 0 && unicode_value <= prev_unicode) ||
+            unicode_value > kUnicodeUpperLimit) {
+          return OTS_FAILURE();
+        }
+        uint16_t glyph = 0;
+        if (!uvs_table.ReadU16(&glyph)) {
+          return OTS_FAILURE();
+        }
+        if (glyph >= num_glyphs) {
+          return OTS_FAILURE();
+        }
+        prev_unicode = unicode_value;
+      }
+    }
+  }
+
+  // We accept the table.
+  // TODO: transcode the subtable.
+  file->cmap->subtable_0_5_14_data = data;
+  file->cmap->subtable_0_5_14_length = length;
+
+  return true;
+}
+
+bool Parse100(ots::OpenTypeFile *file, const uint8_t *data, size_t length) {
+  // Mac Roman table
+  ots::Buffer subtable(data, length);
+
+  if (!subtable.Skip(4)) {
+    return OTS_FAILURE();
+  }
+  uint16_t language = 0;
+  if (!subtable.ReadU16(&language)) {
+    return OTS_FAILURE();
+  }
+  if (language) {
+    // simsun.ttf has non-zero language id.
+    OTS_WARNING("language id should be zero: %u", language);
+  }
+
+  file->cmap->subtable_1_0_0.reserve(kFormat0ArraySize);
+  for (size_t i = 0; i < kFormat0ArraySize; ++i) {
+    uint8_t glyph_id = 0;
+    if (!subtable.ReadU8(&glyph_id)) {
+      return OTS_FAILURE();
+    }
+    file->cmap->subtable_1_0_0.push_back(glyph_id);
+  }
+
+  return true;
+}
+
+}  // namespace
+
+namespace ots {
+
+bool ots_cmap_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  file->cmap = new OpenTypeCMAP;
+
+  uint16_t version = 0;
+  uint16_t num_tables = 0;
+  if (!table.ReadU16(&version) ||
+      !table.ReadU16(&num_tables)) {
+    return OTS_FAILURE();
+  }
+
+  if (version != 0) {
+    return OTS_FAILURE();
+  }
+  if (!num_tables) {
+    return OTS_FAILURE();
+  }
+
+  std::vector<CMAPSubtableHeader> subtable_headers;
+
+  // read the subtable headers
+  subtable_headers.reserve(num_tables);
+  for (unsigned i = 0; i < num_tables; ++i) {
+    CMAPSubtableHeader subt;
+
+    if (!table.ReadU16(&subt.platform) ||
+        !table.ReadU16(&subt.encoding) ||
+        !table.ReadU32(&subt.offset)) {
+      return OTS_FAILURE();
+    }
+
+    subtable_headers.push_back(subt);
+  }
+
+  const size_t data_offset = table.offset();
+
+  // make sure that all the offsets are valid.
+  uint32_t last_id = 0;
+  for (unsigned i = 0; i < num_tables; ++i) {
+    if (subtable_headers[i].offset > 1024 * 1024 * 1024) {
+      return OTS_FAILURE();
+    }
+    if (subtable_headers[i].offset < data_offset ||
+        subtable_headers[i].offset >= length) {
+      return OTS_FAILURE();
+    }
+
+    // check if the table is sorted first by platform ID, then by encoding ID.
+    uint32_t current_id
+        = (subtable_headers[i].platform << 16) + subtable_headers[i].encoding;
+    if ((i != 0) && (last_id >= current_id)) {
+      return OTS_FAILURE();
+    }
+    last_id = current_id;
+  }
+
+  // the format of the table is the first couple of bytes in the table. The
+  // length of the table is stored in a format-specific way.
+  for (unsigned i = 0; i < num_tables; ++i) {
+    table.set_offset(subtable_headers[i].offset);
+    if (!table.ReadU16(&subtable_headers[i].format)) {
+      return OTS_FAILURE();
+    }
+
+    uint16_t len = 0;
+    switch (subtable_headers[i].format) {
+      case 0:
+      case 4:
+        if (!table.ReadU16(&len)) {
+          return OTS_FAILURE();
+        }
+        subtable_headers[i].length = len;
+        break;
+      case 12:
+      case 13:
+        if (!table.Skip(2)) {
+          return OTS_FAILURE();
+        }
+        if (!table.ReadU32(&subtable_headers[i].length)) {
+          return OTS_FAILURE();
+        }
+        break;
+      case 14:
+        if (!table.ReadU32(&subtable_headers[i].length)) {
+          return OTS_FAILURE();
+        }
+        break;
+      default:
+        subtable_headers[i].length = 0;
+        break;
+    }
+  }
+
+  // Now, verify that all the lengths are sane
+  for (unsigned i = 0; i < num_tables; ++i) {
+    if (!subtable_headers[i].length) continue;
+    if (subtable_headers[i].length > 1024 * 1024 * 1024) {
+      return OTS_FAILURE();
+    }
+    // We know that both the offset and length are < 1GB, so the following
+    // addition doesn't overflow
+    const uint32_t end_byte
+        = subtable_headers[i].offset + subtable_headers[i].length;
+    if (end_byte > length) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // check that the cmap subtables are not overlapping.
+  std::set<std::pair<uint32_t, uint32_t> > uniq_checker;
+  std::vector<std::pair<uint32_t, uint8_t> > overlap_checker;
+  for (unsigned i = 0; i < num_tables; ++i) {
+    const uint32_t end_byte
+        = subtable_headers[i].offset + subtable_headers[i].length;
+
+    if (!uniq_checker.insert(std::make_pair(subtable_headers[i].offset,
+                                            end_byte)).second) {
+      // Sometimes Unicode table and MS table share exactly the same data.
+      // We'll allow this.
+      continue;
+    }
+    overlap_checker.push_back(
+        std::make_pair(subtable_headers[i].offset, 1 /* start */));
+    overlap_checker.push_back(
+        std::make_pair(end_byte, 0 /* end */));
+  }
+  std::sort(overlap_checker.begin(), overlap_checker.end());
+  int overlap_count = 0;
+  for (unsigned i = 0; i < overlap_checker.size(); ++i) {
+    overlap_count += (overlap_checker[i].second ? 1 : -1);
+    if (overlap_count > 1) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // we grab the number of glyphs in the file from the maxp table to make sure
+  // that the character map isn't referencing anything beyound this range.
+  if (!file->maxp) {
+    return OTS_FAILURE();
+  }
+  const uint16_t num_glyphs = file->maxp->num_glyphs;
+
+  // We only support a subset of the possible character map tables. Microsoft
+  // 'strongly recommends' that everyone supports the Unicode BMP table with
+  // the UCS-4 table for non-BMP glyphs. We'll pass the following subtables:
+  //   Platform ID   Encoding ID  Format
+  //   0             0            4       (Unicode Default)
+  //   0             3            4       (Unicode BMP)
+  //   0             3            12      (Unicode UCS-4)
+  //   0             5            14      (Unicode Variation Sequences)
+  //   1             0            0       (Mac Roman)
+  //   3             0            4       (MS Symbol)
+  //   3             1            4       (MS Unicode BMP)
+  //   3             10           12      (MS Unicode UCS-4)
+  //   3             10           13      (MS UCS-4 Fallback mapping)
+  //
+  // Note:
+  //  * 0-0-4 table is (usually) written as a 3-1-4 table. If 3-1-4 table
+  //    also exists, the 0-0-4 table is ignored.
+  //  * 0-3-4 table is written as a 3-1-4 table. If 3-1-4 table also exists,
+  //    the 0-3-4 table is ignored.
+  //  * 0-3-12 table is written as a 3-10-12 table. If 3-10-12 table also
+  //    exists, the 0-3-12 table is ignored.
+  //
+
+  for (unsigned i = 0; i < num_tables; ++i) {
+    if (subtable_headers[i].platform == 0) {
+      // Unicode platform
+
+      if ((subtable_headers[i].encoding == 0) &&
+          (subtable_headers[i].format == 4)) {
+        // parse and output the 0-0-4 table as 3-1-4 table. Sometimes the 0-0-4
+        // table actually points to MS symbol data and thus should be parsed as
+        // 3-0-4 table (e.g., marqueem.ttf and quixotic.ttf). This error will be
+        // recovered in ots_cmap_serialise().
+        if (!Parse3x4(file, 1, data + subtable_headers[i].offset,
+                      subtable_headers[i].length, num_glyphs)) {
+          return OTS_FAILURE();
+        }
+      } else if ((subtable_headers[i].encoding == 3) &&
+                 (subtable_headers[i].format == 4)) {
+        // parse and output the 0-3-4 table as 3-1-4 table.
+        if (!Parse3x4(file, 1, data + subtable_headers[i].offset,
+                      subtable_headers[i].length, num_glyphs)) {
+          return OTS_FAILURE();
+        }
+      } else if ((subtable_headers[i].encoding == 3) &&
+                 (subtable_headers[i].format == 12)) {
+        // parse and output the 0-3-12 table as 3-10-12 table.
+        if (!Parse31012(file, data + subtable_headers[i].offset,
+                        subtable_headers[i].length, num_glyphs)) {
+          return OTS_FAILURE();
+        }
+      } else if ((subtable_headers[i].encoding == 5) &&
+                 (subtable_headers[i].format == 14)) {
+        if (!Parse0514(file, data + subtable_headers[i].offset,
+                       subtable_headers[i].length, num_glyphs)) {
+          return OTS_FAILURE();
+        }
+      }
+
+    } else if (subtable_headers[i].platform == 1) {
+      // Mac platform
+
+      if ((subtable_headers[i].encoding == 0) &&
+          (subtable_headers[i].format == 0)) {
+        // parse and output the 1-0-0 table.
+        if (!Parse100(file, data + subtable_headers[i].offset,
+                      subtable_headers[i].length)) {
+          return OTS_FAILURE();
+        }
+      }
+
+    } else if (subtable_headers[i].platform == 3) {
+      // MS platform
+
+      switch (subtable_headers[i].encoding) {
+        case 0:
+        case 1:
+          if (subtable_headers[i].format == 4) {
+            // parse 3-0-4 or 3-1-4 table.
+            if (!Parse3x4(file, subtable_headers[i].encoding,
+                          data + subtable_headers[i].offset,
+                          subtable_headers[i].length, num_glyphs)) {
+              return OTS_FAILURE();
+            }
+          }
+          break;
+        case 10:
+          if (subtable_headers[i].format == 12) {
+            file->cmap->subtable_3_10_12.clear();
+            if (!Parse31012(file, data + subtable_headers[i].offset,
+                            subtable_headers[i].length, num_glyphs)) {
+              return OTS_FAILURE();
+            }
+          } else if (subtable_headers[i].format == 13) {
+            file->cmap->subtable_3_10_13.clear();
+            if (!Parse31013(file, data + subtable_headers[i].offset,
+                            subtable_headers[i].length, num_glyphs)) {
+              return OTS_FAILURE();
+            }
+          }
+          break;
+      }
+    }
+  }
+
+  return true;
+}
+
+bool ots_cmap_should_serialise(OpenTypeFile *file) {
+  return file->cmap;
+}
+
+bool ots_cmap_serialise(OTSStream *out, OpenTypeFile *file) {
+  const bool have_0514 = file->cmap->subtable_0_5_14_data;
+  const bool have_100 = file->cmap->subtable_1_0_0.size();
+  const bool have_304 = file->cmap->subtable_3_0_4_data;
+  // MS Symbol and MS Unicode tables should not co-exist.
+  // See the comment above in 0-0-4 parser.
+  const bool have_314 = (!have_304) && file->cmap->subtable_3_1_4_data;
+  const bool have_31012 = file->cmap->subtable_3_10_12.size();
+  const bool have_31013 = file->cmap->subtable_3_10_13.size();
+  const unsigned num_subtables = static_cast<unsigned>(have_0514) +
+                                 static_cast<unsigned>(have_100) +
+                                 static_cast<unsigned>(have_304) +
+                                 static_cast<unsigned>(have_314) +
+                                 static_cast<unsigned>(have_31012) +
+                                 static_cast<unsigned>(have_31013);
+  const off_t table_start = out->Tell();
+
+  // Some fonts don't have 3-0-4 MS Symbol nor 3-1-4 Unicode BMP tables
+  // (e.g., old fonts for Mac). We don't support them.
+  if (!have_304 && !have_314) {
+    return OTS_FAILURE();
+  }
+
+  if (!out->WriteU16(0) ||
+      !out->WriteU16(num_subtables)) {
+    return OTS_FAILURE();
+  }
+
+  const off_t record_offset = out->Tell();
+  if (!out->Pad(num_subtables * 8)) {
+    return OTS_FAILURE();
+  }
+
+  const off_t offset_100 = out->Tell();
+  if (have_100) {
+    if (!out->WriteU16(0) ||  // format
+        !out->WriteU16(6 + kFormat0ArraySize) ||  // length
+        !out->WriteU16(0)) {  // language
+      return OTS_FAILURE();
+    }
+    if (!out->Write(&(file->cmap->subtable_1_0_0[0]), kFormat0ArraySize)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  const off_t offset_304 = out->Tell();
+  if (have_304) {
+    if (!out->Write(file->cmap->subtable_3_0_4_data,
+                    file->cmap->subtable_3_0_4_length)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  const off_t offset_314 = out->Tell();
+  if (have_314) {
+    if (!out->Write(file->cmap->subtable_3_1_4_data,
+                    file->cmap->subtable_3_1_4_length)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  const off_t offset_31012 = out->Tell();
+  if (have_31012) {
+    std::vector<OpenTypeCMAPSubtableRange> &groups
+        = file->cmap->subtable_3_10_12;
+    const unsigned num_groups = groups.size();
+    if (!out->WriteU16(12) ||
+        !out->WriteU16(0) ||
+        !out->WriteU32(num_groups * 12 + 16) ||
+        !out->WriteU32(0) ||
+        !out->WriteU32(num_groups)) {
+      return OTS_FAILURE();
+    }
+
+    for (unsigned i = 0; i < num_groups; ++i) {
+      if (!out->WriteU32(groups[i].start_range) ||
+          !out->WriteU32(groups[i].end_range) ||
+          !out->WriteU32(groups[i].start_glyph_id)) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  const off_t offset_31013 = out->Tell();
+  if (have_31013) {
+    std::vector<OpenTypeCMAPSubtableRange> &groups
+        = file->cmap->subtable_3_10_13;
+    const unsigned num_groups = groups.size();
+    if (!out->WriteU16(13) ||
+        !out->WriteU16(0) ||
+        !out->WriteU32(num_groups * 12 + 14) ||
+        !out->WriteU32(0) ||
+        !out->WriteU32(num_groups)) {
+      return OTS_FAILURE();
+    }
+
+    for (unsigned i = 0; i < num_groups; ++i) {
+      if (!out->WriteU32(groups[i].start_range) ||
+          !out->WriteU32(groups[i].end_range) ||
+          !out->WriteU32(groups[i].start_glyph_id)) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  const off_t offset_0514 = out->Tell();
+  if (have_0514) {
+    if (!out->Write(file->cmap->subtable_0_5_14_data,
+                    file->cmap->subtable_0_5_14_length)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  const off_t table_end = out->Tell();
+  // We might have hanging bytes from the above's checksum which the OTSStream
+  // then merges into the table of offsets.
+  OTSStream::ChecksumState saved_checksum = out->SaveChecksumState();
+  out->ResetChecksum();
+
+  // Now seek back and write the table of offsets
+  if (!out->Seek(record_offset)) {
+    return OTS_FAILURE();
+  }
+
+  if (have_0514) {
+    if (!out->WriteU16(0) ||
+        !out->WriteU16(5) ||
+        !out->WriteU32(offset_0514 - table_start)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (have_100) {
+    if (!out->WriteU16(1) ||
+        !out->WriteU16(0) ||
+        !out->WriteU32(offset_100 - table_start)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (have_304) {
+    if (!out->WriteU16(3) ||
+        !out->WriteU16(0) ||
+        !out->WriteU32(offset_304 - table_start)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (have_314) {
+    if (!out->WriteU16(3) ||
+        !out->WriteU16(1) ||
+        !out->WriteU32(offset_314 - table_start)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (have_31012) {
+    if (!out->WriteU16(3) ||
+        !out->WriteU16(10) ||
+        !out->WriteU32(offset_31012 - table_start)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (have_31013) {
+    if (!out->WriteU16(3) ||
+        !out->WriteU16(10) ||
+        !out->WriteU32(offset_31013 - table_start)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (!out->Seek(table_end)) {
+    return OTS_FAILURE();
+  }
+  out->RestoreChecksum(saved_checksum);
+
+  return true;
+}
+
+void ots_cmap_free(OpenTypeFile *file) {
+  delete file->cmap;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cmap.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cmap.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,50 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_CMAP_H_
+#define OTS_CMAP_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeCMAPSubtableRange {
+  uint32_t start_range;
+  uint32_t end_range;
+  uint32_t start_glyph_id;
+};
+
+struct OpenTypeCMAP {
+  OpenTypeCMAP()
+      : subtable_3_0_4_data(NULL),
+        subtable_3_0_4_length(0),
+        subtable_3_1_4_data(NULL),
+        subtable_3_1_4_length(0),
+        subtable_0_5_14_data(NULL),
+        subtable_0_5_14_length(0) {
+  }
+
+  // Platform 3, Encoding 0, Format 4, MS Symbol table.
+  const uint8_t *subtable_3_0_4_data;
+  size_t subtable_3_0_4_length;
+  // Platform 3, Encoding 1, Format 4, MS Unicode BMP table.
+  const uint8_t *subtable_3_1_4_data;
+  size_t subtable_3_1_4_length;
+  // Platform 0, Encoding 5, Format 14, Unicode Variation Sequences table.
+  const uint8_t *subtable_0_5_14_data;
+  size_t subtable_0_5_14_length;
+
+  // Platform 3, Encoding 10, Format 12, MS Unicode UCS-4 table.
+  std::vector<OpenTypeCMAPSubtableRange> subtable_3_10_12;
+  // Platform 3, Encoding 10, Format 13, MS UCS-4 Fallback table.
+  std::vector<OpenTypeCMAPSubtableRange> subtable_3_10_13;
+  // Platform 1, Encoding 0, Format 0, Mac Roman table.
+  std::vector<uint8_t> subtable_1_0_0;
+};
+
+}  // namespace ots
+
+#endif
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cvt.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cvt.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,56 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "cvt.h"
+
+// cvt - Control Value Table
+// http://www.microsoft.com/opentype/otspec/cvt.htm
+
+namespace ots {
+
+bool ots_cvt_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeCVT *cvt = new OpenTypeCVT;
+  file->cvt = cvt;
+
+  if (length >= 128 * 1024u) {
+    return OTS_FAILURE();  // almost all cvt tables are less than 4k bytes.
+  }
+
+  if (length % 2 != 0) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.Skip(length)) {
+    return OTS_FAILURE();
+  }
+
+  cvt->data = data;
+  cvt->length = length;
+  return true;
+}
+
+bool ots_cvt_should_serialise(OpenTypeFile *file) {
+  if (!file->glyf) {
+    return false;  // this table is not for CFF fonts.
+  }
+  return g_transcode_hints && file->cvt;
+}
+
+bool ots_cvt_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeCVT *cvt = file->cvt;
+
+  if (!out->Write(cvt->data, cvt->length)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_cvt_free(OpenTypeFile *file) {
+  delete file->cvt;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/cvt.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/cvt.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,19 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_CVT_H_
+#define OTS_CVT_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeCVT {
+  const uint8_t *data;
+  uint32_t length;
+};
+
+}  // namespace ots
+
+#endif  // OTS_CVT_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/fpgm.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/fpgm.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,50 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "fpgm.h"
+
+// fpgm - Font Program
+// http://www.microsoft.com/opentype/otspec/fpgm.htm
+
+namespace ots {
+
+bool ots_fpgm_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeFPGM *fpgm = new OpenTypeFPGM;
+  file->fpgm = fpgm;
+
+  if (length >= 128 * 1024u) {
+    return OTS_FAILURE();  // almost all fpgm tables are less than 5k bytes.
+  }
+
+  if (!table.Skip(length)) {
+    return OTS_FAILURE();
+  }
+
+  fpgm->data = data;
+  fpgm->length = length;
+  return true;
+}
+
+bool ots_fpgm_should_serialise(OpenTypeFile *file) {
+  if (!file->glyf) return false;  // this table is not for CFF fonts.
+  return g_transcode_hints && file->fpgm;
+}
+
+bool ots_fpgm_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeFPGM *fpgm = file->fpgm;
+
+  if (!out->Write(fpgm->data, fpgm->length)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_fpgm_free(OpenTypeFile *file) {
+  delete file->fpgm;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/fpgm.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/fpgm.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,19 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_FPGM_H_
+#define OTS_FPGM_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeFPGM {
+  const uint8_t *data;
+  uint32_t length;
+};
+
+}  // namespace ots
+
+#endif  // OTS_FPGM_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gasp.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gasp.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,106 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gasp.h"
+
+// gasp - Grid-fitting And Scan-conversion Procedure
+// http://www.microsoft.com/opentype/otspec/gasp.htm
+
+#define DROP_THIS_TABLE \
+  do { delete file->gasp; file->gasp = 0; } while (0)
+
+namespace ots {
+
+bool ots_gasp_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeGASP *gasp = new OpenTypeGASP;
+  file->gasp = gasp;
+
+  uint16_t num_ranges = 0;
+  if (!table.ReadU16(&gasp->version) ||
+      !table.ReadU16(&num_ranges)) {
+    return OTS_FAILURE();
+  }
+
+  if (gasp->version > 1) {
+    // Lots of Linux fonts have bad version numbers...
+    OTS_WARNING("bad version: %u", gasp->version);
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  if (num_ranges == 0) {
+    OTS_WARNING("num_ranges is zero");
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  gasp->gasp_ranges.reserve(num_ranges);
+  for (unsigned i = 0; i < num_ranges; ++i) {
+    uint16_t max_ppem = 0;
+    uint16_t behavior = 0;
+    if (!table.ReadU16(&max_ppem) ||
+        !table.ReadU16(&behavior)) {
+      return OTS_FAILURE();
+    }
+    if ((i > 0) && (gasp->gasp_ranges[i - 1].first >= max_ppem)) {
+      // The records in the gaspRange[] array must be sorted in order of
+      // increasing rangeMaxPPEM value.
+      OTS_WARNING("ranges are not sorted");
+      DROP_THIS_TABLE;
+      return true;
+    }
+    if ((i == num_ranges - 1u) &&  // never underflow.
+        (max_ppem != 0xffffu)) {
+      OTS_WARNING("The last record should be 0xFFFF as a sentinel value "
+                  "for rangeMaxPPEM");
+      DROP_THIS_TABLE;
+      return true;
+    }
+
+    if (behavior >> 8) {
+      OTS_WARNING("undefined bits are used: %x", behavior);
+      // mask undefined bits.
+      behavior &= 0x000fu;
+    }
+
+    if (gasp->version == 0 && (behavior >> 2) != 0) {
+      OTS_WARNING("changed the version number to 1");
+      gasp->version = 1;
+    }
+
+    gasp->gasp_ranges.push_back(std::make_pair(max_ppem, behavior));
+  }
+
+  return true;
+}
+
+bool ots_gasp_should_serialise(OpenTypeFile *file) {
+  return file->gasp;
+}
+
+bool ots_gasp_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeGASP *gasp = file->gasp;
+
+  if (!out->WriteU16(gasp->version) ||
+      !out->WriteU16(gasp->gasp_ranges.size())) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < gasp->gasp_ranges.size(); ++i) {
+    if (!out->WriteU16(gasp->gasp_ranges[i].first) ||
+        !out->WriteU16(gasp->gasp_ranges[i].second)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_gasp_free(OpenTypeFile *file) {
+  delete file->gasp;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gasp.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gasp.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,23 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_GASP_H_
+#define OTS_GASP_H_
+
+#include <utility>  // std::pair
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeGASP {
+  uint16_t version;
+  // A array of (max PPEM, GASP behavior) pairs.
+  std::vector<std::pair<uint16_t, uint16_t> > gasp_ranges;
+};
+
+}  // namespace ots
+
+#endif  // OTS_GASP_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gdef.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gdef.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,45 @@
+// Copyright (c) 2010 Mozilla Foundation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gdef.h"
+
+// GDEF - Glyph Definition Table
+// http://www.microsoft.com/typography/otspec/gdef.htm
+
+namespace ots {
+
+bool ots_gdef_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeGDEF *gdef = new OpenTypeGDEF;
+  file->gdef = gdef;
+
+  if (!table.Skip(length)) {
+    return OTS_FAILURE();
+  }
+
+  gdef->data = data;
+  gdef->length = length;
+  return true;
+}
+
+bool ots_gdef_should_serialise(OpenTypeFile *file) {
+  return file->preserve_otl && file->gdef;
+}
+
+bool ots_gdef_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeGDEF *gdef = file->gdef;
+
+  if (!out->Write(gdef->data, gdef->length)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_gdef_free(OpenTypeFile *file) {
+  delete file->gdef;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gdef.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gdef.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,19 @@
+// Copyright (c) 2010 Mozilla Foundation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_GDEF_H_
+#define OTS_GDEF_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeGDEF {
+  const uint8_t *data;
+  uint32_t length;
+};
+
+}  // namespace ots
+
+#endif  // OTS_GDEF_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/glyf.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/glyf.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,300 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "glyf.h"
+
+#include <algorithm>
+#include <limits>
+
+#include "head.h"
+#include "loca.h"
+#include "maxp.h"
+
+// glyf - Glyph Data
+// http://www.microsoft.com/opentype/otspec/glyf.htm
+
+namespace {
+
+bool ParseFlagsForSimpleGlyph(ots::Buffer *table,
+                              uint32_t gly_length,
+                              uint32_t num_flags,
+                              uint32_t *flags_count_logical,
+                              uint32_t *flags_count_physical,
+                              uint32_t *xy_coordinates_length) {
+  uint8_t flag = 0;
+  if (!table->ReadU8(&flag)) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t delta = 0;
+  if (flag & (1u << 1)) {  // x-Short
+    ++delta;
+  } else if (!(flag & (1u << 4))) {
+    delta += 2;
+  }
+
+  if (flag & (1u << 2)) {  // y-Short
+    ++delta;
+  } else if (!(flag & (1u << 5))) {
+    delta += 2;
+  }
+
+  if (flag & (1u << 3)) {  // repeat
+    if (*flags_count_logical + 1 >= num_flags) {
+      return OTS_FAILURE();
+    }
+    uint8_t repeat = 0;
+    if (!table->ReadU8(&repeat)) {
+      return OTS_FAILURE();
+    }
+    if (repeat == 0) {
+      return OTS_FAILURE();
+    }
+    delta += (delta * repeat);
+
+    *flags_count_logical += repeat;
+    if (*flags_count_logical >= num_flags) {
+      return OTS_FAILURE();
+    }
+    ++(*flags_count_physical);
+  }
+
+  if ((flag & (1u << 6)) || (flag & (1u << 7))) {  // reserved flags
+    return OTS_FAILURE();
+  }
+
+  *xy_coordinates_length += delta;
+  if (gly_length < *xy_coordinates_length) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+bool ParseSimpleGlyph(ots::OpenTypeFile *file, const uint8_t *data,
+                      ots::Buffer *table, int16_t num_contours,
+                      uint32_t gly_offset, uint32_t gly_length,
+                      uint32_t *new_size) {
+  ots::OpenTypeGLYF *glyf = file->glyf;
+
+  // read the end-points array
+  uint16_t num_flags = 0;
+  for (int i = 0; i < num_contours; ++i) {
+    uint16_t tmp_index = 0;
+    if (!table->ReadU16(&tmp_index)) {
+      return OTS_FAILURE();
+    }
+    if (tmp_index == 0xffffu) {
+      return OTS_FAILURE();
+    }
+    // check if the indices are monotonically increasing
+    if (i && (tmp_index + 1 <= num_flags)) {
+      return OTS_FAILURE();
+    }
+    num_flags = tmp_index + 1;
+  }
+
+  uint16_t bytecode_length = 0;
+  if (!table->ReadU16(&bytecode_length)) {
+    return OTS_FAILURE();
+  }
+  if ((file->maxp->version_1) &&
+      (file->maxp->max_size_glyf_instructions < bytecode_length)) {
+    return OTS_FAILURE();
+  }
+
+  const uint32_t gly_header_length = 10 + num_contours * 2 + 2;
+  if (gly_length < (gly_header_length + bytecode_length)) {
+    return OTS_FAILURE();
+  }
+
+  if (ots::g_transcode_hints) {
+    glyf->iov.push_back(std::make_pair(
+        data + gly_offset, gly_header_length + bytecode_length));
+  } else {
+    // enqueue two vectors: the glyph data up to the bytecode length, then
+    // a pointer to a static uint16_t 0 to overwrite the length.
+    glyf->iov.push_back(std::make_pair(
+        data + gly_offset, gly_header_length - 2));
+    glyf->iov.push_back(std::make_pair((const uint8_t*) "\x00\x00", 2));
+  }
+
+  if (!table->Skip(bytecode_length)) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t flags_count_physical = 0;  // on memory
+  uint32_t xy_coordinates_length = 0;
+  for (uint32_t flags_count_logical = 0;
+       flags_count_logical < num_flags;
+       ++flags_count_logical, ++flags_count_physical) {
+    if (!ParseFlagsForSimpleGlyph(table,
+                                  gly_length,
+                                  num_flags,
+                                  &flags_count_logical,
+                                  &flags_count_physical,
+                                  &xy_coordinates_length)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (gly_length < (gly_header_length + bytecode_length +
+                    flags_count_physical + xy_coordinates_length)) {
+    return OTS_FAILURE();
+  }
+
+  if (gly_length - (gly_header_length + bytecode_length +
+                    flags_count_physical + xy_coordinates_length) > 3) {
+    // We allow 0-3 bytes difference since gly_length is 4-bytes aligned,
+    // zero-padded length.
+    return OTS_FAILURE();
+  }
+
+  glyf->iov.push_back(std::make_pair(
+      data + gly_offset + gly_header_length + bytecode_length,
+      flags_count_physical + xy_coordinates_length));
+
+  *new_size
+      = gly_header_length + flags_count_physical + xy_coordinates_length;
+  if (ots::g_transcode_hints) {
+    *new_size += bytecode_length;
+  }
+
+  return true;
+}
+
+}  // namespace
+
+namespace ots {
+
+bool ots_glyf_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  if (!file->maxp || !file->loca || !file->head) {
+    return OTS_FAILURE();
+  }
+
+  OpenTypeGLYF *glyf = new OpenTypeGLYF;
+  file->glyf = glyf;
+
+  const unsigned num_glyphs = file->maxp->num_glyphs;
+  std::vector<uint32_t> &offsets = file->loca->offsets;
+
+  if (offsets.size() != num_glyphs + 1) {
+    return OTS_FAILURE();
+  }
+
+  std::vector<uint32_t> resulting_offsets(num_glyphs + 1);
+  uint32_t current_offset = 0;
+
+  for (unsigned i = 0; i < num_glyphs; ++i) {
+    const unsigned gly_offset = offsets[i];
+    // The LOCA parser checks that these values are monotonic
+    const unsigned gly_length = offsets[i + 1] - offsets[i];
+    if (!gly_length) {
+      // this glyph has no outline (e.g. the space charactor)
+      resulting_offsets[i] = current_offset;
+      continue;
+    }
+
+    if (gly_offset >= length) {
+      return OTS_FAILURE();
+    }
+    // Since these are unsigned types, the compiler is not allowed to assume
+    // that they never overflow.
+    if (gly_offset + gly_length < gly_offset) {
+      return OTS_FAILURE();
+    }
+    if (gly_offset + gly_length > length) {
+      return OTS_FAILURE();
+    }
+
+    table.set_offset(gly_offset);
+    int16_t num_contours, xmin, ymin, xmax, ymax;
+    if (!table.ReadS16(&num_contours) ||
+        !table.ReadS16(&xmin) ||
+        !table.ReadS16(&ymin) ||
+        !table.ReadS16(&xmax) ||
+        !table.ReadS16(&ymax)) {
+      return OTS_FAILURE();
+    }
+
+    if (num_contours <= -2) {
+      // -2, -3, -4, ... are reserved for future use.
+      return OTS_FAILURE();
+    }
+
+    // workaround for fonts in http://www.princexml.com/fonts/
+    if ((xmin == 32767) &&
+        (xmax == -32767) &&
+        (ymin == 32767) &&
+        (ymax == -32767)) {
+      OTS_WARNING("bad xmin/xmax/ymin/ymax values");
+      xmin = xmax = ymin = ymax = 0;
+    }
+
+    if (xmin > xmax || ymin > ymax) {
+      return OTS_FAILURE();
+    }
+
+    unsigned new_size = 0;
+    if (num_contours >= 0) {
+      // this is a simple glyph and might contain bytecode
+      if (!ParseSimpleGlyph(file, data, &table,
+                            num_contours, gly_offset, gly_length, &new_size)) {
+        return OTS_FAILURE();
+      }
+    } else {
+      // it's a composite glyph without any bytecode. Enqueue the whole thing
+      glyf->iov.push_back(std::make_pair(data + gly_offset, gly_length));
+      new_size = gly_length;
+    }
+
+    resulting_offsets[i] = current_offset;
+    // glyphs must be four byte aligned
+    // TODO(yusukes): investigate whether this padding is really necessary.
+    //                Which part of the spec requires this?
+    const unsigned padding = (4 - (new_size & 3)) % 4;
+    if (padding) {
+      glyf->iov.push_back(std::make_pair(
+          reinterpret_cast<const uint8_t*>("\x00\x00\x00\x00"), padding));
+      new_size += padding;
+    }
+    current_offset += new_size;
+  }
+  resulting_offsets[num_glyphs] = current_offset;
+
+  const uint16_t max16 = std::numeric_limits<uint16_t>::max();
+  if ((*std::max_element(resulting_offsets.begin(),
+                         resulting_offsets.end()) >= (max16 * 2u)) &&
+      (file->head->index_to_loc_format != 1)) {
+    OTS_WARNING("2-bytes indexing is not possible (due to the padding above)");
+    file->head->index_to_loc_format = 1;
+  }
+
+  file->loca->offsets = resulting_offsets;
+  return true;
+}
+
+bool ots_glyf_should_serialise(OpenTypeFile *file) {
+  return file->glyf;
+}
+
+bool ots_glyf_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeGLYF *glyf = file->glyf;
+
+  for (unsigned i = 0; i < glyf->iov.size(); ++i) {
+    if (!out->Write(glyf->iov[i].first, glyf->iov[i].second)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_glyf_free(OpenTypeFile *file) {
+  delete file->glyf;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/glyf.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/glyf.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,21 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_GLYF_H_
+#define OTS_GLYF_H_
+
+#include <utility>  // std::pair
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeGLYF {
+  std::vector<std::pair<const uint8_t*, size_t> > iov;
+};
+
+}  // namespace ots
+
+#endif  // OTS_GLYF_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gpos.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gpos.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,45 @@
+// Copyright (c) 2010 Mozilla Foundation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gpos.h"
+
+// GPOS - Glyph Positioning Table
+// http://www.microsoft.com/typography/otspec/gpos.htm
+
+namespace ots {
+
+bool ots_gpos_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeGPOS *gpos = new OpenTypeGPOS;
+  file->gpos = gpos;
+
+  if (!table.Skip(length)) {
+    return OTS_FAILURE();
+  }
+
+  gpos->data = data;
+  gpos->length = length;
+  return true;
+}
+
+bool ots_gpos_should_serialise(OpenTypeFile *file) {
+  return file->preserve_otl && file->gpos;
+}
+
+bool ots_gpos_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeGPOS *gpos = file->gpos;
+
+  if (!out->Write(gpos->data, gpos->length)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_gpos_free(OpenTypeFile *file) {
+  delete file->gpos;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gpos.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gpos.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,19 @@
+// Copyright (c) 2010 Mozilla Foundation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_GPOS_H_
+#define OTS_GPOS_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeGPOS {
+  const uint8_t *data;
+  uint32_t length;
+};
+
+}  // namespace ots
+
+#endif  // OTS_GPOS_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gsub.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gsub.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,45 @@
+// Copyright (c) 2010 Mozilla Foundation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "gsub.h"
+
+// GSUB - Glyph Substitution Table
+// http://www.microsoft.com/typography/otspec/gsub.htm
+
+namespace ots {
+
+bool ots_gsub_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeGSUB *gsub = new OpenTypeGSUB;
+  file->gsub = gsub;
+
+  if (!table.Skip(length)) {
+    return OTS_FAILURE();
+  }
+
+  gsub->data = data;
+  gsub->length = length;
+  return true;
+}
+
+bool ots_gsub_should_serialise(OpenTypeFile *file) {
+  return file->preserve_otl && file->gsub;
+}
+
+bool ots_gsub_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeGSUB *gsub = file->gsub;
+
+  if (!out->Write(gsub->data, gsub->length)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_gsub_free(OpenTypeFile *file) {
+  delete file->gsub;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/gsub.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/gsub.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,19 @@
+// Copyright (c) 2010 Mozilla Foundation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_GSUB_H_
+#define OTS_GSUB_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeGSUB {
+  const uint8_t *data;
+  uint32_t length;
+};
+
+}  // namespace ots
+
+#endif  // OTS_GSUB_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/hdmx.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/hdmx.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,134 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "hdmx.h"
+#include "head.h"
+#include "maxp.h"
+
+// hdmx - Horizontal Device Metrics
+// http://www.microsoft.com/opentype/otspec/hdmx.htm
+
+#define DROP_THIS_TABLE \
+  do { delete file->hdmx; file->hdmx = 0; } while (0)
+
+namespace ots {
+
+bool ots_hdmx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  file->hdmx = new OpenTypeHDMX;
+  OpenTypeHDMX * const hdmx = file->hdmx;
+
+  if (!file->head || !file->maxp) {
+    return OTS_FAILURE();
+  }
+
+  if ((file->head->flags & 0x14) == 0) {
+    // http://www.microsoft.com/typography/otspec/recom.htm
+    OTS_WARNING("the table should not be present when bit 2 and 4 of the "
+                "head->flags are not set");
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  int16_t num_recs;
+  if (!table.ReadU16(&hdmx->version) ||
+      !table.ReadS16(&num_recs) ||
+      !table.ReadS32(&hdmx->size_device_record)) {
+    return OTS_FAILURE();
+  }
+  if (hdmx->version != 0) {
+    OTS_WARNING("bad version: %u", hdmx->version);
+    DROP_THIS_TABLE;
+    return true;
+  }
+  if (num_recs <= 0) {
+    OTS_WARNING("bad num_recs: %d", num_recs);
+    DROP_THIS_TABLE;
+    return true;
+  }
+  const int32_t actual_size_device_record = file->maxp->num_glyphs + 2;
+  if (hdmx->size_device_record < actual_size_device_record) {
+    OTS_WARNING("bad hdmx->size_device_record: %d", hdmx->size_device_record);
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  hdmx->pad_len = hdmx->size_device_record - actual_size_device_record;
+  if (hdmx->pad_len > 3) {
+    return OTS_FAILURE();
+  }
+
+  uint8_t last_pixel_size = 0;
+  hdmx->records.reserve(num_recs);
+  for (int i = 0; i < num_recs; ++i) {
+    OpenTypeHDMXDeviceRecord rec;
+
+    if (!table.ReadU8(&rec.pixel_size) ||
+        !table.ReadU8(&rec.max_width)) {
+      return OTS_FAILURE();
+    }
+    if ((i != 0) &&
+        (rec.pixel_size <= last_pixel_size)) {
+      OTS_WARNING("records are not sorted");
+      DROP_THIS_TABLE;
+      return true;
+    }
+    last_pixel_size = rec.pixel_size;
+
+    rec.widths.reserve(file->maxp->num_glyphs);
+    for (unsigned j = 0; j < file->maxp->num_glyphs; ++j) {
+      uint8_t width;
+      if (!table.ReadU8(&width)) {
+        return OTS_FAILURE();
+      }
+      rec.widths.push_back(width);
+    }
+
+    if ((hdmx->pad_len > 0) &&
+        !table.Skip(hdmx->pad_len)) {
+      return OTS_FAILURE();
+    }
+
+    hdmx->records.push_back(rec);
+  }
+
+  return true;
+}
+
+bool ots_hdmx_should_serialise(OpenTypeFile *file) {
+  if (!file->hdmx) return false;
+  if (!file->glyf) return false;  // this table is not for CFF fonts.
+  return true;
+}
+
+bool ots_hdmx_serialise(OTSStream *out, OpenTypeFile *file) {
+  OpenTypeHDMX * const hdmx = file->hdmx;
+
+  if (!out->WriteU16(hdmx->version) ||
+      !out->WriteS16(hdmx->records.size()) ||
+      !out->WriteS32(hdmx->size_device_record)) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < hdmx->records.size(); ++i) {
+    const OpenTypeHDMXDeviceRecord& rec = hdmx->records[i];
+    if (!out->Write(&rec.pixel_size, 1) ||
+        !out->Write(&rec.max_width, 1) ||
+        !out->Write(&rec.widths[0], rec.widths.size())) {
+      return OTS_FAILURE();
+    }
+    if ((hdmx->pad_len > 0) &&
+        !out->Write((const uint8_t *)"\x00\x00\x00", hdmx->pad_len)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_hdmx_free(OpenTypeFile *file) {
+  delete file->hdmx;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/hdmx.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/hdmx.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,29 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_HDMX_H_
+#define OTS_HDMX_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeHDMXDeviceRecord {
+  uint8_t pixel_size;
+  uint8_t max_width;
+  std::vector<uint8_t> widths;
+};
+
+struct OpenTypeHDMX {
+  uint16_t version;
+  int32_t size_device_record;
+  int32_t pad_len;
+  std::vector<OpenTypeHDMXDeviceRecord> records;
+};
+
+}  // namespace ots
+
+#endif
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/head.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/head.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,149 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "head.h"
+
+#include <cstring>
+
+// head - Font Header
+// http://www.microsoft.com/opentype/otspec/head.htm
+
+namespace ots {
+
+bool ots_head_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  file->head = new OpenTypeHEAD;
+
+  uint32_t version = 0;
+  if (!table.ReadU32(&version) ||
+      !table.ReadU32(&file->head->revision)) {
+    return OTS_FAILURE();
+  }
+
+  if (version >> 16 != 1) {
+    return OTS_FAILURE();
+  }
+
+  // Skip the checksum adjustment
+  if (!table.Skip(4)) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t magic;
+  if (!table.ReadTag(&magic) ||
+      std::memcmp(&magic, "\x5F\x0F\x3C\xF5", 4)) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadU16(&file->head->flags)) {
+    return OTS_FAILURE();
+  }
+
+  // We allow bits 0..4, 11..13
+  file->head->flags &= 0x381f;
+
+  if (!table.ReadU16(&file->head->ppem)) {
+    return OTS_FAILURE();
+  }
+
+  // ppem must be in range
+  if (file->head->ppem < 16 ||
+      file->head->ppem > 16384) {
+    return OTS_FAILURE();
+  }
+
+  // ppem must be a power of two
+#if 0
+  // We don't call ots_failure() for now since lots of TrueType fonts are
+  // not following this rule. Putting OTS_WARNING here is too noisy.
+  if ((file->head->ppem - 1) & file->head->ppem) {
+    return OTS_FAILURE();
+  }
+#endif
+
+  if (!table.ReadR64(&file->head->created) ||
+      !table.ReadR64(&file->head->modified)) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadS16(&file->head->xmin) ||
+      !table.ReadS16(&file->head->ymin) ||
+      !table.ReadS16(&file->head->xmax) ||
+      !table.ReadS16(&file->head->ymax)) {
+    return OTS_FAILURE();
+  }
+
+  if (file->head->xmin > file->head->xmax) {
+    return OTS_FAILURE();
+  }
+  if (file->head->ymin > file->head->ymax) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadU16(&file->head->mac_style)) {
+    return OTS_FAILURE();
+  }
+
+  // We allow bits 0..6
+  file->head->mac_style &= 0x7f;
+
+  if (!table.ReadU16(&file->head->min_ppem)) {
+    return OTS_FAILURE();
+  }
+
+  // We don't care about the font direction hint
+  if (!table.Skip(2)) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadS16(&file->head->index_to_loc_format)) {
+    return OTS_FAILURE();
+  }
+  if (file->head->index_to_loc_format < 0 ||
+      file->head->index_to_loc_format > 1) {
+    return OTS_FAILURE();
+  }
+
+  int16_t glyph_data_format;
+  if (!table.ReadS16(&glyph_data_format) ||
+      glyph_data_format) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+bool ots_head_should_serialise(OpenTypeFile *file) {
+  return file->head;
+}
+
+bool ots_head_serialise(OTSStream *out, OpenTypeFile *file) {
+  if (!out->WriteU32(0x00010000) ||
+      !out->WriteU32(file->head->revision) ||
+      !out->WriteU32(0) ||  // check sum not filled in yet
+      !out->WriteU32(0x5F0F3CF5) ||
+      !out->WriteU16(file->head->flags) ||
+      !out->WriteU16(file->head->ppem) ||
+      !out->WriteR64(file->head->created) ||
+      !out->WriteR64(file->head->modified) ||
+      !out->WriteS16(file->head->xmin) ||
+      !out->WriteS16(file->head->ymin) ||
+      !out->WriteS16(file->head->xmax) ||
+      !out->WriteS16(file->head->ymax) ||
+      !out->WriteU16(file->head->mac_style) ||
+      !out->WriteU16(file->head->min_ppem) ||
+      !out->WriteS16(2) ||
+      !out->WriteS16(file->head->index_to_loc_format) ||
+      !out->WriteS16(0)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_head_free(OpenTypeFile *file) {
+  delete file->head;
+}
+
+}  // namespace
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/head.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/head.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,29 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_HEAD_H_
+#define OTS_HEAD_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeHEAD {
+  uint32_t revision;
+  uint16_t flags;
+  uint16_t ppem;
+  uint64_t created;
+  uint64_t modified;
+
+  int16_t xmin, xmax;
+  int16_t ymin, ymax;
+
+  uint16_t mac_style;
+  uint16_t min_ppem;
+  int16_t index_to_loc_format;
+};
+
+}  // namespace ots
+
+#endif  // OTS_HEAD_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/hhea.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/hhea.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,120 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "hhea.h"
+
+#include "head.h"
+#include "maxp.h"
+
+// hhea - Horizontal Header
+// http://www.microsoft.com/opentype/otspec/hhea.htm
+
+namespace ots {
+
+bool ots_hhea_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  OpenTypeHHEA *hhea = new OpenTypeHHEA;
+  file->hhea = hhea;
+
+  uint32_t version = 0;
+  if (!table.ReadU32(&version)) {
+    return OTS_FAILURE();
+  }
+  if (version >> 16 != 1) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadS16(&hhea->ascent) ||
+      !table.ReadS16(&hhea->descent) ||
+      !table.ReadS16(&hhea->linegap) ||
+      !table.ReadU16(&hhea->adv_width_max) ||
+      !table.ReadS16(&hhea->min_lsb) ||
+      !table.ReadS16(&hhea->min_rsb) ||
+      !table.ReadS16(&hhea->x_max_extent) ||
+      !table.ReadS16(&hhea->caret_slope_rise) ||
+      !table.ReadS16(&hhea->caret_slope_run) ||
+      !table.ReadS16(&hhea->caret_offset)) {
+    return OTS_FAILURE();
+  }
+
+  if (hhea->ascent < 0) {
+    OTS_WARNING("bad ascent: %d", hhea->ascent);
+    hhea->ascent = 0;
+  }
+  if (hhea->linegap < 0) {
+    OTS_WARNING("bad linegap: %d", hhea->linegap);
+    hhea->linegap = 0;
+  }
+
+  if (!file->head) {
+    return OTS_FAILURE();
+  }
+
+  // if the font is non-slanted, caret_offset should be zero.
+  if (!(file->head->mac_style & 2) &&
+      (hhea->caret_offset != 0)) {
+    OTS_WARNING("bad caret offset: %d", hhea->caret_offset);
+    hhea->caret_offset = 0;
+  }
+
+  // skip the reserved bytes
+  if (!table.Skip(8)) {
+    return OTS_FAILURE();
+  }
+
+  int16_t data_format;
+  if (!table.ReadS16(&data_format)) {
+    return OTS_FAILURE();
+  }
+  if (data_format) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadU16(&hhea->num_hmetrics)) {
+    return OTS_FAILURE();
+  }
+
+  if (!file->maxp) {
+    return OTS_FAILURE();
+  }
+
+  if (hhea->num_hmetrics > file->maxp->num_glyphs) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+bool ots_hhea_should_serialise(OpenTypeFile *file) {
+  return file->hhea;
+}
+
+bool ots_hhea_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeHHEA *hhea = file->hhea;
+
+  if (!out->WriteU32(0x00010000) ||
+      !out->WriteS16(hhea->ascent) ||
+      !out->WriteS16(hhea->descent) ||
+      !out->WriteS16(hhea->linegap) ||
+      !out->WriteU16(hhea->adv_width_max) ||
+      !out->WriteS16(hhea->min_lsb) ||
+      !out->WriteS16(hhea->min_rsb) ||
+      !out->WriteS16(hhea->x_max_extent) ||
+      !out->WriteS16(hhea->caret_slope_rise) ||
+      !out->WriteS16(hhea->caret_slope_run) ||
+      !out->WriteS16(hhea->caret_offset) ||
+      !out->WriteR64(0) ||  // reserved
+      !out->WriteS16(0) ||  // metric data format
+      !out->WriteU16(hhea->num_hmetrics)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_hhea_free(OpenTypeFile *file) {
+  delete file->hhea;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/hhea.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/hhea.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,28 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_HHEA_H_
+#define OTS_HHEA_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeHHEA {
+  int16_t ascent;
+  int16_t descent;
+  int16_t linegap;
+  uint16_t adv_width_max;
+  int16_t min_lsb;
+  int16_t min_rsb;
+  int16_t x_max_extent;
+  int16_t caret_slope_rise;
+  int16_t caret_slope_run;
+  int16_t caret_offset;
+  uint16_t num_hmetrics;
+};
+
+}  // namespace ots
+
+#endif  // OTS_HHEA_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/hmtx.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/hmtx.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,107 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "hmtx.h"
+
+#include "hhea.h"
+#include "maxp.h"
+
+// hmtx - Horizontal Metrics
+// http://www.microsoft.com/opentype/otspec/hmtx.htm
+
+namespace ots {
+
+bool ots_hmtx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  OpenTypeHMTX *hmtx = new OpenTypeHMTX;
+  file->hmtx = hmtx;
+
+  if (!file->hhea || !file->maxp) {
+    return OTS_FAILURE();
+  }
+
+  // |num_hmetrics| is a uint16_t, so it's bounded < 65536. This limits that
+  // amount of memory that we'll allocate for this to a sane amount.
+  const unsigned num_hmetrics = file->hhea->num_hmetrics;
+
+  if (num_hmetrics > file->maxp->num_glyphs) {
+    return OTS_FAILURE();
+  }
+  if (!num_hmetrics) {
+    return OTS_FAILURE();
+  }
+  const unsigned num_lsbs = file->maxp->num_glyphs - num_hmetrics;
+
+  hmtx->metrics.reserve(num_hmetrics);
+  for (unsigned i = 0; i < num_hmetrics; ++i) {
+    uint16_t adv = 0;
+    int16_t lsb = 0;
+    if (!table.ReadU16(&adv) || !table.ReadS16(&lsb)) {
+      return OTS_FAILURE();
+    }
+
+    // Since so many fonts don't have proper value on |adv| and |lsb|,
+    // we should not call ots_failure() here. For example, about 20% of fonts
+    // in http://www.princexml.com/fonts/ (200+ fonts) fails these tests.
+    if (adv > file->hhea->adv_width_max) {
+      OTS_WARNING("bad adv: %u > %u", adv, file->hhea->adv_width_max);
+      adv = file->hhea->adv_width_max;
+    }
+    if (lsb < file->hhea->min_lsb) {
+      OTS_WARNING("bad lsb: %d < %d", lsb, file->hhea->min_lsb);
+      lsb = file->hhea->min_lsb;
+    }
+
+    hmtx->metrics.push_back(std::make_pair(adv, lsb));
+  }
+
+  hmtx->lsbs.reserve(num_lsbs);
+  for (unsigned i = 0; i < num_lsbs; ++i) {
+    int16_t lsb;
+    if (!table.ReadS16(&lsb)) {
+      // Some Japanese fonts (e.g., mona.ttf) fail this test.
+      return OTS_FAILURE();
+    }
+
+    if (lsb < file->hhea->min_lsb) {
+      // The same as above. Three fonts in http://www.fontsquirrel.com/fontface
+      // (e.g., Notice2Std.otf) have weird lsb values.
+      OTS_WARNING("bad lsb: %d < %d", lsb, file->hhea->min_lsb);
+      lsb = file->hhea->min_lsb;
+    }
+
+    hmtx->lsbs.push_back(lsb);
+  }
+
+  return true;
+}
+
+bool ots_hmtx_should_serialise(OpenTypeFile *file) {
+  return file->hmtx;
+}
+
+bool ots_hmtx_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeHMTX *hmtx = file->hmtx;
+
+  for (unsigned i = 0; i < hmtx->metrics.size(); ++i) {
+    if (!out->WriteU16(hmtx->metrics[i].first) ||
+        !out->WriteS16(hmtx->metrics[i].second)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  for (unsigned i = 0; i < hmtx->lsbs.size(); ++i) {
+    if (!out->WriteS16(hmtx->lsbs[i])) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_hmtx_free(OpenTypeFile *file) {
+  delete file->hmtx;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/hmtx.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/hmtx.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,22 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_HMTX_H_
+#define OTS_HMTX_H_
+
+#include <utility>  // std::pair
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeHMTX {
+  std::vector<std::pair<uint16_t, int16_t> > metrics;
+  std::vector<int16_t> lsbs;
+};
+
+}  // namespace ots
+
+#endif  // OTS_HMTX_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/kern.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/kern.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,196 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "kern.h"
+
+// kern - Kerning
+// http://www.microsoft.com/opentype/otspec/kern.htm
+
+#define DROP_THIS_TABLE \
+  do { delete file->kern; file->kern = 0; } while (0)
+
+namespace ots {
+
+bool ots_kern_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeKERN *kern = new OpenTypeKERN;
+  file->kern = kern;
+
+  uint16_t num_tables = 0;
+  if (!table.ReadU16(&kern->version) ||
+      !table.ReadU16(&num_tables)) {
+    return OTS_FAILURE();
+  }
+
+  if (kern->version > 0) {
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  if (num_tables == 0) {
+    OTS_WARNING("num_tables is zero");
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  kern->subtables.reserve(num_tables);
+  for (unsigned i = 0; i < num_tables; ++i) {
+    OpenTypeKERNFormat0 subtable;
+    uint16_t sub_length = 0;
+
+    if (!table.ReadU16(&subtable.version) ||
+        !table.ReadU16(&sub_length)) {
+      return OTS_FAILURE();
+    }
+
+    if (subtable.version > 0) {
+      OTS_WARNING("Bad subtable version: %d", subtable.version);
+      continue;
+    }
+
+    const size_t current_offset = table.offset();
+    if (current_offset - 4 + sub_length > length) {
+      return OTS_FAILURE();
+    }
+
+    if (!table.ReadU16(&subtable.coverage)) {
+      return OTS_FAILURE();
+    }
+
+    if (!(subtable.coverage & 0x1)) {
+      OTS_WARNING(
+          "We don't support vertical data as the renderer doesn't support it.");
+      continue;
+    }
+    if (subtable.coverage & 0xF0) {
+      OTS_WARNING("Reserved fields should zero-filled.");
+      DROP_THIS_TABLE;
+      return true;
+    }
+    const uint32_t format = (subtable.coverage & 0xFF00) >> 8;
+    if (format != 0) {
+      OTS_WARNING("Format %d is not supported.", format);
+      continue;
+    }
+
+    // Parse the format 0 field.
+    uint16_t num_pairs = 0;
+    if (!table.ReadU16(&num_pairs) ||
+        !table.ReadU16(&subtable.search_range) ||
+        !table.ReadU16(&subtable.entry_selector) ||
+        !table.ReadU16(&subtable.range_shift)) {
+      return OTS_FAILURE();
+    }
+
+    if (!num_pairs) {
+      OTS_WARNING("Zero length subtable is found.");
+      DROP_THIS_TABLE;
+      return true;
+    }
+
+    // Sanity checks for search_range, entry_selector, and range_shift. See the
+    // comment in ots.cc for details.
+    const size_t kFormat0PairSize = 6;  // left, right, and value. 2 bytes each.
+    if (num_pairs > (65536 / kFormat0PairSize)) {
+      // Some fonts (e.g. calibri.ttf, pykes_peak_zero.ttf) have pairs >= 10923.
+      OTS_WARNING("Too large subtable.");
+      DROP_THIS_TABLE;
+      return true;
+    }
+    unsigned max_pow2 = 0;
+    while (1u << (max_pow2 + 1) <= num_pairs) {
+      ++max_pow2;
+    }
+    const uint16_t expected_search_range = (1u << max_pow2) * kFormat0PairSize;
+    if (subtable.search_range != expected_search_range) {
+      OTS_WARNING("bad search range");
+      subtable.search_range = expected_search_range;
+    }
+    if (subtable.entry_selector != max_pow2) {
+      return OTS_FAILURE();
+    }
+    const uint32_t expected_range_shift
+        = kFormat0PairSize * num_pairs - subtable.search_range;
+    if (subtable.range_shift != expected_range_shift) {
+      OTS_WARNING("bad range shift");
+      subtable.range_shift = expected_range_shift;
+    }
+
+    // Read kerning pairs.
+    subtable.pairs.reserve(num_pairs);
+    uint32_t last_pair = 0;
+    for (unsigned j = 0; j < num_pairs; ++j) {
+      OpenTypeKERNFormat0Pair kerning_pair;
+      if (!table.ReadU16(&kerning_pair.left) ||
+          !table.ReadU16(&kerning_pair.right) ||
+          !table.ReadS16(&kerning_pair.value)) {
+        return OTS_FAILURE();
+      }
+      const uint32_t current_pair
+          = (kerning_pair.left << 16) + kerning_pair.right;
+      if (j != 0 && current_pair <= last_pair) {
+        OTS_WARNING("Kerning pairs are not sorted.");
+        // Many free fonts don't follow this rule, so we don't call OTS_FAILURE
+        // in order to support these fonts.
+        DROP_THIS_TABLE;
+        return true;
+      }
+      last_pair = current_pair;
+      subtable.pairs.push_back(kerning_pair);
+    }
+
+    kern->subtables.push_back(subtable);
+  }
+
+  if (!kern->subtables.size()) {
+    OTS_WARNING("All subtables are removed.");
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  return true;
+}
+
+bool ots_kern_should_serialise(OpenTypeFile *file) {
+  if (!file->glyf) return false;  // this table is not for CFF fonts.
+  return file->kern;
+}
+
+bool ots_kern_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeKERN *kern = file->kern;
+
+  if (!out->WriteU16(kern->version) ||
+      !out->WriteU16(kern->subtables.size())) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < kern->subtables.size(); ++i) {
+    const uint16_t length = 14 + (6 * kern->subtables[i].pairs.size());
+    if (!out->WriteU16(kern->subtables[i].version) ||
+        !out->WriteU16(length) ||
+        !out->WriteU16(kern->subtables[i].coverage) ||
+        !out->WriteU16(kern->subtables[i].pairs.size()) ||
+        !out->WriteU16(kern->subtables[i].search_range) ||
+        !out->WriteU16(kern->subtables[i].entry_selector) ||
+        !out->WriteU16(kern->subtables[i].range_shift)) {
+      return OTS_FAILURE();
+    }
+    for (unsigned j = 0; j < kern->subtables[i].pairs.size(); ++j) {
+      if (!out->WriteU16(kern->subtables[i].pairs[j].left) ||
+          !out->WriteU16(kern->subtables[i].pairs[j].right) ||
+          !out->WriteS16(kern->subtables[i].pairs[j].value)) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  return true;
+}
+
+void ots_kern_free(OpenTypeFile *file) {
+  delete file->kern;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/kern.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/kern.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,40 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_KERN_H_
+#define OTS_KERN_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeKERNFormat0Pair {
+  uint16_t left;
+  uint16_t right;
+  int16_t value;
+};
+
+struct OpenTypeKERNFormat0 {
+  uint16_t version;
+  uint16_t coverage;
+  uint16_t search_range;
+  uint16_t entry_selector;
+  uint16_t range_shift;
+  std::vector<OpenTypeKERNFormat0Pair> pairs;
+};
+
+// Format 2 is not supported. Since the format is not supported by Windows,
+// WebFonts unlikely use it. I've checked thousands of proprietary fonts and
+// free fonts, and found no font uses the format.
+
+struct OpenTypeKERN {
+  uint16_t version;
+  std::vector<OpenTypeKERNFormat0> subtables;
+};
+
+}  // namespace ots
+
+#endif  // OTS_KERN_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/loca.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/loca.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,98 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "loca.h"
+
+#include "head.h"
+#include "maxp.h"
+
+// loca - Index to Location
+// http://www.microsoft.com/opentype/otspec/loca.htm
+
+namespace ots {
+
+bool ots_loca_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  // We can't do anything useful in validating this data except to ensure that
+  // the values are monotonically increasing.
+
+  OpenTypeLOCA *loca = new OpenTypeLOCA;
+  file->loca = loca;
+
+  if (!file->maxp || !file->head) {
+    return OTS_FAILURE();
+  }
+
+  const unsigned num_glyphs = file->maxp->num_glyphs;
+  unsigned last_offset = 0;
+  loca->offsets.resize(num_glyphs + 1);
+  // maxp->num_glyphs is uint16_t, thus the addition never overflows.
+
+  if (file->head->index_to_loc_format == 0) {
+    // Note that the <= here (and below) is correct. There is one more offset
+    // than the number of glyphs in order to give the length of the final
+    // glyph.
+    for (unsigned i = 0; i <= num_glyphs; ++i) {
+      uint16_t offset = 0;
+      if (!table.ReadU16(&offset)) {
+        return OTS_FAILURE();
+      }
+      if (offset < last_offset) {
+        return OTS_FAILURE();
+      }
+      last_offset = offset;
+      loca->offsets[i] = offset * 2;
+    }
+  } else {
+    for (unsigned i = 0; i <= num_glyphs; ++i) {
+      uint32_t offset = 0;
+      if (!table.ReadU32(&offset)) {
+        return OTS_FAILURE();
+      }
+      if (offset < last_offset) {
+        return OTS_FAILURE();
+      }
+      last_offset = offset;
+      loca->offsets[i] = offset;
+    }
+  }
+
+  return true;
+}
+
+bool ots_loca_should_serialise(OpenTypeFile *file) {
+  return file->loca;
+}
+
+bool ots_loca_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeLOCA *loca = file->loca;
+  const OpenTypeHEAD *head = file->head;
+
+  if (!head) {
+    return OTS_FAILURE();
+  }
+
+  if (head->index_to_loc_format == 0) {
+    for (unsigned i = 0; i < loca->offsets.size(); ++i) {
+      if (!out->WriteU16(loca->offsets[i] >> 1)) {
+        return OTS_FAILURE();
+      }
+    }
+  } else {
+    for (unsigned i = 0; i < loca->offsets.size(); ++i) {
+      if (!out->WriteU32(loca->offsets[i])) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  return true;
+}
+
+void ots_loca_free(OpenTypeFile *file) {
+  delete file->loca;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/loca.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/loca.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,20 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_LOCA_H_
+#define OTS_LOCA_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeLOCA {
+  std::vector<uint32_t> offsets;
+};
+
+}  // namespace ots
+
+#endif  // OTS_LOCA_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/ltsh.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/ltsh.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,82 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ltsh.h"
+
+#include "maxp.h"
+
+// LTSH - Linear Threshold
+// http://www.microsoft.com/typography/otspec/ltsh.htm
+
+#define DROP_THIS_TABLE \
+  do { delete file->ltsh; file->ltsh = 0; } while (0)
+
+namespace ots {
+
+bool ots_ltsh_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  if (!file->maxp) {
+    return OTS_FAILURE();
+  }
+
+  OpenTypeLTSH *ltsh = new OpenTypeLTSH;
+  file->ltsh = ltsh;
+
+  uint16_t num_glyphs = 0;
+  if (!table.ReadU16(&ltsh->version) ||
+      !table.ReadU16(&num_glyphs)) {
+    return OTS_FAILURE();
+  }
+
+  if (ltsh->version != 0) {
+    OTS_WARNING("bad version: %u", ltsh->version);
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  if (num_glyphs != file->maxp->num_glyphs) {
+    OTS_WARNING("bad num_glyphs: %u", num_glyphs);
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  ltsh->ypels.reserve(num_glyphs);
+  for (unsigned i = 0; i < num_glyphs; ++i) {
+    uint8_t pel = 0;
+    if (!table.ReadU8(&pel)) {
+      return OTS_FAILURE();
+    }
+    ltsh->ypels.push_back(pel);
+  }
+
+  return true;
+}
+
+bool ots_ltsh_should_serialise(OpenTypeFile *file) {
+  if (!file->glyf) return false;  // this table is not for CFF fonts.
+  return file->ltsh;
+}
+
+bool ots_ltsh_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeLTSH *ltsh = file->ltsh;
+
+  if (!out->WriteU16(ltsh->version) ||
+      !out->WriteU16(ltsh->ypels.size())) {
+    return OTS_FAILURE();
+  }
+  for (unsigned i = 0; i < ltsh->ypels.size(); ++i) {
+    if (!out->Write(&(ltsh->ypels[i]), 1)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_ltsh_free(OpenTypeFile *file) {
+  delete file->ltsh;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/ltsh.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/ltsh.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,21 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_LTSH_H_
+#define OTS_LTSH_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeLTSH {
+  uint16_t version;
+  std::vector<uint8_t> ypels;
+};
+
+}  // namespace ots
+
+#endif  // OTS_LTSH_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/maxp.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/maxp.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,128 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "maxp.h"
+
+// maxp - Maximum Profile
+// http://www.microsoft.com/opentype/otspec/maxp.htm
+
+namespace ots {
+
+bool ots_maxp_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeMAXP *maxp = new OpenTypeMAXP;
+  file->maxp = maxp;
+
+  uint32_t version = 0;
+  if (!table.ReadU32(&version)) {
+    return OTS_FAILURE();
+  }
+
+  if (version >> 16 > 1) {
+    return OTS_FAILURE();
+  }
+
+  if (!table.ReadU16(&maxp->num_glyphs)) {
+    return OTS_FAILURE();
+  }
+
+  if (!maxp->num_glyphs) {
+    return OTS_FAILURE();
+  }
+
+  if (version >> 16 == 1) {
+    maxp->version_1 = true;
+    if (!table.ReadU16(&maxp->max_points) ||
+        !table.ReadU16(&maxp->max_contours) ||
+        !table.ReadU16(&maxp->max_c_points) ||
+        !table.ReadU16(&maxp->max_c_contours) ||
+        !table.ReadU16(&maxp->max_zones) ||
+        !table.ReadU16(&maxp->max_t_points) ||
+        !table.ReadU16(&maxp->max_storage) ||
+        !table.ReadU16(&maxp->max_fdefs) ||
+        !table.ReadU16(&maxp->max_idefs) ||
+        !table.ReadU16(&maxp->max_stack) ||
+        !table.ReadU16(&maxp->max_size_glyf_instructions) ||
+        !table.ReadU16(&maxp->max_c_components) ||
+        !table.ReadU16(&maxp->max_c_depth)) {
+      return OTS_FAILURE();
+    }
+
+    if (maxp->max_zones == 0) {
+      // workaround for ipa*.ttf Japanese fonts.
+      OTS_WARNING("bad max_zones: %u", maxp->max_zones);
+      maxp->max_zones = 1;
+    } else if (maxp->max_zones == 3) {
+      // workaround for Ecolier-*.ttf fonts.
+      OTS_WARNING("bad max_zones: %u", maxp->max_zones);
+      maxp->max_zones = 2;
+    }
+
+    if ((maxp->max_zones != 1) && (maxp->max_zones != 2)) {
+      return OTS_FAILURE();
+    }
+  } else {
+    maxp->version_1 = false;
+  }
+
+  return true;
+}
+
+bool ots_maxp_should_serialise(OpenTypeFile *file) {
+  return file->maxp;
+}
+
+bool ots_maxp_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeMAXP *maxp = file->maxp;
+
+  if (!out->WriteU32(maxp->version_1 ? 0x00010000 : 0x00005000) ||
+      !out->WriteU16(maxp->num_glyphs)) {
+    return OTS_FAILURE();
+  }
+
+  if (!maxp->version_1) return true;
+
+  if (!out->WriteU16(maxp->max_points) ||
+      !out->WriteU16(maxp->max_contours) ||
+      !out->WriteU16(maxp->max_c_points) ||
+      !out->WriteU16(maxp->max_c_contours)) {
+    return OTS_FAILURE();
+  }
+
+  if (g_transcode_hints) {
+    if (!out->WriteU16(maxp->max_zones) ||
+        !out->WriteU16(maxp->max_t_points) ||
+        !out->WriteU16(maxp->max_storage) ||
+        !out->WriteU16(maxp->max_fdefs) ||
+        !out->WriteU16(maxp->max_idefs) ||
+        !out->WriteU16(maxp->max_stack) ||
+        !out->WriteU16(maxp->max_size_glyf_instructions)) {
+      return OTS_FAILURE();
+    }
+  } else {
+    if (!out->WriteU16(1) ||  // max zones
+        !out->WriteU16(0) ||  // max twilight points
+        !out->WriteU16(0) ||  // max storage
+        !out->WriteU16(0) ||  // max function defs
+        !out->WriteU16(0) ||  // max instruction defs
+        !out->WriteU16(0) ||  // max stack elements
+        !out->WriteU16(0)) {  // max instruction byte count
+      return OTS_FAILURE();
+    }
+  }
+
+  if (!out->WriteU16(maxp->max_c_components) ||
+      !out->WriteU16(maxp->max_c_depth)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_maxp_free(OpenTypeFile *file) {
+  delete file->maxp;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/maxp.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/maxp.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,35 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_MAXP_H_
+#define OTS_MAXP_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeMAXP {
+  uint16_t num_glyphs;
+  bool version_1;
+
+  uint16_t max_points;
+  uint16_t max_contours;
+  uint16_t max_c_points;
+  uint16_t max_c_contours;
+
+  uint16_t max_zones;
+  uint16_t max_t_points;
+  uint16_t max_storage;
+  uint16_t max_fdefs;
+  uint16_t max_idefs;
+  uint16_t max_stack;
+  uint16_t max_size_glyf_instructions;
+
+  uint16_t max_c_components;
+  uint16_t max_c_depth;
+};
+
+}  // namespace ots
+
+#endif  // OTS_MAXP_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/name.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/name.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,131 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cstring>
+
+#include "cff.h"
+#include "ots.h"
+
+// name - Naming Table
+// http://www.microsoft.com/opentype/otspec/name.htm
+
+namespace ots {
+
+bool ots_name_parse(OpenTypeFile *, const uint8_t *, size_t) {
+  return true;
+}
+
+bool ots_name_should_serialise(OpenTypeFile *) {
+  return true;
+}
+
+bool ots_name_serialise(OTSStream *out, OpenTypeFile *file) {
+  // NAME is a required table, but we don't want anything to do with it. Thus,
+  // we don't bother parsing it and we just serialise an empty name table.
+
+  const char* kStrings[] = {
+      "Derived font data",  // 0: copyright
+      "OTS derived font",  // 1: the name the user sees
+      "Unspecified",  // 2: face weight
+      "UniqueID",  // 3: unique id
+      "OTS derivied font",  // 4: human readable name
+      "1.000",  // 5: version
+      "False",  // 6: postscript name
+      NULL,  // 7: trademark data
+      "OTS",  // 8: foundary
+      "OTS",  // 9: designer
+  };
+  static const size_t kStringsLen = sizeof(kStrings) / sizeof(kStrings[0]);
+
+  // The spec says that "In CFF OpenType fonts, these two name strings, when
+  // translated to ASCII, must also be identical to the font name as stored in
+  // the CFF's Name INDEX." And actually, Mac OS X's font parser requires that.
+  if (file->cff && !file->cff->name.empty()) {
+    kStrings[6] = file->cff->name.c_str();
+  }
+
+  unsigned num_strings = 0;
+  for (unsigned i = 0; i < kStringsLen; ++i) {
+    if (kStrings[i]) num_strings++;
+  }
+
+  if (!out->WriteU16(0) ||  // version
+      // Magic numbers:
+      //   6:  This entry (U16 * 3 = 6 bytes)
+      //   2:  Mac Roman & Windows Roman = 2 types
+      //   12: Each string entry (U16 * 6 = 12 bytes)
+      !out->WriteU16(num_strings * 2) ||  // count
+      !out->WriteU16(6 + num_strings * 2 * 12)) {  // string data offset
+    return OTS_FAILURE();
+  }
+
+  unsigned current_offset = 0;
+  for (unsigned i = 0; i < kStringsLen; ++i) {
+    if (!kStrings[i]) continue;
+
+    // string length in UTF-8 (ASCII).
+    size_t len = std::strlen(kStrings[i]);
+
+    if (!out->WriteU16(1) ||  // Mac
+        !out->WriteU16(0) ||  // Roman
+        !out->WriteU16(0) ||  // English
+        !out->WriteU16(i) ||
+        !out->WriteU16(len) ||
+        !out->WriteU16(current_offset)) {
+      return OTS_FAILURE();
+    }
+
+    current_offset += len;
+  }
+
+  for (unsigned i = 0; i < kStringsLen; ++i) {
+    if (!kStrings[i]) continue;
+
+    // string length in UTF-16.
+    size_t len = std::strlen(kStrings[i]) * 2;
+
+    if (!out->WriteU16(3) ||  // Windows
+        !out->WriteU16(1) ||  // Unicode BMP (UCS-2)
+        !out->WriteU16(0x0409) ||  // US English
+        !out->WriteU16(i) ||
+        !out->WriteU16(len) ||
+        !out->WriteU16(current_offset)) {
+      return OTS_FAILURE();
+    }
+
+    current_offset += len;
+  }
+
+  // Write strings in Mac Roman compatible with ASCII.
+  // Because all the entries are ASCII, we can just copy.
+  for (unsigned i = 0; i < kStringsLen; ++i) {
+    if (!kStrings[i]) continue;
+
+    const size_t len = std::strlen(kStrings[i]);
+    if (!out->Write(kStrings[i], len)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // Write strings in UCS-2. Because all the entries are ASCII,
+  // we can just expand each byte to U16.
+  for (unsigned i = 0; i < kStringsLen; ++i) {
+    if (!kStrings[i]) continue;
+
+    const size_t len = std::strlen(kStrings[i]);
+    for (size_t j = 0; j < len; ++j) {
+      uint16_t v = kStrings[i][j];
+      if (!out->WriteU16(v)) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  return true;
+}
+
+void ots_name_free(OpenTypeFile *) {
+}
+
+}  // namespace
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/os2.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/os2.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,290 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "os2.h"
+
+#include "head.h"
+
+// OS/2 - OS/2 and Windows Metrics
+// http://www.microsoft.com/opentype/otspec/os2.htm
+
+namespace ots {
+
+bool ots_os2_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypeOS2 *os2 = new OpenTypeOS2;
+  file->os2 = os2;
+
+  if (!table.ReadU16(&os2->version) ||
+      !table.ReadS16(&os2->avg_char_width) ||
+      !table.ReadU16(&os2->weight_class) ||
+      !table.ReadU16(&os2->width_class) ||
+      !table.ReadU16(&os2->type) ||
+      !table.ReadS16(&os2->subscript_x_size) ||
+      !table.ReadS16(&os2->subscript_y_size) ||
+      !table.ReadS16(&os2->subscript_x_offset) ||
+      !table.ReadS16(&os2->subscript_y_offset) ||
+      !table.ReadS16(&os2->superscript_x_size) ||
+      !table.ReadS16(&os2->superscript_y_size) ||
+      !table.ReadS16(&os2->superscript_x_offset) ||
+      !table.ReadS16(&os2->superscript_y_offset) ||
+      !table.ReadS16(&os2->strikeout_size) ||
+      !table.ReadS16(&os2->strikeout_position) ||
+      !table.ReadS16(&os2->family_class)) {
+    return OTS_FAILURE();
+  }
+
+  if (os2->version > 4) {
+    return OTS_FAILURE();
+  }
+
+  // Some linux fonts (e.g., Kedage-t.ttf and LucidaSansDemiOblique.ttf) have
+  // weird weight/width classes. Overwrite them with FW_NORMAL/1/9.
+  if (os2->weight_class < 100 ||
+      os2->weight_class > 900 ||
+      os2->weight_class % 100) {
+    OTS_WARNING("bad weight: %u", os2->weight_class);
+    os2->weight_class = 400;  // FW_NORMAL
+  }
+  if (os2->width_class < 1) {
+    OTS_WARNING("bad width: %u", os2->width_class);
+    os2->width_class = 1;
+  } else if (os2->width_class > 9) {
+    OTS_WARNING("bad width: %u", os2->width_class);
+    os2->width_class = 9;
+  }
+
+  // lowest 3 bits of fsType are exclusive.
+  if (os2->type & 0x2) {
+    // mask bits 2 & 3.
+    os2->type &= 0xfff3u;
+  } else if (os2->type & 0x4) {
+    // mask bits 1 & 3.
+    os2->type &= 0xfff4u;
+  } else if (os2->type & 0x8) {
+    // mask bits 1 & 2.
+    os2->type &= 0xfff9u;
+  }
+
+  // mask reserved bits. use only 0..3, 8, 9 bits.
+  os2->type &= 0x30f;
+
+  if (os2->subscript_x_size < 0) {
+    OTS_WARNING("bad subscript_x_size: %d", os2->subscript_x_size);
+    os2->subscript_x_size = 0;
+  }
+  if (os2->subscript_y_size < 0) {
+    OTS_WARNING("bad subscript_y_size: %d", os2->subscript_y_size);
+    os2->subscript_y_size = 0;
+  }
+  if (os2->superscript_x_size < 0) {
+    OTS_WARNING("bad superscript_x_size: %d", os2->superscript_x_size);
+    os2->superscript_x_size = 0;
+  }
+  if (os2->superscript_y_size < 0) {
+    OTS_WARNING("bad superscript_y_size: %d", os2->superscript_y_size);
+    os2->superscript_y_size = 0;
+  }
+  if (os2->strikeout_size < 0) {
+    OTS_WARNING("bad strikeout_size: %d", os2->strikeout_size);
+    os2->strikeout_size = 0;
+  }
+
+  for (unsigned i = 0; i < 10; ++i) {
+    if (!table.ReadU8(&os2->panose[i])) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (!table.ReadU32(&os2->unicode_range_1) ||
+      !table.ReadU32(&os2->unicode_range_2) ||
+      !table.ReadU32(&os2->unicode_range_3) ||
+      !table.ReadU32(&os2->unicode_range_4) ||
+      !table.ReadU32(&os2->vendor_id) ||
+      !table.ReadU16(&os2->selection) ||
+      !table.ReadU16(&os2->first_char_index) ||
+      !table.ReadU16(&os2->last_char_index) ||
+      !table.ReadS16(&os2->typo_ascender) ||
+      !table.ReadS16(&os2->typo_descender) ||
+      !table.ReadS16(&os2->typo_linegap) ||
+      !table.ReadU16(&os2->win_ascent) ||
+      !table.ReadU16(&os2->win_descent)) {
+    return OTS_FAILURE();
+  }
+
+  // If bit 6 is set, then bits 0 and 5 must be clear.
+  if (os2->selection & 0x40) {
+    os2->selection &= 0xffdeu;
+  }
+
+  // the settings of bits 0 and 1 must be reflected in the macStyle bits
+  // in the 'head' table.
+  if (!file->head) {
+    return OTS_FAILURE();
+  }
+  if ((os2->selection & 0x1) &&
+      !(file->head->mac_style & 0x2)) {
+    OTS_WARNING("adjusting Mac style (italic)");
+    file->head->mac_style |= 0x2;
+  }
+  if ((os2->selection & 0x2) &&
+      !(file->head->mac_style & 0x4)) {
+    OTS_WARNING("adjusting Mac style (underscore)");
+    file->head->mac_style |= 0x4;
+  }
+
+  // While bit 6 on implies that bits 0 and 1 of macStyle are clear,
+  // the reverse is not true.
+  if ((os2->selection & 0x40) &&
+      (file->head->mac_style & 0x3)) {
+    OTS_WARNING("adjusting Mac style (regular)");
+    file->head->mac_style &= 0xfffcu;
+  }
+
+  if ((os2->version < 4) &&
+      (os2->selection & 0x300)) {
+    // bit 8 and 9 must be unset in OS/2 table versions less than 4.
+    return OTS_FAILURE();
+  }
+
+  // mask reserved bits. use only 0..9 bits.
+  os2->selection &= 0x3ff;
+
+  if (os2->first_char_index > os2->last_char_index) {
+    return OTS_FAILURE();
+  }
+  if (os2->typo_linegap < 0) {
+    OTS_WARNING("bad linegap: %d", os2->typo_linegap);
+    os2->typo_linegap = 0;
+  }
+
+  if (os2->version < 1) {
+    // http://www.microsoft.com/typography/otspec/os2ver0.htm
+    return true;
+  }
+
+  if (length < offsetof(OpenTypeOS2, code_page_range_2)) {
+    OTS_WARNING("bad version number: %u", os2->version);
+    // Some fonts (e.g., kredit1.ttf and quinquef.ttf) have weird version
+    // numbers. Fix them.
+    os2->version = 0;
+    return true;
+  }
+
+  if (!table.ReadU32(&os2->code_page_range_1) ||
+      !table.ReadU32(&os2->code_page_range_2)) {
+    return OTS_FAILURE();
+  }
+
+  if (os2->version < 2) {
+    // http://www.microsoft.com/typography/otspec/os2ver1.htm
+    return true;
+  }
+
+  if (length < offsetof(OpenTypeOS2, max_context)) {
+    OTS_WARNING("bad version number: %u", os2->version);
+    // some Japanese fonts (e.g., mona.ttf) have weird version number.
+    // fix them.
+    os2->version = 1;
+    return true;
+  }
+
+  if (!table.ReadS16(&os2->x_height) ||
+      !table.ReadS16(&os2->cap_height) ||
+      !table.ReadU16(&os2->default_char) ||
+      !table.ReadU16(&os2->break_char) ||
+      !table.ReadU16(&os2->max_context)) {
+    return OTS_FAILURE();
+  }
+
+  if (os2->x_height < 0) {
+    OTS_WARNING("bad x_height: %d", os2->x_height);
+    os2->x_height = 0;
+  }
+  if (os2->cap_height < 0) {
+    OTS_WARNING("bad cap_height: %d", os2->cap_height);
+    os2->cap_height = 0;
+  }
+
+  return true;
+}
+
+bool ots_os2_should_serialise(OpenTypeFile *file) {
+  return file->os2;
+}
+
+bool ots_os2_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypeOS2 *os2 = file->os2;
+
+  if (!out->WriteU16(os2->version) ||
+      !out->WriteS16(os2->avg_char_width) ||
+      !out->WriteU16(os2->weight_class) ||
+      !out->WriteU16(os2->width_class) ||
+      !out->WriteU16(os2->type) ||
+      !out->WriteS16(os2->subscript_x_size) ||
+      !out->WriteS16(os2->subscript_y_size) ||
+      !out->WriteS16(os2->subscript_x_offset) ||
+      !out->WriteS16(os2->subscript_y_offset) ||
+      !out->WriteS16(os2->superscript_x_size) ||
+      !out->WriteS16(os2->superscript_y_size) ||
+      !out->WriteS16(os2->superscript_x_offset) ||
+      !out->WriteS16(os2->superscript_y_offset) ||
+      !out->WriteS16(os2->strikeout_size) ||
+      !out->WriteS16(os2->strikeout_position) ||
+      !out->WriteS16(os2->family_class)) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < 10; ++i) {
+    if (!out->Write(&os2->panose[i], 1)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (!out->WriteU32(os2->unicode_range_1) ||
+      !out->WriteU32(os2->unicode_range_2) ||
+      !out->WriteU32(os2->unicode_range_3) ||
+      !out->WriteU32(os2->unicode_range_4) ||
+      !out->WriteU32(os2->vendor_id) ||
+      !out->WriteU16(os2->selection) ||
+      !out->WriteU16(os2->first_char_index) ||
+      !out->WriteU16(os2->last_char_index) ||
+      !out->WriteS16(os2->typo_ascender) ||
+      !out->WriteS16(os2->typo_descender) ||
+      !out->WriteS16(os2->typo_linegap) ||
+      !out->WriteU16(os2->win_ascent) ||
+      !out->WriteU16(os2->win_descent)) {
+    return OTS_FAILURE();
+  }
+
+  if (os2->version < 1) {
+    return true;
+  }
+
+  if (!out->WriteU32(os2->code_page_range_1) ||
+      !out->WriteU32(os2->code_page_range_2)) {
+    return OTS_FAILURE();
+  }
+
+  if (os2->version < 2) {
+    return true;
+  }
+
+  if (!out->WriteS16(os2->x_height) ||
+      !out->WriteS16(os2->cap_height) ||
+      !out->WriteU16(os2->default_char) ||
+      !out->WriteU16(os2->break_char) ||
+      !out->WriteU16(os2->max_context)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_os2_free(OpenTypeFile *file) {
+  delete file->os2;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/os2.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/os2.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,54 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_OS2_H_
+#define OTS_OS2_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeOS2 {
+  uint16_t version;
+  int16_t avg_char_width;
+  uint16_t weight_class;
+  uint16_t width_class;
+  uint16_t type;
+  int16_t subscript_x_size;
+  int16_t subscript_y_size;
+  int16_t subscript_x_offset;
+  int16_t subscript_y_offset;
+  int16_t superscript_x_size;
+  int16_t superscript_y_size;
+  int16_t superscript_x_offset;
+  int16_t superscript_y_offset;
+  int16_t strikeout_size;
+  int16_t strikeout_position;
+  int16_t family_class;
+  uint8_t panose[10];
+  uint32_t unicode_range_1;
+  uint32_t unicode_range_2;
+  uint32_t unicode_range_3;
+  uint32_t unicode_range_4;
+  uint32_t vendor_id;
+  uint16_t selection;
+  uint16_t first_char_index;
+  uint16_t last_char_index;
+  int16_t typo_ascender;
+  int16_t typo_descender;
+  int16_t typo_linegap;
+  uint16_t win_ascent;
+  uint16_t win_descent;
+  uint32_t code_page_range_1;
+  uint32_t code_page_range_2;
+  int16_t x_height;
+  int16_t cap_height;
+  uint16_t default_char;
+  uint16_t break_char;
+  uint16_t max_context;
+};
+
+}  // namespace ots
+
+#endif  // OTS_OS2_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/ots.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/ots.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,634 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ots.h"
+
+#include <sys/types.h>
+#include <zlib.h>
+
+#include <algorithm>
+#include <cstdlib>
+#include <cstring>
+#include <map>
+#include <vector>
+
+// The OpenType Font File
+// http://www.microsoft.com/opentype/otspec/otff.htm
+
+#define F(name, capname) \
+  namespace ots { \
+  bool ots_##name##_parse(OpenTypeFile *f, const uint8_t *d, size_t l); \
+  bool ots_##name##_should_serialise(OpenTypeFile *f); \
+  bool ots_##name##_serialise(OTSStream *s, OpenTypeFile *f); \
+  void ots_##name##_free(OpenTypeFile *f); \
+  }
+  // TODO(yusukes): change these function names to follow Chromium coding rule.
+FOR_EACH_TABLE_TYPE
+#undef F
+
+namespace {
+
+bool g_debug_output = true;
+
+struct OpenTypeTable {
+  uint32_t tag;
+  uint32_t chksum;
+  uint32_t offset;
+  uint32_t length;
+  uint32_t uncompressed_length;
+};
+
+// Round a value up to the nearest multiple of 4. Note that this can overflow
+// and return zero.
+template<typename T> T Round4(T value) {
+  return (value + 3) & ~3;
+}
+
+uint32_t Tag(const char *tag_str) {
+  uint32_t ret;
+  std::memcpy(&ret, tag_str, 4);
+  return ret;
+}
+
+bool CheckTag(uint32_t tag_value) {
+  for (unsigned i = 0; i < 4; ++i) {
+    const uint32_t check = tag_value & 0xff;
+    if (check < 32 || check > 126) {
+      return false;  // non-ASCII character found.
+    }
+    tag_value >>= 8;
+  }
+  return true;
+}
+
+struct OutputTable {
+  uint32_t tag;
+  size_t offset;
+  size_t length;
+  uint32_t chksum;
+
+  static bool SortByTag(const OutputTable& a, const OutputTable& b) {
+    const uint32_t atag = ntohl(a.tag);
+    const uint32_t btag = ntohl(b.tag);
+    return atag < btag;
+  }
+};
+
+struct Arena {
+ public:
+  ~Arena() {
+    for (std::vector<uint8_t*>::iterator
+         i = hunks_.begin(); i != hunks_.end(); ++i) {
+      delete[] *i;
+    }
+  }
+
+  uint8_t* Allocate(size_t length) {
+    uint8_t* p = new uint8_t[length];
+    hunks_.push_back(p);
+    return p;
+  }
+
+ private:
+  std::vector<uint8_t*> hunks_;
+};
+
+const struct {
+  uint32_t tag;
+  bool (*parse)(ots::OpenTypeFile *otf, const uint8_t *data, size_t length);
+  bool (*serialise)(ots::OTSStream *out, ots::OpenTypeFile *file);
+  bool (*should_serialise)(ots::OpenTypeFile *file);
+  void (*free)(ots::OpenTypeFile *file);
+  bool required;
+} table_parsers[] = {
+  { Tag("maxp"), ots::ots_maxp_parse, ots::ots_maxp_serialise,
+    ots::ots_maxp_should_serialise, ots::ots_maxp_free, true },
+  { Tag("head"), ots::ots_head_parse, ots::ots_head_serialise,
+    ots::ots_head_should_serialise, ots::ots_head_free, true },
+  { Tag("OS/2"), ots::ots_os2_parse, ots::ots_os2_serialise,
+    ots::ots_os2_should_serialise, ots::ots_os2_free, true },
+  { Tag("cmap"), ots::ots_cmap_parse, ots::ots_cmap_serialise,
+    ots::ots_cmap_should_serialise, ots::ots_cmap_free, true },
+  { Tag("hhea"), ots::ots_hhea_parse, ots::ots_hhea_serialise,
+    ots::ots_hhea_should_serialise, ots::ots_hhea_free, true },
+  { Tag("hmtx"), ots::ots_hmtx_parse, ots::ots_hmtx_serialise,
+    ots::ots_hmtx_should_serialise, ots::ots_hmtx_free, true },
+  { Tag("name"), ots::ots_name_parse, ots::ots_name_serialise,
+    ots::ots_name_should_serialise, ots::ots_name_free, true },
+  { Tag("post"), ots::ots_post_parse, ots::ots_post_serialise,
+    ots::ots_post_should_serialise, ots::ots_post_free, true },
+  { Tag("loca"), ots::ots_loca_parse, ots::ots_loca_serialise,
+    ots::ots_loca_should_serialise, ots::ots_loca_free, false },
+  { Tag("glyf"), ots::ots_glyf_parse, ots::ots_glyf_serialise,
+    ots::ots_glyf_should_serialise, ots::ots_glyf_free, false },
+  { Tag("CFF "), ots::ots_cff_parse, ots::ots_cff_serialise,
+    ots::ots_cff_should_serialise, ots::ots_cff_free, false },
+  { Tag("VDMX"), ots::ots_vdmx_parse, ots::ots_vdmx_serialise,
+    ots::ots_vdmx_should_serialise, ots::ots_vdmx_free, false },
+  { Tag("hdmx"), ots::ots_hdmx_parse, ots::ots_hdmx_serialise,
+    ots::ots_hdmx_should_serialise, ots::ots_hdmx_free, false },
+  { Tag("gasp"), ots::ots_gasp_parse, ots::ots_gasp_serialise,
+    ots::ots_gasp_should_serialise, ots::ots_gasp_free, false },
+  { Tag("cvt "), ots::ots_cvt_parse, ots::ots_cvt_serialise,
+    ots::ots_cvt_should_serialise, ots::ots_cvt_free, false },
+  { Tag("fpgm"), ots::ots_fpgm_parse, ots::ots_fpgm_serialise,
+    ots::ots_fpgm_should_serialise, ots::ots_fpgm_free, false },
+  { Tag("prep"), ots::ots_prep_parse, ots::ots_prep_serialise,
+    ots::ots_prep_should_serialise, ots::ots_prep_free, false },
+  { Tag("LTSH"), ots::ots_ltsh_parse, ots::ots_ltsh_serialise,
+    ots::ots_ltsh_should_serialise, ots::ots_ltsh_free, false },
+  { Tag("VORG"), ots::ots_vorg_parse, ots::ots_vorg_serialise,
+    ots::ots_vorg_should_serialise, ots::ots_vorg_free, false },
+  { Tag("kern"), ots::ots_kern_parse, ots::ots_kern_serialise,
+    ots::ots_kern_should_serialise, ots::ots_kern_free, false },
+  { Tag("GDEF"), ots::ots_gdef_parse, ots::ots_gdef_serialise,
+    ots::ots_gdef_should_serialise, ots::ots_gdef_free, false },
+  { Tag("GPOS"), ots::ots_gpos_parse, ots::ots_gpos_serialise,
+    ots::ots_gpos_should_serialise, ots::ots_gpos_free, false },
+  { Tag("GSUB"), ots::ots_gsub_parse, ots::ots_gsub_serialise,
+    ots::ots_gsub_should_serialise, ots::ots_gsub_free, false },
+  // TODO(yusukes): Support GDEF, GPOS, GSUB, mort, base, and jstf tables.
+  { 0, NULL, NULL, NULL, NULL, false }
+};
+
+bool IsValidVersionTag(uint32_t tag) {
+  return tag == Tag("\x00\x01\x00\x00") ||
+         // OpenType fonts with CFF data have 'OTTO' tag.
+         tag == Tag("OTTO") ||
+         // Older Mac fonts might have 'true' or 'typ1' tag.
+         tag == Tag("true") ||
+         tag == Tag("typ1");
+}
+
+bool ProcessGeneric(ots::OpenTypeFile *header, ots::OTSStream *output,
+                    const uint8_t *data, size_t length,
+                    const std::vector<OpenTypeTable>& tables,
+                    ots::Buffer& file);
+
+bool ProcessTTF(ots::OpenTypeFile *header,
+                ots::OTSStream *output, const uint8_t *data, size_t length) {
+  ots::Buffer file(data, length);
+
+  // we disallow all files > 1GB in size for sanity.
+  if (length > 1024 * 1024 * 1024) {
+    return OTS_FAILURE();
+  }
+
+  if (!file.ReadTag(&header->version)) {
+    return OTS_FAILURE();
+  }
+  if (!IsValidVersionTag(header->version)) {
+      return OTS_FAILURE();
+  }
+
+  if (!file.ReadU16(&header->num_tables) ||
+      !file.ReadU16(&header->search_range) ||
+      !file.ReadU16(&header->entry_selector) ||
+      !file.ReadU16(&header->range_shift)) {
+    return OTS_FAILURE();
+  }
+
+  // search_range is (Maximum power of 2 <= numTables) x 16. Thus, to avoid
+  // overflow num_tables is, at most, 2^16 / 16 = 2^12
+  if (header->num_tables >= 4096 || header->num_tables < 1) {
+    return OTS_FAILURE();
+  }
+
+  unsigned max_pow2 = 0;
+  while (1u << (max_pow2 + 1) <= header->num_tables) {
+    max_pow2++;
+  }
+  const uint16_t expected_search_range = (1u << max_pow2) << 4;
+
+  // Don't call ots_failure() here since ~25% of fonts (250+ fonts) in
+  // http://www.princexml.com/fonts/ have unexpected search_range value.
+  if (header->search_range != expected_search_range) {
+    OTS_WARNING("bad search range");
+    header->search_range = expected_search_range;  // Fix the value.
+  }
+
+  // entry_selector is Log2(maximum power of 2 <= numTables)
+  if (header->entry_selector != max_pow2) {
+    return OTS_FAILURE();
+  }
+
+  // range_shift is NumTables x 16-searchRange. We know that 16*num_tables
+  // doesn't over flow because we range checked it above. Also, we know that
+  // it's > header->search_range by construction of search_range.
+  const uint32_t expected_range_shift
+      = 16 * header->num_tables - header->search_range;
+  if (header->range_shift != expected_range_shift) {
+    OTS_WARNING("bad range shift");
+    header->range_shift = expected_range_shift;  // the same as above.
+  }
+
+  // Next up is the list of tables.
+  std::vector<OpenTypeTable> tables;
+
+  for (unsigned i = 0; i < header->num_tables; ++i) {
+    OpenTypeTable table;
+    if (!file.ReadTag(&table.tag) ||
+        !file.ReadU32(&table.chksum) ||
+        !file.ReadU32(&table.offset) ||
+        !file.ReadU32(&table.length)) {
+      return OTS_FAILURE();
+    }
+
+    table.uncompressed_length = table.length;
+    tables.push_back(table);
+  }
+
+  return ProcessGeneric(header, output, data, length, tables, file);
+}
+
+bool ProcessWOFF(ots::OpenTypeFile *header,
+                 ots::OTSStream *output, const uint8_t *data, size_t length) {
+  ots::Buffer file(data, length);
+
+  // we disallow all files > 1GB in size for sanity.
+  if (length > 1024 * 1024 * 1024) {
+    return OTS_FAILURE();
+  }
+
+  uint32_t woff_tag;
+  if (!file.ReadTag(&woff_tag)) {
+    return OTS_FAILURE();
+  }
+
+  if (woff_tag != Tag("wOFF")) {
+    return OTS_FAILURE();
+  }
+
+  if (!file.ReadTag(&header->version)) {
+    return OTS_FAILURE();
+  }
+  if (!IsValidVersionTag(header->version)) {
+      return OTS_FAILURE();
+  }
+
+  header->search_range = 0;
+  header->entry_selector = 0;
+  header->range_shift = 0;
+
+  uint32_t reported_length;
+  if (!file.ReadU32(&reported_length) || length != reported_length) {
+    return OTS_FAILURE();
+  }
+
+  if (!file.ReadU16(&header->num_tables)) {
+    return OTS_FAILURE();
+  }
+
+  uint16_t reserved_value;
+  if (!file.ReadU16(&reserved_value) || reserved_value) {
+    return OTS_FAILURE();
+  }
+
+  // We don't care about these fields of the header:
+  //   uint32_t uncompressed_size;
+  //   uint16_t major_version, minor_version
+  //   uint32_t meta_offset, meta_length, meta_length_orig
+  //   uint32_t priv_offset, priv_length
+  if (!file.Skip(6 * 4 + 2 * 2)) {
+    return OTS_FAILURE();
+  }
+
+  // Next up is the list of tables.
+  std::vector<OpenTypeTable> tables;
+
+  for (unsigned i = 0; i < header->num_tables; ++i) {
+    OpenTypeTable table;
+    if (!file.ReadTag(&table.tag) ||
+        !file.ReadU32(&table.offset) ||
+        !file.ReadU32(&table.length) ||
+        !file.ReadU32(&table.uncompressed_length) ||
+        !file.ReadU32(&table.chksum)) {
+      return OTS_FAILURE();
+    }
+
+    tables.push_back(table);
+  }
+
+  return ProcessGeneric(header, output, data, length, tables, file);
+}
+
+bool ProcessGeneric(ots::OpenTypeFile *header, ots::OTSStream *output,
+                    const uint8_t *data, size_t length,
+                    const std::vector<OpenTypeTable>& tables,
+                    ots::Buffer& file) {
+  const size_t data_offset = file.offset();
+
+  uint32_t uncompressed_sum = 0;
+
+  for (unsigned i = 0; i < header->num_tables; ++i) {
+    // the tables must be sorted by tag (when taken as big-endian numbers).
+    // This also remove the possibility of duplicate tables.
+    if (i) {
+      const uint32_t this_tag = ntohl(tables[i].tag);
+      const uint32_t prev_tag = ntohl(tables[i - 1].tag);
+      if (this_tag <= prev_tag) {
+        return OTS_FAILURE();
+      }
+    }
+
+    // all tag names must be built from printable ASCII characters
+    if (!CheckTag(tables[i].tag)) {
+      return OTS_FAILURE();
+    }
+
+    // tables must be 4-byte aligned
+    if (tables[i].offset & 3) {
+      return OTS_FAILURE();
+    }
+
+    // and must be within the file
+    if (tables[i].offset < data_offset || tables[i].offset >= length) {
+      return OTS_FAILURE();
+    }
+    // disallow all tables with a zero length
+    if (tables[i].length < 1) {
+      // Note: malayalam.ttf has zero length CVT table...
+      return OTS_FAILURE();
+    }
+    // disallow all tables with a length > 1GB
+    if (tables[i].length > 1024 * 1024 * 1024) {
+      return OTS_FAILURE();
+    }
+    // disallow tables where the uncompressed size is < the compressed size.
+    if (tables[i].uncompressed_length < tables[i].length) {
+      return OTS_FAILURE();
+    }
+    if (tables[i].uncompressed_length > tables[i].length) {
+      // We'll probably be decompressing this table.
+
+      // disallow all tables which uncompress to > 30 MB
+      if (tables[i].uncompressed_length > 30 * 1024 * 1024) {
+        return OTS_FAILURE();
+      }
+      if (uncompressed_sum + tables[i].uncompressed_length < uncompressed_sum) {
+        return OTS_FAILURE();
+      }
+
+      uncompressed_sum += tables[i].uncompressed_length;
+    }
+    // since we required that the file be < 1GB in length, and that the table
+    // length is < 1GB, the following addtion doesn't overflow
+    const uint32_t end_byte = Round4(tables[i].offset + tables[i].length);
+    if (!end_byte || end_byte > length) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // All decompressed tables uncompressed must be <= 30MB.
+  if (uncompressed_sum > 30 * 1024 * 1024) {
+    return OTS_FAILURE();
+  }
+
+  std::map<uint32_t, OpenTypeTable> table_map;
+  for (unsigned i = 0; i < header->num_tables; ++i) {
+    table_map[tables[i].tag] = tables[i];
+  }
+
+  // check that the tables are not overlapping.
+  std::vector<std::pair<uint32_t, uint8_t> > overlap_checker;
+  for (unsigned i = 0; i < header->num_tables; ++i) {
+    overlap_checker.push_back(
+        std::make_pair(tables[i].offset, 1 /* start */));
+    overlap_checker.push_back(
+        std::make_pair(tables[i].offset + tables[i].length, 0 /* end */));
+  }
+  std::sort(overlap_checker.begin(), overlap_checker.end());
+  int overlap_count = 0;
+  for (unsigned i = 0; i < overlap_checker.size(); ++i) {
+    overlap_count += (overlap_checker[i].second ? 1 : -1);
+    if (overlap_count > 1) {
+      return OTS_FAILURE();
+    }
+  }
+
+  Arena arena;
+
+  for (unsigned i = 0; ; ++i) {
+    if (table_parsers[i].parse == NULL) break;
+
+    const std::map<uint32_t, OpenTypeTable>::const_iterator it
+        = table_map.find(table_parsers[i].tag);
+
+    if (it == table_map.end()) {
+      if (table_parsers[i].required) {
+        return OTS_FAILURE();
+      }
+      continue;
+    }
+
+    const uint8_t* table_data;
+    size_t table_length;
+
+    if (it->second.uncompressed_length != it->second.length) {
+      // compressed table. Need to uncompress into memory first.
+      table_length = it->second.uncompressed_length;
+      table_data = arena.Allocate(table_length);
+      uLongf dest_len = table_length;
+      int r = uncompress((Bytef*) table_data, &dest_len,
+                         data + it->second.offset, it->second.length);
+      if (r != Z_OK || dest_len != table_length) {
+        return OTS_FAILURE();
+      }
+    } else {
+      // uncompressed table. We can process directly from memory.
+      table_data = data + it->second.offset;
+      table_length = it->second.length;
+    }
+
+    if (!table_parsers[i].parse(header, table_data, table_length)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  if (header->cff) {
+    // font with PostScript glyph
+    if (header->version != Tag("OTTO")) {
+      return OTS_FAILURE();
+    }
+    if (header->glyf || header->loca) {
+      // mixing outline formats is not recommended
+      return OTS_FAILURE();
+    }
+  } else {
+    if (!header->glyf || !header->loca) {
+      // No TrueType glyph found.
+      // Note: bitmap-only fonts are not supported.
+      return OTS_FAILURE();
+    }
+  }
+
+  unsigned num_output_tables = 0;
+  for (unsigned i = 0; ; ++i) {
+    if (table_parsers[i].parse == NULL) {
+      break;
+    }
+
+    if (table_parsers[i].should_serialise(header)) {
+      num_output_tables++;
+    }
+  }
+
+  unsigned max_pow2 = 0;
+  while (1u << (max_pow2 + 1) <= num_output_tables) {
+    max_pow2++;
+  }
+  const uint16_t output_search_range = (1u << max_pow2) << 4;
+
+  output->ResetChecksum();
+  if (!output->WriteTag(header->version) ||
+      !output->WriteU16(num_output_tables) ||
+      !output->WriteU16(output_search_range) ||
+      !output->WriteU16(max_pow2) ||
+      !output->WriteU16((num_output_tables << 4) - output_search_range)) {
+    return OTS_FAILURE();
+  }
+  const uint32_t offset_table_chksum = output->chksum();
+
+  const size_t table_record_offset = output->Tell();
+  if (!output->Pad(16 * num_output_tables)) {
+    return OTS_FAILURE();
+  }
+
+  std::vector<OutputTable> out_tables;
+
+  size_t head_table_offset = 0;
+  for (unsigned i = 0; ; ++i) {
+    if (table_parsers[i].parse == NULL) {
+      break;
+    }
+
+    if (!table_parsers[i].should_serialise(header)) {
+      continue;
+    }
+
+    OutputTable out;
+    out.tag = table_parsers[i].tag;
+    out.offset = output->Tell();
+
+    output->ResetChecksum();
+    if (table_parsers[i].tag == Tag("head")) {
+      head_table_offset = out.offset;
+    }
+    if (!table_parsers[i].serialise(output, header)) {
+      return OTS_FAILURE();
+    }
+
+    const size_t end_offset = output->Tell();
+    if (end_offset <= out.offset) {
+      // paranoid check. |end_offset| is supposed to be greater than the offset,
+      // as long as the Tell() interface is implemented correctly.
+      return OTS_FAILURE();
+    }
+    out.length = end_offset - out.offset;
+
+    // align tables to four bytes
+    if (!output->Pad((4 - (end_offset & 3)) % 4)) {
+      return OTS_FAILURE();
+    }
+    out.chksum = output->chksum();
+    out_tables.push_back(out);
+  }
+
+  const size_t end_of_file = output->Tell();
+
+  // Need to sort the output tables for inclusion in the file
+  std::sort(out_tables.begin(), out_tables.end(), OutputTable::SortByTag);
+  if (!output->Seek(table_record_offset)) {
+    return OTS_FAILURE();
+  }
+
+  output->ResetChecksum();
+  uint32_t tables_chksum = 0;
+  for (unsigned i = 0; i < out_tables.size(); ++i) {
+    if (!output->WriteTag(out_tables[i].tag) ||
+        !output->WriteU32(out_tables[i].chksum) ||
+        !output->WriteU32(out_tables[i].offset) ||
+        !output->WriteU32(out_tables[i].length)) {
+      return OTS_FAILURE();
+    }
+    tables_chksum += out_tables[i].chksum;
+  }
+  const uint32_t table_record_chksum = output->chksum();
+
+  // http://www.microsoft.com/typography/otspec/otff.htm
+  const uint32_t file_chksum
+      = offset_table_chksum + tables_chksum + table_record_chksum;
+  const uint32_t chksum_magic = static_cast<uint32_t>(0xb1b0afba) - file_chksum;
+
+  // seek into the 'head' table and write in the checksum magic value
+  if (!head_table_offset) {
+    return OTS_FAILURE();  // not reached.
+  }
+  if (!output->Seek(head_table_offset + 8)) {
+    return OTS_FAILURE();
+  }
+  if (!output->WriteU32(chksum_magic)) {
+    return OTS_FAILURE();
+  }
+
+  if (!output->Seek(end_of_file)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+}  // namespace
+
+namespace ots {
+
+void DisableDebugOutput() {
+  g_debug_output = false;
+}
+
+bool Process(OTSStream *output, const uint8_t *data, size_t length, bool preserveOTL) {
+  OpenTypeFile header;
+  if (length < 4) {
+    return OTS_FAILURE();
+  }
+
+  header.preserve_otl = preserveOTL;
+
+  bool result;
+  if (data[0] == 'w' && data[1] == 'O' && data[2] == 'F' && data[3] == 'F') {
+    result = ProcessWOFF(&header, output, data, length);
+  } else {
+    result = ProcessTTF(&header, output, data, length);
+  }
+
+  for (unsigned i = 0; ; ++i) {
+    if (table_parsers[i].parse == NULL) break;
+    table_parsers[i].free(&header);
+  }
+  return result;
+}
+
+#if !defined(_MSC_VER) && defined(OTS_DEBUG)
+bool Failure(const char *f, int l, const char *fn) {
+  if (g_debug_output) {
+    std::fprintf(stderr, "ERROR at %s:%d (%s)\n", f, l, fn);
+    std::fflush(stderr);
+  }
+  return false;
+}
+
+void Warning(const char *f, int l, const char *format, ...) {
+  if (g_debug_output) {
+    std::fprintf(stderr, "WARNING at %s:%d: ", f, l);
+    std::va_list va;
+    va_start(va, format);
+    std::vfprintf(stderr, format, va);
+    va_end(va);
+    std::fprintf(stderr, "\n");
+    std::fflush(stderr);
+  }
+}
+#endif
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/ots.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/ots.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,212 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_H_
+#define OTS_H_
+
+#include <cstdarg>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+
+#include "opentype-sanitiser.h"
+
+namespace ots {
+
+#if defined(_MSC_VER) || !defined(OTS_DEBUG)
+#define OTS_FAILURE() false
+#else
+#define OTS_FAILURE() ots::Failure(__FILE__, __LINE__, __PRETTY_FUNCTION__)
+bool Failure(const char *f, int l, const char *fn);
+#endif
+
+#if defined(_MSC_VER)
+// MSVC supports C99 style variadic macros.
+#define OTS_WARNING(format, ...)
+#else
+// GCC
+#if defined(OTS_DEBUG)
+#define OTS_WARNING(format, args...) \
+    ots::Warning(__FILE__, __LINE__, format, ##args)
+void Warning(const char *f, int l, const char *format, ...)
+     __attribute__((format(printf, 3, 4)));
+#else
+#define OTS_WARNING(format, args...)
+#endif
+#endif
+
+// Define OTS_NO_TRANSCODE_HINTS (i.e., g++ -DOTS_NO_TRANSCODE_HINTS) if you
+// want to omit TrueType hinting instructions and variables in glyf, fpgm, prep,
+// and cvt tables.
+#if defined(OTS_NO_TRANSCODE_HINTS)
+const bool g_transcode_hints = false;
+#else
+const bool g_transcode_hints = true;
+#endif
+
+// -----------------------------------------------------------------------------
+// Buffer helper class
+//
+// This class perform some trival buffer operations while checking for
+// out-of-bounds errors. As a family they return false if anything is amiss,
+// updating the current offset otherwise.
+// -----------------------------------------------------------------------------
+class Buffer {
+ public:
+  Buffer(const uint8_t *buffer, size_t len)
+      : buffer_(buffer),
+        length_(len),
+        offset_(0) { }
+
+  bool Skip(size_t n_bytes) {
+    return Read(NULL, n_bytes);
+  }
+
+  bool Read(uint8_t *buffer, size_t n_bytes) {
+    if (n_bytes > 1024 * 1024 * 1024) {
+      return OTS_FAILURE();
+    }
+    if ((offset_ + n_bytes > length_) ||
+        (offset_ > length_ - n_bytes)) {
+      return OTS_FAILURE();
+    }
+    if (buffer) {
+      std::memcpy(buffer, buffer_ + offset_, n_bytes);
+    }
+    offset_ += n_bytes;
+    return true;
+  }
+
+  inline bool ReadU8(uint8_t *value) {
+    if (offset_ + 1 > length_) {
+      return OTS_FAILURE();
+    }
+    *value = buffer_[offset_];
+    ++offset_;
+    return true;
+  }
+
+  bool ReadU16(uint16_t *value) {
+    if (offset_ + 2 > length_) {
+      return OTS_FAILURE();
+    }
+    std::memcpy(value, buffer_ + offset_, sizeof(uint16_t));
+    *value = ntohs(*value);
+    offset_ += 2;
+    return true;
+  }
+
+  bool ReadS16(int16_t *value) {
+    return ReadU16(reinterpret_cast<uint16_t*>(value));
+  }
+
+  bool ReadU24(uint32_t *value) {
+    if (offset_ + 3 > length_) {
+      return OTS_FAILURE();
+    }
+    *value = static_cast<uint32_t>(buffer_[offset_]) << 16 |
+             static_cast<uint32_t>(buffer_[offset_ + 1]) << 8 |
+             static_cast<uint32_t>(buffer_[offset_ + 2]);
+    offset_ += 3;
+    return true;
+  }
+
+  bool ReadU32(uint32_t *value) {
+    if (offset_ + 4 > length_) {
+      return OTS_FAILURE();
+    }
+    std::memcpy(value, buffer_ + offset_, sizeof(uint32_t));
+    *value = ntohl(*value);
+    offset_ += 4;
+    return true;
+  }
+
+  bool ReadS32(int32_t *value) {
+    return ReadU32(reinterpret_cast<uint32_t*>(value));
+  }
+
+  bool ReadTag(uint32_t *value) {
+    if (offset_ + 4 > length_) {
+      return OTS_FAILURE();
+    }
+    std::memcpy(value, buffer_ + offset_, sizeof(uint32_t));
+    offset_ += 4;
+    return true;
+  }
+
+  bool ReadR64(uint64_t *value) {
+    if (offset_ + 8 > length_) {
+      return OTS_FAILURE();
+    }
+    std::memcpy(value, buffer_ + offset_, sizeof(uint64_t));
+    offset_ += 8;
+    return true;
+  }
+
+  const uint8_t *buffer() const { return buffer_; }
+  size_t offset() const { return offset_; }
+  size_t length() const { return length_; }
+
+  void set_offset(size_t newoffset) { offset_ = newoffset; }
+
+ private:
+  const uint8_t * const buffer_;
+  const size_t length_;
+  size_t offset_;
+};
+
+#define FOR_EACH_TABLE_TYPE \
+  F(cff, CFF) \
+  F(cmap, CMAP) \
+  F(cvt, CVT) \
+  F(fpgm, FPGM) \
+  F(gasp, GASP) \
+  F(glyf, GLYF) \
+  F(hdmx, HDMX) \
+  F(head, HEAD) \
+  F(hhea, HHEA) \
+  F(hmtx, HMTX) \
+  F(kern, KERN) \
+  F(loca, LOCA) \
+  F(ltsh, LTSH) \
+  F(maxp, MAXP) \
+  F(name, NAME) \
+  F(os2, OS2) \
+  F(post, POST) \
+  F(prep, PREP) \
+  F(vdmx, VDMX) \
+  F(vorg, VORG) \
+  F(gdef, GDEF) \
+  F(gpos, GPOS) \
+  F(gsub, GSUB)
+
+#define F(name, capname) struct OpenType##capname;
+FOR_EACH_TABLE_TYPE
+#undef F
+
+struct OpenTypeFile {
+  OpenTypeFile() {
+#define F(name, capname) name = NULL;
+    FOR_EACH_TABLE_TYPE
+#undef F
+  }
+
+  uint32_t version;
+  uint16_t num_tables;
+  uint16_t search_range;
+  uint16_t entry_selector;
+  uint16_t range_shift;
+
+  // This is used to tell the GDEF/GPOS/GSUB parsers whether to preserve the
+  // OpenType Layout tables (**without** any checking).
+  bool preserve_otl;
+
+#define F(name, capname) OpenType##capname *name;
+FOR_EACH_TABLE_TYPE
+#undef F
+};
+
+}  // namespace ots
+
+#endif  // OTS_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/post.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/post.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,181 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "post.h"
+
+#include "maxp.h"
+
+// post - PostScript
+// http://www.microsoft.com/opentype/otspec/post.htm
+
+namespace ots {
+
+bool ots_post_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypePOST *post = new OpenTypePOST;
+  file->post = post;
+
+  if (!table.ReadU32(&post->version) ||
+      !table.ReadU32(&post->italic_angle) ||
+      !table.ReadS16(&post->underline) ||
+      !table.ReadS16(&post->underline_thickness) ||
+      !table.ReadU32(&post->is_fixed_pitch)) {
+    return OTS_FAILURE();
+  }
+
+  if (post->underline_thickness < 0) {
+    post->underline_thickness = 1;
+  }
+
+  if (post->version == 0x00010000) {
+    return true;
+  } else if (post->version == 0x00030000) {
+    return true;
+  } else if (post->version != 0x00020000) {
+    // 0x00025000 is deprecated. We don't accept it.
+    return OTS_FAILURE();
+  }
+
+  // We have a version 2 table with a list of Pascal strings at the end
+
+  // We don't care about the memory usage fields. We'll set all these to zero
+  // when serialising
+  if (!table.Skip(16)) {
+    return OTS_FAILURE();
+  }
+
+  uint16_t num_glyphs = 0;
+  if (!table.ReadU16(&num_glyphs)) {
+    return OTS_FAILURE();
+  }
+
+  if (!file->maxp) {
+    return OTS_FAILURE();
+  }
+
+  if (num_glyphs == 0) {
+    if (file->maxp->num_glyphs > 258) {
+      return OTS_FAILURE();
+    }
+    OTS_WARNING("table version is 1, but no glyf names are found");
+    // workaround for fonts in http://www.fontsquirrel.com/fontface
+    // (e.g., yataghan.ttf).
+    post->version = 0x00010000;
+    return true;
+  }
+
+  if (num_glyphs != file->maxp->num_glyphs) {
+    // Note: Fixedsys500c.ttf seems to have inconsistent num_glyphs values.
+    return OTS_FAILURE();
+  }
+
+  post->glyph_name_index.resize(num_glyphs);
+  for (unsigned i = 0; i < num_glyphs; ++i) {
+    if (!table.ReadU16(&post->glyph_name_index[i])) {
+      return OTS_FAILURE();
+    }
+    if (post->glyph_name_index[i] >= 32768) {
+      // Note: droid_arialuni.ttf fails this test.
+      return OTS_FAILURE();  // reserved area.
+    }
+  }
+
+  // Now we have an array of Pascal strings. We have to check that they are all
+  // valid and read them in.
+  const size_t strings_offset = table.offset();
+  const uint8_t *strings = data + strings_offset;
+  const uint8_t *strings_end = data + length;
+
+  for (;;) {
+    if (strings == strings_end) break;
+    const unsigned string_length = *strings;
+    if (strings + 1 + string_length > strings_end) {
+      return OTS_FAILURE();
+    }
+    if (std::memchr(strings + 1, '\0', string_length)) {
+      return OTS_FAILURE();
+    }
+    post->names.push_back(
+        std::string(reinterpret_cast<const char*>(strings + 1), string_length));
+    strings += 1 + string_length;
+  }
+  const unsigned num_strings = post->names.size();
+
+  // check that all the references are within bounds
+  for (unsigned i = 0; i < num_glyphs; ++i) {
+    unsigned offset = post->glyph_name_index[i];
+    if (offset < 258) {
+      continue;
+    }
+
+    offset -= 258;
+    if (offset >= num_strings) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+bool ots_post_should_serialise(OpenTypeFile *file) {
+  return file->post;
+}
+
+bool ots_post_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypePOST *post = file->post;
+
+  // OpenType with CFF glyphs must have v3 post table.
+  if (file->post && file->cff && file->post->version != 0x00030000) {
+    return OTS_FAILURE();
+  }
+
+  if (!out->WriteU32(post->version) ||
+      !out->WriteU32(post->italic_angle) ||
+      !out->WriteS16(post->underline) ||
+      !out->WriteS16(post->underline_thickness) ||
+      !out->WriteU32(post->is_fixed_pitch) ||
+      !out->WriteU32(0) ||
+      !out->WriteU32(0) ||
+      !out->WriteU32(0) ||
+      !out->WriteU32(0)) {
+    return OTS_FAILURE();
+  }
+
+  if (post->version != 0x00020000) {
+    return true;  // v1.0 and v3.0 does not have glyph names.
+  }
+
+  if (!out->WriteU16(post->glyph_name_index.size())) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < post->glyph_name_index.size(); ++i) {
+    if (!out->WriteU16(post->glyph_name_index[i])) {
+      return OTS_FAILURE();
+    }
+  }
+
+  // Now we just have to write out the strings in the correct order
+  for (unsigned i = 0; i < post->names.size(); ++i) {
+    const std::string& s = post->names[i];
+    const uint8_t string_length = s.size();
+    if (!out->Write(&string_length, 1)) {
+      return OTS_FAILURE();
+    }
+    // Some ttf fonts (e.g., frank.ttf on Windows Vista) have zero-length name.
+    // We allow them.
+    if (string_length > 0 && !out->Write(s.data(), string_length)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_post_free(OpenTypeFile *file) {
+  delete file->post;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/post.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/post.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,29 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_POST_H_
+#define OTS_POST_H_
+
+#include "ots.h"
+
+#include <map>
+#include <string>
+#include <vector>
+
+namespace ots {
+
+struct OpenTypePOST {
+  uint32_t version;
+  uint32_t italic_angle;
+  int16_t underline;
+  int16_t underline_thickness;
+  uint32_t is_fixed_pitch;
+
+  std::vector<uint16_t> glyph_name_index;
+  std::vector<std::string> names;
+};
+
+}  // namespace ots
+
+#endif  // OTS_POST_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/prep.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/prep.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,50 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "prep.h"
+
+// prep - Control Value Program
+// http://www.microsoft.com/opentype/otspec/prep.htm
+
+namespace ots {
+
+bool ots_prep_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+
+  OpenTypePREP *prep = new OpenTypePREP;
+  file->prep = prep;
+
+  if (length >= 128 * 1024u) {
+    return OTS_FAILURE();  // almost all prep tables are less than 9k bytes.
+  }
+
+  if (!table.Skip(length)) {
+    return OTS_FAILURE();
+  }
+
+  prep->data = data;
+  prep->length = length;
+  return true;
+}
+
+bool ots_prep_should_serialise(OpenTypeFile *file) {
+  if (!file->glyf) return false;  // this table is not for CFF fonts.
+  return g_transcode_hints && file->prep;
+}
+
+bool ots_prep_serialise(OTSStream *out, OpenTypeFile *file) {
+  const OpenTypePREP *prep = file->prep;
+
+  if (!out->Write(prep->data, prep->length)) {
+    return OTS_FAILURE();
+  }
+
+  return true;
+}
+
+void ots_prep_free(OpenTypeFile *file) {
+  delete file->prep;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/prep.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/prep.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,19 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_PREP_H_
+#define OTS_PREP_H_
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypePREP {
+  const uint8_t *data;
+  uint32_t length;
+};
+
+}  // namespace ots
+
+#endif  // OTS_PREP_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/vdmx.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/vdmx.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,177 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "vdmx.h"
+
+// VDMX - Vertical Device Metrics
+// http://www.microsoft.com/opentype/otspec/vdmx.htm
+
+#define DROP_THIS_TABLE \
+  do { delete file->vdmx; file->vdmx = 0; } while (0)
+
+namespace ots {
+
+bool ots_vdmx_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  file->vdmx = new OpenTypeVDMX;
+  OpenTypeVDMX * const vdmx = file->vdmx;
+
+  if (!table.ReadU16(&vdmx->version) ||
+      !table.ReadU16(&vdmx->num_recs) ||
+      !table.ReadU16(&vdmx->num_ratios)) {
+    return OTS_FAILURE();
+  }
+
+  if (vdmx->version > 1) {
+    OTS_WARNING("bad version: %u", vdmx->version);
+    DROP_THIS_TABLE;
+    return true;  // continue transcoding
+  }
+
+  vdmx->rat_ranges.reserve(vdmx->num_ratios);
+  for (unsigned i = 0; i < vdmx->num_ratios; ++i) {
+    OpenTypeVDMXRatioRecord rec;
+
+    if (!table.ReadU8(&rec.charset) ||
+        !table.ReadU8(&rec.x_ratio) ||
+        !table.ReadU8(&rec.y_start_ratio) ||
+        !table.ReadU8(&rec.y_end_ratio)) {
+      return OTS_FAILURE();
+    }
+
+    if (rec.charset > 1) {
+      OTS_WARNING("bad charset: %u", rec.charset);
+      DROP_THIS_TABLE;
+      return true;
+    }
+
+    if (rec.y_start_ratio > rec.y_end_ratio) {
+      OTS_WARNING("bad y ratio");
+      DROP_THIS_TABLE;
+      return true;
+    }
+
+    // All values set to zero signal the default grouping to use;
+    // if present, this must be the last Ratio group in the table.
+    if ((i < vdmx->num_ratios - 1u) &&
+        (rec.x_ratio == 0) &&
+        (rec.y_start_ratio == 0) &&
+        (rec.y_end_ratio == 0)) {
+      // workaround for fonts which have 2 or more {0, 0, 0} terminators.
+      OTS_WARNING("superfluous terminator found");
+      DROP_THIS_TABLE;
+      return true;
+    }
+
+    vdmx->rat_ranges.push_back(rec);
+  }
+
+  vdmx->offsets.reserve(vdmx->num_ratios);
+  const size_t current_offset = table.offset();
+  // current_offset is less than (2 bytes * 3) + (4 bytes * USHRT_MAX) = 256k.
+  for (unsigned i = 0; i < vdmx->num_ratios; ++i) {
+    uint16_t offset;
+    if (!table.ReadU16(&offset)) {
+      return OTS_FAILURE();
+    }
+    if (current_offset + offset >= length) {  // thus doesn't overflow.
+      return OTS_FAILURE();
+    }
+
+    vdmx->offsets.push_back(offset);
+  }
+
+  vdmx->groups.reserve(vdmx->num_recs);
+  for (unsigned i = 0; i < vdmx->num_recs; ++i) {
+    OpenTypeVDMXGroup group;
+    if (!table.ReadU16(&group.recs) ||
+        !table.ReadU8(&group.startsz) ||
+        !table.ReadU8(&group.endsz)) {
+      return OTS_FAILURE();
+    }
+    group.entries.reserve(group.recs);
+    for (unsigned j = 0; j < group.recs; ++j) {
+      OpenTypeVDMXVTable vt;
+      if (!table.ReadU16(&vt.y_pel_height) ||
+          !table.ReadS16(&vt.y_max) ||
+          !table.ReadS16(&vt.y_min)) {
+        return OTS_FAILURE();
+      }
+      if (vt.y_max < vt.y_min) {
+        OTS_WARNING("bad y min/max");
+        DROP_THIS_TABLE;
+        return true;
+      }
+
+      // This table must appear in sorted order (sorted by yPelHeight),
+      // but need not be continuous.
+      if ((j != 0) && (group.entries[j - 1].y_pel_height >= vt.y_pel_height)) {
+        OTS_WARNING("the table is not sorted");
+        DROP_THIS_TABLE;
+        return true;
+      }
+
+      group.entries.push_back(vt);
+    }
+    vdmx->groups.push_back(group);
+  }
+
+  return true;
+}
+
+bool ots_vdmx_should_serialise(OpenTypeFile *file) {
+  if (!file->glyf) return false;  // this table is not for CFF fonts.
+  return file->vdmx;
+}
+
+bool ots_vdmx_serialise(OTSStream *out, OpenTypeFile *file) {
+  OpenTypeVDMX * const vdmx = file->vdmx;
+
+  if (!out->WriteU16(vdmx->version) ||
+      !out->WriteU16(vdmx->num_recs) ||
+      !out->WriteU16(vdmx->num_ratios)) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < vdmx->rat_ranges.size(); ++i) {
+    const OpenTypeVDMXRatioRecord& rec = vdmx->rat_ranges[i];
+    if (!out->Write(&rec.charset, 1) ||
+        !out->Write(&rec.x_ratio, 1) ||
+        !out->Write(&rec.y_start_ratio, 1) ||
+        !out->Write(&rec.y_end_ratio, 1)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  for (unsigned i = 0; i < vdmx->offsets.size(); ++i) {
+    if (!out->WriteU16(vdmx->offsets[i])) {
+      return OTS_FAILURE();
+    }
+  }
+
+  for (unsigned i = 0; i < vdmx->groups.size(); ++i) {
+    const OpenTypeVDMXGroup& group = vdmx->groups[i];
+    if (!out->WriteU16(group.recs) ||
+        !out->Write(&group.startsz, 1) ||
+        !out->Write(&group.endsz, 1)) {
+      return OTS_FAILURE();
+    }
+    for (unsigned j = 0; j < group.entries.size(); ++j) {
+      const OpenTypeVDMXVTable& vt = group.entries[j];
+      if (!out->WriteU16(vt.y_pel_height) ||
+          !out->WriteS16(vt.y_max) ||
+          !out->WriteS16(vt.y_min)) {
+        return OTS_FAILURE();
+      }
+    }
+  }
+
+  return true;
+}
+
+void ots_vdmx_free(OpenTypeFile *file) {
+  delete file->vdmx;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/vdmx.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/vdmx.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,45 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_VDMX_H_
+#define OTS_VDMX_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeVDMXRatioRecord {
+  uint8_t charset;
+  uint8_t x_ratio;
+  uint8_t y_start_ratio;
+  uint8_t y_end_ratio;
+};
+
+struct OpenTypeVDMXVTable {
+  uint16_t y_pel_height;
+  int16_t y_max;
+  int16_t y_min;
+};
+
+struct OpenTypeVDMXGroup {
+  uint16_t recs;
+  uint8_t startsz;
+  uint8_t endsz;
+  std::vector<OpenTypeVDMXVTable> entries;
+};
+
+struct OpenTypeVDMX {
+  uint16_t version;
+  uint16_t num_recs;
+  uint16_t num_ratios;
+  std::vector<OpenTypeVDMXRatioRecord> rat_ranges;
+  std::vector<uint16_t> offsets;
+  std::vector<OpenTypeVDMXGroup> groups;
+};
+
+}  // namespace ots
+
+#endif  // OTS_VDMX_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/vorg.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/vorg.cc	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,97 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "vorg.h"
+
+#include <vector>
+
+// VORG - Vertical Origin Table
+// http://www.microsoft.com/opentype/otspec/vorg.htm
+
+#define DROP_THIS_TABLE \
+  do { delete file->vorg; file->vorg = 0; } while (0)
+
+namespace ots {
+
+bool ots_vorg_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
+  Buffer table(data, length);
+  file->vorg = new OpenTypeVORG;
+  OpenTypeVORG * const vorg = file->vorg;
+
+  uint16_t num_recs;
+  if (!table.ReadU16(&vorg->major_version) ||
+      !table.ReadU16(&vorg->minor_version) ||
+      !table.ReadS16(&vorg->default_vert_origin_y) ||
+      !table.ReadU16(&num_recs)) {
+    return OTS_FAILURE();
+  }
+  if (vorg->major_version != 1) {
+    OTS_WARNING("bad major version: %u", vorg->major_version);
+    DROP_THIS_TABLE;
+    return true;
+  }
+  if (vorg->minor_version != 0) {
+    OTS_WARNING("bad minor version: %u", vorg->minor_version);
+    DROP_THIS_TABLE;
+    return true;
+  }
+
+  // num_recs might be zero (e.g., DFHSMinchoPro5-W3-Demo.otf).
+  if (!num_recs) {
+    return true;
+  }
+
+  uint16_t last_glyph_index = 0;
+  vorg->metrics.reserve(num_recs);
+  for (unsigned i = 0; i < num_recs; ++i) {
+    OpenTypeVORGMetrics rec;
+
+    if (!table.ReadU16(&rec.glyph_index) ||
+        !table.ReadS16(&rec.vert_origin_y)) {
+      return OTS_FAILURE();
+    }
+    if ((i != 0) && (rec.glyph_index <= last_glyph_index)) {
+      OTS_WARNING("the table is not sorted");
+      DROP_THIS_TABLE;
+      return true;
+    }
+    last_glyph_index = rec.glyph_index;
+
+    vorg->metrics.push_back(rec);
+  }
+
+  return true;
+}
+
+bool ots_vorg_should_serialise(OpenTypeFile *file) {
+  if (!file->cff) return false;  // this table is not for fonts with TT glyphs.
+  return file->vorg;
+}
+
+bool ots_vorg_serialise(OTSStream *out, OpenTypeFile *file) {
+  OpenTypeVORG * const vorg = file->vorg;
+
+  if (!out->WriteU16(vorg->major_version) ||
+      !out->WriteU16(vorg->minor_version) ||
+      !out->WriteS16(vorg->default_vert_origin_y) ||
+      !out->WriteU16(vorg->metrics.size())) {
+    return OTS_FAILURE();
+  }
+
+  for (unsigned i = 0; i < vorg->metrics.size(); ++i) {
+    const OpenTypeVORGMetrics& rec = vorg->metrics[i];
+    if (!out->WriteU16(rec.glyph_index) ||
+        !out->WriteS16(rec.vert_origin_y)) {
+      return OTS_FAILURE();
+    }
+  }
+
+  return true;
+}
+
+void ots_vorg_free(OpenTypeFile *file) {
+  delete file->vorg;
+}
+
+}  // namespace ots
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/ots/src/vorg.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/ots/src/vorg.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,28 @@
+// Copyright (c) 2009 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OTS_VORG_H_
+#define OTS_VORG_H_
+
+#include <vector>
+
+#include "ots.h"
+
+namespace ots {
+
+struct OpenTypeVORGMetrics {
+  uint16_t glyph_index;
+  int16_t vert_origin_y;
+};
+
+struct OpenTypeVORG {
+  uint16_t major_version;
+  uint16_t minor_version;
+  int16_t default_vert_origin_y;
+  std::vector<OpenTypeVORGMetrics> metrics;
+};
+
+}  // namespace ots
+
+#endif  // OTS_VORG_H_
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/public/gfxPlatform.h
--- a/gfx/thebes/public/gfxPlatform.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/public/gfxPlatform.h	Thu Dec 02 20:33:03 2010 -0500
@@ -226,6 +226,16 @@
      */
     virtual PRBool DownloadableFontsEnabled();
 
+    /**
+     * Whether to sanitize downloaded fonts using the OTS library
+     */
+    PRBool SanitizeDownloadedFonts();
+
+    /**
+     * Whether to preserve OpenType layout tables when sanitizing
+     */
+    PRBool PreserveOTLTablesWhenSanitizing();
+
     // check whether format is supported on a platform or not (if unclear, returns true)
     virtual PRBool IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags) { return PR_FALSE; }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/Makefile.in
--- a/gfx/thebes/src/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -20,6 +20,7 @@
 	uconv \
 	$(LCMS_REQUIRES) \
 	qcms \
+	ots/src \
 	$(NULL)
 
 CPPSRCS	= \
@@ -51,6 +52,7 @@
 	$(NSPR_LIBS) \
 	$(ZLIB_LIBS) \
 	$(QCMS_LIBS) \
+	$(MOZ_OTS_LIBS) \
 	$(NULL)
 
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/gfxFontUtils.cpp
--- a/gfx/thebes/src/gfxFontUtils.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/gfxFontUtils.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1403,7 +1403,7 @@
     }
 
     nsresult rv;
-    nsCOMPtr<nsICharsetConverterManager> ccm =
+    nsCOMPtr<nsICharsetConverterManager_1_9_BRANCH> ccm =
         do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get charset converter manager");
     if (NS_FAILED(rv)) {
@@ -1411,7 +1411,7 @@
     }
 
     nsCOMPtr<nsIUnicodeDecoder> decoder;
-    rv = ccm->GetUnicodeDecoderRaw(csName, getter_AddRefs(decoder));
+    rv = ccm->GetUnicodeDecoderRawInternal(csName, getter_AddRefs(decoder));
     if (NS_FAILED(rv)) {
         NS_WARNING("failed to get the decoder for a font name string");
         return PR_FALSE;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/gfxMacPlatformFontList.mm
--- a/gfx/thebes/src/gfxMacPlatformFontList.mm	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/gfxMacPlatformFontList.mm	Thu Dec 02 20:33:03 2010 -0500
@@ -527,7 +527,12 @@
             } else if (macTraits & NSExpandedFontMask) {
                 fontEntry->mStretch = NS_FONT_STRETCH_EXPANDED;
             }
-            if (macTraits & NSItalicFontMask) {
+            // Cocoa fails to set the Italic traits bit for HelveticaLightItalic,
+            // at least (see bug 611855), so check for style name endings as well
+            if ((macTraits & NSItalicFontMask) ||
+                [facename hasSuffix:@"Italic"] ||
+                [facename hasSuffix:@"Oblique"])
+            {
                 fontEntry->mItalic = PR_TRUE;
             }
             if (macTraits & NSFixedPitchFontMask) {
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/gfxPlatform.cpp
--- a/gfx/thebes/src/gfxPlatform.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/gfxPlatform.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -308,6 +308,23 @@
 }
 
 #define GFX_DOWNLOADABLE_FONTS_ENABLED "gfx.downloadable_fonts.enabled"
+#define GFX_DOWNLOADABLE_FONTS_SANITIZE "gfx.downloadable_fonts.sanitize"
+#define GFX_DOWNLOADABLE_FONTS_SANITIZE_PRESERVE_OTL \
+            "gfx.downloadable_fonts.sanitize.preserve_otl_tables"
+
+static PRBool
+GetBoolPref(const char* aPref, PRBool aDefaultValue = PR_FALSE)
+{
+    nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+    if (prefs) {
+        PRBool value;
+        nsresult rv = prefs->GetBoolPref(aPref, &value);
+        if (NS_SUCCEEDED(rv)) {
+            return value;
+        }
+    }
+    return aDefaultValue;
+}
 
 PRBool
 gfxPlatform::DownloadableFontsEnabled()
@@ -317,18 +334,42 @@
 
     if (initialized == PR_FALSE) {
         initialized = PR_TRUE;
-        nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
-        if (prefs) {
-            PRBool allow;
-            nsresult rv = prefs->GetBoolPref(GFX_DOWNLOADABLE_FONTS_ENABLED, &allow);
-            if (NS_SUCCEEDED(rv))
-                allowDownloadableFonts = allow;
-        }
+        allowDownloadableFonts = GetBoolPref(GFX_DOWNLOADABLE_FONTS_ENABLED);
     }
 
     return allowDownloadableFonts;
 }
 
+PRBool
+gfxPlatform::SanitizeDownloadedFonts()
+{
+    static PRBool initialized = PR_FALSE;
+    static PRBool sanitizeDownloadableFonts = PR_TRUE;
+
+    if (initialized == PR_FALSE) {
+        initialized = PR_TRUE;
+        sanitizeDownloadableFonts =
+            GetBoolPref(GFX_DOWNLOADABLE_FONTS_SANITIZE, PR_TRUE);
+    }
+
+    return sanitizeDownloadableFonts;
+}
+
+PRBool
+gfxPlatform::PreserveOTLTablesWhenSanitizing()
+{
+    static PRBool initialized = PR_FALSE;
+    static PRBool preserveOTLTables = PR_FALSE;
+
+    if (initialized == PR_FALSE) {
+        initialized = PR_TRUE;
+        preserveOTLTables =
+            GetBoolPref(GFX_DOWNLOADABLE_FONTS_SANITIZE_PRESERVE_OTL);
+    }
+
+    return preserveOTLTables;
+}
+
 gfxFontEntry*
 gfxPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
                               const PRUint8 *aFontData,
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/gfxUserFontSet.cpp
--- a/gfx/thebes/src/gfxUserFontSet.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/gfxUserFontSet.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -49,6 +49,9 @@
 
 #include "woff.h"
 
+#include "opentype-sanitiser.h"
+#include "ots-memory-stream.h"
+
 #ifdef PR_LOGGING
 static PRLogModuleInfo *gUserFontsLog = PR_NewLogModule("userfonts");
 #endif /* PR_LOGGING */
@@ -223,6 +226,92 @@
     return nsnull;
 }
 
+// Based on ots::ExpandingMemoryStream from ots-memory-stream.h,
+// adapted to use Mozilla allocators and to allow the final
+// memory buffer to be adopted by the client.
+class ExpandingMemoryStream : public ots::OTSStream {
+public:
+    ExpandingMemoryStream(size_t initial, size_t limit)
+        : mLength(initial), mLimit(limit), mOff(0) {
+        mPtr = NS_Alloc(mLength);
+    }
+
+    ~ExpandingMemoryStream() {
+        NS_Free(mPtr);
+    }
+
+    // return the buffer, and give up ownership of it
+    // so the caller becomes responsible to call NS_Free
+    // when finished with it
+    void* forget() {
+        void* p = mPtr;
+        mPtr = nsnull;
+        return p;
+    }
+
+    bool WriteRaw(const void *data, size_t length) {
+        if ((mOff + length > mLength) ||
+            (mLength > std::numeric_limits<size_t>::max() - mOff)) {
+            if (mLength == mLimit) {
+                return false;
+            }
+            size_t newLength = (mLength + 1) * 2;
+            if (newLength < mLength) {
+                return false;
+            }
+            if (newLength > mLimit) {
+                newLength = mLimit;
+            }
+            mPtr = NS_Realloc(mPtr, newLength);
+            mLength = newLength;
+            return WriteRaw(data, length);
+        }
+        std::memcpy(static_cast<char*>(mPtr) + mOff, data, length);
+        mOff += length;
+        return true;
+    }
+
+    bool Seek(off_t position) {
+        if (position < 0) {
+            return false;
+        }
+        if (static_cast<size_t>(position) > mLength) {
+            return false;
+        }
+        mOff = position;
+        return true;
+    }
+
+    off_t Tell() const {
+        return mOff;
+    }
+
+private:
+    void*        mPtr;
+    size_t       mLength;
+    const size_t mLimit;
+    off_t        mOff;
+};
+
+// Call the OTS library to sanitize an sfnt before attempting to use it.
+// Returns a newly-allocated block, or NULL in case of fatal errors.
+static const PRUint8*
+SanitizeOpenTypeData(const PRUint8* aData, PRUint32 aLength,
+                     PRUint32& aSaneLength, bool aIsCompressed)
+{
+    // limit output/expansion to 256MB
+    ExpandingMemoryStream output(aIsCompressed ? aLength * 2 : aLength,
+                                 1024 * 1024 * 256);
+    if (ots::Process(&output, aData, aLength,
+        gfxPlatform::GetPlatform()->PreserveOTLTablesWhenSanitizing())) {
+        aSaneLength = output.Tell();
+        return static_cast<PRUint8*>(output.forget());
+    } else {
+        aSaneLength = 0;
+        return nsnull;
+    }
+}
+
 // This is called when a font download finishes.
 // Ownership of aFontData passes in here, and the font set must
 // ensure that it is eventually deleted via NS_Free().
@@ -244,26 +333,65 @@
     if (NS_SUCCEEDED(aDownloadStatus)) {
         gfxFontEntry *fe = nsnull;
 
-        // Unwrap/decompress or otherwise munge the downloaded data
+        // Unwrap/decompress/sanitize or otherwise munge the downloaded data
         // to make a usable sfnt structure.
         // This may cause aFontData to point to a new buffer, or be NULL.
-        aFontData = PrepareOpenTypeData(aFontData, &aLength);
-        if (aFontData &&
-            gfxFontUtils::ValidateSFNTHeaders(aFontData, aLength)) {
-            // Here ownership of aFontData is passed to the platform,
-            // which will delete it when no longer required
-            fe = gfxPlatform::GetPlatform()->MakePlatformFont(pe,
-                                                              aFontData,
-                                                              aLength);
-            aFontData = nsnull; // the platform may have freed the data now!
+
+        if (gfxPlatform::GetPlatform()->SanitizeDownloadedFonts()) {
+            gfxUserFontType fontType =
+                gfxFontUtils::DetermineFontDataType(aFontData, aLength);
+
+            // Call the OTS sanitizer; this will also decode WOFF to sfnt
+            // if necessary. The original data in aFontData is left unchanged.
+            PRUint32 saneLen;
+            const PRUint8* saneData =
+                SanitizeOpenTypeData(aFontData, aLength, saneLen,
+                                     fontType == GFX_USERFONT_WOFF);
+#ifdef DEBUG
+            if (!saneData) {
+                char buf[1000];
+                sprintf(buf, "downloaded font rejected for \"%s\"",
+                        NS_ConvertUTF16toUTF8(pe->FamilyName()).get());
+                NS_WARNING(buf);
+            }
+#endif
+            if (saneData) {
+                // Here ownership of saneData is passed to the platform,
+                // which will delete it when no longer required
+                fe = gfxPlatform::GetPlatform()->MakePlatformFont(pe,
+                                                                  saneData,
+                                                                  saneLen);
+                if (!fe) {
+                    NS_WARNING("failed to make platform font from download");
+                }
+            }
         } else {
-            // the data was unusable, so just discard it
-            // (error will be reported below, if logging is enabled)
+            // FIXME: this code can be removed if we remove the pref to
+            // disable the sanitizer; the PrepareOpenTypeData and
+            // ValidateSFNTHeaders functions will then be obsolete.
+            aFontData = PrepareOpenTypeData(aFontData, &aLength);
+
             if (aFontData) {
-                NS_Free((void*)aFontData);
+                if (gfxFontUtils::ValidateSFNTHeaders(aFontData, aLength)) {
+                    // Here ownership of aFontData is passed to the platform,
+                    // which will delete it when no longer required
+                    fe = gfxPlatform::GetPlatform()->MakePlatformFont(pe,
+                                                                      aFontData,
+                                                                      aLength);
+                    aFontData = nsnull; // we must NOT free this below!
+                } else {
+                    // the data was unusable, so just discard it
+                    // (error will be reported below, if logging is enabled)
+                    NS_WARNING("failed to make platform font from download");
+                }
             }
         }
 
+        if (aFontData) {
+            NS_Free((void*)aFontData);
+            aFontData = nsnull;
+        }
+
         if (fe) {
             static_cast<gfxMixedFontFamily*>(pe->mFamily)->ReplaceFontEntry(pe, fe);
             IncrementGeneration();
@@ -291,9 +419,6 @@
         }
     } else {
         // download failed
-        if (aFontData) {
-            NS_Free((void*)aFontData);
-        }
 #ifdef PR_LOGGING
         if (LOG_ENABLED()) {
             nsCAutoString fontURI;
@@ -306,6 +431,10 @@
 #endif
     }
 
+    if (aFontData) {
+        NS_Free((void*)aFontData);
+    }
+
     // error occurred, load next src
     LoadStatus status;
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/gfxWindowsFonts.cpp
--- a/gfx/thebes/src/gfxWindowsFonts.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/gfxWindowsFonts.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1536,9 +1536,9 @@
         nsAutoString utf16;
         AppendASCIItoUTF16(cString, utf16);
         if (isComplex) {
-            InitTextRunUniscribe(aParams->mContext, textRun, utf16.get(), aLength);
+            InitTextRunUniscribe(aParams->mContext, textRun, utf16.get(), utf16.Length());
         } else {
-            InitTextRunGDI(aParams->mContext, textRun, utf16.get(), aLength);
+            InitTextRunGDI(aParams->mContext, textRun, utf16.get(), utf16.Length());
         }
     }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/gfxWindowsSurface.cpp
--- a/gfx/thebes/src/gfxWindowsSurface.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/gfxWindowsSurface.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -179,7 +179,7 @@
                                  const nsAString& aPrintToFileName)
 {
 #ifdef NS_PRINTING
-#define DOC_TITLE_LENGTH 30
+#define DOC_TITLE_LENGTH (MAX_PATH-1)
     DOCINFOW docinfo;
 
     nsString titleStr(aTitle);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/woff.c
--- a/gfx/thebes/src/woff.c	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/woff.c	Thu Dec 02 20:33:03 2010 -0500
@@ -955,6 +955,122 @@
   return NULL;
 }
 
+/* functions to get size and data of a single table */
+
+uint32_t woffGetTableSize(const uint8_t * woffData, uint32_t woffLen,
+                          uint32_t tag, uint32_t * pStatus)
+{
+  uint32_t status = eWOFF_ok;
+  const woffHeader * header;
+  uint16_t numTables;
+  uint16_t tableIndex;
+  const woffDirEntry * woffDir;
+
+  if (pStatus && WOFF_FAILURE(*pStatus)) {
+    return 0;
+  }
+
+  status = sanityCheck(woffData, woffLen);
+  if (WOFF_FAILURE(status)) {
+    FAIL(status);
+  }
+
+  header = (const woffHeader *) (woffData);
+
+  numTables = READ16BE(header->numTables);
+  woffDir = (const woffDirEntry *) (woffData + sizeof(woffHeader));
+
+  for (tableIndex = 0; tableIndex < numTables; ++tableIndex) {
+    uint32_t thisTag;
+    thisTag = READ32BE(woffDir[tableIndex].tag);
+    if (thisTag < tag) {
+      continue;
+    }
+    if (thisTag > tag) {
+      break;
+    }
+    return READ32BE(woffDir[tableIndex].origLen);
+  }
+
+  status = eWOFF_warn_no_such_table;
+
+failure:
+  if (pStatus) {
+    *pStatus = status;
+  }
+  return 0;
+}
+
+void woffGetTableToBuffer(const uint8_t * woffData, uint32_t woffLen,
+                          uint32_t tag, uint8_t * buffer, uint32_t bufferLen,
+                          uint32_t * pTableLen, uint32_t * pStatus)
+{
+  uint32_t status = eWOFF_ok;
+  const woffHeader * header;
+  uint16_t numTables;
+  uint16_t tableIndex;
+  const woffDirEntry * woffDir;
+
+  if (pStatus && WOFF_FAILURE(*pStatus)) {
+    return;
+  }
+
+  status = sanityCheck(woffData, woffLen);
+  if (WOFF_FAILURE(status)) {
+    FAIL(status);
+  }
+
+  header = (const woffHeader *) (woffData);
+
+  numTables = READ16BE(header->numTables);
+  woffDir = (const woffDirEntry *) (woffData + sizeof(woffHeader));
+
+  for (tableIndex = 0; tableIndex < numTables; ++tableIndex) {
+    uint32_t thisTag, origLen, compLen, sourceOffset;
+    thisTag = READ32BE(woffDir[tableIndex].tag);
+    if (thisTag < tag) {
+      continue;
+    }
+    if (thisTag > tag) {
+      break;
+    }
+
+    /* found the required table: decompress it (checking for overflow) */
+    origLen = READ32BE(woffDir[tableIndex].origLen);
+    if (origLen > bufferLen) {
+      FAIL(eWOFF_buffer_too_small);
+    }
+
+    compLen = READ32BE(woffDir[tableIndex].compLen);
+    sourceOffset = READ32BE(woffDir[tableIndex].offset);
+
+    if (compLen < origLen) {
+      uLongf destLen = origLen;
+      if (uncompress((Bytef *)(buffer), &destLen,
+                     (const Bytef *)(woffData + sourceOffset),
+                     compLen) != Z_OK || destLen != origLen) {
+        FAIL(eWOFF_compression_failure);
+      }
+    } else {
+      memcpy(buffer, woffData + sourceOffset, origLen);
+    }
+
+    if (pTableLen) {
+      *pTableLen = origLen;
+    }
+
+    return;
+  }
+
+  status = eWOFF_warn_no_such_table;
+
+failure:
+  if (pStatus) {
+    *pStatus = status;
+  }
+}
+
+
 #ifndef WOFF_MOZILLA_CLIENT
 
 const uint8_t *
diff -r 8fe44c79dfd1 -r 0c159bd1d600 gfx/thebes/src/woff.h
--- a/gfx/thebes/src/woff.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/gfx/thebes/src/woff.h	Thu Dec 02 20:33:03 2010 -0500
@@ -42,7 +42,7 @@
 
 #ifdef _MSC_VER /* MS VC lacks inttypes.h
                    but we can make do with a few definitons here */
-typedef char           int8_t;
+typedef signed char    int8_t;
 typedef short          int16_t;
 typedef int            int32_t;
 typedef unsigned char  uint8_t;
@@ -81,8 +81,9 @@
                                             any DSIG may be invalid */
   eWOFF_warn_unpadded_table = 0x1000,    /* sfnt not correctly padded,
                                             any DSIG may be invalid */
-  eWOFF_warn_removed_DSIG = 0x2000       /* removed digital signature
+  eWOFF_warn_removed_DSIG = 0x2000,      /* removed digital signature
                                             while fixing checksum errors */
+  eWOFF_warn_no_such_table = 0x4000      /* specified table not present */
 };
 
 /* Note: status parameters must be initialized to eWOFF_ok before calling
@@ -167,6 +168,23 @@
 
 
 /*****************************************************************************
+ * Returns the size of buffer needed for a specific table (or zero on error).
+ */
+uint32_t woffGetTableSize(const uint8_t * woffData, uint32_t woffLen,
+                          uint32_t tag, uint32_t * pStatus);
+
+
+/*****************************************************************************
+ * Gets a table from a WOFF font to a caller-supplied buffer of size bufferLen.
+ * Returns the actual size of the decoded table in pTableLen
+ * (must be <= bufferLen, otherwise an error will be returned).
+ */
+void woffGetTableToBuffer(const uint8_t * woffData, uint32_t woffLen,
+                          uint32_t tag, uint8_t * buffer, uint32_t bufferLen,
+                          uint32_t * pTableLen, uint32_t * pStatus);
+
+
+/*****************************************************************************
  * Returns a new malloc() block containing the metadata from the WOFF font,
  * or NULL if an error occurs or no metadata is present.
  * Length of the metadata is returned in metaLen.
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/locale/src/mac/nsCollationMacUC.h
--- a/intl/locale/src/mac/nsCollationMacUC.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/locale/src/mac/nsCollationMacUC.h	Thu Dec 02 20:33:03 2010 -0500
@@ -47,8 +47,8 @@
 // the generated collation key.
 const PRUint32 kCacheSize = 128;
 // According to the documentation, the length of the key should typically be
-// at least 5 * textLength
-const PRUint32 kCollationValueSizeFactor = 5;
+// at least 5 * textLength, but 6* would be safer.
+const PRUint32 kCollationValueSizeFactor = 6;
 
 class nsCollationMacUC : public nsICollation {
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/idl/nsICharsetConverterManager.idl
--- a/intl/uconv/idl/nsICharsetConverterManager.idl	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/idl/nsICharsetConverterManager.idl	Thu Dec 02 20:33:03 2010 -0500
@@ -113,10 +113,11 @@
      * character encoding may be used for certain purposes, if it is 
      * multi-byte, and the language code for it. See charsetData.properties
      * for the source of this data. Some known property names:
-     *    notForBrowser  - not to be used in the bowser.
+     *    notForBrowser  - not to be used in the browser.
      *    notForOutgoing - not to be used for exporting files.
      *    LangGroup      - language code for charset, e.g. 'he' and 'zh-CN'.
      *    isMultibyte    - is this a multi-byte charset?
+     *    isXSSVulnerable - not to be used in untrusted web content
      * 
      * @param charset name of the character encoding, e.g. 'iso-8859-15'.
      * @param prop property desired for the character encoding.
@@ -135,3 +136,16 @@
     nsIAtom getCharsetLangGroup(in string charset);
     nsIAtom getCharsetLangGroupRaw(in string charset);
 };
+
+[scriptable, uuid(36982132-707c-4d77-b27f-958e76e022de)]
+interface nsICharsetConverterManager_1_9_BRANCH : nsICharsetConverterManager
+{
+    /**
+     * "Internal" versions of getUnicodeDecoder* will return a decoder for any
+     *  charset; the other versions will return NS_ERROR_UCONV_NOCONV if the
+     *  requested charset is vulnerable to XSS attacks and should not be used
+     * with untrusted input
+     */
+    nsIUnicodeDecoder getUnicodeDecoderInternal(in string charset);
+    nsIUnicodeDecoder getUnicodeDecoderRawInternal(in string charset);
+};
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/idl/nsIScriptableUConv.idl
--- a/intl/uconv/idl/nsIScriptableUConv.idl	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/idl/nsIScriptableUConv.idl	Thu Dec 02 20:33:03 2010 -0500
@@ -102,3 +102,16 @@
    */
   attribute string charset;
 };
+
+[scriptable, uuid(f7ed6618-5ff5-4f0b-bb83-48ce63eb289b)]
+interface nsIScriptableUnicodeConverter_1_9_BRANCH : nsIScriptableUnicodeConverter
+{
+  /**
+   * Internal use
+   *
+   * When this attribute is set, all charsets may be accessed.
+   * When it is not set (the default), charsets with the isXSSVulnerable flag
+   *  may not be accessed
+   */
+  attribute boolean isInternal;
+};
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/src/charsetData.properties
--- a/intl/uconv/src/charsetData.properties	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/src/charsetData.properties	Thu Dec 02 20:33:03 2010 -0500
@@ -47,6 +47,10 @@
 ## charset_name.notForOutgoing = anything  -  specifies that this charset is 
 ## not to be used for exporting files ('SaveAsCharset' in composer)
 ##
+## charset_name.isXSSVulnerable = anything - specifies that this charset is
+## known to be vulnerable to XSS attacks and should not be exposed to web
+## content
+##
 ## charset_name.LangGroup = 
 ##
 ## charset_name.isMultibyte = multi byte charsets
@@ -63,6 +67,13 @@
 ibm1131.notForBrowser                   = true
 iso-8859-8-e.notForBrowser              = true
 utf-7.notForBrowser                     = true
+x-mac-arabic.notForBrowser              = true
+x-mac-farsi.notForBrowser               = true
+x-mac-hebrew.notForBrowser              = true
+
+x-mac-arabic.isXSSVulnerable            = true
+x-mac-farsi.isXSSVulnerable             = true
+x-mac-hebrew.isXSSVulnerable            = true
 
 t.61-8bit.notForOutgoing             = true
 utf-7.notForOutgoing                 = true
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/src/nsCharsetConverterManager.cpp
--- a/intl/uconv/src/nsCharsetConverterManager.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/src/nsCharsetConverterManager.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -66,8 +66,9 @@
 
 // Class nsCharsetConverterManager [implementation]
 
-NS_IMPL_THREADSAFE_ISUPPORTS1(nsCharsetConverterManager,
-                              nsICharsetConverterManager)
+NS_IMPL_THREADSAFE_ISUPPORTS2(nsCharsetConverterManager,
+                              nsICharsetConverterManager,
+                              nsICharsetConverterManager_1_9_BRANCH)
 
 nsCharsetConverterManager::nsCharsetConverterManager() 
   :mDataBundle(NULL), mTitleBundle(NULL)
@@ -213,6 +214,20 @@
 }
 
 NS_IMETHODIMP
+nsCharsetConverterManager::GetUnicodeDecoderRaw(const char * aSrc,
+                                                nsIUnicodeDecoder ** aResult)
+{
+  nsresult rv;
+
+  nsAutoString str;
+  rv = GetCharsetData(aSrc, NS_LITERAL_STRING(".isXSSVulnerable").get(), str);
+  if (NS_SUCCEEDED(rv))
+    return NS_ERROR_UCONV_NOCONV;
+
+  return GetUnicodeDecoderRawInternal(aSrc, aResult);
+}
+
+NS_IMETHODIMP
 nsCharsetConverterManager::GetUnicodeDecoder(const char * aSrc, 
                                              nsIUnicodeDecoder ** aResult)
 {
@@ -227,8 +242,22 @@
 }
 
 NS_IMETHODIMP
-nsCharsetConverterManager::GetUnicodeDecoderRaw(const char * aSrc, 
-                                                nsIUnicodeDecoder ** aResult)
+nsCharsetConverterManager::GetUnicodeDecoderInternal(const char * aSrc, 
+                                                     nsIUnicodeDecoder ** aResult)
+{
+  // resolve the charset first
+  nsCAutoString charset;
+  
+  // fully qualify to possibly avoid vtable call
+  nsCharsetConverterManager::GetCharsetAlias(aSrc, charset);
+
+  return nsCharsetConverterManager::GetUnicodeDecoderRawInternal(charset.get(),
+                                                                 aResult);
+}
+
+NS_IMETHODIMP
+nsCharsetConverterManager::GetUnicodeDecoderRawInternal(const char * aSrc, 
+                                                        nsIUnicodeDecoder ** aResult)
 {
   *aResult= nsnull;
   nsCOMPtr<nsIUnicodeDecoder> decoder;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/src/nsCharsetConverterManager.h
--- a/intl/uconv/src/nsCharsetConverterManager.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/src/nsCharsetConverterManager.h	Thu Dec 02 20:33:03 2010 -0500
@@ -46,10 +46,11 @@
 #include "nsINativeUConvService.h"
 #endif
 
-class nsCharsetConverterManager : public nsICharsetConverterManager
+class nsCharsetConverterManager : public nsICharsetConverterManager_1_9_BRANCH
 {
   NS_DECL_ISUPPORTS
   NS_DECL_NSICHARSETCONVERTERMANAGER
+  NS_DECL_NSICHARSETCONVERTERMANAGER_1_9_BRANCH
 
 public:
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/src/nsScriptableUConv.cpp
--- a/intl/uconv/src/nsScriptableUConv.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/src/nsScriptableUConv.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -52,9 +52,12 @@
 static PRInt32          gInstanceCount = 0;
 
 /* Implementation file */
-NS_IMPL_ISUPPORTS1(nsScriptableUnicodeConverter, nsIScriptableUnicodeConverter)
+NS_IMPL_ISUPPORTS2(nsScriptableUnicodeConverter,
+                   nsIScriptableUnicodeConverter,
+                   nsIScriptableUnicodeConverter_1_9_BRANCH)
 
 nsScriptableUnicodeConverter::nsScriptableUnicodeConverter()
+: mIsInternal(PR_FALSE)
 {
   PR_AtomicIncrement(&gInstanceCount);
 }
@@ -270,13 +273,27 @@
   return InitConverter();
 }
 
+NS_IMETHODIMP
+nsScriptableUnicodeConverter::GetIsInternal(PRBool *aIsInternal)
+{
+  *aIsInternal = mIsInternal;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScriptableUnicodeConverter::SetIsInternal(const PRBool aIsInternal)
+{
+  mIsInternal = aIsInternal;
+  return NS_OK;
+}
+
 nsresult
 nsScriptableUnicodeConverter::InitConverter()
 {
   nsresult rv = NS_OK;
   mEncoder = NULL ;
 
-  nsCOMPtr<nsICharsetConverterManager> ccm = do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
+  nsCOMPtr<nsICharsetConverterManager_1_9_BRANCH> ccm = do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
 
   if (NS_SUCCEEDED( rv) && (nsnull != ccm)) {
     // get charset atom due to getting unicode converter
@@ -286,7 +303,11 @@
     if(NS_SUCCEEDED(rv)) {
       rv = mEncoder->SetOutputErrorBehavior(nsIUnicodeEncoder::kOnError_Replace, nsnull, (PRUnichar)'?');
       if(NS_SUCCEEDED(rv)) {
-        rv = ccm->GetUnicodeDecoder(mCharset.get(), getter_AddRefs(mDecoder));
+        rv = mIsInternal ?
+          ccm->GetUnicodeDecoderInternal(mCharset.get(),
+                                         getter_AddRefs(mDecoder)) :
+          ccm->GetUnicodeDecoder(mCharset.get(),
+                                 getter_AddRefs(mDecoder));
       }
     }
   }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/src/nsScriptableUConv.h
--- a/intl/uconv/src/nsScriptableUConv.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/src/nsScriptableUConv.h	Thu Dec 02 20:33:03 2010 -0500
@@ -44,11 +44,12 @@
 #include "nsICharsetConverterManager.h"
 #include "nsIScriptableUConv.h"
 
-class nsScriptableUnicodeConverter : public nsIScriptableUnicodeConverter
+class nsScriptableUnicodeConverter : public nsIScriptableUnicodeConverter_1_9_BRANCH
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISCRIPTABLEUNICODECONVERTER
+  NS_DECL_NSISCRIPTABLEUNICODECONVERTER_1_9_BRANCH
 
   nsScriptableUnicodeConverter();
   virtual ~nsScriptableUnicodeConverter();
@@ -57,6 +58,7 @@
   nsCString mCharset;
   nsCOMPtr<nsIUnicodeEncoder> mEncoder;
   nsCOMPtr<nsIUnicodeDecoder> mDecoder;
+  PRPackedBool mIsInternal;
 
   nsresult FinishWithLength(char **_retval, PRInt32* aLength);
   nsresult ConvertFromUnicodeWithLength(const nsAString& aSrc,
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_bug601429.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/uconv/tests/unit/test_bug601429.js	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,52 @@
+const Ci = Components.interfaces;
+const Cc = Components.classes;
+const CC = Components.Constructor;
+
+// Tests whether characters above 0x7F decode to ASCII characters liable to 
+// expose XSS vulnerabilities
+function run_test() {
+  var failures = false;
+  var ccManager = Cc["@mozilla.org/charset-converter-manager;1"]
+        .getService(Ci.nsICharsetConverterManager);
+
+  var ScriptableUnicodeConverter = 
+    CC("@mozilla.org/intl/scriptableunicodeconverter",
+       "nsIScriptableUnicodeConverter");
+  var decodingConverter = new ScriptableUnicodeConverter();
+
+  var charsetList = ccManager.getDecoderList();
+  var counter = 0;
+  while (charsetList.hasMore()) {
+    ++counter;
+    var charset = charsetList.getNext();
+    dump("testing " + counter + " " + charset + "\n");
+      
+    try {
+      decodingConverter.charset = charset;
+    } catch(e) {
+      dump("Warning: couldn't set decoder charset to " + charset + "\n");
+      continue;
+    }
+    for (var i = 0x80; i < 0x100; ++i) {
+      var inString = String.fromCharCode(i);
+      var outString;
+      try {
+	outString = decodingConverter.ConvertToUnicode(inString) +
+	                decodingConverter.Finish();
+      } catch(e) {
+	outString = String.fromCharCode(0xFFFD);
+      }
+      for (var n = 0; n < outString.length; ++n) {
+	var outChar = outString.charAt(n);
+	if (outChar == '<' || outChar == '>' || outChar == '/') {
+	  dump(charset + " has a problem: " + escape(inString) +
+	       " decodes to '" + outString + "'\n");
+	  failures = true;
+	}
+      }
+    }
+  }
+  if (failures) {
+    do_throw("test failed\n");
+  }
+}
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_decode_x_mac_arabic.js
--- a/intl/uconv/tests/unit/test_decode_x_mac_arabic.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/tests/unit/test_decode_x_mac_arabic.js	Thu Dec 02 20:33:03 2010 -0500
@@ -9,11 +9,26 @@
 function run_test() {
     var ScriptableUnicodeConverter =
 	Components.Constructor("@mozilla.org/intl/scriptableunicodeconverter",
-			       "nsIScriptableUnicodeConverter");
+			       "nsIScriptableUnicodeConverter_1_9_BRANCH");
 
     var converter = new ScriptableUnicodeConverter();
+    try {
+	converter.charset = charset;
+    } catch(e) {
+	// expected to throw before we set isInternal
+	converter.charset = "iso-8859-1";
+    }
+
+    var outString = converter.ConvertToUnicode(inString) + converter.Finish();
+    // expected to fail
+    do_check_neq(outString, expectedString);
+
+    // Set isInternal and try again
+    converter.isInternal = true;
+
     converter.charset = charset;
 
     var outString = converter.ConvertToUnicode(inString) + converter.Finish();
+    // expected to pass this time
     do_check_eq(outString, expectedString);
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_decode_x_mac_farsi.js
--- a/intl/uconv/tests/unit/test_decode_x_mac_farsi.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/tests/unit/test_decode_x_mac_farsi.js	Thu Dec 02 20:33:03 2010 -0500
@@ -9,11 +9,26 @@
 function run_test() {
     var ScriptableUnicodeConverter =
 	Components.Constructor("@mozilla.org/intl/scriptableunicodeconverter",
-			       "nsIScriptableUnicodeConverter");
+			       "nsIScriptableUnicodeConverter_1_9_BRANCH");
 
     var converter = new ScriptableUnicodeConverter();
+    try {
+	converter.charset = charset;
+    } catch(e) {
+	// expected to throw before we set isInternal
+	converter.charset = "iso-8859-1";
+    }
+
+    var outString = converter.ConvertToUnicode(inString) + converter.Finish();
+    // expected to fail
+    do_check_neq(outString, expectedString);
+
+    // Set isInternal and try again
+    converter.isInternal = true;
+
     converter.charset = charset;
 
     var outString = converter.ConvertToUnicode(inString) + converter.Finish();
+    // expected to pass this time
     do_check_eq(outString, expectedString);
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_decode_x_mac_hebrew.js
--- a/intl/uconv/tests/unit/test_decode_x_mac_hebrew.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/tests/unit/test_decode_x_mac_hebrew.js	Thu Dec 02 20:33:03 2010 -0500
@@ -9,11 +9,26 @@
 function run_test() {
     var ScriptableUnicodeConverter =
 	Components.Constructor("@mozilla.org/intl/scriptableunicodeconverter",
-			       "nsIScriptableUnicodeConverter");
+			       "nsIScriptableUnicodeConverter_1_9_BRANCH");
 
     var converter = new ScriptableUnicodeConverter();
+    try {
+	converter.charset = charset;
+    } catch(e) {
+	// expected to throw before we set isInternal
+	converter.charset = "iso-8859-1";
+    }
+
+    var outString = converter.ConvertToUnicode(inString) + converter.Finish();
+    // expected to fail
+    do_check_neq(outString, expectedString);
+
+    // Set isInternal and try again
+    converter.isInternal = true;
+
     converter.charset = charset;
 
     var outString = converter.ConvertToUnicode(inString) + converter.Finish();
+    // expected to pass this time
     do_check_eq(outString, expectedString);
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_encode_x_mac_arabic.js
--- a/intl/uconv/tests/unit/test_encode_x_mac_arabic.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/tests/unit/test_encode_x_mac_arabic.js	Thu Dec 02 20:33:03 2010 -0500
@@ -9,11 +9,25 @@
 function run_test() {
     var ScriptableUnicodeConverter =
 	Components.Constructor("@mozilla.org/intl/scriptableunicodeconverter",
-			       "nsIScriptableUnicodeConverter");
+			       "nsIScriptableUnicodeConverter_1_9_BRANCH");
 
     var converter = new ScriptableUnicodeConverter();
+    try {
+	converter.charset = charset;
+    } catch(e) {
+	// expected to throw before we set isInternal
+	converter.charset = "iso-8859-1";
+    }
+
+    var outString = converter.ConvertFromUnicode(inString) + converter.Finish();
+    do_check_neq(outString, expectedString);
+
+    // Set isInternal and try again
+    converter.isInternal = true;
+
     converter.charset = charset;
 
     var outString = converter.ConvertFromUnicode(inString) + converter.Finish();
+    // expected to pass this time
     do_check_eq(outString, expectedString);
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_encode_x_mac_farsi.js
--- a/intl/uconv/tests/unit/test_encode_x_mac_farsi.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/tests/unit/test_encode_x_mac_farsi.js	Thu Dec 02 20:33:03 2010 -0500
@@ -9,11 +9,25 @@
 function run_test() {
     var ScriptableUnicodeConverter =
 	Components.Constructor("@mozilla.org/intl/scriptableunicodeconverter",
-			       "nsIScriptableUnicodeConverter");
+			       "nsIScriptableUnicodeConverter_1_9_BRANCH");
 
     var converter = new ScriptableUnicodeConverter();
+    try {
+	converter.charset = charset;
+    } catch(e) {
+	// expected to throw before we set isInternal
+	converter.charset = "iso-8859-1";
+    }
+
+    var outString = converter.ConvertFromUnicode(inString) + converter.Finish();
+    do_check_neq(outString, expectedString);
+
+    // Set isInternal and try again
+    converter.isInternal = true;
+
     converter.charset = charset;
 
     var outString = converter.ConvertFromUnicode(inString) + converter.Finish();
+    // expected to pass this time
     do_check_eq(outString, expectedString);
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 intl/uconv/tests/unit/test_encode_x_mac_hebrew.js
--- a/intl/uconv/tests/unit/test_encode_x_mac_hebrew.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/intl/uconv/tests/unit/test_encode_x_mac_hebrew.js	Thu Dec 02 20:33:03 2010 -0500
@@ -9,11 +9,25 @@
 function run_test() {
     var ScriptableUnicodeConverter =
 	Components.Constructor("@mozilla.org/intl/scriptableunicodeconverter",
-			       "nsIScriptableUnicodeConverter");
+			       "nsIScriptableUnicodeConverter_1_9_BRANCH");
 
     var converter = new ScriptableUnicodeConverter();
+    try {
+	converter.charset = charset;
+    } catch(e) {
+	// expected to throw before we set isInternal
+	converter.charset = "iso-8859-1";
+    }
+
+    var outString = converter.ConvertFromUnicode(inString) + converter.Finish();
+    do_check_neq(outString, expectedString);
+
+    // Set isInternal and try again
+    converter.isInternal = true;
+
     converter.charset = charset;
 
     var outString = converter.ConvertFromUnicode(inString) + converter.Finish();
+    // expected to pass this time
     do_check_eq(outString, expectedString);
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 ipc/glue/Makefile.in
--- a/ipc/glue/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/ipc/glue/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -41,7 +41,10 @@
 
 include $(DEPTH)/config/autoconf.mk
 
-LOCAL_INCLUDES += -I$(topsrcdir)/toolkit/crashreporter
+LOCAL_INCLUDES += \
+  -I$(topsrcdir)/toolkit/crashreporter \
+  -I$(topsrcdir)/layout/base \
+  $(NULL)
 
 MODULE = ipc
 LIBRARY_NAME = mozipc_s
diff -r 8fe44c79dfd1 -r 0c159bd1d600 ipc/glue/WindowsMessageLoop.cpp
--- a/ipc/glue/WindowsMessageLoop.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/ipc/glue/WindowsMessageLoop.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -47,6 +47,7 @@
 #include "nsIXULAppInfo.h"
 
 #include "mozilla/Mutex.h"
+#include "PaintTracker.h"
 
 using mozilla::ipc::SyncChannel;
 using mozilla::ipc::RPCChannel;
@@ -239,12 +240,6 @@
       deferred = new DeferredRedrawMessage(hwnd, flags);
       break;
     }
-    case WM_NCPAINT: {
-      UINT flags = RDW_INVALIDATE | RDW_FRAME | RDW_NOINTERNALPAINT |
-                   RDW_NOERASE | RDW_NOCHILDREN | RDW_ERASENOW;
-      deferred = new DeferredRedrawMessage(hwnd, flags);
-      break;
-    }
 
     // This message will generate a WM_PAINT message if there are invalid
     // areas.
@@ -288,15 +283,21 @@
     // Messages that are safe to pass to DefWindowProc go here.
     case WM_ENTERIDLE:
     case WM_GETICON:
+    case WM_NCPAINT: // (never trap nc paint events)
     case WM_GETMINMAXINFO:
     case WM_GETTEXT:
     case WM_NCHITTEST:
-    case WM_STYLECHANGING:
-    case WM_SYNCPAINT: // Intentional fall-through.
-    case WM_WINDOWPOSCHANGING: {
+    case WM_STYLECHANGING:  // Intentional fall-through.
+    case WM_WINDOWPOSCHANGING: { 
       return DefWindowProc(hwnd, uMsg, wParam, lParam);
     }
 
+    // Just return, prevents DefWindowProc from messaging the window
+    // syncronously with other events, which may be deferred. Prevents 
+    // random shutdown of aero composition on the window. 
+    case WM_SYNCPAINT:
+      return 0;
+
     // Unknown messages only.
     default: {
 #ifdef DEBUG
@@ -623,6 +624,10 @@
 void
 RPCChannel::SpinInternalEventLoop()
 {
+  if (mozilla::PaintTracker::IsPainting()) {
+    NS_RUNTIMEABORT("Don't spin an event loop while painting.");
+  }
+
   NS_ASSERTION(mTopFrame && mTopFrame->mSpinNestedEvents,
                "Spinning incorrectly");
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 ipc/ipdl/test/cxx/Makefile.in
--- a/ipc/ipdl/test/cxx/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/ipc/ipdl/test/cxx/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -63,7 +63,6 @@
   TestCrashCleanup \
   TestDesc \
   TestHangs \
-  TestLatency \
   TestManyChildAllocs  \
   TestMultiMgrs  \
   TestNestedLoops \
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/config/milestone.txt
--- a/js/src/config/milestone.txt	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/config/milestone.txt	Thu Dec 02 20:33:03 2010 -0500
@@ -10,4 +10,4 @@
 # hardcoded milestones in the tree from these two files.
 #--------------------------------------------------------
 
-1.9.2.12
+1.9.2.13
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jsarray.cpp
--- a/js/src/jsarray.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jsarray.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -322,7 +322,7 @@
         return JS_TRUE;
     }
 
-    if (newlen > MAX_DSLOTS_LENGTH) {
+    if (newlen > MAX_DSLOTS_LENGTH32) {
         js_ReportAllocationOverflow(cx);
         return JS_FALSE;
     }
@@ -653,8 +653,16 @@
     if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
         /* Don't reallocate if we're not actually shrinking our slots. */
         jsuint capacity = js_DenseArrayCapacity(obj);
-        if (capacity > newlen && !ResizeSlots(cx, obj, capacity, newlen))
-            return JS_FALSE;
+        if (capacity > newlen) {
+            jsuint numNonHolesRemoved = 0;
+            for (jsval *slots = obj->dslots + newlen; slots < obj->dslots + capacity; slots++)
+                if (*slots != JSVAL_HOLE)
+                    numNonHolesRemoved++;
+            if (!ResizeSlots(cx, obj, capacity, newlen))
+                return JS_FALSE;
+            obj->fslots[JSSLOT_ARRAY_COUNT] -= numNonHolesRemoved;
+        }
+
     } else if (oldlen - newlen < (1 << 24)) {
         do {
             --oldlen;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jscntxt.cpp
--- a/js/src/jscntxt.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jscntxt.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1380,7 +1380,7 @@
                          JSMSG_SCRIPT_STACK_QUOTA);
 }
 
-void
+JS_FRIEND_API(void)
 js_ReportOverRecursed(JSContext *cx)
 {
     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_OVER_RECURSED);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jscntxt.h
--- a/js/src/jscntxt.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jscntxt.h	Thu Dec 02 20:33:03 2010 -0500
@@ -1671,7 +1671,7 @@
 extern void
 js_ReportOutOfScriptQuota(JSContext *cx);
 
-extern void
+extern JS_FRIEND_API(void)
 js_ReportOverRecursed(JSContext *cx);
 
 extern void
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jsobj.cpp
--- a/js/src/jsobj.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jsobj.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -5866,6 +5866,12 @@
     return JS_FALSE;
 }
 
+JS_FRIEND_API(void)
+js_SetObjectWeakRoot(JSContext *cx, JSObject *obj)
+{
+    cx->weakRoots.newborn[GCX_OBJECT] = obj;
+}
+
 #ifdef DEBUG
 
 /*
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jsobj.h
--- a/js/src/jsobj.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jsobj.h	Thu Dec 02 20:33:03 2010 -0500
@@ -1102,6 +1102,9 @@
 JSBool
 js_Object(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
+JS_FRIEND_API(void)
+js_SetObjectWeakRoot(JSContext *cx, JSObject *obj);
+
 JS_END_EXTERN_C
 
 #endif /* jsobj_h___ */
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jstracer.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -7465,8 +7465,6 @@
 JS_REQUIRES_STACK void
 js_PurgeScriptFragments(JSContext* cx, JSScript* script)
 {
-    if (!TRACING_ENABLED(cx))
-        return;
     debug_only_printf(LC_TMTracer,
                       "Purging fragments for JSScript %p.\n", (void*)script);
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/jsxml.cpp
--- a/js/src/jsxml.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/jsxml.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -6790,7 +6790,7 @@
     vp[0] = OBJECT_TO_JSVAL(ns);
     ns->fslots[JSSLOT_DECLARED] = JSVAL_TRUE;
 
-    qnargv[0] = vp[2] = OBJECT_TO_JSVAL(ns);
+    qnargv[0] = OBJECT_TO_JSVAL(ns);
     qnargv[1] = OBJECT_TO_JSVAL(xml->name);
     qn = js_ConstructObject(cx, &js_QNameClass.base, NULL, NULL, 2, qnargv);
     if (!qn)
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/liveconnect/jsj_JavaArray.c
--- a/js/src/liveconnect/jsj_JavaArray.c	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/liveconnect/jsj_JavaArray.c	Thu Dec 02 20:33:03 2010 -0500
@@ -255,6 +255,7 @@
     if (access_java_array_element(cx, jEnv, obj, id, NULL, JS_FALSE)) {
         *objp = obj;
         *propp = (JSProperty*)1;
+        js_SetObjectWeakRoot(cx, obj);
     } else {
         *objp = NULL;
         *propp = NULL;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/liveconnect/jsj_JavaClass.c
--- a/js/src/liveconnect/jsj_JavaClass.c	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/liveconnect/jsj_JavaClass.c	Thu Dec 02 20:33:03 2010 -0500
@@ -321,6 +321,7 @@
     if (lookup_static_member_by_id(cx, jEnv, obj, NULL, id, NULL)) {
         *objp = obj;
         *propp = (JSProperty*)1;
+        js_SetObjectWeakRoot(cx, obj);
     } else {
         *objp = NULL;
         *propp = NULL;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/liveconnect/jsj_JavaObject.c
--- a/js/src/liveconnect/jsj_JavaObject.c	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/liveconnect/jsj_JavaObject.c	Thu Dec 02 20:33:03 2010 -0500
@@ -846,6 +846,7 @@
             *objp = obj;
             *propp = (JSProperty*)1;
         }
+        js_SetObjectWeakRoot(cx, *objp);
     } else {
         *objp = NULL;
         *propp = NULL;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/liveconnect/nsCLiveconnect.cpp
--- a/js/src/liveconnect/nsCLiveconnect.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/liveconnect/nsCLiveconnect.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -64,6 +64,8 @@
 #include "nsISecurityContext.h"
 #include "nsIServiceManager.h"
 #include "nsIJSContextStack.h"
+#include "nsJVMManager.h"
+#include "nsIPluginInstancePeer2.h"
 
 PR_BEGIN_EXTERN_C
 
@@ -240,6 +242,49 @@
     js_LeaveTrace(cx);
 }
 
+// nsILiveconnect methods (which constitute OJI's Java-to-JavaScript API) may
+// call back into Java (using the OJI plugin's implementation of the
+// nsISecureEnv interface).  But these nsISecureEnv methods assume there is
+// JavaScript on the stack, and Java code can call nsILiveconnect methods
+// "spontaneously" (without any JavaScript on the stack).  So the
+// nsCLiveconnect methods below (those that implement the nsILiveconnect
+// interface) always create an AutoPushJSContext object, which guarantees the
+// presence on the JavaScript stack of at least a dummy frame with a principal.
+//
+// Ordinarily we rely on jsj_enter_js() to tell us which JSContext to pass to
+// the AutoPushJSContext constructor, and really only need to create an
+// AutoPushJSContext object after jsj_enter_js() has returned.  But the first
+// time jsj_enter_js() is called we initialize a bunch of Java classes and
+// their methods and fields (in jsj.c's init_netscape_java_classes() and
+// init_java_VM_reflection()).  This involves calling into Java, and thus
+// using the plugin's nsISecureEnv methods -- which assume there is JavaScript
+// on the stack.
+//
+// So to deal with this edge case (to make sure jsj_enter_js() behaves
+// properly the first time it's called) we need to create an AutoPushJSContext
+// object *before* calling jsj_enter_js() -- which requires that we know which
+// JSContex to pass to the AutoPushJSContext constructor before the call to
+// jsj_enter_js();
+//
+// That's what this function does -- it tells us which JSContext the call to
+// jsj_enter_js() will return (as a result of indirectly calling
+// map_jsj_thread_to_js_context_impl() in lcglue.cpp).
+static JSContext* JSContextForPluginInstance(nsIPluginInstance* pluginInstance)
+{
+    JSContext* context = NULL;
+	if (pluginInstance) {
+        nsCOMPtr<nsIPluginInstancePeer> pluginPeer;
+        if (NS_SUCCEEDED(pluginInstance->GetPeer(getter_AddRefs(pluginPeer)))) {
+            nsresult rv;
+            nsCOMPtr<nsIPluginInstancePeer2> pluginPeer2 = do_QueryInterface(pluginPeer, &rv);
+            if (NS_SUCCEEDED(rv)) {
+                pluginPeer2->GetJSContext(&context);
+            }
+        }
+    }
+    return context;
+}
+
 ////////////////////////////////////////////////////////////////////////////
 // from nsISupports and AggregatedQueryInterface:
 
@@ -285,13 +330,17 @@
     JSBool             dummy_bool     = PR_FALSE;
     JSErrorReporter    saved_state    = NULL;
 
-    jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
-    if (!jsj_env)
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
         return NS_ERROR_FAILURE;
 
     AutoPushJSContext autopush(securitySupports, cx);
     if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
+        return NS_ERROR_FAILURE;
+
+    jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
+    if (!jsj_env)
+        return NS_ERROR_FAILURE;
 
     if (!name) {
         JS_ReportError(cx, "illegal null member name");
@@ -343,14 +392,18 @@
     JSBool             dummy_bool     = PR_FALSE;
     JSErrorReporter    saved_state    = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
        return NS_ERROR_FAILURE;
 
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
     // =-= sudu: check to see if slot can be passed in as is.
     //           Should it be converted to a jsint?
     if (!JS_GetElement(cx, js_obj, slot, &js_val))
@@ -393,14 +446,18 @@
     jsval              js_val;
     JSErrorReporter    saved_state    = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
         return NS_ERROR_FAILURE;
 
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
     if (!name) {
         JS_ReportError(cx, "illegal null member name");
         goto done;
@@ -443,14 +500,18 @@
     jsval              js_val;
     JSErrorReporter    saved_state    = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
         return NS_ERROR_FAILURE;
 
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
     if (!jsj_ConvertJavaObjectToJSValue(cx, jEnv, java_obj, &js_val))
         goto done;
     JS_SetElement(cx, js_obj, slot, &js_val);
@@ -484,14 +545,18 @@
     jsval              js_val;
     JSErrorReporter    saved_state    = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
         return NS_ERROR_FAILURE;
 
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
     if (!name) {
         JS_ReportError(cx, "illegal null member name");
         goto done;
@@ -538,15 +603,20 @@
     JSErrorReporter    saved_state    = NULL;
     jobject            result         = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
         return NS_ERROR_FAILURE;
 
     result = NULL;
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
+
     if (!name) {
         JS_ReportError(cx, "illegal null JavaScript function name");
         goto done;
@@ -620,15 +690,20 @@
     JSPrincipals      *principals     = NULL;
     JSBool             eval_succeeded = PR_FALSE;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
        return NS_ERROR_FAILURE;
 
     result = NULL;
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
+
     if (!script) {
         JS_ReportError(cx, "illegal null string eval argument");
         goto done;
@@ -691,15 +766,20 @@
     JSJavaThreadState *jsj_env        = NULL;
     JSObjectHandle    *handle         = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(securitySupports, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, principalsArray, numPrincipals, securitySupports);
     if (!jsj_env)
        return NS_ERROR_FAILURE;
 
     err_msg = NULL;
-    AutoPushJSContext autopush(securitySupports, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        goto done;
-    
+
     js_obj = JSJ_callbacks->map_java_object_to_js_object(jEnv, mJavaClient, &err_msg);
     if (!js_obj) {
         if (err_msg) {
@@ -772,14 +852,19 @@
     jstring            result         = NULL;
     JSString          *jsstr          = NULL;
 
+    cx = JSContextForPluginInstance(reinterpret_cast<nsIPluginInstance*>(mJavaClient));
+    if (!cx)
+        return NS_ERROR_FAILURE;
+
+    AutoPushJSContext autopush(nsnull, cx);
+    if (NS_FAILED(autopush.ResultOfPush()))
+        return NS_ERROR_FAILURE;
+
     jsj_env = jsj_enter_js(jEnv, mJavaClient, NULL, &cx, NULL, &saved_state, NULL, 0, NULL );
     if (!jsj_env)
        return NS_ERROR_FAILURE;
 
     result = NULL;
-    AutoPushJSContext autopush(nsnull, cx);
-    if (NS_FAILED(autopush.ResultOfPush()))
-        return NS_ERROR_FAILURE;
 
     jsstr = JS_ValueToString(cx, OBJECT_TO_JSVAL(js_obj));
     if (jsstr)
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/nanojit/CodeAlloc.cpp
--- a/js/src/nanojit/CodeAlloc.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/nanojit/CodeAlloc.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -247,8 +247,20 @@
 #endif
 
 #ifdef AVMPLUS_SPARC
+#ifdef __linux__
+void sync_instruction_memory(caddr_t v, u_int len)
+{
+	caddr_t end = v + len;
+	caddr_t p = v;
+	while (p < end) {
+		asm volatile("flush %0" : : "r" (p));
+		p += 32;
+	}
+}
+#else
 extern  "C" void sync_instruction_memory(caddr_t v, u_int len);
 #endif
+#endif
 
 #if defined NANOJIT_IA32 || defined NANOJIT_X64
     // intel chips have dcache/icache interlock
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/xpconnect/crashtests/582649.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/xpconnect/crashtests/582649.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,12 @@
+<html>
+<head>
+	<title>Testcase for bug 582649</title>
+</head>
+<body>
+<script>
+var foo = [];
+foo[0] = foo;
+document.body.setUserData("foo", foo, null);
+</script>
+</body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/xpconnect/crashtests/crashtests.list
--- a/js/src/xpconnect/crashtests/crashtests.list	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/xpconnect/crashtests/crashtests.list	Thu Dec 02 20:33:03 2010 -0500
@@ -19,3 +19,4 @@
 load 475185-1.html
 load 475291-1.html
 load 503286-1.html
+load 582649.html
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/xpconnect/src/Makefile.in
--- a/js/src/xpconnect/src/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/xpconnect/src/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -57,6 +57,11 @@
 endif
 LIBXUL_LIBRARY = 1
 
+ifdef MOZ_XPCTOOLS
+DEFINES         +=  -DXPC_TOOLS_SUPPORT
+REQUIRES	+= xpctools
+endif
+
 REQUIRES	= xpcom \
 		  string \
 		  js \
@@ -174,11 +179,6 @@
 
 endif # ENABLE_JIT
 
-ifdef MOZ_XPCTOOLS
-DEFINES         +=  -DXPC_TOOLS_SUPPORT
-REQUIRES	+= xpctools
-endif
-
 ifdef XPC_IDISPATCH_SUPPORT
 DEFINES		+= -DXPC_IDISPATCH_SUPPORT
 ifdef XPC_COMOBJECT
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/xpconnect/src/xpcvariant.cpp
--- a/js/src/xpconnect/src/xpcvariant.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/xpconnect/src/xpcvariant.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -296,6 +296,8 @@
 
 JSBool XPCVariant::InitializeData(XPCCallContext& ccx)
 {
+    JS_CHECK_RECURSION(ccx.GetJSContext(), return JS_FALSE);
+
     if(JSVAL_IS_INT(mJSVal))
         return NS_SUCCEEDED(nsVariant::SetFromInt32(&mData, 
                                                    JSVAL_TO_INT(mJSVal)));
diff -r 8fe44c79dfd1 -r 0c159bd1d600 js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1324,6 +1324,31 @@
     xpcc->SetException(nsnull);
     ccx.GetThreadData()->SetException(nsnull);
 
+    if(XPCPerThreadData::IsMainThread(ccx))
+    {
+        ssm = XPCWrapper::GetSecurityManager();
+        if(ssm)
+        {
+            nsCOMPtr<nsIPrincipal> objPrincipal;
+            ssm->GetObjectPrincipal(ccx, obj, getter_AddRefs(objPrincipal));
+            if(objPrincipal)
+            {
+                JSStackFrame* fp = nsnull;
+                nsresult rv =
+                    ssm->PushContextPrincipal(ccx, JS_FrameIterator(ccx, &fp),
+                                              objPrincipal);
+                if(NS_FAILED(rv))
+                {
+                    JS_ReportOutOfMemory(ccx);
+                    retval = NS_ERROR_OUT_OF_MEMORY;
+                    goto pre_call_clean_up;
+                }
+
+                popPrincipal = JS_TRUE;
+            }
+        }
+    }
+
     // We use js_AllocStack, js_Invoke, and js_FreeStack so that the gcthings
     // we use as args will be rooted by the engine as we do conversions and
     // prepare to do the function call. This adds a fair amount of complexity,
@@ -1660,31 +1685,6 @@
 
     JS_ClearPendingException(cx);
 
-    if(XPCPerThreadData::IsMainThread(ccx))
-    {
-        ssm = XPCWrapper::GetSecurityManager();
-        if(ssm)
-        {
-            nsCOMPtr<nsIPrincipal> objPrincipal;
-            ssm->GetObjectPrincipal(ccx, obj, getter_AddRefs(objPrincipal));
-            if(objPrincipal)
-            {
-                JSStackFrame* fp = nsnull;
-                nsresult rv =
-                    ssm->PushContextPrincipal(ccx, JS_FrameIterator(ccx, &fp),
-                                              objPrincipal);
-                if(NS_FAILED(rv))
-                {
-                    JS_ReportOutOfMemory(ccx);
-                    retval = NS_ERROR_OUT_OF_MEMORY;
-                    goto done;
-                }
-
-                popPrincipal = JS_TRUE;
-            }
-        }
-    }
-
     if(XPT_MD_IS_GETTER(info->flags))
         success = JS_GetProperty(cx, obj, name, &result);
     else if(XPT_MD_IS_SETTER(info->flags))
@@ -1721,9 +1721,6 @@
         }
     }
 
-    if(popPrincipal)
-        ssm->PopContextPrincipal(ccx);
-
     if(!success)
     {
         PRBool forceReport;
@@ -1939,6 +1936,9 @@
     if(sp)
         js_FreeStack(cx, mark);
 
+    if(popPrincipal)
+        ssm->PopContextPrincipal(ccx);
+
 #ifdef DEBUG_stats_jband
     endTime = PR_IntervalNow();
     printf("%s::%s %d ( c->js ) \n", GetInterfaceName(), info->GetName(), PR_IntervalToMilliseconds(endTime-startTime));
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/base/Makefile.in
--- a/layout/base/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/base/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -89,6 +89,8 @@
 		nsIStyleSheetService.idl	\
 		$(NULL)
 
+EXPORTS_NAMESPACES = mozilla
+
 EXPORTS		= \
 		nsBidi.h \
 		nsBidiPresUtils.h \
@@ -116,6 +118,10 @@
 		nsStyleConsts.h \
 		$(NULL)
 
+EXPORTS_mozilla =\
+  PaintTracker.h \
+  $(NULL)
+
 CPPSRCS		= \
 		nsCSSColorUtils.cpp \
 		nsCSSFrameConstructor.cpp \
@@ -140,6 +146,7 @@
 		nsQuoteList.cpp \
 		nsStyleChangeList.cpp \
 		nsStyleSheetService.cpp \
+		PaintTracker.cpp \
 		$(NULL)
 
 ifndef MOZ_XUL
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/base/PaintTracker.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/PaintTracker.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,7 @@
+#include "mozilla/PaintTracker.h"
+
+namespace mozilla {
+
+int PaintTracker::gPaintTracker;
+
+} // namespace mozilla
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/base/PaintTracker.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/PaintTracker.h	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,30 @@
+#ifndef mozilla_PaintTracker_h
+#define mozilla_PaintTracker_h
+
+#include "nscore.h"
+#include "nsDebug.h"
+
+namespace mozilla {
+
+class NS_STACK_CLASS PaintTracker
+{
+public:
+  PaintTracker() {
+    ++gPaintTracker;
+  }
+  ~PaintTracker() {
+    NS_ASSERTION(gPaintTracker > 0, "Mismatched constructor/destructor");
+    --gPaintTracker;
+  }
+
+  static bool IsPainting() {
+    return !!gPaintTracker;
+  }
+
+private:
+  static int gPaintTracker;
+};
+
+} // namespace mozilla
+
+#endif // mozilla_PaintTracker_h
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/base/crashtests/579655.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/crashtests/579655.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,26 @@
+<!DOCTYPE html>
+<html>
+<script type="text/javascript">
+function load()
+{
+  var bs=document.getElementById("b");
+  if(bs.lastChild){
+      bs.lastChild.textContent="text\/css";	
+      bs.textContent="head";
+  }
+}
+</script> 
+<body onload="load();">
+ <table > 
+   <td>
+     <p id="b">aaaa aaaa aaa aa aaaa aa aaaaaa aaaa aa aa aaa aaa aaaa aaaaaaa aaa aaaa aa a aaaa aaaa aaaaaaa aa aa aa aa aaaaaaa .</p>  
+      <body style="white-space:pre-wrap" >
+      </body>
+   </td>
+   <td dir="rtl" >
+     <body contenteditable="true"> 
+     </body>
+   </td> 
+ </table> 
+</body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/base/crashtests/crashtests.list
--- a/layout/base/crashtests/crashtests.list	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/base/crashtests/crashtests.list	Thu Dec 02 20:33:03 2010 -0500
@@ -256,3 +256,4 @@
 load 522374-2.html
 load 541869-1.xhtml
 load 541869-2.html
+load 579655.html
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/base/nsCSSFrameConstructor.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -7064,11 +7064,6 @@
                        nsIFrame*            aRemovedFrame,
                        nsIFrame*            aFrame)
 {
-#undef RECURSE
-#define RECURSE(top, child)                                                  \
-  DoDeletingFrameSubtree(aFrameManager, aDestroyQueue, (top), (child));      \
-  DoDeletingOverflowContainers(aFrameManager, aDestroyQueue, (top), (child));
-
   // Remove the mapping from the content object to its frame.
   nsIContent* content = aFrame->GetContent();
   if (content) {
@@ -7083,10 +7078,15 @@
     // Walk aFrame's normal flow child frames looking for placeholder frames.
     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
     for (; childFrame; childFrame = childFrame->GetNextSibling()) {
-      NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
-                   "out-of-flow on wrong child list");
+      if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
+        NS_ASSERTION(childListName == nsGkAtoms::overflowContainersList ||
+                     childListName == nsGkAtoms::excessOverflowContainersList,
+                     "out-of-flow on wrong child list");
+        continue;
+      }
       if (NS_LIKELY(nsGkAtoms::placeholderFrame != childFrame->GetType())) {
-        RECURSE(aRemovedFrame, childFrame);
+        DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
+                               aRemovedFrame, childFrame);
       } else {
         nsIFrame* outOfFlowFrame =
           nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
@@ -7104,24 +7104,29 @@
                        "out-of-flow is already in the destroy queue");
           aDestroyQueue.AppendElement(outOfFlowFrame);
           // Recurse into the out-of-flow, it is now the aRemovedFrame.
-          RECURSE(outOfFlowFrame, outOfFlowFrame);
+          DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
+                                 outOfFlowFrame, outOfFlowFrame);
+          DoDeletingOverflowContainers(aFrameManager, aDestroyQueue,
+                                       outOfFlowFrame, outOfFlowFrame);
         }
         else {
           // Also recurse into the out-of-flow when it's a descendant of aRemovedFrame
           // since we don't walk those lists, see |childListName| increment below.
-          RECURSE(aRemovedFrame, outOfFlowFrame);
+          DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
+                                 aRemovedFrame, outOfFlowFrame);
+          DoDeletingOverflowContainers(aFrameManager, aDestroyQueue,
+                                       aRemovedFrame, outOfFlowFrame);
         }
       }
     }
 
     // Move to next child list but skip lists with frames we should have
-    // a placeholder for or that contains only next-in-flow overflow containers
-    // (which we walk explicitly above).
+    // a placeholder for.  Note that we only process in-flow overflow
+    // containers on the overflowContainersList/excessOverflowContainersList,
+    // out-of-flows are reached through the next-in-flow chain (bug 468563).
     do {
       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
-    } while (IsOutOfFlowList(childListName) ||
-             childListName == nsGkAtoms::overflowContainersList ||
-             childListName == nsGkAtoms::excessOverflowContainersList);
+    } while (IsOutOfFlowList(childListName));
   } while (childListName);
 }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/forms/nsIsIndexFrame.cpp
--- a/layout/forms/nsIsIndexFrame.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/forms/nsIsIndexFrame.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -60,7 +60,6 @@
 #include "nsIComponentManager.h"
 #include "nsHTMLParts.h"
 #include "nsLinebreakConverter.h"
-#include "nsILinkHandler.h"
 #include "nsIHTMLDocument.h"
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
@@ -347,8 +346,6 @@
   // End ProcessAsURLEncoded
 
   // make the url string
-  nsILinkHandler *handler = aPresContext->GetLinkHandler();
-
   nsAutoString href;
 
   // Get the document.
@@ -426,10 +423,9 @@
                      flatDocCharset.get(), baseURI);
   if (NS_FAILED(result)) return result;
 
-  // Now pass on absolute url to the click handler
-  if (handler) {
-    handler->OnLinkClick(mContent, uri, nsnull);
-  }
+  // Now pretend we're triggering a link
+  nsContentUtils::TriggerLink(mContent, aPresContext, uri,
+                              EmptyString(), PR_TRUE, PR_TRUE);
   return result;
 }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/crashtests/603490-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/603490-1.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,16 @@
+<!DOCTYPE html><html><script>
+
+function boom()
+{
+  while (document.documentElement.firstChild)
+    document.documentElement.removeChild(document.documentElement.firstChild);
+  document.documentElement.contentEditable = "true";
+  document.execCommand("strikethrough", false, null);
+  try { document.execCommand("justifyfull", false, null); } catch(e) { }
+  document.documentElement.offsetHeight;
+  try { document.execCommand("delete", false, null); } catch(e) { }
+  document.execCommand("inserthtml", false, "<span> <\/span>");
+}
+window.addEventListener("load", boom, false);
+
+</script></html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/crashtests/603510-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/603510-1.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,23 @@
+<!DOCTYPE html>
+<script>
+
+function boom()
+{
+  var r = document.documentElement;
+
+  while (r.firstChild)
+    r.removeChild(r.firstChild);
+
+  var a = document.createTextNode("a");
+  r.appendChild(a);
+  a.splitText(0);
+  a.splitText(0);
+
+  document.documentElement.offsetHeight;
+
+  r.appendChild(document.createTextNode("b"));
+}
+
+window.addEventListener("load", boom, false);
+
+</script>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/crashtests/604843.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/604843.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,28 @@
+<!DOCTYPE html>
+<html>
+<head>
+<script>
+
+function boom()
+{
+  document.documentElement.offsetHeight;
+
+  var c = document.getElementById("c");
+  var t1 = document.createTextNode("x x x x x x x x x x x x x x x x x x x x");
+  var t2 = document.createTextNode("y y y y y y y y y y y y y y y y y y y y y");
+  c.appendChild(t1);
+  c.appendChild(t2);
+  document.documentElement.offsetHeight;
+
+  var div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
+  c.insertBefore(div, t2);
+  document.documentElement.offsetHeight;
+}
+
+</script>
+</head>
+
+<body onload="boom();" style="width: 5ch; font-family: monospace; margin: 0;">
+<table><tbody><tr><td id="c"></td></tr></tbody></table>
+</body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/crashtests/605340.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/605340.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,12 @@
+<!DOCTYPE html>
+<html>
+<body onload="document.getElementById('a').lastChild.appendData('4');">
+
+<div id="a" style="position: absolute;"><span><span style="white-space: pre;">
+1
+2</span>
+3</span>
+</div>
+
+</body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/generic/crashtests/crashtests.list	Thu Dec 02 20:33:03 2010 -0500
@@ -254,3 +254,7 @@
 load 511482.html
 load 515811-1.html
 load 517968.html
+load 603490-1.html
+load 603510-1.html
+load 604843.html
+load 605340.html
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/generic/nsObjectFrame.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -2095,6 +2095,10 @@
     return NS_OK;
   }
 
+  // XXXbz can aMimeType ever actually be null here?  If not, either
+  // the callers are wrong (and passing "" instead of null) or we can
+  // remove the codepaths dealing with null aMimeType in
+  // InstantiateEmbeddedPlugin.
   NS_ASSERTION(aMimeType || aURI, "Need a type or a URI!");
 
   // Note: If PrepareInstanceOwner() returns an error, |this| may very
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/nsTextFrame.h
--- a/layout/generic/nsTextFrame.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/generic/nsTextFrame.h	Thu Dec 02 20:33:03 2010 -0500
@@ -29,7 +29,7 @@
  *   Daniel Glazman <glazman@netscape.com>
  *   Neil Deakin <neil@mozdevgroup.com>
  *   Masayuki Nakano <masayuki@d-toybox.com>
- *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Mats Palmgren <matspal@gmail.com>
  *   Uri Bernstein <uriber@gmail.com>
  *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>
  *
@@ -334,9 +334,6 @@
   // boundary.
   PRInt32 GetInFlowContentLength();
 
-  // Clears out mTextRun from this frame and all other frames that hold a reference
-  // to it, then deletes the textrun.
-  void ClearTextRun();
   /**
    * Acquires the text run for this content, if necessary.
    * @param aRC the rendering context to use as a reference for creating
@@ -356,6 +353,12 @@
 
   gfxTextRun* GetTextRun() { return mTextRun; }
   void SetTextRun(gfxTextRun* aTextRun) { mTextRun = aTextRun; }
+  /**
+   * Clears out |mTextRun| from all frames that hold a reference to it,
+   * starting at |aStartContinuation|, or if it's nsnull, starting at |this|.
+   * Deletes |mTextRun| if all references were cleared and it's not cached.
+   */
+  void ClearTextRun(nsTextFrame* aStartContinuation);
 
   // Get the DOM content range mapped by this frame after excluding
   // whitespace subject to start-of-line and end-of-line trimming.
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/generic/nsTextFrameThebes.cpp
--- a/layout/generic/nsTextFrameThebes.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/generic/nsTextFrameThebes.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -29,7 +29,7 @@
  *   Daniel Glazman <glazman@netscape.com>
  *   Neil Deakin <neil@mozdevgroup.com>
  *   Masayuki Nakano <masayuki@d-toybox.com>
- *   Mats Palmgren <mats.palmgren@bredband.net>
+ *   Mats Palmgren <matspal@gmail.com>
  *   Uri Bernstein <uriber@gmail.com>
  *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>
  *   Michael Ventnor <m.ventnor@gmail.com>
@@ -348,44 +348,101 @@
   }
 }
 
-// Remove the textrun from the frame continuation chain starting at aFrame,
-// which should be marked as a textrun owner.
-static void
-ClearAllTextRunReferences(nsTextFrame* aFrame, gfxTextRun* aTextRun)
-{
-  aFrame->RemoveStateBits(TEXT_IN_TEXTRUN_USER_DATA);
+/**
+ * Remove |aTextRun| from the frame continuation chain starting at
+ * |aStartContinuation| if non-null, otherwise starting at |aFrame|.
+ * Unmark |aFrame| as a text run owner if it's the frame we start at.
+ * Return PR_TRUE if |aStartContinuation| is non-null and was found
+ * in the next-continuation chain of |aFrame|.
+ */
+static PRBool
+ClearAllTextRunReferences(nsTextFrame* aFrame, gfxTextRun* aTextRun,
+                          nsTextFrame* aStartContinuation)
+{
+  NS_PRECONDITION(aFrame, "");
+  NS_PRECONDITION(!aStartContinuation ||
+                  !aStartContinuation->GetTextRun() ||
+                  aStartContinuation->GetTextRun() == aTextRun,
+                  "wrong aStartContinuation for this text run");
+
+  if (!aStartContinuation || aStartContinuation == aFrame) {
+    aFrame->RemoveStateBits(TEXT_IN_TEXTRUN_USER_DATA);
+  } else {
+    do {
+      NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame, "Bad frame");
+      aFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
+    } while (aFrame && aFrame != aStartContinuation);
+  }
+  PRBool found = aStartContinuation == aFrame;
   while (aFrame) {
-    NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame,
-                 "Bad frame");
+    NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame, "Bad frame");
     if (aFrame->GetTextRun() != aTextRun)
       break;
     aFrame->SetTextRun(nsnull);
     aFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
   }
-}
-
-// Figure out which frames 
+  NS_POSTCONDITION(!found || aStartContinuation, "how did we find null?");
+  return found;
+}
+
+/**
+ * Kill all references to |aTextRun| starting at |aStartContinuation|.
+ * It could be referenced by any of its owners, and all their in-flows.
+ * If |aStartContinuation| is null then process all userdata frames
+ * and their continuations.
+ * @note the caller is expected to take care of possibly destroying the
+ * text run if all userdata frames were reset (userdata is deallocated
+ * by this function though). The caller can detect this has occured by
+ * checking |aTextRun->GetUserData() == nsnull|.
+ */
 static void
-UnhookTextRunFromFrames(gfxTextRun* aTextRun)
+UnhookTextRunFromFrames(gfxTextRun* aTextRun, nsTextFrame* aStartContinuation)
 {
   if (!aTextRun->GetUserData())
     return;
 
-  // Kill all references to the textrun. It could be referenced by any of its
-  // owners, and all their in-flows.
   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
-    nsIFrame* firstInFlow = static_cast<nsIFrame*>(aTextRun->GetUserData());
-    ClearAllTextRunReferences(static_cast<nsTextFrame*>(firstInFlow), aTextRun);
+    nsIFrame* userDataFrame = static_cast<nsIFrame*>(aTextRun->GetUserData());
+    PRBool found =
+      ClearAllTextRunReferences(static_cast<nsTextFrame*>(userDataFrame),
+                                aTextRun, aStartContinuation);
+    NS_ASSERTION(!aStartContinuation || found,
+                 "aStartContinuation wasn't found in simple flow text run");
+    if (!(userDataFrame->GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA)) {
+      aTextRun->SetUserData(nsnull);
+    }
   } else {
     TextRunUserData* userData =
       static_cast<TextRunUserData*>(aTextRun->GetUserData());
-    PRInt32 i;
-    for (i = 0; i < userData->mMappedFlowCount; ++i) {
-      ClearAllTextRunReferences(userData->mMappedFlows[i].mStartFrame, aTextRun);
-    }
-    DestroyUserData(userData);
-  }
-  aTextRun->SetUserData(nsnull);  
+    PRInt32 destroyFromIndex = aStartContinuation ? -1 : 0;
+    for (PRInt32 i = 0; i < userData->mMappedFlowCount; ++i) {
+      nsTextFrame* userDataFrame = userData->mMappedFlows[i].mStartFrame;
+      PRBool found =
+        ClearAllTextRunReferences(userDataFrame, aTextRun,
+                                  aStartContinuation);
+      if (found) {
+        if (userDataFrame->GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA) {
+          destroyFromIndex = i + 1;
+        }
+        else {
+          destroyFromIndex = i;
+        }
+        aStartContinuation = nsnull;
+      }
+    }
+    NS_ASSERTION(destroyFromIndex >= 0,
+                 "aStartContinuation wasn't found in multi flow text run");
+    if (destroyFromIndex == 0) {
+      DestroyUserData(userData);
+      aTextRun->SetUserData(nsnull);
+    }
+    else {
+      userData->mMappedFlowCount = destroyFromIndex;
+      if (userData->mLastFlowIndex >= destroyFromIndex) {
+        userData->mLastFlowIndex = destroyFromIndex - 1;
+      }
+    }
+  }
 }
 
 class FrameTextRunCache;
@@ -415,7 +472,7 @@
 
   // This gets called when the timeout has expired on a gfxTextRun
   virtual void NotifyExpired(gfxTextRun* aTextRun) {
-    UnhookTextRunFromFrames(aTextRun);
+    UnhookTextRunFromFrames(aTextRun, nsnull);
     RemoveFromCache(aTextRun);
     delete aTextRun;
   }
@@ -1915,6 +1972,50 @@
   }
 }
 
+// Find the flow corresponding to aContent in aUserData
+static inline TextRunMappedFlow*
+FindFlowForContent(TextRunUserData* aUserData, nsIContent* aContent)
+{
+  // Find the flow that contains us
+  PRInt32 i = aUserData->mLastFlowIndex;
+  PRInt32 delta = 1;
+  PRInt32 sign = 1;
+  // Search starting at the current position and examine close-by
+  // positions first, moving further and further away as we go.
+  while (i >= 0 && i < aUserData->mMappedFlowCount) {
+    TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
+    if (flow->mStartFrame->GetContent() == aContent) {
+      return flow;
+    }
+
+    i += delta;
+    delta = -delta - sign;
+    sign = -sign;
+  }
+
+  // We ran into an array edge.  Add |delta| to |i| once more to get
+  // back to the side where we still need to search, then step in
+  // the |sign| direction.
+  i += delta;
+  if (sign > 0) {
+    for (; i < aUserData->mMappedFlowCount; ++i) {
+      TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
+      if (flow->mStartFrame->GetContent() == aContent) {
+        return flow;
+      }
+    }
+  } else {
+    for (; i >= 0; --i) {
+      TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
+      if (flow->mStartFrame->GetContent() == aContent) {
+        return flow;
+      }
+    }
+  }
+
+  return nsnull;
+}
+
 void
 BuildTextRunsScanner::AssignTextRun(gfxTextRun* aTextRun)
 {
@@ -1945,7 +2046,50 @@
         }
       }
 #endif
-      f->ClearTextRun();
+
+      gfxTextRun* oldTextRun = f->GetTextRun();
+      if (oldTextRun) {
+        nsTextFrame* firstFrame = nsnull;
+        PRUint32 startOffset = 0;
+        if (oldTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
+          firstFrame = static_cast<nsTextFrame*>(oldTextRun->GetUserData());
+        }
+        else {
+          TextRunUserData* userData = static_cast<TextRunUserData*>(oldTextRun->GetUserData());
+          firstFrame = userData->mMappedFlows[0].mStartFrame;
+          if (NS_UNLIKELY(f != firstFrame)) {
+            TextRunMappedFlow* flow = FindFlowForContent(userData, f->GetContent());
+            if (flow) {
+              startOffset = flow->mDOMOffsetToBeforeTransformOffset;
+            }
+            else {
+              NS_ERROR("Can't find flow containing frame 'f'");
+            }
+          }
+        }
+
+        // Optimization: if |f| is the first frame in the flow then there are no
+        // prev-continuations that use |oldTextRun|.
+        nsTextFrame* clearFrom = nsnull;
+        if (NS_UNLIKELY(f != firstFrame)) {
+          // If all the frames in the mapped flow starting at |f| (inclusive)
+          // are empty then we let the prev-continuations keep the old text run.
+          gfxSkipCharsIterator iter(oldTextRun->GetSkipChars(), startOffset, f->GetContentOffset());
+          PRUint32 textRunOffset = iter.ConvertOriginalToSkipped(f->GetContentOffset());
+          clearFrom = textRunOffset == oldTextRun->GetLength() ? f : nsnull;
+        }
+        f->ClearTextRun(clearFrom);
+
+#ifdef DEBUG
+        if (firstFrame && !firstFrame->GetTextRun()) {
+          // oldTextRun was destroyed - assert that we don't reference it.
+          for (PRUint32 i = 0; i < mBreakSinks.Length(); ++i) {
+            NS_ASSERTION(oldTextRun != mBreakSinks[i]->mTextRun,
+                         "destroyed text run is still in use");
+          }
+        }
+#endif
+      }
       f->SetTextRun(aTextRun);
     }
     // Set this bit now; we can't set it any earlier because
@@ -3399,7 +3543,7 @@
   // We might want to clear NS_CREATE_FRAME_IF_NON_WHITESPACE or
   // NS_REFRAME_IF_WHITESPACE on mContent here, since our parent frame
   // type might be changing.  Not clear whether it's worth it.
-  ClearTextRun();
+  ClearTextRun(nsnull);
   if (mNextContinuation) {
     mNextContinuation->SetPrevInFlow(nsnull);
   }
@@ -3492,7 +3636,7 @@
   if (prev->GetStyleContext() != GetStyleContext()) {
     // We're taking part of prev's text, and its style may be different
     // so clear its textrun which may no longer be valid (and don't set ours)
-    prev->ClearTextRun();
+    prev->ClearTextRun(nsnull);
   } else {
     mTextRun = prev->GetTextRun();
   }
@@ -3548,11 +3692,11 @@
   if ((GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA) ||
       !mPrevContinuation ||
       mPrevContinuation->GetStyleContext() != GetStyleContext()) {
-    ClearTextRun();
+    ClearTextRun(nsnull);
     // Clear the previous continuation's text run also, so that it can rebuild
     // the text run to include our text.
     if (mPrevContinuation) {
-      (static_cast<nsTextFrame*>(mPrevContinuation))->ClearTextRun();
+      (static_cast<nsTextFrame*>(mPrevContinuation))->ClearTextRun(nsnull);
     }
   }
   nsSplittableFrame::RemoveFromFlow(this);
@@ -3733,15 +3877,15 @@
 }
 
 void
-nsTextFrame::ClearTextRun()
-{
-  // save textrun because ClearAllTextRunReferences will clear ours
+nsTextFrame::ClearTextRun(nsTextFrame* aStartContinuation)
+{
+  // save textrun because ClearAllTextRunReferences may clear ours
   gfxTextRun* textRun = mTextRun;
   
   if (!textRun)
     return;
 
-  UnhookTextRunFromFrames(textRun);
+  UnhookTextRunFromFrames(textRun, aStartContinuation);
   // see comments in BuildTextRunForFrames...
 //  if (textRun->GetFlags() & gfxFontGroup::TEXT_IS_PERSISTENT) {
 //    NS_ERROR("Shouldn't reach here for now...");
@@ -3754,7 +3898,8 @@
 //    return;
 //  }
 
-  if (!(textRun->GetFlags() & gfxTextRunWordCache::TEXT_IN_CACHE)) {
+  if (!(textRun->GetFlags() & gfxTextRunWordCache::TEXT_IN_CACHE) &&
+      !textRun->GetUserData()) {
     // Remove it now because it's not doing anything useful
     gTextRuns->RemoveFromCache(textRun);
     delete textRun;
@@ -3766,7 +3911,7 @@
 {
   nsTextFrame* f;
   for (f = aFrame; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
-    f->ClearTextRun();
+    f->ClearTextRun(nsnull);
   }
 }
 
@@ -3815,7 +3960,7 @@
 nsTextFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 {
   nsFrame::DidSetStyleContext(aOldStyleContext);
-  ClearTextRun();
+  ClearTextRun(nsnull);
 } 
 
 class nsDisplayText : public nsDisplayItem {
@@ -5603,7 +5748,7 @@
 /* virtual */ 
 void nsTextFrame::MarkIntrinsicWidthsDirty()
 {
-  ClearTextRun();
+  ClearTextRun(nsnull);
   nsFrame::MarkIntrinsicWidthsDirty();
 }
 
@@ -5936,8 +6081,8 @@
     // Our frame is shrinking. Give the text to our next in flow.
     f->mContentOffset = end;
     if (f->GetTextRun() != mTextRun) {
-      ClearTextRun();
-      f->ClearTextRun();
+      ClearTextRun(nsnull);
+      f->ClearTextRun(nsnull);
     }
     return;
   }
@@ -5945,8 +6090,8 @@
     // Our frame is growing. Take text from our in-flow.
     f->mContentOffset = end;
     if (f->GetTextRun() != mTextRun) {
-      ClearTextRun();
-      f->ClearTextRun();
+      ClearTextRun(nsnull);
+      f->ClearTextRun(nsnull);
     }
     f = static_cast<nsTextFrame*>(f->GetNextInFlow());
   }
@@ -6079,7 +6224,7 @@
       // floating first-letter boundaries are significant in textrun
       // construction, so clear the textrun out every time we hit a first-letter
       // and have changed our length (which controls the first-letter boundary)
-      ClearTextRun();
+      ClearTextRun(nsnull);
       // Find the length of the first-letter. We need a textrun for this.
       gfxSkipCharsIterator iter =
         EnsureTextRun(ctx, lineContainer, lineLayout.GetLine(), &flowEndInTextRun);
@@ -6117,7 +6262,7 @@
         // right first-letter boundary
         SetLength(offset + length - GetContentOffset());
         // Ensure that the textrun will be rebuilt
-        ClearTextRun();
+        ClearTextRun(nsnull);
       }
     } 
   }
@@ -6130,7 +6275,7 @@
     // when the textrun was ended in the middle of a text node because a
     // preformatted newline was encountered, and prev-in-flow frames have
     // consumed all the text of the textrun. We need a new textrun.
-    ClearTextRun();
+    ClearTextRun(nsnull);
     iter = EnsureTextRun(ctx, lineContainer,
                          lineLayout.GetLine(), &flowEndInTextRun);
   }
@@ -6754,12 +6899,10 @@
   // Output the tag
   IndentBy(out, aIndent);
   ListTag(out);
-#ifdef DEBUG_waterson
-  fprintf(out, " [parent=%p]", mParent);
-#endif
   if (HasView()) {
     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
   }
+  fprintf(out, " [run=%p]", static_cast<void*>(mTextRun));
 
   PRInt32 totalContentLength;
   nsCAutoString tmp;
@@ -6833,7 +6976,7 @@
    * This is called during bidi resolution from the block container, so we
    * shouldn't be holding a local reference to a textrun anywhere.
    */
-  ClearTextRun();
+  ClearTextRun(nsnull);
 
   nsTextFrame* prev = static_cast<nsTextFrame*>(GetPrevContinuation());
   if (prev) {
@@ -6842,7 +6985,7 @@
     PRInt32 prevOffset = prev->GetContentOffset();
     aStart = PR_MAX(aStart, prevOffset);
     aEnd = PR_MAX(aEnd, prevOffset);
-    prev->ClearTextRun();
+    prev->ClearTextRun(nsnull);
   }
 
   mContentOffset = aStart;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/reftests/bugs/603423-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/603423-1-ref.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html>
+ <head>
+  <title>Testcase for bug 603423</title>
+ </head>
+ <body><p><iframe src="data:text/html;charset=iso-8859-1,<p lang=%22en-US%22 style=%22font-family: serif%22>Hello World</p>"</iframe></p></body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/reftests/bugs/603423-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/603423-1.html	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html>
+ <head>
+  <title>Testcase for bug 603423</title>
+ </head>
+ <body><p lang="en-US"><iframe src="data:text/html;charset=x-mac-arabic,<p lang=%22en-US%22 style=%22font-family: serif%22>Hello World</p>"</iframe></p></body>
+</html>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/reftests/bugs/reftest.list	Thu Dec 02 20:33:03 2010 -0500
@@ -1338,3 +1338,4 @@
 == 537471-1.html 537471-1-ref.html
 == 541382-1.html 541382-1-ref.html
 == 542620-1.html 542620-1-ref.html
+== 603423-1.html 603423-1-ref.html
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/reftests/fonts/VeraBd-validchecksum.ttf
Binary file layout/reftests/fonts/VeraBd-validchecksum.ttf has changed
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/reftests/fonts/markA.otf
Binary file layout/reftests/fonts/markA.otf has changed
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/reftests/fonts/markB.otf
Binary file layout/reftests/fonts/markB.otf has changed
diff -r 8fe44c79dfd1 -r 0c159bd1d600 layout/xul/base/src/tree/src/nsTreeContentView.cpp
--- a/layout/xul/base/src/tree/src/nsTreeContentView.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/layout/xul/base/src/tree/src/nsTreeContentView.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1071,11 +1071,14 @@
   }
   else if (childTag == nsGkAtoms::option) {
     PRInt32 parentIndex = FindContent(aContainer);
-    PRInt32 index = 0;
-    GetIndexInSubtree(aContainer, aChild, &index);
-    PRInt32 count = InsertRow(parentIndex, index, aChild);
-    if (mBoxObject)
-      mBoxObject->RowCountChanged(parentIndex + index + 1, count);
+
+    if (parentIndex >= 0) {
+      PRInt32 index = 0;
+      GetIndexInSubtree(aContainer, aChild, &index);
+      PRInt32 count = InsertRow(parentIndex, index, aChild);
+      if (mBoxObject)
+        mBoxObject->RowCountChanged(parentIndex + index + 1, count);
+    }
   }
 }
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/libpref/src/init/all.js	Thu Dec 02 20:33:03 2010 -0500
@@ -169,6 +169,12 @@
 pref("gfx.color_management.rendering_intent", 0);
 
 pref("gfx.downloadable_fonts.enabled", true);
+pref("gfx.downloadable_fonts.sanitize", true);
+#ifdef XP_MACOSX
+pref("gfx.downloadable_fonts.sanitize.preserve_otl_tables", false);
+#else
+pref("gfx.downloadable_fonts.sanitize.preserve_otl_tables", true);
+#endif
 
 pref("accessibility.browsewithcaret", false);
 pref("accessibility.warn_on_browsewithcaret", true);
@@ -752,6 +758,9 @@
 pref("network.IDN.whitelist.xn--fiqs8s", true); // Simplified
 // hk, Hong Kong, .<Hong Kong>
 pref("network.IDN.whitelist.xn--j6w193g", true);
+// ir, Iran, <.Iran> with variants
+pref("network.IDN.whitelist.xn--mgba3a4f16a", true);
+pref("network.IDN.whitelist.xn--mgba3a4fra", true);
 // jo, Jordan, .<Al-Ordon>
 pref("network.IDN.whitelist.xn--mgbayh7gpa", true);
 // ru, Russian Federation, .<RF>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/libpref/src/nsPrefBranch.cpp
--- a/modules/libpref/src/nsPrefBranch.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/libpref/src/nsPrefBranch.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -71,6 +71,7 @@
   nsPrefBranch     *pBranch;
   nsIObserver      *pObserver;
   nsIWeakReference *pWeakRef;
+  char pDomain[1];
 };
 
 
@@ -634,7 +635,7 @@
       return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  pCallback = (PrefCallbackData *)nsMemory::Alloc(sizeof(PrefCallbackData));
+  pCallback = (PrefCallbackData *)NS_Alloc(sizeof(PrefCallbackData) + strlen(aDomain));
   if (nsnull == pCallback)
     return NS_ERROR_OUT_OF_MEMORY;
 
@@ -656,8 +657,8 @@
     NS_ADDREF(pCallback->pObserver);
   }
 
+  strcpy(pCallback->pDomain, aDomain);
   mObservers->AppendElement(pCallback);
-  mObserverDomains.AppendElement(nsCString(aDomain));
 
   // We must pass a fully qualified preference name to the callback
   pref = getPrefName(aDomain); // aDomain == nsnull only possible failure, trapped above
@@ -687,28 +688,24 @@
 
   for (i = 0; i < count; i++) {
     pCallback = (PrefCallbackData *)mObservers->ElementAt(i);
-    if (pCallback) {
-      if (pCallback->pObserver == aObserver) {
-        domain = mObserverDomains[i];
-        if (domain.Equals(aDomain)) {
-          // We must pass a fully qualified preference name to remove the callback
-          pref = getPrefName(aDomain); // aDomain == nsnull only possible failure, trapped above
-          rv = PREF_UnregisterCallback(pref, NotifyObserver, pCallback);
-          if (NS_SUCCEEDED(rv)) {
-            // Remove this observer from our array so that nobody else can remove
-            // what we're trying to remove ourselves right now.
-            mObservers->RemoveElementAt(i);
-            mObserverDomains.RemoveElementAt(i);
-            if (pCallback->pWeakRef) {
-              NS_RELEASE(pCallback->pWeakRef);
-            } else {
-              NS_RELEASE(pCallback->pObserver);
-            }
-            nsMemory::Free(pCallback);
-          }
-          return rv;
+    if (pCallback &&
+        pCallback->pObserver == aObserver &&
+        !strcmp(pCallback->pDomain, aDomain)) {
+      // We must pass a fully qualified preference name to remove the callback
+      pref = getPrefName(aDomain); // aDomain == nsnull only possible failure, trapped above
+      rv = PREF_UnregisterCallback(pref, NotifyObserver, pCallback);
+      if (NS_SUCCEEDED(rv)) {
+        // Remove this observer from our array so that nobody else can remove
+        // what we're trying to remove ourselves right now.
+        mObservers->RemoveElementAt(i);
+        if (pCallback->pWeakRef) {
+          NS_RELEASE(pCallback->pWeakRef);
+        } else {
+          NS_RELEASE(pCallback->pObserver);
         }
+        NS_Free(pCallback);
       }
+      return rv;
     }
   }
 
@@ -738,7 +735,7 @@
     observer = do_QueryReferent(pData->pWeakRef);
     if (!observer) {
       // this weak referenced observer went away, remove them from the list
-      pData->pBranch->RemoveObserver(newpref, pData->pObserver);
+      pData->pBranch->RemoveObserver(pData->pDomain, pData->pObserver);
       return NS_OK;
     }
   } else {
@@ -768,9 +765,8 @@
       for (i = 0; i < count; ++i) {
         pCallback = (PrefCallbackData *)mObservers->ElementAt(i);
         if (pCallback) {
-          domain = mObserverDomains[i];
           // We must pass a fully qualified preference name to remove the callback
-          pref = getPrefName(domain.get()); // can't fail because domain must be valid
+          pref = getPrefName(pCallback->pDomain);
           // Remove this observer from our array so that nobody else can remove
           // what we're trying to remove right now.
           mObservers->ReplaceElementAt(nsnull, i);
@@ -783,9 +779,6 @@
           nsMemory::Free(pCallback);
         }
       }
-
-      // now empty the observer domains array in bulk
-      mObserverDomains.Clear();
     }
     delete mObservers;
     mObservers = 0;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/libpref/src/nsPrefBranch.h
--- a/modules/libpref/src/nsPrefBranch.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/libpref/src/nsPrefBranch.h	Thu Dec 02 20:33:03 2010 -0500
@@ -83,7 +83,6 @@
   PRInt32               mPrefRootLength;
   nsAutoVoidArray       *mObservers;
   nsCString             mPrefRoot;
-  nsTArray<nsCString>   mObserverDomains;
   PRBool                mIsDefault;
 
 };
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/oji/src/ProxyJNI.cpp
--- a/modules/oji/src/ProxyJNI.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/oji/src/ProxyJNI.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -47,6 +47,7 @@
 #include "nsVoidArray.h"
 #include "plstr.h"
 #include "ProxyClassLoader.h"
+#include "nsCSecurityContext.h"
 
 #include "ProxyJNI.h"
 #include "nsDataHashtable.h"
@@ -281,6 +282,7 @@
     nsISecureEnv* mSecureEnv;
     nsISecurityContext* mContext;
     jbool mInProxyFindClass;
+    nsXPIDLCString mFakeOrigin;
 
     static ProxyJNIEnv& GetProxyEnv(JNIEnv* env) { return *(ProxyJNIEnv*)env; }
 
@@ -293,6 +295,27 @@
         }
     }
 
+    // Don't generate a new fake origin on every call to
+    // nsCSecurityContext::GetOrigin().
+    nsresult getOrSetFakeOrigin(nsCSecurityContext *securityContext)
+    {
+        if (!securityContext)
+            return NS_OK;
+        if (!mFakeOrigin.IsVoid())
+            securityContext->SetFakeOrigin(mFakeOrigin);
+        char origin[256];
+        nsresult rv = securityContext->GetOrigin(origin, 256);
+        if (NS_FAILED(rv))
+            return rv;
+        if (mFakeOrigin.IsVoid()) {
+            const nsCString& contextFakeOrigin =
+               securityContext->GetFakeOrigin();
+            if (!contextFakeOrigin.IsVoid())
+                mFakeOrigin.Assign(contextFakeOrigin);
+        }
+        return NS_OK;
+    }
+
     static jint JNICALL GetVersion(JNIEnv* env)
     {
         jint version = 0;
@@ -499,10 +522,10 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->NewObject(clazz, method->mMethodID, jargs, &outObject, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->NewObject(clazz, method->mMethodID, jargs, &outObject, securityContext);
         NS_IF_RELEASE(securityContext);
-        
         return outObject;
     }
 
@@ -513,8 +536,9 @@
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         JNIMethod* method = (JNIMethod*)methodID;
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->NewObject(clazz, method->mMethodID, args, &outObject, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->NewObject(clazz, method->mMethodID, args, &outObject, securityContext);
         NS_IF_RELEASE(securityContext);
         return outObject;
     }
@@ -568,7 +592,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult rv = secureEnv->CallMethod(method->mReturnType, obj, method->mMethodID, args, &outValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            rv = secureEnv->CallMethod(method->mReturnType, obj, method->mMethodID, args, &outValue, securityContext);
         NS_IF_RELEASE(securityContext);
         return NS_SUCCEEDED(rv) ? outValue : kErrorValue;
     }
@@ -586,8 +612,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->CallMethod(jvoid_type, obj, method->mMethodID, args, &unusedValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->CallMethod(jvoid_type, obj, method->mMethodID, args, &unusedValue, securityContext);
         NS_IF_RELEASE(securityContext);
     }
 
@@ -675,7 +702,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult rv = secureEnv->CallNonvirtualMethod(method->mReturnType, obj, clazz, method->mMethodID, args, &outValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            rv = secureEnv->CallNonvirtualMethod(method->mReturnType, obj, clazz, method->mMethodID, args, &outValue, securityContext);
         NS_IF_RELEASE(securityContext);
         return NS_SUCCEEDED(rv) ? outValue : kErrorValue;
     }
@@ -693,8 +722,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->CallNonvirtualMethod(jvoid_type, obj, clazz, method->mMethodID, args, &unusedValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->CallNonvirtualMethod(jvoid_type, obj, clazz, method->mMethodID, args, &unusedValue, securityContext);
         NS_IF_RELEASE(securityContext);
     }
 
@@ -780,7 +810,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult rv = secureEnv->GetField(field->mFieldType, obj, field->mFieldID, &outValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            rv = secureEnv->GetField(field->mFieldType, obj, field->mFieldID, &outValue, securityContext);
         NS_IF_RELEASE(securityContext);
         return NS_SUCCEEDED(rv) ? outValue : kErrorValue;
     }
@@ -808,8 +840,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->SetField(field->mFieldType, obj, field->mFieldID, value, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->SetField(field->mFieldType, obj, field->mFieldID, value, securityContext);
         NS_IF_RELEASE(securityContext);
     }
 
@@ -864,7 +897,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult rv = secureEnv->CallStaticMethod(method->mReturnType, clazz, method->mMethodID, args, &outValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            rv = secureEnv->CallStaticMethod(method->mReturnType, clazz, method->mMethodID, args, &outValue, securityContext);
         NS_IF_RELEASE(securityContext);
         return NS_SUCCEEDED(rv) ? outValue : kErrorValue;
     }
@@ -882,8 +917,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->CallStaticMethod(jvoid_type, clazz, method->mMethodID, args, &unusedValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->CallStaticMethod(jvoid_type, clazz, method->mMethodID, args, &unusedValue, securityContext);
         NS_IF_RELEASE(securityContext);
     }
 
@@ -969,7 +1005,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult rv = secureEnv->GetStaticField(field->mFieldType, clazz, field->mFieldID, &outValue, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            rv = secureEnv->GetStaticField(field->mFieldType, clazz, field->mFieldID, &outValue, securityContext);
         NS_IF_RELEASE(securityContext);
         return NS_SUCCEEDED(rv) ? outValue : kErrorValue;
     }
@@ -997,8 +1035,9 @@
         ProxyJNIEnv& proxyEnv = GetProxyEnv(env);
         nsISecureEnv* secureEnv = GetSecureEnv(env);
         nsISecurityContext* securityContext = proxyEnv.getContext();
-        nsresult result;
-        result = secureEnv->SetStaticField(field->mFieldType, clazz, field->mFieldID, value, securityContext);
+        nsresult rv = proxyEnv.getOrSetFakeOrigin((nsCSecurityContext*)securityContext);
+        if (NS_SUCCEEDED(rv))
+            secureEnv->SetStaticField(field->mFieldType, clazz, field->mFieldID, value, securityContext);
         NS_IF_RELEASE(securityContext);
     }
 
@@ -1734,9 +1773,8 @@
 ProxyJNIEnv::~ProxyJNIEnv()
 {
     this->functions = NULL;
-    
-    if (mSecureEnv != NULL)
-        mSecureEnv->Release();
+
+    NS_IF_RELEASE(mSecureEnv);
 }
 
 JNIEnv* CreateProxyJNI(nsIJVMPlugin* jvmPlugin, nsISecureEnv* inSecureEnv)
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/oji/src/nsCSecurityContext.cpp
--- a/modules/oji/src/nsCSecurityContext.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/oji/src/nsCSecurityContext.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -57,6 +57,7 @@
 #include "nsIScriptSecurityManager.h"
 #include "nsIServiceManager.h"
 #include "nsCRT.h"
+#include "nsNetUtil.h"
 
 #include "nsTraceRefcnt.h"
 
@@ -103,38 +104,70 @@
     return NS_OK;
 }
 
+nsresult
+nsCSecurityContext::GetOriginImpl(nsXPIDLCString& origin)
+{
+    nsresult rv = NS_OK;
 
-NS_METHOD 
+    if (!m_pPrincipal) {
+        // Get the Script Security Manager.
+        nsCOMPtr<nsIScriptSecurityManager> secMan =
+             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+        if (NS_FAILED(rv) || !secMan)
+            return NS_ERROR_FAILURE;
+
+        secMan->GetSubjectPrincipal(getter_AddRefs(m_pPrincipal));
+        if (!m_pPrincipal)
+            return NS_ERROR_FAILURE;
+    }
+
+    m_pPrincipal->GetOrigin(getter_Copies(origin));
+    if (origin.IsEmpty())
+        return NS_ERROR_FAILURE;
+
+    return NS_OK;
+}
+
+// This method is called from the OJI plugin without checking its return
+// value (from getAndPackSecurityInfo() in remotejni.cpp).  So we need to
+// set the origin appropriately except in the very worst of circumstances,
+// and only then do an error return.
+NS_METHOD
 nsCSecurityContext::GetOrigin(char* buf, int buflen)
 {
-    if (!m_pPrincipal) {
-        // Get the Script Security Manager.
-        nsresult rv = NS_OK;
-        nsCOMPtr<nsIScriptSecurityManager> secMan =
-             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
-        if (NS_FAILED(rv) || !secMan) {
-            return NS_ERROR_FAILURE;
-        }
+    nsXPIDLCString origin;
+    PRBool javaCompatible = PR_FALSE;
 
-        secMan->GetSubjectPrincipal(getter_AddRefs(m_pPrincipal));
-        if (!m_pPrincipal) {
-            return NS_ERROR_FAILURE;
-        }
+    if (NS_SUCCEEDED(GetOriginImpl(origin))) {
+        if (NS_FAILED(NS_CheckIsJavaCompatibleURLString(origin, &javaCompatible)))
+            javaCompatible = PR_FALSE;
+    } else {
+        javaCompatible = PR_FALSE;
     }
 
-    nsXPIDLCString origin;
-    m_pPrincipal->GetOrigin(getter_Copies(origin));
+    PRInt32 originlen = origin.Length();
 
-    PRInt32 originlen = origin.Length();
-    if (origin.IsEmpty() || originlen > buflen - 1) {
+    // Don't pass back a value that Java won't be able to understand or
+    // won't handle correctly.  Instead pass back something that Java will
+    // understand but won't be able to use to access the network, and for
+    // which same-origin checks will always fail.
+    if (!javaCompatible) {
+        if (mFakeOrigin.IsVoid()) {
+            if (NS_FAILED(NS_MakeRandomInvalidURLString(mFakeOrigin)))
+                return NS_ERROR_FAILURE;
+        }
+        origin.Assign(mFakeOrigin);
+        originlen = origin.Length();
+    }
+
+    if (originlen > buflen - 1)
         return NS_ERROR_FAILURE;
-    }
 
     // Copy the string into to user supplied buffer. Is there a better
     // way to do this?
 
     memcpy(buf, origin, originlen);
-    buf[originlen] = nsnull; // Gotta terminate it.
+    buf[originlen] = '\0'; // Gotta terminate it.
 
     return NS_OK;
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/oji/src/nsCSecurityContext.h
--- a/modules/oji/src/nsCSecurityContext.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/oji/src/nsCSecurityContext.h	Thu Dec 02 20:33:03 2010 -0500
@@ -50,6 +50,7 @@
 #include "nsISecurityContext.h"
 #include "nsIPrincipal.h"
 #include "nsCOMPtr.h"
+#include "nsString.h"
 
 struct JSContext;
 
@@ -105,13 +106,22 @@
     nsCSecurityContext(nsIPrincipal* principal);
     virtual ~nsCSecurityContext(void);
 
+    ////////////////////////////////////////////////////////////////////////////
+    // Miscellaneous
+
+    const nsCString& GetFakeOrigin() const { return mFakeOrigin; }
+    void SetFakeOrigin(nsCString& fakeOrigin) { mFakeOrigin.Assign(fakeOrigin); }
+
 protected:
     JSStackFrame *m_pJStoJavaFrame;
     JSContext    *m_pJSCX;
 private:
+    nsresult GetOriginImpl(nsXPIDLCString& origin);
+
     nsCOMPtr<nsIPrincipal> m_pPrincipal;
     PRBool        m_HasUniversalJavaCapability;
     PRBool        m_HasUniversalBrowserReadCapability;
+    nsXPIDLCString mFakeOrigin;
 };
 
 #endif // nsCSecurityContext_h___
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/plugin/base/src/nsPluginHost.cpp
--- a/modules/plugin/base/src/nsPluginHost.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/plugin/base/src/nsPluginHost.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1145,7 +1145,7 @@
   nsresult InitializeEmbedded(nsIURI *aURL,
                              nsIPluginInstance* aInstance,
                              nsIPluginInstanceOwner *aOwner = nsnull,
-                             nsIPluginHost *aHost = nsnull);
+                             nsPluginHost *aHost = nsnull);
 
   nsresult InitializeFullPage(nsIURI* aURL, nsIPluginInstance *aInstance);
 
@@ -1180,7 +1180,7 @@
   // these get passed to the plugin stream listener
   PRUint32                mLength;
   nsPluginStreamType      mStreamType;
-  nsIPluginHost           *mHost;
+  nsPluginHost            *mHost;
 
   // local cached file, we save the content into local cache if browser cache is not available,
   // or plugin asks stream as file and it expects file extension until bug 90558 got fixed
@@ -1536,7 +1536,7 @@
 nsresult nsPluginStreamListenerPeer::InitializeEmbedded(nsIURI *aURL,
                                                         nsIPluginInstance* aInstance,
                                                         nsIPluginInstanceOwner *aOwner,
-                                                        nsIPluginHost *aHost)
+                                                        nsPluginHost *aHost)
 {
 #ifdef PLUGIN_LOGGING
   nsCAutoString urlSpec;
@@ -1809,10 +1809,16 @@
       // determine if we need to try embedded again. FullPage takes a different code path
       nsPluginMode mode;
       mOwner->GetMode(&mode);
-      if (mode == nsPluginMode_Embedded)
-        rv = mHost->InstantiateEmbeddedPlugin(aContentType.get(), aURL, mOwner);
-      else
+      if (mode == nsPluginMode_Embedded) {
+        // Make sure to not allow new streams to be opened here; we've
+        // already got a stream for this data; we just need a properly
+        // set up plugin instance.
+        rv = mHost->DoInstantiateEmbeddedPlugin(aContentType.get(), aURL,
+                                                mOwner, PR_FALSE);
+      }
+      else {
         rv = mHost->SetUpPluginInstance(aContentType.get(), aURL, mOwner);
+      }
 
       if (NS_OK == rv) {
         mOwner->GetInstance(getter_AddRefs(mInstance));
@@ -2886,8 +2892,8 @@
 }
 
 NS_IMETHODIMP nsPluginHost::InstantiatePluginForChannel(nsIChannel* aChannel,
-                                                            nsIPluginInstanceOwner* aOwner,
-                                                            nsIStreamListener** aListener)
+                                                        nsIPluginInstanceOwner* aOwner,
+                                                        nsIStreamListener** aListener)
 {
   NS_PRECONDITION(aChannel && aOwner,
                   "Invalid arguments to InstantiatePluginForChannel");
@@ -2909,8 +2915,9 @@
   }
 #endif
 
-  // XXX do we need to look for stopped plugins, like InstantiateEmbeddedPlugin
-  // does?
+  // Note that we're not setting up a plugin instance here; the stream
+  // listener's OnStartRequest will handle doing that, looking for
+  // stopped plugins, etc, etc.
 
   return NewEmbeddedPluginStreamListener(uri, aOwner, nsnull, aListener);
 }
@@ -2920,6 +2927,14 @@
                                                           nsIURI* aURL,
                                                           nsIPluginInstanceOwner *aOwner)
 {
+  return DoInstantiateEmbeddedPlugin(aMimeType, aURL, aOwner, PR_TRUE);
+}
+
+nsresult
+nsPluginHost::DoInstantiateEmbeddedPlugin(const char *aMimeType, nsIURI* aURL,
+                                          nsIPluginInstanceOwner* aOwner,
+                                          PRBool aAllowOpeningStreams)
+{
   NS_ENSURE_ARG_POINTER(aOwner);
 
 #ifdef PLUGIN_LOGGING
@@ -2955,7 +2970,11 @@
   // Security checks
   // Can't do security checks without a URI - hopefully the plugin will take
   // care of that
-  if (aURL) {
+  // No need to do the security check if aAllowOpeningStreams is
+  // false; we don't plan to do any network access in that case.
+  // Furthermore, doing it could reenter plugin instantiation, which
+  // would be Bad.
+  if (aURL && aAllowOpeningStreams) {
     nsCOMPtr<nsIScriptSecurityManager> secMan =
                     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
     if (NS_FAILED(rv))
@@ -2999,9 +3018,11 @@
   // Determine if the scheme of this URL is one we can handle internaly because we should
   // only open the initial stream if it's one that we can handle internally. Otherwise
   // |NS_OpenURI| in |InstantiateEmbeddedPlugin| may open up a OS protocal registered helper app
+  // Also set bCanHandleInternally to true if aAllowOpeningStreams is
+  // false; we don't want to do any network traffic in that case.
   PRBool bCanHandleInternally = PR_FALSE;
   nsCAutoString scheme;
-  if (aURL && NS_SUCCEEDED(aURL->GetScheme(scheme))) {
+  if (aURL && aAllowOpeningStreams && NS_SUCCEEDED(aURL->GetScheme(scheme))) {
       nsCAutoString contractID(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX);
       contractID += scheme;
       ToLowerCase(contractID);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/plugin/base/src/nsPluginHost.h
--- a/modules/plugin/base/src/nsPluginHost.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/plugin/base/src/nsPluginHost.h	Thu Dec 02 20:33:03 2010 -0500
@@ -326,6 +326,13 @@
                      const nsAString& browserDumpID);
 #endif
 
+  // The guts of InstantiateEmbeddedPlugin.  The last argument should
+  // be false if we already have an in-flight stream and don't need to
+  // set up a new stream.
+  nsresult DoInstantiateEmbeddedPlugin(const char *aMimeType, nsIURI* aURL,
+                                       nsIPluginInstanceOwner* aOwner,
+                                       PRBool aAllowOpeningStreams);
+
 private:
   nsresult
   TrySetUpPluginInstance(const char *aMimeType, nsIURI *aURL, nsIPluginInstanceOwner *aOwner);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/plugin/base/src/nsPluginNativeWindowWin.cpp
--- a/modules/plugin/base/src/nsPluginNativeWindowWin.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/plugin/base/src/nsPluginNativeWindowWin.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -123,6 +123,7 @@
   nsPluginType_Unknown = 0,
   nsPluginType_Flash,
   nsPluginType_Real,
+  nsPluginType_PDF,
   nsPluginType_Other
 } nsPluginType;
 
@@ -154,6 +155,8 @@
   PluginWindowWeakRef mWeakRef;
   nsRefPtr<PluginWindowEvent> mCachedPluginWindowEvent;
 
+  HWND mParentWnd;
+  LONG_PTR mParentProc;
 public:
   nsPluginType mPluginType;
 };
@@ -221,23 +224,6 @@
   nsCOMPtr<nsIPluginInstance> inst;
   win->GetPluginInstance(inst);
 
-  // check plugin mime type and cache whether it is Flash or not
-  // Flash will need special treatment later
-  if (win->mPluginType == nsPluginType_Unknown) {
-    if (inst) {
-      const char* mimetype = nsnull;
-      inst->GetMIMEType(&mimetype);
-      if (mimetype) { 
-        if (!strcmp(mimetype, "application/x-shockwave-flash"))
-          win->mPluginType = nsPluginType_Flash;
-        else if (!strcmp(mimetype, "audio/x-pn-realaudio-plugin"))
-          win->mPluginType = nsPluginType_Real;
-        else
-          win->mPluginType = nsPluginType_Other;
-      }
-    }
-  }
-
   // Real may go into a state where it recursivly dispatches the same event
   // when subclassed. If this is Real, lets examine the event and drop it
   // on the floor if we get into this recursive situation. See bug 192914.
@@ -399,7 +385,10 @@
   mPrevWinProc = NULL;
   mPluginWinProc = NULL;
   mPluginType = nsPluginType_Unknown;
-  
+
+  mParentWnd = NULL;
+  mParentProc = NULL;
+
   if (sWM_FLASHBOUNCEMSG == 0)
     sWM_FLASHBOUNCEMSG = ::RegisterWindowMessage(NS_PLUGIN_CUSTOM_MSG_ID);
 
@@ -494,6 +483,24 @@
   // check the incoming instance, null indicates that window is going away and we are
   // not interested in subclassing business any more, undo and don't subclass
 
+  // check plugin mime type and cache it if it will need special treatment later
+  if (mPluginType == nsPluginType_Unknown) {
+    if (aPluginInstance) {
+      const char* mimetype = nsnull;
+      aPluginInstance->GetMIMEType(&mimetype);
+      if (mimetype) { 
+        if (!strcmp(mimetype, "application/x-shockwave-flash"))
+          mPluginType = nsPluginType_Flash;
+        else if (!strcmp(mimetype, "audio/x-pn-realaudio-plugin"))
+          mPluginType = nsPluginType_Real;
+        else if (!strcmp(mimetype, "application/pdf"))
+          mPluginType = nsPluginType_PDF;
+        else
+          mPluginType = nsPluginType_Other;
+      }
+    }
+  }
+
   // WINCE does not subclass windows.  See bug 300011 for the details.
 #ifndef WINCE
   if (!aPluginInstance) {
@@ -506,6 +513,17 @@
     WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr((HWND)window, GWLP_WNDPROC);
     if (currentWndProc != PluginWndProc)
       mPrevWinProc = currentWndProc;
+
+    // PDF plugin v7.0.9, v8.1.3, and v9.0 subclass parent window, bug 531551
+    // V8.2.2 and V9.1 don't have such problem.
+    if (mPluginType == nsPluginType_PDF) {
+      HWND parent = ::GetParent((HWND)window);
+      if (mParentWnd != parent) {
+        NS_ASSERTION(!mParentWnd, "Plugin's parent window changed");
+        mParentWnd = parent;
+        mParentProc = ::GetWindowLongPtr(mParentWnd, GWLP_WNDPROC);
+      }
+    }
   }
 #endif
 
@@ -584,6 +602,12 @@
     SetWindowLongPtr(hWnd, GWL_STYLE, style);
   }
 
+  if (mPluginType == nsPluginType_PDF && mParentWnd) {
+    ::SetWindowLongPtr(mParentWnd, GWLP_WNDPROC, mParentProc);
+    mParentWnd = NULL;
+    mParentProc = NULL;
+  }
+
   return NS_OK;
 }
 #endif // WINCE
diff -r 8fe44c79dfd1 -r 0c159bd1d600 modules/plugin/test/unit/head_plugins.js
--- a/modules/plugin/test/unit/head_plugins.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/modules/plugin/test/unit/head_plugins.js	Thu Dec 02 20:33:03 2010 -0500
@@ -64,3 +64,8 @@
   }
   return null;
 }
+
+var gPrefs = Components.classes["@mozilla.org/preferences;1"]
+                   .getService(Components.interfaces.nsIPrefBranch);
+// Ensure plugins are globally enabled
+gPrefs.setBoolPref("plugin.disable", false);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/netwerk/base/public/nsNetUtil.h	Thu Dec 02 20:33:03 2010 -0500
@@ -50,6 +50,9 @@
 
 #include "nsCRT.h"
 #include "nsIURI.h"
+#include "nsIStandardURL.h"
+#include "nsIURLParser.h"
+#include "nsIUUIDGenerator.h"
 #include "nsIInputStream.h"
 #include "nsIOutputStream.h"
 #include "nsISafeOutputStream.h"
@@ -1530,7 +1533,7 @@
 
     nsCAutoString host;
     PRUint32 hostHash = 0;
-    if (NS_SUCCEEDED(baseURI->GetHost(host)))
+    if (NS_SUCCEEDED(baseURI->GetAsciiHost(host)))
         hostHash = nsCRT::HashCode(host.get());
 
     // XOR to combine hash values
@@ -1625,6 +1628,13 @@
         return PR_FALSE;
     }
 
+    nsCOMPtr<nsIStandardURL> targetURL(do_QueryInterface(targetBaseURI));
+    nsCOMPtr<nsIStandardURL> sourceURL(do_QueryInterface(sourceBaseURI));
+    if (!targetURL || !sourceURL)
+    {
+        return PR_FALSE;
+    }
+
 #ifdef MOZILLA_INTERNAL_API
     if (!targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator() ))
 #else
@@ -1658,4 +1668,81 @@
   return NS_SUCCEEDED(oldURI->Equals(newURI, &res)) && res;
 }
 
+/**
+ * Helper function to create a random URL string that's properly formed
+ * but guaranteed to be invalid.
+ */  
+#define NS_FAKE_SCHEME "http://"
+#define NS_FAKE_TLD ".invalid"
+inline nsresult
+NS_MakeRandomInvalidURLString(nsCString& result)
+{
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> uuidgen =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsID idee;
+  rv = uuidgen->GenerateUUIDInPlace(&idee);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  char chars[NSID_LENGTH];
+  idee.ToProvidedString(chars);
+
+  result.AssignLiteral(NS_FAKE_SCHEME);
+  // Strip off the '{' and '}' at the beginning and end of the UUID
+  result.Append(chars + 1, NSID_LENGTH - 3);
+  result.AppendLiteral(NS_FAKE_TLD);
+
+  return NS_OK;
+}
+#undef NS_FAKE_SCHEME
+#undef NS_FAKE_TLD
+
+/**
+ * Helper function to determine whether urlString is Java-compatible --
+ * whether it can be passed to the Java URL(String) constructor without the
+ * latter throwing a MalformedURLException, or without Java otherwise
+ * mishandling it.
+ */  
+inline nsresult
+NS_CheckIsJavaCompatibleURLString(nsCString& urlString, PRBool *result)
+{
+  *result = PR_FALSE; // Default to "no"
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIURLParser> urlParser =
+    do_GetService(NS_STDURLPARSER_CONTRACTID, &rv);
+  if (NS_FAILED(rv) || !urlParser)
+    return NS_ERROR_FAILURE;
+
+  PRBool compatible = PR_TRUE;
+  PRUint32 schemePos = 0;
+  PRInt32 schemeLen = 0;
+  urlParser->ParseURL(urlString.get(), -1, &schemePos, &schemeLen,
+                      nsnull, nsnull, nsnull, nsnull);
+  if (schemeLen != -1) {
+    nsCString scheme;
+    scheme.Assign(urlString.get() + schemePos, schemeLen);
+    // By default Java only understands a small number of URL schemes, and of
+    // these only some are likely to represent user input (for example from a
+    // link or the location bar) that Java can legitimately be expected to
+    // handle.  (Besides those listed below, Java also understands the "jar",
+    // "mailto" and "netdoc" schemes.  But it probably doesn't expect these
+    // from a browser, and is therefore likely to mishandle them.)
+    if (PL_strcasecmp(scheme.get(), "http") &&
+        PL_strcasecmp(scheme.get(), "https") &&
+        PL_strcasecmp(scheme.get(), "file") &&
+        PL_strcasecmp(scheme.get(), "ftp") &&
+        PL_strcasecmp(scheme.get(), "gopher"))
+      compatible = PR_FALSE;
+  } else {
+    compatible = PR_FALSE;
+  }
+
+  *result = compatible;
+
+  return NS_OK;
+}
+
 #endif // !nsNetUtil_h__
diff -r 8fe44c79dfd1 -r 0c159bd1d600 netwerk/base/src/nsProtocolProxyService.cpp
--- a/netwerk/base/src/nsProtocolProxyService.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/netwerk/base/src/nsProtocolProxyService.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1253,6 +1253,12 @@
             return NS_OK;
         }
 
+        // See bug #586908.
+        // Avoid endless loop if |uri| is the current PAC-URI. Returning OK
+        // here means that we will not use a proxy for this connection.
+        if (mPACMan && mPACMan->IsPACURI(uri))
+            return NS_OK;
+
         // Switch to new PAC file if that setting has changed. If the setting
         // hasn't changed, ConfigureFromPAC will exit early.
         nsresult rv = ConfigureFromPAC(PACURI, PR_FALSE);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 netwerk/cookie/src/nsCookieService.cpp
--- a/netwerk/cookie/src/nsCookieService.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/netwerk/cookie/src/nsCookieService.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -566,7 +566,7 @@
 
   // cache frequently used statements (for insertion, deletion, and updating)
   rv = mDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
-    "INSERT INTO moz_cookies "
+    "INSERT OR REPLACE INTO moz_cookies "
     "(id, name, value, host, path, expiry, lastAccessed, isSecure, isHttpOnly) "
     "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"),
     getter_AddRefs(mDBState->stmtInsert));
diff -r 8fe44c79dfd1 -r 0c159bd1d600 netwerk/dns/src/effective_tld_names.dat
--- a/netwerk/dns/src/effective_tld_names.dat	Tue Oct 26 19:49:55 2010 -0700
+++ b/netwerk/dns/src/effective_tld_names.dat	Thu Dec 02 20:33:03 2010 -0500
@@ -4442,173 +4442,7 @@
 // only subdomains are available, or even nothing at all. We include the
 // most common ones where it's clear that different sites are different
 // entities.
-k12.ak.us
-k12.al.us
-k12.ar.us
-k12.as.us
-k12.az.us
-k12.ca.us
-k12.co.us
-k12.ct.us
-k12.dc.us
-k12.de.us
-k12.fl.us
-k12.ga.us
-k12.gu.us
-k12.hi.us
-k12.ia.us
-k12.id.us
-k12.il.us
-k12.in.us
-k12.ks.us
-k12.ky.us
-k12.la.us
-k12.ma.us
-k12.md.us
-k12.me.us
-k12.mi.us
-k12.mn.us
-k12.mo.us
-k12.ms.us
-k12.mt.us
-k12.nc.us
-k12.nd.us
-k12.ne.us
-k12.nh.us
-k12.nj.us
-k12.nm.us
-k12.nv.us
-k12.ny.us
-k12.oh.us
-k12.ok.us
-k12.or.us
-k12.pa.us
-k12.pr.us
-k12.ri.us
-k12.sc.us
-k12.sd.us
-k12.tn.us
-k12.tx.us
-k12.ut.us
-k12.vi.us
-k12.vt.us
-k12.va.us
-k12.wa.us
-k12.wi.us
-k12.wv.us
-k12.wy.us
-
-cc.ak.us
-cc.al.us
-cc.ar.us
-cc.as.us
-cc.az.us
-cc.ca.us
-cc.co.us
-cc.ct.us
-cc.dc.us
-cc.de.us
-cc.fl.us
-cc.ga.us
-cc.gu.us
-cc.hi.us
-cc.ia.us
-cc.id.us
-cc.il.us
-cc.in.us
-cc.ks.us
-cc.ky.us
-cc.la.us
-cc.ma.us
-cc.md.us
-cc.me.us
-cc.mi.us
-cc.mn.us
-cc.mo.us
-cc.ms.us
-cc.mt.us
-cc.nc.us
-cc.nd.us
-cc.ne.us
-cc.nh.us
-cc.nj.us
-cc.nm.us
-cc.nv.us
-cc.ny.us
-cc.oh.us
-cc.ok.us
-cc.or.us
-cc.pa.us
-cc.pr.us
-cc.ri.us
-cc.sc.us
-cc.sd.us
-cc.tn.us
-cc.tx.us
-cc.ut.us
-cc.vi.us
-cc.vt.us
-cc.va.us
-cc.wa.us
-cc.wi.us
-cc.wv.us
-cc.wy.us
-
-lib.ak.us
-lib.al.us
-lib.ar.us
-lib.as.us
-lib.az.us
-lib.ca.us
-lib.co.us
-lib.ct.us
-lib.dc.us
-lib.de.us
-lib.fl.us
-lib.ga.us
-lib.gu.us
-lib.hi.us
-lib.ia.us
-lib.id.us
-lib.il.us
-lib.in.us
-lib.ks.us
-lib.ky.us
-lib.la.us
-lib.ma.us
-lib.md.us
-lib.me.us
-lib.mi.us
-lib.mn.us
-lib.mo.us
-lib.ms.us
-lib.mt.us
-lib.nc.us
-lib.nd.us
-lib.ne.us
-lib.nh.us
-lib.nj.us
-lib.nm.us
-lib.nv.us
-lib.ny.us
-lib.oh.us
-lib.ok.us
-lib.or.us
-lib.pa.us
-lib.pr.us
-lib.ri.us
-lib.sc.us
-lib.sd.us
-lib.tn.us
-lib.tx.us
-lib.ut.us
-lib.vi.us
-lib.vt.us
-lib.va.us
-lib.wa.us
-lib.wi.us
-lib.wv.us
-lib.wy.us
+// (Entries removed, perhaps temporarily...see bug 614565)
 
 // k12.ma.us contains school districts in Massachusetts. The 4LDs are 
 //  managed indepedently except for private (PVT), charter (CHTR) and
diff -r 8fe44c79dfd1 -r 0c159bd1d600 netwerk/test/unit/test_bug586908.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/test/unit/test_bug586908.js	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,109 @@
+
+do_load_httpd_js();
+
+var httpserv = null;
+
+const CID = Components.ID("{5645d2c1-d6d8-4091-b117-fe7ee4027db7}");
+const contractID = "@mozilla.org/system-proxy-settings;1"
+
+var systemSettings = {
+  QueryInterface: function (iid) {
+    if (iid.equals(Components.interfaces.nsISupports) ||
+        iid.equals(Components.interfaces.nsIFactory) ||
+        iid.equals(Components.interfaces.nsISystemProxySettings))
+      return this;
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  },
+  createInstance: function (outer, iid) {
+    if (outer)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+    return this.QueryInterface(iid);
+  },
+  lockFactory: function (lock) {
+    throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+  },
+  
+  PACURI: "http://localhost:4444/redirect",
+  getProxyForURI: function(aURI) {
+    throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+  }
+};
+
+function checkValue(request, data, ctx) {
+  do_check_true(called);
+  do_check_eq("ok", data);
+  httpserv.stop(do_test_finished);
+}
+
+function getCacheService()
+{
+  return Components.classes["@mozilla.org/network/cache-service;1"]
+                   .getService(Components.interfaces.nsICacheService);
+}
+
+function makeChan(url) {
+  var ios = Components.classes["@mozilla.org/network/io-service;1"]
+                      .getService(Components.interfaces.nsIIOService);
+  var chan = ios.newChannel(url, null, null)
+                .QueryInterface(Components.interfaces.nsIHttpChannel);
+
+  return chan;
+}
+
+function run_test() {
+  httpserv = new nsHttpServer();
+  httpserv.registerPathHandler("/redirect", redirect);
+  httpserv.registerPathHandler("/pac", pac);
+  httpserv.registerPathHandler("/target", target);
+  httpserv.start(4444);
+
+  Components.manager.nsIComponentRegistrar.registerFactory(
+    CID,
+    "Fake system proxy-settings",
+    contractID, systemSettings);
+
+  // Ensure we're using system-properties
+  const prefs = Cc["@mozilla.org/preferences-service;1"]
+                   .getService(Ci.nsIPrefBranch);
+  prefs.setIntPref("network.proxy.type", 5); // Note: hardcoded in this branch
+
+  // clear cache
+  getCacheService().
+    evictEntries(Components.interfaces.nsICache.STORE_ANYWHERE);
+
+  var chan = makeChan("http://localhost:4444/target");
+  chan.asyncOpen(new ChannelListener(checkValue, null), null);
+
+  do_test_pending();
+}
+
+var called = false, failed = false;
+function redirect(metadata, response) {
+  // If called second time, just return the PAC but set failed-flag
+  if (called) {
+      failed = true;
+      return pac(metadata, response);
+   }
+  
+  called = true;
+  response.setStatusLine(metadata.httpVersion, 302, "Found");
+  response.setHeader("Location", "/pac", false);
+  var body = "Moved\n";
+  response.bodyOutputStream.write(body, body.length);
+}
+
+function pac(metadata, response) {
+  var PAC = 'function FindProxyForURL(url, host) { return "DIRECT"; }';
+  response.setStatusLine(metadata.httpVersion, 200, "Ok");
+  response.setHeader("Content-Type", "application/x-ns-proxy-autoconfig", false);
+  response.bodyOutputStream.write(PAC, PAC.length);
+}
+
+function target(metadata, response) {
+  var retval = "ok";
+  if (failed) retval = "failed";
+
+  response.setStatusLine(metadata.httpVersion, 200, "Ok");
+  response.setHeader("Content-Type", "text/plain", false);
+  response.bodyOutputStream.write(retval, retval.length);
+}
diff -r 8fe44c79dfd1 -r 0c159bd1d600 netwerk/test/unit/test_compareURIs.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/test/unit/test_compareURIs.js	Thu Dec 02 20:33:03 2010 -0500
@@ -0,0 +1,49 @@
+Components.utils.import("resource://gre/modules/NetUtil.jsm");
+
+function do_info(text, stack) {
+  if (!stack)
+    stack = Components.stack.caller;
+
+  dump("TEST-INFO | " + stack.filename + " | [" + stack.name + " : " +
+       stack.lineNumber + "] " + text + "\n");
+}
+function run_test()
+{
+    var tests = [
+	[ "http://mozilla.org/", "http://mozilla.org/somewhere/there", true ],
+	[ "http://mozilla.org/", "http://www.mozilla.org/", false ],
+	[ "http://mozilla.org/", "http://mozilla.org:80", true ],
+	[ "http://mozilla.org/", "http://mozilla.org:90", false ],
+	[ "http://mozilla.org", "https://mozilla.org", false ],
+	[ "http://mozilla.org", "https://mozilla.org:80", false ],	
+	[ "http://mozilla.org:443", "https://mozilla.org", false ],
+	[ "https://mozilla.org:443", "https://mozilla.org", true ],
+	[ "https://mozilla.org:443", "https://mozilla.org/somewhere/", true ],
+	[ "about:", "about:", false ],
+	[ "data:text/plain,text", "data:text/plain,text", false ],
+	[ "about:blank", "about:blank", false ],
+	[ "about:", "http://mozilla.org/", false ],
+	[ "about:", "about:config", false ],
+	[ "about:text/plain,text", "data:text/plain,text", false ],
+	[ "jar:http://mozilla.org/!/", "http://mozilla.org/", true ],
+	[ "view-source:http://mozilla.org/", "http://mozilla.org/", true ]
+    ];
+
+    var secman = Components.classes["@mozilla.org/scriptsecuritymanager;1"].getService(Components.interfaces.nsIScriptSecurityManager);
+
+    tests.forEach(function(aTest) {
+        do_info("Comparing " + aTest[0] + " to " + aTest[1]);
+
+	var uri1 = NetUtil.newURI(aTest[0]);
+	var uri2 = NetUtil.newURI(aTest[1]);
+
+	var equal;
+	try {
+	    secman.checkSameOriginURI(uri1, uri2, false);
+	    equal = true;
+	} catch (e) {
+	    equal = false
+	}
+	do_check_eq(equal, aTest[2]);
+    });
+}
diff -r 8fe44c79dfd1 -r 0c159bd1d600 parser/htmlparser/src/nsScanner.cpp
--- a/parser/htmlparser/src/nsScanner.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/parser/htmlparser/src/nsScanner.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -190,6 +190,16 @@
 
   res = nsParser::GetCharsetConverterManager()->
     GetUnicodeDecoderRaw(mCharset.get(), getter_AddRefs(mUnicodeDecoder));
+  if (NS_FAILED(res))
+  {
+    // GetUnicodeDecoderRaw can fail if the charset has the .isXSSVulnerable
+    // flag. Try to fallback to ISO-8859-1
+    mCharset.AssignLiteral("ISO-8859-1");
+    mCharsetSource = kCharsetFromWeakDocTypeDefault;
+    res = nsParser::GetCharsetConverterManager()->
+      GetUnicodeDecoderRaw(mCharset.get(), getter_AddRefs(mUnicodeDecoder));
+  }
+
   if (NS_SUCCEEDED(res) && mUnicodeDecoder)
   {
      // We need to detect conversion error of character to support XML
diff -r 8fe44c79dfd1 -r 0c159bd1d600 security/manager/ssl/src/nsCrypto.cpp
--- a/security/manager/ssl/src/nsCrypto.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/security/manager/ssl/src/nsCrypto.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -696,6 +696,10 @@
                                                      (params) ? strlen(params):0, 
                                                      keySize, keyPairInfo);
 
+  if (!keyGenParams) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
   // Make sure the token has password already set on it before trying
   // to generate the key.
 
diff -r 8fe44c79dfd1 -r 0c159bd1d600 testing/mochitest/tests/SimpleTest/SimpleTest.js
--- a/testing/mochitest/tests/SimpleTest/SimpleTest.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/testing/mochitest/tests/SimpleTest/SimpleTest.js	Thu Dec 02 20:33:03 2010 -0500
@@ -49,12 +49,12 @@
 **/
 SimpleTest.is = function (a, b, name) {
     var repr = MochiKit.Base.repr;
-    SimpleTest.ok(a == b, name, "got " + repr(a) + ", expected " + repr(b));
+    SimpleTest.ok(a == b, name, repr(a) + " should equal " + repr(b));
 };
 
 SimpleTest.isnot = function (a, b, name) {
     var repr = MochiKit.Base.repr;
-    SimpleTest.ok(a != b, name, "Didn't expect " + repr(a) + ", but got it.");
+    SimpleTest.ok(a != b, name, repr(a) + " should not equal " + repr(b));
 };
 
 //  --------------- Test.Builder/Test.More todo() -----------------
@@ -72,17 +72,18 @@
   if (parentRunner.currentTestURL)
     msg += parentRunner.currentTestURL;
   msg += " | " + test.name;
-  var diag = test.diag ? " - " + test.diag : "";
+  if (test.diag)
+    msg += " - " + test.diag;
   if (test.result) {
       if (test.todo)
-          parentRunner.logger.error(msg + diag);
+          parentRunner.logger.error(msg);
       else
           parentRunner.logger.log(msg);
   } else {
       if (test.todo)
           parentRunner.logger.log(msg);
       else
-          parentRunner.logger.error(msg + diag);
+          parentRunner.logger.error(msg);
   }
 };
 
@@ -92,12 +93,12 @@
 
 SimpleTest.todo_is = function (a, b, name) {
     var repr = MochiKit.Base.repr;
-    SimpleTest.todo(a == b, name, "got " + repr(a) + ", expected " + repr(b));
+    SimpleTest.todo(a == b, name, repr(a) + " should equal " + repr(b));
 };
 
 SimpleTest.todo_isnot = function (a, b, name) {
     var repr = MochiKit.Base.repr;
-    SimpleTest.todo(a != b, name, "Didn't expect " + repr(a) + ", but got it.");
+    SimpleTest.todo(a != b, name, repr(a) + " should not equal " + repr(b));
 };
 
 
@@ -126,7 +127,7 @@
             } else if (test.result && !test.todo) {
                 passed++;
                 cls = "test_ok";
-                msg = "passed | " + test.name;
+                msg = "passed | " + test.name + diag;
             } else {
                 failed++;
                 cls = "test_not_ok";
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/components/alerts/test/test_alerts.html
--- a/toolkit/components/alerts/test/test_alerts.html	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/components/alerts/test/test_alerts.html	Thu Dec 02 20:33:03 2010 -0500
@@ -1,18 +1,21 @@
 <!DOCTYPE HTML>
+<!-- Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/publicdomain/zero/1.0/ -->
 <html>
 <head>
   <title>Test for Alerts Service</title>
   <script type="text/javascript" src="/MochiKit/packed.js"></script>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script> 
-  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
 </head>
+
 <body>
 <p id="display"></p>
 
-Alerts service mochitest<br/>
-
-Did an alert appear anywhere?<br/>
-If so, the test will finish once the alert disappears. If not, the test will time out.<br/>
+<br>Alerts service, with observer "synchronous" case.
+<br>
+<br>Did a notification appear anywhere?
+<br>If so, the test will finish once the notification disappears.
 
 <pre id="test">
 <script class="testbody" type="text/javascript">
@@ -20,29 +23,56 @@
 
 var observer = {
   observe: function (aSubject, aTopic, aData) {
-    if (aTopic != "alertclickcallback") // Did someone click the alert while running mochitests?...
+    if (aTopic == "alertclickcallback")
+      todo(false, "Did someone click the notification while running mochitests? (Please don't.)");
+    else
       is(aTopic, "alertfinished", "Checking the topic for a finished notification");
+    is(aData, "foobarcookie", "Checking whether the alert cookie was passed correctly");
 
-    is(aData, "foobarcookie", "Checking whether the alert cookie was passed correctly");
-    SimpleTest.finish();
+    // finish(), yet let the test actually end first, to be safe.
+    SimpleTest.executeSoon(SimpleTest.finish);
   }
 };
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
-try {
-  var notifier = Cc["@mozilla.org/alerts-service;1"].
-                 getService(Ci.nsIAlertsService);
-  notifier.showAlertNotification(null, "Notification test", "Surprise! I'm here to test notifications!",
-                                 false, "foobarcookie", observer);
 
-  SimpleTest.waitForExplicitFinish();
-} catch (ex) {
-  // Alerts service doesn't exist
+var gNotificationIsAvailable;
+
+if (!("@mozilla.org/alerts-service;1" in Cc)) {
+  todo(false, "Alerts service does not exist in this application");
+} else {
+  ok(true, "Alerts service exists in this application");
+
+  var notifier;
+  try {
+    notifier = Cc["@mozilla.org/alerts-service;1"].
+               getService(Ci.nsIAlertsService);
+    ok(true, "Alerts service is available");
+  } catch (ex) {
+    todo(false, "Alerts service is not available. (Mac OS X without Growl?)", ex);
+  }
+
+  if (notifier) {
+    try {
+      notifier.showAlertNotification(null, "Notification test",
+                                     "Surprise! I'm here to test notifications!",
+                                     false, "foobarcookie", observer);
+      ok(true, "showAlertNotification() succeeded");
+
+      gNotificationIsAvailable = true;
+    } catch (ex) {
+      todo(false, "showAlertNotification() failed. (Mac OS X without Growl?)", ex);
+    }
+  }
 }
 
+if (gNotificationIsAvailable) {
+  // Wait for the (asynchronous) notification callback.
+  SimpleTest.waitForExplicitFinish();
+  ok(true, "Waiting for notification callback to be triggered...");
+}
 </script>
 </pre>
 </body>
 </html>
-
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/components/alerts/test/test_alerts_noobserve.html
--- a/toolkit/components/alerts/test/test_alerts_noobserve.html	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/components/alerts/test/test_alerts_noobserve.html	Thu Dec 02 20:33:03 2010 -0500
@@ -1,15 +1,21 @@
 <!DOCTYPE HTML>
+<!-- Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/publicdomain/zero/1.0/ -->
 <html>
 <head>
   <title>Test for Alerts Service</title>
   <script type="text/javascript" src="/MochiKit/packed.js"></script>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script> 
-  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
 </head>
+
 <body>
 <p id="display"></p>
 
-Alerts service mochitest without observer<br/>
+<br>Alerts service, without observer "asynchronous" case.
+<br>
+<br>A notification should soon appear somewhere.
+<br>If there has been no crash when the notification (later) disappears, assume all is good.
 
 <pre id="test">
 <script class="testbody" type="text/javascript">
@@ -17,18 +23,40 @@
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
-try {
-  var notifier = Cc["@mozilla.org/alerts-service;1"].
-                 getService(Ci.nsIAlertsService);
-  notifier.showAlertNotification(null, "Notification test", "This notification has no observer",
-                                 false, "foobarcookie", null);
-  ok(true, "If we don't crash, we're good.");
-} catch (ex) {
-  // Alerts service doesn't exist
+
+var gNotificationIsAvailable;
+
+if (!("@mozilla.org/alerts-service;1" in Cc)) {
+  todo(false, "Alerts service does not exist in this application");
+} else {
+  ok(true, "Alerts service exists in this application");
+
+  var notifier;
+  try {
+    notifier = Cc["@mozilla.org/alerts-service;1"].
+               getService(Ci.nsIAlertsService);
+    ok(true, "Alerts service is available");
+  } catch (ex) {
+    todo(false, "Alerts service is not available. (Mac OS X without Growl?)", ex);
+  }
+
+  if (notifier) {
+    try {
+      notifier.showAlertNotification(null, "Notification test",
+                                     "This notification has no observer");
+      ok(true, "showAlertNotification() succeeded");
+
+      gNotificationIsAvailable = true;
+    } catch (ex) {
+      todo(false, "showAlertNotification() failed. (Mac OS X without Growl?)", ex);
+    }
+  }
 }
 
+if (gNotificationIsAvailable) {
+  ok(true, "Notification should actually display during later tests... (Hope this doesn't disturb them!)");
+}
 </script>
 </pre>
 </body>
 </html>
-
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/components/downloads/test/unit/test_bug_401430.js
--- a/toolkit/components/downloads/test/unit/test_bug_401430.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/components/downloads/test/unit/test_bug_401430.js	Thu Dec 02 20:33:03 2010 -0500
@@ -46,13 +46,35 @@
 // U+3056 : HIRAGANA LETTER ZA
 const resultFileName = "test\u00e3\u041b\u3056" + Date.now() + ".doc";
 
+// Milliseconds between polls.
+const POLL_REGISTRY_TIMEOUT = 200;
+// Max number of polls.
+const POLL_REGISTRY_MAX_LOOPS = 25;
+
 function checkResult() {
   // delete the saved file (this doesn't affect the "recent documents" list)
   var resultFile = do_get_file(resultFileName);
   resultFile.remove(false);
 
-  do_check_true(checkRecentDocsFor(resultFileName));
-  do_test_finished();
+  // Need to poll RecentDocs value because the SHAddToRecentDocs call
+  // doesn't update the registry immediately.
+  do_timeout(POLL_REGISTRY_TIMEOUT, "pollRecentDocs();");
+}
+
+var gPollsCount = 0;
+function pollRecentDocs() {
+  if (++gPollsCount > POLL_REGISTRY_MAX_LOOPS) {
+    do_throw("Maximum time elapsed while polling RecentDocs.");
+    do_test_finished();
+    return;
+  }
+
+  if (checkRecentDocsFor(resultFileName)) {
+    print("Document found in RecentDocs");
+    do_test_finished();
+  }
+  else
+    do_timeout(POLL_REGISTRY_TIMEOUT, "pollRecentDocs();");
 }
 
 function checkRecentDocsFor(aFileName) {
@@ -104,9 +126,7 @@
   var listener = {
     onDownloadStateChange: function test_401430_odsc(aState, aDownload) {
       if (aDownload.state == Ci.nsIDownloadManager.DOWNLOAD_FINISHED) {
-        // Need to run this from a timeout, because the SHAddToRecentDocs call
-        // doesn't update the registry immediately.
-        do_timeout(1000, "checkResult();");
+        checkResult();
       }
     },
     onStateChange: function(a, b, c, d, e) { },
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/content/license.html
--- a/toolkit/content/license.html	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/content/license.html	Thu Dec 02 20:33:03 2010 -0500
@@ -1063,7 +1063,7 @@
 General Public License applies to most of the Free Software
 Foundation's software and to any other program whose authors commit to
 using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
+the GNU Lesser General Public License instead.)  You can apply it to
 your programs, too.
 
 <p>  When we speak of free software, we are referring to freedom, not
@@ -1365,9 +1365,9 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 </pre>
 
 <p>Also add information on how to contact you by electronic and paper mail.
@@ -1402,7 +1402,7 @@
 <p>This General Public License does not permit incorporating your program into
 proprietary programs.  If your program is a subroutine library, you may
 consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
+library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.
 
 
@@ -2109,8 +2109,9 @@
 
     <h1><a name="chromium"></a>Chromium License</h1>
 
-    <p class="correctme">This license applies to some files in the directory
-      <span class="path">ipc/chromium/</span>.
+    <p class="correctme">This license applies to some files in the directories
+      <span class="path">ipc/chromium/</span> and
+      <span class="path">gfx/ots/</span>.
     </p>
 
 <pre>
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/crashreporter/tools/upload_symbols.sh
--- a/toolkit/crashreporter/tools/upload_symbols.sh	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/crashreporter/tools/upload_symbols.sh	Thu Dec 02 20:33:03 2010 -0500
@@ -44,6 +44,9 @@
 # And will use the following optional environment variables if set:
 # SYMBOL_SERVER_SSH_KEY : path to a ssh private key to use
 # SYMBOL_SERVER_PORT    : port to use for ssh
+# POST_SYMBOL_UPLOAD_CMD: a commandline to run on the remote host after
+#                         uploading. The full path of the symbol index
+#                         file will be appended to the commandline.
 #
 set -e
 
@@ -63,4 +66,11 @@
    cd ${SYMBOL_SERVER_PATH};
    unzip -o '$archive';
    rm -v '$archive';"
+if test -n "$POST_SYMBOL_UPLOAD_CMD"; then
+  echo "${POST_SYMBOL_UPLOAD_CMD} \"${SYMBOL_SERVER_PATH}/${SYMBOL_INDEX_NAME}\""
+  ssh -2 ${SYMBOL_SERVER_PORT:+-p $SYMBOL_SERVER_PORT} \
+  ${SYMBOL_SERVER_SSH_KEY:+-i "$SYMBOL_SERVER_SSH_KEY"} \
+  -l ${SYMBOL_SERVER_USER} ${SYMBOL_SERVER_HOST} \
+  "${POST_SYMBOL_UPLOAD_CMD} \"${SYMBOL_SERVER_PATH}/${SYMBOL_INDEX_NAME}\""
+fi
 echo "Symbol transfer completed"
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/library/libxul-rules.mk
--- a/toolkit/library/libxul-rules.mk	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/library/libxul-rules.mk	Thu Dec 02 20:33:03 2010 -0500
@@ -44,6 +44,7 @@
 	$(MOZ_JS_LIBS) \
 	$(NSS_LIBS) \
 	$(MOZ_CAIRO_LIBS) \
+	$(MOZ_OTS_LIBS) \
 	$(NULL)
 
 ifdef MOZ_NATIVE_ZLIB
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/mozapps/extensions/src/nsExtensionManager.js.in
--- a/toolkit/mozapps/extensions/src/nsExtensionManager.js.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/mozapps/extensions/src/nsExtensionManager.js.in	Thu Dec 02 20:33:03 2010 -0500
@@ -1227,10 +1227,11 @@
               linkedDirectory.isDirectory()) {
             locations.push(linkedDirectory);
             this._locationToIDMap[linkedDirectory.persistentDescriptor] = entry.leafName;
+            continue;
           }
         }
-        else
-          locations.push(entry);
+
+        locations.push(entry);
       }
       entries.close();
     }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/mozapps/extensions/test/unit/head_extensionmanager.js
--- a/toolkit/mozapps/extensions/test/unit/head_extensionmanager.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/mozapps/extensions/test/unit/head_extensionmanager.js	Thu Dec 02 20:33:03 2010 -0500
@@ -264,3 +264,5 @@
                    .getService(Components.interfaces.nsIPrefBranch);
 // Enable more extensive EM logging
 gPrefs.setBoolPref("extensions.logging.enabled", true);
+// Ensure plugins are globally enabled
+gPrefs.setBoolPref("plugin.disable", false);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/mozapps/extensions/test/unit/test_bug386153.js
--- a/toolkit/mozapps/extensions/test/unit/test_bug386153.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/mozapps/extensions/test/unit/test_bug386153.js	Thu Dec 02 20:33:03 2010 -0500
@@ -63,8 +63,8 @@
     var unsigned = findXPI(dpb, "unsigned.xpi");
     var signed = findXPI(dpb, "signed.xpi");
     var untrusted = findXPI(dpb, "signed-untrusted.xpi");
-    var no_o = findXPI(dpb, "signed-no-o.xpi");
-    var no_cn = findXPI(dpb, "signed-no-cn.xpi");
+    var no_o = findXPI(dpb, "signed-no-o@tests.mozilla.org.xpi");
+    var no_cn = findXPI(dpb, "signed-no-cn@tests.mozilla.org.jar");
 
     // Test the names and certs are correct
     do_check_eq(dpb.GetString(unsigned), "XPI Test");
@@ -126,8 +126,8 @@
   do_get_file("data/signed.xpi").copyTo(il, null);
   do_get_file("data/signed-untrusted.xpi").copyTo(il, null);
   do_get_file("data/signed-tampered.xpi").copyTo(il, null);
-  do_get_file("data/signed-no-o.xpi").copyTo(il, null);
-  do_get_file("data/signed-no-cn.xpi").copyTo(il, null);
+  do_get_file("data/signed-no-o.xpi").copyTo(il, "signed-no-o@tests.mozilla.org.xpi");
+  do_get_file("data/signed-no-cn.xpi").copyTo(il, "signed-no-cn@tests.mozilla.org.jar");
 
   // Starting the EM will detect and attempt to install the xpis
   startupEM();
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/mozapps/update/src/nsUpdateService.js.in
--- a/toolkit/mozapps/update/src/nsUpdateService.js.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/mozapps/update/src/nsUpdateService.js.in	Thu Dec 02 20:33:03 2010 -0500
@@ -166,8 +166,13 @@
   let macutils = Cc["@mozilla.org/xpcom/mac-utils;1"].
                  getService(Ci.nsIMacUtils);
 
+  // Provide the info to determine whether the system is running ppc or i386 so
+  // it is possible to provide updates to Mozilla 2.0 for users running i386. On
+  // 1.9.2 we only supported ppc and i386 universal binaries so hardcode the
+  // second half of what app update reports as the ABI if the user is running a
+  // universal binary.
   if (macutils.isUniversalBinary)
-    abi = "Universal-gcc3";
+    abi += "-u-ppc-i386";
 #endif
   return abi;
 });
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/mozapps/update/src/updater/updater.cpp
--- a/toolkit/mozapps/update/src/updater/updater.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/mozapps/update/src/updater/updater.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -82,6 +82,9 @@
 #else
 # include <sys/wait.h>
 # include <unistd.h>
+#ifdef XP_MACOSX
+# include <sys/time.h>
+#endif
 
 # define NS_T(str) str
 # define NS_tsnprintf snprintf
@@ -1383,10 +1386,30 @@
     gArchiveReader.Close();
   }
 
-  if (rv)
+  if (rv) {
     LOG(("failed: %d\n", rv));
-  else
+  }
+  else {
+#ifdef XP_MACOSX
+    // If the update was successful we need to update the timestamp
+    // on the top-level Mac OS X bundle directory so that Mac OS X's
+    // Launch Services picks up any major changes. Here we assume that
+    // the current working directory is the top-level bundle directory.
+    char* cwd = getcwd(NULL, 0);
+    if (cwd) {
+      if (utimes(cwd, NULL) != 0) {
+        LOG(("Couldn't set access/modification time on application bundle.\n"));
+      }
+      free(cwd);
+    }
+    else {
+      LOG(("Couldn't get current working directory for setting "
+           "access/modification time on application bundle.\n"));
+    }
+#endif
     LOG(("succeeded\n"));
+  }
+
   WriteStatusFile(rv);
 
   LOG(("calling QuitProgressUI\n"));
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/mozapps/update/test/unit/test_0040_general.js
--- a/toolkit/mozapps/update/test/unit/test_0040_general.js	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/mozapps/update/test/unit/test_0040_general.js	Thu Dec 02 20:33:03 2010 -0500
@@ -140,7 +140,7 @@
                    getService(AUS_Ci.nsIMacUtils);
 
     if (macutils.isUniversalBinary)
-      abi = "Universal-gcc3";
+      abi += "-u-ppc-i386";
   }
 
   do_check_eq(getResult(gRequestURL), gAppInfo.OS + "_" + abi);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 toolkit/system/gnome/Makefile.in
--- a/toolkit/system/gnome/Makefile.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/toolkit/system/gnome/Makefile.in	Thu Dec 02 20:33:03 2010 -0500
@@ -89,6 +89,7 @@
 include $(topsrcdir)/config/rules.mk
 
 CXXFLAGS += \
+	$(MOZ_GTK2_CFLAGS) \
 	$(MOZ_GCONF_CFLAGS) \
 	$(MOZ_GNOMEVFS_CFLAGS) \
 	$(GLIB_CFLAGS) \
diff -r 8fe44c79dfd1 -r 0c159bd1d600 tools/update-packaging/unwrap_full_update.sh
--- a/tools/update-packaging/unwrap_full_update.sh	Tue Oct 26 19:49:55 2010 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,56 +0,0 @@
-#!/bin/bash
-#
-# This tool unpacks a full update package generated by make_full_update.sh
-# Author: Darin Fisher
-#
-
-# -----------------------------------------------------------------------------
-# By default just assume that these tools exist on our path
-MAR=${MAR:-mar}
-BZIP2=${BZIP2:-bzip2}
-
-# -----------------------------------------------------------------------------
-#
-print_usage() {
-  echo "Usage: $(basename $0) [OPTIONS] ARCHIVE"
-}
-
-if [ $# = 0 ]; then
-  print_usage
-  exit 1
-fi
-
-if [ $1 = -h ]; then
-  print_usage
-  echo ""
-  echo "The contents of ARCHIVE will be unpacked into the current directory."
-  echo ""
-  echo "Options:"
-  echo "  -h  show this help text"
-  echo ""
-  exit 1
-fi
-
-# -----------------------------------------------------------------------------
-
-archive="$1"
-
-# Generate a list of all files in the archive.
-files=($($MAR -t "$archive" | cut -d'	' -f3))
-
-# Extract the files, creating subdirectories.  The resulting files are bzip2
-# compressed, so we need to walk the list of files, and decompress them.
-$MAR -x "$archive"
-
-num_files=${#files[*]}
-
-# Skip first "file" since it is actually the column header string "NAME" that
-# does not correspond to an actual file in the archive.
-for ((i=1; $i<$num_files; i=$i+1)); do
-  eval "f=${files[$i]}"
-
-  echo "  decompressing $f"
-
-  mv -f "$f" "$f.bz2"
-  $BZIP2 -d "$f.bz2"
-done
diff -r 8fe44c79dfd1 -r 0c159bd1d600 widget/src/cocoa/nsChildView.h
--- a/widget/src/cocoa/nsChildView.h	Tue Oct 26 19:49:55 2010 -0700
+++ b/widget/src/cocoa/nsChildView.h	Thu Dec 02 20:33:03 2010 -0500
@@ -244,23 +244,24 @@
   static PRBool IsComposing() { return sComposingView ? PR_TRUE : PR_FALSE; }
   static PRBool IsIMEEnabled() { return sIsIMEEnabled; }
   static PRBool IgnoreCommit() { return sIgnoreCommit; }
-
-  static void OnDestroyView(NSView<mozView>* aDestroyingView);
+  // returns nsIWidget::IME_STATUS_*
+  static PRUint32 GetIMEEnabled() { return sIMEEnabledStatus; }
 
   // Note that we cannot get the actual state in TSM. But we can trust this
   // value. Because nsIMEStateManager reset this at every focus changing.
   // XXX If plug-ins changed that, we cannot return correct state.
   static PRBool IsRomanKeyboardsOnly() { return sIsRomanKeyboardsOnly; }
 
+  static void OnDestroyView(NSView<mozView>* aDestroyingView);
+
   static PRBool GetIMEOpenState();
 
   static void InitTSMDocument(NSView<mozView>* aViewForCaret);
   static void StartComposing(NSView<mozView>* aComposingView);
   static void UpdateComposing(NSString* aComposingString);
   static void EndComposing();
-  static void EnableIME(PRBool aEnable);
   static void SetIMEOpenState(PRBool aOpen);
-  static void SetRomanKeyboardsOnly(PRBool aRomanOnly);
+  static nsresult SetIMEEnabled(PRUint32 aEnabled);
 
   static void CommitIME();
   static void CancelIME();
@@ -274,10 +275,14 @@
   static TSMDocumentID sDocumentID;
   static NSString* sComposingString;
   static nsITimer* sSyncKeyScriptTimer;
+  static PRUint32 sIMEEnabledStatus; // nsIWidget::IME_STATUS_*
 
   static void KillComposing();
   static void CallKeyScriptAPI();
   static void SyncKeyScript(nsITimer* aTimer, void* aClosure);
+
+  static void EnableIME(PRBool aEnable);
+  static void SetRomanKeyboardsOnly(PRBool aRomanOnly);
 };
 
 //-------------------------------------------------------------------------
diff -r 8fe44c79dfd1 -r 0c159bd1d600 widget/src/cocoa/nsChildView.mm
--- a/widget/src/cocoa/nsChildView.mm	Tue Oct 26 19:49:55 2010 -0700
+++ b/widget/src/cocoa/nsChildView.mm	Thu Dec 02 20:33:03 2010 -0500
@@ -136,6 +136,7 @@
 TSMDocumentID nsTSMManager::sDocumentID = nsnull;
 NSString* nsTSMManager::sComposingString = nsnull;
 nsITimer* nsTSMManager::sSyncKeyScriptTimer = nsnull;
+PRUint32 nsTSMManager::sIMEEnabledStatus = nsIWidget::IME_STATUS_ENABLED;
 
 static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
 static NSView* sLastViewEntered = nil;
@@ -2008,24 +2009,7 @@
   NSLog(@"**** SetIMEEnabled aState = %d", aState);
 #endif
 
-  switch (aState) {
-    case nsIWidget::IME_STATUS_ENABLED:
-    case nsIWidget::IME_STATUS_PLUGIN:
-      nsTSMManager::SetRomanKeyboardsOnly(PR_FALSE);
-      nsTSMManager::EnableIME(PR_TRUE);
-      break;
-    case nsIWidget::IME_STATUS_DISABLED:
-      nsTSMManager::SetRomanKeyboardsOnly(PR_FALSE);
-      nsTSMManager::EnableIME(PR_FALSE);
-      break;
-    case nsIWidget::IME_STATUS_PASSWORD:
-      nsTSMManager::SetRomanKeyboardsOnly(PR_TRUE);
-      nsTSMManager::EnableIME(PR_FALSE);
-      break;
-    default:
-      NS_ERROR("not implemented!");
-  }
-  return NS_OK;
+  return nsTSMManager::SetIMEEnabled(aState);
 }
 
 NS_IMETHODIMP nsChildView::GetIMEEnabled(PRUint32* aState)
@@ -2034,12 +2018,7 @@
   NSLog(@"**** GetIMEEnabled");
 #endif
 
-  if (nsTSMManager::IsIMEEnabled())
-    *aState = nsIWidget::IME_STATUS_ENABLED;
-  else if (nsTSMManager::IsRomanKeyboardsOnly())
-    *aState = nsIWidget::IME_STATUS_PASSWORD;
-  else
-    *aState = nsIWidget::IME_STATUS_DISABLED;
+  *aState = nsTSMManager::GetIMEEnabled();
   return NS_OK;
 }
 
@@ -6348,12 +6327,42 @@
   KeyScript(aOpen ? smKeySwapScript : smKeyRoman);
 }
 
+nsresult
+nsTSMManager::SetIMEEnabled(PRUint32 aEnabled)
+{
+  switch (aEnabled) {
+    case nsIWidget::IME_STATUS_ENABLED:
+    case nsIWidget::IME_STATUS_PLUGIN:
+      SetRomanKeyboardsOnly(PR_FALSE);
+      EnableIME(PR_TRUE);
+      break;
+    case nsIWidget::IME_STATUS_DISABLED:
+      SetRomanKeyboardsOnly(PR_FALSE);
+      EnableIME(PR_FALSE);
+      break;
+    case nsIWidget::IME_STATUS_PASSWORD:
+      SetRomanKeyboardsOnly(PR_TRUE);
+      EnableIME(PR_FALSE);
+      break;
+    default:
+      NS_ERROR("not implemented!");
+      return NS_ERROR_UNEXPECTED;
+  }
+  sIMEEnabledStatus = aEnabled;
+  return NS_OK;
+}
+
 #define ENABLE_ROMAN_KYBDS_ONLY -23
 void
 nsTSMManager::SetRomanKeyboardsOnly(PRBool aRomanOnly)
 {
   CommitIME();
 
+  if (sIMEEnabledStatus != nsIWidget::IME_STATUS_PLUGIN &&
+      sIsRomanKeyboardsOnly == aRomanOnly) {
+    return;
+  }
+
   sIsRomanKeyboardsOnly = aRomanOnly;
   CallKeyScriptAPI();
 }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 xpcom/glue/nsTextFormatter.cpp
--- a/xpcom/glue/nsTextFormatter.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/xpcom/glue/nsTextFormatter.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1188,6 +1188,9 @@
 static int
 StringStuff(SprintfState* ss, const PRUnichar* sp, PRUint32 len)
 {
+    if (*sp == '\0')
+      return 0;
+
     ptrdiff_t off = ss->cur - ss->base;
     
     nsAString* str = static_cast<nsAString*>(ss->stuffclosure);
diff -r 8fe44c79dfd1 -r 0c159bd1d600 xpcom/io/nsDirectoryService.cpp
--- a/xpcom/io/nsDirectoryService.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/xpcom/io/nsDirectoryService.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -174,8 +174,10 @@
                     printf("nsDirectoryService - CurrentProcessDir is: %s\n", buffer);
 #endif
                     rv = localFile->InitWithNativePath(nsDependentCString(buffer));
-                    if (NS_SUCCEEDED(rv))
+                    if (NS_SUCCEEDED(rv)) {
+                        localFile->Normalize();
                         *aFile = localFile;
+                    }
                 }
                 CFRelease(parentURL);
             }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp
--- a/xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/xpcom/reflect/xptinfo/src/xptiInterfaceInfoManager.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -629,16 +629,17 @@
         NS_ASSERTION(count, "broken search path! bad count");
         for(PRUint32 i = 0; i < count; i++)
         {
-            nsCOMPtr<nsIFile> current;
+            nsCOMPtr<nsIFile> current, normalized;
             aSearchPath->QueryElementAt(i, NS_GET_IID(nsIFile), 
                                         getter_AddRefs(current));
             NS_ASSERTION(current, "broken search path! bad element");
             // nsIFile::Equals basically compares path strings so normalize
             // before the comparison.
             parent->Normalize();
-            current->Normalize();
+            current->Clone(getter_AddRefs(normalized));
+            normalized->Normalize();
             PRBool same;
-            if (NS_SUCCEEDED(parent->Equals(current, &same)) && same)
+            if (NS_SUCCEEDED(parent->Equals(normalized, &same)) && same)
                 return (int) i;
         }
     }
diff -r 8fe44c79dfd1 -r 0c159bd1d600 xpfe/components/intl/nsCharsetMenu.cpp
--- a/xpfe/components/intl/nsCharsetMenu.cpp	Tue Oct 26 19:49:55 2010 -0700
+++ b/xpfe/components/intl/nsCharsetMenu.cpp	Thu Dec 02 20:33:03 2010 -0500
@@ -1253,6 +1253,10 @@
 
   nsresult res = NS_OK;
 
+  // remove charsets "not for browser"
+  res = RemoveFlaggedCharsets(aDecs, NS_LITERAL_STRING(".notForBrowser"));
+  if (NS_FAILED(res)) return res;
+
   nsCOMPtr<nsIRDFContainer> container1;
   nsCOMPtr<nsIRDFContainer> container2;
   nsCOMPtr<nsIRDFContainer> container3;
diff -r 8fe44c79dfd1 -r 0c159bd1d600 xulrunner/installer/mozilla-plugin.pc.in
--- a/xulrunner/installer/mozilla-plugin.pc.in	Tue Oct 26 19:49:55 2010 -0700
+++ b/xulrunner/installer/mozilla-plugin.pc.in	Thu Dec 02 20:33:03 2010 -0500
@@ -5,5 +5,5 @@
 Name: Mozilla Plug-In API
 Description: Mozilla Plug-In API
 Version: %MOZILLA_VERSION%
-Cflags: -I${includedir}/stable -DXP_UNIX %ojidef%
+Cflags: -I${includedir} -DXP_UNIX %ojidef%
 
