diff --git a/Makefile.am b/Makefile.am
index cda6437..7e34571 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,20 +1,21 @@
-SUBDIRS = marshallers
-
-SUBDIRS += \
-	   libnm-util \
-	   libnm-glib \
-	   src \
-	   include \
-	   introspection \
-	   callouts \
-	   system-settings \
-	   tools \
-	   policy \
-	   initscript \
-	   test \
-	   po \
-	   man \
-	   docs
+SUBDIRS = \
+	marshallers \
+	libnm-util \
+	libnm-glib \
+	src \
+	include \
+	introspection \
+	callouts \
+	system-settings \
+	cli \
+	tools \
+	policy \
+	initscript \
+	test \
+	po \
+	man \
+	docs \
+	examples
 
 EXTRA_DIST = \
 	CONTRIBUTING \
diff --git a/autogen.sh b/autogen.sh
index 7454373..213fb08 100755
diff --git a/cli/Makefile.am b/cli/Makefile.am
new file mode 100644
index 0000000..f268924
--- /dev/null
+++ b/cli/Makefile.am
@@ -0,0 +1,2 @@
+SUBDIRS = src
+
diff --git a/cli/src/Makefile.am b/cli/src/Makefile.am
new file mode 100644
index 0000000..2a1bd12
--- /dev/null
+++ b/cli/src/Makefile.am
@@ -0,0 +1,36 @@
+bin_PROGRAMS = \
+	nmcli
+
+INCLUDES = \
+	-I${top_srcdir} \
+	-I${top_srcdir}/include \
+	-I${top_builddir}/marshallers \
+	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/libnm-glib
+
+nmcli_SOURCES = \
+	connections.c \
+	connections.h \
+	devices.c \
+	devices.h \
+	network-manager.c \
+	network-manager.h \
+	nmcli.c \
+	nmcli.h \
+	utils.c \
+	utils.h
+
+nmcli_CPPFLAGS = \
+	$(DBUS_CFLAGS) \
+	$(GLIB_CFLAGS) \
+	-DNMCLI_LOCALEDIR=\"$(datadir)/locale\" \
+	-DG_DISABLE_DEPRECATED
+
+nmcli_LDADD = \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS) \
+	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/libnm-util/libnm-util.la \
+	$(top_builddir)/libnm-glib/libnm-glib.la
+
+
diff --git a/cli/src/connections.c b/cli/src/connections.c
new file mode 100644
index 0000000..ae09fe0
--- /dev/null
+++ b/cli/src/connections.c
@@ -0,0 +1,1261 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <signal.h>
+#include <netinet/ether.h>
+
+#include <nm-client.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-wired.h>
+#include <nm-setting-pppoe.h>
+#include <nm-setting-wireless.h>
+#include <nm-setting-gsm.h>
+#include <nm-setting-cdma.h>
+#include <nm-setting-bluetooth.h>
+#include <nm-setting-olpc-mesh.h>
+#include <nm-device-ethernet.h>
+#include <nm-device-wifi.h>
+#include <nm-gsm-device.h>
+#include <nm-cdma-device.h>
+#include <nm-device-bt.h>
+//#include <nm-device-olpc-mesh.h>
+#include <nm-remote-settings.h>
+#include <nm-remote-settings-system.h>
+#include <nm-settings-interface.h>
+#include <nm-settings-connection-interface.h>
+#include <nm-vpn-connection.h>
+
+#include "utils.h"
+#include "connections.h"
+
+
+typedef struct {
+	NmCli *nmc;
+	int argc;
+	char **argv;
+} ArgsInfo;
+
+extern GMainLoop *loop;   /* glib main loop variable */
+
+static ArgsInfo args_info;
+
+/* static function prototypes */
+static void usage (void);
+static void quit (void);
+static void show_connection (NMConnection *data, gpointer user_data);
+static NMConnection *find_connection (GSList *list, const char *filter_type, const char *filter_val);
+static gboolean find_device_for_connection (NmCli *nmc, NMConnection *connection, const char *iface, const char *ap,
+                                            NMDevice **device, const char **spec_object, GError **error);
+static const char *active_connection_state_to_string (NMActiveConnectionState state);
+static void active_connection_state_cb (NMActiveConnection *active, GParamSpec *pspec, gpointer user_data);
+static void activate_connection_cb (gpointer user_data, const char *path, GError *error);
+static void get_connections_cb (NMSettingsInterface *settings, gpointer user_data);
+static NMCResultCode do_connections_list (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_connections_status (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_connection_up (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_connection_down (NmCli *nmc, int argc, char **argv);
+
+static void
+usage (void)
+{
+	fprintf (stderr,
+	 	 _("Usage: nmcli con { COMMAND | help }\n"
+		 "  COMMAND := { list | status | up | down }\n\n"
+		 "  list [id <id> | uuid <id> | system | user]\n"
+		 "  status\n"
+		 "  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout <timeout>]\n"
+		 "  down id <id> | uuid <id>\n"));
+}
+
+/* quit main loop */
+static void
+quit (void)
+{
+	g_main_loop_quit (loop);  /* quit main loop */
+}
+
+static void
+show_connection (NMConnection *data, gpointer user_data)
+{
+	NMConnection *connection = (NMConnection *) data;
+	NMSettingConnection *s_con;
+	const char *id;
+	const char *uuid;
+	const char *con_type;
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	if (s_con) {
+		id = nm_setting_connection_get_id (s_con);
+		uuid = nm_setting_connection_get_uuid (s_con);
+		con_type = nm_setting_connection_get_connection_type (s_con);
+		print_table_line (0, con_type, 17, uuid, 38, id, 0, NULL);
+	}
+}
+
+static NMConnection *
+find_connection (GSList *list, const char *filter_type, const char *filter_val)
+{
+	NMSettingConnection *s_con;
+	NMConnection *connection;
+	GSList *iterator;
+	const char *id;
+	const char *uuid;
+
+	iterator = list;
+	while (iterator) {
+		connection = NM_CONNECTION (iterator->data);
+		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+		if (s_con) {
+			id = nm_setting_connection_get_id (s_con);
+			uuid = nm_setting_connection_get_uuid (s_con);
+			if (filter_type) {
+				if ((strcmp (filter_type, "id") == 0 && strcmp (filter_val, id) == 0) ||
+				    (strcmp (filter_type, "uuid") == 0 && strcmp (filter_val, uuid) == 0)) {
+					return connection;
+				}
+			}
+		}
+		iterator = g_slist_next (iterator);
+	}
+
+	return NULL;
+}
+
+static NMCResultCode
+do_connections_list (NmCli *nmc, int argc, char **argv)
+{
+	gboolean valid_param_specified = FALSE;
+
+	nmc->should_wait = FALSE;
+
+	if (argc == 0) {
+		valid_param_specified = TRUE;
+		if (nmc->print_output == NMC_PRINT_PRETTY)
+			print_table_header (_("Connections"), _("Type"), 17, _("UUID"), 38, _("Name"), 20, NULL);
+		else if (nmc->print_output == NMC_PRINT_NORMAL)
+			print_table_line (0, _("Type"), 17, _("UUID"), 38, _("Name"), 0, NULL);
+
+		if (nmc->print_output > NMC_PRINT_TERSE)
+			printf (_("System connections:\n"));
+		g_slist_foreach (nmc->system_connections, (GFunc) show_connection, NULL);
+
+		if (nmc->print_output > NMC_PRINT_TERSE)
+			printf (_("User connections:\n"));
+		g_slist_foreach (nmc->user_connections, (GFunc) show_connection, NULL);
+	}
+	else {
+		while (argc > 0) {
+			if (strcmp (*argv, "id") == 0 || strcmp (*argv, "uuid") == 0) {
+				const char *selector = *argv;
+				NMConnection *con1;
+				NMConnection *con2;
+
+				if (next_arg (&argc, &argv) != 0) {
+					g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+					goto error;
+				}
+				valid_param_specified = TRUE;
+
+				con1 = find_connection (nmc->system_connections, selector, *argv);
+				con2 = find_connection (nmc->user_connections, selector, *argv);
+				if (con1) nm_connection_dump (con1);
+				if (con2) nm_connection_dump (con2);
+				if (!con1 && !con2) {
+					g_string_printf (nmc->return_text, _("Error: %s - no such connection."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				}
+			}
+			else if (strcmp (*argv, "system") == 0) {
+				valid_param_specified = TRUE;
+				if (nmc->print_output == NMC_PRINT_PRETTY)
+					print_table_header (_("System-wide connections"), _("Type"), 17, _("UUID"), 38, _("Name"), 20, NULL);
+				else if (nmc->print_output == NMC_PRINT_NORMAL)
+					print_table_line (0, _("Type"), 17, _("UUID"), 38, _("Name"), 0, NULL);
+
+				g_slist_foreach (nmc->system_connections, (GFunc) show_connection, NULL);
+			}
+			else if (strcmp (*argv, "user") == 0) {
+				valid_param_specified = TRUE;
+				if (nmc->print_output == NMC_PRINT_PRETTY)
+					print_table_header (_("User connections"), _("Type"), 17, _("UUID"), 38, _("Name"), 20, NULL);
+				else if (nmc->print_output == NMC_PRINT_NORMAL)
+					print_table_line (0, _("Type"), 17, _("UUID"), 38, _("Name"), 0, NULL);
+
+				g_slist_foreach (nmc->user_connections, (GFunc) show_connection, NULL);
+			}
+			else {
+				fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+			}
+
+			argc--;
+			argv++;
+		}
+	}
+
+	if (!valid_param_specified) {
+		g_string_printf (nmc->return_text, _("Error: no valid parameter specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+	}
+
+error:
+	return nmc->return_value;
+}
+
+static void
+show_active_connection (gpointer data, gpointer user_data)
+{
+	NMActiveConnection *active = NM_ACTIVE_CONNECTION (data);
+	GSList *con_list = (GSList *) user_data;
+	GSList *iter;
+	const char *active_path;
+	NMConnectionScope active_service_scope;
+	NMSettingConnection *s_con;
+	const GPtrArray *devices;
+	GString *dev_str;
+	int i;
+
+	dev_str = g_string_new (NULL);
+
+	active_path = nm_active_connection_get_connection (active);
+	active_service_scope = nm_active_connection_get_scope (active);
+
+	/* Get devices of the active connection */
+	devices = nm_active_connection_get_devices (active);
+	for (i = 0; devices && (i < devices->len); i++) {
+		NMDevice *device = g_ptr_array_index (devices, i);
+
+		g_string_append (dev_str, nm_device_get_iface (device));
+		g_string_append_c (dev_str, ',');
+	}
+	if (dev_str->len > 0)
+		g_string_truncate (dev_str, dev_str->len - 1);  /* Cut off last ',' */
+
+	for (iter = con_list; iter; iter = g_slist_next (iter)) {
+		NMConnection *connection = (NMConnection *) iter->data;
+		const char *con_path = nm_connection_get_path (connection);
+		NMConnectionScope con_scope = nm_connection_get_scope (connection);
+
+		if (!strcmp (active_path, con_path) && active_service_scope == con_scope) {
+			/* this connection is active */
+			s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+			g_assert (s_con != NULL);
+			// FIXME: Fix the output
+			print_table_line (0, nm_active_connection_get_default (active) ? _("yes") : _("no"), 8,
+			                     nm_active_connection_get_service_name (active), 45,
+//			                     nm_active_connection_get_specific_object (active), 0,
+//			                     nm_active_connection_get_connection (active), 0,
+			                     dev_str->str, 10,
+			                     nm_setting_connection_get_uuid (s_con), 38,
+			                     nm_setting_connection_get_id (s_con), 0, NULL);
+
+		}
+	}
+
+	g_string_free (dev_str, TRUE);
+}
+
+static NMCResultCode
+do_connections_status (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *active_cons;
+
+	nmc->should_wait = FALSE;
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		return nmc->return_value;
+
+	active_cons = nm_client_get_active_connections (nmc->client);
+
+	// FIXME: Fix the output
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("Active connections"), _("Default"), 8, _("Service"), 45, _("Devices"), 10, _("UUID"), 38, _("Name"), 20, NULL);
+	else if (nmc->print_output == NMC_PRINT_NORMAL)
+		print_table_line (0, _("Default"), 8, _("Service"), 45, _("Devices"), 10, _("UUID"), 38, _("Name"), 0, NULL);
+
+	if (active_cons && active_cons->len) {
+		g_ptr_array_foreach ((GPtrArray *) active_cons, show_active_connection, (gpointer) nmc->system_connections);
+		g_ptr_array_foreach ((GPtrArray *) active_cons, show_active_connection, (gpointer) nmc->user_connections);
+	}
+
+	return NMC_RESULT_SUCCESS;
+}
+
+/* --------------------
+ * These function should be moved to libnm-glib in the end.
+ */
+static gboolean
+check_ethernet_compatible (NMDeviceEthernet *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	const char *connection_type;
+	gboolean is_pppoe = FALSE;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	connection_type = nm_setting_connection_get_connection_type (s_con);
+	if (   strcmp (connection_type, NM_SETTING_WIRED_SETTING_NAME)
+	    && strcmp (connection_type, NM_SETTING_PPPOE_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a wired or PPPoE connection.");
+		return FALSE;
+	}
+
+	if (!strcmp (connection_type, NM_SETTING_PPPOE_SETTING_NAME))
+		is_pppoe = TRUE;
+
+	s_wired = (NMSettingWired *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED);
+	/* Wired setting is optional for PPPoE */
+	if (!is_pppoe && !s_wired) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid wired connection.");
+		return FALSE;
+	}
+
+	if (s_wired) {
+		const GByteArray *mac;
+		const char *device_mac_str;
+		struct ether_addr *device_mac;
+
+		device_mac_str = nm_device_ethernet_get_hw_address (device);
+		device_mac = ether_aton (device_mac_str);
+		if (!device_mac) {
+			g_set_error (error, 0, 0, "Invalid device MAC address.");
+			return FALSE;
+		}
+
+		mac = nm_setting_wired_get_mac_address (s_wired);
+		if (mac && memcmp (mac->data, device_mac->ether_addr_octet, ETH_ALEN)) {
+			g_set_error (error, 0, 0,
+			             "The connection's MAC address did not match this device.");
+			return FALSE;
+		}
+	}
+
+	// FIXME: check bitrate against device capabilities
+
+	return TRUE;
+}
+
+static gboolean
+check_wifi_compatible (NMDeviceWifi *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_WIRELESS_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a WiFi connection.");
+		return FALSE;
+	}
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	if (!s_wireless) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid WiFi connection.");
+		return FALSE;
+	}
+
+	if (s_wireless) {
+		const GByteArray *mac;
+		const char *device_mac_str;
+		struct ether_addr *device_mac;
+
+		device_mac_str = nm_device_wifi_get_hw_address (device);
+		device_mac = ether_aton (device_mac_str);
+		if (!device_mac) {
+			g_set_error (error, 0, 0, "Invalid device MAC address.");
+			return FALSE;
+		}
+
+		mac = nm_setting_wireless_get_mac_address (s_wireless);
+		if (mac && memcmp (mac->data, device_mac->ether_addr_octet, ETH_ALEN)) {
+			g_set_error (error, 0, 0,
+		        	     "The connection's MAC address did not match this device.");
+			return FALSE;
+		}
+	}
+
+	// FIXME: check channel/freq/band against bands the hardware supports
+	// FIXME: check encryption against device capabilities
+	// FIXME: check bitrate against device capabilities
+
+	return TRUE;
+}
+
+static gboolean
+check_bt_compatible (NMDeviceBt *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingBluetooth *s_bt;
+	const GByteArray *array;
+	char *str;
+	const char *device_hw_str;
+	int addr_match = FALSE;
+	const char *bt_type_str;
+	guint32 bt_type, bt_capab;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_BLUETOOTH_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a Bluetooth connection.");
+		return FALSE;
+	}
+
+	s_bt = NM_SETTING_BLUETOOTH (nm_connection_get_setting (connection, NM_TYPE_SETTING_BLUETOOTH));
+	if (!s_bt) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid Bluetooth connection.");
+		return FALSE;
+	}
+
+	array = nm_setting_bluetooth_get_bdaddr (s_bt);
+	if (!array || (array->len != ETH_ALEN)) {
+		g_set_error (error, 0, 0,
+		             "The connection did not contain a valid Bluetooth address.");
+		return FALSE;
+	}
+
+	bt_type_str = nm_setting_bluetooth_get_connection_type (s_bt);
+	g_assert (bt_type_str);
+
+	bt_type = NM_BT_CAPABILITY_NONE;
+	if (!strcmp (bt_type_str, NM_SETTING_BLUETOOTH_TYPE_DUN))
+		bt_type = NM_BT_CAPABILITY_DUN;
+	else if (!strcmp (bt_type_str, NM_SETTING_BLUETOOTH_TYPE_PANU))
+		bt_type = NM_BT_CAPABILITY_NAP;
+
+	bt_capab = nm_device_bt_get_capabilities (device);
+	if (!(bt_type & bt_capab)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not compatible with the device's capabilities.");
+		return FALSE;
+	}
+
+	device_hw_str = nm_device_bt_get_hw_address (device);
+
+	str = g_strdup_printf ("%02X:%02X:%02X:%02X:%02X:%02X",
+	                       array->data[0], array->data[1], array->data[2],
+	                       array->data[3], array->data[4], array->data[5]);
+	addr_match = !strcmp (device_hw_str, str);
+	g_free (str);
+
+	return addr_match;
+}
+
+#if 0
+static gboolean
+check_olpc_mesh_compatible (NMDeviceOlpcMesh *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingOlpcMesh *s_mesh;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_OLPC_MESH_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a Mesh connection.");
+		return FALSE;
+	}
+
+	s_mesh = NM_SETTING_OLPC_MESH (nm_connection_get_setting (connection, NM_TYPE_SETTING_OLPC_MESH));
+	if (!s_mesh) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid Mesh connection.");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+#endif
+
+static gboolean
+nm_device_is_connection_compatible (NMDevice *device, NMConnection *connection, GError **error)
+{
+	g_return_val_if_fail (NM_IS_DEVICE (device), FALSE);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
+
+	if (NM_IS_DEVICE_ETHERNET (device))
+		return check_ethernet_compatible (NM_DEVICE_ETHERNET (device), connection, error);
+	else if (NM_IS_DEVICE_WIFI (device))
+		return check_wifi_compatible (NM_DEVICE_WIFI (device), connection, error);
+	else if (NM_IS_DEVICE_BT (device))
+		return check_bt_compatible (NM_DEVICE_BT (device), connection, error);
+//	else if (NM_IS_DEVICE_OLPC_MESH (device))
+//		return check_olpc_mesh_compatible (NM_DEVICE_OLPC_MESH (device), connection, error);
+
+	g_set_error (error, 0, 0, "unhandled device type '%s'", G_OBJECT_TYPE_NAME (device));
+	return FALSE;
+}
+
+
+/**
+ * nm_client_get_active_connection_by_path:
+ * @client: a #NMClient
+ * @object_path: the object path to search for
+ *
+ * Gets a #NMActiveConnection from a #NMClient.
+ *
+ * Returns: the #NMActiveConnection for the given @object_path or %NULL if none is found.
+ **/
+static NMActiveConnection *
+nm_client_get_active_connection_by_path (NMClient *client, const char *object_path)
+{
+	const GPtrArray *actives;
+	int i;
+	NMActiveConnection *active = NULL;
+
+	g_return_val_if_fail (NM_IS_CLIENT (client), NULL);
+	g_return_val_if_fail (object_path, NULL);
+
+	actives = nm_client_get_active_connections (client);
+	if (!actives)
+		return NULL;
+
+	for (i = 0; i < actives->len; i++) {
+		NMActiveConnection *candidate = g_ptr_array_index (actives, i);
+		if (!strcmp (nm_object_get_path (NM_OBJECT (candidate)), object_path)) {
+			active = candidate;
+			break;
+		}
+	}
+
+	return active;
+}
+/* -------------------- */
+
+static NMActiveConnection *
+get_default_active_connection (NmCli *nmc, NMDevice **device)
+{
+	NMActiveConnection *default_ac = NULL;
+	NMDevice *non_default_device = NULL;
+	NMActiveConnection *non_default_ac = NULL;
+	const GPtrArray *connections;
+	int i;
+
+	g_return_val_if_fail (nmc != NULL, NULL);
+	g_return_val_if_fail (device != NULL, NULL);
+	g_return_val_if_fail (*device == NULL, NULL);
+
+	connections = nm_client_get_active_connections (nmc->client);
+	for (i = 0; connections && (i < connections->len); i++) {
+		NMActiveConnection *candidate = g_ptr_array_index (connections, i);
+		const GPtrArray *devices;
+
+		devices = nm_active_connection_get_devices (candidate);
+		if (!devices || !devices->len)
+			continue;
+
+		if (nm_active_connection_get_default (candidate)) {
+			if (!default_ac) {
+				*device = g_ptr_array_index (devices, 0);
+				default_ac = candidate;
+			}
+		} else {
+			if (!non_default_ac) {
+				non_default_device = g_ptr_array_index (devices, 0);
+				non_default_ac = candidate;
+			}
+		}
+	}
+
+	/* Prefer the default connection if one exists, otherwise return the first
+	 * non-default connection.
+	 */
+	if (!default_ac && non_default_ac) {
+		default_ac = non_default_ac;
+		*device = non_default_device;
+	}
+	return default_ac;
+}
+
+/* Find a device to activate the connection on.
+ * IN:  connection:  connection to activate
+ *      iface:       device interface name to use (optional)
+ *      ap:          access point to use (optional; valid just for 802-11-wireless)
+ * OUT: device:      found device
+ *      spec_object: specific_object path of NMAccessPoint
+ * RETURNS: TRUE when a device is found, FALSE otherwise.
+ */
+static gboolean
+find_device_for_connection (NmCli *nmc, NMConnection *connection, const char *iface, const char *ap,
+                            NMDevice **device, const char **spec_object, GError **error)
+{
+	NMSettingConnection *s_con;
+	const char *con_type;
+	int i, j;
+
+	g_return_val_if_fail (nmc != NULL, FALSE);
+	g_return_val_if_fail (device != NULL && *device == NULL, FALSE);
+	g_return_val_if_fail (spec_object != NULL && *spec_object == NULL, FALSE);
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_assert (s_con);
+	con_type = nm_setting_connection_get_connection_type (s_con);
+
+	if (strcmp (con_type, "vpn") == 0) {
+		/* VPN connections */
+		NMActiveConnection *active = NULL;
+		if (iface) {
+			const GPtrArray *connections = nm_client_get_active_connections (nmc->client);
+			for (i = 0; connections && (i < connections->len) && !active; i++) {
+				NMActiveConnection *candidate = g_ptr_array_index (connections, i);
+				const GPtrArray *devices = nm_active_connection_get_devices (candidate);
+				if (!devices || !devices->len)
+					continue;
+
+				for (j = 0; devices && (j < devices->len); j++) {
+					NMDevice *dev = g_ptr_array_index (devices, j);
+					if (!strcmp (iface, nm_device_get_iface (dev))) {
+						active = candidate;
+						*device = dev;
+						break;
+					}
+				}
+			}
+			if (!active) {
+				g_set_error (error, 0, 0, _("no active connection on device '%s'"), iface);
+				return FALSE;
+			}
+			*spec_object = nm_object_get_path (NM_OBJECT (active));
+			return TRUE;
+		} else {
+			active = get_default_active_connection (nmc, device);
+			if (!active) {
+				g_set_error (error, 0, 0, _("no active connection or device"));
+				return FALSE;
+			}
+			*spec_object = nm_object_get_path (NM_OBJECT (active));
+			return TRUE;
+		}
+	} else {
+		/* Other connections */
+		NMDevice *found_device = NULL;
+		const GPtrArray *devices = nm_client_get_devices (nmc->client);
+
+		for (i = 0; devices && (i < devices->len) && !found_device; i++) {
+			NMDevice *dev = g_ptr_array_index (devices, i);
+
+			if (iface) {
+				const char *dev_iface = nm_device_get_iface (dev);
+				if (   !strcmp (dev_iface, iface)
+				    && nm_device_is_connection_compatible (dev, connection, NULL)) {
+					found_device = dev;
+				}
+			} else {
+				if (nm_device_is_connection_compatible (dev, connection, NULL)) {
+					found_device = dev;
+				}
+			}
+
+			if (found_device && ap && !strcmp (con_type, "802-11-wireless") && NM_IS_DEVICE_WIFI (dev)) {
+				char *hwaddr_up = g_ascii_strup (ap, -1);
+				const GPtrArray *aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (dev));
+				found_device = NULL;  /* Mark as not found; set to the device again later, only if AP matches */
+
+				for (j = 0; aps && (j < aps->len); j++) {
+					NMAccessPoint *candidate_ap = g_ptr_array_index (aps, j);
+					const char *candidate_hwaddr = nm_access_point_get_hw_address (candidate_ap);
+
+					if (!strcmp (hwaddr_up, candidate_hwaddr)) {
+						found_device = dev;
+						*spec_object = nm_object_get_path (NM_OBJECT (candidate_ap));
+						break;
+					}
+				}
+				g_free (hwaddr_up);
+			}
+		}
+
+		if (found_device) {
+			*device = found_device;
+			return TRUE;
+		} else {
+			if (iface)
+				g_set_error (error, 0, 0, "device '%s' not compatible with connection '%s'", iface, nm_setting_connection_get_id (s_con));
+			else
+				g_set_error (error, 0, 0, "no device found for connection '%s'", nm_setting_connection_get_id (s_con));
+			return FALSE;
+		}
+	}
+}
+
+static const char *
+active_connection_state_to_string (NMActiveConnectionState state)
+{
+	switch (state) {
+	case NM_ACTIVE_CONNECTION_STATE_ACTIVATING:
+		return _("activating");
+	case NM_ACTIVE_CONNECTION_STATE_ACTIVATED:
+		return _("activated");
+	case NM_ACTIVE_CONNECTION_STATE_UNKNOWN:
+	default:
+		return _("unknown");
+	}
+}
+
+static const char *
+vpn_connection_state_to_string (NMVPNConnectionState state)
+{
+	switch (state) {
+	case NM_VPN_CONNECTION_STATE_PREPARE:
+		return _("VPN connecting (prepare)");
+	case NM_VPN_CONNECTION_STATE_NEED_AUTH:
+		return _("VPN connecting (need authentication)");
+	case NM_VPN_CONNECTION_STATE_CONNECT:
+		return _("VPN connecting");
+	case NM_VPN_CONNECTION_STATE_IP_CONFIG_GET:
+		return _("VPN connecting (getting IP configuration)");
+	case NM_VPN_CONNECTION_STATE_ACTIVATED:
+		return _("VPN connected");
+	case NM_VPN_CONNECTION_STATE_FAILED:
+		return _("VPN connection failed");
+	case NM_VPN_CONNECTION_STATE_DISCONNECTED:
+		return _("VPN disconnected");
+	default:
+		return _("unknown");
+	}
+}
+
+static const char *
+vpn_connection_state_reason_to_string (NMVPNConnectionStateReason reason)
+{
+	switch (reason) {
+	case NM_VPN_CONNECTION_STATE_REASON_UNKNOWN:
+		return _("unknown reason");
+	case NM_VPN_CONNECTION_STATE_REASON_NONE:
+		return _("none");
+	case NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED:
+		return _("the user was disconnected");
+	case NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED:
+		return _("the base network connection was interrupted");
+	case NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED:
+		return _("the VPN service stopped unexpectedly");
+	case NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID:
+		return _("the VPN service returned invalid configuration");
+	case NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT:
+		return _("the connection attempt timed out");
+	case NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT:
+		return _("the VPN service did not start in time");
+	case NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED:
+		return _("the VPN service failed to start");
+	case NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS:
+		return _("no valid VPN secrets");
+	case NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED:
+		return _("invalid VPN secrets");
+	case NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED:
+		return _("the connection was removed");
+	default:
+		return _("unknown");
+	}
+}
+
+static void
+active_connection_state_cb (NMActiveConnection *active, GParamSpec *pspec, gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMActiveConnectionState state;
+
+	state = nm_active_connection_get_state (active);
+
+	printf (_("state: %s\n"), active_connection_state_to_string (state));
+
+	if (state == NM_ACTIVE_CONNECTION_STATE_ACTIVATED) {
+		printf (_("Connection activated\n"));
+		quit ();
+	} else if (state == NM_ACTIVE_CONNECTION_STATE_UNKNOWN) { 
+		g_string_printf (nmc->return_text, _("Error: Connection activation failed."));
+		nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		quit ();
+	}
+}
+
+static void
+vpn_connection_state_cb (NMVPNConnection *vpn,
+                         NMVPNConnectionState state,
+                         NMVPNConnectionStateReason reason,
+                         gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+
+	switch (state) {
+	case NM_VPN_CONNECTION_STATE_PREPARE:
+	case NM_VPN_CONNECTION_STATE_NEED_AUTH:
+	case NM_VPN_CONNECTION_STATE_CONNECT:
+	case NM_VPN_CONNECTION_STATE_IP_CONFIG_GET:
+		printf (_("state: %s (%d)\n"), vpn_connection_state_to_string (state), state);
+		break;
+
+	case NM_VPN_CONNECTION_STATE_ACTIVATED:
+		printf (_("Connection activated\n"));
+		quit ();
+		break;
+
+	case NM_VPN_CONNECTION_STATE_FAILED:
+	case NM_VPN_CONNECTION_STATE_DISCONNECTED:
+		g_string_printf (nmc->return_text, _("Error: Connection activation failed: %s."), vpn_connection_state_reason_to_string (reason));
+		nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		quit ();
+		break;
+
+	default:
+		break;
+	}
+}
+
+static gboolean
+timeout_cb (gpointer user_data)
+{
+	/* Time expired -> exit nmcli */
+
+	NmCli *nmc = (NmCli *) user_data;
+
+	g_string_printf (nmc->return_text, _("Error: Timeout %d sec expired."), nmc->timeout);
+	nmc->return_value = NMC_RESULT_ERROR_TIMEOUT_EXPIRED;
+	quit ();
+	return FALSE;
+}
+
+static void
+foo_active_connections_changed_cb (NMClient *client,
+                                   GParamSpec *pspec,
+                                   gpointer user_data)
+{
+	/* Call again activate_connection_cb with dummy arguments;
+	 * the correct ones are taken from its first call.
+	 */
+	activate_connection_cb (NULL, NULL, NULL);
+}
+
+static void
+activate_connection_cb (gpointer user_data, const char *path, GError *error)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMActiveConnection *active;
+	NMActiveConnectionState state;
+	static gulong handler_id = 0;
+	static NmCli *orig_nmc;
+	static const char *orig_path;
+	static GError *orig_error;
+
+	if (nmc)
+	{
+		/* Called first time; store actual arguments */
+		orig_nmc = nmc;
+		orig_path = path;
+		orig_error = error;
+	}
+
+	/* Disconnect the handler not to be run any more */
+	if (handler_id != 0) {
+		g_signal_handler_disconnect (orig_nmc->client, handler_id);
+		handler_id = 0;
+	}
+
+	if (orig_error) {
+		g_string_printf (orig_nmc->return_text, _("Error: Connection activation failed: %s"), orig_error->message);
+		orig_nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		quit ();
+	} else {
+		active = nm_client_get_active_connection_by_path (orig_nmc->client, orig_path);
+		if (!active) {
+			/* The active connection path is not in active connections list yet; wait for active-connections signal. */
+			/* This is basically the case for VPN connections. */
+			if (nmc) {
+				/* Called first time, i.e. by nm_client_activate_connection() */
+				handler_id = g_signal_connect (orig_nmc->client, "notify::active-connections",
+				                               G_CALLBACK (foo_active_connections_changed_cb), NULL);
+				return;
+			} else {
+				g_string_printf (orig_nmc->return_text, _("Error: Obtaining active connection for '%s' failed."), orig_path);
+				orig_nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+				quit ();
+				return;
+			}
+		}
+
+		state = nm_active_connection_get_state (active);
+
+		printf (_("Active connection state: %s\n"), active_connection_state_to_string (state));
+		printf (_("Active connection path: %s\n"), orig_path);
+
+		if (!orig_nmc->should_wait || state == NM_ACTIVE_CONNECTION_STATE_ACTIVATED) {
+			/* don't want to wait or already activated */
+			quit ();
+		} else {
+			if (NM_IS_VPN_CONNECTION (active))
+				g_signal_connect (NM_VPN_CONNECTION (active), "vpn-state-changed", G_CALLBACK (vpn_connection_state_cb), orig_nmc);
+			else
+				g_signal_connect (active, "notify::state", G_CALLBACK (active_connection_state_cb), orig_nmc);
+
+			/* Start timer not to loop forever when signals are not emitted */
+			g_timeout_add_seconds (orig_nmc->timeout, timeout_cb, orig_nmc);
+		}
+	}
+}
+
+static NMCResultCode
+do_connection_up (NmCli *nmc, int argc, char **argv)
+{
+	NMDevice *device = NULL;
+	const char *spec_object = NULL;
+	gboolean device_found;
+	NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	gboolean is_system;
+	const char *con_path;
+	const char *con_type;
+	const char *iface = NULL;
+	const char *ap = NULL;
+	gboolean id_specified = FALSE;
+	gboolean wait = TRUE;
+	GError *error = NULL;
+
+	/* Set default timeout for connection activation. It can take quite a long time.
+	 * Using 90 seconds.
+	 */
+	nmc->timeout = 90;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "id") == 0 || strcmp (*argv, "uuid") == 0) {
+			const char *selector = *argv;
+			id_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			if ((connection = find_connection (nmc->system_connections, selector, *argv)) == NULL)
+				connection = find_connection (nmc->user_connections, selector, *argv);
+
+			if (!connection) {
+				g_string_printf (nmc->return_text, _("Error: Unknown connection: %s."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+		}
+		else if (strcmp (*argv, "iface") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		}
+		else if (strcmp (*argv, "ap") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			ap = *argv;
+		}
+		else if (strcmp (*argv, "--nowait") == 0) {
+			wait = FALSE;
+		} else if (strcmp (*argv, "--timeout") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			errno = 0;
+			nmc->timeout = strtol (*argv, NULL, 10);
+			if (errno || nmc->timeout < 0) {
+				g_string_printf (nmc->return_text, _("Error: timeout value '%s' is not valid."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!id_specified) {
+		g_string_printf (nmc->return_text, _("Error: id or uuid has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	is_system = (nm_connection_get_scope (connection) == NM_CONNECTION_SCOPE_SYSTEM) ? TRUE : FALSE;
+	con_path = nm_connection_get_path (connection);
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_assert (s_con);
+	con_type = nm_setting_connection_get_connection_type (s_con);
+
+	device_found = find_device_for_connection (nmc, connection, iface, ap, &device, &spec_object, &error);
+
+	if (!device_found) {
+		if (error)
+			g_string_printf (nmc->return_text, _("Error: No suitable device found: %s."), error->message);
+		else
+			g_string_printf (nmc->return_text, _("Error: No suitable device found."));
+		nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		goto error;
+	}
+
+	nmc->should_wait = wait;
+	nm_client_activate_connection (nmc->client,
+	                               is_system ? NM_DBUS_SERVICE_SYSTEM_SETTINGS : NM_DBUS_SERVICE_USER_SETTINGS,
+	                               con_path,
+	                               device,
+	                               spec_object,
+	                               activate_connection_cb,
+	                               nmc);
+
+	return nmc->return_value;
+error:
+	nmc->should_wait = FALSE;
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_connection_down (NmCli *nmc, int argc, char **argv)
+{
+	NMConnection *connection = NULL;
+	NMActiveConnection *active = NULL;
+	const GPtrArray *active_cons;
+	const char *con_path;
+	const char *active_path;
+	NMConnectionScope active_service_scope, con_scope;
+	gboolean id_specified = FALSE;
+	gboolean wait = TRUE;
+	int i;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "id") == 0 || strcmp (*argv, "uuid") == 0) {
+			const char *selector = *argv;
+			id_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			if ((connection = find_connection (nmc->system_connections, selector, *argv)) == NULL)
+				connection = find_connection (nmc->user_connections, selector, *argv);
+
+			if (!connection) {
+				g_string_printf (nmc->return_text, _("Error: Unknown connection: %s."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+		}
+		else if (strcmp (*argv, "--nowait") == 0) {
+			wait = FALSE;
+		}
+		else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!id_specified) {
+		g_string_printf (nmc->return_text, _("Error: id or uuid has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	con_path = nm_connection_get_path (connection);
+	con_scope = nm_connection_get_scope (connection);
+
+	active_cons = nm_client_get_active_connections (nmc->client);
+	for (i = 0; active_cons && (i < active_cons->len); i++) {
+		NMActiveConnection *candidate = g_ptr_array_index (active_cons, i);
+
+		active_path = nm_active_connection_get_connection (candidate);
+		active_service_scope = nm_active_connection_get_scope (candidate);
+		if (!strcmp (active_path, con_path) && active_service_scope == con_scope) {
+			active = candidate;
+			break;
+		}
+	}
+
+	if (active)
+		nm_client_deactivate_connection (nmc->client, active);
+	else {
+		fprintf (stderr, _("Warning: Connection not active\n"));
+	}
+
+error:
+	nmc->should_wait = FALSE;
+	return nmc->return_value;
+}
+
+/* callback called when connections are obtained from the settings service */
+static void
+get_connections_cb (NMSettingsInterface *settings, gpointer user_data)
+{
+	ArgsInfo *args = (ArgsInfo *) user_data;
+	static gboolean system_cb_called = FALSE;
+	static gboolean user_cb_called = FALSE;
+
+	if (NM_IS_REMOTE_SETTINGS_SYSTEM (settings)) {
+		system_cb_called = TRUE;
+		args->nmc->system_connections = nm_settings_interface_list_connections (settings);
+	}
+	else {
+		user_cb_called = TRUE;
+		args->nmc->user_connections = nm_settings_interface_list_connections (settings);
+	}
+
+	/* return and wait for the callback of the second settings is called */
+	if ((args->nmc->system_settings_running && !system_cb_called) || 
+	    (args->nmc->user_settings_running && !user_cb_called))
+		return;
+
+	if (args->argc == 0) {
+		args->nmc->return_value = do_connections_list (args->nmc, args->argc, args->argv);
+	} else {
+
+	 	if (matches (*args->argv, "list") == 0) {
+			args->nmc->return_value = do_connections_list (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches(*args->argv, "status") == 0) {
+			args->nmc->return_value = do_connections_status (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches(*args->argv, "up") == 0) {
+			args->nmc->return_value = do_connection_up (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches(*args->argv, "down") == 0) {
+			args->nmc->return_value = do_connection_down (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches (*args->argv, "help") == 0) {
+			usage ();
+			args->nmc->should_wait = FALSE;
+		} else {
+			usage ();
+			g_string_printf (args->nmc->return_text, _("Error: 'con' command '%s' is not valid."), *args->argv);
+			args->nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			args->nmc->should_wait = FALSE;
+		}
+	}
+
+	if (!args->nmc->should_wait)
+		quit ();
+}
+
+
+/* Entry point function for connections-related commands: 'nmcli con' */
+NMCResultCode
+do_connections (NmCli *nmc, int argc, char **argv)
+{
+	DBusGConnection *bus;
+	GError *error = NULL;
+
+	nmc->should_wait = TRUE;
+
+	args_info.nmc = nmc;
+	args_info.argc = argc;
+	args_info.argv = argv;
+
+	/* connect to DBus' system bus */
+	bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (error || !bus) {
+		g_string_printf (nmc->return_text, _("Error: could not connect to D-Bus."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+	}
+
+	/* get system settings */
+	if (!(nmc->system_settings = nm_remote_settings_system_new (bus))) {
+		g_string_printf (nmc->return_text, _("Error: Could not get system settings."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+
+	}
+
+	/* get user settings */
+	if (!(nmc->user_settings = nm_remote_settings_new (bus, NM_CONNECTION_SCOPE_USER))) {
+		g_string_printf (nmc->return_text, _("Error: Could not get user settings."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+	}
+
+	/* find out whether setting services are running */
+	g_object_get (nmc->system_settings, NM_REMOTE_SETTINGS_SERVICE_RUNNING, &nmc->system_settings_running, NULL);
+	g_object_get (nmc->user_settings, NM_REMOTE_SETTINGS_SERVICE_RUNNING, &nmc->user_settings_running, NULL);
+
+	if (!nmc->system_settings_running && !nmc->user_settings_running) {
+		g_string_printf (nmc->return_text, _("Error: Can't obtain connections: settings services are not running."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+	}
+
+	/* connect to signal "connections-read" - emitted when connections are fetched and ready */
+	if (nmc->system_settings_running)
+		g_signal_connect (nmc->system_settings, NM_SETTINGS_INTERFACE_CONNECTIONS_READ,
+		                  G_CALLBACK (get_connections_cb), &args_info);
+
+	if (nmc->user_settings_running)
+		g_signal_connect (nmc->user_settings, NM_SETTINGS_INTERFACE_CONNECTIONS_READ,
+		                  G_CALLBACK (get_connections_cb), &args_info);
+
+	dbus_g_connection_unref (bus);
+
+	/* The rest will be done in get_connection_cb() callback.
+	 * We need to wait for signals that connections are read.
+	 */
+	return NMC_RESULT_SUCCESS;
+}
diff --git a/cli/src/connections.h b/cli/src/connections.h
new file mode 100644
index 0000000..a1ed1c1
--- /dev/null
+++ b/cli/src/connections.h
@@ -0,0 +1,27 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_CONNECTIONS_H
+#define NMC_CONNECTIONS_H
+
+#include "nmcli.h"
+
+NMCResultCode do_connections (NmCli *nmc, int argc, char **argv);
+
+#endif /* NMC_CONNECTIONS_H */
diff --git a/cli/src/devices.c b/cli/src/devices.c
new file mode 100644
index 0000000..d6c0b43
--- /dev/null
+++ b/cli/src/devices.c
@@ -0,0 +1,950 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <nm-client.h>
+#include <nm-device-wifi.h>
+
+#include <nm-client.h>
+#include <nm-device.h>
+#include <nm-device-ethernet.h>
+#include <nm-device-wifi.h>
+#include <nm-gsm-device.h>
+#include <nm-cdma-device.h>
+#include <nm-device-bt.h>
+//#include <nm-device-olpc-mesh.h>
+#include <nm-utils.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-vpn-connection.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-wired.h>
+#include <nm-setting-pppoe.h>
+#include <nm-setting-wireless.h>
+#include <nm-setting-gsm.h>
+#include <nm-setting-cdma.h>
+#include <nm-setting-bluetooth.h>
+#include <nm-setting-olpc-mesh.h>
+
+#include "utils.h"
+#include "devices.h"
+
+
+/* static function prototypes */
+static void usage (void);
+static const char *device_state_to_string (NMDeviceState state);
+static NMCResultCode do_devices_status (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_devices_list (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_device_disconnect (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_device_wifi (NmCli *nmc, int argc, char **argv);
+
+
+extern GMainLoop *loop;   /* glib main loop variable */
+
+static void
+usage (void)
+{
+	fprintf (stderr,
+	 	 _("Usage: nmcli dev { COMMAND | help }\n\n"
+		 "  COMMAND := { status | list | disconnect | wifi }\n\n"
+		 "  status\n"
+		 "  list [iface <iface>]\n"
+		 "  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+		 "  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n\n"));
+}
+
+/* quit main loop */
+static void
+quit (void)
+{
+	g_main_loop_quit (loop);  /* quit main loop */
+}
+
+static const char *
+device_state_to_string (NMDeviceState state)
+{
+	switch (state) {
+	case NM_DEVICE_STATE_UNMANAGED:
+		return _("unmanaged");
+	case NM_DEVICE_STATE_UNAVAILABLE:
+		return _("unavailable");
+	case NM_DEVICE_STATE_DISCONNECTED:
+		return _("disconnected");
+	case NM_DEVICE_STATE_PREPARE:
+		return _("connecting (prepare)");
+	case NM_DEVICE_STATE_CONFIG:
+		return _("connecting (configuring)");
+	case NM_DEVICE_STATE_NEED_AUTH:
+		return _("connecting (need authentication)");
+	case NM_DEVICE_STATE_IP_CONFIG:
+		return _("connecting (getting IP configuration)");
+	case NM_DEVICE_STATE_ACTIVATED:
+		return _("connected");
+	case NM_DEVICE_STATE_FAILED:
+		return _("connection failed");
+	default:
+		return _("unknown");
+	}
+}
+
+/* Return device type - use setting names to match with connection types */
+static const char *
+get_device_type (NMDevice * device)
+{
+	if (NM_IS_DEVICE_ETHERNET (device))
+		return NM_SETTING_WIRED_SETTING_NAME;
+	else if (NM_IS_DEVICE_WIFI (device))
+		return NM_SETTING_WIRELESS_SETTING_NAME;
+	else if (NM_IS_GSM_DEVICE (device))
+		return NM_SETTING_GSM_SETTING_NAME;
+	else if (NM_IS_CDMA_DEVICE (device))
+		return NM_SETTING_CDMA_SETTING_NAME;
+	else if (NM_IS_DEVICE_BT (device))
+		return NM_SETTING_BLUETOOTH_SETTING_NAME;
+//	else if (NM_IS_DEVICE_OLPC_MESH (device))
+//		return NM_SETTING_OLPC_MESH_SETTING_NAME;
+	else
+		return _("Unknown");
+}
+
+static char *
+ap_wpa_rsn_flags_to_string (guint32 flags)
+{
+	char *flags_str[16]; /* Enough space for flags and terminating NULL */
+	char *ret_str;
+	int i = 0;
+
+	if (flags & NM_802_11_AP_SEC_PAIR_WEP40)
+		flags_str[i++] = g_strdup ("pair_wpe40");
+	if (flags & NM_802_11_AP_SEC_PAIR_WEP104)
+		flags_str[i++] = g_strdup ("pair_wpe104");
+	if (flags & NM_802_11_AP_SEC_PAIR_TKIP)
+		flags_str[i++] = g_strdup ("pair_tkip");
+	if (flags & NM_802_11_AP_SEC_PAIR_CCMP)
+		flags_str[i++] = g_strdup ("pair_ccmp");
+	if (flags & NM_802_11_AP_SEC_GROUP_WEP40)
+		flags_str[i++] = g_strdup ("group_wpe40");
+	if (flags & NM_802_11_AP_SEC_GROUP_WEP104)
+		flags_str[i++] = g_strdup ("group_wpe104");
+	if (flags & NM_802_11_AP_SEC_GROUP_TKIP)
+		flags_str[i++] = g_strdup ("group_tkip");
+	if (flags & NM_802_11_AP_SEC_GROUP_CCMP)
+		flags_str[i++] = g_strdup ("group_ccmp");
+	if (flags & NM_802_11_AP_SEC_KEY_MGMT_PSK)
+		flags_str[i++] = g_strdup ("psk");
+	if (flags & NM_802_11_AP_SEC_KEY_MGMT_802_1X)
+		flags_str[i++] = g_strdup ("802.1X");
+
+	if (i == 0)
+		flags_str[i++] = g_strdup (_("(none)"));
+
+	flags_str[i] = NULL;
+
+	ret_str = g_strjoinv (" ", flags_str);
+
+	i = 0;
+	while (flags_str[i])
+		 g_free (flags_str[i++]);
+
+	return ret_str;
+}
+
+static void
+print_header (const char *label, const char *iface, const char *connection)
+{
+	GString *string;
+
+	string = g_string_sized_new (79);
+	g_string_append_printf (string, "- %s: ", label);
+	if (iface)
+		g_string_append_printf (string, "%s ", iface);
+	if (connection)
+		g_string_append_printf (string, " [%s] ", connection);
+
+	while (string->len < 80)
+		g_string_append_c (string, '-');
+
+	printf ("%s\n", string->str);
+
+	g_string_free (string, TRUE);
+}
+
+static gchar *
+ip4_address_as_string (guint32 ip)
+{
+	struct in_addr tmp_addr;
+	char buf[INET_ADDRSTRLEN+1];
+
+	memset (&buf, '\0', sizeof (buf));
+	tmp_addr.s_addr = ip;
+
+	if (inet_ntop (AF_INET, &tmp_addr, buf, INET_ADDRSTRLEN)) {
+		return g_strdup (buf);
+	} else {
+		g_warning (_("%s: error converting IP4 address 0x%X"),
+		            __func__, ntohl (tmp_addr.s_addr));
+		return NULL;
+	}
+}
+
+static void
+detail_access_point (gpointer data, gpointer user_data)
+{
+	NMAccessPoint *ap = NM_ACCESS_POINT (data);
+	const char *active_bssid = (const char *) user_data;
+	GString *str;
+	gboolean active = FALSE;
+	guint32 flags, wpa_flags, rsn_flags;
+	const GByteArray * ssid;
+	char *tmp;
+
+	flags = nm_access_point_get_flags (ap);
+	wpa_flags = nm_access_point_get_wpa_flags (ap);
+	rsn_flags = nm_access_point_get_rsn_flags (ap);
+
+	if (active_bssid) {
+		const char *current_bssid = nm_access_point_get_hw_address (ap);
+		if (current_bssid && !strcmp (current_bssid, active_bssid))
+			active = TRUE;
+	}
+
+	str = g_string_new (NULL);
+	g_string_append_printf (str,
+	                        _("%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"),
+	                        (nm_access_point_get_mode (ap) == NM_802_11_MODE_INFRA) ? ("Infra") : _("Ad-Hoc"),
+	                        nm_access_point_get_hw_address (ap),
+	                        nm_access_point_get_frequency (ap),
+	                        nm_access_point_get_max_bitrate (ap) / 1000,
+	                        nm_access_point_get_strength (ap));
+
+	if (   !(flags & NM_802_11_AP_FLAGS_PRIVACY)
+	    &&  (wpa_flags != NM_802_11_AP_SEC_NONE)
+	    &&  (rsn_flags != NM_802_11_AP_SEC_NONE))
+		g_string_append (str, _(", Encrypted: "));
+
+	if (   (flags & NM_802_11_AP_FLAGS_PRIVACY)
+	    && (wpa_flags == NM_802_11_AP_SEC_NONE)
+	    && (rsn_flags == NM_802_11_AP_SEC_NONE))
+		g_string_append (str, _(" WEP"));
+	if (wpa_flags != NM_802_11_AP_SEC_NONE)
+		g_string_append (str, _(" WPA"));
+	if (rsn_flags != NM_802_11_AP_SEC_NONE)
+		g_string_append (str, _(" WPA2"));
+	if (   (wpa_flags & NM_802_11_AP_SEC_KEY_MGMT_802_1X)
+	    || (rsn_flags & NM_802_11_AP_SEC_KEY_MGMT_802_1X))
+		g_string_append (str, _(" Enterprise"));
+
+	/* FIXME: broadcast/hidden */
+
+	ssid = nm_access_point_get_ssid (ap);
+	tmp = g_strdup_printf ("  %s%s", active ? "*" : "",
+	                       ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : _("(none)"));
+
+	print_table_line (0, tmp, 25, str->str, 0, NULL);
+
+	g_string_free (str, TRUE);
+	g_free (tmp);
+}
+
+struct cb_info {
+	NMClient *client;
+	const GPtrArray *active;
+};
+
+static void
+show_device_info (gpointer data, gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (data);
+//	struct cb_info *info = user_data;
+	char *tmp;
+	NMDeviceState state;
+	const char *dev_type;
+	guint32 caps;
+	guint32 speed;
+	const GArray *array;
+	gboolean is_default = FALSE;
+	const char *id = NULL;
+
+	state = nm_device_get_state (device);
+	print_header (_("Device"), nm_device_get_iface (device), id);
+
+	/* General information */
+	dev_type = get_device_type (device);
+	print_table_line (0, _("Type"), 25, dev_type, 0, NULL);
+	print_table_line (0, _("Driver"), 25, nm_device_get_driver (device) ? nm_device_get_driver (device) : _("(unknown)"), 0, NULL);
+	print_table_line (0, _("State"), 25, device_state_to_string (state), 0, NULL);
+	if (is_default)
+		print_table_line (0, _("Default"), 25, _("yes"), 0, NULL);
+	else
+		print_table_line (0, _("Default"), 25, _("no"), 0, NULL);
+
+	tmp = NULL;
+	if (NM_IS_DEVICE_ETHERNET (device))
+		tmp = g_strdup (nm_device_ethernet_get_hw_address (NM_DEVICE_ETHERNET (device)));
+	else if (NM_IS_DEVICE_WIFI (device))
+		tmp = g_strdup (nm_device_wifi_get_hw_address (NM_DEVICE_WIFI (device)));
+
+	if (tmp) {
+		print_table_line (0, _("HW Address"), 25, tmp, 0, NULL);
+		g_free (tmp);
+	}
+
+	/* Capabilities */
+	caps = nm_device_get_capabilities (device);
+	printf (_("\n  Capabilities:\n"));
+	if (caps & NM_DEVICE_CAP_CARRIER_DETECT)
+		print_table_line (2, _("Carrier Detect"), 23, _("yes"), 0, NULL);
+
+	speed = 0;
+	if (NM_IS_DEVICE_ETHERNET (device)) {
+		/* Speed in Mb/s */
+		speed = nm_device_ethernet_get_speed (NM_DEVICE_ETHERNET (device));
+	} else if (NM_IS_DEVICE_WIFI (device)) {
+		/* Speed in b/s */
+		speed = nm_device_wifi_get_bitrate (NM_DEVICE_WIFI (device));
+		speed /= 1000;
+	}
+
+	if (speed) {
+		char *speed_string;
+
+		speed_string = g_strdup_printf (_("%u Mb/s"), speed);
+		print_table_line (2, _("Speed"), 23, speed_string, 0, NULL);
+		g_free (speed_string);
+	}
+
+	/* Wireless specific information */
+	if ((NM_IS_DEVICE_WIFI (device))) {
+		guint32 wcaps;
+		NMAccessPoint *active_ap = NULL;
+		const char *active_bssid = NULL;
+		const GPtrArray *aps;
+
+		printf (_("\n  Wireless Properties\n"));
+
+		wcaps = nm_device_wifi_get_capabilities (NM_DEVICE_WIFI (device));
+
+		if (wcaps & (NM_WIFI_DEVICE_CAP_CIPHER_WEP40 | NM_WIFI_DEVICE_CAP_CIPHER_WEP104))
+			print_table_line (2, _("WEP Encryption"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_WPA)
+			print_table_line (2, _("WPA Encryption"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_RSN)
+			print_table_line (2, _("WPA2 Encryption"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_CIPHER_TKIP)
+			print_table_line (2, _("TKIP cipher"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_CIPHER_CCMP)
+			print_table_line (2, _("CCMP cipher"), 23, _("yes"), 0, NULL);
+
+		if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED) {
+			active_ap = nm_device_wifi_get_active_access_point (NM_DEVICE_WIFI (device));
+			active_bssid = active_ap ? nm_access_point_get_hw_address (active_ap) : NULL;
+		}
+
+		printf (_("\n  Wireless Access Points %s\n"), active_ap ? _("(* = current AP)") : "");
+
+		aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
+		if (aps && aps->len)
+			g_ptr_array_foreach ((GPtrArray *) aps, detail_access_point, (gpointer) active_bssid);
+	} else if (NM_IS_DEVICE_ETHERNET (device)) {
+		printf (_("\n  Wired Properties\n"));
+
+		if (nm_device_ethernet_get_carrier (NM_DEVICE_ETHERNET (device)))
+			print_table_line (2, _("Carrier"), 23, _("on"), 0, NULL);
+		else
+			print_table_line (2, _("Carrier"), 23, _("off"), 0, NULL);
+	}
+
+	/* IP Setup info */
+	if (state == NM_DEVICE_STATE_ACTIVATED) {
+		NMIP4Config *cfg = nm_device_get_ip4_config (device);
+		GSList *iter;
+
+		printf (_("\n  IPv4 Settings:\n"));
+
+		for (iter = (GSList *) nm_ip4_config_get_addresses (cfg); iter; iter = g_slist_next (iter)) {
+			NMIP4Address *addr = (NMIP4Address *) iter->data;
+			guint32 prefix = nm_ip4_address_get_prefix (addr);
+			char *tmp2;
+
+			tmp = ip4_address_as_string (nm_ip4_address_get_address (addr));
+			print_table_line (2, _("Address"), 23, tmp, 0, NULL);
+			g_free (tmp);
+
+			tmp2 = ip4_address_as_string (nm_utils_ip4_prefix_to_netmask (prefix));
+			tmp = g_strdup_printf ("%d (%s)", prefix, tmp2);
+			g_free (tmp2);
+			print_table_line (2, _("Prefix"), 23, tmp, 0, NULL);
+			g_free (tmp);
+
+			tmp = ip4_address_as_string (nm_ip4_address_get_gateway (addr));
+			print_table_line (2, _("Gateway"), 23, tmp, 0, NULL);
+			g_free (tmp);
+			printf ("\n");
+		}
+
+		array = nm_ip4_config_get_nameservers (cfg);
+		if (array) {
+			int i;
+
+			for (i = 0; i < array->len; i++) {
+				tmp = ip4_address_as_string (g_array_index (array, guint32, i));
+				print_table_line (2, _("DNS"), 23, tmp, 0, NULL);
+				g_free (tmp);
+			}
+		}
+	}
+
+	printf ("\n\n");
+}
+
+static void
+show_device_status (NMDevice *device, NmCli *nmc)
+{
+	const char *iface;
+	const char *type;
+	const char *state;
+
+	iface = nm_device_get_iface (device);
+	type = get_device_type (device);
+	state = device_state_to_string (nm_device_get_state (device));
+
+	print_table_line (0, iface, 10, type, 17, state, 0, NULL);
+}
+
+static NMCResultCode
+do_devices_status (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	int i;
+
+	while (argc > 0) {
+		fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		argc--;
+		argv++;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("Status of devices"), _("Device"), 10, _("Type"), 17, _("State"), 12, NULL);
+	else if (nmc->print_output == NMC_PRINT_NORMAL)
+		print_table_line (0, _("Device"), 10, _("Type"), 17, _("State"), 0, NULL);
+
+	for (i = 0; devices && (i < devices->len); i++) {
+		NMDevice *device = g_ptr_array_index (devices, i);
+		show_device_status (device, nmc);
+	}
+
+	return NMC_RESULT_SUCCESS;
+
+error:
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_devices_list (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	NMDevice *device = NULL;
+	const char *iface = NULL;
+	gboolean iface_specified = FALSE;
+	int i;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			iface_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: '%s' argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	if (iface_specified) {
+		for (i = 0; devices && (i < devices->len); i++) {
+			NMDevice *candidate = g_ptr_array_index (devices, i);
+			const char *dev_iface = nm_device_get_iface (candidate);
+
+			if (!strcmp (dev_iface, iface))
+				device = candidate;
+		}
+		if (!device) {
+		 	g_string_printf (nmc->return_text, _("Error: Device '%s' not found."), iface);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			goto error;
+		}
+		show_device_info (device, nmc->client);
+	} else {
+		if (devices)
+			g_ptr_array_foreach ((GPtrArray *) devices, show_device_info, nmc->client);
+	}
+
+error:
+	return nmc->return_value;
+}
+
+static void
+device_state_cb (NMDevice *device, GParamSpec *pspec, gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMDeviceState state;
+
+	state = nm_device_get_state (device);
+
+	if (state == NM_DEVICE_STATE_DISCONNECTED) {
+		g_string_printf (nmc->return_text, _("Success: Device '%s' successfully disconnected."), nm_device_get_iface (device));
+		quit ();
+	}
+}
+
+static gboolean
+timeout_cb (gpointer user_data)
+{
+	/* Time expired -> exit nmcli */
+
+	NmCli *nmc = (NmCli *) user_data;
+
+	g_string_printf (nmc->return_text, _("Error: Timeout %d sec expired."), nmc->timeout);
+	nmc->return_value = NMC_RESULT_ERROR_TIMEOUT_EXPIRED;
+	quit ();
+	return FALSE;
+}
+
+static void
+disconnect_device_cb (NMDevice *device, GError *error, gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMDeviceState state;
+
+	if (error) {
+		g_string_printf (nmc->return_text, _("Error: Device '%s' (%s) disconnecting failed: %s"),
+		                 nm_device_get_iface (device),
+		                 nm_object_get_path (NM_OBJECT (device)),
+		                 error->message ? error->message : _("(unknown)"));
+		nmc->return_value = NMC_RESULT_ERROR_DEV_DISCONNECT;
+		quit ();
+	} else {
+		state = nm_device_get_state (device);
+		printf (_("Device state: %d (%s)\n"), state, device_state_to_string (state));
+
+		if (!nmc->should_wait || state == NM_DEVICE_STATE_DISCONNECTED) {
+			/* Don't want to wait or device already disconnected */
+			quit ();
+		} else {
+			g_signal_connect (device, "notify::state", G_CALLBACK (device_state_cb), nmc);
+			/* Start timer not to loop forever if "notify::state" signal is not issued */
+			g_timeout_add_seconds (nmc->timeout, timeout_cb, nmc);
+		}
+
+	}
+}
+
+static NMCResultCode
+do_device_disconnect (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	NMDevice *device = NULL;
+	const char *iface = NULL;
+	gboolean iface_specified = FALSE;
+	gboolean wait = TRUE;
+	int i;
+
+	/* Set default timeout for disconnect operation */
+	nmc->timeout = 10;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			iface_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		} else if (strcmp (*argv, "--nowait") == 0) {
+			wait = FALSE;
+		} else if (strcmp (*argv, "--timeout") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			errno = 0;
+			nmc->timeout = strtol (*argv, NULL, 10);
+			if (errno || nmc->timeout < 0) {
+				g_string_printf (nmc->return_text, _("Error: timeout value '%s' is not valid."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!iface_specified) {
+		g_string_printf (nmc->return_text, _("Error: iface has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+	for (i = 0; devices && (i < devices->len); i++) {
+		NMDevice *candidate = g_ptr_array_index (devices, i);
+		const char *dev_iface = nm_device_get_iface (candidate);
+
+		if (!strcmp (dev_iface, iface))
+			device = candidate;
+	}
+
+	if (!device) {
+		g_string_printf (nmc->return_text, _("Error: Device '%s' not found."), iface);
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	nmc->should_wait = wait;
+	nm_device_disconnect (device, disconnect_device_cb, nmc);
+
+error:
+	return nmc->return_value;
+}
+
+static void
+show_acces_point_info (NMDevice *device)
+{
+	NMAccessPoint *active_ap = NULL;
+	const char *active_bssid = NULL;
+	const GPtrArray *aps;
+
+	if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED) {
+		active_ap = nm_device_wifi_get_active_access_point (NM_DEVICE_WIFI (device));
+		active_bssid = active_ap ? nm_access_point_get_hw_address (active_ap) : NULL;
+	}
+
+	aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
+	if (aps && aps->len)
+		g_ptr_array_foreach ((GPtrArray *) aps, detail_access_point, (gpointer) active_bssid);
+}
+
+static NMCResultCode
+do_device_wifi_list (NmCli *nmc, int argc, char **argv)
+{
+	//TODO: cleanup
+	const GPtrArray *devices;
+	NMDevice *device = NULL;
+	const char *iface = NULL;
+	gboolean iface_specified = FALSE;
+	int i;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			iface_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	if (iface_specified) {
+		for (i = 0; devices && (i < devices->len); i++) {
+			NMDevice *candidate = g_ptr_array_index (devices, i);
+			const char *dev_iface = nm_device_get_iface (candidate);
+
+			if (!strcmp (dev_iface, iface))
+				device = candidate;
+		}
+
+		if (!device) {
+		 	g_string_printf (nmc->return_text, _("Error: Device '%s' not found."), iface);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			goto error;
+		}
+
+		if ((NM_IS_DEVICE_WIFI (device))) {
+			if (nmc->print_output == NMC_PRINT_PRETTY)
+				print_table_header (_("WiFi scan list"), NULL);
+
+			show_acces_point_info (device);
+		} else {
+		 	g_string_printf (nmc->return_text, _("Error: Device '%s' is not a WiFi device."), iface);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			goto error;
+		}
+	} else {
+		if (nmc->print_output == NMC_PRINT_PRETTY)
+			print_table_header (_("WiFi scan list"), NULL);
+
+		for (i = 0; devices && (i < devices->len); i++) {
+			NMDevice *dev = g_ptr_array_index (devices, i);
+			const char *dev_iface = nm_device_get_iface (dev);
+
+			if ((NM_IS_DEVICE_WIFI (dev))) {
+				if (nmc->print_output > NMC_PRINT_TERSE)
+					print_table_line (0, _("Device:"), 0, dev_iface, 0, NULL);
+
+				show_acces_point_info (dev);
+			}
+		}
+	}
+
+error:
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_device_wifi_apinfo (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	const GPtrArray *aps;
+	NMAccessPoint *ap = NULL;
+	const char *iface = NULL;
+	const char *hwaddr_user = NULL;
+	const char *hwaddr;
+	gboolean stop = FALSE;
+	guint32 flags, wpa_flags, rsn_flags, freq, bitrate;
+	guint8 strength;
+	const GByteArray *ssid; 
+	NM80211Mode mode;
+	char *freq_str, *ssid_str, *bitrate_str, *strength_str, *wpa_flags_str, *rsn_flags_str;
+	int i, j;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+			iface = *argv;
+		} else if (strcmp (*argv, "hwaddr") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+			hwaddr_user = *argv;
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!hwaddr_user) {
+		g_string_printf (nmc->return_text, _("Error: hwaddr has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	for (i = 0; !stop && devices && (i < devices->len); i++) {
+		NMDevice *device = g_ptr_array_index (devices, i);
+		const char *dev_iface = nm_device_get_iface (device);
+
+		if (iface) {
+			if (!strcmp (iface, dev_iface))
+				stop = TRUE;
+			else
+				continue;
+		}
+
+		aps = NULL;
+		if ((NM_IS_DEVICE_WIFI (device)))
+			aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
+		for (j = 0; aps && (j < aps->len); j++) {
+			char *hwaddr_up;
+			NMAccessPoint *candidate_ap = g_ptr_array_index (aps, j);
+			const char *candidate_hwaddr = nm_access_point_get_hw_address (candidate_ap);
+
+			hwaddr_up = g_ascii_strup (hwaddr_user, -1);
+			if (!strcmp (hwaddr_up, candidate_hwaddr))
+				ap = candidate_ap;
+			g_free (hwaddr_up);
+		}
+	}
+
+	if (!ap) {
+	 	g_string_printf (nmc->return_text, _("Error: Access point with hwaddr '%s' not found."), hwaddr_user);
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* get AP properties */
+	flags = nm_access_point_get_flags (ap);
+	wpa_flags = nm_access_point_get_wpa_flags (ap);
+	rsn_flags = nm_access_point_get_rsn_flags (ap);
+	ssid = nm_access_point_get_ssid (ap);
+	hwaddr = nm_access_point_get_hw_address (ap);
+	freq = nm_access_point_get_frequency (ap);
+	mode = nm_access_point_get_mode (ap);
+	bitrate = nm_access_point_get_max_bitrate (ap);
+	strength = nm_access_point_get_strength (ap);
+
+	/* print them */
+	ssid_str = g_strdup_printf ("%s", ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : _("(none)"));
+	freq_str = g_strdup_printf (_("%u MHz"), freq);
+	bitrate_str = g_strdup_printf (_("%u MB/s"), bitrate/1000);
+	strength_str = g_strdup_printf ("%u", strength);
+	wpa_flags_str = ap_wpa_rsn_flags_to_string (wpa_flags);
+	rsn_flags_str = ap_wpa_rsn_flags_to_string (rsn_flags);
+
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("AP parameters"), NULL);
+	else if (nmc->print_output == NMC_PRINT_NORMAL)
+		print_table_line (0, _("AP parameters"), 0, NULL);
+
+	print_table_line (0, _("SSID:"), 25, ssid_str, 0, NULL);
+	print_table_line (0, _("BSSID:"), 25, hwaddr, 0, NULL);
+	print_table_line (0, _("Frequency:"), 25, freq_str, 0, NULL);
+	print_table_line (0, _("Mode:"), 25, mode == NM_802_11_MODE_ADHOC ? _("Ad-hoc") : mode == NM_802_11_MODE_INFRA ? _("Infrastructure") : _("Unknown"), 0, NULL);
+	print_table_line (0, _("Maximal bitrate:"), 25, bitrate_str, 0, NULL);
+	print_table_line (0, _("Strength:"), 25, strength_str, 0, NULL);
+	print_table_line (0, _("Flags:"), 25, flags == NM_802_11_AP_FLAGS_PRIVACY ? _("privacy") : _("(none)"), 0, NULL);
+	print_table_line (0, _("WPA flags:"), 25, wpa_flags_str, 0, NULL);
+	print_table_line (0, _("RSN flags:"), 25, rsn_flags_str, 0, NULL);
+
+	g_free (ssid_str);
+	g_free (freq_str);
+	g_free (bitrate_str);
+	g_free (strength_str);
+	g_free (wpa_flags_str);
+	g_free (rsn_flags_str);
+
+error:
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_device_wifi (NmCli *nmc, int argc, char **argv)
+{
+	if (argc == 0)
+		nmc->return_value = do_device_wifi_list (nmc, argc-1, argv+1);
+	else if (argc > 0) {
+		if (matches (*argv, "list") == 0) {
+			nmc->return_value = do_device_wifi_list (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "apinfo") == 0) {
+			nmc->return_value = do_device_wifi_apinfo (nmc, argc-1, argv+1);
+		}
+		else {
+			g_string_printf (nmc->return_text, _("Error: 'dev wifi' command '%s' is not valid."), *argv);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+	return nmc->return_value;
+}
+
+
+NMCResultCode
+do_devices (NmCli *nmc, int argc, char **argv)
+{
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	if (argc == 0)
+		nmc->return_value = do_devices_status (nmc, argc-1, argv+1);
+
+	if (argc > 0) {
+		if (matches (*argv, "status") == 0) {
+			nmc->return_value = do_devices_status (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "list") == 0) {
+			nmc->return_value = do_devices_list (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "disconnect") == 0) {
+			nmc->return_value = do_device_disconnect (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "wifi") == 0) {
+			nmc->return_value = do_device_wifi (nmc, argc-1, argv+1);
+		}
+		else if (strcmp (*argv, "help") == 0) {
+			usage ();
+		}
+		else {
+			g_string_printf (nmc->return_text, _("Error: 'dev' command '%s' is not valid."), *argv);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+error:
+	return nmc->return_value;
+}
diff --git a/cli/src/devices.h b/cli/src/devices.h
new file mode 100644
index 0000000..152dd20
--- /dev/null
+++ b/cli/src/devices.h
@@ -0,0 +1,27 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_DEVICES_H
+#define NMC_DEVICES_H
+
+#include "nmcli.h"
+
+NMCResultCode do_devices (NmCli *nmc, int argc, char **argv);
+
+#endif /* NMC_DEVICES_H */
diff --git a/cli/src/network-manager.c b/cli/src/network-manager.c
new file mode 100644
index 0000000..b5c3bd5
--- /dev/null
+++ b/cli/src/network-manager.c
@@ -0,0 +1,186 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <nm-client.h>
+#include <nm-setting-connection.h>
+
+#include "utils.h"
+#include "network-manager.h"
+
+
+extern GMainLoop *loop;
+
+/* static function prototypes */
+static void usage (void);
+static void quit (void);
+static const char *nm_state_to_string (NMState state);
+static NMCResultCode show_nm_status (NmCli *nmc);
+
+
+static void
+usage (void)
+{
+	fprintf (stderr,
+	 	 _("Usage: nmcli nm { COMMAND | help }\n\n"
+		 "  COMMAND := { status | sleep | wakeup | wifi | wwan }\n\n"
+		 "  status\n"
+		 "  sleep\n"
+		 "  wakeup\n"
+		 "  wifi [on|off]\n"
+		 "  wwan [on|off]\n\n"));
+}
+
+/* quit main loop */
+static void
+quit (void)
+{
+	g_main_loop_quit (loop);  /* quit main loop */
+}
+
+static const char *
+nm_state_to_string (NMState state)
+{
+	switch (state) {
+	case NM_STATE_ASLEEP:
+		return _("asleep");
+	case NM_STATE_CONNECTING:
+		return _("connecting");
+	case NM_STATE_CONNECTED:
+		return _("connected");
+	case NM_STATE_DISCONNECTED:
+		return _("disconnected");
+	case NM_STATE_UNKNOWN:
+	default:
+		return _("unknown");
+	}
+}
+
+static NMCResultCode
+show_nm_status (NmCli *nmc)
+{
+	gboolean nm_running;
+	NMState state;
+	const char *wireless_hw_enabled_str, *wireless_enabled_str;
+	const char *wwan_hw_enabled_str, *wwan_enabled_str;
+
+	g_return_val_if_fail (nmc->client != NULL, NMC_RESULT_ERROR_UNKNOWN);
+
+	nm_running = nm_client_get_manager_running (nmc->client);
+	state = nm_client_get_state (nmc->client);
+	if (nm_running) {
+		wireless_hw_enabled_str = nm_client_wireless_hardware_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+		wireless_enabled_str = nm_client_wireless_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+		wwan_hw_enabled_str = nm_client_wwan_hardware_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+		wwan_enabled_str = nm_client_wwan_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+	} else {
+		wireless_hw_enabled_str = wireless_enabled_str = wwan_hw_enabled_str = wwan_enabled_str = _("unknown");
+	}
+
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("NetworkManager status"), NULL);
+
+	print_table_line (0, _("NM running:"), 25, nm_running ? _("running") : _("not running"), 0, NULL);
+	print_table_line (0, _("NM state:"), 25, nm_state_to_string (state), 0, NULL);
+	print_table_line (0, _("NM wireless hardware:"), 25, wireless_hw_enabled_str, 0, NULL);
+	print_table_line (0, _("NM wireless:"), 25, wireless_enabled_str, 0, NULL);
+	print_table_line (0, _("NM WWAN hardware:"), 25, wwan_hw_enabled_str, 0, NULL);
+	print_table_line (0, _("NM WWAN:"), 25, wwan_enabled_str, 0, NULL);
+
+	return NMC_RESULT_SUCCESS;
+}
+
+
+/* entry point function for global network manager related commands 'nmcli nm' */
+NMCResultCode
+do_network_manager (NmCli *nmc, int argc, char **argv)
+{
+	gboolean enable_wifi;
+	gboolean enable_wwan;
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto end;
+
+	if (argc == 0) {
+		nmc->return_value = show_nm_status (nmc);
+	}
+
+	if (argc > 0) {
+		if (matches (*argv, "status") == 0) {
+			nmc->return_value = show_nm_status (nmc);
+		}
+		else if (matches (*argv, "sleep") == 0) {
+			nm_client_sleep (nmc->client, TRUE);		
+		}
+		else if (matches (*argv, "wakeup") == 0) {
+			nm_client_sleep (nmc->client, FALSE);
+		}
+		else if (matches (*argv, "wifi") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				/* no argument, show current state */
+				print_table_line (0, _("NM wireless:"), 25, nm_client_wireless_get_enabled (nmc->client) ? _("enabled") : _("disabled"), 0, NULL);
+			} else {
+				if (!strcmp (*argv, "on"))
+					enable_wifi = TRUE;
+				else if (!strcmp (*argv, "off"))
+					enable_wifi = FALSE;
+				else {
+					g_string_printf (nmc->return_text, _("Error: invalid 'wifi' parameter: '%s'."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+					goto end;
+				}
+				nm_client_wireless_set_enabled (nmc->client, enable_wifi);
+			}
+		}
+		else if (matches (*argv, "wwan") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				/* no argument, show current state */
+				print_table_line (0, _("NM WWAN:"), 25, nm_client_wwan_get_enabled (nmc->client) ? _("enabled") : _("disabled"), 0, NULL);
+			} else {
+				if (!strcmp (*argv, "on"))
+					enable_wwan = TRUE;
+				else if (!strcmp (*argv, "off"))
+					enable_wwan = FALSE;
+				else {
+					g_string_printf (nmc->return_text, _("Error: invalid 'wwan' parameter: '%s'."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+					goto end;
+				}
+				nm_client_wwan_set_enabled (nmc->client, enable_wwan);
+			}
+		}
+		else if (strcmp (*argv, "help") == 0) {
+			usage ();
+		}
+		else {
+			g_string_printf (nmc->return_text, _("Error: 'nm' command '%s' is not valid."), *argv);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+end:
+	quit ();
+	return nmc->return_value;
+}
diff --git a/cli/src/network-manager.h b/cli/src/network-manager.h
new file mode 100644
index 0000000..93cc1b0
--- /dev/null
+++ b/cli/src/network-manager.h
@@ -0,0 +1,27 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_NETWORK_MANAGER_H
+#define NMC_NETWORK_MANAGER_H
+
+#include "nmcli.h"
+
+NMCResultCode do_network_manager (NmCli *nmc, int argc, char **argv);
+
+#endif /* NMC_NETWORK_MANAGER_H */
diff --git a/cli/src/nmcli.c b/cli/src/nmcli.c
new file mode 100644
index 0000000..f2ed715
--- /dev/null
+++ b/cli/src/nmcli.c
@@ -0,0 +1,283 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * Jiri Klimes <jklimes@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+/* Generated configuration file */
+#include "config.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <locale.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <nm-client.h>
+#include <nm-setting-connection.h>
+#include <nm-remote-settings.h>
+#include <nm-remote-settings-system.h>
+#include <nm-settings-interface.h>
+#include <nm-settings-connection-interface.h>
+
+#include "nmcli.h"
+#include "utils.h"
+#include "connections.h"
+#include "devices.h"
+#include "network-manager.h"
+
+#define NMCLI_VERSION "0.1"
+
+
+typedef struct {
+	NmCli *nmc;
+	int argc;
+	char **argv;
+} ArgsInfo;
+
+/* --- Global variables --- */
+GMainLoop *loop = NULL;
+
+
+static void
+usage (const char *prog_name)
+{
+	fprintf (stderr,
+	         _("Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n\n"
+	         "OPTIONS\n"
+	         "  -t[erse]    terse output\n"
+	         "  -p[retty]   pretty output\n"
+	         "  -v[ersion]  show program version\n"
+	         "  -h[elp]     print this help\n\n"
+	         "OBJECT\n"
+	         "  nm          NetworkManager status\n"
+	         "  con         NetworkManager connections\n"
+	         "  dev         devices managed by NetworkManager\n\n"),
+	          prog_name);
+}
+
+static NMCResultCode 
+do_help (NmCli *nmc, int argc, char **argv)
+{
+	usage ("nmcli");
+	return NMC_RESULT_SUCCESS;
+}
+
+static const struct cmd {
+	const char *cmd;
+	NMCResultCode (*func) (NmCli *nmc, int argc, char **argv);
+} nmcli_cmds[] = {
+	{ "nm",         do_network_manager },
+	{ "con",        do_connections },
+	{ "dev",        do_devices },
+	{ "help",       do_help },
+	{ 0 }
+};
+
+static NMCResultCode
+do_cmd (NmCli *nmc, const char *argv0, int argc, char **argv)
+{
+	const struct cmd *c;
+
+	for (c = nmcli_cmds; c->cmd; ++c) {
+		if (matches (argv0, c->cmd) == 0)
+			return c->func (nmc, argc-1, argv+1);
+	}
+
+	g_string_printf (nmc->return_text, _("Object '%s' is unknown, try 'nmcli help'."), argv0);
+	nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+	return nmc->return_value;
+}
+
+static NMCResultCode
+parse_command_line (NmCli *nmc, int argc, char **argv)
+{
+	char *base;
+
+	base = strrchr (argv[0], '/');
+	if (base == NULL)
+		base = argv[0];
+	else
+		base++;
+
+	/* parse options */
+	while (argc > 1) {
+		char *opt = argv[1];
+		/* '--' ends options */
+		if (strcmp (opt, "--") == 0) {
+			argc--; argv++;
+			break;
+		}
+		if (opt[0] != '-')
+			break;
+		if (opt[1] == '-')
+			opt++;
+		if (matches (opt, "-terse") == 0) {
+			nmc->print_output = NMC_PRINT_TERSE;
+		} else if (matches (opt, "-pretty") == 0) {
+			nmc->print_output = NMC_PRINT_PRETTY;
+		} else if (matches (opt, "-version") == 0) {
+			printf (_("nmcli tool, version %s\n"), NMCLI_VERSION);
+			return NMC_RESULT_SUCCESS;
+		} else if (matches (opt, "-help") == 0) {
+			usage (base);
+			return NMC_RESULT_SUCCESS;
+		} else {
+			g_string_printf (nmc->return_text, _("Option '%s' is unknown, try 'nmcli -help'."), opt);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			return nmc->return_value;
+		}
+		argc--;
+		argv++;
+	}
+
+	if (argc > 1)
+		return do_cmd (nmc, argv[1], argc-1, argv+1);
+
+	usage (base);
+	return nmc->return_value;
+}
+
+static void
+signal_handler (int signo)
+{
+	if (signo == SIGINT || signo == SIGTERM) {
+		g_message (_("Caught signal %d, shutting down..."), signo);
+		g_main_loop_quit (loop);
+	}
+}
+
+static void
+setup_signals (void)
+{
+	struct sigaction action;
+	sigset_t mask;
+
+	sigemptyset (&mask);
+	action.sa_handler = signal_handler;
+	action.sa_mask = mask;
+	action.sa_flags = 0;
+	sigaction (SIGTERM,  &action, NULL);
+	sigaction (SIGINT,  &action, NULL);
+}
+
+static NMClient *
+nmc_get_client (NmCli *nmc)
+{
+	if (!nmc->client) {
+		nmc->client = nm_client_new ();
+		if (!nmc->client) {
+			g_string_printf (nmc->return_text, _("Error: Could not connect to NetworkManager."));
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+	return nmc->client;
+}
+
+/* Initialize NmCli structure - set default values */
+static void
+nmc_init (NmCli *nmc)
+{
+	nmc->client = NULL;
+	nmc->get_client = &nmc_get_client;
+
+	nmc->return_value = NMC_RESULT_SUCCESS;
+	nmc->return_text = g_string_new (_("Success"));
+
+	nmc->timeout = 10;
+
+	nmc->system_settings = NULL;
+	nmc->user_settings = NULL;
+
+	nmc->system_settings_running = FALSE;
+	nmc->user_settings_running = FALSE;
+
+	nmc->system_connections = NULL;
+	nmc->user_connections = NULL;
+
+	nmc->should_wait = FALSE;
+	nmc->print_output = NMC_PRINT_NORMAL;
+}
+
+static void
+nmc_cleanup (NmCli *nmc)
+{
+	if (nmc->client) g_object_unref (nmc->client);
+
+	g_string_free (nmc->return_text, TRUE);
+
+	if (nmc->system_settings) g_object_unref (nmc->system_settings);
+	if (nmc->user_settings) g_object_unref (nmc->user_settings);
+
+	g_slist_free (nmc->system_connections);
+	g_slist_free (nmc->user_connections);
+}
+
+static gboolean
+start (gpointer data)
+{
+	ArgsInfo *info = (ArgsInfo *) data;
+	info->nmc->return_value = parse_command_line (info->nmc, info->argc, info->argv);
+
+	if (!info->nmc->should_wait)
+		g_main_loop_quit (loop);
+
+	return FALSE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+	NmCli nmc;
+	ArgsInfo args_info = { &nmc, argc, argv };
+
+	/* Set locale to use environment variables */
+	setlocale (LC_ALL, "");
+
+#ifdef GETTEXT_PACKAGE
+	/* Set i18n stuff */
+	bindtextdomain (GETTEXT_PACKAGE, NMCLI_LOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+	textdomain (GETTEXT_PACKAGE);
+#endif
+
+	g_type_init ();
+
+	nmc_init (&nmc);
+	g_idle_add (start, &args_info);
+
+	loop = g_main_loop_new (NULL, FALSE);  /* create main loop */
+	setup_signals ();                      /* setup UNIX signals */
+	g_main_loop_run (loop);                /* run main loop */
+
+	/* Print result descripting text */
+	if (nmc.return_value != NMC_RESULT_SUCCESS) {
+		fprintf (stderr, "%s\n", nmc.return_text->str);
+	}
+
+	g_main_loop_unref (loop);
+	nmc_cleanup (&nmc);
+
+	return nmc.return_value;
+}
diff --git a/cli/src/nmcli.h b/cli/src/nmcli.h
new file mode 100644
index 0000000..2daa415
--- /dev/null
+++ b/cli/src/nmcli.h
@@ -0,0 +1,77 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_NMCLI_H
+#define NMC_NMCLI_H
+
+#include <nm-remote-settings.h>
+#include <nm-remote-settings-system.h>
+
+
+/* nmcli exit codes */
+typedef enum {
+	/* Indicates successful execution */
+	NMC_RESULT_SUCCESS = 0,
+
+	/* Unknown / unspecified error */
+	NMC_RESULT_ERROR_UNKNOWN,
+
+	/* A timeout expired */
+	NMC_RESULT_ERROR_TIMEOUT_EXPIRED,
+
+	/* Error in connection activation */
+	NMC_RESULT_ERROR_CON_ACTIVATION,
+
+	/* Error in connection deactivation */
+	NMC_RESULT_ERROR_CON_DEACTIVATION,
+
+	/* Error in device disconnect */
+	NMC_RESULT_ERROR_DEV_DISCONNECT
+} NMCResultCode;
+
+typedef enum {
+	NMC_PRINT_TERSE = 0,
+	NMC_PRINT_NORMAL,
+	NMC_PRINT_PRETTY
+} NMCPrintOutput;
+
+/* NmCli - main structure */
+typedef struct _NmCli {
+	NMClient *client;
+	NMClient *(*get_client) (struct _NmCli *nmc);
+
+	NMCResultCode return_value;
+	GString *return_text;
+
+	int timeout;
+
+	NMRemoteSettingsSystem *system_settings;
+	NMRemoteSettings *user_settings;
+
+	gboolean system_settings_running;
+	gboolean user_settings_running;
+
+	GSList *system_connections;
+	GSList *user_connections;
+
+	gboolean should_wait;
+	NMCPrintOutput print_output;
+} NmCli;
+
+#endif /* NMC_NMCLI_H */
diff --git a/cli/src/utils.c b/cli/src/utils.c
new file mode 100644
index 0000000..cd99b10
--- /dev/null
+++ b/cli/src/utils.c
@@ -0,0 +1,126 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include "utils.h"
+
+int
+matches (const char *cmd, const char *pattern)
+{
+	int len = strlen (cmd);
+	if (len > strlen (pattern))
+		return -1;
+	return memcmp (pattern, cmd, len);
+}
+
+int
+next_arg (int *argc, char ***argv)
+{
+	if (*argc <= 1) {
+		return -1;
+	}
+	else {
+		(*argc)--;
+		(*argv)++;
+	}
+	return 0;
+}
+
+void
+print_table_header (const char *name, ...)
+{
+	va_list ap;
+	GString *str;
+	char *col, *line = NULL;
+	int col_width, width1, width2, table_width = 0;
+
+	str = g_string_new (NULL);
+
+	va_start (ap, name);
+	while ((col = va_arg (ap, char *)) != NULL) {
+		col_width = va_arg (ap, int);
+		width1 = strlen (col);
+		width2 = g_utf8_strlen (col, -1);  /* Width of the string (in screen colums) */
+		g_string_append_printf (str, "%-*s", col_width + width1 - width2, col);
+		g_string_append_c (str, ' ');  /* Column separator */
+		table_width += col_width + width1 - width2 + 1;
+	}
+	va_end (ap);
+
+	if (table_width <= 0)
+		table_width = g_utf8_strlen (name, -1) + 4;
+
+	/* Print the table header */
+	line = g_strnfill (table_width, '=');
+	printf ("%s\n", line);
+	width1 = strlen (name);
+	width2 = g_utf8_strlen (name, -1);
+	printf ("%*s\n", (table_width + width2)/2 + width1 - width2, name);
+	printf ("%s\n", line);
+	if (str->len > 0) {
+		g_string_truncate (str, str->len-1);  /* Chop off last column separator */
+		printf ("%s\n", str->str);
+		g_free (line);
+		line = g_strnfill (table_width, '-');
+		printf ("%s\n", line);
+	}
+
+	g_free (line);
+	g_string_free (str, TRUE);
+}
+
+void
+print_table_line (int indent, ...)
+{
+	va_list ap;
+	GString *str;
+	char *col, *indent_str;
+	int col_width, width1, width2;
+
+	str = g_string_new (NULL);
+
+	va_start (ap, indent);
+	while ((col = va_arg (ap, char *)) != NULL) {
+		col_width = va_arg (ap, int);
+		width1 = strlen (col);
+		width2 = g_utf8_strlen (col, -1);  /* Width of the string (in screen colums) */
+		g_string_append_printf (str, "%-*s", col_width + width1 - width2, col);
+		g_string_append_c (str, ' ');  /* Column separator */
+	}
+	va_end (ap);
+
+	/* Print the line */
+	if (str->len > 0)
+	{
+		g_string_truncate (str, str->len-1);  /* Chop off last column separator */
+		if (indent > 0) {
+			indent_str = g_strnfill (indent, ' ');
+			g_string_prepend (str,  indent_str);
+			g_free (indent_str);
+		}
+		printf ("%s\n", str->str);
+	}
+
+	g_string_free (str, TRUE);
+}
+
diff --git a/cli/src/utils.h b/cli/src/utils.h
new file mode 100644
index 0000000..468550e
--- /dev/null
+++ b/cli/src/utils.h
@@ -0,0 +1,28 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_UTILS_H
+#define NMC_UTILS_H
+
+int matches (const char *cmd, const char *pattern);
+int next_arg (int *argc, char ***argv);
+void print_table_header (const char *name, ...);
+void print_table_line (int indent, ...);
+
+#endif /* NMC_UTILS_H */
diff --git a/configure.ac b/configure.ac
index 124f47c..adfe67f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -164,6 +164,14 @@ if test x"$with_distro" = xpardus; then
   AC_DEFINE(TARGET_PARDUS, 1, [Define if you have Pardus])
 fi
 
+dnl
+dnl Distribution version string
+dnl
+AC_ARG_WITH(dist-version, AS_HELP_STRING([--with-dist-version=<NM-distribution-version>], [Define the NM's distribution version string]), ac_distver=$withval, ac_distver="")
+if ! test x"$ac_distver" = x""; then
+  AC_DEFINE_UNQUOTED(NM_DIST_VERSION, "$ac_distver", [Define the distribution version string])
+fi
+
 AC_MSG_CHECKING([Linux Wireless Extensions >= 18])
 AC_TRY_COMPILE([#ifndef __user
                 #define __user
@@ -292,67 +300,73 @@ else
 fi
 AC_SUBST(PPPD_PLUGIN_DIR)
 
-# DHCP client
-AC_ARG_WITH([dhcp-client], AS_HELP_STRING([--with-dhcp-client=dhcpcd|dhclient], [path to the chosen dhcp client]))
+# dhclient support
+AC_ARG_WITH([dhclient], AS_HELP_STRING([--with-dhclient=yes|no|path], [Enable dhclient 4.x support]))
 # If a full path is given, use that and do not test if it works or not.
-case "${with_dhcp_client}" in
+case "${with_dhclient}" in
 	/*)
-		DHCP_CLIENT_PATH="${with_dhcp_client}"
-		AC_MSG_NOTICE(using the DHCP client ${DHCP_CLIENT_PATH})
+		DHCLIENT_PATH="${with_dhclient}"
+		AC_MSG_NOTICE(using dhclient at ${DHCLIENT_PATH})
 		;;
-esac
-if test -z "$DHCP_CLIENT_PATH" -a \( -z "$with_dhcp_client" -o x`basename "$with_dhcp_client"` = "xdhclient" \); then
-	# We only work with ISC dhclient - the FreeBSD and OpenBSD derivatives don't have the same userland.
-	AC_MSG_CHECKING(for dhclient)
-	for client in "$with_dhcp_client" /sbin/dhclient /usr/pkg/sbin/dhclient /usr/local/sbin/dhclient; do
-		test -x "$client" || continue
-		case `"$client" --version 2>&1` in
-			"isc-dhclient-"*) DHCP_CLIENT_PATH="$client"; break;;
-		esac
-	done
-	if test -z "$DHCP_CLIENT_PATH"; then
-		AC_MSG_RESULT(no)
-		if test -n "$with_dhcp_client"; then
-			AC_MSG_ERROR([Could not find ISC dhclient])
+	no)	AC_MSG_NOTICE(dhclient support disabled)
+		;;
+	*)
+		AC_MSG_CHECKING(for dhclient)
+		# NM only works with ISC dhclient - other derivatives don't have
+		# the same userland.  NM also requires dhclient 4.x since older
+		# versions do not have IPv6 support.
+		for path in /sbin /usr/sbin /usr/pkg/sbin /usr/local/sbin; do
+			test -x "${path}/dhclient" || continue
+			case `"$path/dhclient" --version 2>&1` in
+				"isc-dhclient-4"*) DHCLIENT_PATH="$path/dhclient"; break;;
+			esac
+		done
+		if test -n "${DHCLIENT_PATH}"; then
+			AC_MSG_RESULT($DHCLIENT_PATH)
+		else
+			AC_MSG_RESULT(no)
 		fi
-	else
-		AC_MSG_RESULT($DHCP_CLIENT_PATH)
-	fi
-fi
-if test -z "$DHCP_CLIENT_PATH" -a \( -z "$with_dhcp_client" -o x`basename "$with_dhcp_client"` = "xdhcpcd" \); then
-	test -n "$DHCP_CLIENT_PATH" && echo bar
-	# We fully work with upstream dhcpcd-4
-	AC_MSG_CHECKING([for dhcpcd])
-	for client in "$with_dhcp_client" /sbin/dhcpcd /usr/pkg/sbin/dhcpcd /usr/local/sbin/dhcpcd; do
-		test -x "$client" || continue
-		case `"$client" --version 2>/dev/null` in
-			"dhcpcd "[123]*);;
-			"dhcpcd "*) DHCP_CLIENT_PATH="$client"; break;;
-		esac
-	done
-	if test -z "$DHCP_CLIENT_PATH"; then
-		AC_MSG_RESULT(no)
-		if test -n "$with_dhcp_client"; then
-			AC_MSG_ERROR([Could not find dhcpcd-4 or newer])
+		;;
+esac
+
+# dhcpcd support
+AC_ARG_WITH([dhcpcd], AS_HELP_STRING([--with-dhcpcd=yes|no|path], [Enable dhcpcd 4.x support]))
+# If a full path is given, use that and do not test if it works or not.
+case "${with_dhcpcd}" in
+	/*)
+		DHCPCD_PATH="${with_dhcpcd}"
+		AC_MSG_NOTICE(using dhcpcd at ${DHCPCD_PATH})
+		;;
+	no)	AC_MSG_NOTICE(dhcpcd support disabled)
+		;;
+	*)
+		AC_MSG_CHECKING(for dhcpcd)
+		# We fully work with upstream dhcpcd-4
+		for path in /sbin /usr/sbin /usr/pkg/sbin /usr/local/sbin; do
+			test -x "${path}/dhclient" || continue
+			case `"$path/dhcpcd" --version 2>/dev/null` in
+				"dhcpcd "[123]*);;
+				"dhcpcd "*) DHCP_CLIENT_PATH="$path/dhcpcd"; break;;
+			esac
+		done
+		if test -n "${DHCPCD_PATH}"; then
+			AC_MSG_RESULT($DHCPCD_PATH)
+		else
+			AC_MSG_RESULT(no)
 		fi
-	else
-		AC_MSG_RESULT($DHCP_CLIENT_PATH)
-	fi
-fi
-if test -z "$DHCP_CLIENT_PATH"; then
+		;;
+esac
+
+if test -z "$DHCPCD_PATH" -a -z "$DHCLIENT_PATH"; then
 	# DHCP clients are not a build time dependency, only runtime.
 	# dhclient has been the longtime default for NM and it's in /sbin
 	# in most distros, so use it.
 	AC_MSG_WARN([Could not find a suitable DHCP client])
-	DHCP_CLIENT_PATH=/sbin/dhclient
+	DHCLIENT_PATH=/sbin/dhclient
 	AC_MSG_WARN([Falling back to ISC dhclient, ${DHCP_CLIENT_PATH}])
 fi
-AC_SUBST(DHCP_CLIENT_PATH)
-DHCP_CLIENT=`basename "$DHCP_CLIENT_PATH"`
-if test "$DHCP_CLIENT" != "dhclient" -a "$DHCP_CLIENT" != "dhcpcd"; then
-	AC_MSG_ERROR([No backend for the DHCP client ${DHCP_CLIENT}])
-fi
-AC_SUBST(DHCP_CLIENT)
+AC_SUBST(DHCLIENT_PATH)
+AC_SUBST(DHCPCD_PATH)
 
 # resolvconf support
 AC_ARG_WITH([resolvconf],
@@ -434,6 +448,7 @@ include/Makefile
 src/Makefile
 src/tests/Makefile
 marshallers/Makefile
+src/logging/Makefile
 src/named-manager/Makefile
 src/vpn-manager/Makefile
 src/dhcp-manager/Makefile
@@ -466,6 +481,8 @@ system-settings/plugins/keyfile/Makefile
 system-settings/plugins/keyfile/io/Makefile
 system-settings/plugins/keyfile/tests/Makefile
 system-settings/plugins/keyfile/tests/keyfiles/Makefile
+cli/Makefile
+cli/src/Makefile
 test/Makefile
 initscript/Makefile
 initscript/RedHat/Makefile
@@ -487,6 +504,8 @@ initscript/Mandriva/networkmanager
 introspection/Makefile
 man/Makefile
 man/NetworkManager.8
+man/NetworkManager.conf.5
+man/nm-system-settings.conf.5
 man/nm-tool.1
 po/Makefile.in
 policy/Makefile
@@ -494,16 +513,31 @@ docs/Makefile
 docs/libnm-glib/Makefile
 docs/libnm-util/Makefile
 NetworkManager.pc
+examples/Makefile
+examples/python/Makefile
 ])
 AC_OUTPUT
 
 echo
-echo Distribution targeting: ${with_distro}
+echo Distribution target: ${with_distro}
 echo 'if this is not correct, please specifiy your distro with --with-distro=DISTRO'
 
+echo 
+
+if test -n "${DHCLIENT_PATH}"; then
+	echo ISC dhclient support: ${DHCLIENT_PATH}
+else
+	echo ISC dhclient support: no
+fi
+
+if test -n "${DHCPCD_PATH}"; then
+	echo dhcpcd support: ${DHCPCD_PATH}
+else
+	echo dhcpcd support: no
+fi
+
 echo
 echo Building documentation: ${with_docs}
-echo
 echo Building tests: ${with_tests}
 echo
 
diff --git a/docs/generate-settings-spec.c b/docs/generate-settings-spec.c
index dd78fc9..d7a391f 100644
--- a/docs/generate-settings-spec.c
+++ b/docs/generate-settings-spec.c
@@ -128,6 +128,7 @@ write_one_setting (FILE *f, SettingNewFunc func)
 		value_desc = g_param_spec_get_blurb (*iter);
 
 		g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (*iter));
+		g_param_value_set_default (*iter, &value);
 		default_value = g_strdup_value_contents (&value);
 		if (default_value && !strcmp (default_value, "NULL")) {
 			g_free (default_value);
diff --git a/docs/libnm-glib/Makefile.am b/docs/libnm-glib/Makefile.am
index 297722a..96ff66e 100644
--- a/docs/libnm-glib/Makefile.am
+++ b/docs/libnm-glib/Makefile.am
@@ -34,23 +34,26 @@ IGNORE_HFILES= \
 	nm-device-private.h \
 	nm-object-cache.h \
 	nm-object-private.h \
+	nm-remote-connection-private.h \
 	nm-types-private.h \
 	nm-access-point-bindings.h \
+	nm-active-connection-bindings.h \
 	nm-client-bindings.h \
 	nm-device-bindings.h \
+	nm-device-bt-bindings.h \
 	nm-device-ethernet-bindings.h \
 	nm-device-wifi-bindings.h \
-	nm-exported-connection-glue.h \
+	nm-dhcp4-config-bindings.h \
+	nm-dhcp6-config-bindings.h \
 	nm-exported-connection-bindings.h \
-	nm-settings-glue.h \
+	nm-exported-connection-glue.h \
+	nm-ip4-config-bindings.h \
+	nm-ip6-config-bindings.h \
 	nm-settings-bindings.h \
+	nm-settings-glue.h \
 	nm-settings-system-bindings.h \
 	nm-vpn-connection-bindings.h \
-	nm-vpn-plugin-glue.h \
-	nm-active-connection-bindings.h \
-	nm-ip4-config-bindings.h \
-	nm-dhcp4-config-bindings.h \
-	nm-ip4-config-bindings.h
+	nm-vpn-plugin-glue.h
 
 # Images to copy into HTML directory.
 HTML_IMAGES = 
diff --git a/docs/libnm-glib/libnm-glib-docs.sgml b/docs/libnm-glib/libnm-glib-docs.sgml
index 8fe5a1d..b4e5dac 100644
--- a/docs/libnm-glib/libnm-glib-docs.sgml
+++ b/docs/libnm-glib/libnm-glib-docs.sgml
@@ -5,35 +5,40 @@
   <bookinfo>
     <title>libnm-glib Reference Manual</title>
     <releaseinfo>
-      for libnm-glib [VERSION]
+      for libnm-glib 0.8
       The latest version of this documentation can be found on-line at
-      <ulink role="online-location" url="http://[SERVER]/libnm-glib/index.html">http://[SERVER]/libnm-glib/</ulink>.
+      <ulink role="online-location" url="http://projects.gnome.org/NetworkManager/developers/libnm-glib/08/">http://projects.gnome.org/NetworkManager/developers/libnm-glib/08/</ulink>.
     </releaseinfo>
   </bookinfo>
 
   <chapter>
-    <title>[Insert title here]</title>
-    <xi:include href="xml/nm-access-point.xml"/>
-    <xi:include href="xml/nm-cdma-device.xml"/>
+    <title>libnm-glib Objects</title>
     <xi:include href="xml/nm-client.xml"/>
-    <xi:include href="xml/nm-gsm-device.xml"/>
+    <xi:include href="xml/nm-active-connection.xml"/>
     <xi:include href="xml/nm-device.xml"/>
+    <xi:include href="xml/nm-device-ethernet.xml"/>
+    <xi:include href="xml/nm-device-wifi.xml"/>
+    <xi:include href="xml/nm-serial-device.xml"/>
+    <xi:include href="xml/nm-gsm-device.xml"/>
+    <xi:include href="xml/nm-cdma-device.xml"/>
+    <xi:include href="xml/nm-device-bt.xml"/>
+    <xi:include href="xml/nm-access-point.xml"/>
     <xi:include href="xml/nm-ip4-config.xml"/>
     <xi:include href="xml/nm-ip6-config.xml"/>
+    <xi:include href="xml/nm-dhcp4-config.xml"/>
+    <xi:include href="xml/nm-dhcp6-config.xml"/>
+    <xi:include href="xml/nm-exported-connection.xml"/>
     <xi:include href="xml/nm-object.xml"/>
-    <xi:include href="xml/nm-settings.xml"/>
+    <xi:include href="xml/nm-remote-connection.xml"/>
+    <xi:include href="xml/nm-remote-settings.xml"/>
+    <xi:include href="xml/nm-remote-settings-system.xml"/>
+    <xi:include href="xml/nm-settings-connection-interface.xml"/>
+    <xi:include href="xml/nm-settings-interface.xml"/>
+    <xi:include href="xml/nm-settings-service.xml"/>
+    <xi:include href="xml/nm-settings-system-interface.xml"/>
+    <xi:include href="xml/nm-types.xml"/>
     <xi:include href="xml/nm-vpn-connection.xml"/>
     <xi:include href="xml/nm-vpn-plugin.xml"/>
-    <xi:include href="xml/nm-dbus-settings-system.xml"/>
-    <xi:include href="xml/nm-active-connection.xml"/>
-    <xi:include href="xml/nm-device-ethernet.xml"/>
-    <xi:include href="xml/nm-device-wifi.xml"/>
-    <xi:include href="xml/nm-dbus-connection.xml"/>
-    <xi:include href="xml/nm-serial-device.xml"/>
-    <xi:include href="xml/nm-dbus-settings.xml"/>
-    <xi:include href="xml/nm-dhcp4-config.xml"/>
     <xi:include href="xml/nm-vpn-plugin-ui-interface.xml"/>
-    <xi:include href="xml/libnm_glib.xml"/>
-    <xi:include href="xml/nm-types.xml"/>
   </chapter>
 </book>
diff --git a/docs/libnm-util/libnm-util-docs.sgml b/docs/libnm-util/libnm-util-docs.sgml
index 3758b6e..78b931d 100644
--- a/docs/libnm-util/libnm-util-docs.sgml
+++ b/docs/libnm-util/libnm-util-docs.sgml
@@ -8,9 +8,9 @@
   <bookinfo>
     <title>libnm-util Reference Manual</title>
     <releaseinfo>
-      for libnm-util [VERSION]
+      for libnm-util 0.8
       The latest version of this documentation can be found on-line at
-      <ulink role="online-location" url="http://[SERVER]/libnm-util/index.html">http://[SERVER]/libnm-util/</ulink>.
+      <ulink role="online-location" url="http://projects.gnome.org/NetworkManager/developers/libnm-util/08/">http://projects.gnome.org/NetworkManager/developers/libnm-util/08/</ulink>.
     </releaseinfo>
   </bookinfo>
 
diff --git a/examples/Makefile.am b/examples/Makefile.am
new file mode 100644
index 0000000..c2ddf78
--- /dev/null
+++ b/examples/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS=python
diff --git a/examples/python/Makefile.am b/examples/python/Makefile.am
new file mode 100644
index 0000000..a64727a
--- /dev/null
+++ b/examples/python/Makefile.am
@@ -0,0 +1,4 @@
+EXTRA_DIST = \
+	nm-state.py \
+	add-system-connection.py
+
diff --git a/examples/python/add-system-connection.py b/examples/python/add-system-connection.py
new file mode 100644
index 0000000..3cf350e
--- /dev/null
+++ b/examples/python/add-system-connection.py
@@ -0,0 +1,48 @@
+#!/bin/env python
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Copyright (C) 2010 Red Hat, Inc.
+#
+
+import dbus
+
+s_wired = dbus.Dictionary({'duplex': 'full'})
+s_con = dbus.Dictionary({
+            'type': '802-3-ethernet',
+            'uuid': '7371bb78-c1f7-42a3-a9db-5b9566e8ca07',
+            'id': 'MyConnection'})
+
+addr1 = dbus.Array([dbus.UInt32(50462986L), dbus.UInt32(0L), dbus.UInt32(16908554L)], signature=dbus.Signature('u'))
+s_ip4 = dbus.Dictionary({
+            'addresses': dbus.Array([addr1], signature=dbus.Signature('au')),
+            'method': 'manual'})
+
+s_ip6 = dbus.Dictionary({'method': 'ignore'})
+
+con = dbus.Dictionary({
+    '802-3-ethernet': s_wired,
+    'connection': s_con,
+    'ipv4': s_ip4,
+    'ipv6': s_ip6})
+
+
+bus = dbus.SystemBus()
+
+proxy = bus.get_object("org.freedesktop.NetworkManagerSystemSettings", "/org/freedesktop/NetworkManagerSettings")
+settings = dbus.Interface(proxy, "org.freedesktop.NetworkManagerSettings")
+
+settings.AddConnection(con)
+
diff --git a/examples/python/nm-state.py b/examples/python/nm-state.py
new file mode 100644
index 0000000..fddd2da
--- /dev/null
+++ b/examples/python/nm-state.py
@@ -0,0 +1,69 @@
+#!/bin/env python
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Copyright (C) 2010 Red Hat, Inc.
+#
+
+import dbus
+
+bus = dbus.SystemBus()
+
+proxy = bus.get_object("org.freedesktop.NetworkManager", "/org/freedesktop/NetworkManager")
+manager = dbus.Interface(proxy, "org.freedesktop.NetworkManager")
+
+# Get device-specific state
+devices = manager.GetDevices()
+for d in devices:
+    dev_proxy = bus.get_object("org.freedesktop.NetworkManager", d)
+    prop_iface = dbus.Interface(dev_proxy, "org.freedesktop.DBus.Properties")
+
+    # Get the device's current state and interface name
+    state = prop_iface.Get("org.freedesktop.NetworkManager.Device", "State")
+    name = prop_iface.Get("org.freedesktop.NetworkManager.Device", "Interface")
+
+    # and print them out
+    if state == 8:   # activated
+        print "Device %s is activated" % name
+    else:
+        print "Device %s is not activated" % name
+
+
+# Get active connection state
+manager_prop_iface = dbus.Interface(proxy, "org.freedesktop.DBus.Properties")
+active = manager_prop_iface.Get("org.freedesktop.NetworkManager", "ActiveConnections")
+for a in active:
+    ac_proxy = bus.get_object("org.freedesktop.NetworkManager", a)
+    prop_iface = dbus.Interface(ac_proxy, "org.freedesktop.DBus.Properties")
+    state = prop_iface.Get("org.freedesktop.NetworkManager.ActiveConnection", "State")
+
+    # Connections in NM are a collection of settings that describe everything
+    # needed to connect to a specific network.  Lets get those details so we
+    # can find the user-readable name of the connection.
+    con_path = prop_iface.Get("org.freedesktop.NetworkManager.ActiveConnection", "Connection")
+    con_service = prop_iface.Get("org.freedesktop.NetworkManager.ActiveConnection", "ServiceName")
+
+    # ask the provider of the connection for its details
+    service_proxy = bus.get_object(con_service, con_path)
+    con_iface = dbus.Interface(service_proxy, "org.freedesktop.NetworkManagerSettings.Connection")
+    con_details = con_iface.GetSettings()
+    con_name = con_details['connection']['id']
+
+    if state == 2:   # activated
+        print "Connection '%s' is activated" % con_name
+    else:
+        print "Connection '%s' is activating" % con_name
+
+
diff --git a/examples/python/vpn.py b/examples/python/vpn.py
new file mode 100644
index 0000000..4b4057f
--- /dev/null
+++ b/examples/python/vpn.py
@@ -0,0 +1,152 @@
+#!/usr/bin/python
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Copyright (C) 2009 Novell, Inc.
+# Copyright (C) 2009 Red Hat, Inc.
+#
+
+# Run this script without any arguments to list the available connection uuids.
+
+# The uuid of the connection to activate
+CONNECTION_UUID="ac6dc9b2-85ef-4311-83d8-add5d7db3f59"
+
+# UID to use. Note that NM only allows the owner of the connection to activate it.
+#UID=1000
+UID=0
+
+import sys
+import os
+import dbus
+from dbus.mainloop.glib import DBusGMainLoop
+import gobject
+
+DBusGMainLoop(set_as_default=True)
+
+def get_connections():
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', '/org/freedesktop/NetworkManagerSettings')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings')
+    return iface.ListConnections()
+
+
+def get_connection_by_uuid(uuid):
+    bus = dbus.SystemBus()
+    for c in get_connections():
+        proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', c)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings.Connection')
+        settings = iface.GetSettings()
+        if settings['connection']['uuid'] == uuid:
+            return c
+
+    return None
+
+
+def list_uuids():
+    bus = dbus.SystemBus()
+    for c in get_connections():
+        proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', c)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings.Connection')
+        settings = iface.GetSettings()
+        conn = settings['connection']
+        print "%s - %s (%s)" % (conn['uuid'], conn['id'], conn['type'])
+
+
+def get_active_connection_path(uuid):
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.DBus.Properties')
+    active_connections = iface.Get('org.freedesktop.NetworkManager', 'ActiveConnections')
+    all_connections = get_connections()
+
+    for a in active_connections:
+        proxy = bus.get_object('org.freedesktop.NetworkManager', a)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.DBus.Properties')
+        path = iface.Get('org.freedesktop.NetworkManager.Connection.Active', 'Connection')
+
+        proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', path)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings.Connection')
+        settings = iface.GetSettings()
+
+        if settings['connection']['uuid'] == uuid:
+            return a
+
+    return None
+
+
+def get_wifi_device_path():
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManager')
+    devices = iface.GetDevices()
+    for d in devices:
+        proxy = bus.get_object('org.freedesktop.NetworkManager', d)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.DBus.Properties')
+        devtype = iface.Get('org.freedesktop.NetworkManager.Device', 'DeviceType')
+        if devtype == 2:
+            return d
+    return None
+
+def activate_connection(connection_path, device_path):
+
+    def reply_handler(opath):
+    	print "Success: device activating"
+        sys.exit(0)
+
+    def error_handler(*args):
+    	print "Error activating device: %s" % args
+        sys.exit(1)
+
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManager')
+    iface.ActivateConnection('org.freedesktop.NetworkManagerUserSettings',
+                             connection_path,
+                             device_path, 
+                             "/",
+                             reply_handler=reply_handler,
+                             error_handler=error_handler)
+
+
+# Change the UID first if required
+if UID != 0:
+    os.setuid(UID)
+
+# Are we configured?
+if not len(CONNECTION_UUID):
+    print "missing connection UUID"
+    sys.exit(0)
+
+connection_path = get_connection_by_uuid(CONNECTION_UUID)
+if not connection_path:
+    # Configured VPN connection is not known to NM, check CONNECTION_UUID.
+    print "couldn't find the connection"
+    sys.exit(1)
+
+device_path = get_wifi_device_path()
+if not device_path:
+    print "no wifi device found"
+    sys.exit(1)
+
+# Is it already activated?
+if get_active_connection_path(CONNECTION_UUID):
+    print "already connected"
+    sys.exit(0)
+
+print "Activating connection..."
+activate_connection(connection_path, device_path)
+loop = gobject.MainLoop()
+loop.run()
+
diff --git a/include/NetworkManager.h b/include/NetworkManager.h
index c8d5074..9df444f 100644
--- a/include/NetworkManager.h
+++ b/include/NetworkManager.h
@@ -42,6 +42,7 @@
 #define NM_DBUS_INTERFACE_IP4_CONFIG        NM_DBUS_INTERFACE ".IP4Config"
 #define NM_DBUS_INTERFACE_DHCP4_CONFIG      NM_DBUS_INTERFACE ".DHCP4Config"
 #define NM_DBUS_INTERFACE_IP6_CONFIG        NM_DBUS_INTERFACE ".IP6Config"
+#define NM_DBUS_INTERFACE_DHCP6_CONFIG      NM_DBUS_INTERFACE ".DHCP6Config"
 
 
 #define NM_DBUS_SERVICE_USER_SETTINGS     "org.freedesktop.NetworkManagerUserSettings"
@@ -240,130 +241,136 @@ typedef enum {
 	NM_DEVICE_STATE_REASON_NONE = 0,
 
 	/* Unknown error */
-	NM_DEVICE_STATE_REASON_UNKNOWN,
+	NM_DEVICE_STATE_REASON_UNKNOWN = 1,
 
 	/* Device is now managed */
-	NM_DEVICE_STATE_REASON_NOW_MANAGED,
+	NM_DEVICE_STATE_REASON_NOW_MANAGED = 2,
 
 	/* Device is now managed unmanaged */
-	NM_DEVICE_STATE_REASON_NOW_UNMANAGED,
+	NM_DEVICE_STATE_REASON_NOW_UNMANAGED = 3,
 
 	/* The device could not be readied for configuration */
-	NM_DEVICE_STATE_REASON_CONFIG_FAILED,
+	NM_DEVICE_STATE_REASON_CONFIG_FAILED = 4,
 
 	/* IP configuration could not be reserved (no available address, timeout, etc) */
-	NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE,
+	NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE = 5,
 
 	/* The IP config is no longer valid */
-	NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED,
+	NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED = 6,
 
 	/* Secrets were required, but not provided */
-	NM_DEVICE_STATE_REASON_NO_SECRETS,
+	NM_DEVICE_STATE_REASON_NO_SECRETS = 7,
 
 	/* 802.1x supplicant disconnected */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT = 8,
 
 	/* 802.1x supplicant configuration failed */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED = 9,
 
 	/* 802.1x supplicant failed */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED = 10,
 
 	/* 802.1x supplicant took too long to authenticate */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT = 11,
 
 	/* PPP service failed to start */
-	NM_DEVICE_STATE_REASON_PPP_START_FAILED,
+	NM_DEVICE_STATE_REASON_PPP_START_FAILED = 12,
 
 	/* PPP service disconnected */
-	NM_DEVICE_STATE_REASON_PPP_DISCONNECT,
+	NM_DEVICE_STATE_REASON_PPP_DISCONNECT = 13,
 
 	/* PPP failed */
-	NM_DEVICE_STATE_REASON_PPP_FAILED,
+	NM_DEVICE_STATE_REASON_PPP_FAILED = 14,
 
 	/* DHCP client failed to start */
-	NM_DEVICE_STATE_REASON_DHCP_START_FAILED,
+	NM_DEVICE_STATE_REASON_DHCP_START_FAILED = 15,
 
 	/* DHCP client error */
-	NM_DEVICE_STATE_REASON_DHCP_ERROR,
+	NM_DEVICE_STATE_REASON_DHCP_ERROR = 16,
 
 	/* DHCP client failed */
-	NM_DEVICE_STATE_REASON_DHCP_FAILED,
+	NM_DEVICE_STATE_REASON_DHCP_FAILED = 17,
 
 	/* Shared connection service failed to start */
-	NM_DEVICE_STATE_REASON_SHARED_START_FAILED,
+	NM_DEVICE_STATE_REASON_SHARED_START_FAILED = 18,
 
 	/* Shared connection service failed */
-	NM_DEVICE_STATE_REASON_SHARED_FAILED,
+	NM_DEVICE_STATE_REASON_SHARED_FAILED = 19,
 
 	/* AutoIP service failed to start */
-	NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED,
+	NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED = 20,
 
 	/* AutoIP service error */
-	NM_DEVICE_STATE_REASON_AUTOIP_ERROR,
+	NM_DEVICE_STATE_REASON_AUTOIP_ERROR = 21,
 
 	/* AutoIP service failed */
-	NM_DEVICE_STATE_REASON_AUTOIP_FAILED,
+	NM_DEVICE_STATE_REASON_AUTOIP_FAILED = 22,
 
 	/* The line is busy */
-	NM_DEVICE_STATE_REASON_MODEM_BUSY,
+	NM_DEVICE_STATE_REASON_MODEM_BUSY = 23,
 
 	/* No dial tone */
-	NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE,
+	NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE = 24,
 
 	/* No carrier could be established */
-	NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER,
+	NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER = 25,
 
 	/* The dialing request timed out */
-	NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT,
+	NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT = 26,
 
 	/* The dialing attempt failed */
-	NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED,
+	NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED = 27,
 
 	/* Modem initialization failed */
-	NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED,
+	NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED = 28,
 
 	/* Failed to select the specified APN */
-	NM_DEVICE_STATE_REASON_GSM_APN_FAILED,
+	NM_DEVICE_STATE_REASON_GSM_APN_FAILED = 29,
 
 	/* Not searching for networks */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING = 30,
 
 	/* Network registration denied */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED = 31,
 
 	/* Network registration timed out */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT = 32,
 
 	/* Failed to register with the requested network */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED = 33,
 
 	/* PIN check failed */
-	NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED,
+	NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED = 34,
 
 	/* Necessary firmware for the device may be missing */
-	NM_DEVICE_STATE_REASON_FIRMWARE_MISSING,
+	NM_DEVICE_STATE_REASON_FIRMWARE_MISSING = 35,
 
 	/* The device was removed */
-	NM_DEVICE_STATE_REASON_REMOVED,
+	NM_DEVICE_STATE_REASON_REMOVED = 36,
 
 	/* NetworkManager went to sleep */
-	NM_DEVICE_STATE_REASON_SLEEPING,
+	NM_DEVICE_STATE_REASON_SLEEPING = 37,
 
 	/* The device's active connection disappeared */
-	NM_DEVICE_STATE_REASON_CONNECTION_REMOVED,
+	NM_DEVICE_STATE_REASON_CONNECTION_REMOVED = 38,
 
 	/* Device disconnected by user or client */
-	NM_DEVICE_STATE_REASON_USER_REQUESTED,
+	NM_DEVICE_STATE_REASON_USER_REQUESTED = 39,
 
 	/* Carrier/link changed */
-	NM_DEVICE_STATE_REASON_CARRIER,
+	NM_DEVICE_STATE_REASON_CARRIER = 40,
 
 	/* The device's existing connection was assumed */
-	NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED,
+	NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED = 41,
 
 	/* The supplicant is now available */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE = 42,
+
+	/* The modem could not be found */
+	NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND = 43,
+
+	/* The Bluetooth connection failed or timed out */
+	NM_DEVICE_STATE_REASON_BT_FAILED = 44,
 
 	/* Unused */
 	NM_DEVICE_STATE_REASON_LAST = 0xFFFF
diff --git a/introspection/Makefile.am b/introspection/Makefile.am
index 0dc286a..212da3a 100644
--- a/introspection/Makefile.am
+++ b/introspection/Makefile.am
@@ -23,5 +23,6 @@ EXTRA_DIST = \
 	nm-vpn-connection.xml \
 	nm-ppp-manager.xml \
 	nm-active-connection.xml \
-	nm-dhcp4-config.xml
+	nm-dhcp4-config.xml \
+	nm-dhcp6-config.xml
 
diff --git a/introspection/all.xml b/introspection/all.xml
index 67f1e54..d6b2f23 100644
--- a/introspection/all.xml
+++ b/introspection/all.xml
@@ -38,6 +38,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</
 <xi:include href="nm-ip4-config.xml"/>
 <xi:include href="nm-ip6-config.xml"/>
 <xi:include href="nm-dhcp4-config.xml"/>
+<xi:include href="nm-dhcp6-config.xml"/>
 <xi:include href="nm-settings.xml"/>
 <xi:include href="nm-exported-connection.xml"/>
 <xi:include href="nm-active-connection.xml"/>
diff --git a/introspection/nm-device.xml b/introspection/nm-device.xml
index c23b596..0d0a950 100644
--- a/introspection/nm-device.xml
+++ b/introspection/nm-device.xml
@@ -392,7 +392,17 @@
           The 802.1x supplicant is now available.
         </tp:docstring>
       </tp:enumvalue>
-	</tp:enum>
+      <tp:enumvalue suffix="MODEM_NOT_FOUND" value="43">
+        <tp:docstring>
+          The modem could not be found.
+        </tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="BT_FAILED" value="44">
+        <tp:docstring>
+          The Bluetooth connection timed out or failed.
+        </tp:docstring>
+      </tp:enumvalue>
+    </tp:enum>
 
   </interface>
 </node>
diff --git a/introspection/nm-dhcp6-config.xml b/introspection/nm-dhcp6-config.xml
new file mode 100644
index 0000000..93b0f1c
--- /dev/null
+++ b/introspection/nm-dhcp6-config.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+    <interface name="org.freedesktop.NetworkManager.DHCP6Config">
+        <tp:docstring>
+            Options and configuration returned by the IPv6 DHCP server.
+        </tp:docstring>
+        <property name="Options" type="a{sv}" access="read">
+            <tp:docstring>Configuration options returned by a DHCP server, if any.</tp:docstring>
+        </property>
+
+        <signal name="PropertiesChanged">
+            <arg name="properties" type="a{sv}" tp:type="String_Variant_Map">
+                <tp:docstring>
+                    A dictionary mapping property names to variant boxed values
+                </tp:docstring>
+            </arg>
+        </signal>
+    </interface>
+</node>
diff --git a/introspection/nm-exported-connection.xml b/introspection/nm-exported-connection.xml
index 5cb157e..46907c0 100644
--- a/introspection/nm-exported-connection.xml
+++ b/introspection/nm-exported-connection.xml
@@ -46,7 +46,7 @@
             </tp:docstring>
             <arg name="settings" type="a{sa{sv}}" tp:type="String_String_Variant_Map_Map">
                 <tp:docstring>
-                    Contains the changed settings.
+                    Contains complete connection setting parameters, including changes.
                 </tp:docstring>
             </arg>
         </signal>
diff --git a/introspection/nm-manager.xml b/introspection/nm-manager.xml
index 8303f4d..406b5cf 100644
--- a/introspection/nm-manager.xml
+++ b/introspection/nm-manager.xml
@@ -96,6 +96,28 @@
       </arg>
     </method>
 
+    <method name="SetLogging">
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_manager_set_logging"/>
+      <tp:docstring>
+        Set logging verbosity and which operations are logged.
+      </tp:docstring>
+      <arg name="level" type="s" direction="in">
+        <tp:docstring>
+          One of [ERR, WARN, INFO, DEBUG].
+        </tp:docstring>
+      </arg>
+      <arg name="domains" type="s" direction="in">
+        <tp:docstring>
+          A combination of logging domains separated by commas (','), or "NONE"
+          to disable logging.  Each domain enables logging for operations
+          related to that domain.  Available domains are: [NONE, HW, RKILL,
+          ETHER, WIFI, BT, MB, DHCP4, DHCP6, PPP, WIFI_SCAN, IP4, IP6, AUTOIP4,
+          DNS, VPN, SHARING, SUPPLICANT, USER_SET, SYS_SET, SUSPEND, CORE,
+          DEVICE, OLPC]
+        </tp:docstring>
+      </arg>
+    </method>
+
     <property name="WirelessEnabled" type="b" access="readwrite">
       <tp:docstring>
         Indicates if wireless is currently enabled or not.
diff --git a/libnm-glib/Makefile.am b/libnm-glib/Makefile.am
index 2aa6124..58b5bc5 100644
--- a/libnm-glib/Makefile.am
+++ b/libnm-glib/Makefile.am
@@ -20,7 +20,32 @@ BUILT_SOURCES = \
 	nm-active-connection-bindings.h \
 	nm-ip4-config-bindings.h \
 	nm-dhcp4-config-bindings.h \
-	nm-ip6-config-bindings.h
+	nm-ip6-config-bindings.h \
+	nm-dhcp6-config-bindings.h
+
+#####################################################
+# Deprecated original libnm_glib bits
+#####################################################
+
+noinst_LTLIBRARIES = libdeprecated-nm-glib.la
+
+libdeprecated_nm_glib_la_SOURCES = \
+	libnm_glib.h \
+	libnm_glib.c
+
+libdeprecated_nm_glib_la_CPPFLAGS = \
+	$(DBUS_CFLAGS) \
+	$(GLIB_CFLAGS) \
+	-Wno-deprecated-declarations \
+	-Wno-deprecated
+
+libdeprecated_nm_glib_la_LIBADD = \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS)
+
+#####################################################
+# Real libnm-glib stuff
+#####################################################
 
 lib_LTLIBRARIES = libnm-glib.la libnm-glib-vpn.la
 
@@ -52,6 +77,7 @@ libnminclude_HEADERS = \
 	nm-active-connection.h \
 	nm-dhcp4-config.h \
 	nm-ip6-config.h \
+	nm-dhcp6-config.h \
 	nm-remote-connection.h \
 	nm-settings-interface.h \
 	nm-settings-system-interface.h \
@@ -62,7 +88,6 @@ libnminclude_HEADERS = \
 	nm-settings-service.h
 
 libnm_glib_la_SOURCES = \
-	libnm_glib.c \
 	nm-object.c \
 	nm-object-private.h \
 	nm-client.c \
@@ -86,6 +111,7 @@ libnm_glib_la_SOURCES = \
 	nm-active-connection.c \
 	nm-dhcp4-config.c \
 	nm-ip6-config.c \
+	nm-dhcp6-config.c \
 	nm-remote-connection.c \
 	nm-remote-connection-private.h \
 	nm-settings-interface.c \
@@ -99,13 +125,14 @@ libnm_glib_la_SOURCES = \
 libnm_glib_la_LIBADD = \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(builddir)/libdeprecated-nm-glib.la \
 	$(GLIB_LIBS) \
 	$(DBUS_LIBS) \
 	$(GCONF_LIBS) \
 	$(GUDEV_LIBS)
 
 libnm_glib_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-glib.ver \
-	-version-info "4:0:2"
+	-version-info "4:1:2"
 
 noinst_PROGRAMS = libnm-glib-test
 
@@ -172,6 +199,9 @@ nm-dhcp4-config-bindings.h: $(top_srcdir)/introspection/nm-dhcp4-config.xml
 nm-ip6-config-bindings.h: $(top_srcdir)/introspection/nm-ip6-config.xml
 	dbus-binding-tool --prefix=nm_ip6_config --mode=glib-client --output=$@ $<
 
+nm-dhcp6-config-bindings.h: $(top_srcdir)/introspection/nm-dhcp6-config.xml
+	dbus-binding-tool --prefix=nm_dhcp6_config --mode=glib-client --output=$@ $<
+
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libnm-glib.pc libnm-glib-vpn.pc
 
@@ -179,5 +209,4 @@ DISTCLEANFILES = libnm-glib.pc libnm-glib.pc
 
 EXTRA_DIST = libnm-glib.pc.in libnm-glib-vpn.pc.in libnm-glib.ver libnm-glib-vpn.ver
 
-CLEANFILES = \
-	$(BUILT_SOURCES)
+CLEANFILES = $(BUILT_SOURCES)
diff --git a/libnm-glib/libnm-glib-test.c b/libnm-glib/libnm-glib-test.c
index ed29601..3ac0a24 100644
--- a/libnm-glib/libnm-glib-test.c
+++ b/libnm-glib/libnm-glib-test.c
@@ -36,6 +36,7 @@
 #include "nm-device-wifi.h"
 #include "nm-utils.h"
 #include "nm-active-connection.h"
+#include "nm-vpn-connection.h"
 #include "nm-setting-ip4-config.h"
 
 static gboolean
@@ -291,8 +292,10 @@ active_connections_changed (NMClient *client, GParamSpec *pspec, gpointer user_d
 		connection = g_ptr_array_index (connections, i);
 		g_print ("    %s\n", nm_object_get_path (NM_OBJECT (connection)));
 		devices = nm_active_connection_get_devices (connection);
-		for (j = 0; j < devices->len; j++)
+		for (j = 0; devices && j < devices->len; j++)
 			g_print ("           %s\n", nm_device_get_udi (g_ptr_array_index (devices, j)));
+		if (NM_IS_VPN_CONNECTION (connection))
+			g_print ("           VPN base connection: %s\n", nm_active_connection_get_specific_object (connection));
 	}
 }
 
diff --git a/libnm-glib/libnm-glib.ver b/libnm-glib/libnm-glib.ver
index 1caa2d4..dfe4fe5 100644
--- a/libnm-glib/libnm-glib.ver
+++ b/libnm-glib/libnm-glib.ver
@@ -129,6 +129,7 @@ global:
 	nm_settings_connection_interface_get_type;
 	nm_settings_connection_interface_update;
 	nm_settings_interface_add_connection;
+	nm_settings_interface_error_get_type;
 	nm_settings_interface_error_quark;
 	nm_settings_interface_get_connection_by_path;
 	nm_settings_interface_get_type;
diff --git a/libnm-glib/libnm_glib.h b/libnm-glib/libnm_glib.h
index fa3c812..01c055d 100644
--- a/libnm-glib/libnm_glib.h
+++ b/libnm-glib/libnm_glib.h
@@ -37,21 +37,21 @@ typedef enum libnm_glib_state
 	LIBNM_NO_NETWORK_CONNECTION,
 	LIBNM_ACTIVE_NETWORK_CONNECTION,
 	LIBNM_INVALID_CONTEXT
-} libnm_glib_state;
+} libnm_glib_state G_GNUC_DEPRECATED;
 
-typedef struct libnm_glib_ctx libnm_glib_ctx;
+typedef struct libnm_glib_ctx libnm_glib_ctx G_GNUC_DEPRECATED;
 
 
-typedef void (*libnm_glib_callback_func) (libnm_glib_ctx *libnm_ctx, gpointer user_data);
+typedef void (*libnm_glib_callback_func) (libnm_glib_ctx *libnm_ctx, gpointer user_data) G_GNUC_DEPRECATED;
 
 
-libnm_glib_ctx		*libnm_glib_init				(void);
-void				 libnm_glib_shutdown			(libnm_glib_ctx *ctx);
+G_GNUC_DEPRECATED libnm_glib_ctx *  libnm_glib_init                (void);
+G_GNUC_DEPRECATED void              libnm_glib_shutdown            (libnm_glib_ctx *ctx);
 
-libnm_glib_state	 libnm_glib_get_network_state		(const libnm_glib_ctx *ctx);
+G_GNUC_DEPRECATED libnm_glib_state  libnm_glib_get_network_state   (const libnm_glib_ctx *ctx);
 
-guint				 libnm_glib_register_callback		(libnm_glib_ctx *ctx, libnm_glib_callback_func func, gpointer user_data, GMainContext *g_main_ctx);
-void				 libnm_glib_unregister_callback	(libnm_glib_ctx *ctx, guint id);
+G_GNUC_DEPRECATED guint             libnm_glib_register_callback   (libnm_glib_ctx *ctx, libnm_glib_callback_func func, gpointer user_data, GMainContext *g_main_ctx);
+G_GNUC_DEPRECATED void              libnm_glib_unregister_callback (libnm_glib_ctx *ctx, guint id);
 
 G_END_DECLS
 
diff --git a/libnm-glib/nm-device.c b/libnm-glib/nm-device.c
index 17caa99..a24eb06 100644
--- a/libnm-glib/nm-device.c
+++ b/libnm-glib/nm-device.c
@@ -59,6 +59,8 @@ typedef struct {
 	gboolean null_dhcp4_config;
 	NMIP6Config *ip6_config;
 	gboolean null_ip6_config;
+	NMDHCP6Config *dhcp6_config;
+	gboolean null_dhcp6_config;
 	NMDeviceState state;
 
 	GUdevClient *client;
@@ -79,6 +81,7 @@ enum {
 	PROP_STATE,
 	PROP_PRODUCT,
 	PROP_VENDOR,
+	PROP_DHCP6_CONFIG,
 
 	LAST_PROP
 };
@@ -220,6 +223,46 @@ demarshal_ip6_config (NMObject *object, GParamSpec *pspec, GValue *value, gpoint
 	return TRUE;
 }
 
+static gboolean
+demarshal_dhcp6_config (NMObject *object, GParamSpec *pspec, GValue *value, gpointer field)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (object);
+	const char *path;
+	NMDHCP6Config *config = NULL;
+	DBusGConnection *connection;
+
+	if (!G_VALUE_HOLDS (value, DBUS_TYPE_G_OBJECT_PATH))
+		return FALSE;
+
+	priv->null_dhcp6_config = FALSE;
+
+	path = g_value_get_boxed (value);
+	if (path) {
+		if (!strcmp (path, "/"))
+			priv->null_dhcp6_config = TRUE;
+		else {
+			config = NM_DHCP6_CONFIG (_nm_object_cache_get (path));
+			if (config)
+				config = g_object_ref (config);
+			else {
+				connection = nm_object_get_connection (object);
+				config = NM_DHCP6_CONFIG (nm_dhcp6_config_new (connection, path));
+			}
+		}
+	}
+
+	if (priv->dhcp6_config) {
+		g_object_unref (priv->dhcp6_config);
+		priv->dhcp6_config = NULL;
+	}
+
+	if (config)
+		priv->dhcp6_config = config;
+
+	_nm_object_queue_notify (object, NM_DEVICE_DHCP6_CONFIG);
+	return TRUE;
+}
+
 static void
 register_for_property_changed (NMDevice *device)
 {
@@ -230,9 +273,10 @@ register_for_property_changed (NMDevice *device)
 		{ NM_DEVICE_DRIVER,       _nm_object_demarshal_generic, &priv->driver },
 		{ NM_DEVICE_CAPABILITIES, _nm_object_demarshal_generic, &priv->capabilities },
 		{ NM_DEVICE_MANAGED,      _nm_object_demarshal_generic, &priv->managed },
-		{ NM_DEVICE_IP4_CONFIG,   demarshal_ip4_config,        &priv->ip4_config },
-		{ NM_DEVICE_DHCP4_CONFIG, demarshal_dhcp4_config,      &priv->dhcp4_config },
-		{ NM_DEVICE_IP6_CONFIG,   demarshal_ip6_config,        &priv->ip6_config },
+		{ NM_DEVICE_IP4_CONFIG,   demarshal_ip4_config,         &priv->ip4_config },
+		{ NM_DEVICE_DHCP4_CONFIG, demarshal_dhcp4_config,       &priv->dhcp4_config },
+		{ NM_DEVICE_IP6_CONFIG,   demarshal_ip6_config,         &priv->ip6_config },
+		{ NM_DEVICE_DHCP6_CONFIG, demarshal_dhcp6_config,       &priv->dhcp6_config },
 		{ NULL },
 	};
 
@@ -318,6 +362,8 @@ dispose (GObject *object)
 		g_object_unref (priv->dhcp4_config);
 	if (priv->ip6_config)
 		g_object_unref (priv->ip6_config);
+	if (priv->dhcp6_config)
+		g_object_unref (priv->dhcp6_config);
 	if (priv->client)
 		g_object_unref (priv->client);
 
@@ -371,6 +417,9 @@ get_property (GObject *object,
 	case PROP_IP6_CONFIG:
 		g_value_set_object (value, nm_device_get_ip6_config (device));
 		break;
+	case PROP_DHCP6_CONFIG:
+		g_value_set_object (value, nm_device_get_dhcp6_config (device));
+		break;
 	case PROP_STATE:
 		g_value_set_uint (value, nm_device_get_state (device));
 		break;
@@ -506,6 +555,19 @@ nm_device_class_init (NMDeviceClass *device_class)
 		                      G_PARAM_READABLE));
 
 	/**
+	 * NMDevice:dhcp6-config:
+	 *
+	 * The #NMDHCP6Config of the device.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_DHCP6_CONFIG,
+		 g_param_spec_object (NM_DEVICE_DHCP6_CONFIG,
+						  "DHCP6 Config",
+						  "DHCP6 Config",
+						  NM_TYPE_DHCP6_CONFIG,
+						  G_PARAM_READABLE));
+
+	/**
 	 * NMDevice:state:
 	 *
 	 * The state of the device.
@@ -871,6 +933,41 @@ nm_device_get_ip6_config (NMDevice *device)
 }
 
 /**
+ * nm_device_get_dhcp6_config:
+ * @device: a #NMDevice
+ *
+ * Gets the current #NMDHCP6Config associated with the #NMDevice.
+ *
+ * Returns: the #NMDHCPConfig or %NULL if the device is not activated or not
+ * using DHCP.
+ **/
+NMDHCP6Config *
+nm_device_get_dhcp6_config (NMDevice *device)
+{
+	NMDevicePrivate *priv;
+	char *path;
+	GValue value = { 0, };
+
+	g_return_val_if_fail (NM_IS_DEVICE (device), NULL);
+
+	priv = NM_DEVICE_GET_PRIVATE (device);
+	if (priv->dhcp6_config)
+		return priv->dhcp6_config;
+	if (priv->null_dhcp6_config)
+		return NULL;
+
+	path = _nm_object_get_object_path_property (NM_OBJECT (device), NM_DBUS_INTERFACE_DEVICE, "Dhcp6Config");
+	if (path) {
+		g_value_init (&value, DBUS_TYPE_G_OBJECT_PATH);
+		g_value_take_boxed (&value, path);
+		demarshal_dhcp6_config (NM_OBJECT (device), NULL, &value, &priv->dhcp6_config);
+		g_value_unset (&value);
+	}
+
+	return priv->dhcp6_config;
+}
+
+/**
  * nm_device_get_state:
  * @device: a #NMDevice
  *
diff --git a/libnm-glib/nm-device.h b/libnm-glib/nm-device.h
index da015d6..64694ec 100644
--- a/libnm-glib/nm-device.h
+++ b/libnm-glib/nm-device.h
@@ -32,6 +32,7 @@
 #include "nm-ip4-config.h"
 #include "nm-dhcp4-config.h"
 #include "nm-ip6-config.h"
+#include "nm-dhcp6-config.h"
 #include "nm-connection.h"
 
 G_BEGIN_DECLS
@@ -51,6 +52,7 @@ G_BEGIN_DECLS
 #define NM_DEVICE_IP4_CONFIG "ip4-config"
 #define NM_DEVICE_DHCP4_CONFIG "dhcp4-config"
 #define NM_DEVICE_IP6_CONFIG "ip6-config"
+#define NM_DEVICE_DHCP6_CONFIG "dhcp6-config"
 #define NM_DEVICE_STATE "state"
 #define NM_DEVICE_VENDOR "vendor"
 #define NM_DEVICE_PRODUCT "product"
@@ -89,6 +91,7 @@ gboolean      nm_device_get_managed        (NMDevice *device);
 NMIP4Config * nm_device_get_ip4_config     (NMDevice *device);
 NMDHCP4Config * nm_device_get_dhcp4_config (NMDevice *device);
 NMIP6Config * nm_device_get_ip6_config     (NMDevice *device);
+NMDHCP6Config * nm_device_get_dhcp6_config (NMDevice *device);
 NMDeviceState nm_device_get_state          (NMDevice *device);
 const char *  nm_device_get_product        (NMDevice *device);
 const char *  nm_device_get_vendor         (NMDevice *device);
diff --git a/libnm-glib/nm-dhcp6-config.c b/libnm-glib/nm-dhcp6-config.c
new file mode 100644
index 0000000..49eeda3
--- /dev/null
+++ b/libnm-glib/nm-dhcp6-config.c
@@ -0,0 +1,248 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
+ * Copyright (C) 2008 Novell, Inc.
+ */
+
+#include <string.h>
+
+#include "nm-dhcp6-config.h"
+#include "NetworkManager.h"
+#include "nm-types-private.h"
+#include "nm-object-private.h"
+#include "nm-utils.h"
+
+G_DEFINE_TYPE (NMDHCP6Config, nm_dhcp6_config, NM_TYPE_OBJECT)
+
+#define NM_DHCP6_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigPrivate))
+
+typedef struct {
+	DBusGProxy *proxy;
+
+	GHashTable *options;
+} NMDHCP6ConfigPrivate;
+
+enum {
+	PROP_0,
+	PROP_OPTIONS,
+
+	LAST_PROP
+};
+
+static void
+nm_dhcp6_config_init (NMDHCP6Config *config)
+{
+}
+
+static void
+copy_options (gpointer key, gpointer data, gpointer user_data)
+{
+	GHashTable *options = (GHashTable *) user_data;
+	GValue *value = (GValue *) data;
+
+	g_hash_table_insert (options, g_strdup (key), g_value_dup_string (value));
+}
+
+static gboolean
+demarshal_dhcp6_options (NMObject *object, GParamSpec *pspec, GValue *value, gpointer field)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+	GHashTable *new_options;
+
+	g_hash_table_remove_all (priv->options);
+
+	new_options = g_value_get_boxed (value);
+	if (new_options)
+		g_hash_table_foreach (new_options, copy_options, priv->options);
+
+	_nm_object_queue_notify (object, NM_DHCP6_CONFIG_OPTIONS);
+	return TRUE;
+}
+
+static void
+register_for_property_changed (NMDHCP6Config *config)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (config);
+	const NMPropertiesChangedInfo property_changed_info[] = {
+		{ NM_DHCP6_CONFIG_OPTIONS,   demarshal_dhcp6_options,  &priv->options },
+		{ NULL },
+	};
+
+	_nm_object_handle_properties_changed (NM_OBJECT (config),
+	                                     priv->proxy,
+	                                     property_changed_info);
+}
+
+static GObject*
+constructor (GType type,
+		   guint n_construct_params,
+		   GObjectConstructParam *construct_params)
+{
+	NMObject *object;
+	DBusGConnection *connection;
+	NMDHCP6ConfigPrivate *priv;
+
+	object = (NMObject *) G_OBJECT_CLASS (nm_dhcp6_config_parent_class)->constructor (type,
+																 n_construct_params,
+																 construct_params);
+	if (!object)
+		return NULL;
+
+	priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+
+	connection = nm_object_get_connection (object);
+
+	priv->proxy = dbus_g_proxy_new_for_name (connection,
+										   NM_DBUS_SERVICE,
+										   nm_object_get_path (object),
+										   NM_DBUS_INTERFACE_DHCP6_CONFIG);
+
+	register_for_property_changed (NM_DHCP6_CONFIG (object));
+
+	return G_OBJECT (object);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+
+	if (priv->options)
+		g_hash_table_destroy (priv->options);
+
+	g_object_unref (priv->proxy);
+
+	G_OBJECT_CLASS (nm_dhcp6_config_parent_class)->finalize (object);
+}
+
+static void
+get_property (GObject *object,
+              guint prop_id,
+              GValue *value,
+              GParamSpec *pspec)
+{
+	NMDHCP6Config *self = NM_DHCP6_CONFIG (object);
+
+	switch (prop_id) {
+	case PROP_OPTIONS:
+		g_value_set_boxed (value, nm_dhcp6_config_get_options (self));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_dhcp6_config_class_init (NMDHCP6ConfigClass *config_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (config_class);
+
+	g_type_class_add_private (config_class, sizeof (NMDHCP6ConfigPrivate));
+
+	/* virtual methods */
+	object_class->constructor = constructor;
+	object_class->get_property = get_property;
+	object_class->finalize = finalize;
+
+	/* properties */
+
+	/**
+	 * NMDHCP6Config:options:
+	 *
+	 * The #GHashTable containing options of the configuration.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_OPTIONS,
+		 g_param_spec_boxed (NM_DHCP6_CONFIG_OPTIONS,
+						       "Options",
+						       "Options",
+						       G_TYPE_HASH_TABLE,
+						       G_PARAM_READABLE));
+}
+
+/**
+ * nm_dhcp6_config_new:
+ * @connection: the #DBusGConnection
+ * @object_path: the DBus object path of the device
+ *
+ * Creates a new #NMDHCP6Config.
+ *
+ * Returns: a new configuration
+ **/
+GObject *
+nm_dhcp6_config_new (DBusGConnection *connection, const char *object_path)
+{
+	return (GObject *) g_object_new (NM_TYPE_DHCP6_CONFIG,
+									 NM_OBJECT_DBUS_CONNECTION, connection,
+									 NM_OBJECT_DBUS_PATH, object_path,
+									 NULL);
+}
+
+/**
+ * nm_dhcp6_config_get_options:
+ * @config: a #NMDHCP6Config
+ *
+ * Gets all the options contained in the configuration.
+ *
+ * Returns: the #GHashTable containing strings for keys and values.
+ * This is the internal copy used by the configuration, and must not be modified.
+ **/
+GHashTable *
+nm_dhcp6_config_get_options (NMDHCP6Config *config)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (config);
+	GValue value = { 0, };
+
+	if (g_hash_table_size (priv->options))
+		return priv->options;
+
+	if (!_nm_object_get_property (NM_OBJECT (config),
+	                             "org.freedesktop.DBus.Properties",
+	                             "Options",
+	                             &value))
+		goto out;
+
+	demarshal_dhcp6_options (NM_OBJECT (config), NULL, &value, &priv->options);	
+	g_value_unset (&value);
+
+out:
+	return priv->options;
+}
+
+/**
+ * nm_dhcp6_config_get_one_option:
+ * @config: a #NMDHCP6Config
+ * @option: the option to retrieve
+ *
+ * Gets one option by option name.
+ *
+ * Returns: the configuration option's value. This is the internal string used by the
+ * configuration, and must not be modified.
+ **/
+const char *
+nm_dhcp6_config_get_one_option (NMDHCP6Config *config, const char *option)
+{
+	g_return_val_if_fail (NM_IS_DHCP6_CONFIG (config), NULL);
+
+	return g_hash_table_lookup (nm_dhcp6_config_get_options (config), option);
+}
+
diff --git a/libnm-glib/nm-dhcp6-config.h b/libnm-glib/nm-dhcp6-config.h
new file mode 100644
index 0000000..91f32fa
--- /dev/null
+++ b/libnm-glib/nm-dhcp6-config.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
+ * Copyright (C) 2008 Novell, Inc.
+ */
+
+#ifndef NM_DHCP6_CONFIG_H
+#define NM_DHCP6_CONFIG_H
+
+#include <glib.h>
+#include <glib-object.h>
+#include <dbus/dbus-glib.h>
+#include "nm-object.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DHCP6_CONFIG            (nm_dhcp6_config_get_type ())
+#define NM_DHCP6_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP6_CONFIG, NMDHCP6Config))
+#define NM_DHCP6_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigClass))
+#define NM_IS_DHCP6_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+#define NM_IS_DHCP6_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+
+typedef struct {
+	NMObject parent;
+} NMDHCP6Config;
+
+typedef struct {
+	NMObjectClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+	void (*_reserved5) (void);
+	void (*_reserved6) (void);
+} NMDHCP6ConfigClass;
+
+#define NM_DHCP6_CONFIG_OPTIONS "options"
+
+GType nm_dhcp6_config_get_type (void);
+
+GObject *nm_dhcp6_config_new (DBusGConnection *connection, const char *object_path);
+
+GHashTable * nm_dhcp6_config_get_options (NMDHCP6Config *config);
+
+const char * nm_dhcp6_config_get_one_option (NMDHCP6Config *config, const char *option);
+
+G_END_DECLS
+
+#endif /* NM_DHCP6_CONFIG_H */
diff --git a/libnm-glib/nm-exported-connection.c b/libnm-glib/nm-exported-connection.c
index 8ca64e7..3a8e51c 100644
--- a/libnm-glib/nm-exported-connection.c
+++ b/libnm-glib/nm-exported-connection.c
@@ -228,7 +228,9 @@ impl_exported_connection_get_secrets (NMExportedConnection *self,
 	if (NM_EXPORTED_CONNECTION_GET_CLASS (self)->get_secrets)
 		NM_EXPORTED_CONNECTION_GET_CLASS (self)->get_secrets (self, setting_name, hints, request_new, context);
 	else {
-		error = g_error_new (0, 0, "%s: %s:%d get_secrets() unimplemented", __func__, __FILE__, __LINE__);
+		error = g_error_new (NM_SETTINGS_INTERFACE_ERROR,
+		                     NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		                     "%s: %s:%d get_secrets() unimplemented", __func__, __FILE__, __LINE__);
 		dbus_g_method_return_error (context, error);
 		g_error_free (error);
 	}
diff --git a/libnm-glib/nm-remote-connection.c b/libnm-glib/nm-remote-connection.c
index 6495647..5d104d0 100644
--- a/libnm-glib/nm-remote-connection.c
+++ b/libnm-glib/nm-remote-connection.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2009 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -324,12 +324,14 @@ constructor (GType type,
 	                                         nm_connection_get_path (NM_CONNECTION (object)),
 	                                         NM_DBUS_IFACE_SETTINGS_CONNECTION);
 	g_assert (priv->proxy);
+	dbus_g_proxy_set_default_timeout (priv->proxy, G_MAXINT);
 
 	priv->secrets_proxy = dbus_g_proxy_new_for_name (priv->bus,
 	                                                 service,
 	                                                 nm_connection_get_path (NM_CONNECTION (object)),
 	                                                 NM_DBUS_IFACE_SETTINGS_CONNECTION_SECRETS);
 	g_assert (priv->secrets_proxy);
+	dbus_g_proxy_set_default_timeout (priv->secrets_proxy, G_MAXINT);
 
 	dbus_g_proxy_add_signal (priv->proxy, "Updated", DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, G_TYPE_INVALID);
 	dbus_g_proxy_connect_signal (priv->proxy, "Updated", G_CALLBACK (updated_cb), object, NULL);
diff --git a/libnm-glib/nm-remote-settings-system.c b/libnm-glib/nm-remote-settings-system.c
index 4e30fda..95098c7 100644
--- a/libnm-glib/nm-remote-settings-system.c
+++ b/libnm-glib/nm-remote-settings-system.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2008 Novell, Inc.
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -280,6 +280,7 @@ constructor (GType type,
 	                                         NM_DBUS_PATH_SETTINGS,
 	                                         NM_DBUS_IFACE_SETTINGS_SYSTEM);
 	g_assert (priv->proxy);
+	dbus_g_proxy_set_default_timeout (priv->proxy, G_MAXINT);
 
 	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__BOXED,
 	                                   G_TYPE_NONE,
diff --git a/libnm-glib/nm-remote-settings.c b/libnm-glib/nm-remote-settings.c
index 55ae0f3..92814a1 100644
--- a/libnm-glib/nm-remote-settings.c
+++ b/libnm-glib/nm-remote-settings.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2008 Novell, Inc.
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -414,6 +414,7 @@ constructor (GType type,
 	                                         NM_DBUS_PATH_SETTINGS,
 	                                         NM_DBUS_IFACE_SETTINGS);
 	g_assert (priv->proxy);
+	dbus_g_proxy_set_default_timeout (priv->proxy, G_MAXINT);
 
 	dbus_g_proxy_add_signal (priv->proxy, "NewConnection",
 	                         DBUS_TYPE_G_OBJECT_PATH,
diff --git a/libnm-glib/nm-vpn-connection.c b/libnm-glib/nm-vpn-connection.c
index f66ed19..6910b6f 100644
--- a/libnm-glib/nm-vpn-connection.c
+++ b/libnm-glib/nm-vpn-connection.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2008 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -41,6 +41,17 @@ typedef struct {
 } NMVPNConnectionPrivate;
 
 enum {
+	PROP_0,
+	PROP_VPN_STATE,
+	PROP_BANNER,
+
+	LAST_PROP
+};
+
+#define DBUS_PROP_VPN_STATE "VpnState"
+#define DBUS_PROP_BANNER "Banner"
+
+enum {
 	VPN_STATE_CHANGED,
 
 	LAST_SIGNAL
@@ -74,8 +85,8 @@ nm_vpn_connection_get_banner (NMVPNConnection *vpn)
 
 	if (!priv->banner) {
 		priv->banner = _nm_object_get_string_property (NM_OBJECT (vpn),
-		                                              NM_DBUS_INTERFACE_VPN_CONNECTION,
-		                                              "Banner");
+		                                               NM_DBUS_INTERFACE_VPN_CONNECTION,
+		                                               DBUS_PROP_BANNER);
 		if (priv->banner && !strlen (priv->banner)) {
 			g_free (priv->banner);
 			priv->banner = NULL;
@@ -94,8 +105,8 @@ nm_vpn_connection_get_vpn_state (NMVPNConnection *vpn)
 	priv = NM_VPN_CONNECTION_GET_PRIVATE (vpn);
 	if (priv->vpn_state == NM_VPN_CONNECTION_STATE_UNKNOWN) {
 		priv->vpn_state = _nm_object_get_uint_property (NM_OBJECT (vpn),
-		                                           NM_DBUS_INTERFACE_VPN_CONNECTION,
-		                                           "VpnState");
+		                                                NM_DBUS_INTERFACE_VPN_CONNECTION,
+		                                                DBUS_PROP_VPN_STATE);
 	}
 	return priv->vpn_state;
 }
@@ -173,6 +184,27 @@ finalize (GObject *object)
 }
 
 static void
+get_property (GObject *object,
+              guint prop_id,
+              GValue *value,
+              GParamSpec *pspec)
+{
+	NMVPNConnection *self = NM_VPN_CONNECTION (object);
+
+	switch (prop_id) {
+	case PROP_VPN_STATE:
+		g_value_set_uint (value, nm_vpn_connection_get_vpn_state (self));
+		break;
+	case PROP_BANNER:
+		g_value_set_string (value, nm_vpn_connection_get_banner (self));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
 nm_vpn_connection_class_init (NMVPNConnectionClass *connection_class)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (connection_class);
@@ -181,8 +213,37 @@ nm_vpn_connection_class_init (NMVPNConnectionClass *connection_class)
 
 	/* virtual methods */
 	object_class->constructor = constructor;
+	object_class->get_property = get_property;
 	object_class->finalize = finalize;
 
+	/* properties */
+
+	/**
+	 * NMVPNConnection:vpn-state:
+	 *
+	 * The VPN state of the active VPN connection.
+	 **/
+	g_object_class_install_property (object_class, PROP_VPN_STATE,
+	                                 g_param_spec_uint (NM_VPN_CONNECTION_VPN_STATE,
+	                                                    "VpnState",
+	                                                    "Current VPN state",
+	                                                    NM_VPN_CONNECTION_STATE_UNKNOWN,
+	                                                    NM_VPN_CONNECTION_STATE_DISCONNECTED,
+	                                                    NM_VPN_CONNECTION_STATE_UNKNOWN,
+	                                                    G_PARAM_READABLE));
+
+	/**
+	 * NMVPNConnection:banner:
+	 *
+	 * The VPN login banner of the active VPN connection.
+	 **/
+	g_object_class_install_property (object_class, PROP_BANNER,
+	                                 g_param_spec_string (NM_VPN_CONNECTION_BANNER,
+	                                                      "Banner",
+	                                                      "Login Banner",
+	                                                      NULL,
+	                                                      G_PARAM_READABLE));
+
 	/* signals */
 	signals[VPN_STATE_CHANGED] =
 		g_signal_new ("vpn-state-changed",
diff --git a/libnm-glib/nm-vpn-connection.h b/libnm-glib/nm-vpn-connection.h
index 122a85b..e03a80c 100644
--- a/libnm-glib/nm-vpn-connection.h
+++ b/libnm-glib/nm-vpn-connection.h
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2008 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #ifndef NM_VPN_CONNECTION_H
@@ -39,6 +39,9 @@ G_BEGIN_DECLS
 #define NM_IS_VPN_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_VPN_CONNECTION))
 #define NM_VPN_CONNECTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_VPN_CONNECTION, NMVPNConnectionClass))
 
+#define NM_VPN_CONNECTION_VPN_STATE "vpn-state"
+#define NM_VPN_CONNECTION_BANNER "banner"
+
 typedef struct {
 	NMActiveConnection parent;
 } NMVPNConnection;
diff --git a/libnm-util/Makefile.am b/libnm-util/Makefile.am
index 2aa4c4e..8f6a0cc 100644
--- a/libnm-util/Makefile.am
+++ b/libnm-util/Makefile.am
@@ -59,7 +59,7 @@ libnm_util_la_SOURCES=			\
 libnm_util_la_LIBADD = $(GLIB_LIBS) $(DBUS_LIBS) $(UUID_LIBS)
 
 libnm_util_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-util.ver \
-	-version-info "2:0:1"
+	-version-info "4:2:3"
 
 if WITH_GNUTLS
 libnm_util_la_SOURCES += crypto_gnutls.c
diff --git a/libnm-util/libnm-util.ver b/libnm-util/libnm-util.ver
index 17ce174..44d9ac5 100644
--- a/libnm-util/libnm-util.ver
+++ b/libnm-util/libnm-util.ver
@@ -132,9 +132,11 @@ global:
 	nm_setting_gsm_get_apn;
 	nm_setting_gsm_get_network_id;
 	nm_setting_gsm_get_network_type;
+	nm_setting_gsm_get_allowed_bands;
 	nm_setting_gsm_get_band;
 	nm_setting_gsm_get_pin;
 	nm_setting_gsm_get_puk;
+	nm_setting_gsm_get_home_only;
 	nm_setting_ip4_config_error_get_type;
 	nm_setting_ip4_config_error_quark;
 	nm_setting_ip4_config_get_type;
@@ -345,6 +347,7 @@ global:
 	nm_utils_ip4_addresses_to_gvalue;
 	nm_utils_ip4_netmask_to_prefix;
 	nm_utils_ip4_prefix_to_netmask;
+	nm_utils_ip4_get_default_prefix;
 	nm_utils_ip4_routes_from_gvalue;
 	nm_utils_ip4_routes_to_gvalue;
 	nm_utils_ip6_addresses_from_gvalue;
diff --git a/libnm-util/nm-setting-connection.c b/libnm-util/nm-setting-connection.c
index 1dedad3..65f613e 100644
--- a/libnm-util/nm-setting-connection.c
+++ b/libnm-util/nm-setting-connection.c
@@ -434,7 +434,7 @@ nm_setting_connection_class_init (NMSettingConnectionClass *setting_class)
 						  "(ie, contains only hexadecimal characters and '-'). "
 						  "The UUID should be assigned when the connection is "
 						  "created and never changed as long as the connection "
-						  "stilla pplies to the same network.  For example, "
+						  "still applies to the same network.  For example, "
 						  "it should not be changed when the user changes the "
 						  "connection's 'id', but should be recreated when the "
 						  "WiFi SSID, mobile broadband network provider, or the "
diff --git a/libnm-util/nm-setting-gsm.c b/libnm-util/nm-setting-gsm.c
index 626d219..4b4560c 100644
--- a/libnm-util/nm-setting-gsm.c
+++ b/libnm-util/nm-setting-gsm.c
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  * (C) Copyright 2007 - 2008 Novell, Inc.
  */
 
@@ -80,6 +80,8 @@ typedef struct {
 	guint32 allowed_bands;     /* A bitfield of NM_SETTING_GSM_BAND_* */
 
 	char *pin;
+
+	gboolean home_only;
 } NMSettingGsmPrivate;
 
 enum {
@@ -94,6 +96,7 @@ enum {
 	PROP_PIN,
 	PROP_PUK,
 	PROP_ALLOWED_BANDS,
+	PROP_HOME_ONLY,
 
 	LAST_PROP
 };
@@ -191,6 +194,14 @@ nm_setting_gsm_get_puk (NMSettingGsm *setting)
 	return NULL;
 }
 
+gboolean
+nm_setting_gsm_get_home_only (NMSettingGsm *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_GSM (setting), FALSE);
+
+	return NM_SETTING_GSM_GET_PRIVATE (setting)->home_only;
+}
+
 static gboolean
 verify (NMSetting *setting, GSList *all_settings, GError **error)
 {
@@ -356,6 +367,9 @@ set_property (GObject *object, guint prop_id,
 		if (str && strlen (str))
 			g_warning ("Tried to set deprecated property " NM_SETTING_GSM_SETTING_NAME "/" NM_SETTING_GSM_PUK);
 		break;
+	case PROP_HOME_ONLY:
+		priv->home_only = g_value_get_boolean (value);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -401,6 +415,9 @@ get_property (GObject *object, guint prop_id,
 		/* deprecated */
 		g_value_set_int (value, -1);
 		break;
+	case PROP_HOME_ONLY:
+		g_value_set_boolean (value, nm_setting_gsm_get_home_only (setting));
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -572,7 +589,8 @@ nm_setting_gsm_class_init (NMSettingGsmClass *setting_class)
 		                     || NM_SETTING_GSM_BAND_U800
 		                     || NM_SETTING_GSM_BAND_U850
 		                     || NM_SETTING_GSM_BAND_U900
-		                     || NM_SETTING_GSM_BAND_U17IX,
+		                     || NM_SETTING_GSM_BAND_U17IX
+		                     || NM_SETTING_GSM_BAND_U1900,
 		                    NM_SETTING_GSM_BAND_ANY,
 		                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
@@ -593,6 +611,22 @@ nm_setting_gsm_class_init (NMSettingGsmClass *setting_class)
 						  NULL,
 						  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE | NM_SETTING_PARAM_SECRET));
 
+	/**
+	 * NMSettingGsm:home-only:
+	 *
+	 * When TRUE, only connections to the home network will be allowed.
+	 * Connections to roaming networks will not be made.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_HOME_ONLY,
+		 g_param_spec_boolean (NM_SETTING_GSM_HOME_ONLY,
+						  "PIN",
+						  "When TRUE, only connections to the home network will "
+						  "be allowed.  Connections to roaming networks will "
+						  "not be made.",
+						  FALSE,
+						  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
 	/* Deprecated properties */
 	/**
 	 * NMSettingGsm:puk:
diff --git a/libnm-util/nm-setting-gsm.h b/libnm-util/nm-setting-gsm.h
index 5b6a056..0ac7122 100644
--- a/libnm-util/nm-setting-gsm.h
+++ b/libnm-util/nm-setting-gsm.h
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  * (C) Copyright 2007 - 2008 Novell, Inc.
  */
 
@@ -61,6 +61,7 @@ GQuark nm_setting_gsm_error_quark (void);
 #define NM_SETTING_GSM_NETWORK_TYPE  "network-type"
 #define NM_SETTING_GSM_ALLOWED_BANDS "allowed-bands"
 #define NM_SETTING_GSM_PIN           "pin"
+#define NM_SETTING_GSM_HOME_ONLY     "home-only"
 
 /* DEPRECATED & UNUSED */
 #define NM_SETTING_GSM_PUK           "puk"
@@ -95,6 +96,7 @@ typedef enum {
 	NM_SETTING_GSM_BAND_U850         = 0x00000200, /* WCDMA 3GPP UMTS 850 MHz      (Class V) */
 	NM_SETTING_GSM_BAND_U900         = 0x00000400, /* WCDMA 3GPP UMTS 900 MHz      (Class VIII) */
 	NM_SETTING_GSM_BAND_U17IX        = 0x00000800, /* WCDMA 3GPP UMTS 1700 MHz     (Class IX) */
+	NM_SETTING_GSM_BAND_U1900        = 0x00001000, /* WCDMA 3GPP UMTS 1900 MHz     (Class II) */
 } NMSettingGsmNetworkBand;
 
 typedef struct {
@@ -122,6 +124,7 @@ const char *nm_setting_gsm_get_network_id    (NMSettingGsm *setting);
 int         nm_setting_gsm_get_network_type  (NMSettingGsm *setting);
 guint32     nm_setting_gsm_get_allowed_bands (NMSettingGsm *setting);
 const char *nm_setting_gsm_get_pin           (NMSettingGsm *setting);
+gboolean    nm_setting_gsm_get_home_only     (NMSettingGsm *setting);
 
 /* DEPRECATED & UNUSED */
 const char *nm_setting_gsm_get_puk           (NMSettingGsm *setting);
diff --git a/libnm-util/nm-setting-ip4-config.c b/libnm-util/nm-setting-ip4-config.c
index 580369f..46ebbd3 100644
--- a/libnm-util/nm-setting-ip4-config.c
+++ b/libnm-util/nm-setting-ip4-config.c
@@ -879,7 +879,7 @@ nm_setting_ip4_config_class_init (NMSettingIP4ConfigClass *setting_class)
 	 * NMSettingIP4Config:ignore-auto-dns:
 	 *
 	 * When the method is set to 'auto' and this property to TRUE, automatically
-	 * configured nameservers and search domains are ignored and only namservers
+	 * configured nameservers and search domains are ignored and only nameservers
 	 * and search domains specified in #NMSettingIP4Config:dns and
 	 * #NMSettingIP4Config:dns-search, if any, are used.
 	 **/
@@ -889,7 +889,7 @@ nm_setting_ip4_config_class_init (NMSettingIP4ConfigClass *setting_class)
 						   "Ignore automatic DNS",
 						   "When the method is set to 'auto' and this property "
 						   "to TRUE, automatically configured nameservers and "
-						   "search domains are ignored and only namservers and "
+						   "search domains are ignored and only nameservers and "
 						   "search domains specified in the 'dns' and 'dns-search' "
 						   "properties, if any, are used.",
 						   FALSE,
diff --git a/libnm-util/nm-setting-ip6-config.c b/libnm-util/nm-setting-ip6-config.c
index b1577f0..3fbf1a2 100644
--- a/libnm-util/nm-setting-ip6-config.c
+++ b/libnm-util/nm-setting-ip6-config.c
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -435,26 +435,23 @@ verify (NMSetting *setting, GSList *all_settings, GError **error)
 			             NM_SETTING_IP6_CONFIG_ADDRESSES);
 			return FALSE;
 		}
-	} else if (   !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
-	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)
+	} else if (   !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)
 	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)
 	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
-		if (!priv->ignore_auto_dns) {
-			if (priv->dns && g_slist_length (priv->dns)) {
-				g_set_error (error,
-				             NM_SETTING_IP6_CONFIG_ERROR,
-				             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
-				             NM_SETTING_IP6_CONFIG_DNS);
-				return FALSE;
-			}
-
-			if (g_slist_length (priv->dns_search)) {
-				g_set_error (error,
-				             NM_SETTING_IP6_CONFIG_ERROR,
-				             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
-				             NM_SETTING_IP6_CONFIG_DNS_SEARCH);
-				return FALSE;
-			}
+		if (g_slist_length (priv->dns)) {
+			g_set_error (error,
+			             NM_SETTING_IP6_CONFIG_ERROR,
+			             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
+			             NM_SETTING_IP6_CONFIG_DNS);
+			return FALSE;
+		}
+
+		if (g_slist_length (priv->dns_search)) {
+			g_set_error (error,
+			             NM_SETTING_IP6_CONFIG_ERROR,
+			             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
+			             NM_SETTING_IP6_CONFIG_DNS_SEARCH);
+			return FALSE;
 		}
 
 		if (g_slist_length (priv->addresses)) {
@@ -464,6 +461,9 @@ verify (NMSetting *setting, GSList *all_settings, GError **error)
 			             NM_SETTING_IP6_CONFIG_ADDRESSES);
 			return FALSE;
 		}
+	} else if (   !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
+	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
+		/* nothing to do */
 	} else {
 		g_set_error (error,
 		             NM_SETTING_IP6_CONFIG_ERROR,
@@ -598,30 +598,33 @@ nm_setting_ip6_config_class_init (NMSettingIP6ConfigClass *setting_class)
 	 *
 	 * IPv6 configuration method.  If 'auto' is specified then the appropriate
 	 * automatic method (DHCP, PPP, advertisement, etc) is used for the
-	 * interface and most other properties can be left unset.  If 'link-local'
-	 * is specified, then an IPv6 link-local address will be assigned to the
-	 * interface.  If 'manual' is specified, static IP addressing is used and
-	 * at least one IP address must be given in the 'addresses' property.  If
-	 * 'ignored' is specified, IPv6 configuration is not done. This property
-	 * must be set.  NOTE: DHCP configuration and the 'shared' method are not
-	 * yet supported.
+	 * interface and most other properties can be left unset.  To force the use
+	 * of DHCP only, specify 'dhcp'; this  method is only valid for ethernet-
+	 * based hardware.  If 'link-local' is specified, then an IPv6 link-local
+	 * address will be assigned to the interface.  If 'manual' is specified,
+	 * static IP addressing is used and at least one IP address must be given
+	 * in the 'addresses' property.  If 'ignored' is specified, IPv6
+	 * configuration is not done. This property must be set.  NOTE: the 'shared'
+	 * method are not yet supported.
 	 **/
 	g_object_class_install_property
 		(object_class, PROP_METHOD,
 		 g_param_spec_string (NM_SETTING_IP6_CONFIG_METHOD,
 						      "Method",
 						      "IPv6 configuration method.  If 'auto' is specified "
-						      "then the appropriate automatic method (DHCP, PPP, "
+						      "then the appropriate automatic method (PPP, router "
 						      "advertisement, etc) is used for the device and "
-						      "most other properties can be left unset.  If "
+						      "most other properties can be left unset.  To force "
+						      "the use of DHCP only, specify 'dhcp'; this method "
+						      "is only valid for ethernet-based hardware.  If "
 						      "'link-local' is specified, then an IPv6 link-local "
 						      "address will be assigned to the interface.  If "
 						      "'manual' is specified, static IP addressing is "
 						      "used and at least one IP address must be given in "
 						      " the 'addresses' property.  If 'ignored' is "
 						      "specified, IPv6 configuration is not done. This "
-						      "property must be set.  NOTE: DHCP configuration "
-						      "and the 'shared' method are not yet supported.",
+						      "property must be set.  NOTE: the 'shared' method"
+						      "is not yet supported.",
 						      NULL,
 						      G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
 
@@ -740,38 +743,39 @@ nm_setting_ip6_config_class_init (NMSettingIP6ConfigClass *setting_class)
 	/**
 	 * NMSettingIP6Config:ignore-auto-routes:
 	 *
-	 * When the method is set to 'auto' and this property to TRUE, automatically
-	 * configured routes are ignored and only routes specified in
-	 * #NMSettingIP6Config:routes, if any, are used.
+	 * When the method is set to 'auto' or 'dhcp' and this property is set to
+	 * TRUE, automatically configured routes are ignored and only routes
+	 * specified in #NMSettingIP6Config:routes, if any, are used.
 	 **/
 	g_object_class_install_property
 		(object_class, PROP_IGNORE_AUTO_ROUTES,
 		 g_param_spec_boolean (NM_SETTING_IP6_CONFIG_IGNORE_AUTO_ROUTES,
 						   "Ignore automatic routes",
-						   "When the method is set to 'auto' and this property "
-						   "to TRUE, automatically configured routes are "
-						   "ignored and only routes specified in the 'routes' "
-						   "property, if any, are used.",
+						   "When the method is set to 'auto' or 'dhcp' and this "
+						   "property is set to TRUE, automatically configured "
+						   "routes are ignored and only routes specified in the "
+						   "'routes' property, if any, are used.",
 						   FALSE,
 						   G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
 	/**
 	 * NMSettingIP6Config:ignore-auto-dns:
 	 *
-	 * When the method is set to 'auto' and this property to TRUE, automatically
-	 * configured nameservers and search domains are ignored and only namservers
-	 * and search domains specified in #NMSettingIP6Config:dns and
-	 * #NMSettingIP6Config:dns-search, if any, are used.
+	 * When the method is set to 'auto' or 'dhcp' and this property is set to
+	 * TRUE, automatically configured nameservers and search domains are ignored
+	 * and only nameservers and search domains specified in
+	 * #NMSettingIP6Config:dns and #NMSettingIP6Config:dns-search, if any, are
+	 * used.
 	 **/
 	g_object_class_install_property
 		(object_class, PROP_IGNORE_AUTO_DNS,
 		 g_param_spec_boolean (NM_SETTING_IP6_CONFIG_IGNORE_AUTO_DNS,
 						   "Ignore DHCPv6/RDNSS DNS",
-						   "When the method is set to 'auto' and this property "
-						   "to TRUE, automatically configured nameservers and "
-						   "search domains are ignored and only namservers and "
-						   "search domains specified in the 'dns' and 'dns-search' "
-						   "properties, if any, are used.",
+						   "When the method is set to 'auto' or 'dhcp' and this "
+						   "property is set to TRUE, automatically configured "
+						   "nameservers and search domains are ignored and only "
+						   "nameservers and search domains specified in the 'dns' "
+						   "and 'dns-search' properties, if any, are used.",
 						   FALSE,
 						   G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
diff --git a/libnm-util/nm-setting-ip6-config.h b/libnm-util/nm-setting-ip6-config.h
index 18082e4..b089679 100644
--- a/libnm-util/nm-setting-ip6-config.h
+++ b/libnm-util/nm-setting-ip6-config.h
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  */
 
 #ifndef NM_SETTING_IP6_CONFIG_H
@@ -65,6 +65,7 @@ GQuark nm_setting_ip6_config_error_quark (void);
 
 #define NM_SETTING_IP6_CONFIG_METHOD_IGNORE     "ignore"
 #define NM_SETTING_IP6_CONFIG_METHOD_AUTO       "auto"
+#define NM_SETTING_IP6_CONFIG_METHOD_DHCP       "dhcp"
 #define NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL "link-local"
 #define NM_SETTING_IP6_CONFIG_METHOD_MANUAL     "manual"
 #define NM_SETTING_IP6_CONFIG_METHOD_SHARED     "shared"
diff --git a/libnm-util/nm-utils.c b/libnm-util/nm-utils.c
index 8ec872d..5ca3014 100644
--- a/libnm-util/nm-utils.c
+++ b/libnm-util/nm-utils.c
@@ -21,7 +21,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2005 - 2009 Red Hat, Inc.
+ * (C) Copyright 2005 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -624,7 +624,7 @@ nm_utils_convert_uint_array_to_string (const GValue *src_value, GValue *dest_val
 }
 
 static void
-nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValue *dest_value)
+nm_utils_convert_ip4_addr_route_struct_array_to_string (const GValue *src_value, GValue *dest_value)
 {
 	GPtrArray *ptr_array;
 	GString *printable;
@@ -639,6 +639,7 @@ nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValu
 		GArray *array;
 		char buf[INET_ADDRSTRLEN + 1];
 		struct in_addr addr;
+		gboolean is_addr; /* array contains address x route */
 
 		if (i > 0)
 			g_string_append (printable, ", ");
@@ -649,13 +650,17 @@ nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValu
 			g_string_append (printable, "invalid");
 			continue;
 		}
+		is_addr = (array->len < 4);
 
 		memset (buf, 0, sizeof (buf));
 		addr.s_addr = g_array_index (array, guint32, 0);
 		if (!inet_ntop (AF_INET, &addr, buf, INET_ADDRSTRLEN))
 			nm_warning ("%s: error converting IP4 address 0x%X",
 			            __func__, ntohl (addr.s_addr));
-		g_string_append_printf (printable, "ip = %s", buf);
+		if (is_addr)
+			g_string_append_printf (printable, "ip = %s", buf);
+		else
+			g_string_append_printf (printable, "dst = %s", buf);
 		g_string_append (printable, ", ");
 
 		memset (buf, 0, sizeof (buf));
@@ -670,7 +675,18 @@ nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValu
 			if (!inet_ntop (AF_INET, &addr, buf, INET_ADDRSTRLEN))
 				nm_warning ("%s: error converting IP4 address 0x%X",
 				            __func__, ntohl (addr.s_addr));
-			g_string_append_printf (printable, "gw = %s", buf);
+			if (is_addr)
+				g_string_append_printf (printable, "gw = %s", buf);
+			else
+				g_string_append_printf (printable, "nh = %s", buf);
+		}
+
+		if (array->len > 3) {
+			g_string_append (printable, ", ");
+
+			memset (buf, 0, sizeof (buf));
+			g_string_append_printf (printable, "mt = %u",
+			                        g_array_index (array, guint32, 3));
 		}
 
 		g_string_append (printable, " }");
@@ -764,6 +780,203 @@ nm_utils_convert_byte_array_to_string (const GValue *src_value, GValue *dest_val
 	g_string_free (printable, FALSE);
 }
 
+static gboolean
+nm_utils_inet6_ntop (struct in6_addr *addr, char *buf)
+{
+	if (!inet_ntop (AF_INET6, addr, buf, INET6_ADDRSTRLEN)) {
+		int i;
+		GString *ip6_str = g_string_new (NULL);
+		g_string_append_printf (ip6_str, "%02X", addr->s6_addr[0]);
+		for (i = 1; i < 16; i++)
+			g_string_append_printf (ip6_str, " %02X", addr->s6_addr[i]);
+		nm_warning ("%s: error converting IP6 address %s",
+		            __func__, ip6_str->str);
+		g_string_free (ip6_str, TRUE);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static void
+nm_utils_convert_ip6_dns_array_to_string (const GValue *src_value, GValue *dest_value)
+{
+	GPtrArray *ptr_array;
+	GString *printable;
+	guint i = 0;
+
+	g_return_if_fail (g_type_is_a (G_VALUE_TYPE (src_value), DBUS_TYPE_G_ARRAY_OF_ARRAY_OF_UCHAR));
+
+	ptr_array = (GPtrArray *) g_value_get_boxed (src_value);
+
+	printable = g_string_new ("[");
+	while (ptr_array && (i < ptr_array->len)) {
+		GByteArray *bytearray;
+		char buf[INET6_ADDRSTRLEN];
+		struct in6_addr *addr;
+
+		if (i > 0)
+			g_string_append (printable, ", ");
+
+		bytearray = (GByteArray *) g_ptr_array_index (ptr_array, i++);
+		if (bytearray->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) bytearray->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "%s", buf);
+	}
+	g_string_append_c (printable, ']');
+
+	g_value_take_string (dest_value, printable->str);
+	g_string_free (printable, FALSE);
+}
+
+static void
+nm_utils_convert_ip6_addr_struct_array_to_string (const GValue *src_value, GValue *dest_value)
+{
+	GPtrArray *ptr_array;
+	GString *printable;
+	guint i = 0;
+
+	g_return_if_fail (g_type_is_a (G_VALUE_TYPE (src_value), DBUS_TYPE_G_ARRAY_OF_IP6_ADDRESS));
+
+	ptr_array = (GPtrArray *) g_value_get_boxed (src_value);
+
+	printable = g_string_new ("[");
+	while (ptr_array && (i < ptr_array->len)) {
+		GValueArray *elements;
+		GValue *tmp;
+		GByteArray *ba_addr;
+		char buf[INET6_ADDRSTRLEN];
+		struct in6_addr *addr;
+		guint32 prefix;
+
+		if (i > 0)
+			g_string_append (printable, ", ");
+
+		g_string_append (printable, "{ ");
+		elements = (GValueArray *) g_ptr_array_index (ptr_array, i++);
+		if (   (elements->n_values != 2)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 0)) != DBUS_TYPE_G_UCHAR_ARRAY)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 1)) != G_TYPE_UINT)) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+
+		/* IPv6 address */
+		tmp = g_value_array_get_nth (elements, 0);
+		ba_addr = g_value_get_boxed (tmp);
+		if (ba_addr->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) ba_addr->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "ip = %s", buf);
+		g_string_append (printable, ", ");
+
+		/* Prefix */
+		tmp = g_value_array_get_nth (elements, 1);
+		prefix = g_value_get_uint (tmp);
+		if (prefix > 128) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		g_string_append_printf (printable, "px = %u", prefix);
+		g_string_append (printable, " }");
+	}
+	g_string_append_c (printable, ']');
+
+	g_value_take_string (dest_value, printable->str);
+	g_string_free (printable, FALSE);
+}
+
+static void
+nm_utils_convert_ip6_route_struct_array_to_string (const GValue *src_value, GValue *dest_value)
+{
+	GPtrArray *ptr_array;
+	GString *printable;
+	guint i = 0;
+
+	g_return_if_fail (g_type_is_a (G_VALUE_TYPE (src_value), DBUS_TYPE_G_ARRAY_OF_IP6_ROUTE));
+
+	ptr_array = (GPtrArray *) g_value_get_boxed (src_value);
+
+	printable = g_string_new ("[");
+	while (ptr_array && (i < ptr_array->len)) {
+		GValueArray *elements;
+		GValue *tmp;
+		GByteArray *ba_addr;
+		char buf[INET6_ADDRSTRLEN];
+		struct in6_addr *addr;
+		guint32 prefix, metric;
+
+		if (i > 0)
+			g_string_append (printable, ", ");
+
+		g_string_append (printable, "{ ");
+		elements = (GValueArray *) g_ptr_array_index (ptr_array, i++);
+		if (   (elements->n_values != 4)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 0)) != DBUS_TYPE_G_UCHAR_ARRAY)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 1)) != G_TYPE_UINT)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 2)) != DBUS_TYPE_G_UCHAR_ARRAY)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 3)) != G_TYPE_UINT)) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+
+		/* Destination address */
+		tmp = g_value_array_get_nth (elements, 0);
+		ba_addr = g_value_get_boxed (tmp);
+		if (ba_addr->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) ba_addr->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "dst = %s", buf);
+		g_string_append (printable, ", ");
+
+		/* Prefix */
+		tmp = g_value_array_get_nth (elements, 1);
+		prefix = g_value_get_uint (tmp);
+		if (prefix > 128) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		g_string_append_printf (printable, "px = %u", prefix);
+		g_string_append (printable, ", ");
+
+		/* Next hop addresses */
+		tmp = g_value_array_get_nth (elements, 2);
+		ba_addr = g_value_get_boxed (tmp);
+		if (ba_addr->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) ba_addr->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "nh = %s", buf);
+		g_string_append (printable, ", ");
+
+		/* Metric */
+		tmp = g_value_array_get_nth (elements, 3);
+		metric = g_value_get_uint (tmp);
+		g_string_append_printf (printable, "mt = %u", metric);
+
+		g_string_append (printable, " }");
+	}
+	g_string_append_c (printable, ']');
+
+	g_value_take_string (dest_value, printable->str);
+	g_string_free (printable, FALSE);
+}
+
 void
 _nm_utils_register_value_transformations (void)
 {
@@ -781,7 +994,7 @@ _nm_utils_register_value_transformations (void)
 		                                 nm_utils_convert_uint_array_to_string);
 		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_ARRAY_OF_UINT,
 		                                 G_TYPE_STRING, 
-		                                 nm_utils_convert_ip4_addr_struct_array_to_string);
+		                                 nm_utils_convert_ip4_addr_route_struct_array_to_string);
 		g_value_register_transform_func (DBUS_TYPE_G_MAP_OF_VARIANT,
 		                                 G_TYPE_STRING, 
 		                                 nm_utils_convert_gvalue_hash_to_string);
@@ -791,6 +1004,15 @@ _nm_utils_register_value_transformations (void)
 		g_value_register_transform_func (DBUS_TYPE_G_UCHAR_ARRAY,
 		                                 G_TYPE_STRING,
 		                                 nm_utils_convert_byte_array_to_string);
+		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_ARRAY_OF_UCHAR,
+		                                 G_TYPE_STRING, 
+		                                 nm_utils_convert_ip6_dns_array_to_string);
+		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_IP6_ADDRESS,
+		                                 G_TYPE_STRING, 
+		                                 nm_utils_convert_ip6_addr_struct_array_to_string);
+		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_IP6_ROUTE,
+		                                 G_TYPE_STRING, 
+		                                 nm_utils_convert_ip6_route_struct_array_to_string);
 		registered = TRUE;
 	}
 }
@@ -1209,6 +1431,41 @@ nm_utils_ip4_prefix_to_netmask (guint32 prefix)
 }
 
 
+/**
+ * nm_utils_ip4_get_default_prefix:
+ * @ip: an IPv4 address (in network byte order)
+ *
+ * When the Internet was originally set up, various ranges of IP addresses were
+ * segmented into three network classes: A, B, and C.  This function will return
+ * a prefix that is associated with the IP address specified defining where it
+ * falls in the predefined classes.
+ *
+ * Returns: the default class prefix for the given IP
+ **/
+/* The function is originally from ipcalc.c of Red Hat's initscripts. */
+guint32
+nm_utils_ip4_get_default_prefix (guint32 ip)
+{
+	if (((ntohl (ip) & 0xFF000000) >> 24) <= 127)
+		return 8;  /* Class A - 255.0.0.0 */
+	else if (((ntohl (ip) & 0xFF000000) >> 24) <= 191)
+		return 16;  /* Class B - 255.255.0.0 */
+
+	return 24;  /* Class C - 255.255.255.0 */
+}
+
+/**
+ * nm_utils_ip6_addresses_from_gvalue:
+ * @value: gvalue containing a GPtrArray of GValueArrays of (GArray of guchars) and guint32
+ *
+ * Utility function to convert a #GPtrArray of #GValueArrays of (#GArray of guchars) and guint32
+ * representing a list of NetworkManager IPv6 addresses (which is a pair of address
+ * and prefix), into a GSList of #NMIP6Address objects.  The specific format of
+ * this serialization is not guaranteed to be stable and the #GValueArray may be
+ * extended in the future.
+ *
+ * Returns: a newly allocated #GSList of #NMIP6Address objects
+ **/
 GSList *
 nm_utils_ip6_addresses_from_gvalue (const GValue *value)
 {
@@ -1257,6 +1514,19 @@ nm_utils_ip6_addresses_from_gvalue (const GValue *value)
 	return g_slist_reverse (list);
 }
 
+/**
+ * nm_utils_ip6_addresses_to_gvalue:
+ * @list: a list of #NMIP6Address objects
+ * @value: a pointer to a #GValue into which to place the converted addresses,
+ * which should be unset by the caller (when no longer needed) with
+ * g_value_unset().
+ *
+ * Utility function to convert a #GSList of #NMIP6Address objects into a
+ * GPtrArray of GValueArrays of (GArray or guchars) and guint32 representing a list
+ * of NetworkManager IPv6 addresses (which is a pair of address and prefix).
+ * The specific format of this serialization is not guaranteed to be stable and may be
+ * extended in the future.
+ **/
 void
 nm_utils_ip6_addresses_to_gvalue (GSList *list, GValue *value)
 {
@@ -1291,6 +1561,19 @@ nm_utils_ip6_addresses_to_gvalue (GSList *list, GValue *value)
 	g_value_take_boxed (value, addresses);
 }
 
+/**
+ * nm_utils_ip6_routes_from_gvalue:
+ * @value: gvalue containing a GPtrArray of GValueArrays of (GArray or guchars), guint32,
+ * (GArray of guchars), and guint32
+ *
+ * Utility function GPtrArray of GValueArrays of (GArray or guchars), guint32,
+ * (GArray of guchars), and guint32 representing a list of NetworkManager IPv6
+ * routes (which is a tuple of destination, prefix, next hop, and metric)
+ * into a GSList of #NMIP6Route objects.  The specific format of this serialization
+ * is not guaranteed to be stable and may be extended in the future.
+ *
+ * Returns: a newly allocated #GSList of #NMIP6Route objects
+ **/
 GSList *
 nm_utils_ip6_routes_from_gvalue (const GValue *value)
 {
@@ -1343,6 +1626,19 @@ nm_utils_ip6_routes_from_gvalue (const GValue *value)
 	return g_slist_reverse (list);
 }
 
+/**
+ * nm_utils_ip6_routes_to_gvalue:
+ * @list: a list of #NMIP6Route objects
+ * @value: a pointer to a #GValue into which to place the converted routes,
+ * which should be unset by the caller (when no longer needed) with
+ * g_value_unset().
+ *
+ * Utility function to convert a #GSList of #NMIP6Route objects into a GPtrArray of
+ * GValueArrays of (GArray or guchars), guint32, (GArray of guchars), and guint32
+ * representing a list of NetworkManager IPv6 routes (which is a tuple of destination,
+ * prefix, next hop, and metric).  The specific format of this serialization is not 
+ * guaranteed to be stable and may be extended in the future.
+ **/
 void
 nm_utils_ip6_routes_to_gvalue (GSList *list, GValue *value)
 {
diff --git a/libnm-util/nm-utils.h b/libnm-util/nm-utils.h
index bbb304f..8308a23 100644
--- a/libnm-util/nm-utils.h
+++ b/libnm-util/nm-utils.h
@@ -20,7 +20,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2005 - 2008 Red Hat, Inc.
+ * (C) Copyright 2005 - 2010 Red Hat, Inc.
  */
 
 #ifndef NM_UTILS_H
@@ -192,6 +192,7 @@ void nm_utils_ip4_routes_to_gvalue (GSList *list, GValue *value);
 
 guint32 nm_utils_ip4_netmask_to_prefix (guint32 netmask);
 guint32 nm_utils_ip4_prefix_to_netmask (guint32 prefix);
+guint32 nm_utils_ip4_get_default_prefix (guint32 ip);
 
 GSList *nm_utils_ip6_addresses_from_gvalue (const GValue *value);
 void nm_utils_ip6_addresses_to_gvalue (GSList *list, GValue *value);
diff --git a/libnm-util/tests/test-settings-defaults.c b/libnm-util/tests/test-settings-defaults.c
index 7f0adc5..9f38a14 100644
--- a/libnm-util/tests/test-settings-defaults.c
+++ b/libnm-util/tests/test-settings-defaults.c
@@ -118,7 +118,7 @@ int main (int argc, char **argv)
 	test_defaults (NM_TYPE_SETTING_CDMA, NM_SETTING_CDMA_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_GSM, NM_SETTING_GSM_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_IP4_CONFIG, NM_SETTING_IP4_CONFIG_SETTING_NAME);
-//	test_defaults (NM_TYPE_SETTING_IP6_CONFIG, NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	test_defaults (NM_TYPE_SETTING_IP6_CONFIG, NM_SETTING_IP6_CONFIG_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_PPP, NM_SETTING_PPP_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_PPPOE, NM_SETTING_PPPOE_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_SERIAL, NM_SETTING_SERIAL_SETTING_NAME);
diff --git a/man/Makefile.am b/man/Makefile.am
index c3000d7..7cbc5a1 100644
--- a/man/Makefile.am
+++ b/man/Makefile.am
@@ -1,8 +1,15 @@
 man_MANS =				\
 	NetworkManager.8		\
+	NetworkManager.conf.5		\
+	nm-system-settings.conf.5	\
 	nm-tool.1
 
 EXTRA_DIST =				\
 	$(man_MANS)			\
 	NetworkManager.8.in		\
+	NetworkManager.conf.5.in	\
+	nm-system-settings.conf.5.in	\
 	nm-tool.1.in
+
+CLEANFILES = $(man_MANS)
+
diff --git a/man/NetworkManager.8.in b/man/NetworkManager.8.in
index 426cc7b..a6be073 100644
--- a/man/NetworkManager.8.in
+++ b/man/NetworkManager.8.in
@@ -1,14 +1,14 @@
 .\" NetworkManager(8) manual page
 .\"
-.\" Copyright (C) 2005 - 2009 Red Hat, Inc.
+.\" Copyright (C) 2005 - 2010 Red Hat, Inc.
 .\" Copyright (C) 2005 - 2009 Novell, Inc.
 .\" Copyright (C) 2005 Robert Love
 .\"
-.TH NETWORKMANAGER "8"
+.TH NETWORKMANAGER "8" "January 29, 2010"
 .SH NAME
 NetworkManager \- network management daemon
 .SH SYNOPSIS
-.B NetworkManager [\-\-no-daemon]
+.B NetworkManager [\-\-no\-daemon] [\-\-pid\-file=<filename>] [\-\-state\-file=<filename>] [\-\-config=<filename>] [\-\-plugins=<plugin1>,plugin2>,...] [\-\-log\-level=<level>] [\-\-log\-domains=<domain1>,<domain2>,...]
 .SH DESCRIPTION
 The \fINetworkManager\fP daemon attempts to make  networking configuration and
 operation as painless and automatic as possible by managing the primary network
@@ -18,7 +18,7 @@ connection for that device becomes available, unless that behavior is disabled.
 Information about networking is exported via a D-Bus interface to any interested
 application, providing a rich API with which to inspect and control network
 settings and operation.
-.TP
+.P
 NetworkManager will execute scripts in the /etc/NetworkManager/dispatcher.d
 directory in alphabetical order in response to network events.  Each script
 should be (a) a regular file, (b) owned by root, (c) not writable by group or
@@ -29,12 +29,12 @@ and second an action.
 .I "up"
 The interface has been activated.  The environment contains more information
 about the interface; CONNECTION_UUID contains the UUID of the connection.  Other
-variables are IP4_ADDRESS_N where N is a number from 0 to (# IPv4 addresses - 1),
+variables are IP4_ADDRESS_N where N is a number from 0 to (# IPv4 addresses \- 1),
 in the format "address/prefix gateway".  IP4_NUM_ADDRESSES contains the number
 addresses the script may expect.  IP4_NAMESERVERS contains a space-separated
 list of the DNS servers, and IP4_DOMAINS contains a space-separated list of the
 search domains.  Routes use the format IP4_ROUTE_N where N is a number from 0
-to (# IPv4 routes - 1), in the format "address/prefix next-hop metric", and
+to (# IPv4 routes \- 1), in the format "address/prefix next-hop metric", and
 IP4_NUM_ROUTES contains the number of routes to expect.  If the connection used
 DHCP for address configuration, the received DHCP configuration is passed in the
 environment using standard DHCP option names, prefixed with "DHCP4_", like
@@ -43,11 +43,11 @@ environment using standard DHCP option names, prefixed with "DHCP4_", like
 .I "down"
 The interface has been deactivated.
 .TP
-.I "vpn-up"
+.I "vpn\-up"
 A VPN connection has been activated.  The environment contains the connection
 UUID in the variable CONNECTION_UUID.
 .TP
-.I "vpn-down"
+.I "vpn\-down"
 A VPN connection has been deactivated.
 .TP
 .I "hostname"
@@ -55,21 +55,54 @@ The system hostname has been updated.  Use gethostname(2) to retrieve it.
 .SH OPTIONS
 The following options are supported:
 .TP
-.I "--no-daemon"
+.I "\-\-no\-daemon"
 Do not daemonize.  This is useful for debugging, and directs log output to the
 controlling terminal in addition to syslog.
+.TP
+.I "\-\-pid\-file=<filename>"
+Specify location of a PID file.  The PID file is used for storing PID of the
+running proccess and prevents running multiple instances.
+.TP
+.I "\-\-state\-file=<filename>"
+Specify file for storing state of the NetworkManager persistently.  If not specified,
+the default value of '<LOCALSTATEDIR>/lib/NetworkManager/NetworkManager.state' is
+used; where <LOCALSTATEDIR> is dependent on your distribution (usually it's /var).
+.TP
+.I "\-\-config=<filename>"
+Specify configuration file to set up various settings for NetworkManager.  If not
+specified, the default value of '<SYSCONFDIR>/NetworkManager/NetworkManager.conf'
+is used with a fallback to the older 'nm\-system\-settings.conf' if located in
+the same directory; where <SYSCONFDIR> is dependent on your distribution (usually
+it's /etc).  See \fBNetworkManager.conf\fP(5) for more information on configuration
+file.
+.TP
+.I "\-\-plugins=<plugin1>,<plugin2>, ...
+List plugins used to manage system-wide connection settings.   This list has
+preference over plugins specified in the configuration file.  Currently supported
+plugins are: keyfile, ifcfg\-rh, ifcfg\-suse, ifupdown.
+See \fBNetworkManager.conf\fP(5) for more information on the plugins.
+.TP
+.I "\-\-log\-level=<level>
+Sets how much information NetworkManager sends to the log destination (usually
+syslog's "daemon" facility).  By default, only informational, warning, and error
+messages are logged.  See \fBNetworkManager.conf\fP(5) for more information on
+log levels and domains.
+.TP
+.I "\-\-log\-domains=<domain1>,<domain2>, ...
+Sets which operations are logged to the log destination (usually syslog).  By
+default, most domains are logging-enabled.  See \fBNetworkManager.conf\fP(5) for
+more information on log levels and domains.
 .SH DEBUGGING
 The following environment variables are supported to help debugging.  When used
-in conjunction with the "--no-daemon" option (thus echoing PPP and DHCP helper
+in conjunction with the "\-\-no\-daemon" option (thus echoing PPP and DHCP helper
 output to stdout) these can quickly help pinpoint the source of connection
-issues.
-.TP
-.I "NM_SERIAL_DEBUG"
-When set to anything, causes NetworkManager to log all serial communication to
-and from serial devices like mobile broadband 3G modems.
+issues.  Also see the \-\-log\-level and \-\-log\-domains to enable debug logging inside
+NetworkManager itself.
 .TP
 .I "NM_PPP_DEBUG"
 When set to anything, causes NetworkManager to turn on PPP debugging in pppd,
 which logs all PPP and PPTP frames and client/server exchanges.
 .SH SEE ALSO
-.BR nm-tool (1)
+.BR nm\-tool (1),
+.BR NetworkManager.conf (5).
+
diff --git a/man/NetworkManager.conf.5.in b/man/NetworkManager.conf.5.in
new file mode 100644
index 0000000..c3af611
--- /dev/null
+++ b/man/NetworkManager.conf.5.in
@@ -0,0 +1,139 @@
+.\" NetworkManager.conf(5) manual page
+.\"
+.\" Copyright (C) 2010 Red Hat, Inc.
+.\"
+.TH "NetworkManager.conf" "5" "1 February 2010" ""
+.SH NAME
+NetworkManager.conf \- NetworkManager configuration file
+.SH SYNOPSIS
+/etc/NetworkManager/NetworkManager.conf
+.br
+or
+.br
+\fI<SYSCONFDIR>\fP/NetworkManager/NetworkManager.conf
+.br
+where <SYSCONFDIR> depends on your distribution or build.
+.SH DESCRIPTION
+.P
+.I NetworkManager.conf
+is a configuration file for NetworkManager. It is used to set up various
+aspects of NetworkManager's behavior. The location of
+the file may be changed through use of the "\-\-config=" argument for
+\fBNetworkManager\fP (8).
+
+It is not necessary to restart NetworkManager when making changes, as the
+configuration file is watched for changes and reloaded automatically when necessary.
+.SH "FILE FORMAT"
+.P
+The configuration file format is so-called key file (sort of ini-style format).
+It consists of sections (groups) of key-value pairs. Lines beginning with a '#' and blank
+lines are considered comments. Sections are started by a header line containing
+the section enclosed in '[' and ']', and ended implicitly by the start of
+the next section or the end of the file. Each key-value pair must be contained
+in a section.
+.br
+Minimal system settings configuration file looks like this:
+.P
+.nf
+[main]
+plugins=keyfile
+.fi
+.P
+Description of sections and available keys follows:
+.SS [main]
+This section is the only mandatory section of the configuration file.
+.TP
+.B plugins=\fIplugin1\fP,\fIplugin2\fP, ...
+List plugin names separated by ','. Plugins are used to read/write system-wide
+connection. When more plugins are specified, the connections are read from all
+listed plugins. When writing connections, the plugins will be asked to save the
+connection in the order listed here. If the first plugin cannot write out that
+connection type, or can't write out any connections, the next plugin is tried.
+If none of the plugins can save the connection, the error is returned to the user.
+.P
+.RS
+.B "Available plugins:"
+.br
+.TP 
+.I keyfile
+plugin is the generic plugin that supports all the connection types and
+capabilities that NetworkManager has. It writes files out in a .ini-style format in
+/etc/NetworkManager/system-connections. For security, it will ignore files
+that are readable or writeable by any user or group other than
+.I root
+since private keys and passphrases may be stored in plaintext inside the file.
+.TP 
+.I ifcfg\-rh
+plugin is used on the Fedora and Red Hat Enterprise Linux distributions
+to read and write configuration from the standard /etc/sysconfig/network-scripts/ifcfg-* files.
+It currently supports reading wired, WiFi, and 802.1x connections, but does not yet support reading
+or writing mobile broadband, PPPoE, or VPN connections. To allow reading and writing of these
+add \fIkeyfile\fP plugin to your configuration as well.
+.TP
+.I ifupdown
+plugin is used on the Debian and Ubuntu distributions, and reads connections from
+/etc/network/interfaces. Since it cannot write connections out (that support isn't planned),
+it is usually paired with the \fIkeyfile\fP plugin to enable saving and editing of new connections.
+The \fIifupdown\fP plugin supports basic wired and WiFi connections, including WPA-PSK.
+.TP
+.I ifcfg\-suse
+plugin is only provided for simple backward compatibility with SUSE and OpenSUSE configuration.
+Most setups should be using the \fIkeyfile\fP plugin instead. The \fIifcfg\-suse\fP plugin supports
+reading wired and WiFi connections, but does not support saving any connection types.
+.RE
+.TP
+.B dhcp=\fIdhclient\fP | \fIdhcpcd\fP
+This key sets up what DHCP client NetworkManager will use. Presently
+\fIdhclient\fP and \fIdhcpcd\fP are supported. The client configured here should
+be available on your system too. If this key is missing, available DHCP clients
+are looked for in this order: dhclient, dhcpcd.
+.SS [keyfile]
+This section contains keyfile-specific options and thus only has effect when using \fIkeyfile\fP plugin.
+.TP
+.B hostname=\fI<hostname>\fP
+Set a persistent hostname when using the \fIkeyfile\fP plugin.
+.TP
+.B unmanaged-devices=\fImac:<hwaddr>\fP;\fImac:<hwaddr>\fP;...
+Set devices that should be ignored by NetworkManager when using the \fIkeyfile\fP
+plugin. Devices are specified in the following format: "mac:<hwaddr>", where
+<hwaddr> is MAC address of the device to be ignored, in lowercase. Multiple
+entries are separated by a semicolon. Example:
+.nf
+unmanaged-devices=mac:00:22:68:1c:59:b1;mac:00:1e:65:30:d1:c4
+.fi
+.SS [ifupdown]
+This section contains ifupdown-specific options and thus only has effect when using \fIifupdown\fP plugin.
+.TP
+.B managed=\fIfalse\fP | \fItrue\fP
+Controls whether interfaces listed in the 'interfaces' file are managed by NetworkManager.
+If set to \fItrue\fP, then interfaces listed in /etc/network/interfaces are managed by NetworkManager.
+If set to \fIfalse\fP, then any interface listed in /etc/network/interfaces will be
+ignored by NetworkManager. Remember that NetworkManager controls the default route,
+so because the interface is ignored, NetworkManager may assign the default route to
+some other interface.
+When the option is missing, \fIfalse\fP value is taken as default.
+.SS [logging]
+This section controls NetworkManager's logging.  Any settings here are
+overridden by the \-\-log\-level and \-\-log\-domains command-line options.
+.TP
+.B level=\fI<level>\fP
+One of [ERR, WARN, INFO, DEBUG].  The ERR level logs only critical errors.  WARN
+logs warnings that may reflect operation.  INFO logs various informational
+messages that are useful for tracking state and operations.  DEBUG enables
+verbose logging for debugging purposes.  Subsequent levels also log all messages
+from earlier levels; thus setting the log level to INFO also logs error and
+warning messages.
+.TP
+.B domains=\fI<domain1>,<domain2>, ...\fP
+The following log domains are available: [NONE, HW, RKILL, ETHER, WIFI, BT, MB,
+DHCP4, DHCP6, PPP, WIFI_SCAN, IP4, IP6, AUTOIP4, DNS, VPN, SHARING, SUPPLICANT,
+USER_SET, SYS_SET, SUSPEND, CORE, DEVICE, OLPC].  When "NONE" is given by itself,
+logging is disabled.  MB = Mobile Broadband, USER_SET = user settings operations
+and communication, SYS_SET = system settings service operations, OLPC = OLPC
+Mesh device operations, CORE = core daemon operations, DEVICE = activation and
+general interface operations.
+.SH "SEE ALSO"
+.BR http://live.gnome.org/NetworkManager/SystemSettings
+.sp
+.BR NetworkManager (8),
+.BR nm\-tool (1).
diff --git a/man/nm-system-settings.conf.5.in b/man/nm-system-settings.conf.5.in
new file mode 100644
index 0000000..e48d0c8
--- /dev/null
+++ b/man/nm-system-settings.conf.5.in
@@ -0,0 +1,26 @@
+.\" nm-system-settings.conf(5) manual page
+.\"
+.\" Copyright (C) 2010 Red Hat, Inc.
+.\"
+.TH "nm-system-settings.conf" "5" "1 February 2010" ""
+.SH NAME
+nm\-system\-settings.conf \- Deprecated NetworkManager configuration file
+.SH SYNOPSIS
+/etc/NetworkManager/nm\-system\-settings.conf
+.br
+or
+.br
+\fI<SYSCONFDIR>\fP/NetworkManager/nm\-system\-settings.conf
+.br
+where <SYSCONFDIR> depends on your distribution or build.
+.SH DESCRIPTION
+.P
+.I nm\-system\-settings.conf
+is a deprecated configuration file for \fBNetworkManager\fP (5).  While this
+file can still be used, NetworkManager now defaults to reading the config
+file <SYSCONFDIR>\fP/NetworkManager/NetworkManager.conf\fP instead, falling back
+to nm\-system\-settings.conf if NetworkManager.conf does not exist.
+.SH "SEE ALSO"
+.BR NetworkManager (8),
+.BR NetworkManager.conf (5),
+.BR nm\-tool (1).
diff --git a/marshallers/nm-marshal.list b/marshallers/nm-marshal.list
index 38669dd..e19f8be 100644
--- a/marshallers/nm-marshal.list
+++ b/marshallers/nm-marshal.list
@@ -16,10 +16,14 @@ VOID:STRING,STRING,STRING,UINT
 VOID:OBJECT,UINT,UINT
 VOID:STRING,INT
 VOID:STRING,UINT
+VOID:STRING,UINT,BOOLEAN
 VOID:OBJECT,OBJECT,ENUM
 VOID:POINTER,STRING
 VOID:STRING,BOXED
 BOOLEAN:POINTER,STRING,BOOLEAN,UINT,STRING,STRING
+VOID:STRING,BOOLEAN,UINT,STRING,STRING
 BOOLEAN:VOID
 VOID:STRING,BOOLEAN
+VOID:STRING,OBJECT,POINTER
+VOID:BOOLEAN,UINT
 
diff --git a/po/LINGUAS b/po/LINGUAS
index 4ab6fac..9494643 100644
--- a/po/LINGUAS
+++ b/po/LINGUAS
@@ -22,6 +22,7 @@ fr
 gl
 gu
 he
+hi
 hr
 hu
 id
@@ -34,6 +35,7 @@ ku
 lt
 lv
 mk
+ml
 mr
 nb
 ne
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 44235ea..2cf4d23 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -1,14 +1,21 @@
 [encoding: UTF-8]
 # List of source files containing translatable strings.
 # Please keep this file sorted alphabetically.
+cli/src/connections.c
+cli/src/devices.c
+cli/src/network-manager.c
+cli/src/nmcli.c
+cli/src/utils.c
 libnm-util/crypto.c
 libnm-util/crypto_gnutls.c
 libnm-util/crypto_nss.c
 libnm-util/nm-utils.c
 src/nm-netlink-monitor.c
-src/NetworkManager.c
+src/main.c
 src/dhcp-manager/nm-dhcp-dhclient.c
+src/dhcp-manager/nm-dhcp-manager.c
 src/ip6-manager/nm-netlink-listener.c
+src/logging/nm-logging.c
 src/named-manager/nm-named-manager.c
 src/system-settings/nm-default-wired-connection.c
 system-settings/plugins/ifcfg-rh/reader.c
diff --git a/po/bn_IN.po b/po/bn_IN.po
index 9a71891..4ace70d 100644
--- a/po/bn_IN.po
+++ b/po/bn_IN.po
@@ -1,17 +1,17 @@
-# translation of NetworkManager.po.master.po to Bengali INDIA
+# translation of NetworkManager.master.po to Bengali INDIA
 # Bengali (India) translation of NetworkManager.
 # Copyright (C) 2009 NetworkManager's COPYRIGHT HOLDER
 # This file is distributed under the same license as the NetworkManager package.
 #
-# Runa Bhattacharjee <runab@redhat.com>, 2009.
+# Runa Bhattacharjee <runab@redhat.com>, 2009, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: NetworkManager.po.master\n"
+"Project-Id-Version: NetworkManager.master\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-06-04 03:24+0000\n"
-"PO-Revision-Date: 2009-06-05 18:45+0530\n"
+"POT-Creation-Date: 2009-09-29 03:25+0000\n"
+"PO-Revision-Date: 2010-02-19 17:25+0530\n"
 "Last-Translator: Runa Bhattacharjee <runab@redhat.com>\n"
-"Language-Team: Bengali INDIA <discuss@lists.ankur.org.in>\n"
+"Language-Team: Bengali INDIA <anubad@lists.ankur.org.in>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
@@ -103,8 +103,9 @@ msgstr "IV    
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV-  -    "
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:335
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "-'  '%s' "
@@ -124,72 +125,111 @@ msgstr "-'  
 msgid "Not enough memory to store decrypted private key."
 msgstr "  -     "
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "    "
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "MD5    : %s / %s"
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "IV-   ( %zd  )"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "  -    "
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "     : %s / %s"
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "  -   : %s / %s"
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "  IV   : %s / %s"
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "-   : %s / %s"
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:266
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "-   :    "
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:277
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "-   "
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:355
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "      "
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "     : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "  -   : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "  IV   : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "   : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr " -  : %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "PKCS#12    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "PKCS#12    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12    : %s"
 
 #: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "    : %d"
@@ -199,105 +239,186 @@ msgstr "   
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "MD5    : %d"
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "IV-   ( %d  )"
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "     "
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "  -   "
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "  IV   "
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "    "
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "-   : %d"
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "-   :     "
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "-'    : %d"
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:363
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "     "
+
+#: ../libnm-util/crypto_nss.c:371
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "  -   "
+
+#: ../libnm-util/crypto_nss.c:379
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "  IV   "
+
+#: ../libnm-util/crypto_nss.c:387
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "    "
+
+#: ../libnm-util/crypto_nss.c:395
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "  : %d"
+
+#: ../libnm-util/crypto_nss.c:403
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "       "
+
+#: ../libnm-util/crypto_nss.c:446
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "   : %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:481
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr " UCS2-   : %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:509
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:518
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:527
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:458
+#: ../libnm-util/crypto_nss.c:556
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "    "
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+#| msgid "Not enough memory to decrypt private key."
+msgid "Not enough memory to make encryption key."
+msgstr "-     "
+
+#: ../libnm-util/nm-utils.c:1633
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM       "
+
+#: ../libnm-util/nm-utils.c:1645
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM   IV      "
+
+#: ../libnm-util/nm-utils.c:1657
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM           "
+
+#: ../libnm-util/nm-utils.c:1676
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM        "
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:569
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "netlink   : %s"
 
-#: ../src/nm-netlink-monitor.c:255
+#: ../src/nm-netlink-monitor.c:260
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
 msgstr "    netlink    : %s"
 
-#: ../src/nm-netlink-monitor.c:265
+#: ../src/nm-netlink-monitor.c:270
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
 msgstr "    netlink-    : %s"
 
-#: ../src/nm-netlink-monitor.c:273
+#: ../src/nm-netlink-monitor.c:278
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
 msgstr "    netlink    : %s"
 
-#: ../src/nm-netlink-monitor.c:281
+#: ../src/nm-netlink-monitor.c:286
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
 msgstr "    netlink     : %s"
 
-#: ../src/nm-netlink-monitor.c:422
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "    "
+
+#: ../src/nm-netlink-monitor.c:558
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "    : %s"
 
-#: ../src/nm-netlink-monitor.c:488
-msgid "error occurred while waiting for data on socket"
-msgstr "    "
-
-#: ../src/NetworkManager.c:296
+#: ../src/NetworkManager.c:330
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr "          --help  \n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:97
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
 msgid "# Created by NetworkManager\n"
 msgstr "# NetworkManager  \n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:103
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -306,28 +427,77 @@ msgstr ""
 "# %s    \n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:255
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "netlink    : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "netlink-    : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "netlink    : %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr ": libc resolver  -  -     "
+msgstr ""
+": libc resolver  -  -     "
+""
 
-#: ../src/named-manager/nm-named-manager.c:257
+#: ../src/named-manager/nm-named-manager.c:317
 msgid "The nameservers listed below may not be recognized."
 msgstr " -     "
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2149
-msgid "System"
-msgstr ""
-
-#: ../system-settings/src/nm-default-wired-connection.c:182
+#: ../src/system-settings/nm-default-wired-connection.c:194
 #, c-format
 msgid "Auto %s"
 msgstr " %s"
 
+#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+msgid "System"
+msgstr ""
+
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr " -     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr " -     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "  -  "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
 msgid "Modify system connections"
 msgstr "   "
 
-#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
 msgid "System policy prevents modification of system settings"
-msgstr "  -        "
+msgstr ""
+"  -        "
+""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+#| msgid "System policy prevents modification of system settings"
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr ""
+"  -     -    "
+""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "  ,  -        "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "  ,  -        "
 
diff --git a/po/cs.po b/po/cs.po
index ed0ac8c..1be6b82 100644
--- a/po/cs.po
+++ b/po/cs.po
@@ -5,269 +5,1382 @@
 # Miloslav Trmac <mitr@volny.cz>, 2004 - 2006.
 # Jakub Friedl <jfriedl@suse.cz>, 2006.
 # Ji Eischmann <jiri@eischmann.cz>, 2008.
-#
+# Marek ernock <marek@manet.cz>, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-09-17 22:27+0200\n"
-"PO-Revision-Date: 2008-09-17 22:08+0200\n"
-"Last-Translator: Petr Kovar <pknbe@volny.cz>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-09 03:24+0000\n"
+"PO-Revision-Date: 2010-04-23 13:02+0200\n"
+"Last-Translator: Marek ernock <marek@manet.cz>\n"
 "Language-Team: Czech <gnome-cs-list@gnome.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"
 
-#: ../src/nm-netlink-monitor.c:193 ../src/nm-netlink-monitor.c:474
+#: ../cli/src/connections.c:86
 #, c-format
-msgid "error processing netlink message: %s"
-msgstr "chyba pi zpracovn zprvy netlink: %s"
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Pouit: nmcli con {PKAZ | help}\n"
+"  PKAZ := {list | status | up | down}\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <rozhran>] [ap <hw_adresa>] [--nowait] [--"
+"timeout <asov_limit>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Pipojen"
 
-#: ../src/nm-netlink-monitor.c:250
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Nzev"
+
+#: ../cli/src/connections.c:163
 #, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "nelze alokovat ovldn netlinku pro sledovn stavu spojen: %s"
+msgid "System connections:\n"
+msgstr "Systmov pipojen:\n"
 
-#: ../src/nm-netlink-monitor.c:260
+#: ../cli/src/connections.c:167
 #, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "nelze se pipojit k netlinku pro sledovn stavu spojen: %s"
+msgid "User connections:\n"
+msgstr "Uivatelsk pipojen:\n"
 
-#: ../src/nm-netlink-monitor.c:268
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
 #, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "nelze se pipojit ke skupin netlink pro sledovn stavu spojen: %s"
+msgid "Error: %s argument is missing."
+msgstr "Chyba: schz argument %s."
 
-#: ../src/nm-netlink-monitor.c:276
+#: ../cli/src/connections.c:189
 #, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgid "Error: %s - no such connection."
+msgstr "Chyba: %s - takov pipojen neexistuje."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Pipojen v rmci systmu"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Uivatelsk pipojen"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Neznm parametr: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Chyba: nezadn dn platn parametr."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ano"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "ne"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Aktivn pipojen"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Vchoz"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Sluba"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Zazen"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "dn aktivn pipojen nebo zazen %s"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "dn aktivn pipojen nebo zazen"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktivuje se"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktivovno"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "neznmo"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN se pipojuje (pprava)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN se pipojuje (poaduje oven)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN se pipojuje"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN se pipojuje (zskv se nastaven IP)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN pipojena"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN se nezdailo pipojit"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN odpojena"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "neznm dvod"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "dn"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "uivatel byl odpojen"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "zkladn sov pipojen bylo perueno"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "sluba VPN neoekvan zastavena"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "sluba VPN vrtila neplatn nastaven"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "pokusu o pipojen vyprel asov limit"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "sluba VPN se nespustila v asovm limitu"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "slubu VPN se nezdailo spustit"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "dn platn utajen VPN"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "neplatn utajen VPN"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "pipojen odstranno"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "stav: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Pipojen aktivovno\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Chyba: Selhala aktivace pipojen."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "stav: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Chyba: Selhala aktivace pipojen: %s"
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Chyba: asov limit %d sekund vyprel."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Chyba: Selhala aktivace pipojen: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Chyba: Zskn aktivnho pipojen pro %s selhalo."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Stav aktivnho pipojen: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Cesta aktivnho pipojen: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Chyba: Neznm pipojen: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Chyba: hodnota asovho limitu %s nen platn."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Chyba: nebylo ureno id nebo uuid."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Chyba: Nenalezeno vhodn zazen: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Chyba: Nenalezeno vhodn zazen."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Varovn: Pipojen nen aktivn\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Chyba: pkaz %s nen pro con platn."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Chyba: nelze se pipojit ke sbrnici D-Bus."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Chyba: Nelze zskat systmov nastaven."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Chyba: Nelze zskat uivatelsk nastaven."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Chyba: Nelze zskat pipojen: sluba sprvy nastaven neb."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"nelze alokovat vyrovnvac pam netlinku pro sledovn stavu spojen: %s"
+"Pouit: nmcli dev {PKAZ | help}\n"
+"\n"
+"  PKAZ := {status | list | disconnect | wifi}\n"
+"\n"
+"  status\n"
+"  list [iface <rozhran>]\n"
+"  disconnect iface <rozhran> [--nowait] [--timeout <asov_limit>]\n"
+"  wifi [list [iface <rozhran>] | apinfo iface <rozhran> hwaddr "
+"<hw_adresa>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "nen pod sprvou"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "nedostupn"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "odpojeno"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "pipojuje se (pprava)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "pipojuje se (nastavovn)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "pipojuje se (poadovno oven)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "pipojuje se (zskv se nastaven IP)"
 
-#: ../src/nm-netlink-monitor.c:439
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "pipojeno"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "pipojen se nezdailo"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Neznm"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(nic)"
+
+#: ../cli/src/devices.c:209
 #, c-format
-msgid "error updating link cache: %s"
-msgstr "chyba pi aktualizaci link cache: %s"
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: chyba pevodu adresy IP4 0x%X"
 
-#: ../src/nm-netlink-monitor.c:497
+#: ../cli/src/devices.c:238
 #, c-format
-msgid "error occurred while waiting for data on socket"
-msgstr "pi ekn na data ze socketu dolo k chyb"
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Frekv %d MHz, Rychlost %d Mb/s, Sla sig %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", ifrovno: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Podnikov"
 
-#: ../src/NetworkManager.c:250
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Zazen"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Ovlada"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(neznmo)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Stav"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW adresa"
+
+#: ../cli/src/devices.c:319
 #, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Neplatn volba. Platn volby uvidte pi pouit --help.\n"
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Schopnosti:\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:89
-msgid "# Created by NetworkManager\n"
-msgstr "# Vytvoeno NetworkManagerem\n"
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Detekce nosnho signlu"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:95
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Rychlost"
+
+#: ../cli/src/devices.c:348
 #, c-format
 msgid ""
-"# Merged from %s\n"
 "\n"
+"  Wireless Properties\n"
 msgstr ""
-"# Sloueno z %s\n"
 "\n"
+"  Vlastnosti bezdrtov sti\n"
 
-#: ../src/named-manager/nm-named-manager.c:256
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr "Poznmka: libc resolver neme podporovat vce ne 3 nameservery."
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "ifrovn WEP"
 
-#: ../src/named-manager/nm-named-manager.c:258
-msgid "The nameservers listed below may not be recognized."
-msgstr "Nameservery uveden v seznamu dole nelze rozpoznat."
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "ifrovn WPA"
 
-#: ../system-settings/src/main.c:366
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "ifrovn WPA2"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "ifra TKIP"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "ifra CCMP"
+
+#: ../cli/src/devices.c:368
 #, c-format
-msgid "Auto %s"
-msgstr "Auto %s"
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Bezdrtov pstupov bod %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = aktuln pstupov bod)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Vlastnosti drtov sti\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Nosn signl"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "zapnut"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "vypnut"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  Nastaven IPv4:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adresa"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Pedsl"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Brna"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Stav zazen"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Chyba: schz argument %s."
 
-#: ../libnm-util/crypto.c:125
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Chyba: Zazen %s nenalezeno."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "spch: Zazen %s spn odpojeno."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Chyba: Odpojen zazen %s (%s) selhalo: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Stav zazen: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Chyba: nebylo ureno rozhran."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Seznam prohledn WiFi"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Chyba: Zazen %s nen zazen WiFi."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Zazen:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Chyba: mus bt urena hardwarov adresa."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Chyba: Pstupov bod s hardwarovou adresou %s nenalezen."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parametry pstupovho bodu"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Kmitoet:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Reim:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastruktura"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Max. penosov rychlost:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Sla signlu:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Pznaky:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "soukrom"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "Pznaky WPA:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "Pznaky RSN:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Chyba: pkaz %s nen pro dev wifi platn."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Chyba: pkaz %s nen pro dev platn."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Pouit: nmcli nm {PKAZ | help}\n"
+"\n"
+"  PKAZ := {status | sleep | wakeup | wifi | wwan}\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "uspn"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "pipojuje se"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "povoleno"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "zakzno"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Stav sprvce st NetworkManager"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "Bh NM:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "b"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "neb"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Stav NM:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "Bezdrtov hardware NM:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "Bezdrtov st NM:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "Hardware WWAN NM"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "St WWAN NM:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Chyba: neplatn parametr pro wifi: %s"
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Chyba: neplatn parametr pro wwan: %s"
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Chyba: pkaz %s nen pro nm platn."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Pouit: %s [PEPNAE] OBJEKT {PKAZ | help}\n"
+"\n"
+"PEPNAE\n"
+"  -t[erse]    strun vpis\n"
+"  -p[retty]   hezk vpis\n"
+"  -v[ersion]  zobrazit verzi programu\n"
+"  -h[elp]     zobrazit tuto npovdu\n"
+"\n"
+"OBJEKT\n"
+"  nm          stav NetworkManageru\n"
+"  con         pipojen v NetworkManageru\n"
+"  dev         zazen spravovan NetworkManagerem\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Objekt %s je neznm, zkuste nmcli help."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nstroj nmcli, verze %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Pepna %s je neznm, zkuste nmcli -help."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Zachycen signl %d, vypn se"
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Chyba: Nelze se pipojit ke sprvci st NetworkManager."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "spch"
+
+#: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
-msgstr "Soubor kle PEM neml koncovou znaku '%s'."
+msgstr "Soubor kle PEM neml koncovou znaku %s."
 
-#: ../libnm-util/crypto.c:135
+#: ../libnm-util/crypto.c:130
 #, c-format
 msgid "Doesn't look like a PEM private key file."
 msgstr "Nevypad jako soubor soukromho kle PEM."
 
-#: ../libnm-util/crypto.c:143
+#: ../libnm-util/crypto.c:138
 #, c-format
 msgid "Not enough memory to store PEM file data."
-msgstr "Nen dostatek pamti na uloen dat PEM souboru."
+msgstr "Nen dostatek pamti pro uloen dat souboru PEM."
 
-#: ../libnm-util/crypto.c:159
+#: ../libnm-util/crypto.c:154
 #, c-format
 msgid "Malformed PEM file: Proc-Type was not first tag."
-msgstr "Nesprvn PEM soubor: Proc-Type nebylo prvn znakou."
+msgstr "Vadn soubor PEM: znaka Proc-Type nebyla prvn znakou."
 
-#: ../libnm-util/crypto.c:167
+#: ../libnm-util/crypto.c:162
 #, c-format
 msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
-msgstr "Nesprvn PEM soubor: neznm znaka Proc-Type '%s'."
+msgstr "Vadn soubor PEM: neznm znaka Proc-Type %s."
 
-#: ../libnm-util/crypto.c:177
+#: ../libnm-util/crypto.c:172
 #, c-format
 msgid "Malformed PEM file: DEK-Info was not the second tag."
-msgstr "Nesprvn PEM soubor: DEK-Info nebylo druhou znakou."
+msgstr "Vadn soubor PEM: znaka DEK-Info nebyla druhou znakou."
 
-#: ../libnm-util/crypto.c:188
+#: ../libnm-util/crypto.c:183
 #, c-format
 msgid "Malformed PEM file: no IV found in DEK-Info tag."
-msgstr "Nesprvn PEM soubor: nebylo nalezeno IV ve znace DEK-Info."
+msgstr "Vadn soubor PEM: nebyl nalezen IV ve znace DEK-Info."
 
-#: ../libnm-util/crypto.c:195
+#: ../libnm-util/crypto.c:190
 #, c-format
 msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
-msgstr "Nesprvn PEM soubor: neplatn formt IV ve znace DEK-Info."
+msgstr "Vadn soubor PEM: neplatn formt IV ve znace DEK-Info."
 
-#: ../libnm-util/crypto.c:208
+#: ../libnm-util/crypto.c:203
 #, c-format
 msgid "Malformed PEM file: unknown private key cipher '%s'."
-msgstr "Nesprvn PEM soubor: neznm ifra soukromho kle '%s'."
+msgstr "Vadn soubor PEM: neznm ifra soukromho kle %s."
 
-#: ../libnm-util/crypto.c:227
+#: ../libnm-util/crypto.c:222
 #, c-format
 msgid "Could not decode private key."
 msgstr "Nelze dekdovat soukrom kl."
 
-#: ../libnm-util/crypto.c:271
+#: ../libnm-util/crypto.c:267
 #, c-format
 msgid "PEM certificate '%s' had no end tag '%s'."
-msgstr "PEM certifikt '%s' nem koncovou znaku '%s'."
+msgstr "Certifikt PEM %s nem koncovou znaku %s."
 
-#: ../libnm-util/crypto.c:281
+#: ../libnm-util/crypto.c:277
 #, c-format
 msgid "Failed to decode certificate."
 msgstr "Selhalo dekdovn certifiktu."
 
-#: ../libnm-util/crypto.c:290 ../libnm-util/crypto.c:298
+#: ../libnm-util/crypto.c:286
 #, c-format
 msgid "Not enough memory to store certificate data."
-msgstr "Nen dostatek pamti na uloen dat certifiktu."
+msgstr "Nedostatek pamti pro uloen dat certifiktu."
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Not enough memory to store file data."
+msgstr "Nedostatek pamti na uloen dat souboru."
 
-#: ../libnm-util/crypto.c:328
+#: ../libnm-util/crypto.c:324
 #, c-format
 msgid "IV must be an even number of bytes in length."
-msgstr "IV mus bt sud slo bajt na dlku."
+msgstr "IV mus mt na dlku sud poet bajt."
 
-#: ../libnm-util/crypto.c:337
+#: ../libnm-util/crypto.c:333
 #, c-format
 msgid "Not enough memory to store the IV."
-msgstr "Nen dostatek pamti pro uloen IV."
+msgstr "Nedostatek pamti pro uloen IV."
 
-#: ../libnm-util/crypto.c:348
+#: ../libnm-util/crypto.c:344
 #, c-format
 msgid "IV contains non-hexadecimal digits."
-msgstr "IV obsahuje neestnctkov slice."
+msgstr "IV obsahuje jin ne estnctkov slice."
 
-#: ../libnm-util/crypto.c:386 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:157
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
-msgstr "ifra soukromho kle '%s' je neznm."
+msgstr "ifra soukromho kle %s je neznm."
 
-#: ../libnm-util/crypto.c:395
+#: ../libnm-util/crypto.c:391
 #, c-format
-msgid "Not enough memory to create private key decryption key."
-msgstr ""
-"Nen dostatek pamti pro vytvoen deifrovacho kle k soukrommu kli."
+#| msgid "Not enough memory to store decrypted private key."
+msgid "Not enough memory to decrypt private key."
+msgstr "Nedostatek pamti pro deifrovn soukromho kle."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Unable to determine private key type."
+msgstr "Nelze urit typ soukromho kle."
 
-#: ../libnm-util/crypto.c:513
+#: ../libnm-util/crypto.c:530
 #, c-format
 msgid "Not enough memory to store decrypted private key."
-msgstr "Nen dostatek pamti pro uloen deifrovanho soukromho kle."
+msgstr "Nedostatek pamti pro uloen deifrovanho soukromho kle."
 
-#: ../libnm-util/crypto_gnutls.c:45
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
-msgstr "Nelze inicializovat ifrovac engine."
+msgstr "Selhala inicializace ifrovacho programu."
 
-#: ../libnm-util/crypto_gnutls.c:89
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
-msgstr "Nelze inicializovat MD5 engine: %s / %s."
+msgstr "Selhala inicializace programu pro MD5: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:166
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Neplatn dlka IV (mus bt nejmn %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
-msgstr "Nen dostatek pamti pro vyrovnvac pam deifrovanho kle."
+msgstr "Nedostatek pamti pro vyrovnvac pam deifrovanho kle."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
-msgstr "Nelze inicializovat kontext dekdovac ifry: %s / %s."
+msgstr "Selhala inicializace kontextu deifrovac ifry: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
-msgstr "Nelze nastavit symetrick kl pro dekdovn: %s / %s."
+msgstr "Selhalo nastaven symetrickho kle pro deifrovn: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
-msgstr "Nelze nastavit IV pro dekdovn: %s / %s."
+msgstr "Selhalo nastaven IV pro dekdovn: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
-msgstr "Nelze dekdovat soukrom kl: %s / %s."
+msgstr "Selhalo dekdovn soukromho kle: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Selhalo deifrovn soukromho kle: neoekvan zarovnn dlky."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key."
+msgstr "Selhalo deifrovn soukromho kle."
 
-#: ../libnm-util/crypto_gnutls.c:225
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Nelze alokovat pam pro ifrovn."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Selhala inicializace kontextu ifrovac ifry: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Selhalo nastaven symetrickho kle pro ifrovn: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Selhalo nastaven IV pro ifrovn: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Selhalo ifrovn dat: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Chyba pi inicializaci dat certifiktu: %s"
 
-#: ../libnm-util/crypto_gnutls.c:237
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "Nelze dekdovat certifikt: %s"
 
-#: ../libnm-util/crypto_nss.c:52
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "Nelze inicializovat dekodr PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "Nelze dekdovat soubor PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "Nelze ovit soubor PKCS#12: %s"
+
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
-msgstr "Nelze inicializovat ifrovac engine: %d."
+msgstr "Selhala inicializace ifrovacho programu: %d."
 
-#: ../libnm-util/crypto_nss.c:98
+#: ../libnm-util/crypto_nss.c:111
 #, c-format
 msgid "Failed to initialize the MD5 context: %d."
-msgstr "Nelze inicializovat MD5 kontext: %d."
+msgstr "Selhala inicializace kontextu MD5: %d."
 
-#: ../libnm-util/crypto_nss.c:174
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Neplatn dlka IV (mus bt nejmn %d)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
-msgstr "Nelze inicializovat slot dekdovac ifry."
+msgstr "Selhala inicializace slotu deifrovac ifry."
 
-#: ../libnm-util/crypto_nss.c:184
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
-msgstr "Nelze nastavit symetrick kl pro dekdovn."
+msgstr "Selhalo nastaven symetrickho kle pro deifrovn."
 
-#: ../libnm-util/crypto_nss.c:194
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
-msgstr "Nelze nastavit IV pro dekdovn."
+msgstr "Selhalo nastaven IV pro deifrovn."
 
-#: ../libnm-util/crypto_nss.c:202
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
-msgstr "Nelze inicializovat kontext dekdovn."
+msgstr "Selhala inicializace deifrovacho kontextu."
 
-#: ../libnm-util/crypto_nss.c:215
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
-msgstr "Nelze dekdovat soukrom kl: %d."
+msgstr "Selhalo deifrovn soukromho kle: %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr ""
+"Selhalo deifrovn soukromho kle: deifrovan data jsou pli velk."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
-msgstr "Nelze dokonit dekdovn soukromho kle: %d."
+msgstr "Selhalo dokonen deifrovn soukromho kle: %d."
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Selhala inicializace slotu ifrovac ifry."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "Selhalo nastaven symetrickho kle pro ifrovn."
 
-#: ../libnm-util/crypto_nss.c:271
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "Selhalo nastaven IV pro ifrovn."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "Selhala inicializace kontextu ifrovn."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "Selhalo ifrovn: %d"
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Neoekvan mnostv dat po zaifrovn."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "Nelze dekdovat certifikt: %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "Nelze pevst heslo na UCS2: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "Nelze inicializovat dekodr PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "Nelze dekdovat soubor PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "Nelze ovit soubor PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "Nelze vygenerovat nhodn data."
+
+#: ../libnm-util/nm-utils.c:1818
+#, c-format
+#| msgid "Not enough memory to create private key decryption key."
+msgid "Not enough memory to make encryption key."
+msgstr "Nedostatek pamti pro vytvoen ifrovacho kle."
+
+#: ../libnm-util/nm-utils.c:1928
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Nelze alokovat pam pro vytvoen souboru PEM."
+
+#: ../libnm-util/nm-utils.c:1940
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Nelze alokovat pam pro zpis IV do souboru PEM."
+
+#: ../libnm-util/nm-utils.c:1952
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Nelze alokovat pam pro zpis ifrovanho kle do souboru PEM."
+
+#: ../libnm-util/nm-utils.c:1971
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "Nelze alokovat pam pro data souboru PEM."
+
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "chyba pi zpracovn zprvy netlink: %s"
+
+#: ../src/nm-netlink-monitor.c:259
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "nelze alokovat ovldn netlinku pro sledovn stavu spojen: %s"
+
+#: ../src/nm-netlink-monitor.c:269
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "nelze se pipojit k netlinku pro sledovn stavu spojen: %s"
+
+#: ../src/nm-netlink-monitor.c:277
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "nelze se pipojit ke skupin netlink pro sledovn stavu spojen: %s"
+
+#: ../src/nm-netlink-monitor.c:285
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "nelze alokovat mezipam netlinku pro sledovn stavu spojen: %s"
+
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
+msgid "error occurred while waiting for data on socket"
+msgstr "vyskytla se chyba pi ekn na data ze soketu"
+
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "chyba pi aktualizaci mezipamti spojen: %s"
+
+#: ../src/main.c:498
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr ""
+"Neplatn pepna. Platn pepnae si mete zobrazit pomoc --help.\n"
+
+#: ../src/main.c:558
+#, c-format
+#| msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s. Pomoc --help si prosm zobrazte seznam platnch pepna.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
+msgid "# Created by NetworkManager\n"
+msgstr "# Vytvoeno NetworkManagerem\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# Sloueno z %s\n"
+"\n"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "nebyl nalezen dn pouiteln klient DHCP."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "dhclient byl nalezen."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "dhcpcd byl nalezen."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "nepodporovan klient DHCP %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "nelze alokovat ovldn netlinku: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:209
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "nelze se pipojit k netlinku: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:306
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "nelze se pipojit ke skupin netlink: %s"
+
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "Neznm rove evidence %s"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "Neznm domna evidence %s"
+
+#: ../src/named-manager/nm-named-manager.c:314
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ""
+"Poznmka: peklada adres z libc neme podporovat vce ne 3 jmenn servery."
+
+#: ../src/named-manager/nm-named-manager.c:316
+msgid "The nameservers listed below may not be recognized."
+msgstr "Jmenn servery uveden v nsledujcm seznamu nelze rozpoznat."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "%s (automaticky)"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "Systm"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Sdlen pipojen pes chrnnou s WiFi"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Sdlen pipojen pes otevenou s WiFi"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Mnit trval systmov nzev potae"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Mnit systmov pipojen"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "Systmov politika zabrnila zmn systmovho nastaven."
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "Systmov politika zabrnila zmn trvalho systmovho nzvu potae"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "Systmov politika zabrnila sdlen pipojen pes chrnnou s WiFi"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "Systmov politika zabrnila sdlen pipojen pes otevenou s WiFi"
diff --git a/po/de.po b/po/de.po
index 0570938..ea2fe02 100644
--- a/po/de.po
+++ b/po/de.po
@@ -7,20 +7,867 @@
 # Thomas Gier <info@thomasgier.de>, 2007.
 # Andre Klapper <ak-47@gmx.net>, 2007.
 # Hauke Mehrtens <hauke@hauke-m.de>, 2008.
-# Christian Kirbach <Christian.Kirbach@googlemail.com>, 2009.
-#
+# Christian Kirbach <Christian.Kirbach@googlemail.com>, 2009, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager HEAD\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-10-15 23:02+0200\n"
-"PO-Revision-Date: 2009-10-14 11:27+0200\n"
+"POT-Creation-Date: 2010-03-12 08:15+0100\n"
+"PO-Revision-Date: 2010-03-12 08:17+0100\n"
 "Last-Translator: Christian Kirbach <Christian.Kirbach@googlemail.com>\n"
-"Language-Team: German <gnome-de@gnome.org>\n"
+"Language-Team: Deutsch <gnome-de@gnome.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1)\n"
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Aufruf: nmcli con { BEFEHL | help }\n"
+"  BEFEHL := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Verbindungen"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Name"
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "System-Verbindungen:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "Benutzer-Verbindungen:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Fehler: %s Argument fehlt."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Fehler: %s - keine solche Verbindung."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Systemweite Verbindungen"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Benutzer-Verbindungen"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Unbekannter Parameter: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Fehler: Kein gltiger Parameter angegeben."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ja"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "nein"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Aktive Verbindungen "
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Vorgabe"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Dienst"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Gert"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "keine aktive Verbindung auf Gert %s"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "keine aktive Verbindung auf Gert"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "wird aktiviert"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktiviert"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "unbekannt"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN wird verbunden (vorbereiten)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN wird verbunden (Legitimierung erforderlich)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN wird verbunden"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN wird verbunden (IP-Konfiguration wird ermittelt)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN verbunden"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN-Verbindung fehlgeschlagen"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN getrennt"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "unbekannter Grund"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "kein"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "der Benutzer wurde getrennt"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "die Basisverbindung wurde unterbrochen"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "der VPN-Dienst brach unerwartet ab"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "der VPN-Dienst gab eine ungltige Konfiguration zurck"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "Der Verbindungsversuch ist zeitlich abgelaufen"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "der VPN-Dienst ist nicht rechtzeitig gestartet"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "der VPN-Dienst konnte nicht starten"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "keine gltigen VPN-Geheimnisse"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "ungltige VPN-Geheimnisse"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "Die Verbindung wurde entfernt"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "Zustand: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Verbindung aktiviert\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Fehler: Aktivierung der Verbindung fehlgeschlagen."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "Zustand: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Fehler: Aktivierung der Verbindung fehlgeschlagen: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Fehler: Zeitbeschrnkung von %d Sekunden abgelaufen."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Fehler: Aktivierung der Verbindung fehlgeschlagen: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Fehler: Erlangen der Verbindung fr %s ist fehlgeschlagen."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Zustand der aktiven Verbindung: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Pfad der aktiven Verbindung: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Fehler: Unbekannte Verbindung: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Fehler: Der Wert %s fr den Zeitablauf ist nicht gltig."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Fehler: id oder uuid muss angegeben werden."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Fehler: Kein passendes Gert gefunden: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Fehler: Kein passendes Gert gefunden."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Warnung: Verbindung ist derzeit nicht aktiv\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Fehler: Der Befehl %s fr con ist nicht gltig."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Fehler: Es konnte nicht mit D-Bus verbunden werden."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Fehler: Systemeinstellungen konnten nicht ermittelt werden"
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Fehler: Benutzereinstellungen konnten nicht ermittelt werden."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr ""
+"Fehler: Verbindungen knnen nicht erlangt werden: Die Einstellungsdienste "
+"werden nicht ausgefhrt."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Aufruf: nmcli dev { BEFEHL | help }\n"
+"\n"
+"  BEFEHL := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "nicht verwaltet"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "nicht verfgbar"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "getrennt"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "wird verbunden (vorbereiten)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "wird verbunden (konfigurieren)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "wird verbunden (Legitimierung erforderlich)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "wird verbunden (IP-Konfiguration wird ermittelt)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "verbunden"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "Verbindung fehlgeschlagen"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Unbekannt"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(keine)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: Fehler bei Umwandlung der IPv4-Addresse 0x%X"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Frequenz %d MHz, Durchsatz %d Mb/s, Strke %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", Verschlsselt:"
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+# Das ergibt z.B. WPA-Enterprise, klingt komisch mit Unternehmen
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr "Enterprise"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Gert"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Treiber"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(unbekannt)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Zustand"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Hardware-Adresse"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"Fhigkeiten:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Trgersignal erkannt"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Geschwindigkeit"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  Eigenschaften der drahtlosen Verbindung\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP-Verschlsselung"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA-Verschlsselung"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2-Verschlsselung"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP-Chiffre"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP-Chiffre"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Zugangspunkte fr Drahtlosnetzwerk %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = aktueller Zugangspunkt)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Eigenschaften der kabelgebundenen Verbindung\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Trgersignal"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "an"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "aus"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4-Einstellungen:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adresse"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Prfix"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Gateway"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Status von Gerten"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Fehler: Argument %s fehlt."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Fehler: Gert %s wurde nicht gefunden"
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Erfolg: Gert %s wurde erfolgreich getrennt."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Fehler: Trennung des Gertes %s (%s) ist fehlgeschlagen: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Gertezustand:  %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Fehler: Schnittstelle muss angegeben werden."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Suchliste fr WiFi"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Fehler: Gert %s ist kein WiFi-Gert."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Gert:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Fehler: Hardware-Adresse muss angegeben werden."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr ""
+"Fehler: Der Zugangspunkt mit Hardware-Adresse %s wurde nicht gefunden."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parameter des Zugangspunktes"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Frequenz:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Modus:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastuktur"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Maximale Bitrate:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Strke:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Flags:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "Datenschutzmodus"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA-Flags:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN-Flags:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Fehler: Der Befehl %s fr dev wifi ist nicht gltig."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Fehler: Der Befehl %s fr dev ist nicht gltig."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Aufruf: nmcli nm { BEFEHL | help }\n"
+"\n"
+"  BEFEHL := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "schlafend"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "wird verbunden"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "aktiviert"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "deaktiviert"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Status von NetworkManager"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM luft:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "wird ausgefhrt"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "wird nicht ausgefhrt"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Status von NM:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM Drahtlos-Hardware:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM drahtlos:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN-Hardware:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Fehler: Ungltiger wifi-Parameter: %s."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Fehler: Ungltiger wwan-Parameter: %s."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Fehler: Der Befehl %s fr nm ist nicht gltig."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Aufruf: %s [OPTIONEN] OBJEKT { BEFEHL | help }\n"
+"\n"
+"OPTIONEN\n"
+"  -t[erse]    knappe Ausgabe\n"
+"  -p[retty]   hbsche Ausgabe\n"
+"  -v[ersion]  Programm-Version anzeigen\n"
+"  -h[elp]     dies Hilfe ausgeben\n"
+"\n"
+"OBJEKT\n"
+"  nm          Status von NetworkManager\n"
+"  con         Verbindungen von NetworkManager\n"
+"  dev         von NetworkManager verwaltete Verbindungen\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Objekt %s ist unbekannt, versuchen Sie nmcli help."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli, Version %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Option %s ist unbekannt, versuchen Sie nmcli -help."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Signal %d wurde empfangen, wird beendet "
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Fehler: Verbindung konnte nicht mit NetworkManager hergestellt werden."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Erfolg"
 
 #: ../libnm-util/crypto.c:120
 #, c-format
@@ -237,7 +1084,7 @@ msgstr "PKCS#12 konnte nicht decodiert werden: %s"
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12-Datei konnte nicht berprft werden: %s"
 
-#: ../libnm-util/crypto_nss.c:57
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Fehler beim Initialisieren der Verschlsselung: %d."
@@ -351,38 +1198,38 @@ msgstr "PKCS#12-Datei konnte nicht berprft werden: %d"
 msgid "Could not generate random data."
 msgstr "Zufllige Daten konnten nicht erstellt werden."
 
-#: ../libnm-util/nm-utils.c:1522
+#: ../libnm-util/nm-utils.c:1545
 #, c-format
 msgid "Not enough memory to make encryption key."
 msgstr "Nicht genug Speicher zum Erstellen eines Schlssels."
 
-#: ../libnm-util/nm-utils.c:1633
+#: ../libnm-util/nm-utils.c:1655
 msgid "Could not allocate memory for PEM file creation."
 msgstr ""
 "Es konnte kein Speicher zum Erstellen der PEM-Datei angefordert werden."
 
-#: ../libnm-util/nm-utils.c:1645
+#: ../libnm-util/nm-utils.c:1667
 #, c-format
 msgid "Could not allocate memory for writing IV to PEM file."
 msgstr ""
 "Es konnte kein Speicher zum Schreiben des IV in die PEM-Datei angefordert "
 "werden."
 
-#: ../libnm-util/nm-utils.c:1657
+#: ../libnm-util/nm-utils.c:1679
 #, c-format
 msgid "Could not allocate memory for writing encrypted key to PEM file."
 msgstr ""
 "Es konnte kein Speicher zum Schreiben des IV in die PEM-Datei angefordert "
 "werden."
 
-#: ../libnm-util/nm-utils.c:1676
+#: ../libnm-util/nm-utils.c:1698
 #, c-format
 msgid "Could not allocate memory for PEM file data."
 msgstr ""
 "Es konnte kein Speicher fr die Daten der PEM-Datei angefordert werden."
 
 #: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
-#: ../src/nm-netlink-monitor.c:569
+#: ../src/nm-netlink-monitor.c:582
 #: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
@@ -421,23 +1268,23 @@ msgstr ""
 msgid "error occurred while waiting for data on socket"
 msgstr "Whrend des Wartens auf Daten am Socket ist ein Fehler aufgetreten"
 
-#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "Fehler beim Aktualisieren des Verbindungs-Cache: %s"
 
-#: ../src/NetworkManager.c:330
+#: ../src/main.c:494
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr ""
-"Ungltige Option.  Verwenden Sie Bitte --help, um eine Liste der gltigen "
+"Ungltige Option.  Verwenden Sie bitte --help, um eine Liste der gltigen "
 "Optionen zu erhalten.\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
 msgid "# Created by NetworkManager\n"
 msgstr "# Erstellt von NetworkManager\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -478,7 +1325,7 @@ msgstr ""
 msgid "Auto %s"
 msgstr "Auto %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
 msgid "System"
 msgstr "System"
 
diff --git a/po/es.po b/po/es.po
index 6120118..6919c06 100644
--- a/po/es.po
+++ b/po/es.po
@@ -1,102 +1,872 @@
-# translation of NetworkManager.HEAD.po to Espaol
-# translation of NetworkManager.HEAD.po to
-# Traduccin de NetworkManager al espaol.
+# translation of NetworkManager.HEAD.po to Spanish
 # Copyright (C) Spanish translation for NetworkManager
 # This file is distributed under the same license as the NetworkManager package.
 #
 # Antonio Ognio <antonio@linux.org.pe>, 2004.
-# Francisco Javier F. Serrador <serrador@cvs.gnome.org>, 2004, 2005, 2006.
+# Francisco Javier F. Serrador <serrador@cvs.gnome.org>, 2004, 2005, 2006, 2010.
 # Lucas Vieites Faria <lucas@asixinformatica.com>, 2005, 2006.
-# Jorge Gonzlez <jorgegonz@svn.gnome.org>, 2007, 2008.
+# Jorge Gonzlez <jorgegonz@svn.gnome.org>, 2007, 2008, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager.HEAD\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
-"product=NetworkManager&amp;component=general\n"
-"POT-Creation-Date: 2008-11-13 21:19+0000\n"
-"PO-Revision-Date: 2008-11-14 20:28+0100\n"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-09 03:24+0000\n"
+"PO-Revision-Date: 2010-04-10 19:52+0200\n"
 "Last-Translator: Jorge Gonzlez <jorgegonz@svn.gnome.org>\n"
 "Language-Team: Espaol <gnome-es-list@gnome.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms:  nplurals=2; plural=(n != 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:476
+#: ../cli/src/connections.c:86
 #, c-format
-msgid "error processing netlink message: %s"
-msgstr "error al procesar el mensaje de netlink: %s"
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Uso: nmcli con { COMANDO | help }\n"
+"  COMANDO := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <interfaz>] [ap <direccin-hardware>] [--"
+"nowait] [--timeout <tiempo-de-expiracin>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Conexiones"
 
-#: ../src/nm-netlink-monitor.c:252
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Tipo"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Nombre"
+
+#: ../cli/src/connections.c:163
 #, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "System connections:\n"
+msgstr "Conexiones del sistema:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "Conexiones del usuario:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Error: falta el argumento %s."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Error: %s; no existe tal conexin."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Conexiones amplias del sistema"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Conexiones del usuario"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Parmetro desconocido: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Error: no se especific un parmetro vlido."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "s"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "no"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Activar conexiones"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Predeterminada"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Servicio"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Dispositivos"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "no existe una conexin activa en el dispositivo %s"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "no existe una conexin o dispositivo activo"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "activando"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "activada"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "desconocido"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "Conectando con la VPN (preparacin)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "Conectando con la VPN (necesita autorizacin)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "Conectando con la VPN"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "Conectando con la VPN (obteniendo configuracin IP)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN conectada"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "Fall la conexin VPN"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN desconectada"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "razn desconocida"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "ninguna"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "se desconect al usuario"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "se interrumpi la conexin base de red"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "el servicio VPN finaliz inesperadamente"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "el servicio VPN devolvi una configuracin no vlida"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "expir el intento de conexin"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "el servicio VPN no se inici a tiempo"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "el servicio VPN fall al iniciar"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "secretos VPN no vlidos"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "secretos VPN invlidos"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "se rechaz la conexin"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "estado: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Conexin activada\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Error: fall la activacin de la conexin."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "estado: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Error: fall la activacin de la conexin: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Error: Expir el tiempo de conexin de %d segs."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Error: fall la activacin de la conexin: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Error: fall la obtencin de una conexin activa para %s."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Estado de la conexin activa: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Ruta de la conexin activa: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Error: conexin desconocida: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Error: el valor %s no es vlido para el tiempo de expiracin."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Error: se debe especificar el id o uuid."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Error: no se encontr un dispositivo apropiado: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Error: no se encontr un dispositivo apropiado."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Aviso: la conexin no est activa\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Error: el comando con %s no es vlido."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Error: no se pudo conectar con D-Bus."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Error: no se pudo obtener la configuracin del sistema."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Error: no se pudo obtener la configuracin del usuario."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
 msgstr ""
-"no se puede asignar el manejador netlink para monitorizar el estado del "
-"enlace: %s"
+"Error: no se pueden obtener las conexiones: los servicios de configuracin "
+"no se estn ejecutando."
 
-#: ../src/nm-netlink-monitor.c:262
+#: ../cli/src/devices.c:73
 #, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"no se puede conectar con netlink para monitorizar el estado del enlace: %s"
+"Uso: nmcli dev { COMANDO | help }\n"
+"\n"
+"  COMANDO := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <interfaz>]\n"
+"  disconnect iface <interfaz> [--nowait] [--timeout <tiempo-de-expiracin>]\n"
+"  wifi [list [iface <interfaz>] | apinfo iface <interfaz> hwaddr <direccin-"
+"hardware>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "sin gestionar"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "no disponible"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "desconectado"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "conectando (preparacin)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "conectando (configuracin)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "conectando (necesita autorizacin)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "conectando (obteniendo configuracin IP)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "conectado"
 
-#: ../src/nm-netlink-monitor.c:270
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "fall la conexin"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Desconocido"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(nada)"
+
+#: ../cli/src/devices.c:209
 #, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: error al convertir la direccin IP4 en 0x%X"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, frecuencia %d MHz, tasa %d Mb/s, intensidad %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", cifrado: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Enterprise"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Dispositivo"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Controlador"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(desconocido)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Estado"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Direccin hardware"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
 msgstr ""
-"no pudo unirse al grupo netlink para monitorizar el estado del enlace: %s"
+"\n"
+"  Capacidades:\n"
 
-#: ../src/nm-netlink-monitor.c:278
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Detector de portadora"
+
+#: ../cli/src/devices.c:336
 #, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Velocidad"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
 msgstr ""
-"no se puede asignar el enlace a la cach de netlink para monitorizar el "
-"estado del enlace: %s"
+"\n"
+"  Propiedades de la conexin inalmbrica\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "Cifrado WEP"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "Cifrado WPA"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "Cifrado WPA2"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "Cifrado TKIP"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "Cifrado CCMP"
 
-#: ../src/nm-netlink-monitor.c:441
+#: ../cli/src/devices.c:368
 #, c-format
-msgid "error updating link cache: %s"
-msgstr "error al actualizar el enlace cach: %s"
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Puntos de acceso inalmbricos %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = PA actual)"
 
-#: ../src/nm-netlink-monitor.c:499
+#: ../cli/src/devices.c:374
 #, c-format
-msgid "error occurred while waiting for data on socket"
-msgstr "ha ocurrido un error mientras esperaban datos en un socket"
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Propiedades de la conexin cableada\n"
 
-#: ../src/NetworkManager.c:252
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Portadora"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "encendido"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "apagado"
+
+#: ../cli/src/devices.c:387
 #, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
 msgstr ""
-"Opcin no vlida. Use --help para ver una lista de las opciones vlidas.\n"
+"\n"
+"  Ajustes de IPv4:\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:88
-msgid "# Created by NetworkManager\n"
-msgstr "# Creado por NetworkManager\n"
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Direccin"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Prefijo"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Pasarela"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Estado de los dispositivos"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Error: falta el argumento %s."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Error: no se encontr el dispositivo %s"
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "xito: se desconect correctamente el dispositivo %s."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Error: fall la desconexin del dispositivo %s (%s): %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Estado del dispositivo: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Error: se debe especificar la interfaz."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Lista de la inspeccin inalmbrica"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Error: el dispositivo %s no es un dispositivo inalmbrico."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Dispositivo:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Error: se debe especificar la direccin hardware."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Error: no se encontr el punto de acceso con direccin hardware %s."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:94
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parmetros del PA"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Frecuencia:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Modo:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infraestructura"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Tasa de bits mxima:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Intensidad:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Opciones:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "privacidad"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "Opciones WPA:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "Opciones RSN:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Error: el comando dev wifi %s no es vlido."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Error: el comando dev %s no es vlido."
+
+#: ../cli/src/network-manager.c:46
 #, c-format
 msgid ""
-"# Merged from %s\n"
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
 "\n"
 msgstr ""
-"# Mezclado de %s\n"
+"Uso: nmcli nm {COMANDO | help }\n"
+"\n"
+"  COMANDO := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:256
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "dormida"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "conectando"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "activado"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "desactivado"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Estado de NetworkManager"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM en ejecucin:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "en ejecucin"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "no est en ejecucin"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Estado de NM:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "Hardware inalmbrico de NM:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "Inalmbrico de NM:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "Hardware WWAN de NM:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "WWAN de NM:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Error: parmetro wifi no vlido: %s."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Error: parmetro wwan no vlido: %s."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Error: el comando nm %s no es vlido."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
 msgstr ""
-"NOTA: el resolutor de nombres de libc puede que no soporte ms de 3 "
-"servidores de nombres."
+"Uso: %s [OPCIONES] OBJETO { COMANDO | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    salida breve\n"
+"  -p[retty]   salida bonita\n"
+"  -v[ersion]  mostrar la versin del programa\n"
+"  -h[elp]     mostrar esta ayuda\n"
+"\n"
+"OBJECT\n"
+"  nm          estado de NetworkManager\n"
+"  con         conexiones de NetworkManager\n"
+"  dev         dispositivos gestionados por NetworkManager\n"
+"\n"
 
-#: ../src/named-manager/nm-named-manager.c:258
-msgid "The nameservers listed below may not be recognized."
-msgstr "Puede que los servidores de nombres listados abajo no se reconozcan."
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Se desconoce el objeto %s, intente nmcli help."
 
-#: ../system-settings/src/main.c:376
+#: ../cli/src/nmcli.c:139
 #, c-format
-msgid "Auto %s"
-msgstr "Auto %ss"
+msgid "nmcli tool, version %s\n"
+msgstr "herramienta nmcli, versin %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Se desconoce la opcin %s, intente nmcli -help."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Se captur la seal %d, apagando..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Error: no se pudo conectar con NetworkManager."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "xito"
 
 #: ../libnm-util/crypto.c:120
 #, c-format
@@ -184,8 +954,9 @@ msgstr "No hay memoria suficiente para almacenar la IV."
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV contiene dgitos no hexadecimales."
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Se desconoca el cifrador de clave privada %s."
@@ -205,71 +976,106 @@ msgstr "No se pudo determinar el tipo de clave privada."
 msgid "Not enough memory to store decrypted private key."
 msgstr "No hay memoria suficiente para almacenar la clave privada descifrada."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "Fall al inicializar el motor de descifrado."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "Fall al inicializar el motor MD5: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Longitud IV no vlida (debe ser al menos %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "No hay memoria suficiente para el bfer de la clave descifrada."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "Fall al inicializar el contexto de descifrado: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "Fall al establecer la clave simtrica para el descifrado: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "Fall al establecer IV para el descifrado: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "Fall al descifrar la clave privada: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Fall al descifrar la clave privada: longitud inesperada del relleno."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "Fall al descifrar la clave privada."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "No se pudo reservar memoria para el cifrado."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Fall al inicializar el contexto de cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Fall al establecer la clave simtrica para el cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Fall al establecer IV para el cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Fall al cifrar los datos: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Error al inicializar los datos del certificado: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "No se pudo decodificar el certificado: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "No se pudo inicializar el decodificador PKCS#12: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "No se pudo decodificar el archivo PKCS#12: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "No se pudo verificar el archivo PKCS#12: %s"
 
-#: ../libnm-util/crypto_nss.c:57
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Fall al inicializar el motor de cifrado: %d."
@@ -279,62 +1085,296 @@ msgstr "Fall al inicializar el motor de cifrado: %d."
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "Fall al inicializar el contexto MD5: %d"
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Longitud de IV no vlida (debe ser al menos %d)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "Fall al inicializar la ranura de descifrado."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "Fall al establecer la clave simtrica para el descifrado."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "Fall al establecer IV para el descifrado."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "Fall al inicializar el contexto de descifrado."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "Fall al descifrar la clave privada: %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr ""
+"Fall al descifrar la clave privada: los datos descifrados son demasiado "
+"grandes."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "Fall la finalizacin del descifrado de la clave privada: %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Fall al inicializar la ranura de cifrado."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "Fall al establecer la clave simtrica para el cifrado."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "Fall al establecer IV para el cifrado."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "Fall al inicializar el contexto de cifrado."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "Fall al cifrar: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Cantidad de datos inesperada despus de cifrar."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "No se pudo decodificar el certificado: %d"
 
-#: ../libnm-util/crypto_nss.c:317
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "No se pudo convertir la contrasea a UCS2: %d"
 
-#: ../libnm-util/crypto_nss.c:345
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "No se pudo inicializar el decodificador PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:354
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "No se pudo decodificar el archivo PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:363
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "No se pudo verificar el archivo PKCS#12: %d"
 
-#~ msgid "Not enough memory to create private key decryption key."
-#~ msgstr ""
-#~ "No hay memoria suficiente para crear la clave privada de la clave de "
-#~ "descifrado."
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "No se pudo generar datos aleatorios."
+
+#: ../libnm-util/nm-utils.c:1818
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "No hay memoria suficiente para crear la clave privada de cifrado."
+
+#: ../libnm-util/nm-utils.c:1928
+msgid "Could not allocate memory for PEM file creation."
+msgstr "No se pudo reservar memoria para crear el archivo PEM."
+
+#: ../libnm-util/nm-utils.c:1940
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "No se pudo asignar memoria para escribir IV en el archivo PEM."
+
+#: ../libnm-util/nm-utils.c:1952
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr ""
+"No se pudo asignar memoria para escribir la clave cifrada en el archivo PEM."
+
+#: ../libnm-util/nm-utils.c:1971
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "No se pudo reservar memoria para el archivo de datos PEM."
+
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "error al procesar el mensaje de netlink: %s"
+
+#: ../src/nm-netlink-monitor.c:259
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr ""
+"no se puede asignar el manejador netlink para monitorizar el estado del "
+"enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:269
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr ""
+"no se puede conectar con netlink para monitorizar el estado del enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:277
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr ""
+"no pudo unirse al grupo netlink para monitorizar el estado del enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:285
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr ""
+"no se puede asignar el enlace a la cach de netlink para monitorizar el "
+"estado del enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
+msgid "error occurred while waiting for data on socket"
+msgstr "ha ocurrido un error mientras esperaban datos en un socket"
+
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "error al actualizar el enlace cach: %s"
+
+#: ../src/main.c:498
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr ""
+"Opcin no vlida. Use --help para ver una lista de las opciones vlidas.\n"
+
+#: ../src/main.c:558
+#, c-format
+#| msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s. Use --help para ver una lista de las opciones vlidas.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
+msgid "# Created by NetworkManager\n"
+msgstr "# Creado por NetworkManager\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# Mezclado de %s\n"
+"\n"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "no se encontr ningn cliente de DHCP usable."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "no se pudo encontrar dhclient."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "no se pudo encontrar dhcpd."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "no se soporta el cliente de DHCP %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "no se puede asignar el manejador netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:209
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "no se puede conectar con netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:306
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "no pudo unirse al grupo netlink: %s"
+
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "Nivel de registro %s desconocido"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "Dominio de registro %s desconocido"
+
+#: ../src/named-manager/nm-named-manager.c:314
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ""
+"NOTA: el resolutor de nombres de libc puede que no soporte ms de 3 "
+"servidores de nombres."
+
+#: ../src/named-manager/nm-named-manager.c:316
+msgid "The nameservers listed below may not be recognized."
+msgstr "Puede que los servidores de nombres listados abajo no se reconozcan."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "Auto %ss"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "Sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Compartir la conexin a travs de una red inalmbrica protegida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Compartir la conexin a travs de una red inalmbrica abierta"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Modificar el nombre de equipo persistente del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Modificar las conexiones del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr ""
+"La poltica del sistema impide modificaciones de los ajustes del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr ""
+"La poltica del sistema impide la modificaciones del nombre de equipo "
+"persistente del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr ""
+"La poltica del sistema impide compartir conexiones a travs de una red "
+"inalmbrica protegida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr ""
+"La poltica del sistema impide compartir conexiones a travs de una red "
+"inalmbrica abierta"
diff --git a/po/eu.po b/po/eu.po
index 58353d1..f2e96a5 100644
--- a/po/eu.po
+++ b/po/eu.po
@@ -1,276 +1,1351 @@
-# translation of eu.po to Basque
+# translation of NetworkManager.master.po to Basque
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
 # This file is distributed under the same license as the PACKAGE package.
 #
-# Iaki Larraaga Murgoitio <dooteo@euskalgnu.org>, 2008.
+# Iaki Larraaga Murgoitio <dooteo@euskalgnu.org>, 2008, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: eu\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-09-09 16:04+0200\n"
-"PO-Revision-Date: 2008-09-09 16:25+0200\n"
+"Project-Id-Version: NetworkManager.master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-02-26 03:24+0000\n"
+"PO-Revision-Date: 2010-03-16 17:05+0100\n"
 "Last-Translator: Iaki Larraaga Murgoitio <dooteo@euskalgnu.org>\n"
 "Language-Team: Basque <itzulpena@euskalgnu.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms:  nplurals=2; plural=(n > 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
 "X-Generator: KBabel 1.11.4\n"
 
-#: ../src/nm-netlink-monitor.c:193 ../src/nm-netlink-monitor.c:474
+#: ../cli/src/connections.c:86
 #, c-format
-msgid "error processing netlink message: %s"
-msgstr "errorea netlink-en mezua prozesatzean: %s"
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Erabilera: nmcli con { KOMANDOA| help }\n"
+"  KOMANDOA := { list | status | up | down }\n"
+"\n"
+"  list [id <IDa> | uuid <IDa> | system | user]\n"
+"  status\n"
+"  up id <IDa> | uuid <IDa> [iface <interfazea>] [ap <HW_helbidea>] [--nowait] [--timeout "
+"<denbora-muga>]\n"
+"  down id <IDa> | uuid <IDa>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Konexioak"
 
-#: ../src/nm-netlink-monitor.c:250
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Mota"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUIDa"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Izena"
+
+#: ../cli/src/connections.c:163
 #, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+msgid "System connections:\n"
+msgstr "Sistemako konexioak:\n"
 
-#: ../src/nm-netlink-monitor.c:260
+#: ../cli/src/connections.c:167
 #, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+msgid "User connections:\n"
+msgstr "Erabiltzailearen konexioak:\n"
 
-#: ../src/nm-netlink-monitor.c:268
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
 #, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "ezin da netlink taldearekin elkartu konexioaren egoera monitorizatzeko: %s"
+msgid "Error: %s argument is missing."
+msgstr "Errorea: %s argumentua falta da."
 
-#: ../src/nm-netlink-monitor.c:276
+#: ../cli/src/connections.c:189
 #, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgid "Error: %s - no such connection."
+msgstr "Errorea: %s - ez dago halako konexiorik"
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Sistema osoko konexioak"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Erabiltzailearen konexioak"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Parametro ezezagunak: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Errorea: ez da baliozko parametrorik zehaztu."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "bai"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "ez"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Konexio aktiboak"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Lehenetsia"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Zerbitzua"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Gailuak"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "ez dago konexio aktiborik '%s' gailuan"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ez dago konexio edo gailu aktiborik"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktibatzen"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktibatuta"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "ezezaguna"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN konektatzen (prestatzen)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN konektatzen (autentifikazioa behar da)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN konektatzen"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN konektatzen (IP konfigurazioa lortzen)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN konektatuta"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN konexioak huts egin du"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN deskonektatuta"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "arrazoi ezezaguna"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "bat ere ez"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "erabiltzailea deskonektatu egin da"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "oinarriko sarearen konexioa eten egin da"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN zerbitzua ustekabean gelditu da"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN zerbitzuak konfigurazio baliogabea itzuli du"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "konexioaren saiakeraren denbora-muga"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN zerbitzua ez da orduan abiatu"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "huts egin du VPN zerbitzuak abiaraztean"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "VPNren ezkutukoak ez dira baliozkoak"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "VPNren ezkutukoak baliogabeak"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "konexioa kendu egin da"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "egoera: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Konexioa aktibatuta\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Errorea: konexioaren aktibazioak huts egin du"
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "egoera: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Errorea: konexioaren aktibazioak huts egin du: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Errorea: denbora-muga %d segundotan iraungituta."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Errorea: konexioaren aktibazioak huts egin du: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Errorea: hust egin du '%s'(r)en konexio aktiboa lortzean."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Konexio aktiboaren egoera: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Konexio aktiboaren bide-izena: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Errorea: konexio ezezaguna: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Errorea: denbora-mugaren '%s' balioa ez da baliozkoa."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Errorea: IDa edo UUIDa zehaztu behar da."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Errorea: ez da gailu egokirik aurkitu: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Errorea: ez da gailu egokirik aurkitu."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Abisua: konexioa ez dago aktibo\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Errorea: 'con' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Errorea: ezin izan da 'D-Bus'-arekin konektatu."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Errorea: ezin izan da sistemako ezarpenik lortu."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Errorea: ezin izan da erabiltzailearen ezarpenik lortu."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Errorea: ezin da konexiorik lortu. Ezarpenen zerbitzuak ez dira exekutatzen ari."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"ezin da netlink-en konexio-cachea esleitu konexioaren egoera "
-"monitorizatzeko: %s"
+"Erabilera: nmcli dev { KOMANDOA | help }\n"
+"\n"
+"  KOMANDOA := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <interfazea>]\n"
+"  disconnect iface <interfazea> [--nowait] [--timeout <denbora-muga>]\n"
+"  wifi [list [iface <interfazea>] | apinfo iface <interfazea> hwaddr <HW_helbidea>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "kudeatu gabea"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "ez dago erabilgarri"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "deskonektatuta"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "konektatzen (prestatzen)"
 
-#: ../src/nm-netlink-monitor.c:439
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "konektatzen (konfiguratzen)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "konektatzen (autentifikazioa behar da)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "konektatzen (IParen konfigurazioa lortzen)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "konektatuta"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "konexioak huts egin du"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Ezezaguna"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(bat ere ez)"
+
+#: ../cli/src/devices.c:209
 #, c-format
-msgid "error updating link cache: %s"
-msgstr "errorea netlink-en konexio-cachea eguneratzean: %s"
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: errorea 0x%X IP4 helbidea bihurtzean"
 
-#: ../src/nm-netlink-monitor.c:497
+#: ../cli/src/devices.c:238
 #, c-format
-msgid "error occurred while waiting for data on socket"
-msgstr "errorea gertatu da socket-eko datuen zai egotean"
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Maizt. %d MHz, Emaria: %d Mb/s, Indarra %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
 
-#: ../src/NetworkManager.c:250
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", enkriptatuta: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " enpresa"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Gailua"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Kontrolatzailea"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(ezezaguna)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Egoera"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW helbidea"
+
+#: ../cli/src/devices.c:319
 #, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Aukera baliogabea. Erabili '--help' baliozko aukeren zerrenda ikusteko.\n"
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Ahalmenak:\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:89
-msgid "# Created by NetworkManager\n"
-msgstr "# NetworkManager-ek sortuta\n"
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Garraiolaria detektatuta"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Abiadura"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:95
+#: ../cli/src/devices.c:348
 #, c-format
 msgid ""
-"# Merged from %s\n"
 "\n"
+"  Wireless Properties\n"
 msgstr ""
-"# %s(e)ndik batuta\n"
 "\n"
+"  Haririk gabekoaren propietateak\n"
 
-#: ../src/named-manager/nm-named-manager.c:240
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP enkriptatzea"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA enkriptatzea"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 enkriptatzea"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP zifratua"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP zifratua"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
 msgstr ""
-"OHARRA: libc-en ebaztaileak ez du 3 izen-zerbitzari baino gehiago "
-"onartzen."
+"\n"
+"  %s haririk gabeko sarbide-puntua\n"
 
-#: ../src/named-manager/nm-named-manager.c:242
-msgid "The nameservers listed below may not be recognized."
-msgstr "Azpian zerrendatutako izen-zenbitzariak ez dira ezagutuko."
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = uneko SarPunt)"
 
-#: ../system-settings/src/main.c:366
+#: ../cli/src/devices.c:374
 #, c-format
-msgid "Auto %s"
-msgstr "Auto %s"
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Haridunaren propietateak\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Garraiolaria"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "piztu"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "itzali"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4 ezarpenak:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Helbidea"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Aurrizkia"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Atebidea"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Gailuen egoera"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Errorea: '%s' argumentua falta da."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Errorea: '%s' gailua ez da aurkitu."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Ongi burututa: '%s' gailua ongi deskonektatu da."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Errorea: huts egin du '%s' (%s) gailua deskonektatzean: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Gailuaren egoera: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Errorea: interfazea zehaztu behar da."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Wifi-en eskaneatze-zerrenda"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Errorea: '%s' gailua ez da haririk gabeko gailu bat."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Gailua:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Errorea: hardwarearen helbidea zehaztu behar da."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Errorea: ez da '%s' hw helbideko sarbide-punturik aurkitu."
 
-#: ../libnm-util/crypto.c:125
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "SPuntuaren parametroak"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSIDa:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSIDa:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Maiztasuna:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Modua:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Azpiegitura"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Gehienezko bit-emaria:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Indarra:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Banderak:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "pribatutasuna"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA banderak:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN banderak:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Errorea: 'dev wifi' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Errorea: 'dev' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Erabilera: nmcli nm { KOMANDOA | help }\n"
+"\n"
+"  KOMANDOA := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "lotan"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "konektatzen"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "gaituta"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "desgaituta"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "NetworkManager-en egoera"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM-ren exekuzioa:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "exekutatzen"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "ez da exekutatzen ari"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM-ren egoera:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM haririk gabeko hardwarea:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM haririk gabekoa:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN hardwarea:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Errorea: baliogabeko 'wifi' parametroa: '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Errorea: baliogabeko 'wwan' parametroa: '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Errorea: 'nm' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Erabilera: %s [AUKERAK] OBJEKTUA { KOMANDOA | help }\n"
+"\n"
+"AUKERAK\n"
+"  -t[erse]    xehetasunezko irteera\n"
+"  -p[retty]   irteera politta\n"
+"  -v[ersion]  erakutsi programaren bertsioa\n"
+"  -h[elp]     erakutsi laguntza hau\n"
+"\n"
+"OBJEKTUA\n"
+"  nm          NetworkManager-en egoera\n"
+"  con         NetworkManager-en konexioak\n"
+"  dev         NetworkManager-ek kudeatutako gailuak\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "'%s' objektua ezezaguna da. Saiatu honako komandoarekin: nmcli help"
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli tresna, %s bertsioa\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "'%s' aukera ezezaguna da. Saiatu honako komandoarekin: nmcli -help"
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d seinalea jaso da, itzaltzen..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Errorea: ezin izan da NetworkManager-ekin konektatu."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Behar bezala egin da"
+
+#: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
 msgstr "PEM gako-fitxategiak ez du amaierako '%s' etiketa."
 
-#: ../libnm-util/crypto.c:135
+#: ../libnm-util/crypto.c:130
 #, c-format
 msgid "Doesn't look like a PEM private key file."
 msgstr "Ez dirudi PEM gako pribatuaren fitxategia denik."
 
-#: ../libnm-util/crypto.c:143
+#: ../libnm-util/crypto.c:138
 #, c-format
 msgid "Not enough memory to store PEM file data."
 msgstr "Ez dago nahikoa memoria PEM fitxategiko datuak gordetzeko."
 
-#: ../libnm-util/crypto.c:159
+#: ../libnm-util/crypto.c:154
 #, c-format
 msgid "Malformed PEM file: Proc-Type was not first tag."
 msgstr "Gaizki osatutako PEM fitxategia: Proc-Type ez da aurreneko etiketa."
 
-#: ../libnm-util/crypto.c:167
+#: ../libnm-util/crypto.c:162
 #, c-format
 msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
 msgstr "Gaizki osatutako PEM fitxategia: Proc-Type '%s' etiketa ezezaguna."
 
-#: ../libnm-util/crypto.c:177
+#: ../libnm-util/crypto.c:172
 #, c-format
 msgid "Malformed PEM file: DEK-Info was not the second tag."
 msgstr "Gaizki osatutako PEM fitxategia: DEK-Info ez da bigarren etiketa."
 
-#: ../libnm-util/crypto.c:188
+#: ../libnm-util/crypto.c:183
 #, c-format
 msgid "Malformed PEM file: no IV found in DEK-Info tag."
 msgstr "Gaizki osatutako PEM fitxategia: ez da IV aurkitu DEK-Info etiketan."
 
-#: ../libnm-util/crypto.c:195
+#: ../libnm-util/crypto.c:190
 #, c-format
 msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
 msgstr ""
 "Gaizki osatutako PEM fitxategia: IV-ek okerreko formatua du DEK-Info "
 "etiketan."
 
-#: ../libnm-util/crypto.c:208
+#: ../libnm-util/crypto.c:203
 #, c-format
 msgid "Malformed PEM file: unknown private key cipher '%s'."
 msgstr "Gaizki osatutako PEM fitxategia: gako pribatuaren '%s' zifratua ezezaguna."
 
-#: ../libnm-util/crypto.c:227
+#: ../libnm-util/crypto.c:222
 #, c-format
 msgid "Could not decode private key."
 msgstr "Ezin izan da gako pribatua deskodetu."
 
-#: ../libnm-util/crypto.c:271
+#: ../libnm-util/crypto.c:267
 #, c-format
 msgid "PEM certificate '%s' had no end tag '%s'."
 msgstr "'%s' PEM ziurtagiriak ez du amaierako '%s' etiketa."
 
-#: ../libnm-util/crypto.c:281
+#: ../libnm-util/crypto.c:277
 #, c-format
 msgid "Failed to decode certificate."
 msgstr "Huts egin du ziurtagiria deskodetzean."
 
-#: ../libnm-util/crypto.c:290 ../libnm-util/crypto.c:298
+#: ../libnm-util/crypto.c:286
 #, c-format
 msgid "Not enough memory to store certificate data."
 msgstr "Ez dago nahikoa memoria ziurtagiriaren datuak gordetzeko."
 
-#: ../libnm-util/crypto.c:328
+#: ../libnm-util/crypto.c:294
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Not enough memory to store file data."
+msgstr "Ez dago nahikoa memoria fitxategiko datuak gordetzeko."
+
+#: ../libnm-util/crypto.c:324
 #, c-format
 msgid "IV must be an even number of bytes in length."
 msgstr "IV-ek byte-kopuru bikoitia izan behar du luzeran."
 
-#: ../libnm-util/crypto.c:337
+#: ../libnm-util/crypto.c:333
 #, c-format
 msgid "Not enough memory to store the IV."
 msgstr "Ez dago nahikoa memoria IV gordetzeko."
 
-#: ../libnm-util/crypto.c:348
+#: ../libnm-util/crypto.c:344
 #, c-format
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV-ek hamaseitarrak ez diren digituak ditu."
 
-#: ../libnm-util/crypto.c:386 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:157
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Gako pribatuaren '%s' zifratua ezezaguna da."
 
-#: ../libnm-util/crypto.c:395
+#: ../libnm-util/crypto.c:391
+#, c-format
+#| msgid "Not enough memory to store decrypted private key."
+msgid "Not enough memory to decrypt private key."
+msgstr "Ez dago nahikoa memoria gako pribatua deszifratzeko."
+
+#: ../libnm-util/crypto.c:511
 #, c-format
-msgid "Not enough memory to create private key decryption key."
-msgstr "Ez dago nahikoa memoria gako pribatuaren gako deszifratua sortzeko."
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Unable to determine private key type."
+msgstr "Huts egin du gako pribatuaren mota zehaztean."
 
-#: ../libnm-util/crypto.c:513
+#: ../libnm-util/crypto.c:530
 #, c-format
 msgid "Not enough memory to store decrypted private key."
 msgstr "Ez dago nahikoa memoria deszifratutako gako pribatua gordetzeko."
 
-#: ../libnm-util/crypto_gnutls.c:45
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "Huts egin du zifratzearen motorra hasieratzean."
 
-#: ../libnm-util/crypto_gnutls.c:89
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "Huts egin du MD5 motorra hasieratzean: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:166
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Baliogabeko IV luzera (gutxienez %zd izan behar du)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "Ez dago nahikoa memoria deszifratutako gako buferrarentzako."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "Huts egin du zifratze-testuingurua hasieratzean deszifratzeko: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "Huts egin du gako simetrikoa ezartzean deszifratzeko: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "Huts egin du IV ezartzean deszifratzeko: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "Huts egin du gako pribatua deszifratzean: %s /%s."
 
-#: ../libnm-util/crypto_gnutls.c:225
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Huts egin du gako pribatua deszifratzean: ustekabeko betegarriaren luzera."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key."
+msgstr "Huts egin du gako pribatua deszifratzean."
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Ezin izan da memoria esleitu enkriptatzeko."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Huts egin du zifratze-testuingurua enkriptazioa hasieratzean: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Huts egin du gako simetrikoa ezartzean enkriptatzeko: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Huts egin du IV ezartzean enkriptatzeko: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Huts egin du datuak enkriptatzean: %s /%s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Errorea ziurtagiriaren datuak hasieratzean: %s"
 
-#: ../libnm-util/crypto_gnutls.c:237
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "Ezin izan da ziurtagiria deskodetu: %s."
 
-#: ../libnm-util/crypto_nss.c:52
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "Ezin izan da PKCS#12 deskodetzailea hasieratu: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "Ezin izan da PKCS#12 fitxategia deskodetu: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "Ezin izan da PKCS#12 fitxategia egiaztatu: %s"
+
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Huts egin du zifratzearen motorra hasieratzean: %d."
 
-#: ../libnm-util/crypto_nss.c:98
+#: ../libnm-util/crypto_nss.c:111
 #, c-format
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "Huts egin du MD5-en testuingurua hasieratzean: %d."
 
-#: ../libnm-util/crypto_nss.c:174
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Baliogabeko IV luzera (gutxienez %d izan behar du)"
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "Huts egin du zifratuaren erretena hasieratzean deszifratzeko."
 
-#: ../libnm-util/crypto_nss.c:184
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "Huts egin du gako simetrikoa ezartzean deszifratzeko."
 
-#: ../libnm-util/crypto_nss.c:194
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "Huts egin du IV ezartzean deszifratzeko."
 
-#: ../libnm-util/crypto_nss.c:202
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "Huts egin du deszifratzearen testuingurua hasieratzean."
 
-#: ../libnm-util/crypto_nss.c:215
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "Huts egin du gako pribatua deszifratzean: %d."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Huts egin du gako pribatua deszifratzean: deszifratutako datuak luzeegiak dira."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "Huts egin du gako pribatuaren deszifratzea amaitzean: %d."
 
-#: ../libnm-util/crypto_nss.c:271
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Huts egin du zifratuaren erretenaren enkriptazioa hasieratzean."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "Huts egin du gako simetrikoa ezartzean enkriptatzeko."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "Huts egin du IV ezartzean enkriptatzeko."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "Huts egin du enkriptazioaren testuingurua hasieratzean."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "Huts egin du enkriptatzean: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Ustekabeko datu kopurua enkriptatu ostean."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "Ezin izan da ziurtagiria dekodetu: %d"
 
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "Ezin izan da pasahitza UCS2-ra bihurtu: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "Ezin izan da PKCS#12 deskodetzailea hasieratu: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "Ezin izan da PKCS#12 fitxategia deskodetu: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "Ezin izan da PKCS#12 fitxategia egiaztatu: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "Ezin izan da ausazko daturik sortu."
+
+#: ../libnm-util/nm-utils.c:1545
+#, c-format
+#| msgid "Not enough memory to create private key decryption key."
+msgid "Not enough memory to make encryption key."
+msgstr "Ez dago nahikoa memoria gakoa enkriptatzeko."
+
+#: ../libnm-util/nm-utils.c:1655
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Ezin izan da memoria esleitu PEM fitxategia sortzeko."
+
+#: ../libnm-util/nm-utils.c:1667
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Ezin izan da memoria esleitu IV idazteko PEM fitxategian."
+
+#: ../libnm-util/nm-utils.c:1679
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Ezin izan da memoria esleitu enkriptatutako gakoa idazteko PEM fitxategian."
+
+#: ../libnm-util/nm-utils.c:1698
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "Ezin izan da memoria esleitu PEM fitxategiko datuentzako."
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "errorea netlink-en mezua prozesatzean: %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "ezin da netlink taldearekin elkartu konexioaren egoera monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr ""
+"ezin da netlink-en konexio-cachea esleitu konexioaren egoera "
+"monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "errorea gertatu da socket-eko datuen zai egotean"
+
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "errorea netlink-en konexio-cachea eguneratzean: %s"
+
+#: ../src/NetworkManager.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "Aukera baliogabea. Erabili '--help' baliozko aukeren zerrenda ikusteko.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
+msgid "# Created by NetworkManager\n"
+msgstr "# NetworkManager-ek sortuta\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# %s(e)ndik batuta\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "ezin da netlink-en kudeaketa esleitu: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "ezin da netlink-ekin konektatu: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "ezin da netlink taldearekin elkartu: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "OHARRA: libc-en ebaztaileak ez du 3 izen-zerbitzari baino gehiago onartzen."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "Azpian zerrendatutako izen-zenbitzariak ez dira ezagutuko."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "Auto %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "Sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Konexio partekatua babestutako haririk gabeko sarearen bidez"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Konexio partekatua irekitako haririk gabeko sarearen bidez"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Aldatu sistemako ostalari-izen iraunkorra"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Aldatu sistemako konexioak"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "Sistemako arauek sistemako ezarpenak aldatzea saihesten dute"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "Sistemako arauek sistemako ostalari-izen iraunkorra aldatzea saihesten dute"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "Sistemako arauek babestutako haririk gabeko sareen bidez konexioak partekatzea saihesten dute"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "Sistemako arauek irakitako haririk gabeko sareen bidez konexioak partekatzea saihesten dute"
+
diff --git a/po/gl.po b/po/gl.po
index 5193a4b..ca5d3d5 100644
--- a/po/gl.po
+++ b/po/gl.po
@@ -2,53 +2,487 @@
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
 # This file is distributed under the same license as the PACKAGE package.
 #
-# Ignacio Casal Quinteiro <icq@cvs.gnome.org>, 2007.
-# Ignacio Casal Quinteiro <icq@svn.gnome.org>, 2008.
+# Ignacio Casal Quinteiro <icq@cvs.gnome.org>, 2007, 2008.
+# Miguel Anxo Bouzada <mbouzada@gmail.com>, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: gl\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-02-13 16:21+0100\n"
-"PO-Revision-Date: 2008-02-13 16:23+0100\n"
-"Last-Translator: Ignacio Casal Quinteiro <icq@svn.gnome.org>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2009-09-29 03:25+0000\n"
+"PO-Revision-Date: 2010-02-25 11:06+0100\n"
+"Last-Translator: Miguel Anxo Bouzada <mbouzada@gmail.com>\n"
 "Language-Team: Galego <proxecto@trasno.net>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
 
-#: ../src/nm-netlink-monitor.c:188 ../src/nm-netlink-monitor.c:448
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "O ficheiro de chave PEM non ten a etiqueta de final %s."
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr "Non parece un ficheiro de chave privada PEM."
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr "Non hai memoria abondo para almacenar o ficheiro PEM."
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr "Ficheiro PEM malformado: Proc-Type non  a primeira etiqueta."
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr "Ficheiro PEM malformado: a etiqueta Proc-Type %s  descoecida."
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr "Ficheiro PEM malformado: Proc-Type non  a segunda etiqueta."
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr "Ficheiro PEM malformado: non se atopou ningn IV na etiqueta DEK-Info"
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr "Ficheiro PEM malformado: formato de IV incorrecto na etiqueta DEK-Info"
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr "Ficheiro PEM malformado: o cifrado da chave privada %s  descoecido"
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "Non puido ser decodificada a chave privada."
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "O certificado PEM %s non ten unha etiqueta de final %s."
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "Fallou ao decodificar o certificado"
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "Non hai memoria abondo para almacenar os datos do certificado"
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "Non hai memoriaabondo para almacenar os datos do ficheiro"
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV debe ter un nmero par de bytes en lonxitude."
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "Non hai memoria abondo para almacenar o IV."
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV contn dxitos non hexadecimais."
+
+#: ../libnm-util/crypto.c:382
+#: ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266
+#: ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:335
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "O cifrado %s da chave privada  descoecido."
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "Non hai memoria abondo para descifrar esta chave privada."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "Non foi posbel determinar o tipo de chave privada"
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "Non hai memoria abondo para almacenar a chave privada descifrada."
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "Produciuse un erro ao iniciar o motor de cifrado"
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "Produciuse un erro ao iniciar a arquitectura MD5: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Lonxitude de IV incorrecta (debe ser polo menos %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165
+#: ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "Non hai memoria abondo para o bfer da chave descifrada."
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "Produciuse un erro ao inicializar o contexto de cifrado para o descifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "Produciuse un erro ao establecer a chave simtrica para o descifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "Produciuse un erro ao establecer IV para o descifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "Produciuse un erro ao descifrar a chave privada: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210
+#: ../libnm-util/crypto_nss.c:266
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Produciuse un fallo ao descifrar a chave privada: lonxitude de desprazamento non esperada."
+
+#: ../libnm-util/crypto_gnutls.c:221
+#: ../libnm-util/crypto_nss.c:277
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "Produciuse un erro ao descifrar a chave privada"
+
+#: ../libnm-util/crypto_gnutls.c:286
+#: ../libnm-util/crypto_nss.c:355
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Non foi posbel asignar a memoria para cifrar."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Produciuse un erro ao inicializar o contexto da chave de cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Produciuse un erro ao establecer a chave simtrica para o cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Produciuse un erro ao establecer IV para o cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Produciuse un erro ao cifrar os datos: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "Produciuse un erro ao iniciar a certificacin dos datos: %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "Non se puido decodificar o certificado: %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "Non foi posbel iniciar o decodificador PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "Non foi posbel decodificar o ficheiro PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "Non foi posbel verificar o ficheiro PKCS#12: %s"
+
+#: ../libnm-util/crypto_nss.c:57
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "Produciuse un erro ao iniciar o motor de cifrado:%d."
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "Produciuse un erro ao iniciar o contexto MD5: %d."
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Lonxitude de IV incorrecta (debe ser polo menos %d)."
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "Produciuse un erro ao iniciar a raura de cifrado para o descifrado"
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "Produciuse un erro ao establecer a chave simtrica para o descifrado."
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "Produciuse un erro ao establecer IV para o descifrado."
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "Produciuse un erro ao iniciar o contexto de descifrado."
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "Produciuse un erro ao descifrar a chave privada: %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Produciuse un erro ao descifrar a chave privada: os datos descifrados son moi grandes."
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "Produciuse un erro ao finalizar o descifrado da chave privada: %d."
+
+#: ../libnm-util/crypto_nss.c:363
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Produciuse un erro ao inicializar a raura da cifra de cifrado."
+
+#: ../libnm-util/crypto_nss.c:371
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "Produciuse un erro ao establecer a chave simtrica para o cifrado."
+
+#: ../libnm-util/crypto_nss.c:379
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "Produciuse un erro ao establecer IV para o cifrado."
+
+#: ../libnm-util/crypto_nss.c:387
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "Produciuse un erro ao inicializar o contexto de cifrado."
+
+#: ../libnm-util/crypto_nss.c:395
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "Produciuse un erro ao cifrar: %d."
+
+#: ../libnm-util/crypto_nss.c:403
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Tamao non agardado de datos despois de cifrar."
+
+#: ../libnm-util/crypto_nss.c:446
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "Non foi posbel decodificar o certificado: %d"
+
+#: ../libnm-util/crypto_nss.c:481
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "Non foi posbel converter a chave a UCS2: %d"
+
+#: ../libnm-util/crypto_nss.c:509
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "Non foi posbel iniciar o decodificador PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:518
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "Non fo posbel decodificar o ficheiro PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:527
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "Non foi posbel verficar o ficheiro PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:556
+msgid "Could not generate random data."
+msgstr "Non foi posbel xerar datos aleatorios."
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "Sen memoria abondo para crear a chave de cifrado."
+
+#: ../libnm-util/nm-utils.c:1633
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Non foi posbel asignar memoria para a creacin do ficheiro PEM,"
+
+#: ../libnm-util/nm-utils.c:1645
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Non foi posbel asignar memoria para escribir IV no ficheiro PEM."
+
+#: ../libnm-util/nm-utils.c:1657
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Non foi posbel asignar memoria para escribir a chave cifrada no ficheiro PEM."
+
+#: ../libnm-util/nm-utils.c:1676
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "Non foi posbel asignar memoria para os datos do ficheiro PEM."
+
+#: ../src/nm-netlink-monitor.c:194
+#: ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:569
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
-msgstr "erro procesando a mensaxe netlink: %s"
+msgstr "produciuse un erro procesando a mensaxe netlink: %s"
 
-#: ../src/nm-netlink-monitor.c:245
+#: ../src/nm-netlink-monitor.c:260
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "non se pode crear o manexador netlink para monitorizar o estado da ligazn: %s"
+msgstr "non  posbel crear o manexador netlink para monitorizar o estado da ligazn: %s"
 
-#: ../src/nm-netlink-monitor.c:255
+#: ../src/nm-netlink-monitor.c:270
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "non se pode conectar ao netlink para monitorizar o estado da lingazn: %s"
+msgstr "non  posbel conectar ao netlink para monitorizar o estado da lingazn: %s"
 
-#: ../src/nm-netlink-monitor.c:263
+#: ../src/nm-netlink-monitor.c:278
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "non se pode unir ao grupo netlink para monitorizar o estado da ligazn: %s"
+msgstr "non  posbel unir ao grupo netlink para monitorizar o estado da ligazn: %s"
 
-#: ../src/nm-netlink-monitor.c:271
+#: ../src/nm-netlink-monitor.c:286
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "non se pode asignar a ligazn  cach netlink para monitorizar o estado da ligazn: %s"
+msgstr "non  posbel asignar a ligazn  cach netlink para monitorizar o estado da ligazn: %s"
 
-#: ../src/nm-netlink-monitor.c:471
-#, c-format
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
-msgstr "ocorreu un erro agardando por datos nun socket"
+msgstr "producouse un erro agardando por datos nun socket"
+
+#: ../src/nm-netlink-monitor.c:558
+#, c-format
+#| msgid "error processing netlink message: %s"
+msgid "error updating link cache: %s"
+msgstr "produciuse un erro ao actualizar a cach de ligazns: %s"
 
-#: ../src/NetworkManager.c:255
+#: ../src/NetworkManager.c:330
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Opcin invlida. Use --help para ver a lista de opcins vlidas.\n"
+msgstr "Opcin incorrecta. Use --help para ver a lista de opcins vlidas.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+msgid "# Created by NetworkManager\n"
+msgstr "# Creado por NetworkManager\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# Fusionado desde %s\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "non  posbel asignar un manexador para a ligazon de rede: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "non  posbel conectar coa ligazn de rede: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "non  posbel unir ao grupo da ligazn de rede: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "NOTE: o importador libc non permite mis de 3 nomes de servidores."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "Os nomes de servidores listados a seguir poden non ser recoecidos"
+
+#: ../src/system-settings/nm-default-wired-connection.c:194
+#, c-format
+msgid "Auto %s"
+msgstr "Auto %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+msgid "System"
+msgstr "Sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Conexin compartida a travs dunha rede WiFi protexida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Conexin compartida a travs dunha rede WiFi aberta"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Modificar o nome persistente do anfitrin do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Modificar as conexins do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "A poltica do sistema impide a modificacin da configuracin do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "A poltica do sistema impide a modificacin do nome do anfitrin do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "A poltica do sistema impide compartir conexins a travs dunha rede WiFi protexida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "A poltica do sistema impide compartir conexins a travs dunha rede WiFi aberta"
 
diff --git a/po/hi.po b/po/hi.po
new file mode 100644
index 0000000..291b17a
--- /dev/null
+++ b/po/hi.po
@@ -0,0 +1,477 @@
+# translation of NetworkManager.master.po to Hindi
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Rajesh Ranjan <rranjan@redhat.com>, 2010.
+msgid ""
+msgstr ""
+"Project-Id-Version: NetworkManager.master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-02-24 03:25+0000\n"
+"PO-Revision-Date: 2010-02-24 12:47+0530\n"
+"Last-Translator: Rajesh Ranjan <rranjan@redhat.com>\n"
+"Language-Team: Hindi <Red Hat>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.11.4\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n\n"
+
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "PEM        '%s'  ."
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr " PEM         ."
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr "PEM         ."
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr " PEM : Proc-Type    ."
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr " PEM :  Proc-Type  '%s'."
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr " PEM : DEK-Info    ."
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr " PEM :  IV DEK-Info    ."
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr " PEM : IV    DEK-Info  ."
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr " PEM :     '%s'."
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "      ."
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "PEM  '%s'      '%s'  ."
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "    ."
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "        ."
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "        ."
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV         ."
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "IV       ."
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV      ."
+
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "   '%s'  ."
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "        ."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "      ."
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "         ."
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "     ."
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "MD5     : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr " IV  (   %zd  )."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "       ."
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "       : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "        : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "IV        : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "     : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "     :   ."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "     ."
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "       ."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "       : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "        : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "IV        : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "     : %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "    : %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "PKCS#12     : %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "PKCS#12     : %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "PKCS#12    : %s"
+
+#: ../libnm-util/crypto_nss.c:56
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "     : %d."
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "MD5     : %d."
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr " IV  (    %d  )."
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "       ."
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "        ."
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "IV        ."
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "     ."
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "     : %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "     :     ."
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "         : %d."
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "      ."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "        ."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "IV        ."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "     ."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "   : %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "      ."
+
+#: ../libnm-util/crypto_nss.c:447
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "    : %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "  UCS2    : %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "PKCS#12      : %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "PKCS#12     : %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "PKCS#12    : %d"
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "    ."
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "         ."
+
+#: ../libnm-util/nm-utils.c:1632
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM         ."
+
+#: ../libnm-util/nm-utils.c:1644
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "IV  PEM          ."
+
+#: ../libnm-util/nm-utils.c:1656
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "   PEM          ."
+
+#: ../libnm-util/nm-utils.c:1675
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM         ."
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "netlink     : %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "            : %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "          : %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "          : %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "           : %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "         "
+
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "     : %s"
+
+#: ../src/NetworkManager.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr " .   --help        .\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:297
+msgid "# Created by NetworkManager\n"
+msgstr "#    \n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:313
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"#%s   \n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "     : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "     : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "      : %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ": libc  3         ."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "          ."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr " %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3220
+msgid "System"
+msgstr ""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "  WiFi     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "  WiFi     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "    "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "  "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "        ."
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "         ."
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "  WiFi          "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "  WiFi          "
+
diff --git a/po/kn.po b/po/kn.po
index 999ee84..bd04652 100644
--- a/po/kn.po
+++ b/po/kn.po
@@ -3,21 +3,866 @@
 # Copyright (C) 2009 NetworkManager's COPYRIGHT HOLDER
 # This file is distributed under the same license as the NetworkManager package.
 #
-# Shankar Prasad <svenkate@redhat.com>, 2009.
+# Shankar Prasad <svenkate@redhat.com>, 2009, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager.po.master.kn\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-06-15 03:24+0000\n"
-"PO-Revision-Date: 2009-06-15 14:24+0530\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-21 03:24+0000\n"
+"PO-Revision-Date: 2010-04-20 18:07+0530\n"
 "Last-Translator: Shankar Prasad <svenkate@redhat.com>\n"
-"Language-Team: Kannada <en@li.org>\n"
+"Language-Team: kn-IN <>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: KBabel 1.11.4\n"
+"X-Generator: Lokalize 1.0\n"
 "Plural-Forms:  nplurals=2; plural=(n != 1);\n"
 
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+": nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr ""
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr ": %s  "
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr ": %s -   ."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr " "
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr " "
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr " : %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr ":    ."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr ""
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr ""
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr " "
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr ""
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "'%s'      "
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "     "
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr ""
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr ""
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr ""
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN   ()"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN   ( )"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN "
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN  (IP  )"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN "
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN  "
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN  "
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr " "
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr " "
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "  "
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "   "
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN   "
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN    "
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "   "
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN    "
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN   "
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "  VPN  ()"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr " VPN "
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "  "
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr ": %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr " \n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr ":   ."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr ": %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr ":   : %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr ":  %d sec ."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr ":   : %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr ": '%s'     ."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr ":  : %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr ": '%s'     ."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr ": id  uuid  ."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr ":     : %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr ":     ."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr ":  \n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr ": 'con'  '%s'  ."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr ": D-Bus   ."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr ":   ."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr ":   ."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr ":  :  ."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+": nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr " "
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr ""
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr " "
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "  ()"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "  ()"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "  ( )"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "  (IP  )"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr ""
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr " "
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr ""
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "( )"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: IP4  0x%X   "
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s,  %d MHz,  %d Mb/s,  %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr ""
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", : "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " "
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr ""
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr ""
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "()"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr ""
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW "
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+" :\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr " "
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr ""
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"   \n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP "
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA "
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 "
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP "
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP "
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"     %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* =  AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"   \n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "()"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr ""
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr ""
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPV4 :\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr ""
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr ""
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr ""
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr " "
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr ": '%s'  ."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr ": '%s'    ."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr ": '%s'     ."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr ": '%s' (%s)      : %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr " : %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr ": iface  ."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi  "
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr ": '%s'   WiFi ."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr ":"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr ": hwaddr  ."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr ": '%s'  hwaddr    ."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP "
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr ""
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr " "
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "  :"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr ""
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA :"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN :"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr ": '%s'  'dev wifi'  ."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr ": '%s'  'dev'  ."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+": nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr ""
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr " "
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr ""
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr ""
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "NetworkManager "
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr ""
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr ""
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM  :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr ":  'wifi' : '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr ":  'wwan'  : '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr ": '%s'  'nm'  ."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+": %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "'%s'    , 'nmcli help'  ."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli ,  %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "'%s'    , 'nmcli -help'  ."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d   ,  ......"
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr ": NetworkManager   ."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr ""
+
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -103,8 +948,9 @@ msgstr "IV   
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV  -   ."
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "   '%s' ."
@@ -124,72 +970,106 @@ msgstr "   
 msgid "Not enough memory to store decrypted private key."
 msgstr "       ."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "    ."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "MD5    : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr " IV  ( %zd )."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "     ."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "     : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "     : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "  IV   : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "    : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "    :   "
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "    ."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "   ."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr " IV   : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "   : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "   : %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "PKCS#12    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "PKCS#12    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12  : %s"
 
-#: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "    : %d."
@@ -199,105 +1079,191 @@ msgstr "   
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "MD5   : %d."
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr " IV  ( %d )."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "     ."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "     ."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "  IV   ."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "    ."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "    : %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr ""
+"    :     "
+" ."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "     : %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "    ."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "    ."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr " IV   ."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "   ."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr " : %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "   ."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "   : %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr " UCS2   : %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12   : %d"
 
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:458
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "   ."
+
+#: ../libnm-util/nm-utils.c:1818
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "     ."
+
+#: ../libnm-util/nm-utils.c:1928
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM     ."
+
+#: ../libnm-util/nm-utils.c:1940
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "IV  PEM     ."
+
+#: ../libnm-util/nm-utils.c:1952
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr ""
+"  PEM     ."
+
+#: ../libnm-util/nm-utils.c:1971
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM     ."
+
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "    : %s"
 
-#: ../src/nm-netlink-monitor.c:255
+#: ../src/nm-netlink-monitor.c:259
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "         : %s"
+msgstr ""
+"         "
+": %s"
 
-#: ../src/nm-netlink-monitor.c:265
+#: ../src/nm-netlink-monitor.c:269
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "       : %s"
+msgstr ""
+"       : %"
+"s"
 
-#: ../src/nm-netlink-monitor.c:273
+#: ../src/nm-netlink-monitor.c:277
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "       : %s"
+msgstr ""
+"       : %s"
 
-#: ../src/nm-netlink-monitor.c:281
+#: ../src/nm-netlink-monitor.c:285
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "        : %s"
+msgstr ""
+"        "
+": %s"
+
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
+msgid "error occurred while waiting for data on socket"
+msgstr "    "
 
-#: ../src/nm-netlink-monitor.c:422
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "     : %s"
 
-#: ../src/nm-netlink-monitor.c:488
-msgid "error occurred while waiting for data on socket"
-msgstr "    "
-
-#: ../src/NetworkManager.c:329
+#: ../src/main.c:498
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr " .     --help  .\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:97
+#: ../src/main.c:558
+#, c-format
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s.     --help  .\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
 msgid "# Created by NetworkManager\n"
 msgstr "# NetworkManager  \n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:103
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -306,28 +1272,97 @@ msgstr ""
 "# %s  \n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:255
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "  DHCP  ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "'dhclient'  ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "'dhcpcd'  ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr " DHCP  '%s'"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "    : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:209
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "   : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:306
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "   : %s"
+
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "   '%s'"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "   '%s'"
+
+#: ../src/named-manager/nm-named-manager.c:314
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr ": libc ()    ."
+msgstr ""
+": libc ()    "
+"."
 
-#: ../src/named-manager/nm-named-manager.c:257
+#: ../src/named-manager/nm-named-manager.c:316
 msgid "The nameservers listed below may not be recognized."
 msgstr "    ."
 
-#: ../src/system-settings/nm-default-wired-connection.c:182
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
 msgstr " %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2168
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3229
 msgid "System"
-msgstr ""
+msgstr ""
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "  WiFi    "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "  WiFi    "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "    "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
 msgid "Modify system connections"
 msgstr "  "
 
-#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
 msgid "System policy prevents modification of system settings"
 msgstr "     "
 
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "       "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr ""
+"  WiFi       "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr ""
+"  WiFi       "
diff --git a/po/ml.po b/po/ml.po
new file mode 100644
index 0000000..d5728ea
--- /dev/null
+++ b/po/ml.po
@@ -0,0 +1,1320 @@
+# translation of NetworkManager.master_upstream.ml.po to
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# Ani Peter <apeter@redhat.com>, 2010
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: NetworkManager.master_upstream.ml\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-03-23 03:25+0000\n"
+"PO-Revision-Date: 2010-03-23 17:04+0530\n"
+"Last-Translator: Ani Peter <apeter@redhat.com> |  \n"
+"Language-Team:  Swathantra Malayalam Computing |    <smc-discuss@googlegroups.com>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.11.4\n"
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+" : nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr ""
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr ": %s  ."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr ": %s -   ."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr " "
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr " "
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr " : %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr ":   ."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr ""
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr ""
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr " "
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr ""
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr " '%s'-   "
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "    "
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr ""
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr ""
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr ""
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "   ()"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "   ( )"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "  "
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "   (  )"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "  "
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "  "
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr " "
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr " "
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr ""
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr " "
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "   "
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "   "
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "     "
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "  "
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "   "
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "   "
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "   "
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "  "
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "  "
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr ": %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr " \n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr ":   ."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr ": %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr ":   : %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr ":  %d   ."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr ":   : %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr ": '%s'-    ."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr ":  : %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr ":   '%s' ."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr ": id  uuid ."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr ":   : %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr ":   ."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr ":  \n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr ": 'con'  '%s' ."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr ": D-Bus-   ."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr ":    ."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr ":    ."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr ":   :   ."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+" : nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr " "
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr ""
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr ""
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "  ()"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "  ()"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "  ( )"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "  (  )"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr " "
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr " "
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr ""
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "()"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s:IP4  0x%X  "
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Freq %d MHz, Rate %d Mb/s,  %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "-"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ",  : "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr ""
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr ""
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr ""
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "()"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr ""
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW "
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  :\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr " "
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr ""
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"   \n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP "
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA "
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 "
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP "
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP "
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"     %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = current AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"   \n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr ""
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr ""
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr ""
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4 :\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr ""
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr ""
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr ""
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr " "
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr ": '%s'  ."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr ":  '%s' ."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr ":  '%s'  ."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr ":  '%s' (%s)  : %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr " : %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr ": iface ."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi  "
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr ": '%s'    ."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr ":"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr ": hwaddr ."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr ": hwaddr '%s'-   ."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr " "
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "-"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr ""
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "  :"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr ""
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA :"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN :"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr ": 'dev wifi'  '%s' ."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr ": 'dev'  '%s' ."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+" : nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "asleep"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr " "
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "enabled"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "disabled"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr " "
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr ""
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr ""
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM  :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr ":  'wifi' : '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr ":  'wwan' : '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr ": 'nm'  '%s' ."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+" : %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "'%s'  , 'nmcli help' ."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli ,  %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "'%s'  , 'nmcli -help' ."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d  ,  ..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr ":    ."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr ""
+
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "PEM     '%s' ."
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr " PEM    ."
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr " PEM     ."
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr " PEM : Proc-   ."
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr " PEM :  Proc-  '%s'."
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr " PEM : DEK-Info   ."
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr " PEM : DEK-Info  IV ."
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr " PEM : DEK-Info  IV-  ."
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr " PEM :     '%s'."
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "    ."
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "PEM  '%s'-   '%s' ."
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "   ."
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "    ."
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "    ."
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV-    ."
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "IV   ."
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV- - ."
+
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "   '%s' ."
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "     ."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "    ."
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "      ."
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "   ."
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "MD5   : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr " IV  ( %zd )"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "     ."
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr " IV  : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "    :   ."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "    ."
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "   ,"
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "    : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr " IV  : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "   : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "   : %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "   : %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "PKCS#12   : %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "PKCS#12    : %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "PKCS#12   : %s"
+
+#: ../libnm-util/crypto_nss.c:56
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "   : %d."
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "MD5   : %d."
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr " IV  ( %d )."
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "    ."
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "    ."
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr " IV  ."
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "   ."
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "    : %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "    :     ."
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "    : %d."
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "    ."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "    ."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr " IV   ."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "   ."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "  : %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "    "
+
+#: ../libnm-util/crypto_nss.c:447
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "   : %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr " UCS2-  : %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "PKCS#12   : %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "PKCS#12    : %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "PKCS#12   : %d"
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "   ."
+
+#: ../libnm-util/nm-utils.c:1802
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "    ."
+
+#: ../libnm-util/nm-utils.c:1912
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM     ."
+
+#: ../libnm-util/nm-utils.c:1924
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM  IV    ."
+
+#: ../libnm-util/nm-utils.c:1936
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM        ."
+
+#: ../libnm-util/nm-utils.c:1955
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM     ."
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "   : %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "      : %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "      : %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "       : %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "       : %s "
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "   "
+
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "   : %s"
+
+#: ../src/main.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr " .      --help .\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
+msgid "# Created by NetworkManager\n"
+msgstr "#  NetworkManager\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# %s-  \n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "   : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "   : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "   : %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ": libc  3   ."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "   ."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr " %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr ""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "      "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "      "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "   "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "   "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "       "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "      "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "         "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "         "
+
diff --git a/po/or.po b/po/or.po
index dc12475..5ab219e 100644
--- a/po/or.po
+++ b/po/or.po
@@ -1,87 +1,23 @@
-# translation of or.po to Oriya
+# translation of NetworkManager.master.or.po to Oriya
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
 # This file is distributed under the same license as the PACKAGE package.
 #
-# Manoj Kumar Giri <mgiri@redhat.com>, 2008.
+# Manoj Kumar Giri <mgiri@redhat.com>, 2008, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: or\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&amp;component=general\n"
-"POT-Creation-Date: 2008-11-25 21:02+0000\n"
-"PO-Revision-Date: 2008-11-26 19:09+0530\n"
+"Project-Id-Version: NetworkManager.master.or\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2009-09-29 03:25+0000\n"
+"PO-Revision-Date: 2010-02-10 16:09+0530\n"
 "Last-Translator: Manoj Kumar Giri <mgiri@redhat.com>\n"
-"Language-Team: Oriya\n"
+"Language-Team: Oriya <oriya-it@googlegroups.com>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms: nplurals=2;plural=(n!=1)\n"
-
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:454
-#, c-format
-msgid "error processing netlink message: %s"
-msgstr "netlink   : %s"
-
-#: ../src/nm-netlink-monitor.c:251
-#, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "     netlink   : %s"
-
-#: ../src/nm-netlink-monitor.c:261
-#, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "     netlink    : %s"
-
-#: ../src/nm-netlink-monitor.c:269
-#, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "     netlink   : %s"
-
-#: ../src/nm-netlink-monitor.c:277
-#, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "     netlink   : %s"
-
-#: ../src/nm-netlink-monitor.c:418
-#, c-format
-msgid "error updating link cache: %s"
-msgstr "    : %s"
-
-#: ../src/nm-netlink-monitor.c:484
-msgid "error occurred while waiting for data on socket"
-msgstr "      "
-
-#: ../src/NetworkManager.c:293
-#, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr " .         --  .\n"
-
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:88
-msgid "# Created by NetworkManager\n"
-msgstr "# NetworkManager  \n"
-
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:94
-#, c-format
-msgid ""
-"# Merged from %s\n"
-"\n"
-msgstr ""
-"# %s  \n"
+"Plural-Forms:  nplurals=2; plural=(n!=1);\n\n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:256
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr ": libc resolver 3   nameserver  ."
-
-#: ../src/named-manager/nm-named-manager.c:258
-msgid "The nameservers listed below may not be recognized."
-msgstr "  nameserver  ."
-
-#: ../system-settings/src/main.c:376
-#, c-format
-msgid "Auto %s"
-msgstr " %s"
-
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -167,8 +103,9 @@ msgstr "IV     
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV    ."
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:335
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "   '%s'  ."
@@ -188,66 +125,106 @@ msgstr "   
 msgid "Not enough memory to store decrypted private key."
 msgstr "        ."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "    ."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "MD5    : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr " IV  ( %zd  )"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "       ."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "     : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "      : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "  IV   : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "     : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:266
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "    :   "
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:277
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "     ."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:355
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "       "
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "     : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "      : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "  IV   : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "   : %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "   : %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "PKCS#12    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "PKCS#12    : %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12    : %s"
@@ -262,58 +239,258 @@ msgstr "   
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "MD5    : %d."
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr " IV  (   %d  )"
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "     ."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "      ."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "  IV   ."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "    ."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "    : %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "    :    "
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "     : %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:363
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "     "
+
+#: ../libnm-util/crypto_nss.c:371
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "      "
+
+#: ../libnm-util/crypto_nss.c:379
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "  IV   "
+
+#: ../libnm-util/crypto_nss.c:387
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "    "
+
+#: ../libnm-util/crypto_nss.c:395
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "  : %d."
+
+#: ../libnm-util/crypto_nss.c:403
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "     "
+
+#: ../libnm-util/crypto_nss.c:446
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "   : %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:481
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr " UCS2   : %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:509
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:518
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:527
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12   : %d"
 
+#: ../libnm-util/crypto_nss.c:556
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "    "
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+#| msgid "Not enough memory to decrypt private key."
+msgid "Not enough memory to make encryption key."
+msgstr "         "
+
+#: ../libnm-util/nm-utils.c:1633
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM        "
+
+#: ../libnm-util/nm-utils.c:1645
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM  IV       "
+
+#: ../libnm-util/nm-utils.c:1657
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM          "
+
+#: ../libnm-util/nm-utils.c:1676
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM     "
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:569
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "netlink   : %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "     netlink   : %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "     netlink    : %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "     netlink   : %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "     netlink   : %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "      "
+
+#: ../src/nm-netlink-monitor.c:558
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "    : %s"
+
+#: ../src/NetworkManager.c:330
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr " .         --  .\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+msgid "# Created by NetworkManager\n"
+msgstr "# NetworkManager  \n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# %s  \n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "netlink   : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "netlink    : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "netlink   : %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ": libc resolver 3   nameserver  ."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "  nameserver  ."
+
+#: ../src/system-settings/nm-default-wired-connection.c:194
+#, c-format
+msgid "Auto %s"
+msgstr " %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+msgid "System"
+msgstr ""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "  WiFi   "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "  WiFi   "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "    "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "   "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "      "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "       "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "    WiFi      "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "    WiFi      "
+
diff --git a/po/pa.po b/po/pa.po
index 859ec9f..052406e 100644
--- a/po/pa.po
+++ b/po/pa.po
@@ -4,221 +4,1478 @@
 #
 # Amanpreet Singh Alam <aalam@redhat.com>, 2004.
 # Amanpreet Singh Alam <amanpreetalam@yahoo.com>, 2005.
-# A S Alam <aalam@users.sf.net>, 2007.
+# A S Alam <aalam@users.sf.net>, 2007, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager.HEAD\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2007-02-03 18:35+0000\n"
-"PO-Revision-Date: 2007-02-04 08:37+0530\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug."
+"cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-03-24 03:26+0000\n"
+"PO-Revision-Date: 2010-04-03 14:08+0530\n"
 "Last-Translator: A S Alam <aalam@users.sf.net>\n"
-"Language-Team: Punjabi <fedora-trans-pa@redhat.com>\n"
+"Language-Team: Punjabi/Panjabi <kde-i18n-doc@kde.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: KBabel 1.11.4\n"
+"X-Generator: Lokalize 1.0\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 "\n"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:417
-msgid "Cannot add VPN connection"
-msgstr "VPN      "
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+": nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+#| msgid "VPN Connections"
+msgid "Connections"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr ""
+
+#: ../cli/src/connections.c:163
+#, c-format
+#| msgid "VPN Connections"
+msgid "System connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+#| msgid "VPN Connections"
+msgid "User connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr ": %s    "
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr ": %s -      "
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "- "
+
+#: ../cli/src/connections.c:205
+#| msgid "VPN Connections"
+msgid "User connections"
+msgstr " "
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr " : %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr ":     "
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr ""
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+#| msgid "none"
+msgid "no"
+msgstr ""
+
+#: ../cli/src/connections.c:297
+#| msgid "VPN Connections"
+msgid "Active connections"
+msgstr " "
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr ""
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr " '%s'      "
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "      "
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "    "
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr " "
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr ""
+
+#: ../cli/src/connections.c:744
+#| msgid "VPN Connections"
+msgid "VPN connecting (prepare)"
+msgstr "VPN  ()"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN      (   )"
+
+#: ../cli/src/connections.c:748
+#| msgid "VPN Connections"
+msgid "VPN connecting"
+msgstr "VPN     "
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN      (IP     )"
+
+#: ../cli/src/connections.c:752
+#| msgid "VPN Connections"
+msgid "VPN connected"
+msgstr "VPN  "
+
+#: ../cli/src/connections.c:754
+#| msgid "VPN Connections"
+msgid "VPN connection failed"
+msgstr "VPN   "
+
+#: ../cli/src/connections.c:756
+#| msgid "VPN Connections"
+msgid "VPN disconnected"
+msgstr "VPN -"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr " "
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr " "
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr " -  "
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "   ' "
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN    "
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN      "
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "      "
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN   '   "
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN      "
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "  VPN   "
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr " VPN "
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "  "
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:419
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr ": %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "  \n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr ":      "
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr ": %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr ":     : %s"
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr ": - %d   "
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr ":     : %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+#| msgid "Error retrieving VPN connection '%s'"
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr ": '%s'       "
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+#| msgid "Error retrieving VPN connection '%s'"
+msgid "Error: Unknown connection: %s."
+msgstr ":  : %s"
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr ": -  '%s'   "
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr ": id  uuid  "
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr ":     : %s"
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr ":     "
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr ":    \n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr ": 'con'  '%s'  "
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr ": -      "
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr ":      "
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr ":      "
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr ":     :      "
+
+#: ../cli/src/devices.c:73
+#, c-format
 msgid ""
-"No suitable VPN software was found on your system. Contact your system "
-"administrator."
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"     VPN       "
-"   "
+": nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "-"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "-"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "- "
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "     ()"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "     ( )"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "     (  )"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "     (IP     )"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr " "
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:461
-msgid "Cannot import VPN connection"
-msgstr "VPN      "
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "  "
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:463
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr ""
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+#| msgid "none"
+msgid "(none)"
+msgstr "( )"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: IP4  0x%X   "
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s,  %d MHz,  %d Mb/s,  %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "-"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ",  : "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+#| msgid "WPA Enterprise"
+msgid " Enterprise"
+msgstr " "
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr ""
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr ""
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "()"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr ""
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW "
+
+#: ../cli/src/devices.c:319
 #, c-format
 msgid ""
-"Cannot find suitable software for VPN connection type '%s' to import the "
-"file '%s'. Contact your system administrator."
+"\n"
+"  Capabilities:\n"
 msgstr ""
-"VPN   '%s'   '%s'      "
-"         "
+"\n"
+"  :\n"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:580
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr " "
+
+#: ../cli/src/devices.c:336
 #, c-format
-msgid "Error retrieving VPN connection '%s'"
-msgstr "VPN  '%s'   "
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr ""
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:583
+#: ../cli/src/devices.c:348
 #, c-format
 msgid ""
-"Could not find the UI files for VPN connection type '%s'. Contact your "
-"system administrator."
+"\n"
+"  Wireless Properties\n"
 msgstr ""
-"VPN   '%s'  UI       "
-"   "
+"\n"
+"  \n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP "
+
+#: ../cli/src/devices.c:355
+#| msgid "WPA Enterprise"
+msgid "WPA Encryption"
+msgstr "WPA "
+
+#: ../cli/src/devices.c:357
+#| msgid "WPA2 Enterprise"
+msgid "WPA2 Encryption"
+msgstr "WPA2  "
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:727
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP "
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP "
+
+#: ../cli/src/devices.c:368
 #, c-format
-msgid "Delete VPN connection \"%s\"?"
-msgstr " VPN \"%s\"   ?"
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"     %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* =  AP)"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:730
+#: ../cli/src/devices.c:374
 #, c-format
 msgid ""
-"All information about the VPN connection \"%s\" will be lost and you may "
-"need your system administrator to provide information to create a new "
-"connection."
+"\n"
+"  Wired Properties\n"
 msgstr ""
-"VPN  \"%s\"          "
-"         "
-"   "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.c:924
-msgid "Unable to load"
-msgstr "   "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.c:926
-msgid "Cannot find some needed resources (the glade file)!"
-msgstr "     ( )!"
-
-#. druid_window = GTK_DIALOG (gtk_dialog_new_with_buttons (_("Create VPN Connection"),
-#. NULL,
-#. GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
-#. GTK_STOCK_CANCEL,
-#. GTK_RESPONSE_REJECT,
-#. GTK_STOCK_APPLY,
-#. GTK_RESPONSE_ACCEPT,
-#. NULL));
-#: ../gnome/vpn-properties/nm-vpn-properties.c:1081
-msgid "Create VPN Connection"
-msgstr "VPN  "
-
-#. gtk_container_add (GTK_CONTAINER (druid_window->vbox), GTK_WIDGET(gtk_label_new("Some label")));
-#. gtk_box_pack_start (GTK_BOX (druid_window->vbox), GTK_WIDGET(druid), TRUE,TRUE,0);
-#. gtk_box_pack_start (GTK_BOX (druid_window->vbox), GTK_WIDGET(gtk_label_new("Some label")), TRUE,TRUE,0);
-#. toplevel = gtk_widget_get_toplevel (GTK_WIDGET (druid));
-#. gtk_signal_connect (GTK_OBJECT (toplevel), "delete_event", GTK_SIGNAL_FUNC (vpn_window_close), NULL);
-#. make the druid window modal wrt. our main window
-#. gtk_window_set_modal (druid_window, TRUE);
-#. gtk_window_set_transient_for (GTK_WINDOW(druid_window), GTK_WINDOW (dialog));
-#. Edit dialog
-#: ../gnome/vpn-properties/nm-vpn-properties.c:1099
-msgid "Edit VPN Connection"
-msgstr "VPN  "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:1
-msgid "Add a new VPN connection"
-msgstr "  VPN  "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:2
-msgid "Delete the selected VPN connection"
-msgstr " VPN  "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:3
-msgid "E_xport"
-msgstr "(_x)"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:4
-msgid "Edit the selected VPN connection"
-msgstr " VPN  ' "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:5
-msgid "Export the VPN settings to a file"
-msgstr "VPN    ' "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:6
-msgid "Export the selected VPN connection to a file"
-msgstr " VPN   ' "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:7
-msgid "Manage Virtual Private Network Connections"
-msgstr "    "
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:8
-msgid "VPN Connections"
-msgstr "VPN "
-
-#: ../src/nm-ap-security-wep.c:52
-msgid "40-bit WEP"
-msgstr "40- WEP"
-
-#: ../src/nm-ap-security-wep.c:54
-msgid "104-bit WEP"
-msgstr "104- WEP"
-
-#: ../src/nm-ap-security-wpa-psk.c:51
-msgid "WPA TKIP"
-msgstr "WPA TKIP"
-
-#: ../src/nm-ap-security-wpa-psk.c:53
-msgid "WPA CCMP"
-msgstr "WPA CCMP"
-
-#: ../src/nm-ap-security-wpa-psk.c:55
-msgid "WPA Automatic"
-msgstr "WPA "
-
-#: ../src/nm-ap-security-wpa-psk.c:60
-msgid "WPA2 TKIP"
-msgstr "WPA2 TKIP"
-
-#: ../src/nm-ap-security-wpa-psk.c:62
-msgid "WPA2 CCMP"
-msgstr "WPA2 CCMP"
-
-#: ../src/nm-ap-security-wpa-psk.c:64
-msgid "WPA2 Automatic"
-msgstr "WPA2 "
-
-#: ../src/nm-ap-security.c:334
-msgid "none"
-msgstr " "
+"\n"
+"    \n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr ""
+
+#: ../cli/src/devices.c:377
+#| msgid "none"
+msgid "on"
+msgstr ""
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr ""
 
-#: ../src/nm-netlink-monitor.c:174
+#: ../cli/src/devices.c:387
 #, c-format
-msgid "unable to create netlink socket for monitoring wired ethernet devices - %s"
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
 msgstr ""
-"    - %s    netlink   "
-" "
+"\n"
+"  IPv4 :\n"
 
-#: ../src/nm-netlink-monitor.c:192
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr ""
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "-"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr ""
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "  "
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr ": '%s'   "
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
 #, c-format
-msgid "unable to bind to netlink socket for monitoring wired ethernet devices - %s"
+msgid "Error: Device '%s' not found."
+msgstr ":  '%s'  "
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr ":  '%s'   -  "
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr ":  '%s' (%s) - : %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr " : %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr ": iface    "
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "  "
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr ":  '%s' -   "
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr ":"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr ": hwaddr    "
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr ": hwaddr '%s'     "
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP "
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "-"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr ""
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "- :"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr ""
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA :"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN :"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr ": 'dev wifi'  '%s'   "
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr ": 'dev'  '%s'   "
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
 msgstr ""
-"    - %s    netlink   "
-" "
+": nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "asleep"
+
+#: ../cli/src/network-manager.c:69
+#| msgid "VPN Connections"
+msgid "connecting"
+msgstr "    "
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr " "
 
-#: ../src/nm-netlink-monitor.c:427
-msgid "operation took too long"
-msgstr "     "
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr " "
 
-#: ../src/nm-netlink-monitor.c:524
-msgid "received data from wrong type of sender"
-msgstr "       "
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr " "
 
-#: ../src/nm-netlink-monitor.c:537
-msgid "received data from unexpected sender"
-msgstr "     "
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM   :"
 
-#: ../src/nm-netlink-monitor.c:666
-msgid "too much data was sent over socket and some of it was lost"
-msgstr "         '    "
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "  "
 
-#: ../src/nm-netlink-monitor.c:774
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "   "
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM  :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM :"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr ":  'wifi' : '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr ":  'wwan' : '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr ": 'nm'  '%s'   "
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+": %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr " '%s'  , 'nmcli help'   "
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli ,  %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr " '%s'   'nmcli -help'   "
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d  ,     ..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr ":       "
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr ""
+
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "PEM       '%s'  "
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr "PEM      "
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr "PEM         "
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr " PEM : Proc-Type    "
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr " PEM :  Proc-Type  '%s' "
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr " PEM : DEK-Info    "
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr " PEM : DEK-Info    IV  "
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr "  PEM : DEK-Info     IV"
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr " PEM :     '%s'"
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "      "
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "PEM  '%s'     '%s'  "
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "     "
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "        "
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "        "
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV       "
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "IV       "
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV  -  "
+
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "   '%s'  "
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "        "
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "      "
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "          "
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "      "
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "MD5      : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr " IV  (- %zd   )"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "        "
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "      : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "       : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "%s / %s :   IV     "
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "     : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "     :   "
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "     "
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "       "
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "      : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "       : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "  IV    : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "    : %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "   ' : %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "     : %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "PKCS#12      : %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "PKCS#12     : %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "PKCS#12     : %s"
+
+#: ../libnm-util/crypto_nss.c:56
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "     : %d"
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "MD5     : %d"
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr " IV  (- %d   )"
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "       "
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "        "
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "  IV     "
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "     : "
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "     : %d"
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "     :     "
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "        : %d"
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "       "
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "       "
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "  IV    "
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "      "
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "   : %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "       ' "
+
+#: ../libnm-util/crypto_nss.c:447
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "     : %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "  UCS2 '    : %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "PKCS#12      : %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "PKCS#12     : %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "PKCS#12     : %d"
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "      "
+
+#: ../libnm-util/nm-utils.c:1802
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "       "
+
+#: ../libnm-util/nm-utils.c:1912
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM         "
+
+#: ../libnm-util/nm-utils.c:1924
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM   IV       "
+
+#: ../libnm-util/nm-utils.c:1936
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM            "
+
+#: ../libnm-util/nm-utils.c:1955
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM         "
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "      : %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+#| msgid ""
+#| "unable to create netlink socket for monitoring wired ethernet devices - %s"
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "         : %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+#| msgid ""
+#| "unable to bind to netlink socket for monitoring wired ethernet devices - %"
+#| "s"
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "          : %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+#| msgid ""
+#| "unable to bind to netlink socket for monitoring wired ethernet devices - %"
+#| "s"
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "          : %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+#| msgid ""
+#| "unable to create netlink socket for monitoring wired ethernet devices - %s"
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "           : %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
 msgstr "       "
 
-#: ../src/nm-ap-security-wpa-eap.c:93 ../src/nm-ap-security-wpa-eap.c:117
-msgid "WPA2 Enterprise"
-msgstr "WPA2 "
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "     : %s"
+
+#: ../src/main.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "      --help  \n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:324
+msgid "# Created by NetworkManager\n"
+msgstr "#   \n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:340
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"#%s  \n"
+"\n"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "  DHCP     "
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "'dhclient'   "
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "'dhcpcd'   "
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr " DHCP  '%s'"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "netlink    : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "netlink     : %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "netlink     :: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ": libc     -      "
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "  -    "
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr " %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr ""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr " -     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr " -     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "  - "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "  "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "        "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "    -     "
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr ""
+"     -       "
+""
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr ""
+"     -       "
+
+#~ msgid "Cannot add VPN connection"
+#~ msgstr "VPN      "
+
+#~ msgid ""
+#~ "No suitable VPN software was found on your system. Contact your system "
+#~ "administrator."
+#~ msgstr ""
+#~ "     VPN          "
+
+#~ msgid "Cannot import VPN connection"
+#~ msgstr "VPN      "
+
+#~ msgid ""
+#~ "Cannot find suitable software for VPN connection type '%s' to import the "
+#~ "file '%s'. Contact your system administrator."
+#~ msgstr ""
+#~ "VPN   '%s'   '%s'          "
+#~ "     "
+
+#~ msgid ""
+#~ "Could not find the UI files for VPN connection type '%s'. Contact your "
+#~ "system administrator."
+#~ msgstr ""
+#~ "VPN   '%s'  UI          "
+
+#~ msgid "Delete VPN connection \"%s\"?"
+#~ msgstr " VPN \"%s\"   ?"
+
+#~ msgid ""
+#~ "All information about the VPN connection \"%s\" will be lost and you may "
+#~ "need your system administrator to provide information to create a new "
+#~ "connection."
+#~ msgstr ""
+#~ "VPN  \"%s\"              "
+#~ "        "
+
+#~ msgid "Unable to load"
+#~ msgstr "   "
+
+#~ msgid "Cannot find some needed resources (the glade file)!"
+#~ msgstr "     ( )!"
+
+#~ msgid "Create VPN Connection"
+#~ msgstr "VPN  "
+
+#~ msgid "Edit VPN Connection"
+#~ msgstr "VPN  "
+
+#~ msgid "Add a new VPN connection"
+#~ msgstr "  VPN  "
+
+#~ msgid "Delete the selected VPN connection"
+#~ msgstr " VPN  "
+
+#~ msgid "E_xport"
+#~ msgstr "(_x)"
+
+#~ msgid "Edit the selected VPN connection"
+#~ msgstr " VPN  ' "
+
+#~ msgid "Export the VPN settings to a file"
+#~ msgstr "VPN    ' "
+
+#~ msgid "Export the selected VPN connection to a file"
+#~ msgstr " VPN   ' "
+
+#~ msgid "Manage Virtual Private Network Connections"
+#~ msgstr "    "
+
+#~ msgid "40-bit WEP"
+#~ msgstr "40- WEP"
+
+#~ msgid "104-bit WEP"
+#~ msgstr "104- WEP"
+
+#~ msgid "WPA TKIP"
+#~ msgstr "WPA TKIP"
+
+#~ msgid "WPA CCMP"
+#~ msgstr "WPA CCMP"
+
+#~ msgid "WPA Automatic"
+#~ msgstr "WPA "
+
+#~ msgid "WPA2 TKIP"
+#~ msgstr "WPA2 TKIP"
+
+#~ msgid "WPA2 CCMP"
+#~ msgstr "WPA2 CCMP"
+
+#~ msgid "WPA2 Automatic"
+#~ msgstr "WPA2 "
+
+#~ msgid "operation took too long"
+#~ msgstr "     "
+
+#~ msgid "received data from wrong type of sender"
+#~ msgstr "       "
 
-#: ../src/nm-ap-security-wpa-eap.c:95 ../src/nm-ap-security-wpa-eap.c:122
-msgid "WPA Enterprise"
-msgstr "WPA "
+#~ msgid "received data from unexpected sender"
+#~ msgstr "     "
 
-#: ../src/nm-ap-security-leap.c:66 ../src/nm-ap-security-leap.c:82
-msgid "LEAP"
-msgstr "LEAP"
+#~ msgid "too much data was sent over socket and some of it was lost"
+#~ msgstr "         '    "
 
+#~ msgid "LEAP"
+#~ msgstr "LEAP"
diff --git a/po/pl.po b/po/pl.po
index bcee37a..7ffa179 100644
--- a/po/pl.po
+++ b/po/pl.po
@@ -8,9 +8,9 @@ msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-08-27 03:24+0000\n"
-"PO-Revision-Date: 2009-09-09 01:47+0200\n"
-"Last-Translator: Piotr Drg <piotrdrag@gmail.com>\n"
+"POT-Creation-Date: 2010-02-26 03:24+0000\n"
+"PO-Revision-Date: 2010-03-08 11:52+0100\n"
+"Last-Translator: Tomasz Dominikowski <dominikowski@gmail.com>\n"
 "Language-Team: Polish <gnomepl@aviary.pl>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -19,6 +19,1076 @@ msgstr ""
 "X-Poedit-Language: Polish\n"
 "X-Poedit-Country: Poland\n"
 
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout <timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Uycie: nmcli con { POLECENIE | help }\n"
+"  POLECENIE := { list | status | up | down }\n"
+"\n"
+"  list [id <identyfikator> | uuid <identyfikator> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <interfejs>] [ap <adres_sprztowy>] [--nowait] [--timeout <czas>]\n"
+"  down id <identyfikator> | uuid <identyfikator>\n"
+
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Poczenia"
+
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Nazwa"
+
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "Poczenia systemowe:\n"
+
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "Poczenia uytkownika:\n"
+
+
+#: ../cli/src/connections.c:178
+#: ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983
+#: ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003
+#: ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604
+#: ../cli/src/devices.c:614
+#: ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785
+#: ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Bd: brak parametru %s."
+
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Bd: %s - nie ma takiego poczenia."
+
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Poczenia systemowe"
+
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Poczenia uytkownika"
+
+
+#: ../cli/src/connections.c:212
+#: ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103
+#: ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494
+#: ../cli/src/devices.c:628
+#: ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Nieznany parametr: %s\n"
+
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Bd: nie podano prawidowego parametru."
+
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321
+#: ../cli/src/devices.c:353
+#: ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357
+#: ../cli/src/devices.c:359
+#: ../cli/src/devices.c:361
+msgid "yes"
+msgstr "tak"
+
+
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:304
+msgid "no"
+msgstr "nie"
+
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Aktywne poczenia"
+
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Domylne"
+
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Usuga"
+
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Urzdzenia"
+
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "brak aktywnych pocze na urzdzeniu \"%s\""
+
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "brak aktywnych pocze na urzdze"
+
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktywowanie"
+
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktywowano"
+
+
+#: ../cli/src/connections.c:735
+#: ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791
+#: ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76
+#: ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "nieznane"
+
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "czenie z VPN (przygotowanie)"
+
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "czenie z VPN (wymaga uwierzytelnienia)"
+
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "czenie z VPN"
+
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "czenie z VPN (pobieranie konfiguracji adresu IP)"
+
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "Poczono z VPN"
+
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "Poczenie z VPN si nie powiodo"
+
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "Rozczono z VPN"
+
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "nieznany powd"
+
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "brak"
+
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "uytkownik zosta rozczony"
+
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "podstawowe poczenie sieciowe zostao przerwane"
+
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "usuga VPN zostaa nieoczekiwanie zatrzymana"
+
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "usuga VPN zwrcia nieprawidow konfiguracj"
+
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "prba poczenia przekroczya czas oczekiwania"
+
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "usuga VPN nie zostaa uruchomiona w czasie"
+
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "uruchomienie usugi VPN si nie powiodo"
+
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "brak prawidowych hase VPN"
+
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "nieprawidowe hasa VPN"
+
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "poczenie zostao usunite"
+
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "stan: %s\n"
+
+
+#: ../cli/src/connections.c:806
+#: ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Aktywowano poczenie\n"
+
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Bd: aktywacja poczenia si nie powioda."
+
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "stan: %s (%d)\n"
+
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Bd: aktywacja poczenia si nie powioda: %s."
+
+
+#: ../cli/src/connections.c:855
+#: ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Bd: przekroczono czas oczekiwania o %d sekund."
+
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Bd: aktywacja poczenia si nie powioda: %s"
+
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Bd: uzyskanie aktywnego poczenia dla \"%s\" si nie powiodo."
+
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Stan aktywnego poczenia: %s\n"
+
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "cieka aktywnego poczenia: %s\n"
+
+
+#: ../cli/src/connections.c:976
+#: ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Bd: nieznane poczenie: %s."
+
+
+#: ../cli/src/connections.c:1011
+#: ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Bd: warto czasu oczekiwania \"%s\" jest nieprawidowa."
+
+
+#: ../cli/src/connections.c:1024
+#: ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Bd: naley poda identyfikator lub UUID."
+
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Bd: nie odnaleziono odpowiedniego urzdzenia: %s"
+
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Bd: nie odnaleziono odpowiedniego urzdzenia."
+
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Ostrzeenie: poczenie nie jest aktywne\n"
+
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Bd: polecenie \"con\" \"%s\" jest nieprawidowe."
+
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Bd: nie mona poczy si z D-Bus."
+
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Bd: nie mona uzyska ustawie systemu."
+
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Bd: nie mona uzyska ustawie uytkownika."
+
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Bd: nie mona uzyska pocze: usugi ustawie nie s uruchomione."
+
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Uycie: nmcli dev { POLECENIE | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <interfejs>]\n"
+"  disconnect iface <interfejs> [--nowait] [--timeout <czas>]\n"
+"  wifi [list [iface <interfejs>] | apinfo iface <interfejs> hwaddr <adres_sprztowy>]\n"
+"\n"
+
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "niezarzdzane"
+
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "niedostpne"
+
+
+#: ../cli/src/devices.c:97
+#: ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "rozczono"
+
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "czenie (przygotowanie)"
+
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "czenie (konfigurowanie)"
+
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "czenie (wymaga uwierzytelnienia)"
+
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "czenie (pobieranie konfiguracji adresu IP)"
+
+
+#: ../cli/src/devices.c:107
+#: ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "poczono"
+
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "poczenie si nie powiodo"
+
+
+#: ../cli/src/devices.c:132
+#: ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Nieznane"
+
+
+#. print them
+#: ../cli/src/devices.c:164
+#: ../cli/src/devices.c:266
+#: ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(brak)"
+
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: bd podczas konwertowania adresu IPv4 0x%X"
+
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, czstotliwo %d MHz, prdko %d Mb/s, sia sygnau %d"
+
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-hoc"
+
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", zaszyfrowane: "
+
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Enterprise"
+
+
+#: ../cli/src/devices.c:294
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Urzdzenie"
+
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Sterownik"
+
+
+#: ../cli/src/devices.c:299
+#: ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(nieznane)"
+
+
+#: ../cli/src/devices.c:300
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "State"
+msgstr "Stan"
+
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Adres sprztowy"
+
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Moliwoci:\n"
+
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Wykrywanie operatora"
+
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Prdko"
+
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  Waciwoci sieci bezprzewodowej\n"
+
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "Szyfrowanie WEP"
+
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "Szyfrowanie WPA"
+
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "Szyfrowanie WPA2"
+
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "Szyfr TKIP"
+
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "Szyfr CCMP"
+
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Bezprzewodowe punkty dostpowe %s\n"
+
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = biecy punkt dostpowy)"
+
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Waciwoci sieci przewodowej\n"
+
+
+#: ../cli/src/devices.c:377
+#: ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Operator"
+
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "wczone"
+
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "wyczone"
+
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  Ustawienia IPv4:\n"
+
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adres"
+
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Przedrostek"
+
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Brama"
+
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Stan urzdzenia"
+
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Bd: brak parametru \"%s\"."
+
+
+#: ../cli/src/devices.c:516
+#: ../cli/src/devices.c:655
+#: ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Bd: nie odnaleziono urzdzenia \"%s\"."
+
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Powodzenie: urzdzenie \"%s\" zostao rozczone."
+
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Bd: rozczenie urzdzenia \"%s\" (%s) si nie powiodo: %s"
+
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Stan urzdzenia: %d (%s)\n"
+
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Bd: naley poda interfejs."
+
+
+#: ../cli/src/devices.c:736
+#: ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Lista skanowania sieci WiFi"
+
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Bd: urzdzenie \"%s\" nie jest urzdzeniem WiFi."
+
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Urzdzenie:"
+
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Bd: naley poda adres sprztowy."
+
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Bd: nie odnaleziono punktu dostpowego z adresem sprztowym \"%s\"."
+
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+
+#: ../cli/src/devices.c:869
+#: ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parametry punkty dostpowego"
+
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Czstotliwo:"
+
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Tryb:"
+
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastruktura"
+
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Maksymalna prdko:"
+
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Sia sygnau:"
+
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Flagi:"
+
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "prywatne"
+
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "Flagi WPA:"
+
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "Flagi RSN:"
+
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Bd: polecenie \"dev wifi\" \"%s\" jest nieprawidowe."
+
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Bd: polecenie \"dev\" \"%s\" jest nieprawidowe."
+
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Uycie: nmcli nm { POLECENIE | help }\n"
+"\n"
+"  POLECENIE := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "wstrzymane"
+
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "czenie"
+
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "wczone"
+
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "wyczone"
+
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Stan programu NetworkManager"
+
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "Program NetworkManager jest uruchomiony:"
+
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "uruchamiany"
+
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "nieuruchomiony"
+
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Stan programu NetworkManager:"
+
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "Adres sprztowy programu NetworkManager:"
+
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107
+#: ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "Sie bezprzewodowa programu NetworkManager:"
+
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "WWAM sprztu programu NetworkManager:"
+
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109
+#: ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "WWAN programu NetworkManager:"
+
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Bd: nieprawidowy parametr \"wifi\": \"%s\"."
+
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Bd: nieprawidowy parametr \"wwan\": \"%s\"."
+
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Bd: parametr \"nm\" \"%s\" jest nieprawidowy."
+
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Uycie: %s [OPCJE] OBIEKT { POLECENIE | help }\n"
+"\n"
+"OPCJE\n"
+"  -t[erse]    zwize wyjcie\n"
+"  -p[retty]   sformatowane wyjcie\n"
+"  -v[ersion]  wywietla wersj programu\n"
+"  -h[elp]     wywietla t opcj\n"
+"\n"
+"OBIEKT\n"
+"  nm          stan programu NetworkManager\n"
+"  con         poczenia programu NetworkManager\n"
+"  dev         urzdzenia zarzdzane przez program NetworkManager\n"
+"\n"
+
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Obiekt \"%s\" jest nieznany. Mona sprbowa polecenie \"nmcli help\"."
+
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "narzdzie nmcli, wersja %s\n"
+
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Opcja \"%s\" jest nieznana. Mona sprbowa polecenie \"nmcli help\"."
+
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Przechwycono sygna %d, wyczanie..."
+
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Bd: nie mona poczy si z programem NetworkManager."
+
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Powodzenie"
+
+
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -29,10 +1099,11 @@ msgstr "Plik klucza PEM nie zawiera znacznika kocowego \"%s\"."
 msgid "Doesn't look like a PEM private key file."
 msgstr "Nie wyglda na plik klucza prywatnego PEM."
 
+
 #: ../libnm-util/crypto.c:138
 #, c-format
 msgid "Not enough memory to store PEM file data."
-msgstr "Brak wystarczajcej iloci pamici do przechowania danych PEM."
+msgstr "Brak wystarczajcej iloci pamici do przechowania danych pliku PEM."
 
 #: ../libnm-util/crypto.c:154
 #, c-format
@@ -57,7 +1128,7 @@ msgstr "Uszkodzony plik PEM: brak IV w znaczniku DEK-Info."
 #: ../libnm-util/crypto.c:190
 #, c-format
 msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
-msgstr "Uszkodzony plik PEM: niepoprawny format IV w znaczniku DEK-Info."
+msgstr "Uszkodzony plik PEM: nieprawidowy format IV w znaczniku DEK-Info."
 
 #: ../libnm-util/crypto.c:203
 #, c-format
@@ -67,17 +1138,18 @@ msgstr "Uszkodzony plik PEM: nieznany szyfr klucza prywatnego: \"%s\"."
 #: ../libnm-util/crypto.c:222
 #, c-format
 msgid "Could not decode private key."
-msgstr "Nie mona byo zdekodowa klucza prywatnego."
+msgstr "Nie mona zdekodowa klucza prywatnego."
 
 #: ../libnm-util/crypto.c:267
 #, c-format
 msgid "PEM certificate '%s' had no end tag '%s'."
 msgstr "Certyfikat PEM \"%s\" nie zawiera koczcego znacznika \"%s\"."
 
+
 #: ../libnm-util/crypto.c:277
 #, c-format
 msgid "Failed to decode certificate."
-msgstr "Nieudane zdekodowanie certyfikatu."
+msgstr "Zdekodowanie certyfikatu si nie powiodo."
 
 #: ../libnm-util/crypto.c:286
 #, c-format
@@ -89,24 +1161,28 @@ msgstr "Brak wystarczajcej iloci pamici do przechowania danych certyfikatu
 msgid "Not enough memory to store file data."
 msgstr "Brak wystarczajcej iloci pamici do przechowania danych pliku."
 
+
 #: ../libnm-util/crypto.c:324
 #, c-format
 msgid "IV must be an even number of bytes in length."
-msgstr "Ilo bajtw w IV musi by parzyst liczb."
+msgstr "Liczba bajtw w IV musi by liczb parzyst."
 
 #: ../libnm-util/crypto.c:333
 #, c-format
 msgid "Not enough memory to store the IV."
 msgstr "Brak wystarczajcej iloci pamici do przechowania IV."
 
+
 #: ../libnm-util/crypto.c:344
 #, c-format
 msgid "IV contains non-hexadecimal digits."
-msgstr "IV zawiera nie-szesnastkowe cyfry."
+msgstr "IV zawiera nieszesnastkowe cyfry."
 
 #: ../libnm-util/crypto.c:382
-#: ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266
+#: ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Nieznany szyfr klucza prywatnego \"%s\"."
@@ -116,187 +1192,353 @@ msgstr "Nieznany szyfr klucza prywatnego \"%s\"."
 msgid "Not enough memory to decrypt private key."
 msgstr "Brak wystarczajcej iloci pamici do odszyfrowania klucza prywatnego."
 
+
 #: ../libnm-util/crypto.c:511
 #, c-format
 msgid "Unable to determine private key type."
-msgstr "Nieudane okrelenie typu klucza prywatnego."
+msgstr "Nie mona okreli typu klucza prywatnego."
 
 #: ../libnm-util/crypto.c:530
 #, c-format
 msgid "Not enough memory to store decrypted private key."
 msgstr "Brak wystarczajcej iloci pamici do przechowania odszyfrowanego klucza prywatnego."
 
-#: ../libnm-util/crypto_gnutls.c:46
+
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
-msgstr "Nieudana inicjacja moduu szyfrowania."
+msgstr "Zainicjowanie moduu szyfrowania si nie powiodo."
+
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
-msgstr "Nieudana inicjacja moduu MD5: %s / %s."
+msgstr "Zainicjowanie moduu MD5 si nie powiodo: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152
-#: ../libnm-util/crypto_nss.c:178
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Nieprawidowa dugo IV (musi wynosi co najmniej %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165
+#: ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "Brak wystarczajcej iloci pamici dla bufora odszyfrowanego klucza."
 
-#: ../libnm-util/crypto_gnutls.c:160
+
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
-msgstr "Nieudana inicjacja kontekstu szyfru do odszyfrowania: %s / %s."
+msgstr "Zainicjowanie kontekstu szyfru do odszyfrowania si nie powiodo: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
-msgstr "Nieudane ustawienie klucza symetrycznego do odszyfrowania: %s / %s."
+msgstr "Ustawienie klucza symetrycznego do odszyfrowania si nie powiodo: %s / %s."
+
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
-msgstr "Nieudane ustawienie IV do odszyfrowania: %s / %s."
+msgstr "Ustawienie IV do odszyfrowania si nie powiodo: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
-msgstr "Nieudane odszyfrowanie klucza prywatnego: %s / %s."
+msgstr "Odszyfrowanie klucza prywatnego si nie powiodo: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+
+#: ../libnm-util/crypto_gnutls.c:210
+#: ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Odszyfrowanie klucza prywatnego si nie powiodo: nieoczekiwana dugo wypenienia."
+
+
+#: ../libnm-util/crypto_gnutls.c:221
+#: ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
-msgstr "Nieudane odszyfrowanie klucza prywatnego."
+msgstr "Odszyfrowanie klucza prywatnego si nie powiodo."
+
+
+#: ../libnm-util/crypto_gnutls.c:286
+#: ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Nie mona przydzieli pamici do szyfrowania."
+
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Zainicjowanie kontekstu szyfru do szyfrowania si nie powiodo: %s / %s."
+
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Ustawienie klucza symetrycznego do szyfrowania si nie powiodo: %s / %s."
+
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Ustawienie IV do szyfrowania si nie powiodo: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:235
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Zaszyfrowanie danych si nie powiodo: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Bd podczas inicjowania danych certyfikatu: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
-msgstr "Nie mona byo zdekodowa certyfikatu: %s"
+msgstr "Nie mona zdekodowa certyfikatu: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "Nie mona zainicjowa dekodera PKCS#12: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
-msgstr "Nie mona byo odszyfrowa pliku PKCS#12: %s"
+msgstr "Nie mona odszyfrowa pliku PKCS#12: %s"
+
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
-msgstr "Nie mona byo zweryfikowa pliku PKCS#12: %s"
+msgstr "Nie mona zweryfikowa pliku PKCS#12: %s"
 
-#: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
+
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
-msgstr "Nieudana inicjacja moduu szyfrowania: %d."
+msgstr "Zainicjowanie moduu szyfrowania si nie powiodo: %d."
+
 
 #: ../libnm-util/crypto_nss.c:111
 #, c-format
 msgid "Failed to initialize the MD5 context: %d."
-msgstr "Nieudana inicjacja kontekstu MD5: %d."
+msgstr "Zainicjowanie kontekstu MD5 si nie powiodo: %d."
 
-#: ../libnm-util/crypto_nss.c:186
+
+#: ../libnm-util/crypto_nss.c:179
 #, c-format
-msgid "Failed to initialize the decryption cipher slot."
-msgstr "Nieudana inicjacja slotu szyfru do odszyfrowania."
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Nieprawidowa dugo IV (musi wynosi co najmniej %d)."
+
 
 #: ../libnm-util/crypto_nss.c:196
 #, c-format
-msgid "Failed to set symmetric key for decryption."
-msgstr "Nieudane ustawienie klucza symetrycznego do odszyfrowania."
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "Zainicjowanie gniazda szyfru do odszyfrowania si nie powiodo."
+
 
 #: ../libnm-util/crypto_nss.c:206
 #, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "Ustawienie klucza symetrycznego do odszyfrowania si nie powiodo."
+
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
 msgid "Failed to set IV for decryption."
-msgstr "Nieudane ustawienie IV do odszyfrowania."
+msgstr "Ustawienie IV do odszyfrowania si nie powiodo."
+
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
-msgstr "Nieudana inicjacja kontekstu odszyfrowania."
+msgstr "Zainicjowanie kontekstu odszyfrowania si nie powiodo."
 
-#: ../libnm-util/crypto_nss.c:227
+
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
-msgstr "Nieudane odszyfrowanie klucza prywatnego: %d."
+msgstr "Odszyfrowanie klucza prywatnego si nie powiodo: %d."
+
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Odszyfrowanie klucza prywatnego si nie powiodo: odszyfrowane dane s za due."
+
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
-msgstr "Nieudane ukoczenie odszyfrowania klucza prywatnego: %d."
+msgstr "Zakoczenie odszyfrowania klucza prywatnego si nie powiodo: %d."
+
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Zainicjowanie gniazda szyfru do szyfrowania si nie powiodo."
+
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "Ustawienie klucza symetrycznego do szyfrowania si nie powiodo."
+
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "Ustawienie IV do szyfrowania si nie powiodo."
 
-#: ../libnm-util/crypto_nss.c:284
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "Zainicjowanie kontekstu szyfrowania si nie powiodo."
+
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "Zaszyfrowanie si nie powiodo: %d."
+
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Nieoczekiwana ilo danych po zaszyfrowaniu."
+
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
-msgstr "Nie mona byo zdekodowa certyfikatu: %d"
+msgstr "Nie mona zdekodowa certyfikatu: %d"
+
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
-msgstr "Nie mona skonwertowa hasa do UCS2: %d"
+msgstr "Nie mona przekonwertowa hasa do UCS2: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "Nie mona zainicjowa dekodera PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
-msgstr "Nie mona byo odszyfrowa pliku PKCS#12: %d"
+msgstr "Nie mona odszyfrowa pliku PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
-msgstr "Nie mona byo zweryfikowa pliku PKCS#12: %d"
+msgstr "Nie mona zweryfikowa pliku PKCS#12: %d"
+
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "Nie mona utworzy losowych danych."
+
+
+#: ../libnm-util/nm-utils.c:1545
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "Brak wystarczajcej iloci pamici, aby utworzy klucz szyfrowania."
+
+
+#: ../libnm-util/nm-utils.c:1655
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Nie mona przydzieli pamici do utworzenia pliku PEM."
+
+
+#: ../libnm-util/nm-utils.c:1667
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Nie mona przydzieli pamici do zapisywania IV do pliku PEM."
+
+
+#: ../libnm-util/nm-utils.c:1679
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Nie mona przydzieli pamici do zapisywania zaszyfrowanego klucza do pliku PEM."
+
+
+#: ../libnm-util/nm-utils.c:1698
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "Nie mona przydzieli pamici dla danych pliku PEM."
 
 #: ../src/nm-netlink-monitor.c:194
 #: ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "bd podczas przetwarzania komunikatu netlink: %s"
 
+
 #: ../src/nm-netlink-monitor.c:260
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "nie mona utworzy uchwytu netlink dla monitorowania statusu poczenia: %s"
+msgstr "nie mona przydzieli uchwytu netlink dla monitorowania stanu poczenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:270
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "nie mona poczy si z netlink dla monitorowania statusu poczenia: %s"
+msgstr "nie mona poczy si z netlink dla monitorowania stanu poczenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:278
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "nie mona doczy do grupy netlink dla monitorowania statusu poczenia: %s"
+msgstr "nie mona doczy do grupy netlink dla monitorowania stanu poczenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:286
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "nie mona utworzy buforw poczenia netlink dla monitorowania statusu poczenia: %s"
+msgstr "nie mona przydzieli pamici podrcznej poczenia netlink dla monitorowania stanu poczenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
-msgstr "napotkano bd podczas oczekiwania na dane"
+msgstr "wystpi bd podczas oczekiwania na dane na gniedzie"
+
+
+#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "bd podczas aktualizowania pamici podrcznej poczenia: %s"
 
-#: ../src/NetworkManager.c:330
+
+#: ../src/NetworkManager.c:494
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Bdna opcja. Parametr --help wywietla list poprawnych opcji.\n"
+msgstr "Nieprawidowa opcja. Parametr --help wywietli list prawidowych opcji.\n"
+
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
 msgid "# Created by NetworkManager\n"
-msgstr "# Utworzony przez NetworkManager\n"
+msgstr "# Utworzony przez program NetworkManager\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -305,6 +1547,22 @@ msgstr ""
 "# Scalony od %s\n"
 "\n"
 
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "nie mona przydzieli uchwytu netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "nie mona poczy si z netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "nie mona doczy do grupy netlink: %s"
+
 #: ../src/named-manager/nm-named-manager.c:315
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
 msgstr "UWAGA: obsuga nazw libc nie obsuguje wicej ni 3 serwery nazw."
@@ -313,14 +1571,16 @@ msgstr "UWAGA: obsuga nazw libc nie obsuguje wicej ni 3 serwery nazw."
 msgid "The nameservers listed below may not be recognized."
 msgstr "Ponisze serwery nazw nie mog nie zosta rozpoznane."
 
-#: ../src/system-settings/nm-default-wired-connection.c:194
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
-msgstr "Auto %s"
+msgstr "Automatyczne %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2446
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
 msgid "System"
-msgstr "System"
+msgstr "Systemowe"
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
 msgid "Connection sharing via a protected WiFi network"
@@ -353,3 +1613,4 @@ msgstr "Polityka systemu powstrzymuje wspdzielenie pocze przez chronio
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
 msgid "System policy prevents sharing connections via an open WiFi network"
 msgstr "Polityka systemu powstrzymuje wspdzielenie pocze przez otwart sie WiFi"
+
diff --git a/po/sv.po b/po/sv.po
index f8f2d2b..d9d9147 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -1,7 +1,7 @@
 # Swedish messages for NetworkManager.
-# Copyright (C) 2004, 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 2004, 2005, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 # Christian Rose <menthos@menthos.com>, 2004, 2005, 2006.
-# Daniel Nylander <po@danielnylander.se>, 2006, 2008, 2009.
+# Daniel Nylander <po@danielnylander.se>, 2006, 2008, 2009, 2010.
 #
 # $Id: sv.po,v 1.14 2006/12/10 18:34:55 dnylande Exp $
 #
@@ -9,8 +9,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-08-27 03:24+0000\n"
-"PO-Revision-Date: 2009-09-05 09:45+0100\n"
+"POT-Creation-Date: 2010-02-26 03:24+0000\n"
+"PO-Revision-Date: 2010-03-02 22:05+0100\n"
 "Last-Translator: Daniel Nylander <po@danielnylander.se>\n"
 "Language-Team: Swedish <tp-sv@listor.tp-sv.se>\n"
 "MIME-Version: 1.0\n"
@@ -18,6 +18,940 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout <timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Anvndning: nmcli con { KOMMANDO | help }\n"
+"  KOMMANDO := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | anvndare]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <grnssnitt>] [ap <hwaddr>] [--nowait] [--timeout <tidsgrns>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+#| msgid "_VPN Connections"
+msgid "Connections"
+msgstr "Anslutningar"
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Namn"
+
+#: ../cli/src/connections.c:163
+#, c-format
+#| msgid "Modify system connections"
+msgid "System connections:\n"
+msgstr "Systemanslutningar:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+#| msgid "No network connection"
+msgid "User connections:\n"
+msgstr "Anvndaranslutningar:\n"
+
+#: ../cli/src/connections.c:178
+#: ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983
+#: ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003
+#: ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604
+#: ../cli/src/devices.c:614
+#: ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785
+#: ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Fel: %s-argument saknas."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Fel: %s - ingen sdan anslutning."
+
+#: ../cli/src/connections.c:196
+#| msgid "Modify system connections"
+msgid "System-wide connections"
+msgstr "Systemanslutningar"
+
+#: ../cli/src/connections.c:205
+#| msgid "No network connection"
+msgid "User connections"
+msgstr "Anvndaranslutningar"
+
+#: ../cli/src/connections.c:212
+#: ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103
+#: ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494
+#: ../cli/src/devices.c:628
+#: ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Oknd parameter: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Fel: ingen giltig parameter angiven."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321
+#: ../cli/src/devices.c:353
+#: ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357
+#: ../cli/src/devices.c:359
+#: ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ja"
+
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:304
+msgid "no"
+msgstr "nej"
+
+#: ../cli/src/connections.c:297
+#| msgid "Modify system connections"
+msgid "Active connections"
+msgstr "Aktiva anslutningar"
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Standard"
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Tjnst"
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Enheter"
+
+#: ../cli/src/connections.c:659
+#, c-format
+#| msgid "VPN connection to '%s'"
+msgid "no active connection on device '%s'"
+msgstr "ingen aktiv anslutning p enheten \"%s\""
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ingen aktiv anslutning eller enhet"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktiverar"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktiverad"
+
+#: ../cli/src/connections.c:735
+#: ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791
+#: ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76
+#: ../cli/src/network-manager.c:98
+#| msgid "(unknown)"
+msgid "unknown"
+msgstr "oknt"
+
+#: ../cli/src/connections.c:744
+#| msgid "VPN connecting to '%s'"
+msgid "VPN connecting (prepare)"
+msgstr "VPN ansluter (frbereder)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN ansluter (behver autentisering)"
+
+#: ../cli/src/connections.c:748
+#| msgid "_VPN Connections"
+msgid "VPN connecting"
+msgstr "VPN ansluter"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN ansluter (hmtar IP-konfiguration)"
+
+#: ../cli/src/connections.c:752
+#| msgid "_VPN Connections"
+msgid "VPN connected"
+msgstr "VPN ansluten"
+
+#: ../cli/src/connections.c:754
+#| msgid "VPN Connect Failure"
+msgid "VPN connection failed"
+msgstr "VPN-anslutning misslyckades"
+
+#: ../cli/src/connections.c:756
+#| msgid "VPN Connect Failure"
+msgid "VPN disconnected"
+msgstr "VPN frnkopplad"
+
+#: ../cli/src/connections.c:767
+#| msgid "(unknown)"
+msgid "unknown reason"
+msgstr "oknd anledning"
+
+#: ../cli/src/connections.c:769
+#| msgid "None"
+msgid "none"
+msgstr "ingen"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "anvndaren kopplades frn"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "basntverksanslutningen avbrts"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN-tjnsten stoppades ovntat"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN-tjnsten returnerade en ogiltig konfiguration"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "anslutningsfrsket versteg tidsgrnsen"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN-tjnsten startade inte i tid"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN-tjnsten misslyckades med att starta"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "inga giltiga VPN-hemligheter"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "ogiltiga VPN-hemligheter"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "anslutningen togs bort"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "tillstnd: %s\n"
+
+#: ../cli/src/connections.c:806
+#: ../cli/src/connections.c:832
+#, c-format
+#| msgid "Connection _Information"
+msgid "Connection activated\n"
+msgstr "Anslutning aktiverad\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+#| msgid "Connection to the wired network failed."
+msgid "Error: Connection activation failed."
+msgstr "Fel: Aktivering av anslutning misslyckades."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "tillstnd: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Fel: Aktivering av anslutning misslyckades: %s."
+
+#: ../cli/src/connections.c:855
+#: ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Fel: Tidsgrnsen %d sekunder gick ut."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Fel: Aktivering av anslutning misslyckades: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Fel: Hmtning av aktiv anslutning fr \"%s\" misslyckades."
+
+#: ../cli/src/connections.c:921
+#, c-format
+#| msgid "VPN connection to '%s'"
+msgid "Active connection state: %s\n"
+msgstr "Tillstnd fr aktiv anslutning: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+#| msgid "VPN connection to '%s'"
+msgid "Active connection path: %s\n"
+msgstr "Skvg fr aktiv anslutning: %s\n"
+
+#: ../cli/src/connections.c:976
+#: ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Fel: Oknd anslutning: %s."
+
+#: ../cli/src/connections.c:1011
+#: ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Fel: vrdet \"%s\" fr tidsgrnsen r inte giltigt."
+
+#: ../cli/src/connections.c:1024
+#: ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Fel: id eller uuid mste anges."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Fel: Ingen lmplig enhet hittades: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Fel: Ingen lmplig enhet hittades."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Varning: Anslutningen r inte aktiv\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Fel: \"con\"-kommandot \"%s\" r inte giltigt."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Fel: kunde inte ansluta till D-Bus."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Fel: Kunde inte f systeminstllningar."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Fel: Kunde inte f anvndarinstllningar."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Fel: Kan inte f anslutningar: instllningstjnster r inte igng."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Anvndning: nmcli dev { KOMMANDO | help }\n"
+"\n"
+"  KOMMANDO := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <grnssnitt>]\n"
+"  disconnect iface <grnssnitt> [--nowait] [--timeout <tidsgrns>]\n"
+"  wifi [list [iface <grnssnitt>] | apinfo iface <grnssnitt> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "ohanterad"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "otillgnglig"
+
+#: ../cli/src/devices.c:97
+#: ../cli/src/network-manager.c:73
+#| msgid "_Disconnect VPN..."
+msgid "disconnected"
+msgstr "frnkopplad"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "ansluter (frbereder)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "ansluter (konfigurerar)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "ansluter (behver autentisering)"
+
+#: ../cli/src/devices.c:105
+#| msgid "Connection _Information"
+msgid "connecting (getting IP configuration)"
+msgstr "ansluter (hmtar IP-konfiguration)"
+
+#: ../cli/src/devices.c:107
+#: ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "ansluten"
+
+#: ../cli/src/devices.c:109
+#| msgid "Connection _Information"
+msgid "connection failed"
+msgstr "anslutningen misslyckades"
+
+#: ../cli/src/devices.c:132
+#: ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Oknt"
+
+#. print them
+#: ../cli/src/devices.c:164
+#: ../cli/src/devices.c:266
+#: ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+#| msgid "(unknown)"
+msgid "(none)"
+msgstr "(ingen)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: fel vid konvertering av IP4-adress 0x%X"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Frekv %d MHz, Hast %d Mb/s, Styrka %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", Krypterad: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Enterprise"
+
+#: ../cli/src/devices.c:294
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Enhet"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Drivrutin"
+
+#: ../cli/src/devices.c:299
+#: ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(oknt)"
+
+#: ../cli/src/devices.c:300
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "State"
+msgstr "Tillstnd"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Hrdvaruadress"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Frmgor:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Brardetektering"
+
+#: ../cli/src/devices.c:336
+#, c-format
+#| msgid "%d Mb/s"
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Hastighet"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  Trdlsa egenskaper\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP-kryptering"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA-kryptering"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2-kryptering"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP-chiffer"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP-chiffer"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Trdlsa accesspunkter %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = aktuell AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Trdbundna egenskaper\n"
+
+#: ../cli/src/devices.c:377
+#: ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Brare"
+
+#: ../cli/src/devices.c:377
+#| msgid "None"
+msgid "on"
+msgstr "p"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "av"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4-instllningar:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adress"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Prefix"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Gateway"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Status fr enheter"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Fel: \"%s\"-argument saknas."
+
+#: ../cli/src/devices.c:516
+#: ../cli/src/devices.c:655
+#: ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Fel: Enheten \"%s\" hittades inte."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Lyckades: Enheten \"%s\" kopplades frn."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Fel: Frnkoppling av enheten \"%s\" (%s) misslyckades: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Enhetstillstnd: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Fel: grnssnitt (iface) mste anges."
+
+#: ../cli/src/devices.c:736
+#: ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi-avskningslista"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Fel: Enheten \"%s\" r inte en WiFi-enhet."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Enhet:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Fel: hwaddr mste anges."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Fel: Accesspunkt med hwaddr \"%s\" hittades inte."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+#| msgid "%d Mb/s"
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869
+#: ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP-parametrar"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Frekvens:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Lge:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastruktur"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Maximal bitfrekvens:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Styrka:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Flaggor:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "integritet"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA-flaggor:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN-flaggor:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Fel: \"dev wifi\"-kommandot \"%s\" r inte giltigt."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Fel: \"dev\"-kommandot \"%s\" r inte giltigt."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Anvndning: nmcli nm { KOMMANDO | help }\n"
+"\n"
+"  KOMMANDO := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "sover"
+
+#: ../cli/src/network-manager.c:69
+#| msgid "VPN connecting to '%s'"
+msgid "connecting"
+msgstr "ansluter"
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "aktiverad"
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "inaktiverad"
+
+#: ../cli/src/network-manager.c:102
+#| msgid "NetworkManager Applet"
+msgid "NetworkManager status"
+msgstr "Status fr Ntverkshanterare"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM kr:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "kr"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "kr inte"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM tillstnd:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM trdls hrdvara:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107
+#: ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM trdls:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN hrdvara:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109
+#: ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Fel: ogiltig \"wifi\"-parameter: \"%s\"."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Fel: ogiltig \"wwan\"-parameter: \"%s\"."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Fel: \"nm\"-kommandot \"%s\" r inte giltigt."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Anvndning: %s [FLAGGOR] OBJEKT { KOMMANDO | help }\n"
+"\n"
+"FLAGGOR\n"
+"  -t[erse]    kort utdata\n"
+"  -p[retty]   vackert utdata\n"
+"  -v[ersion]  visa programversion\n"
+"  -h[elp]     skriv ut denna hjlp\n"
+"\n"
+"OBJEKT\n"
+"  nm          status fr Ntverkshanterare\n"
+"  con         anslutningar i Ntverkshanterare\n"
+"  dev         enheter hanterade av Ntverkshanterare\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Objektet \"%s\" r oknt, prova \"nmcli help\"."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli-verktyg, version %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Flagan \"%s\" r oknd, prova \"nmcli -help\"."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Fngade signal %d, stnger av..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Fel: Kunde inte ansluta till Ntverkshanterare."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Lyckades"
+
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -104,8 +1038,10 @@ msgid "IV contains non-hexadecimal digits."
 msgstr "IV innehller icke-hexadecimala siffror."
 
 #: ../libnm-util/crypto.c:382
-#: ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266
+#: ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Privata nyckelchiffret \"%s\" var oknt."
@@ -125,73 +1061,115 @@ msgstr "Kunde inte bestmma typ av privat nyckel."
 msgid "Not enough memory to store decrypted private key."
 msgstr "Inte tillrckligt mycket minne fr att lagra dekrypterad privat nyckel."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "Misslyckades med att initiera krypteringsmotorn."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "Misslyckades med att initiera MD5-motorn: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152
-#: ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Ogiltig IV-lngd (mste vara minst %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165
+#: ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "Inte tillrckligt mycket minne fr buffert fr dekrypterade nycklar."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "Misslyckades med att initiera chifferkontexten fr dekryptering: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "Misslyckades med att stlla in symmetrisk nyckel fr dekryptering: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "Misslyckades med att stlla in IV fr dekryptering: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "Misslyckades med att dekryptera den privata nyckeln: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210
+#: ../libnm-util/crypto_nss.c:267
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Misslyckades med att dekryptera privata nyckeln: ovntad utfyllningslngd."
+
+#: ../libnm-util/crypto_gnutls.c:221
+#: ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "Misslyckades med att dekryptera privata nyckeln."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286
+#: ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Kunde inte allokera minne fr kryptering."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Misslyckades med att initiera chifferkontexten fr kryptering: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Misslyckades med att stlla in symmetrisk nyckel fr kryptering: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Misslyckades med att stlla in IV fr kryptering: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Misslyckades med att kryptera datat: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Fel vid initiering av certifikatdata: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "Kunde inte avkoda certifikat: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "Kunde inte initiera PKCS#12-avkodare: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "Kunde inte avkoda PKCS#12-fil: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "Kunde inte verifiera PKCS#12-fil: %s"
 
-#: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Misslyckades med att initiera krypteringsmotorn: %d."
@@ -201,63 +1179,143 @@ msgstr "Misslyckades med att initiera krypteringsmotorn: %d."
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "Misslyckades med att initiera MD5-kontexten: %d."
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Ogiltig IV-lngd (mste vara minst %d)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "Misslyckades med att initiera dekrypteringschifferplatsen."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "Misslyckades med att stlla in symmetrisk nyckel fr dekryptering."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "Misslyckades med att stlla in IV fr dekryptering."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "Misslyckades med att initiera dekrypteringskontexten."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "Misslyckades med att dekryptera privata nyckeln: %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Misslyckades med att dekryptera privata nyckeln: dekrypterat data r fr stort."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "Misslyckades med att frdigstlla dekryptering av den privata nyckeln: %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Misslyckades med att initiera krypteringschifferplatsen."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "Misslyckades med att stlla in symmetrisk nyckel fr kryptering."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "Misslyckades med att stlla in IV fr kryptering."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "Misslyckades med att initiera krypteringskontexten."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "Misslyckades med att kryptera: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Ovntad mngd data efter kryptering."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "Kunde inte avkoda certifikat: %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "Kunde inte konvertera lsenord till UCS2: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "Kunde inte initiera PKCS#12-avkodare: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "Kunde inte avkoda PKCS#12-fil: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "Kunde inte verifiera PKCS#12-fil: %d"
 
+#: ../libnm-util/crypto_nss.c:557
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "Kunde inte generera slumpmssigt data."
+
+#: ../libnm-util/nm-utils.c:1545
+#, c-format
+#| msgid "Not enough memory to create private key decryption key."
+msgid "Not enough memory to make encryption key."
+msgstr "Inte tillrckligt mycket minne fr att skapa krypteringsnyckel."
+
+#: ../libnm-util/nm-utils.c:1655
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Kunde inte allokera minne fr att skapa PEM-fil."
+
+#: ../libnm-util/nm-utils.c:1667
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Kunde inte allokera minne fr skrivning av IV till PEM-fil."
+
+#: ../libnm-util/nm-utils.c:1679
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Kunde inte allokera minne fr skrivning av krypterad nyckel till PEM-fil."
+
+#: ../libnm-util/nm-utils.c:1698
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "Kunde inte allokera minne fr PEM-fildata."
+
 #: ../src/nm-netlink-monitor.c:194
 #: ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "fel vid behandling av netlink-meddelande: %s"
@@ -283,19 +1341,26 @@ msgid "unable to allocate netlink link cache for monitoring link status: %s"
 msgstr "kan inte allokera netlink-lnkcache fr vervakning av lnkstatus: %s"
 
 #: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
 msgstr "fel intrffade vid vntan p data i uttaget"
 
-#: ../src/NetworkManager.c:330
+#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "fel vid uppdatering av lnkcache: %s"
+
+#: ../src/NetworkManager.c:494
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr "Ogiltig flagga.  Anvnd --help fr att se en lista ver giltiga flaggor.\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
 msgid "# Created by NetworkManager\n"
 msgstr "# Skapad av Ntverkshanterare\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -304,6 +1369,24 @@ msgstr ""
 "# Sammanfogad frn %s\n"
 "\n"
 
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "kan inte allokera netlink-handtag: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "kan inte ansluta till netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "kan inte g med i netlink-grupp: %s"
+
 #: ../src/named-manager/nm-named-manager.c:315
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
 msgstr "OBSERVERA: uppslag via glibc kanske inte har std fr fler n 3 namnservrar."
@@ -312,13 +1395,12 @@ msgstr "OBSERVERA: uppslag via glibc kanske inte har std fr fler n 3 namns
 msgid "The nameservers listed below may not be recognized."
 msgstr "Namnservrarna listade nedan kanske inte kommer att knnas igen."
 
-#: ../src/system-settings/nm-default-wired-connection.c:194
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
 msgstr "Automatisk %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2446
-#| msgid "Open System"
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
 msgid "System"
 msgstr "System"
 
@@ -335,7 +1417,6 @@ msgid "Modify persistent system hostname"
 msgstr "ndra bestende vrdnamn fr systemet"
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
-#| msgid "No active connections!"
 msgid "Modify system connections"
 msgstr "ndra systemanslutningar"
 
@@ -355,12 +1436,6 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett skyddat tr
 msgid "System policy prevents sharing connections via an open WiFi network"
 msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet trdlst ntverk"
 
-#~ msgid "error updating link cache: %s"
-#~ msgstr "fel vid uppdatering av lnkcache: %s"
-#~ msgid "Not enough memory to create private key decryption key."
-#~ msgstr ""
-#~ "Inte tillrckligt mycket minne fr att skapa dekrypteringsnyckel fr "
-#~ "privat nyckel."
 #~ msgid "operation took too long"
 #~ msgstr "tgrden tog fr lng tid"
 #~ msgid "received data from wrong type of sender"
@@ -373,22 +1448,14 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet tr
 #~ msgstr "Lsenfras fr det trdlsa ntverket %s"
 #~ msgid "Connection to the wireless network '%s' failed."
 #~ msgstr "Anslutning till det trdlsa ntverket \"%s\" misslyckades."
-#~ msgid "Connection to the wired network failed."
-#~ msgstr "Anslutning till det trdburna ntverket misslyckades."
 #~ msgid "Error displaying connection information:"
 #~ msgstr "Fel vid visning av anslutningsinformation:"
 #~ msgid "Could not find some required resources (the glade file)!"
 #~ msgstr "Kunde inte hitta en del ndvndiga resurser (glade-filen)!"
-#~ msgid "%d Mb/s"
-#~ msgstr "%d Mb/s"
 #~ msgid "Wired Ethernet (%s)"
 #~ msgstr "Trdbundet Ethernet (%s)"
 #~ msgid "Wireless Ethernet (%s)"
 #~ msgstr "Trdlst Ethernet (%s)"
-#~ msgid "Unknown"
-#~ msgstr "Oknt"
-#~ msgid "NetworkManager Applet"
-#~ msgstr "Panelprogram fr ntverkshantering"
 #~ msgid ""
 #~ "Copyright  2004-2006 Red Hat, Inc.\n"
 #~ "Copyright  2005-2006 Novell, Inc."
@@ -427,8 +1494,6 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet tr
 #~ msgstr ""
 #~ "Kunde inte starta VPN-anslutningen \"%s\" p grund av ett fel vid start "
 #~ "av VPN-programmet."
-#~ msgid "VPN Connect Failure"
-#~ msgstr "VPN-anslutningsfel"
 #~ msgid "Could not start the VPN connection '%s' due to a connection error."
 #~ msgstr ""
 #~ "Kunde inte starta VPN-anslutningen \"%s\" p grund av ett anslutningsfel."
@@ -454,8 +1519,6 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet tr
 #~ msgstr "Ntverksenheten \"%s (%s)\" stder inte trdls genomskning."
 #~ msgid "The network device \"%s (%s)\" does not support link detection."
 #~ msgstr "Ntverksenheten \"%s (%s)\" stder inte lnkdetektering."
-#~ msgid "(unknown)"
-#~ msgstr "(oknt)"
 #~ msgid "Preparing device %s for the wired network..."
 #~ msgstr "Frbereder enheten %s fr det trdbundna ntverket..."
 #~ msgid "Preparing device %s for the wireless network '%s'..."
@@ -478,28 +1541,18 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet tr
 #~ msgstr "Ntverkshanteraren r inte igng"
 #~ msgid "Networking disabled"
 #~ msgstr "Ntverk inaktiverat"
-#~ msgid "No network connection"
-#~ msgstr "Ingen ntverksanslutning"
 #~ msgid "Wired network connection"
 #~ msgstr "Trdbunden ntverksanslutning"
 #~ msgid "Connected to an Ad-Hoc wireless network"
 #~ msgstr "Ansluten till ett trdlst ad hoc-ntverk"
 #~ msgid "Wireless network connection to '%s' (%d%%)"
 #~ msgstr "Trdls ntverksanslutning till \"%s\" (%d%%)"
-#~ msgid "VPN connection to '%s'"
-#~ msgstr "VPN-anslutning till \"%s\""
-#~ msgid "VPN connecting to '%s'"
-#~ msgstr "VPN-ansluter till \"%s\""
 #~ msgid "_Connect to Other Wireless Network..."
 #~ msgstr "_Anslut till annat trdlst ntverk..."
 #~ msgid "Create _New Wireless Network..."
 #~ msgstr "Skapa _nytt trdlst ntverk..."
-#~ msgid "_VPN Connections"
-#~ msgstr "_VPN-anslutningar"
 #~ msgid "_Configure VPN..."
 #~ msgstr "_Konfigurera VPN..."
-#~ msgid "_Disconnect VPN..."
-#~ msgstr "Koppla _frn VPN..."
 #~ msgid "_Dial Up Connections"
 #~ msgstr "_Uppringda anslutningar"
 #~ msgid "Connect to %s..."
@@ -514,8 +1567,6 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet tr
 #~ msgstr "Aktivera _ntverk"
 #~ msgid "Enable _Wireless"
 #~ msgstr "Aktivera _trdlst"
-#~ msgid "Connection _Information"
-#~ msgstr "Anslutnings_information"
 #~ msgid "_Help"
 #~ msgstr "_Hjlp"
 #~ msgid "_About"
@@ -536,8 +1587,6 @@ msgstr "Systemets policy frhindrar delning av anslutningar via ett ppet tr
 #~ msgstr "TKIP"
 #~ msgid "Dynamic WEP"
 #~ msgstr "Dynamisk WEP"
-#~ msgid "None"
-#~ msgstr "Ingen"
 #~ msgid "WEP 64/128-bit ASCII"
 #~ msgstr "WEP 64/128-bitars ASCII"
 #~ msgid "WEP 64/128-bit Hex"
diff --git a/po/te.po b/po/te.po
index 7b3ace2..4d9101b 100644
--- a/po/te.po
+++ b/po/te.po
@@ -1,4 +1,4 @@
-# translation of NetworkManager.master.te.po to Telugu
+# translation of te.po to Telugu
 # Telugu translation of NetworkManager.
 # Copyright (C) 2009 NetworkManager's COPYRIGHT HOLDER
 # This file is distributed under the same license as the NetworkManager package.
@@ -6,18 +6,866 @@
 # Krishna Babu K <kkrothap@redhat.com>, 2009, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: NetworkManager.master.te\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-09-29 03:25+0000\n"
-"PO-Revision-Date: 2010-01-29 15:20+0530\n"
+"Project-Id-Version: te\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-21 03:24+0000\n"
+"PO-Revision-Date: 2010-04-21 18:32+0530\n"
 "Last-Translator: Krishna Babu K <kkrothap@redhat.com>\n"
 "Language-Team: Telugu <en@li.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms: nplurals=2; plural=(n!=1);\n\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n"
 "\n"
+"\n"
+"\n"
+"\n"
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr ""
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr ""
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr " :\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr ": %s  ."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr ": %s -   ."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "- "
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr " "
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr " : %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr ":    ."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr ""
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr ""
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr " "
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr ""
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr ""
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr " '%s'     "
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "     "
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr ""
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr ""
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr ""
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN  ()"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN  ( )"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN "
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN  (IP  )"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN "
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN  "
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN "
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr " "
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr ""
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "  "
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "   "
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN   "
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN    "
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "   "
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN    "
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN   "
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "  VPN  "
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr " VPN "
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr " "
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr ": %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr " \n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr ":   ."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr ": %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr ":   : %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr ":  %d  ."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr ":   : %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr ": '%s'     ."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "  : %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr ":  : %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr ":   '%s' ."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr ": id  uuid  ."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr ":    : %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr ":    ."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr ":   \n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr ": 'con'  '%s'  ."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr ": D-Bus  ."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr ":    ."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr ":    ."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr ":  :   ."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr ""
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr ""
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr ""
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr " ()"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr " ()"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr " ( )"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr " (IP  )"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr ""
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr " "
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr ""
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "()"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: IP4  0x%X  "
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, () %d MHz,  %d Mb/s, () %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", : "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr ""
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr ""
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr ""
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "()"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr ""
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW "
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  :\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr " "
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr ""
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"   \n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP "
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA "
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 "
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP "
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP "
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"     %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = current AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"   \n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr ""
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr ""
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr ""
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4 :\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr ""
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr ""
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr ""
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "  "
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr ": '%s'  ."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr ":  '%s' ."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr ":  '%s'  ."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr ":  '%s' (%s)  : %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr " : %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr ": iface  ."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi  "
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr ":  '%s'  WiFi  ."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr ":"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr ": hwaddr  ."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr ":  '%s'   ."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP "
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr ":"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "()"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr " :"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr ":"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr ""
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA :"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN :"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr ": 'dev wifi'  '%s' ."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr ": 'dev'  '%s' ."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "(asleep)"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr ""
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr ""
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr ""
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr " "
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr " :"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr ""
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr ""
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr " :"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "  :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr " :"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr " WWAN :"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr ":  'wifi' : '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr ":  'wwan' : '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr ": 'nm'  '%s' ."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr " '%s' , 'nmcli help' ."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli ,  %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr " '%s' , 'nmcli -help' ."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr " %d , ..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr ":   ."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr ""
 
 #: ../libnm-util/crypto.c:120
 #, c-format
@@ -106,7 +954,7 @@ msgstr "IV - 
 
 #: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
 #: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
-#: ../libnm-util/crypto_nss.c:335
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "   '%s'  ."
@@ -165,43 +1013,38 @@ msgstr "  IV  
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "    : %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:266
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
 #, c-format
-#| msgid "Failed to decrypt the private key: %d."
 msgid "Failed to decrypt the private key: unexpected padding length."
 msgstr "    :   ."
 
-#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:277
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "    ."
 
-#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:355
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
 #, c-format
 msgid "Could not allocate memory for encrypting."
 msgstr "    ."
 
 #: ../libnm-util/crypto_gnutls.c:294
 #, c-format
-#| msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgid "Failed to initialize the encryption cipher context: %s / %s."
 msgstr "     : %s / %s."
 
 #: ../libnm-util/crypto_gnutls.c:303
 #, c-format
-#| msgid "Failed to set symmetric key for decryption: %s / %s."
 msgid "Failed to set symmetric key for encryption: %s / %s."
 msgstr "     : %s / %s."
 
 #: ../libnm-util/crypto_gnutls.c:313
 #, c-format
-#| msgid "Failed to set IV for decryption: %s / %s."
 msgid "Failed to set IV for encryption: %s / %s."
 msgstr "  IV  : %s / %s."
 
 #: ../libnm-util/crypto_gnutls.c:322
 #, c-format
-#| msgid "Failed to decrypt the private key: %s / %s."
 msgid "Failed to encrypt the data: %s / %s."
 msgstr "   : %s / %s."
 
@@ -230,7 +1073,7 @@ msgstr "PKCS#12    
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12   : %s"
 
-#: ../libnm-util/crypto_nss.c:57
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "    : %d."
@@ -272,7 +1115,6 @@ msgstr "  
 
 #: ../libnm-util/crypto_nss.c:245
 #, c-format
-#| msgid "Failed to decrypt the private key: %d."
 msgid "Failed to decrypt the private key: decrypted data too large."
 msgstr "    :     ."
 
@@ -281,145 +1123,141 @@ msgstr "  
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "      : %d."
 
-#: ../libnm-util/crypto_nss.c:363
+#: ../libnm-util/crypto_nss.c:364
 #, c-format
-#| msgid "Failed to initialize the decryption cipher slot."
 msgid "Failed to initialize the encryption cipher slot."
 msgstr "    ."
 
-#: ../libnm-util/crypto_nss.c:371
+#: ../libnm-util/crypto_nss.c:372
 #, c-format
-#| msgid "Failed to set symmetric key for decryption."
 msgid "Failed to set symmetric key for encryption."
 msgstr "     ."
 
-#: ../libnm-util/crypto_nss.c:379
+#: ../libnm-util/crypto_nss.c:380
 #, c-format
-#| msgid "Failed to set IV for decryption."
 msgid "Failed to set IV for encryption."
 msgstr "  IV  ."
 
-#: ../libnm-util/crypto_nss.c:387
+#: ../libnm-util/crypto_nss.c:388
 #, c-format
-#| msgid "Failed to initialize the decryption context."
 msgid "Failed to initialize the encryption context."
 msgstr "   ."
 
-#: ../libnm-util/crypto_nss.c:395
+#: ../libnm-util/crypto_nss.c:396
 #, c-format
-#| msgid "Failed to decrypt the private key: %d."
 msgid "Failed to encrypt: %d."
 msgstr "  : %d."
 
-#: ../libnm-util/crypto_nss.c:403
+#: ../libnm-util/crypto_nss.c:404
 #, c-format
 msgid "Unexpected amount of data after encrypting."
 msgstr "     ."
 
-#: ../libnm-util/crypto_nss.c:446
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "   : %d"
 
-#: ../libnm-util/crypto_nss.c:481
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr " UCS2  : %d"
 
-#: ../libnm-util/crypto_nss.c:509
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:518
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12    : %d"
 
-#: ../libnm-util/crypto_nss.c:527
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12   : %d"
 
-#: ../libnm-util/crypto_nss.c:556
-#| msgid "Could not decode private key."
+#: ../libnm-util/crypto_nss.c:557
 msgid "Could not generate random data."
 msgstr "   ."
 
-#: ../libnm-util/nm-utils.c:1522
+#: ../libnm-util/nm-utils.c:1818
 #, c-format
-#| msgid "Not enough memory to decrypt private key."
 msgid "Not enough memory to make encryption key."
 msgstr "     ."
 
-#: ../libnm-util/nm-utils.c:1633
-#| msgid "Not enough memory to store PEM file data."
+#: ../libnm-util/nm-utils.c:1928
 msgid "Could not allocate memory for PEM file creation."
 msgstr " PEM     ."
 
-#: ../libnm-util/nm-utils.c:1645
+#: ../libnm-util/nm-utils.c:1940
 #, c-format
 msgid "Could not allocate memory for writing IV to PEM file."
 msgstr "IV PEM     ."
 
-#: ../libnm-util/nm-utils.c:1657
+#: ../libnm-util/nm-utils.c:1952
 #, c-format
 msgid "Could not allocate memory for writing encrypted key to PEM file."
 msgstr "   PEM     ."
 
-#: ../libnm-util/nm-utils.c:1676
+#: ../libnm-util/nm-utils.c:1971
 #, c-format
-#| msgid "Not enough memory to store PEM file data."
 msgid "Could not allocate memory for PEM file data."
 msgstr "PEM      ."
 
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
-#: ../src/nm-netlink-monitor.c:569
-#: ../src/ip6-manager/nm-netlink-listener.c:352
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "    : %s"
 
-#: ../src/nm-netlink-monitor.c:260
+#: ../src/nm-netlink-monitor.c:259
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
 msgstr "      : %s"
 
-#: ../src/nm-netlink-monitor.c:270
+#: ../src/nm-netlink-monitor.c:269
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
 msgstr "     : %s"
 
-#: ../src/nm-netlink-monitor.c:278
+#: ../src/nm-netlink-monitor.c:277
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
 msgstr "      :%s"
 
-#: ../src/nm-netlink-monitor.c:286
+#: ../src/nm-netlink-monitor.c:285
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
 msgstr "      : %s"
 
-#: ../src/nm-netlink-monitor.c:494
-#: ../src/ip6-manager/nm-netlink-listener.c:382
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
 msgid "error occurred while waiting for data on socket"
 msgstr "      "
 
-#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "   : %s"
 
-#: ../src/NetworkManager.c:330
+#: ../src/main.c:498
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr " .      --help .\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/main.c:558
+#, c-format
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s.       --help .\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
 msgid "# Created by NetworkManager\n"
 msgstr "#   \n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -428,38 +1266,62 @@ msgstr ""
 "# %s \n"
 "\n"
 
-#: ../src/ip6-manager/nm-netlink-listener.c:200
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "  DHCP  ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "'dhclient'  ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "'dhcpcd'  ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr " DHCP  '%s'"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
 #, c-format
-#| msgid "unable to allocate netlink handle for monitoring link status: %s"
 msgid "unable to allocate netlink handle: %s"
 msgstr "   : %s"
 
-#: ../src/ip6-manager/nm-netlink-listener.c:210
+#: ../src/ip6-manager/nm-netlink-listener.c:209
 #, c-format
-#| msgid "unable to connect to netlink for monitoring link status: %s"
 msgid "unable to connect to netlink: %s"
 msgstr "  : %s"
 
-#: ../src/ip6-manager/nm-netlink-listener.c:307
+#: ../src/ip6-manager/nm-netlink-listener.c:306
 #, c-format
-#| msgid "unable to join netlink group for monitoring link status: %s"
 msgid "unable to join netlink group: %s"
 msgstr "   : %s"
 
-#: ../src/named-manager/nm-named-manager.c:315
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "   '%s'"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "   '%s'"
+
+#: ../src/named-manager/nm-named-manager.c:314
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
 msgstr ": libc  3     ."
 
-#: ../src/named-manager/nm-named-manager.c:317
+#: ../src/named-manager/nm-named-manager.c:316
 msgid "The nameservers listed below may not be recognized."
 msgstr "    ."
 
-#: ../src/system-settings/nm-default-wired-connection.c:194
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
 msgstr " %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3229
 msgid "System"
 msgstr ""
 
@@ -484,7 +1346,6 @@ msgid "System policy prevents modification of system settings"
 msgstr "     "
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
-#| msgid "System policy prevents modification of system settings"
 msgid "System policy prevents modification of the persistent system hostname"
 msgstr "      "
 
@@ -495,4 +1356,3 @@ msgstr " WiFi   
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
 msgid "System policy prevents sharing connections via an open WiFi network"
 msgstr " WiFi       "
-
diff --git a/src/Makefile.am b/src/Makefile.am
index f351c78..214f754 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,4 +1,5 @@
 SUBDIRS= \
+	logging \
 	named-manager \
 	vpn-manager \
 	dhcp-manager \
@@ -16,6 +17,7 @@ SUBDIRS= \
 INCLUDES = -I${top_srcdir}                   \
            -I${top_srcdir}/include           \
            -I${top_builddir}/marshallers   \
+           -I${top_srcdir}/src/logging \
            -I${top_srcdir}/src/named-manager \
            -I${top_srcdir}/src/vpn-manager   \
            -I${top_srcdir}/src/dhcp-manager  \
@@ -30,13 +32,18 @@ INCLUDES = -I${top_srcdir}                   \
            -I${top_srcdir}/callouts
 
 ###########################################
-# DHCP test library
+# Test libraries
 ###########################################
 
-noinst_LTLIBRARIES = libtest-dhcp.la
+noinst_LTLIBRARIES = libtest-dhcp.la libtest-policy-hosts.la
+
+###########################################
+# DHCP test library
+###########################################
 
 libtest_dhcp_la_SOURCES = \
 	nm-ip4-config.c \
+	nm-ip6-config.c \
 	nm-hostname-provider.c \
 	nm-dbus-manager.c
 
@@ -46,11 +53,26 @@ libtest_dhcp_la_CPPFLAGS = \
 	$(LIBNL_CFLAGS)
 
 libtest_dhcp_la_LIBADD = \
+	$(top_builddir)/marshallers/libmarshallers.la \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(GLIB_LIBS) \
 	$(DBUS_LIBS) \
 	$(LIBNL_LIBS)
 
+###########################################
+# Hosts policy test library
+###########################################
+
+libtest_policy_hosts_la_SOURCES = \
+	nm-policy-hosts.c \
+	nm-policy-hosts.h
+
+libtest_policy_hosts_la_CPPFLAGS = \
+	$(GLIB_CFLAGS)
+
+libtest_policy_hosts_la_LIBADD = \
+	$(GLIB_LIBS)
+
 
 ###########################################
 # NetworkManager
@@ -74,8 +96,14 @@ NetworkManager_SOURCES = \
 		nm-device-olpc-mesh.h	\
 		nm-device-bt.c \
 		nm-device-bt.h \
-		NetworkManagerAP.c \
-		NetworkManagerAP.h \
+		nm-device-modem.h \
+		nm-device-modem.c \
+		nm-device-cdma.c \
+		nm-device-cdma.h \
+		nm-device-gsm.c \
+		nm-device-gsm.h \
+		nm-wifi-ap.c \
+		nm-wifi-ap.h \
 		nm-dbus-manager.h \
 		nm-dbus-manager.c \
 		nm-udev-manager.c \
@@ -90,15 +118,15 @@ NetworkManager_SOURCES = \
 		nm-secrets-provider-interface.h \
 		nm-active-connection.h \
 		nm-active-connection.c \
-		NetworkManager.c \
-		NetworkManagerPolicy.c \
-		NetworkManagerPolicy.h \
+		main.c \
+		nm-policy.c \
+		nm-policy.h \
+		nm-policy-hosts.c \
+		nm-policy-hosts.h \
 		NetworkManagerUtils.c \
 		NetworkManagerUtils.h \
-		NetworkManagerSystem.c \
-		NetworkManagerSystem.h \
-		nm-logging.c \
-		nm-logging.h \
+		nm-system.c \
+		nm-system.h \
 		nm-manager.c \
 		nm-manager.h \
 		nm-netlink-monitor.c \
@@ -113,6 +141,8 @@ NetworkManager_SOURCES = \
 		nm-netlink.h \
 		nm-dhcp4-config.c \
 		nm-dhcp4-config.h \
+		nm-dhcp6-config.c \
+		nm-dhcp6-config.h \
 		nm-rfkill.h
 
 nm-access-point-glue.h: $(top_srcdir)/introspection/nm-access-point.xml
@@ -148,6 +178,15 @@ nm-active-connection-glue.h: $(top_srcdir)/introspection/nm-active-connection.xm
 nm-dhcp4-config-glue.h: $(top_srcdir)/introspection/nm-dhcp4-config.xml
 	dbus-binding-tool --prefix=nm_dhcp4_config --mode=glib-server --output=$@ $<
 
+nm-dhcp6-config-glue.h: $(top_srcdir)/introspection/nm-dhcp6-config.xml
+	dbus-binding-tool --prefix=nm_dhcp6_config --mode=glib-server --output=$@ $<
+
+nm-device-cdma-glue.h: $(top_srcdir)/introspection/nm-device-cdma.xml
+	dbus-binding-tool --prefix=nm_device_cdma --mode=glib-server --output=$@ $<
+
+nm-device-gsm-glue.h: $(top_srcdir)/introspection/nm-device-gsm.xml
+	dbus-binding-tool --prefix=nm_device_gsm --mode=glib-server --output=$@ $<
+
 BUILT_SOURCES = \
 	nm-access-point-glue.h \
 	nm-manager-glue.h \
@@ -156,10 +195,13 @@ BUILT_SOURCES = \
 	nm-device-wifi-glue.h \
 	nm-device-olpc-mesh-glue.h \
 	nm-device-bt-glue.h \
+	nm-device-cdma-glue.h \
+	nm-device-gsm-glue.h \
 	nm-ip4-config-glue.h \
 	nm-ip6-config-glue.h \
 	nm-active-connection-glue.h \
-	nm-dhcp4-config-glue.h
+	nm-dhcp4-config-glue.h \
+	nm-dhcp6-config-glue.h
 
 NetworkManager_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
@@ -182,6 +224,7 @@ NetworkManager_CPPFLAGS = \
 
 NetworkManager_LDADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	./logging/libnm-logging.la \
 	./named-manager/libnamed-manager.la \
 	./vpn-manager/libvpn-manager.la \
 	./dhcp-manager/libdhcp-manager.la \
diff --git a/src/NetworkManager.c b/src/NetworkManager.c
deleted file mode 100644
index 09a4320..0000000
--- a/src/NetworkManager.c
+++ /dev/null
@@ -1,680 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2005 - 2008 Novell, Inc.
- */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <glib.h>
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <getopt.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <glib/gi18n.h>
-#include <gmodule.h>
-#include <string.h>
-
-#include "NetworkManager.h"
-#include "nm-utils.h"
-#include "NetworkManagerUtils.h"
-#include "nm-manager.h"
-#include "NetworkManagerPolicy.h"
-#include "NetworkManagerSystem.h"
-#include "nm-named-manager.h"
-#include "nm-dbus-manager.h"
-#include "nm-supplicant-manager.h"
-#include "nm-dhcp-manager.h"
-#include "nm-hostname-provider.h"
-#include "nm-netlink-monitor.h"
-#include "nm-vpn-manager.h"
-#include "nm-logging.h"
-
-#define NM_DEFAULT_PID_FILE	LOCALSTATEDIR"/run/NetworkManager.pid"
-#define NM_DEFAULT_SYSTEM_CONF_FILE	SYSCONFDIR"/NetworkManager/nm-system-settings.conf"
-#define NM_DEFAULT_SYSTEM_STATE_FILE	LOCALSTATEDIR"/lib/NetworkManager/NetworkManager.state"
-
-/*
- * Globals
- */
-static NMManager *manager = NULL;
-static GMainLoop *main_loop = NULL;
-
-typedef struct {
-	time_t time;
-	GQuark domain;
-	guint32 code;
-	guint32 count;
-} MonitorInfo;
-
-static gboolean
-detach_monitor (gpointer data)
-{
-	nm_info ("Detaching netlink event monitor");
-	nm_netlink_monitor_detach (NM_NETLINK_MONITOR (data));
-	return FALSE;
-}
-
-static void
-nm_error_monitoring_device_link_state (NMNetlinkMonitor *monitor,
-									   GError *error,
-									   gpointer user_data)
-{
-	MonitorInfo *info = (MonitorInfo *) user_data;
-	time_t now;
-
-	now = time (NULL);
-
-	if (info->domain != error->domain || info->code != error->code || (info->time && now > info->time + 10)) {
-		/* FIXME: Try to handle the error instead of just printing it. */
-		nm_warning ("error monitoring device for netlink events: %s\n",
-					error->message);
-
-		info->time = now;
-		info->domain = error->domain;
-		info->code = error->code;
-		info->count = 0;
-	}
-
-	info->count++;
-	if (info->count > 100) {
-		/* Broken drivers will sometimes cause a flood of netlink errors.
-		 * rh #459205, novell #443429, lp #284507
-		 */
-		nm_warning ("Excessive netlink errors ocurred, disabling netlink monitor.");
-		nm_warning ("Link change events will not be processed.");
-		g_idle_add_full (G_PRIORITY_HIGH, detach_monitor, monitor, NULL);
-	}
-}
-
-static gboolean
-nm_monitor_setup (void)
-{
-	GError *error = NULL;
-	NMNetlinkMonitor *monitor;
-	MonitorInfo *info;
-
-	monitor = nm_netlink_monitor_get ();
-	nm_netlink_monitor_open_connection (monitor, &error);
-	if (error != NULL)
-	{
-		nm_warning ("could not monitor wired ethernet devices: %s",
-					error->message);
-		g_error_free (error);
-		g_object_unref (monitor);
-		return FALSE;
-	}
-
-	info = g_new0 (MonitorInfo, 1);
-	g_signal_connect_data (G_OBJECT (monitor), "error",
-						   G_CALLBACK (nm_error_monitoring_device_link_state),
-						   info,
-						   (GClosureNotify) g_free,
-						   0);
-
-	nm_netlink_monitor_attach (monitor);
-
-	/* Request initial status of cards */
-	nm_netlink_monitor_request_status (monitor, NULL);
-
-	return TRUE;
-}
-
-static gboolean quit_early = FALSE;
-
-static void
-nm_signal_handler (int signo)
-{
-	static int in_fatal = 0;
-
-	/* avoid loops */
-	if (in_fatal > 0)
-		return;
-	++in_fatal;
-
-	switch (signo)
-	{
-		case SIGSEGV:
-		case SIGBUS:
-		case SIGILL:
-		case SIGABRT:
-			nm_warning ("Caught signal %d.  Generating backtrace...", signo);
-			nm_logging_backtrace ();
-			exit (1);
-			break;
-
-		case SIGFPE:
-		case SIGPIPE:
-			/* let the fatal signals interrupt us */
-			--in_fatal;
-
-			nm_warning ("Caught signal %d, shutting down abnormally.  Generating backtrace...", signo);
-			nm_logging_backtrace ();
-			g_main_loop_quit (main_loop);
-			break;
-
-		case SIGINT:
-		case SIGTERM:
-			/* let the fatal signals interrupt us */
-			--in_fatal;
-
-			nm_warning ("Caught signal %d, shutting down normally.", signo);
-			quit_early = TRUE;
-			g_main_loop_quit (main_loop);
-			break;
-
-		case SIGHUP:
-			--in_fatal;
-			/* FIXME:
-			 * Reread config stuff like system config files, VPN service files, etc
-			 */
-			break;
-
-		case SIGUSR1:
-			--in_fatal;
-			/* FIXME:
-			 * Play with log levels or something
-			 */
-			break;
-
-		default:
-			signal (signo, nm_signal_handler);
-			break;
-	}
-}
-
-static void
-setup_signals (void)
-{
-	struct sigaction action;
-	sigset_t mask;
-
-	sigemptyset (&mask);
-	action.sa_handler = nm_signal_handler;
-	action.sa_mask = mask;
-	action.sa_flags = 0;
-	sigaction (SIGTERM,  &action, NULL);
-	sigaction (SIGINT,  &action, NULL);
-	sigaction (SIGILL,  &action, NULL);
-	sigaction (SIGBUS,  &action, NULL);
-	sigaction (SIGFPE,  &action, NULL);
-	sigaction (SIGHUP,  &action, NULL);
-	sigaction (SIGSEGV, &action, NULL);
-	sigaction (SIGABRT, &action, NULL);
-	sigaction (SIGUSR1,  &action, NULL);
-}
-
-static gboolean
-write_pidfile (const char *pidfile)
-{
- 	char pid[16];
-	int fd;
-	gboolean success = FALSE;
- 
-	if ((fd = open (pidfile, O_CREAT|O_WRONLY|O_TRUNC, 00644)) < 0) {
-		nm_warning ("Opening %s failed: %s", pidfile, strerror (errno));
-		return FALSE;
-	}
-
- 	snprintf (pid, sizeof (pid), "%d", getpid ());
-	if (write (fd, pid, strlen (pid)) < 0)
-		nm_warning ("Writing to %s failed: %s", pidfile, strerror (errno));
-	else
-		success = TRUE;
-
-	if (close (fd))
-		nm_warning ("Closing %s failed: %s", pidfile, strerror (errno));
-
-	return success;
-}
-
-/* Check whether the pidfile already exists and contains PID of a running NetworkManager
- *  Returns:  FALSE - specified pidfile doesn't exist or doesn't contain PID of a running NM process
- *            TRUE  - specified pidfile already exists and contains PID of a running NM process
- */
-static gboolean
-check_pidfile (const char *pidfile)
-{
-	char *contents = NULL;
-	gsize len = 0;
-	glong pid;
-	char *proc_cmdline = NULL;
-	gboolean nm_running = FALSE;
-	const char *process_name;
-
-	if (!g_file_get_contents (pidfile, &contents, &len, NULL))
-		return FALSE;
-
-	if (len <= 0)
-		goto done;
-
-	errno = 0;
-	pid = strtol (contents, NULL, 10);
-	if (pid <= 0 || pid > 65536 || errno)
-		goto done;
-
-	g_free (contents);
-	proc_cmdline = g_strdup_printf ("/proc/%ld/cmdline", pid);
-	if (!g_file_get_contents (proc_cmdline, &contents, &len, NULL))
-		goto done;
-
-	process_name = strrchr (contents, '/');
-	if (process_name)
-		process_name++;
-	else
-		process_name = contents;
-	if (strcmp (process_name, "NetworkManager") == 0) {
-		/* Check that the process exists */
-		if (kill (pid, 0) == 0) {
-			g_warning ("NetworkManager is already running (pid %ld)", pid);
-			nm_running = TRUE;
-		}
-	}
-
-done:
-	g_free (proc_cmdline);
-	g_free (contents);
-	return nm_running;
-}
-
-static gboolean
-parse_config_file (const char *filename, char **plugins, GError **error)
-{
-	GKeyFile *config;
-
-	config = g_key_file_new ();
-	if (!config) {
-		g_set_error (error, 0, 0,
-		             "Not enough memory to load config file.");
-		return FALSE;
-	}
-
-	g_key_file_set_list_separator (config, ',');
-	if (!g_key_file_load_from_file (config, filename, G_KEY_FILE_NONE, error))
-		return FALSE;
-
-	*plugins = g_key_file_get_value (config, "main", "plugins", error);
-	if (*error)
-		return FALSE;
-
-	g_key_file_free (config);
-	return TRUE;
-}
-
-static gboolean
-parse_state_file (const char *filename,
-                  gboolean *net_enabled,
-                  gboolean *wifi_enabled,
-                  gboolean *wwan_enabled,
-                  GError **error)
-{
-	GKeyFile *state_file;
-	GError *tmp_error = NULL;
-	gboolean wifi, net, wwan;
-
-	g_return_val_if_fail (net_enabled != NULL, FALSE);
-	g_return_val_if_fail (wifi_enabled != NULL, FALSE);
-	g_return_val_if_fail (wwan_enabled != NULL, FALSE);
-
-	state_file = g_key_file_new ();
-	if (!state_file) {
-		g_set_error (error, 0, 0,
-		             "Not enough memory to load state file.");
-		return FALSE;
-	}
-
-	g_key_file_set_list_separator (state_file, ',');
-	if (!g_key_file_load_from_file (state_file, filename, G_KEY_FILE_KEEP_COMMENTS, &tmp_error)) {
-		/* This is kinda ugly; create the file and directory if it doesn't
-		 * exist yet.  We can't rely on distros necessarily creating the
-		 * /var/lib/NetworkManager for us since we have to ensure that
-		 * users upgrading NM get this working too.
-		 */
-		if (   tmp_error->domain == G_FILE_ERROR
-		    && tmp_error->code == G_FILE_ERROR_NOENT) {
-			char *data, *dirname;
-			gsize len = 0;
-			gboolean ret = FALSE;
-
-			/* try to create the directory if it doesn't exist */
-			dirname = g_path_get_dirname (filename);
-			errno = 0;
-			if (mkdir (dirname, 0755) != 0) {
-				if (errno != EEXIST) {
-					g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_ACCES,
-					             "Error creating state directory %s: %d", dirname, errno);
-					g_free (dirname);
-					return FALSE;
-				}
-			}
-			g_free (dirname);
-
-			/* Write out the initial state to the state file */
-			g_key_file_set_boolean (state_file, "main", "NetworkingEnabled", *net_enabled);
-			g_key_file_set_boolean (state_file, "main", "WirelessEnabled", *wifi_enabled);
-			g_key_file_set_boolean (state_file, "main", "WWANEnabled", *wwan_enabled);
-
-			data = g_key_file_to_data (state_file, &len, NULL);
-			if (data)
-				ret = g_file_set_contents (filename, data, len, error);
-			g_free (data);
-
-			return ret;
-		} else {
-			g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-			g_clear_error (&tmp_error);
-		}
-
-		/* Otherwise, file probably corrupt or inaccessible */
-		return FALSE;
-	}
-
-	/* Reading state bits of NetworkManager; an error leaves the passed-in state
-	 * value unchanged.
-	 */
-	net = g_key_file_get_boolean (state_file, "main", "NetworkingEnabled", &tmp_error);
-	if (tmp_error)
-		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-	else
-		*net_enabled = net;
-	g_clear_error (&tmp_error);
-
-	wifi = g_key_file_get_boolean (state_file, "main", "WirelessEnabled", &tmp_error);
-	if (tmp_error) {
-		g_clear_error (error);
-		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-	} else
-		*wifi_enabled = wifi;
-	g_clear_error (&tmp_error);
-
-	wwan = g_key_file_get_boolean (state_file, "main", "WWANEnabled", &tmp_error);
-	if (tmp_error) {
-		g_clear_error (error);
-		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-	} else
-		*wwan_enabled = wwan;
-	g_clear_error (&tmp_error);
-
-	g_key_file_free (state_file);
-
-	return TRUE;
-}
-
-/*
- * main
- *
- */
-int
-main (int argc, char *argv[])
-{
-	GOptionContext *opt_ctx = NULL;
-	gboolean become_daemon = FALSE;
-	gboolean g_fatal_warnings = FALSE;
-	char *pidfile = NULL, *user_pidfile = NULL;
-	char *config = NULL, *plugins = NULL;
-	char *state_file = NM_DEFAULT_SYSTEM_STATE_FILE;
-	gboolean wifi_enabled = TRUE, net_enabled = TRUE, wwan_enabled = TRUE;
-	gboolean success;
-	NMPolicy *policy = NULL;
-	NMVPNManager *vpn_manager = NULL;
-	NMNamedManager *named_mgr = NULL;
-	NMDBusManager *dbus_mgr = NULL;
-	NMSupplicantManager *sup_mgr = NULL;
-	NMDHCPManager *dhcp_mgr = NULL;
-	GError *error = NULL;
-	gboolean wrote_pidfile = FALSE;
-
-	GOptionEntry options[] = {
-		{ "no-daemon", 0, 0, G_OPTION_ARG_NONE, &become_daemon, "Don't become a daemon", NULL },
-		{ "g-fatal-warnings", 0, 0, G_OPTION_ARG_NONE, &g_fatal_warnings, "Make all warnings fatal", NULL },
-		{ "pid-file", 0, 0, G_OPTION_ARG_FILENAME, &user_pidfile, "Specify the location of a PID file", "filename" },
-		{ "state-file", 0, 0, G_OPTION_ARG_FILENAME, &state_file, "State file location", "/path/to/state.file" },
-		{ "config", 0, 0, G_OPTION_ARG_FILENAME, &config, "Config file location", "/path/to/config.file" },
-		{ "plugins", 0, 0, G_OPTION_ARG_STRING, &plugins, "List of plugins separated by ,", "plugin1,plugin2" },
-		{NULL}
-	};
-
-	if (getuid () != 0) {
-		g_printerr ("You must be root to run NetworkManager!\n");
-		exit (1);
-	}
-
-	if (!g_module_supported ()) {
-		g_printerr ("GModules are not supported on your platform!");
-		exit (1);
-	}
-
-	bindtextdomain (GETTEXT_PACKAGE, NMLOCALEDIR);
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-	textdomain (GETTEXT_PACKAGE);
-
-	/* Parse options */
-	opt_ctx = g_option_context_new ("");
-	g_option_context_set_translation_domain (opt_ctx, "UTF-8");
-	g_option_context_set_ignore_unknown_options (opt_ctx, FALSE);
-	g_option_context_set_help_enabled (opt_ctx, TRUE);
-	g_option_context_add_main_entries (opt_ctx, options, NULL);
-
-	g_option_context_set_summary (opt_ctx,
-		"NetworkManager monitors all network connections and automatically\nchooses the best connection to use.  It also allows the user to\nspecify wireless access points which wireless cards in the computer\nshould associate with.");
-
-	success = g_option_context_parse (opt_ctx, &argc, &argv, NULL);
-	g_option_context_free (opt_ctx);
-
-	if (!success) {
-		fprintf (stderr, _("Invalid option.  Please use --help to see a list of valid options.\n"));
-		exit (1);
-	}
-
-	pidfile = g_strdup (user_pidfile ? user_pidfile : NM_DEFAULT_PID_FILE);
-
-	/* check pid file */
-	if (check_pidfile (pidfile))
-		exit (1);
-
-	/* Parse the config file */
-	if (config) {
-		if (!parse_config_file (config, &plugins, &error)) {
-			g_warning ("Config file %s invalid: (%d) %s.",
-			           config,
-			           error ? error->code : -1,
-			           (error && error->message) ? error->message : "unknown");
-			exit (1);
-		}
-	} else {
-		config = NM_DEFAULT_SYSTEM_CONF_FILE;
-		if (!parse_config_file (config, &plugins, &error)) {
-			g_warning ("Default config file %s invalid: (%d) %s.",
-			           config,
-			           error ? error->code : -1,
-			           (error && error->message) ? error->message : "unknown");
-			config = NULL;
-			/* Not a hard failure */
-		}
-	}
-
-	g_clear_error (&error);
-
-	/* Parse the state file */
-	if (!parse_state_file (state_file, &net_enabled, &wifi_enabled, &wwan_enabled, &error)) {
-		g_warning ("State file %s parsing failed: (%d) %s.",
-		           state_file,
-		           error ? error->code : -1,
-		           (error && error->message) ? error->message : "unknown");
-		/* Not a hard failure */
-	}
-
-	/* Tricky: become_daemon is FALSE by default, so unless it's TRUE because
-	 * of a CLI option, it'll become TRUE after this
-	 */
-	become_daemon = !become_daemon;
-	if (become_daemon) {
-		if (daemon (0, 0) < 0) {
-			int saved_errno;
-
-			saved_errno = errno;
-			nm_error ("Could not daemonize: %s [error %u]",
-			          g_strerror (saved_errno),
-			          saved_errno);
-			exit (1);
-		}
-		if (write_pidfile (pidfile))
-			wrote_pidfile = TRUE;
-	}
-
-	if (g_fatal_warnings) {
-		GLogLevelFlags fatal_mask;
-
-		fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
-		fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
-		g_log_set_always_fatal (fatal_mask);
-	}
-
-	/*
-	 * Set the umask to 0022, which results in 0666 & ~0022 = 0644.
-	 * Otherwise, if root (or an su'ing user) has a wacky umask, we could
-	 * write out an unreadable resolv.conf.
-	 */
-	umask (022);
-
-	g_type_init ();
-	if (!g_thread_supported ())
-		g_thread_init (NULL);
-	dbus_g_thread_init ();
-
-	setup_signals ();
-
-	nm_logging_setup (become_daemon);
-
-	nm_info ("starting...");
-	success = FALSE;
-
-	main_loop = g_main_loop_new (NULL, FALSE);
-
-	/* Create watch functions that monitor cards for link status. */
-	if (!nm_monitor_setup ())
-		goto done;
-
-	/* Initialize our DBus service & connection */
-	dbus_mgr = nm_dbus_manager_get ();
-
-	vpn_manager = nm_vpn_manager_get ();
-	if (!vpn_manager) {
-		nm_warning ("Failed to start the VPN manager.");
-		goto done;
-	}
-
-	named_mgr = nm_named_manager_get ();
-	if (!named_mgr) {
-		nm_warning ("Failed to start the named manager.");
-		goto done;
-	}
-
-	manager = nm_manager_get (config,
-	                          plugins,
-	                          state_file,
-	                          net_enabled,
-	                          wifi_enabled,
-	                          wwan_enabled,
-	                          &error);
-	if (manager == NULL) {
-		nm_error ("Failed to initialize the network manager: %s",
-		          error && error->message ? error->message : "(unknown)");
-		goto done;
-	}
-
-	policy = nm_policy_new (manager, vpn_manager);
-	if (policy == NULL) {
-		nm_error ("Failed to initialize the policy.");
-		goto done;
-	}
-
-	/* Initialize the supplicant manager */
-	sup_mgr = nm_supplicant_manager_get ();
-	if (!sup_mgr) {
-		nm_error ("Failed to initialize the supplicant manager.");
-		goto done;
-	}
-
-	dhcp_mgr = nm_dhcp_manager_get ();
-	if (!dhcp_mgr) {
-		nm_warning ("Failed to start the DHCP manager.");
-		goto done;
-	}
-
-	nm_dhcp_manager_set_hostname_provider (dhcp_mgr, NM_HOSTNAME_PROVIDER (manager));
-
-	/* Start our DBus service */
-	if (!nm_dbus_manager_start_service (dbus_mgr)) {
-		nm_warning ("Failed to start the dbus service.");
-		goto done;
-	}
-
-	nm_manager_start (manager);
-
-	/* Bring up the loopback interface. */
-	nm_system_enable_loopback ();
-
-	success = TRUE;
-
-	/* Told to quit before getting to the mainloop by the signal handler */
-	if (quit_early == TRUE)
-		goto done;
-
-	g_main_loop_run (main_loop);
-
-done:
-	if (policy)
-		nm_policy_destroy (policy);
-
-	if (manager)
-		g_object_unref (manager);
-
-	if (vpn_manager)
-		g_object_unref (vpn_manager);
-
-	if (named_mgr)
-		g_object_unref (named_mgr);
-
-	if (dhcp_mgr)
-		g_object_unref (dhcp_mgr);
-
-	if (sup_mgr)
-		g_object_unref (sup_mgr);
-
-	if (dbus_mgr)
-		g_object_unref (dbus_mgr);
-
-	nm_logging_shutdown ();
-
-	if (pidfile && wrote_pidfile)
-		unlink (pidfile);
-	g_free (pidfile);
-
-	nm_info ("exiting (%s)", success ? "success" : "error");
-	exit (success ? 0 : 1);
-}
diff --git a/src/NetworkManagerAP.c b/src/NetworkManagerAP.c
deleted file mode 100644
index 9b95924..0000000
--- a/src/NetworkManagerAP.c
+++ /dev/null
@@ -1,1476 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#include "wireless-helper.h"
-
-#include <string.h>
-
-#include "NetworkManagerAP.h"
-#include "NetworkManagerUtils.h"
-#include "nm-utils.h"
-#include "nm-dbus-manager.h"
-#include "wpa.h"
-#include "nm-properties-changed-signal.h"
-#include "nm-setting-wireless.h"
-
-#include "nm-access-point-glue.h"
-
-/*
- * Encapsulates Access Point information
- */
-typedef struct
-{
-	char *dbus_path;
-
-	/* Scanned or cached values */
-	GByteArray *	ssid;
-	struct ether_addr	address;
-	NM80211Mode		mode;
-	gint8			strength;
-	guint32			freq;		/* Frequency in MHz; ie 2412 (== 2.412 GHz) */
-	guint32			max_bitrate;/* Maximum bitrate of the AP in Kbit/s (ie 54000 Kb/s == 54Mbit/s) */
-
-	guint32			flags;		/* General flags */
-	guint32			wpa_flags;	/* WPA-related flags */
-	guint32			rsn_flags;	/* RSN (WPA2) -related flags */
-
-	/* Non-scanned attributes */
-	gboolean			fake;	/* Whether or not the AP is from a scan */
-	gboolean			broadcast;	/* Whether or not the AP is broadcasting (hidden) */
-	gboolean			user_created;	/* Whether or not the AP was created
-										 * by the user with "Create network..."
-										 * A subset of Ad-Hoc mode.  user_created
-										 * implies Ad-Hoc, but not necessarily
-										 * the other way around.
-										 */
-	glong				last_seen;	/* Last time the AP was seen in a scan in seconds */
-
-	/* Things from user prefs/NetworkManagerInfo */
-	GTimeVal			timestamp;
-	GSList *			user_addresses;
-} NMAccessPointPrivate;
-
-#define NM_AP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_AP, NMAccessPointPrivate))
-
-G_DEFINE_TYPE (NMAccessPoint, nm_ap, G_TYPE_OBJECT)
-
-enum {
-	PROPERTIES_CHANGED,
-
-	LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-enum {
-	PROP_0,
-	PROP_FLAGS,
-	PROP_WPA_FLAGS,
-	PROP_RSN_FLAGS,
-	PROP_SSID,
-	PROP_FREQUENCY,
-	PROP_HW_ADDRESS,
-	PROP_MODE,
-	PROP_MAX_BITRATE,
-	PROP_STRENGTH,
-	LAST_PROP
-};
-
-static void
-nm_ap_init (NMAccessPoint *ap)
-{
-	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (ap);
-
-	priv->dbus_path = NULL;
-	priv->mode = NM_802_11_MODE_INFRA;
-	priv->flags = NM_802_11_AP_FLAGS_NONE;
-	priv->wpa_flags = NM_802_11_AP_SEC_NONE;
-	priv->rsn_flags = NM_802_11_AP_SEC_NONE;
-	priv->broadcast = TRUE;
-}
-
-static void
-finalize (GObject *object)
-{
-	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
-
-	g_free (priv->dbus_path);
-	if (priv->ssid)
-		g_byte_array_free (priv->ssid, TRUE);
-	g_slist_foreach (priv->user_addresses, (GFunc)g_free, NULL);
-	g_slist_free (priv->user_addresses);
-
-	G_OBJECT_CLASS (nm_ap_parent_class)->finalize (object);
-}
-
-static void
-set_property (GObject *object, guint prop_id,
-		    const GValue *value, GParamSpec *pspec)
-{
-	NMAccessPoint *ap = NM_AP (object);
-
-	switch (prop_id) {
-	case PROP_FLAGS:
-		nm_ap_set_flags (ap, g_value_get_uint (value));
-		break;
-	case PROP_WPA_FLAGS:
-		nm_ap_set_wpa_flags (ap, g_value_get_uint (value));
-		break;
-	case PROP_RSN_FLAGS:
-		nm_ap_set_rsn_flags (ap, g_value_get_uint (value));
-		break;
-	case PROP_SSID:
-		nm_ap_set_ssid (ap, (GByteArray *) g_value_get_boxed (value));
-		break;
-	case PROP_FREQUENCY:
-		nm_ap_set_freq (ap, g_value_get_uint (value));
-		break;
-	case PROP_MODE:
-		nm_ap_set_mode (ap, g_value_get_uint (value));
-		break;
-	case PROP_MAX_BITRATE:
-		nm_ap_set_max_bitrate (ap, g_value_get_uint (value));
-		break;
-	case PROP_STRENGTH:
-		nm_ap_set_strength (ap, g_value_get_char (value));
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-get_property (GObject *object, guint prop_id,
-			  GValue *value, GParamSpec *pspec)
-{
-	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
-	GArray * ssid;
-	int len;
-	int i;
-
-	switch (prop_id) {
-	case PROP_FLAGS:
-		g_value_set_uint (value, priv->flags);
-		break;
-	case PROP_WPA_FLAGS:
-		g_value_set_uint (value, priv->wpa_flags);
-		break;
-	case PROP_RSN_FLAGS:
-		g_value_set_uint (value, priv->rsn_flags);
-		break;
-	case PROP_SSID:
-		len = priv->ssid ? priv->ssid->len : 0;
-		ssid = g_array_sized_new (FALSE, TRUE, sizeof (unsigned char), len);
-		for (i = 0; i < len; i++)
-			g_array_append_val (ssid, priv->ssid->data[i]);
-		g_value_set_boxed (value, ssid);
-		g_array_free (ssid, TRUE);
-		break;
-	case PROP_FREQUENCY:
-		g_value_set_uint (value, priv->freq);
-		break;
-	case PROP_HW_ADDRESS:
-		g_value_take_string (value, nm_ether_ntop (&priv->address));
-		break;
-	case PROP_MODE:
-		g_value_set_uint (value, priv->mode);
-		break;
-	case PROP_MAX_BITRATE:
-		g_value_set_uint (value, priv->max_bitrate);
-		break;
-	case PROP_STRENGTH:
-		g_value_set_char (value, priv->strength);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-nm_ap_class_init (NMAccessPointClass *ap_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (ap_class);
-	guint32 all_sec_flags;
-
-	g_type_class_add_private (ap_class, sizeof (NMAccessPointPrivate));
-
-	/* virtual methods */
-	object_class->set_property = set_property;
-	object_class->get_property = get_property;
-	object_class->finalize = finalize;
-
-	/* properties */
-
-	all_sec_flags =   NM_802_11_AP_SEC_NONE
-	                | NM_802_11_AP_SEC_PAIR_WEP40
-	                | NM_802_11_AP_SEC_PAIR_WEP104
-	                | NM_802_11_AP_SEC_PAIR_TKIP
-	                | NM_802_11_AP_SEC_PAIR_CCMP
-	                | NM_802_11_AP_SEC_GROUP_WEP40
-	                | NM_802_11_AP_SEC_GROUP_WEP104
-	                | NM_802_11_AP_SEC_GROUP_TKIP
-	                | NM_802_11_AP_SEC_GROUP_CCMP
-	                | NM_802_11_AP_SEC_KEY_MGMT_PSK
-	                | NM_802_11_AP_SEC_KEY_MGMT_802_1X;
-
-	g_object_class_install_property
-		(object_class, PROP_FLAGS,
-		 g_param_spec_uint (NM_AP_FLAGS,
-							"Flags",
-							"Flags",
-							NM_802_11_AP_FLAGS_NONE,
-							NM_802_11_AP_FLAGS_PRIVACY,
-							NM_802_11_AP_FLAGS_NONE,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_WPA_FLAGS,
-		 g_param_spec_uint (NM_AP_WPA_FLAGS,
-							"WPA Flags",
-							"WPA Flags",
-							NM_802_11_AP_SEC_NONE,
-							all_sec_flags,
-							NM_802_11_AP_SEC_NONE,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_RSN_FLAGS,
-		 g_param_spec_uint (NM_AP_RSN_FLAGS,
-							"RSN Flags",
-							"RSN Flags",
-							NM_802_11_AP_SEC_NONE,
-							all_sec_flags,
-							NM_802_11_AP_SEC_NONE,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_SSID,
-	     g_param_spec_boxed (NM_AP_SSID,
-	                         "SSID",
-	                         "SSID",
-	                         DBUS_TYPE_G_UCHAR_ARRAY,
-	                         G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_FREQUENCY,
-		 g_param_spec_uint (NM_AP_FREQUENCY,
-							"Frequency",
-							"Frequency",
-							0, 10000, 0,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_HW_ADDRESS,
-		 g_param_spec_string (NM_AP_HW_ADDRESS,
-							  "MAC Address",
-							  "Hardware MAC address",
-							  NULL,
-							  G_PARAM_READABLE));
-	
-	g_object_class_install_property
-		(object_class, PROP_MODE,
-		 g_param_spec_uint (NM_AP_MODE,
-						   "Mode",
-						   "Mode",
-						   NM_802_11_MODE_ADHOC, NM_802_11_MODE_INFRA, NM_802_11_MODE_INFRA,
-						   G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_MAX_BITRATE,
-		 g_param_spec_uint (NM_AP_MAX_BITRATE,
-							"Max Bitrate",
-							"Max Bitrate",
-							0, G_MAXUINT16, 0,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_STRENGTH,
-		 g_param_spec_char (NM_AP_STRENGTH,
-							"Strength",
-							"Strength",
-							G_MININT8, G_MAXINT8, 0,
-							G_PARAM_READWRITE));
-
-	/* Signals */
-	signals[PROPERTIES_CHANGED] = 
-		nm_properties_changed_signal_new (object_class,
-								    G_STRUCT_OFFSET (NMAccessPointClass, properties_changed));
-
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (ap_class),
-							   &dbus_glib_nm_access_point_object_info);
-}
-
-void
-nm_ap_export_to_dbus (NMAccessPoint *ap)
-{
-	NMAccessPointPrivate *priv;
-	NMDBusManager *mgr;
-	DBusGConnection *g_connection;
-	static guint32 counter = 0;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->dbus_path) {
-		nm_warning ("Tried to export AP %s twice.", priv->dbus_path);
-		return;
-	}
-
-	mgr = nm_dbus_manager_get ();
-	g_assert (mgr);
-
-	g_connection = nm_dbus_manager_get_connection (mgr);
-	g_assert (g_connection);
-
-	priv->dbus_path = g_strdup_printf (NM_DBUS_PATH_ACCESS_POINT "/%d", counter++);
-	dbus_g_connection_register_g_object (g_connection, priv->dbus_path, G_OBJECT (ap));
-
-	g_object_unref (mgr);
-}
-
-/*
- * nm_ap_new
- *
- * Create a new, blank user access point info structure
- *
- */
-NMAccessPoint *nm_ap_new (void)
-{
-	GObject *object;
-
-	object = g_object_new (NM_TYPE_AP, NULL);
-	if (!object)
-		return NULL;
-
-	return (NMAccessPoint *) object;
-}
-
-
-#define IEEE80211_CAP_ESS       0x0001
-#define IEEE80211_CAP_IBSS      0x0002
-#define IEEE80211_CAP_PRIVACY   0x0010
-
-static void
-foreach_property_cb (gpointer key, gpointer value, gpointer user_data)
-{
-	GValue *variant = (GValue *) value;
-	NMAccessPoint *ap = (NMAccessPoint *) user_data;
-
-	if (G_VALUE_HOLDS_BOXED (variant)) {
-		GArray *array = g_value_get_boxed (variant);
-
-		if (!strcmp (key, "ssid")) {
-			guint32 len = MIN (IW_ESSID_MAX_SIZE, array->len);
-			GByteArray * ssid;
-
-			/* Stupid ieee80211 layer uses <hidden> */
-			if (((len == 8) || (len == 9))
-				&& (memcmp (array->data, "<hidden>", 8) == 0))
-				return;
-
-			if (nm_utils_is_empty_ssid ((const guint8 *) array->data, len))
-				return;
-
-			ssid = g_byte_array_sized_new (len);
-			g_byte_array_append (ssid, (const guint8 *) array->data, len);
-			nm_ap_set_ssid (ap, ssid);
-			g_byte_array_free (ssid, TRUE);
-		} else if (!strcmp (key, "bssid")) {
-			struct ether_addr addr;
-
-			if (array->len != ETH_ALEN)
-				return;
-			memset (&addr, 0, sizeof (struct ether_addr));
-			memcpy (&addr, array->data, ETH_ALEN);
-			nm_ap_set_address (ap, &addr);
-		} else if (!strcmp (key, "wpaie")) {
-			guint8 * ie = (guint8 *) array->data;
-			guint32 flags = nm_ap_get_wpa_flags (ap);
-
-			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
-				return;
-			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
-			nm_ap_set_wpa_flags (ap, flags);
-		} else if (!strcmp (key, "rsnie")) {
-			guint8 * ie = (guint8 *) array->data;
-			guint32 flags = nm_ap_get_rsn_flags (ap);
-
-			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
-				return;
-			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
-			nm_ap_set_rsn_flags (ap, flags);
-		}
-	} else if (G_VALUE_HOLDS_INT (variant)) {
-		gint32 int_val = g_value_get_int (variant);
-
-		if (!strcmp (key, "frequency")) {
-			nm_ap_set_freq (ap, (guint32) int_val);
-		} else if (!strcmp (key, "maxrate")) {
-			/* Supplicant reports as b/s, we use Kb/s internally */
-			nm_ap_set_max_bitrate (ap, int_val / 1000);
-		}
-	} else if (G_VALUE_HOLDS_UINT (variant)) {
-		guint32 val = g_value_get_uint (variant);
-
-		if (!strcmp (key, "capabilities")) {
-			if (val & IEEE80211_CAP_ESS) {
-				nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
-			} else if (val & IEEE80211_CAP_IBSS) {
-				nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
-			}
-
-			if (val & IEEE80211_CAP_PRIVACY) {
-				guint32 flags = nm_ap_get_flags (ap);
-				nm_ap_set_flags (ap, flags | NM_802_11_AP_FLAGS_PRIVACY);
-			}
-		}
-	}
-}
-
-
-NMAccessPoint *
-nm_ap_new_from_properties (GHashTable *properties)
-{
-	NMAccessPoint *ap;
-	GTimeVal cur_time;
-	const struct ether_addr * addr;
-	const char bad_bssid1[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-	const char bad_bssid2[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
-
-	g_return_val_if_fail (properties != NULL, NULL);
-
-	ap = nm_ap_new ();
-
-	g_object_freeze_notify (G_OBJECT (ap));
-	g_hash_table_foreach (properties, foreach_property_cb, ap);
-
-	/* ignore APs with invalid BSSIDs */
-	addr = nm_ap_get_address (ap);
-	if (   !(memcmp (addr->ether_addr_octet, bad_bssid1, ETH_ALEN))
-	    || !(memcmp (addr->ether_addr_octet, bad_bssid2, ETH_ALEN))) {
-		g_object_unref (ap);
-		return NULL;
-	}
-
-	g_get_current_time (&cur_time);
-	nm_ap_set_last_seen (ap, cur_time.tv_sec);
-
-	if (!nm_ap_get_ssid (ap))
-		nm_ap_set_broadcast (ap, FALSE);
-
-	g_object_thaw_notify (G_OBJECT (ap));
-
-	return ap;
-}
-
-#define PROTO_WPA "wpa"
-#define PROTO_RSN "rsn"
-
-static gboolean
-has_proto (NMSettingWirelessSecurity *sec, const char *proto)
-{
-	guint32 num_protos = nm_setting_wireless_security_get_num_protos (sec);
-	guint32 i;
-
-	if (num_protos == 0)
-		return TRUE; /* interpret no protos as "all" */
-
-	for (i = 0; i < num_protos; i++) {
-		if (!strcmp (nm_setting_wireless_security_get_proto (sec, i), proto))
-			return TRUE;
-	}
-	return FALSE;
-}
-
-static void
-add_pair_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
-{
-	guint32 num = nm_setting_wireless_security_get_num_pairwise (sec);
-	guint32 flags = NM_802_11_AP_SEC_NONE;
-	guint32 i;
-
-	/* If no ciphers are specified, that means "all" WPA ciphers */
-	if (num == 0) {
-		flags |= NM_802_11_AP_SEC_PAIR_TKIP | NM_802_11_AP_SEC_PAIR_CCMP;
-	} else {
-		for (i = 0; i < num; i++) {
-			const char *cipher = nm_setting_wireless_security_get_pairwise (sec, i);
-
-			if (!strcmp (cipher, "tkip"))
-				flags |= NM_802_11_AP_SEC_PAIR_TKIP;
-			else if (!strcmp (cipher, "ccmp"))
-				flags |= NM_802_11_AP_SEC_PAIR_CCMP;
-		}
-	}
-
-	if (has_proto (sec, PROTO_WPA))
-		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
-	if (has_proto (sec, PROTO_RSN))
-		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
-}
-
-static void
-add_group_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
-{
-	guint32 num = nm_setting_wireless_security_get_num_groups (sec);
-	guint32 flags = NM_802_11_AP_SEC_NONE;
-	guint32 i;
-
-	/* If no ciphers are specified, that means "all" WPA ciphers */
-	if (num == 0) {
-		flags |= NM_802_11_AP_SEC_GROUP_TKIP | NM_802_11_AP_SEC_GROUP_CCMP;
-	} else {
-		for (i = 0; i < num; i++) {
-			const char *cipher = nm_setting_wireless_security_get_group (sec, i);
-
-			if (!strcmp (cipher, "wep40"))
-				flags |= NM_802_11_AP_SEC_GROUP_WEP40;
-			else if (!strcmp (cipher, "wep104"))
-				flags |= NM_802_11_AP_SEC_GROUP_WEP104;
-			else if (!strcmp (cipher, "tkip"))
-				flags |= NM_802_11_AP_SEC_GROUP_TKIP;
-			else if (!strcmp (cipher, "ccmp"))
-				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
-		}
-	}
-
-	if (has_proto (sec, PROTO_WPA))
-		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
-	if (has_proto (sec, PROTO_RSN))
-		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
-}
-
-NMAccessPoint *
-nm_ap_new_fake_from_connection (NMConnection *connection)
-{
-	NMAccessPoint *ap;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wireless_sec;
-	const GByteArray *ssid;
-	const char *mode, *band, *key_mgmt;
-	guint32 channel, flags;
-	gboolean psk = FALSE, eap = FALSE;
-
-	g_return_val_if_fail (connection != NULL, NULL);
-
-	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
-	g_return_val_if_fail (s_wireless != NULL, NULL);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_return_val_if_fail (ssid != NULL, NULL);
-	g_return_val_if_fail (ssid->len > 0, NULL);
-
-	ap = nm_ap_new ();
-	nm_ap_set_fake (ap, TRUE);
-	nm_ap_set_ssid (ap, ssid);
-
-	// FIXME: bssid too?
-
-	mode = nm_setting_wireless_get_mode (s_wireless);
-	if (mode) {
-		if (!strcmp (mode, "infrastructure"))
-			nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
-		else if (!strcmp (mode, "adhoc"))
-			nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
-		else
-			goto error;
-	} else {
-		nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
-	}
-
-	band = nm_setting_wireless_get_band (s_wireless);
-	channel = nm_setting_wireless_get_channel (s_wireless);
-
-	if (band && channel) {
-		guint32 freq = channel_to_freq (channel, band);
-
-		if (freq == 0)
-			goto error;
-
-		nm_ap_set_freq (ap, freq);
-	}
-
-	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY);
-	/* Assume presence of a security setting means the AP is encrypted */
-	if (!s_wireless_sec)
-		goto done;
-
-	key_mgmt = nm_setting_wireless_security_get_key_mgmt (s_wireless_sec);
-
-	/* Everything below here uses encryption */
-	nm_ap_set_flags (ap, nm_ap_get_flags (ap) | NM_802_11_AP_FLAGS_PRIVACY);
-
-	/* Static & Dynamic WEP */
-	if (!strcmp (key_mgmt, "none") || !strcmp (key_mgmt, "ieee8021x"))
-		goto done;
-
-	psk = !strcmp (key_mgmt, "wpa-psk");
-	eap = !strcmp (key_mgmt, "wpa-eap");
-	if (psk || eap) {
-		if (has_proto (s_wireless_sec, PROTO_WPA)) {
-			flags = nm_ap_get_wpa_flags (ap);
-			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
-			nm_ap_set_wpa_flags (ap, flags);
-		}
-		if (has_proto (s_wireless_sec, PROTO_RSN)) {
-			flags = nm_ap_get_rsn_flags (ap);
-			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
-			nm_ap_set_rsn_flags (ap, flags);
-		}
-
-		add_pair_ciphers (ap, s_wireless_sec);
-		add_group_ciphers (ap, s_wireless_sec);
-	} else if (!strcmp (key_mgmt, "wpa-none")) {
-		guint32 i;
-
-		/* Ad-Hoc has special requirements: proto=WPA, pairwise=(none), and
-		 * group=TKIP/CCMP (but not both).
-		 */
-
-		flags = nm_ap_get_wpa_flags (ap);
-		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
-
-		/* Clear ciphers; pairwise must be unset anyway, and group gets set below */
-		flags &= ~(  NM_802_11_AP_SEC_PAIR_WEP40
-		           | NM_802_11_AP_SEC_PAIR_WEP104
-		           | NM_802_11_AP_SEC_PAIR_TKIP
-		           | NM_802_11_AP_SEC_PAIR_CCMP
-		           | NM_802_11_AP_SEC_GROUP_WEP40
-		           | NM_802_11_AP_SEC_GROUP_WEP104
-		           | NM_802_11_AP_SEC_GROUP_TKIP
-		           | NM_802_11_AP_SEC_GROUP_CCMP);
-
-		for (i = 0; i < nm_setting_wireless_security_get_num_groups (s_wireless_sec); i++) {
-			if (!strcmp (nm_setting_wireless_security_get_group (s_wireless_sec, i), "ccmp")) {
-				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
-				break;
-			}
-		}
-
-		/* Default to TKIP since not all WPA-capable cards can do CCMP */
-		if (!(flags & NM_802_11_AP_SEC_GROUP_CCMP))
-			flags |= NM_802_11_AP_SEC_GROUP_TKIP;
-
-		nm_ap_set_wpa_flags (ap, flags);
-
-		/* Don't use Ad-Hoc RSN yet */
-		nm_ap_set_rsn_flags (ap, NM_802_11_AP_SEC_NONE);
-	}
-
-done:
-	return ap;
-
-error:
-	g_object_unref (ap);
-	return NULL;
-}
-
-
-#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
-#define MAC_ARG(x) ((guint8*)(x))[0],((guint8*)(x))[1],((guint8*)(x))[2],((guint8*)(x))[3],((guint8*)(x))[4],((guint8*)(x))[5]
-
-void
-nm_ap_print_self (NMAccessPoint *ap,
-                  const char * prefix)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	nm_info ("%s'%s' (%p) stamp=%ld flags=0x%X wpa-flags=0x%X rsn-flags=0x%x "
-	         "bssid=" MAC_FMT " strength=%d freq=%d rate=%d mode=%d seen=%ld",
-	         prefix,
-	         priv->ssid ? nm_utils_escape_ssid (priv->ssid->data, priv->ssid->len) : "(none)",
-	         ap,
-	         priv->timestamp.tv_sec,
-	         priv->flags,
-	         priv->wpa_flags,
-	         priv->rsn_flags,
-	         MAC_ARG (priv->address.ether_addr_octet),
-	         priv->strength,
-	         priv->freq,
-	         priv->max_bitrate,
-	         priv->mode,
-	         priv->last_seen);
-}
-
-const char *
-nm_ap_get_dbus_path (NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	return NM_AP_GET_PRIVATE (ap)->dbus_path;
-}
-
-
-/*
- * Get/set functions for timestamp
- *
- */
-const GTimeVal *nm_ap_get_timestamp (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	return (&NM_AP_GET_PRIVATE (ap)->timestamp);
-}
-
-void nm_ap_set_timestamp (NMAccessPoint *ap, glong sec, glong usec)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	priv->timestamp.tv_sec = sec;
-	priv->timestamp.tv_usec = usec;
-}
-
-void nm_ap_set_timestamp_via_timestamp (NMAccessPoint *ap, const GTimeVal *timestamp)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->timestamp = *timestamp;
-}
-
-/*
- * Get/set functions for ssid
- *
- */
-const GByteArray * nm_ap_get_ssid (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	return NM_AP_GET_PRIVATE (ap)->ssid;
-}
-
-void
-nm_ap_set_ssid (NMAccessPoint *ap, const GByteArray * ssid)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if ((ssid == priv->ssid) && ssid == NULL)
-		return;
-
-	/* same SSID */
-	if ((ssid && priv->ssid) && (ssid->len == priv->ssid->len)) {
-		if (!memcmp (ssid->data, priv->ssid->data, ssid->len))
-			return;
-	}
-
-	if (priv->ssid) {
-		g_byte_array_free (priv->ssid, TRUE);
-		priv->ssid = NULL;
-	}
-
-	if (ssid) {
-		priv->ssid = g_byte_array_sized_new (ssid->len);
-		priv->ssid->len = ssid->len;
-		memcpy (priv->ssid->data, ssid->data, ssid->len);
-	}
-
-	g_object_notify (G_OBJECT (ap), NM_AP_SSID);
-}
-
-
-guint32
-nm_ap_get_flags (NMAccessPoint *ap)
-{
-	guint32 flags;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_FLAGS_NONE);
-
-	g_object_get (ap, NM_AP_FLAGS, &flags, NULL);
-
-	return flags;
-}
-
-
-void
-nm_ap_set_flags (NMAccessPoint *ap, guint32 flags)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->flags != flags) {
-		priv->flags = flags;
-		g_object_notify (G_OBJECT (ap), NM_AP_FLAGS);
-	}
-}
-
-guint32
-nm_ap_get_wpa_flags (NMAccessPoint *ap)
-{
-	guint32 flags;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
-
-	g_object_get (ap, NM_AP_WPA_FLAGS, &flags, NULL);
-
-	return flags;
-}
-
-
-void
-nm_ap_set_wpa_flags (NMAccessPoint *ap, guint32 flags)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->wpa_flags != flags) {
-		priv->wpa_flags = flags;
-		g_object_notify (G_OBJECT (ap), NM_AP_WPA_FLAGS);
-	}
-}
-
-guint32
-nm_ap_get_rsn_flags (NMAccessPoint *ap)
-{
-	guint32 flags;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
-
-	g_object_get (ap, NM_AP_RSN_FLAGS, &flags, NULL);
-
-	return flags;
-}
-
-
-void
-nm_ap_set_rsn_flags (NMAccessPoint *ap, guint32 flags)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->rsn_flags != flags) {
-		priv->rsn_flags = flags;
-		g_object_notify (G_OBJECT (ap), NM_AP_RSN_FLAGS);
-	}
-}
-
-/*
- * Get/set functions for address
- *
- */
-const struct ether_addr * nm_ap_get_address (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	return &NM_AP_GET_PRIVATE (ap)->address;
-}
-
-void nm_ap_set_address (NMAccessPoint *ap, const struct ether_addr * addr)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-	g_return_if_fail (addr != NULL);
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (memcmp (addr, &priv->address, sizeof (priv->address))) {
-		memcpy (&NM_AP_GET_PRIVATE (ap)->address, addr, sizeof (struct ether_addr));
-		g_object_notify (G_OBJECT (ap), NM_AP_HW_ADDRESS);
-	}
-}
-
-
-/*
- * Get/set functions for mode (ie Ad-Hoc, Infrastructure, etc)
- *
- */
-NM80211Mode nm_ap_get_mode (NMAccessPoint *ap)
-{
-	NM80211Mode mode;
-
-	g_return_val_if_fail (NM_IS_AP (ap), -1);
-
-	g_object_get (ap, NM_AP_MODE, &mode, NULL);
-
-	return mode;
-}
-
-void nm_ap_set_mode (NMAccessPoint *ap, const NM80211Mode mode)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	if (mode == NM_802_11_MODE_ADHOC || mode == NM_802_11_MODE_INFRA) {
-		priv = NM_AP_GET_PRIVATE (ap);
-
-		if (priv->mode != mode) {
-			priv->mode = mode;
-			g_object_notify (G_OBJECT (ap), NM_AP_MODE);
-		}
-	} else
-		nm_warning ("Invalid AP mode '%d'", mode);
-}
-
-
-/*
- * Get/set functions for strength
- *
- */
-gint8 nm_ap_get_strength (NMAccessPoint *ap)
-{
-	gint8 strength;
-
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	g_object_get (ap, NM_AP_STRENGTH, &strength, NULL);
-
-	return strength;
-}
-
-void nm_ap_set_strength (NMAccessPoint *ap, const gint8 strength)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->strength != strength) {
-		priv->strength = strength;
-		g_object_notify (G_OBJECT (ap), NM_AP_STRENGTH);
-	}
-}
-
-
-/*
- * Get/set functions for frequency
- *
- */
-guint32
-nm_ap_get_freq (NMAccessPoint *ap)
-{
-	guint32 freq;
-
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	g_object_get (ap, NM_AP_FREQUENCY, &freq, NULL);
-
-	return freq;
-}
-
-void
-nm_ap_set_freq (NMAccessPoint *ap,
-                const guint32 freq)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->freq != freq) {
-		priv->freq = freq;
-		g_object_notify (G_OBJECT (ap), NM_AP_FREQUENCY);
-	}
-}
-
-
-/*
- * Get/set functions for max bitrate
- *
- */
-guint32 nm_ap_get_max_bitrate (NMAccessPoint *ap)
-{
-	guint32 rate;
-
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	g_object_get (ap, NM_AP_MAX_BITRATE, &rate, NULL);
-
-	return rate;
-}
-
-void
-nm_ap_set_max_bitrate (NMAccessPoint *ap, guint32 bitrate)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->max_bitrate != bitrate) {
-		priv->max_bitrate = bitrate;
-		g_object_notify (G_OBJECT (ap), NM_AP_MAX_BITRATE);
-	}
-}
-
-/*
- * Get/Set functions to indicate that an access point is 'fake', ie whether
- * or not it was created from scan results
- */
-gboolean nm_ap_get_fake (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
-
-	return NM_AP_GET_PRIVATE (ap)->fake;
-}
-
-void nm_ap_set_fake (NMAccessPoint *ap, gboolean fake)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->fake = fake;
-}
-
-
-/*
- * Get/Set functions to indicate whether an AP broadcasts its SSID.
- */
-gboolean nm_ap_get_broadcast (NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), TRUE);
-
-	return NM_AP_GET_PRIVATE (ap)->broadcast;
-}
-
-
-void nm_ap_set_broadcast (NMAccessPoint *ap, gboolean broadcast)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->broadcast = broadcast;
-}
-
-
-/*
- * Get/Set functions for how long ago the AP was last seen in a scan.
- * APs older than a certain date are dropped from the list.
- *
- */
-glong nm_ap_get_last_seen (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
-
-	return NM_AP_GET_PRIVATE (ap)->last_seen;
-}
-
-void nm_ap_set_last_seen (NMAccessPoint *ap, const glong last_seen)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->last_seen = last_seen;
-}
-
-
-/*
- * Get/Set functions to indicate that an access point is
- * user-created, ie whether or not its a network filled with
- * information from the user and intended to create a new Ad-Hoc
- * wireless network.
- *
- */
-gboolean nm_ap_get_user_created (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
-
-	return NM_AP_GET_PRIVATE (ap)->user_created;
-}
-
-void nm_ap_set_user_created (NMAccessPoint *ap, gboolean user_created)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->user_created = user_created;
-}
-
-
-/*
- * Get/Set functions for user address list
- *
- * The internal address list is always "owned" by the AP and
- * the list returned by nm_ap_get_user_addresses() is a deep copy.
- * Likewise, when setting the list, a deep copy is made for the
- * ap's actual list.
- *
- */
-GSList *nm_ap_get_user_addresses (const NMAccessPoint *ap)
-{
-	GSList	*new = NULL;
-	GSList	*elt = NULL;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	for (elt = NM_AP_GET_PRIVATE (ap)->user_addresses; elt; elt = g_slist_next (elt))
-	{
-		if (elt->data)
-			new = g_slist_append (new, g_strdup (elt->data));
-	}
-
-	/* Return a _deep__copy_ of the address list */
-	return new;
-}
-
-void nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list)
-{
-	NMAccessPointPrivate *priv;
-	GSList	*elt = NULL;
-	GSList	*new = NULL;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	/* Free existing list */
-	g_slist_foreach (priv->user_addresses, (GFunc) g_free, NULL);
-
-	/* Copy new list and set as our own */
-	for (elt = list; elt; elt = g_slist_next (elt))
-	{
-		if (elt->data)
-			new = g_slist_append (new, g_ascii_strup (elt->data, -1));
-	}
-
-	priv->user_addresses = new;
-}
-
-
-guint32
-nm_ap_add_security_from_ie (guint32 flags,
-                            const guint8 *wpa_ie,
-                            guint32 length)
-{
-	wpa_ie_data * cap_data;
-
-	if (!(cap_data = wpa_parse_wpa_ie (wpa_ie, length)))
-		return NM_802_11_AP_SEC_NONE;
-
-	/* Pairwise cipher flags */
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP40)
-		flags |= NM_802_11_AP_SEC_PAIR_WEP40;
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP104)
-		flags |= NM_802_11_AP_SEC_PAIR_WEP104;
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_TKIP)
-		flags |= NM_802_11_AP_SEC_PAIR_TKIP;
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_CCMP)
-		flags |= NM_802_11_AP_SEC_PAIR_CCMP;
-
-	/* Group cipher flags */
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP40)
-		flags |= NM_802_11_AP_SEC_GROUP_WEP40;
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP104)
-		flags |= NM_802_11_AP_SEC_GROUP_WEP104;
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_TKIP)
-		flags |= NM_802_11_AP_SEC_GROUP_TKIP;
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_CCMP)
-		flags |= NM_802_11_AP_SEC_GROUP_CCMP;
-
-	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_802_1X)
-		flags |= NM_802_11_AP_SEC_KEY_MGMT_802_1X;
-	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_PSK)
-		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
-
-	g_slice_free (wpa_ie_data, cap_data);
-	return flags;
-}
-
-gboolean
-nm_ap_check_compatible (NMAccessPoint *self,
-                        NMConnection *connection)
-{
-	NMAccessPointPrivate *priv;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wireless_sec;
-	const char *mode;
-	const char *band;
-	const GByteArray *bssid;
-	guint32 channel;
-
-	g_return_val_if_fail (NM_IS_AP (self), FALSE);
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
-
-	priv = NM_AP_GET_PRIVATE (self);
-
-	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
-	if (s_wireless == NULL)
-		return FALSE;
-	
-	if (!nm_utils_same_ssid (nm_setting_wireless_get_ssid (s_wireless), priv->ssid, TRUE))
-		return FALSE;
-
-	bssid = nm_setting_wireless_get_bssid (s_wireless);
-	if (bssid && memcmp (bssid->data, &priv->address, ETH_ALEN))
-		return FALSE;
-
-	mode = nm_setting_wireless_get_mode (s_wireless);
-	if (mode) {
-		if (!strcmp (mode, "infrastructure") && (priv->mode != NM_802_11_MODE_INFRA))
-			return FALSE;
-		if (!strcmp (mode, "adhoc") && (priv->mode != NM_802_11_MODE_ADHOC))
-			return FALSE;
-	}
-
-	band = nm_setting_wireless_get_band (s_wireless);
-	if (band) {
-		if (!strcmp (band, "a")) {
-			if (priv->freq < 4915 || priv->freq > 5825)
-				return FALSE;
-		} else if (!strcmp (band, "bg")) {
-			if (priv->freq < 2412 || priv->freq > 2484)
-				return FALSE;
-		}
-	}
-
-	channel = nm_setting_wireless_get_channel (s_wireless);
-	if (channel) {
-		guint32 ap_chan = freq_to_channel (priv->freq);
-
-		if (channel != ap_chan)
-			return FALSE;
-	}
-
-	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection,
-															    NM_TYPE_SETTING_WIRELESS_SECURITY);
-
-	return nm_setting_wireless_ap_security_compatible (s_wireless,
-											 s_wireless_sec,
-											 nm_ap_get_flags (self),
-											 nm_ap_get_wpa_flags (self),
-											 nm_ap_get_rsn_flags (self),
-											 nm_ap_get_mode (self));
-}
-
-static gboolean
-capabilities_compatible (guint32 a_flags, guint32 b_flags)
-{
-	if (a_flags == b_flags)
-		return TRUE;
-
-	/* Make sure there's a common key management method */
-	if (!((a_flags & 0x300) & (b_flags & 0x300)))
-		return FALSE;
-
-	/* Ensure common pairwise ciphers */
-	if (!((a_flags & 0xF) & (b_flags & 0xF)))
-		return FALSE;
-
-	/* Ensure common group ciphers */
-	if (!((a_flags & 0xF0) & (b_flags & 0xF0)))
-		return FALSE;
-
-	return TRUE;
-}
-
-NMAccessPoint *
-nm_ap_match_in_list (NMAccessPoint *find_ap,
-                     GSList *ap_list,
-                     gboolean strict_match)
-{
-	GSList *iter;
-
-	g_return_val_if_fail (find_ap != NULL, NULL);
-
-	for (iter = ap_list; iter; iter = g_slist_next (iter)) {
-		NMAccessPoint * list_ap = NM_AP (iter->data);
-		const GByteArray * list_ssid = nm_ap_get_ssid (list_ap);
-		const struct ether_addr * list_addr = nm_ap_get_address (list_ap);
-
-		const GByteArray * find_ssid = nm_ap_get_ssid (find_ap);
-		const struct ether_addr * find_addr = nm_ap_get_address (find_ap);
-
-		/* SSID match; if both APs are hiding their SSIDs,
-		 * let matching continue on BSSID and other properties
-		 */
-		if (   (!list_ssid && find_ssid)
-		    || (list_ssid && !find_ssid)
-		    || !nm_utils_same_ssid (list_ssid, find_ssid, TRUE))
-			continue;
-
-		/* BSSID match */
-		if (   (strict_match || nm_ethernet_address_is_valid (find_addr))
-		    && nm_ethernet_address_is_valid (list_addr)
-		    && memcmp (list_addr->ether_addr_octet, 
-		               find_addr->ether_addr_octet,
-		               ETH_ALEN) != 0) {
-			continue;
-		}
-
-		/* mode match */
-		if (nm_ap_get_mode (list_ap) != nm_ap_get_mode (find_ap))
-			continue;
-
-		/* Frequency match */
-		if (nm_ap_get_freq (list_ap) != nm_ap_get_freq (find_ap))
-			continue;
-
-		/* AP flags */
-		if (nm_ap_get_flags (list_ap) != nm_ap_get_flags (find_ap))
-			continue;
-
-		if (strict_match) {
-			if (nm_ap_get_wpa_flags (list_ap) != nm_ap_get_wpa_flags (find_ap))
-				continue;
-
-			if (nm_ap_get_rsn_flags (list_ap) != nm_ap_get_rsn_flags (find_ap))
-				continue;
-		} else {
-			guint32 list_wpa_flags = nm_ap_get_wpa_flags (list_ap);
-			guint32 find_wpa_flags = nm_ap_get_wpa_flags (find_ap);
-			guint32 list_rsn_flags = nm_ap_get_rsn_flags (list_ap);
-			guint32 find_rsn_flags = nm_ap_get_rsn_flags (find_ap);
-
-			/* Just ensure that there is overlap in the capabilities */
-			if (   !capabilities_compatible (list_wpa_flags, find_wpa_flags)
-			    && !capabilities_compatible (list_rsn_flags, find_rsn_flags))
-				continue;
-		}
-
-		return list_ap;
-	}
-
-	return NULL;
-}
-
-
-struct cf_pair {
-	guint32 chan;
-	guint32 freq;
-};
-
-static struct cf_pair a_table[] = {
-	/* A band */
-	{  7, 5035 },
-	{  8, 5040 },
-	{  9, 5045 },
-	{ 11, 5055 },
-	{ 12, 5060 },
-	{ 16, 5080 },
-	{ 34, 5170 },
-	{ 36, 5180 },
-	{ 38, 5190 },
-	{ 40, 5200 },
-	{ 42, 5210 },
-	{ 44, 5220 },
-	{ 46, 5230 },
-	{ 48, 5240 },
-	{ 50, 5250 },
-	{ 52, 5260 },
-	{ 56, 5280 },
-	{ 58, 5290 },
-	{ 60, 5300 },
-	{ 64, 5320 },
-	{ 100, 5500 },
-	{ 104, 5520 },
-	{ 108, 5540 },
-	{ 112, 5560 },
-	{ 116, 5580 },
-	{ 120, 5600 },
-	{ 124, 5620 },
-	{ 128, 5640 },
-	{ 132, 5660 },
-	{ 136, 5680 },
-	{ 140, 5700 },
-	{ 149, 5745 },
-	{ 152, 5760 },
-	{ 153, 5765 },
-	{ 157, 5785 },
-	{ 160, 5800 },
-	{ 161, 5805 },
-	{ 165, 5825 },
-	{ 183, 4915 },
-	{ 184, 4920 },
-	{ 185, 4925 },
-	{ 187, 4935 },
-	{ 188, 4945 },
-	{ 192, 4960 },
-	{ 196, 4980 },
-	{ 0, -1 }
-};
-
-static struct cf_pair bg_table[] = {
-	/* B/G band */
-	{ 1, 2412 },
-	{ 2, 2417 },
-	{ 3, 2422 },
-	{ 4, 2427 },
-	{ 5, 2432 },
-	{ 6, 2437 },
-	{ 7, 2442 },
-	{ 8, 2447 },
-	{ 9, 2452 },
-	{ 10, 2457 },
-	{ 11, 2462 },
-	{ 12, 2467 },
-	{ 13, 2472 },
-	{ 14, 2484 },
-	{ 0, -1 }
-};
-
-guint32
-freq_to_channel (guint32 freq)
-{
-	int i = 0;
-
-	if (freq > 4900) {
-		while (a_table[i].chan && (a_table[i].freq != freq))
-			i++;
-		return a_table[i].chan;
-	} else {
-		while (bg_table[i].chan && (bg_table[i].freq != freq))
-			i++;
-		return bg_table[i].chan;
-	}
-
-	return 0;
-}
-
-guint32
-channel_to_freq (guint32 channel, const char *band)
-{
-	int i = 0;
-
-	if (!strcmp (band, "a")) {
-		while (a_table[i].chan && (a_table[i].chan != channel))
-			i++;
-		return a_table[i].freq;
-	} else if (!strcmp (band, "bg")) {
-		while (bg_table[i].chan && (bg_table[i].chan != channel))
-			i++;
-		return a_table[i].freq;
-	}
-
-	return 0;
-}
-
diff --git a/src/NetworkManagerAP.h b/src/NetworkManagerAP.h
deleted file mode 100644
index edc9e56..0000000
--- a/src/NetworkManagerAP.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#ifndef NM_ACCESS_POINT_H
-#define NM_ACCESS_POINT_H
-
-#include <glib.h>
-#include <glib-object.h>
-#include <time.h>
-#include "NetworkManager.h"
-#include "nm-connection.h"
-
-#define NM_TYPE_AP            (nm_ap_get_type ())
-#define NM_AP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_AP, NMAccessPoint))
-#define NM_AP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_AP, NMAccessPointClass))
-#define NM_IS_AP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_AP))
-#define NM_IS_AP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_AP))
-#define NM_AP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_AP, NMAccessPointClass))
-
-#define NM_AP_FLAGS "flags"
-#define NM_AP_WPA_FLAGS "wpa-flags"
-#define NM_AP_RSN_FLAGS "rsn-flags"
-#define NM_AP_SSID "ssid"
-#define NM_AP_FREQUENCY "frequency"
-#define NM_AP_HW_ADDRESS "hw-address"
-#define NM_AP_MODE "mode"
-#define NM_AP_MAX_BITRATE "max-bitrate"
-#define NM_AP_STRENGTH "strength"
-
-typedef struct {
-	GObject parent;
-} NMAccessPoint;
-
-typedef struct {
-	GObjectClass parent;
-
-	/* Signals */
-	void (*properties_changed) (NMAccessPoint *ap, GHashTable *properties);
-} NMAccessPointClass;
-
-GType nm_ap_get_type (void);
-
-NMAccessPoint *	nm_ap_new				(void);
-NMAccessPoint * nm_ap_new_from_properties (GHashTable *properties);
-NMAccessPoint * nm_ap_new_fake_from_connection (NMConnection *connection);
-void            nm_ap_export_to_dbus    (NMAccessPoint *ap);
-
-const char *		nm_ap_get_dbus_path (NMAccessPoint *ap);
-const GTimeVal *	nm_ap_get_timestamp				(const NMAccessPoint *ap);
-void				nm_ap_set_timestamp				(NMAccessPoint *ap, glong sec, glong usec);
-void				nm_ap_set_timestamp_via_timestamp	(NMAccessPoint *ap, const GTimeVal *timestamp);
-
-const GByteArray *	nm_ap_get_ssid (const NMAccessPoint * ap);
-void				nm_ap_set_ssid (NMAccessPoint * ap, const GByteArray * ssid);
-
-guint32			nm_ap_get_flags	(NMAccessPoint *ap);
-void				nm_ap_set_flags	(NMAccessPoint *ap, guint32 flags);
-
-guint32			nm_ap_get_wpa_flags	(NMAccessPoint *ap);
-void				nm_ap_set_wpa_flags	(NMAccessPoint *ap, guint32 flags);
-
-guint32			nm_ap_get_rsn_flags	(NMAccessPoint *ap);
-void				nm_ap_set_rsn_flags	(NMAccessPoint *ap, guint32 flags);
-
-const struct ether_addr * nm_ap_get_address	(const NMAccessPoint *ap);
-void				nm_ap_set_address		(NMAccessPoint *ap, const struct ether_addr *addr);
-
-NM80211Mode			nm_ap_get_mode			(NMAccessPoint *ap);
-void				nm_ap_set_mode			(NMAccessPoint *ap, const NM80211Mode mode);
-
-gint8			nm_ap_get_strength		(NMAccessPoint *ap);
-void				nm_ap_set_strength		(NMAccessPoint *ap, gint8 strength);
-
-guint32			nm_ap_get_freq			(NMAccessPoint *ap);
-void				nm_ap_set_freq			(NMAccessPoint *ap, guint32 freq);
-
-guint32			nm_ap_get_max_bitrate			(NMAccessPoint *ap);
-void				nm_ap_set_max_bitrate		(NMAccessPoint *ap, guint32 bitrate);
-
-gboolean			nm_ap_get_fake	(const NMAccessPoint *ap);
-void				nm_ap_set_fake	(NMAccessPoint *ap, gboolean fake);
-
-gboolean			nm_ap_get_broadcast		(NMAccessPoint *ap);
-void				nm_ap_set_broadcast		(NMAccessPoint *ap, gboolean broadcast);
-
-glong			nm_ap_get_last_seen		(const NMAccessPoint *ap);
-void				nm_ap_set_last_seen		(NMAccessPoint *ap, const glong last_seen);
-
-gboolean			nm_ap_get_user_created	(const NMAccessPoint *ap);
-void				nm_ap_set_user_created	(NMAccessPoint *ap, gboolean user_created);
-
-GSList *			nm_ap_get_user_addresses	(const NMAccessPoint *ap);
-void				nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list);
-
-guint32				nm_ap_add_security_from_ie (guint32 flags,
-                                                const guint8 *wpa_ie,
-                                                guint32 length);
-
-gboolean			nm_ap_check_compatible (NMAccessPoint *self,
-                                            NMConnection *connection);
-
-NMAccessPoint *     nm_ap_match_in_list (NMAccessPoint *find_ap,
-                                         GSList *ap_list,
-                                         gboolean strict_match);
-
-void				nm_ap_print_self (NMAccessPoint *ap, const char * prefix);
-
-guint32 freq_to_channel (guint32 freq);
-guint32 channel_to_freq (guint32 channel, const char *band);
-
-#endif /* NM_ACCESS_POINT_H */
diff --git a/src/NetworkManagerPolicy.c b/src/NetworkManagerPolicy.c
deleted file mode 100644
index 1b7801c..0000000
--- a/src/NetworkManagerPolicy.c
+++ /dev/null
@@ -1,1231 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2007 - 2008 Novell, Inc.
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <netdb.h>
-#include <ctype.h>
-
-#include "NetworkManagerPolicy.h"
-#include "NetworkManagerUtils.h"
-#include "NetworkManagerAP.h"
-#include "nm-activation-request.h"
-#include "nm-utils.h"
-#include "nm-device-interface.h"
-#include "nm-device.h"
-#include "nm-device-wifi.h"
-#include "nm-device-ethernet.h"
-#include "nm-dbus-manager.h"
-#include "nm-setting-ip4-config.h"
-#include "nm-setting-connection.h"
-#include "NetworkManagerSystem.h"
-#include "nm-named-manager.h"
-#include "nm-vpn-manager.h"
-#include "nm-modem.h"
-
-typedef struct LookupThread LookupThread;
-
-typedef void (*LookupCallback) (LookupThread *thread, gpointer user_data);
-
-struct LookupThread {
-	GThread *thread;
-
-	GMutex *lock;
-	gboolean die;
-	int ret;
-
-	guint32 ip4_addr;
-	char hostname[NI_MAXHOST + 1];
-
-	LookupCallback callback;
-	gpointer user_data;
-};
-
-struct NMPolicy {
-	NMManager *manager;
-	guint update_state_id;
-	GSList *pending_activation_checks;
-	GSList *signal_ids;
-	GSList *dev_signal_ids;
-
-	NMVPNManager *vpn_manager;
-	gulong vpn_activated_id;
-	gulong vpn_deactivated_id;
-
-	NMDevice *default_device;
-
-	LookupThread *lookup;
-
-	char *orig_hostname; /* hostname at NM start time */
-};
-
-static gboolean
-lookup_thread_run_cb (gpointer user_data)
-{
-	LookupThread *thread = (LookupThread *) user_data;
-
-	(*thread->callback) (thread, thread->user_data);
-	return FALSE;
-}
-
-static gpointer
-lookup_thread_worker (gpointer data)
-{
-	LookupThread *thread = (LookupThread *) data;
-	struct sockaddr_in addr;
-
-	g_mutex_lock (thread->lock);
-	if (thread->die) {
-		g_mutex_unlock (thread->lock);
-		return (gpointer) NULL;
-	}
-	g_mutex_unlock (thread->lock);
-
-	addr.sin_family = AF_INET;
-	addr.sin_addr.s_addr = thread->ip4_addr;
-
-	thread->ret = getnameinfo ((struct sockaddr *) &addr, sizeof (struct sockaddr_in),
-	                           thread->hostname, NI_MAXHOST, NULL, 0,
-	                           NI_NAMEREQD);
-	if (thread->ret == 0) {
-		int i;
-
-		for (i = 0; i < strlen (thread->hostname); i++)
-			thread->hostname[i] = tolower (thread->hostname[i]);
-	}
-
-	/* Don't track the idle handler ID because by the time the g_idle_add()
-	 * returns the ID, the handler may already have run and freed the
-	 * LookupThread.
-	 */
-	g_idle_add (lookup_thread_run_cb, thread);
-	return (gpointer) TRUE;
-}
-
-static void
-lookup_thread_free (LookupThread *thread)
-{
-	g_return_if_fail (thread != NULL);
-
-	g_mutex_free (thread->lock);
-	memset (thread, 0, sizeof (LookupThread));
-	g_free (thread);
-}
-
-static LookupThread *
-lookup_thread_new (guint32 ip4_addr, LookupCallback callback, gpointer user_data)
-{
-	LookupThread *thread;
-
-	thread = g_malloc0 (sizeof (LookupThread));
-	if (!thread)
-		return NULL;
-
-	thread->lock = g_mutex_new ();
-	thread->callback = callback;
-	thread->user_data = user_data;
-	thread->ip4_addr = ip4_addr;
-
-	thread->thread = g_thread_create (lookup_thread_worker, thread, FALSE, NULL);
-	if (!thread->thread) {
-		lookup_thread_free (thread);
-		return NULL;
-	}
-
-	return thread;
-}
-
-static void
-lookup_thread_die (LookupThread *thread)
-{
-	g_return_if_fail (thread != NULL);
-
-	g_mutex_lock (thread->lock);
-	thread->die = TRUE;
-	g_mutex_unlock (thread->lock);
-}
-
-#define INVALID_TAG "invalid"
-
-static const char *
-get_connection_id (NMConnection *connection)
-{
-	NMSettingConnection *s_con;
-
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
-
-	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-	g_return_val_if_fail (s_con != NULL, NULL);
-
-	return nm_setting_connection_get_id (s_con);
-}
-
-static NMDevice *
-get_best_device (NMManager *manager, NMActRequest **out_req)
-{
-	GSList *devices, *iter;
-	NMDevice *best = NULL;
-	int best_prio = G_MAXINT;
-
-	g_return_val_if_fail (manager != NULL, NULL);
-	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
-	g_return_val_if_fail (out_req != NULL, NULL);
-	g_return_val_if_fail (*out_req == NULL, NULL);
-
-	devices = nm_manager_get_devices (manager);
-	for (iter = devices; iter; iter = g_slist_next (iter)) {
-		NMDevice *dev = NM_DEVICE (iter->data);
-		NMActRequest *req;
-		NMConnection *connection;
-		NMIP4Config *ip4_config;
-		NMSettingIP4Config *s_ip4;
-		int prio;
-		guint i;
-		gboolean can_default = FALSE;
-		const char *method = NULL;
-
-		if (nm_device_get_state (dev) != NM_DEVICE_STATE_ACTIVATED)
-			continue;
-
-		ip4_config = nm_device_get_ip4_config (dev);
-		if (!ip4_config)
-			continue;
-
-		req = nm_device_get_act_request (dev);
-		g_assert (req);
-		connection = nm_act_request_get_connection (req);
-		g_assert (connection);
-
-		/* Never set the default route through an IPv4LL-addressed device */
-		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-		if (s_ip4)
-			method = nm_setting_ip4_config_get_method (s_ip4);
-
-		if (s_ip4 && !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
-			continue;
-
-		/* Make sure at least one of this device's IP addresses has a gateway */
-		for (i = 0; i < nm_ip4_config_get_num_addresses (ip4_config); i++) {
-			NMIP4Address *addr;
-
-			addr = nm_ip4_config_get_address (ip4_config, i);
-			if (nm_ip4_address_get_gateway (addr)) {
-				can_default = TRUE;
-				break;
-			}
-		}
-
-		if (!can_default && !NM_IS_MODEM (dev))
-			continue;
-
-		/* 'never-default' devices can't ever be the default */
-		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
-			continue;
-
-		prio = nm_device_get_priority (dev);
-		if (prio > 0 && prio < best_prio) {
-			best = dev;
-			best_prio = prio;
-			*out_req = req;
-		}
-	}
-
-	return best;
-}
-
-static gboolean
-is_localhost_mapping (const char *str)
-{
-	return (!strncmp (str, "127.0.0.1", strlen ("127.0.0.1")) && strstr (str, "localhost"));
-}
-
-static gboolean
-find_token (const char *line, const char *token)
-{
-	const char *start = line, *p = line;
-
-	g_return_val_if_fail (line != NULL, FALSE);
-	g_return_val_if_fail (token != NULL, FALSE);
-	g_return_val_if_fail (strlen (token) > 0, FALSE);
-
-	/* Walk through the line to find the next whitespace character */
-	while (p <= line + strlen (line)) {
-		if (isblank (*p) || (*p == '\0')) {
-			/* Token starts with 'start' and ends with 'end' */
-			if ((p > start) && *start && !strncmp (start, token, (p - start)))
-				return TRUE; /* found */
-
-			/* not found; advance start and continue looking */
-			start = p + 1;
-		}
-		p++;
-	}
-
-	return FALSE;
-}
-
-#if 0
-/* Testcase for find_token; break it out and add it to the testsuite */
-
-typedef struct {
-	const char *line;
-	const char *token;
-	gboolean expected;
-} Foo;
-
-static Foo foo[] = {
-	{ "127.0.0.1\tfoobar\tblah", "blah", TRUE },
-	{ "", "blah", FALSE },
-	{ "1.1.1.1\tbork\tfoo", "blah", FALSE },
-	{ "127.0.0.1 foobar\tblah", "blah", TRUE },
-	{ "127.0.0.1 foobar blah", "blah", TRUE },
-	{ "192.168.1.1 blah borkbork", "blah", TRUE },
-	{ "192.168.1.1 foobar\tblah borkbork", "blah", TRUE },
-	{ "192.168.1.1\tfoobar\tblah\tborkbork", "blah", TRUE },
-	{ "192.168.1.1 \tfoobar \tblah \tborkbork\t ", "blah", TRUE },
-	{ "\t\t\t\t   \t\t\tasdfadf  a\t\t\t\t\t   \t\t\t\t\t ", "blah", FALSE },
-	{ NULL, NULL, FALSE }
-};
-
-int main(int argc, char **argv)
-{
-	Foo *iter = &foo[0];
-
-	while (iter->line) {
-		if (find_token (iter->line, iter->token) != iter->expected) {
-			g_message ("Failed: '%s' <= '%s' (%d)", iter->line, iter->token, iter->expected);
-			return 1;
-		}
-		iter++;
-	}
-
-	g_message ("Success");
-	return 0;
-}
-#endif
-
-#define FALLBACK_HOSTNAME "localhost.localdomain"
-
-static gboolean
-update_etc_hosts (const char *hostname)
-{
-	char *contents = NULL;
-	char **lines = NULL, **line, **host_mapping = NULL;
-	GError *error = NULL;
-	gboolean initial_comments = TRUE;
-	gboolean added = FALSE;
-	gsize contents_len = 0;
-	GString *new_contents;
-	gboolean success = FALSE;
-
-	g_return_val_if_fail (hostname != NULL, FALSE);
-
-	if (!g_file_get_contents (SYSCONFDIR "/hosts", &contents, &contents_len, &error)) {
-		nm_warning ("%s: couldn't read " SYSCONFDIR "/hosts: (%d) %s",
-		            __func__, error ? error->code : 0,
-		            (error && error->message) ? error->message : "(unknown)");
-		if (error)
-			g_error_free (error);
-	} else {
-		lines = g_strsplit_set (contents, "\n\r", 0);
-		g_free (contents);
-	}
-
-	new_contents = g_string_sized_new (contents_len ? contents_len + 100 : 200);
-	if (!new_contents) {
-		nm_warning ("%s: not enough memory to update " SYSCONFDIR "/hosts", __func__);
-		return FALSE;
-	}
-
-	/* Two-pass modification of /etc/hosts:
-	 *
-	 * 1) Look for a non-comment, non-localhost line that contains the current
-	 *    hostname.  Mark that line.
-	 *
-	 * 2) For each line in the existing /etc/hosts, add it to the new /etc/hosts
-	 *    unless it starts with 127.0.0.1 and is right after the initial comments
-	 *    (if any) and contains "localhost".
-	 */
-
-	/* Find any existing hostname mapping */
-	for (line = lines; lines && *line; line++) {
-		/* Look for any line that (a) contains the current hostname, and
-		 * (b) does not start with '127.0.0.1' and contain 'localhost'.
-		 */
-		if (   strlen (*line)
-		    && (*line[0] != '#')
-		    && find_token (*line, hostname)
-		    && !is_localhost_mapping (*line)) {
-			host_mapping = line;
-			break;
-		}
-	}
-
-	/* Construct the new hosts file; replace any 127.0.0.1 entry that is at the
-	 * beginning of the file or right after initial comments and contains
-	 * the string 'localhost'.  If there is no 127.0.0.1 entry at the beginning
-	 * or after initial comments that contains 'localhost', add one there
-	 * and ignore any other 127.0.0.1 entries that contain 'localhost'.
-	 */
-	for (line = lines, initial_comments = TRUE; lines && *line; line++) {
-		gboolean add_line = TRUE;
-
-		/* This is the first line after the initial comments */
-		if (strlen (*line) && initial_comments && (*line[0] != '#')) {
-			initial_comments = FALSE;
-
-			/* If some other line contained the hostname, make a simple
-			 * localhost mapping and assume the user knows what they are doing
-			 * with their manual hostname entry.  Otherwise if the hostname
-			 * wasn't found somewhere else, add it to the localhost mapping line
-			 * to make sure it's mapped to something.
-			 */
-			if (host_mapping)
-				g_string_append (new_contents, "127.0.0.1");
-			else
-				g_string_append_printf (new_contents, "127.0.0.1\t%s", hostname);
-
-			if (strcmp (hostname, FALLBACK_HOSTNAME))
-				g_string_append_printf (new_contents, "\t" FALLBACK_HOSTNAME);
-
-			g_string_append (new_contents, "\tlocalhost\n");
-			added = TRUE;
-
-			/* Don't add the entry if it's supposed to be the actual localhost reverse mapping */
-			if (is_localhost_mapping (*line))
-				add_line = FALSE;
-		}
-
-		if (add_line) {
-			g_string_append (new_contents, *line);
-			/* Only append the new line if this isn't the last line in the file */
-			if (*(line+1))
-				g_string_append_c (new_contents, '\n');
-		}
-	}
-
-	/* Hmm, /etc/hosts was empty for some reason */
-	if (!added) {
-		g_string_append (new_contents, "# Do not remove the following line, or various programs\n");
-		g_string_append (new_contents, "# that require network functionality will fail.\n");
-		g_string_append (new_contents, "127.0.0.1\t" FALLBACK_HOSTNAME "\tlocalhost\n");
-	}
-
-	error = NULL;
-	if (!g_file_set_contents (SYSCONFDIR "/hosts", new_contents->str, -1, &error)) {
-		nm_warning ("%s: couldn't update " SYSCONFDIR "/hosts: (%d) %s",
-		            __func__, error ? error->code : 0,
-		            (error && error->message) ? error->message : "(unknown)");
-		if (error)
-			g_error_free (error);
-	} else
-		success = TRUE;
-
-	g_string_free (new_contents, TRUE);
-	return success;
-}
-
-static void
-set_system_hostname (const char *new_hostname, const char *msg)
-{
-	char old_hostname[HOST_NAME_MAX + 1];
-	int ret = 0;
-	const char *name = new_hostname ? new_hostname : FALLBACK_HOSTNAME;
-
-	old_hostname[HOST_NAME_MAX] = '\0';
-	errno = 0;
-	ret = gethostname (old_hostname, HOST_NAME_MAX);
-	if (ret != 0) {
-		nm_warning ("%s: couldn't get the system hostname: (%d) %s",
-		            __func__, errno, strerror (errno));
-	} else {
-		/* Do nothing if the hostname isn't actually changing */
-		if (   (new_hostname && !strcmp (old_hostname, new_hostname))
-		    || (!new_hostname && !strcmp (old_hostname, FALLBACK_HOSTNAME)))
-			return;
-	}
-
-	nm_info ("Setting system hostname to '%s' (%s)", name, msg);
-
-	ret = sethostname (name, strlen (name));
-	if (ret == 0) {
-		if (!update_etc_hosts (name)) {
-			/* error updating /etc/hosts; fallback to localhost.localdomain */
-			nm_info ("Setting system hostname to '" FALLBACK_HOSTNAME "' (error updating /etc/hosts)");
-			ret = sethostname (FALLBACK_HOSTNAME, strlen (FALLBACK_HOSTNAME));
-			if (ret != 0) {
-				nm_warning ("%s: couldn't set the fallback system hostname (%s): (%d) %s",
-				            __func__, FALLBACK_HOSTNAME, errno, strerror (errno));
-			}
-		}
-		nm_utils_call_dispatcher ("hostname", NULL, NULL, NULL);
-	} else {
-		nm_warning ("%s: couldn't set the system hostname to '%s': (%d) %s",
-		            __func__, name, errno, strerror (errno));
-	}
-}
-
-static void
-lookup_callback (LookupThread *thread, gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-
-	/* If the thread was told to die or it's not the current in-progress
-	 * hostname lookup, nothing to do.
-	 */
-	if (thread->die || (thread != policy->lookup))
-		goto done;
-
-	policy->lookup = NULL;
-	if (!strlen (thread->hostname)) {
-		char *msg;
-
-		/* No valid IP4 config (!!); fall back to localhost.localdomain */
-		msg = g_strdup_printf ("address lookup failed: %d", thread->ret);
-		set_system_hostname (NULL, msg);
-		g_free (msg);
-	} else
-		set_system_hostname (thread->hostname, "from address lookup");
-
-done:
-	lookup_thread_free (thread);
-}
-
-static void
-update_system_hostname (NMPolicy *policy, NMDevice *best)
-{
-	char *configured_hostname = NULL;
-	NMActRequest *best_req = NULL;
-	NMDHCP4Config *dhcp4_config;
-	NMIP4Config *ip4_config;
-	NMIP4Address *addr;
-
-	g_return_if_fail (policy != NULL);
-
-	if (policy->lookup) {
-		lookup_thread_die (policy->lookup);
-		policy->lookup = NULL;
-	}
-
-	/* Hostname precedence order:
-	 *
-	 * 1) a configured hostname (from system-settings)
-	 * 2) automatic hostname from the default device's config (DHCP, VPN, etc)
-	 * 3) the original hostname when NM started
-	 * 4) reverse-DNS of the best device's IPv4 address
-	 *
-	 */
-
-	/* Try a persistent hostname first */
-	g_object_get (G_OBJECT (policy->manager), NM_MANAGER_HOSTNAME, &configured_hostname, NULL);
-	if (configured_hostname) {
-		set_system_hostname (configured_hostname, "from system configuration");
-		g_free (configured_hostname);
-		return;
-	}
-
-	/* Try automatically determined hostname from the best device's IP config */
-	if (!best)
-		best = get_best_device (policy->manager, &best_req);
-
-	if (!best) {
-		/* No best device; fall back to original hostname or if there wasn't
-		 * one, 'localhost.localdomain'
-		 */
-		set_system_hostname (policy->orig_hostname, "no default device");
-		return;
-	}
-
-	/* Grab a hostname out of the device's DHCP4 config */
-	dhcp4_config = nm_device_get_dhcp4_config (best);
-	if (dhcp4_config) {
-		const char *dhcp4_hostname, *p;
-
-		p = dhcp4_hostname = nm_dhcp4_config_get_option (dhcp4_config, "host_name");
-		if (dhcp4_hostname && strlen (dhcp4_hostname)) {
-			/* Sanity check */
-			while (*p) {
-				if (!isblank (*p++)) {
-					set_system_hostname (dhcp4_hostname, "from DHCP");
-					return;
-				}
-			}
-			nm_warning ("%s: DHCP-provided hostname '%s' looks invalid; ignoring it",
-			            __func__, dhcp4_hostname);
-		}
-	}
-
-	/* If no automatically-configured hostname, try using the hostname from
-	 * when NM started up.
-	 */
-	if (policy->orig_hostname) {
-		set_system_hostname (policy->orig_hostname, "from system startup");
-		return;
-	}
-
-	/* No configured hostname, no automatically determined hostname, and
-	 * no bootup hostname. Start reverse DNS of the current IP address.
-	 */
-	ip4_config = nm_device_get_ip4_config (best);
-	if (   !ip4_config
-	    || (nm_ip4_config_get_num_nameservers (ip4_config) == 0)
-	    || (nm_ip4_config_get_num_addresses (ip4_config) == 0)) {
-		/* No valid IP4 config (!!); fall back to localhost.localdomain */
-		set_system_hostname (NULL, "no IPv4 config");
-		return;
-	}
-
-	addr = nm_ip4_config_get_address (ip4_config, 0);
-	g_assert (addr); /* checked for > 1 address above */
-
-	/* Start the hostname lookup thread */
-	policy->lookup = lookup_thread_new (nm_ip4_address_get_address (addr), lookup_callback, policy);
-	if (!policy->lookup) {
-		/* Fall back to 'localhost.localdomain' */
-		set_system_hostname (NULL, "error starting hostname thread");
-	}
-}
-
-static void
-update_routing_and_dns (NMPolicy *policy, gboolean force_update)
-{
-	NMNamedIPConfigType dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
-	NMDevice *best = NULL;
-	NMActRequest *best_req = NULL;
-	NMNamedManager *named_mgr;
-	GSList *devices = NULL, *iter, *vpns;
-	NMIP4Config *ip4_config = NULL;
-	NMIP4Address *addr;
-	const char *ip_iface = NULL;
-	NMConnection *connection = NULL;
-	NMSettingConnection *s_con = NULL;
-	const char *connection_id;
-
-	best = get_best_device (policy->manager, &best_req);
-	if (!best)
-		goto out;
-	if (!force_update && (best == policy->default_device))
-		goto out;
-
-	/* If a VPN connection is active, it is preferred */
-	vpns = nm_vpn_manager_get_active_connections (policy->vpn_manager);
-	for (iter = vpns; iter; iter = g_slist_next (iter)) {
-		NMVPNConnection *candidate = NM_VPN_CONNECTION (iter->data);
-		NMConnection *vpn_connection;
-		NMSettingIP4Config *s_ip4;
-		gboolean can_default = TRUE;
-		NMVPNConnectionState vpn_state;
-
-		/* If it's marked 'never-default', don't make it default */
-		vpn_connection = nm_vpn_connection_get_connection (candidate);
-		g_assert (vpn_connection);
-		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (vpn_connection, NM_TYPE_SETTING_IP4_CONFIG);
-		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
-			can_default = FALSE;
-
-		vpn_state = nm_vpn_connection_get_vpn_state (candidate);
-		if (can_default && (vpn_state == NM_VPN_CONNECTION_STATE_ACTIVATED)) {
-			NMIP4Config *parent_ip4;
-			NMDevice *parent;
-
-			ip_iface = nm_vpn_connection_get_ip_iface (candidate);
-			connection = nm_vpn_connection_get_connection (candidate);
-			ip4_config = nm_vpn_connection_get_ip4_config (candidate);
-			addr = nm_ip4_config_get_address (ip4_config, 0);
-
-			parent = nm_vpn_connection_get_parent_device (candidate);
-			parent_ip4 = nm_device_get_ip4_config (parent);
-
-			nm_system_replace_default_ip4_route_vpn (ip_iface,
-			                                         nm_ip4_address_get_gateway (addr),
-			                                         nm_vpn_connection_get_ip4_internal_gateway (candidate),
-			                                         nm_ip4_config_get_mss (ip4_config),
-			                                         nm_device_get_ip_iface (parent),
-			                                         nm_ip4_config_get_mss (parent_ip4));
-
-			dns_type = NM_NAMED_IP_CONFIG_TYPE_VPN;
-		}
-		g_object_unref (candidate);
-	}
-	g_slist_free (vpns);
-
-	/* The best device gets the default route if a VPN connection didn't */
-	if (!ip_iface || !ip4_config) {
-		connection = nm_act_request_get_connection (best_req);
-		ip_iface = nm_device_get_ip_iface (best);
-		ip4_config = nm_device_get_ip4_config (best);
-		g_assert (ip4_config);
-		addr = nm_ip4_config_get_address (ip4_config, 0);
-
-		nm_system_replace_default_ip4_route (ip_iface, nm_ip4_address_get_gateway (addr), nm_ip4_config_get_mss (ip4_config));
-
-		dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
-	}
-
-	if (!ip_iface || !ip4_config) {
-		nm_warning ("%s: couldn't determine IP interface (%p) or IPv4 config (%p)!",
-		            __func__, ip_iface, ip4_config);
-		goto out;
-	}
-
-	/* Update the default active connection.  Only mark the new default
-	 * active connection after setting default = FALSE on all other connections
-	 * first.  The order is important, we don't want two connections marked
-	 * default at the same time ever.
-	 */
-	devices = nm_manager_get_devices (policy->manager);
-	for (iter = devices; iter; iter = g_slist_next (iter)) {
-		NMDevice *dev = NM_DEVICE (iter->data);
-		NMActRequest *req;
-
-		req = nm_device_get_act_request (dev);
-		if (req && (req != best_req))
-			nm_act_request_set_default (req, FALSE);
-	}
-
-	named_mgr = nm_named_manager_get ();
-	nm_named_manager_add_ip4_config (named_mgr, ip_iface, ip4_config, dns_type);
-	g_object_unref (named_mgr);
-
-	/* Now set new default active connection _after_ updating DNS info, so that
-	 * if the connection is shared dnsmasq picks up the right stuff.
-	 */
-	if (best_req)
-		nm_act_request_set_default (best_req, TRUE);
-
-	if (connection)
-		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-
-	connection_id = s_con ? nm_setting_connection_get_id (s_con) : NULL;
-	if (connection_id)
-		nm_info ("Policy set '%s' (%s) as default for routing and DNS.", connection_id, ip_iface);
-	else
-		nm_info ("Policy set (%s) as default for routing and DNS.", ip_iface);
-
-out:
-	/* Update the system hostname */
-	update_system_hostname (policy, best);
-
-	policy->default_device = best;	
-}
-
-typedef struct {
-	NMPolicy *policy;
-	NMDevice *device;
-	guint id;
-} ActivateData;
-
-static gboolean
-auto_activate_device (gpointer user_data)
-{
-	ActivateData *data = (ActivateData *) user_data;
-	NMPolicy *policy;
-	NMConnection *best_connection;
-	char *specific_object = NULL;
-	GSList *connections, *iter;
-
-	g_assert (data);
-	policy = data->policy;
-
-	// FIXME: if a device is already activating (or activated) with a connection
-	// but another connection now overrides the current one for that device,
-	// deactivate the device and activate the new connection instead of just
-	// bailing if the device is already active
-	if (nm_device_get_act_request (data->device))
-		goto out;
-
-	/* System connections first, then user connections */
-	connections = nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_SYSTEM);
-	connections = g_slist_concat (connections, nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_USER));
-
-	/* Remove connections that are in the invalid list. */
-	iter = connections;
-	while (iter) {
-		NMConnection *iter_connection = NM_CONNECTION (iter->data);
-		GSList *next = g_slist_next (iter);
-
-		if (g_object_get_data (G_OBJECT (iter_connection), INVALID_TAG)) {
-			connections = g_slist_remove_link (connections, iter);
-			g_object_unref (iter_connection);
-			g_slist_free (iter);
-		}
-		iter = next;
-	}
-
-	best_connection = nm_device_get_best_auto_connection (data->device, connections, &specific_object);
-	if (best_connection) {
-		GError *error = NULL;
-		const char *device_path;
-
-		device_path = nm_device_get_path (data->device);
-		if (!nm_manager_activate_connection (policy->manager,
-		                                     best_connection,
-		                                     specific_object,
-		                                     device_path,
-		                                     FALSE,
-		                                     &error)) {
-			NMSettingConnection *s_con;
-
-			s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (best_connection, NM_TYPE_SETTING_CONNECTION));
-			g_assert (s_con);
-
-			nm_warning ("Connection '%s' auto-activation failed: (%d) %s",
-			            nm_setting_connection_get_id (s_con), error->code, error->message);
-			g_error_free (error);
-		}
-	}
-
-	g_slist_foreach (connections, (GFunc) g_object_unref, NULL);
-	g_slist_free (connections);
-
- out:
-	/* Remove this call's handler ID */
-	policy->pending_activation_checks = g_slist_remove (policy->pending_activation_checks, data);
-	g_object_unref (data->device);
-	g_free (data);
-
-	return FALSE;
-}
-
-/*****************************************************************************/
-
-static void
-vpn_connection_activated (NMVPNManager *manager,
-                          NMVPNConnection *vpn,
-                          gpointer user_data)
-{
-	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
-}
-
-static void
-vpn_connection_deactivated (NMVPNManager *manager,
-                            NMVPNConnection *vpn,
-                            NMVPNConnectionState state,
-                            NMVPNConnectionStateReason reason,
-                            gpointer user_data)
-{
-	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
-}
-
-static void
-global_state_changed (NMManager *manager, NMState state, gpointer user_data)
-{
-}
-
-static void
-hostname_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
-{
-	update_system_hostname ((NMPolicy *) user_data, NULL);
-}
-
-static void
-sleeping_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
-{
-	gboolean sleeping = FALSE;
-	GSList *connections, *iter;
-
-	g_object_get (G_OBJECT (manager), NM_MANAGER_SLEEPING, &sleeping, NULL);
-
-	/* Clear the invalid flag on all connections so they'll get retried on wakeup */
-	if (sleeping) {
-		connections = nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_SYSTEM);
-		connections = g_slist_concat (connections, nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_USER));
-		for (iter = connections; iter; iter = g_slist_next (iter))
-			g_object_set_data (G_OBJECT (iter->data), INVALID_TAG, NULL);
-		g_slist_free (connections);
-	}
-}
-
-static void
-schedule_activate_check (NMPolicy *policy, NMDevice *device, guint delay_seconds)
-{
-	ActivateData *data;
-	GSList *iter;
-	NMDeviceState state;
-
-	if (nm_manager_get_state (policy->manager) == NM_STATE_ASLEEP)
-		return;
-
-	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
-	if (state < NM_DEVICE_STATE_DISCONNECTED)
-		return;
-
-	if (!nm_device_autoconnect_allowed (device))
-		return;
-
-	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
-		/* Only one pending activation check at a time */
-		if (((ActivateData *) iter->data)->device == device)
-			return;
-	}
-
-	data = g_malloc0 (sizeof (ActivateData));
-	g_return_if_fail (data != NULL);
-
-	data->policy = policy;
-	data->device = g_object_ref (device);
-	data->id = delay_seconds ? g_timeout_add_seconds (delay_seconds, auto_activate_device, data) : g_idle_add (auto_activate_device, data);
-	policy->pending_activation_checks = g_slist_append (policy->pending_activation_checks, data);
-}
-
-static NMConnection *
-get_device_connection (NMDevice *device)
-{
-	NMActRequest *req;
-
-	req = nm_device_get_act_request (device);
-	if (!req)
-		return NULL;
-
-	return nm_act_request_get_connection (req);
-}
-
-static void
-device_state_changed (NMDevice *device,
-                      NMDeviceState new_state,
-                      NMDeviceState old_state,
-                      NMDeviceStateReason reason,
-                      gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-	NMConnection *connection = get_device_connection (device);
-
-	switch (new_state) {
-	case NM_DEVICE_STATE_FAILED:
-		/* Mark the connection invalid if it failed during activation so that
-		 * it doesn't get automatically chosen over and over and over again.
-		 */
-		if (connection && IS_ACTIVATING_STATE (old_state)) {
-			g_object_set_data (G_OBJECT (connection), INVALID_TAG, GUINT_TO_POINTER (TRUE));
-			nm_info ("Marking connection '%s' invalid.", get_connection_id (connection));
-			nm_connection_clear_secrets (connection);
-		}
-		schedule_activate_check (policy, device, 3);
-		break;
-	case NM_DEVICE_STATE_ACTIVATED:
-		/* Clear the invalid tag on the connection */
-		if (connection)
-			g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
-
-		update_routing_and_dns (policy, FALSE);
-		break;
-	case NM_DEVICE_STATE_UNMANAGED:
-	case NM_DEVICE_STATE_UNAVAILABLE:
-	case NM_DEVICE_STATE_DISCONNECTED:
-		update_routing_and_dns (policy, FALSE);
-		schedule_activate_check (policy, device, 0);
-		break;
-	default:
-		break;
-	}
-}
-
-static void
-device_ip4_config_changed (NMDevice *device,
-                           GParamSpec *pspec,
-                           gpointer user_data)
-{
-	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
-}
-
-static void
-wireless_networks_changed (NMDeviceWifi *device, NMAccessPoint *ap, gpointer user_data)
-{
-	schedule_activate_check ((NMPolicy *) user_data, NM_DEVICE (device), 0);
-}
-
-typedef struct {
-	gulong id;
-	NMDevice *device;
-} DeviceSignalID;
-
-static GSList *
-add_device_signal_id (GSList *list, gulong id, NMDevice *device)
-{
-	DeviceSignalID *data;
-
-	data = g_malloc0 (sizeof (DeviceSignalID));
-	if (!data)
-		return list;
-
-	data->id = id;
-	data->device = device;
-	return g_slist_append (list, data);
-}
-
-static void
-device_added (NMManager *manager, NMDevice *device, gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-	gulong id;
-
-	id = g_signal_connect (device, "state-changed",
-	                       G_CALLBACK (device_state_changed),
-	                       policy);
-	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-
-	id = g_signal_connect (device, "notify::" NM_DEVICE_INTERFACE_IP4_CONFIG,
-	                       G_CALLBACK (device_ip4_config_changed),
-	                       policy);
-	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-
-	if (NM_IS_DEVICE_WIFI (device)) {
-		id = g_signal_connect (device, "access-point-added",
-		                       G_CALLBACK (wireless_networks_changed),
-		                       policy);
-		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-
-		id = g_signal_connect (device, "access-point-removed",
-		                       G_CALLBACK (wireless_networks_changed),
-		                       policy);
-		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-	}
-}
-
-static void
-device_removed (NMManager *manager, NMDevice *device, gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-	GSList *iter;
-
-	/* Clear any idle callbacks for this device */
-	iter = policy->pending_activation_checks;
-	while (iter) {
-		ActivateData *data = (ActivateData *) iter->data;
-		GSList *next = g_slist_next (iter);
-
-		if (data->device == device) {
-			g_source_remove (data->id);
-			g_object_unref (data->device);
-			g_free (data);
-			policy->pending_activation_checks = g_slist_delete_link (policy->pending_activation_checks, iter);
-		}
-		iter = next;
-	}
-
-	/* Clear any signal handlers for this device */
-	iter = policy->dev_signal_ids;
-	while (iter) {
-		DeviceSignalID *data = (DeviceSignalID *) iter->data;
-		GSList *next = g_slist_next (iter);
-
-		if (data->device == device) {
-			g_signal_handler_disconnect (data->device, data->id);
-			g_free (data);
-			policy->dev_signal_ids = g_slist_delete_link (policy->dev_signal_ids, iter);
-		}
-		iter = next;
-	}
-
-	update_routing_and_dns (policy, FALSE);
-}
-
-static void
-schedule_activate_all (NMPolicy *policy)
-{
-	GSList *iter, *devices;
-
-	devices = nm_manager_get_devices (policy->manager);
-	for (iter = devices; iter; iter = g_slist_next (iter))
-		schedule_activate_check (policy, NM_DEVICE (iter->data), 0);
-}
-
-static void
-connections_added (NMManager *manager,
-                   NMConnectionScope scope,
-                   gpointer user_data)
-{
-	schedule_activate_all ((NMPolicy *) user_data);
-}
-
-static void
-connection_added (NMManager *manager,
-                  NMConnection *connection,
-                  NMConnectionScope scope,
-                  gpointer user_data)
-{
-	schedule_activate_all ((NMPolicy *) user_data);
-}
-
-static void
-connection_updated (NMManager *manager,
-                    NMConnection *connection,
-                    NMConnectionScope scope,
-                    gpointer user_data)
-{
-	/* Clear the invalid tag on the connection if it got updated. */
-	g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
-
-	schedule_activate_all ((NMPolicy *) user_data);
-}
-
-static void
-connection_removed (NMManager *manager,
-                    NMConnection *connection,
-                    NMConnectionScope scope,
-                    gpointer user_data)
-{
-	NMSettingConnection *s_con;
-	GPtrArray *list;
-	int i;
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	if (!s_con)
-		return;
-
-	list = nm_manager_get_active_connections_by_connection (manager, connection);
-	if (!list)
-		return;
-
-	for (i = 0; i < list->len; i++) {
-		char *path = g_ptr_array_index (list, i);
-		GError *error = NULL;
-
-		if (!nm_manager_deactivate_connection (manager, path, NM_DEVICE_STATE_REASON_CONNECTION_REMOVED, &error)) {
-			nm_warning ("Connection '%s' disappeared, but error deactivating it: (%d) %s",
-			            nm_setting_connection_get_id (s_con), error->code, error->message);
-			g_error_free (error);
-		}
-		g_free (path);
-	}
-	g_ptr_array_free (list, TRUE);
-}
-
-NMPolicy *
-nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager)
-{
-	NMPolicy *policy;
-	static gboolean initialized = FALSE;
-	gulong id;
-	char hostname[HOST_NAME_MAX + 2];
-
-	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
-	g_return_val_if_fail (initialized == FALSE, NULL);
-
-	policy = g_malloc0 (sizeof (NMPolicy));
-	policy->manager = g_object_ref (manager);
-	policy->update_state_id = 0;
-
-	/* Grab hostname on startup and use that if nothing provides one */
-	memset (hostname, 0, sizeof (hostname));
-	if (gethostname (&hostname[0], HOST_NAME_MAX) == 0) {
-		/* only cache it if it's a valid hostname */
-		if (strlen (hostname) && strcmp (hostname, "localhost") && strcmp (hostname, "localhost.localdomain"))
-			policy->orig_hostname = g_strdup (hostname);
-	}
-
-	policy->vpn_manager = g_object_ref (vpn_manager);
-	id = g_signal_connect (policy->vpn_manager, "connection-activated",
-	                       G_CALLBACK (vpn_connection_activated), policy);
-	policy->vpn_activated_id = id;
-	id = g_signal_connect (policy->vpn_manager, "connection-deactivated",
-	                       G_CALLBACK (vpn_connection_deactivated), policy);
-	policy->vpn_deactivated_id = id;
-
-	id = g_signal_connect (manager, "state-changed",
-	                       G_CALLBACK (global_state_changed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "notify::" NM_MANAGER_HOSTNAME,
-	                       G_CALLBACK (hostname_changed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "notify::" NM_MANAGER_SLEEPING,
-	                       G_CALLBACK (sleeping_changed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "device-added",
-	                       G_CALLBACK (device_added), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "device-removed",
-	                       G_CALLBACK (device_removed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	/* Large batch of connections added, manager doesn't want us to
-	 * process each one individually.
-	 */
-	id = g_signal_connect (manager, "connections-added",
-	                       G_CALLBACK (connections_added), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	/* Single connection added */
-	id = g_signal_connect (manager, "connection-added",
-	                       G_CALLBACK (connection_added), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "connection-updated",
-	                       G_CALLBACK (connection_updated), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "connection-removed",
-	                       G_CALLBACK (connection_removed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	return policy;
-}
-
-void
-nm_policy_destroy (NMPolicy *policy)
-{
-	GSList *iter;
-
-	g_return_if_fail (policy != NULL);
-
-	/* Tell any existing hostname lookup thread to die, it'll get cleaned up
-	 * by the lookup thread callback.
-	  */
-	if (policy->lookup) {
-		lookup_thread_die (policy->lookup);
-		policy->lookup = NULL;
-	}
-
-	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
-		ActivateData *data = (ActivateData *) iter->data;
-
-		g_source_remove (data->id);
-		g_object_unref (data->device);
-		g_free (data);
-	}
-	g_slist_free (policy->pending_activation_checks);
-
-	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_activated_id);
-	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_deactivated_id);
-
-	for (iter = policy->signal_ids; iter; iter = g_slist_next (iter))
-		g_signal_handler_disconnect (policy->manager, (gulong) iter->data);
-	g_slist_free (policy->signal_ids);
-
-	for (iter = policy->dev_signal_ids; iter; iter = g_slist_next (iter)) {
-		DeviceSignalID *data = (DeviceSignalID *) iter->data;
-
-		g_signal_handler_disconnect (data->device, data->id);
-		g_free (data);
-	}
-	g_slist_free (policy->dev_signal_ids);
-
-	g_free (policy->orig_hostname);
-
-	g_object_unref (policy->manager);
-	g_free (policy);
-}
-
diff --git a/src/NetworkManagerPolicy.h b/src/NetworkManagerPolicy.h
deleted file mode 100644
index 7d99613..0000000
--- a/src/NetworkManagerPolicy.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2007 - 2008 Novell, Inc.
- */
-
-#ifndef NETWORK_MANAGER_POLICY_H
-#define NETWORK_MANAGER_POLICY_H
-
-#include "NetworkManager.h"
-#include "nm-manager.h"
-#include "nm-vpn-manager.h"
-#include "nm-device.h"
-#include "nm-activation-request.h"
-
-typedef struct NMPolicy NMPolicy;
-
-NMPolicy *nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager);
-void nm_policy_destroy (NMPolicy *policy);
-
-#endif /* NETWORK_MANAGER_POLICY_H */
diff --git a/src/NetworkManagerSystem.c b/src/NetworkManagerSystem.c
deleted file mode 100644
index c514a22..0000000
--- a/src/NetworkManagerSystem.c
+++ /dev/null
@@ -1,1109 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2005 - 2008 Novell, Inc.
- * Copyright (C) 1996 - 1997 Yoichi Hariguchi <yoichi@fore.com>
- * Copyright (C) January, 1998 Sergei Viznyuk <sv@phystech.com>
- */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <netinet/in.h>
-#include <net/route.h>
-#include <arpa/nameser.h>
-#include <arpa/inet.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <syslog.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <resolv.h>
-#include <netdb.h>
-#include <glib.h>
-#include <ctype.h>
-#include <net/if.h>
-
-#include "NetworkManagerSystem.h"
-#include "nm-device.h"
-#include "nm-named-manager.h"
-#include "NetworkManagerUtils.h"
-#include "nm-utils.h"
-#include "nm-netlink.h"
-
-/* Because of a bug in libnl, rtnl.h should be included before route.h */
-#include <netlink/route/rtnl.h>
-
-#include <netlink/route/addr.h>
-#include <netlink/route/route.h>
-#include <netlink/netlink.h>
-#include <netlink/utils.h>
-#include <netlink/route/link.h>
-
-static void nm_system_device_set_priority (const char *iface,
-								   NMIP4Config *config,
-								   int priority);
-
-static gboolean
-ip4_dest_in_same_subnet (NMIP4Config *config, guint32 dest, guint32 dest_prefix)
-{
-	int num;
-	int i;
-
-	num = nm_ip4_config_get_num_addresses (config);
-	for (i = 0; i < num; i++) {
-		NMIP4Address *addr = nm_ip4_config_get_address (config, i);
-		guint32 prefix = nm_ip4_address_get_prefix (addr);
-		guint32 address = nm_ip4_address_get_address (addr);
-
-		if (prefix <= dest_prefix) {
-			guint32 masked_addr = ntohl(address) >> (32 - prefix);
-			guint32 masked_dest = ntohl(dest) >> (32 - prefix);
-
-			if (masked_addr == masked_dest)
-				return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
-static struct rtnl_route *
-create_route (int iface_idx, int mss)
-{
-	struct rtnl_route *route;
-
-	route = rtnl_route_alloc ();
-	if (route) {
-		rtnl_route_set_oif (route, iface_idx);
-
-		if (mss && rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0)
-			nm_warning ("Could not set mss");
-	} else
-		nm_warning ("Could not allocate route");
-
-	return route;
-}
-
-static struct rtnl_route *
-nm_system_device_set_ip4_route (const char *iface, 
-                                guint32 ip4_dest,
-                                guint32 ip4_prefix,
-                                guint32 ip4_gateway,
-                                guint32 metric,
-                                int mss)
-{
-	struct nl_handle *nlh;
-	struct rtnl_route *route;
-	struct nl_addr *dest_addr;
-	struct nl_addr *gw_addr = NULL;
-	int err, iface_idx;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, NULL);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	g_return_val_if_fail (iface_idx >= 0, NULL);
-
-	route = create_route (iface_idx, mss);
-	g_return_val_if_fail (route != NULL, NULL);
-
-	/* Destination */
-	dest_addr = nl_addr_build (AF_INET, &ip4_dest, sizeof (ip4_dest));
-	g_return_val_if_fail (dest_addr != NULL, NULL);
-	nl_addr_set_prefixlen (dest_addr, (int) ip4_prefix);
-
-	rtnl_route_set_dst (route, dest_addr);
-	nl_addr_put (dest_addr);
-
-	/* Gateway */
-	if (ip4_gateway) {
-		gw_addr = nl_addr_build (AF_INET, &ip4_gateway, sizeof (ip4_gateway));
-		if (gw_addr) {
-			rtnl_route_set_gateway (route, gw_addr);
-			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
-		} else {
-			nm_warning ("Invalid gateway");
-			rtnl_route_put (route);
-			return NULL;
-		}
-	}
-
-	/* Metric */
-	if (metric)
-		rtnl_route_set_prio (route, metric);
-
-	/* Add the route */
-	err = rtnl_route_add (nlh, route, 0);
-	if (err == -ESRCH && ip4_gateway) {
-		/* Gateway might be over a bridge; try adding a route to gateway first */
-		struct rtnl_route *route2;
-
-		route2 = create_route (iface_idx, mss);
-		if (route2) {
-			/* Add route to gateway over bridge */
-			rtnl_route_set_dst (route2, gw_addr);
-			err = rtnl_route_add (nlh, route2, 0);
-			if (!err) {
-				/* Try adding the route again */
-				err = rtnl_route_add (nlh, route, 0);
-				if (err)
-					rtnl_route_del (nlh, route2, 0);
-			}
-			rtnl_route_put (route2);
-		}
-	}
-
-	if (gw_addr)
-		nl_addr_put (gw_addr);
-
-	if (err) {
-		nm_warning ("Failed to set IPv4 route on '%s': %s", iface, nl_geterror ());
-		rtnl_route_put (route);
-		route = NULL;
-	}
-
-	return route;
-}
-
-static gboolean
-sync_addresses (const char *iface, int ifindex, int family,
-				struct rtnl_addr **addrs, int num_addrs)
-{
-	struct nl_handle *nlh;
-	struct nl_cache *addr_cache;
-	struct rtnl_addr *filter_addr, *match_addr;
-	struct nl_object *match;
-	int i, err;
-
-	nlh = nm_netlink_get_default_handle ();
-	if (!nlh)
-		return FALSE;
-
-	addr_cache = rtnl_addr_alloc_cache (nlh);
-	if (!addr_cache)
-		return FALSE;
-
-	filter_addr = rtnl_addr_alloc ();
-	if (!filter_addr) {
-		nl_cache_free (addr_cache);
-		return FALSE;
-	}
-	rtnl_addr_set_ifindex (filter_addr, ifindex);
-	if (family)
-		rtnl_addr_set_family (filter_addr, family);
-
-	/* Walk through the cache, comparing the addresses already on
-	 * the interface to the addresses in addrs.
-	 */
-	for (match = nl_cache_get_first (addr_cache); match; match = nl_cache_get_next (match)) {
-		match_addr = (struct rtnl_addr *)match;
-
-		/* Skip addresses not on our interface */
-		if (!nl_object_match_filter (match, (struct nl_object *)filter_addr))
-			continue;
-
-		if (addrs) {
-			for (i = 0; i < num_addrs; i++) {
-				if (addrs[i] &&
-					nl_object_identical (match, (struct nl_object *)addrs[i]))
-					break;
-			}
-
-			if (addrs[i]) {
-				/* match == addrs[i], so remove it from addrs so we don't
-				 * try to add it to the interface again below.
-				 */
-				rtnl_addr_put (addrs[i]);
-				addrs[i] = NULL;
-				continue;
-			}
-		}
-
-		/* Don't delete IPv6 link-local addresses; they don't belong to NM */
-		if (rtnl_addr_get_family (match_addr) == AF_INET6 &&
-			rtnl_addr_get_scope (match_addr) == RT_SCOPE_LINK) {
-			continue;
-		}
-
-		/* Otherwise, match_addr should be removed from the interface. */
-		err = rtnl_addr_delete (nlh, match_addr, 0);
-		if (err < 0) {
-			nm_warning ("(%s) error %d returned from rtnl_addr_delete(): %s",
-						iface, err, nl_geterror ());
-		}
-	}
-
-	rtnl_addr_put (filter_addr);
-	nl_cache_free (addr_cache);
-
-	/* Now add the remaining new addresses */
-	for (i = 0; i < num_addrs; i++) {
-		if (!addrs[i])
-			continue;
-
-		err = rtnl_addr_add (nlh, addrs[i], 0);
-		if (err < 0) {
-			nm_warning ("(%s) error %d returned from rtnl_addr_add():\n%s",
-						iface, err, nl_geterror ());
-		}
-
-		rtnl_addr_put (addrs[i]);
-	}
-	g_free (addrs);
-
-	return TRUE;
-}
-
-static gboolean
-add_ip4_addresses (NMIP4Config *config, const char *iface)
-{
-	int num_addrs, i, iface_idx;
-	guint32 flags = 0;
-	gboolean did_gw = FALSE;
-	struct rtnl_addr **addrs;
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-
-	num_addrs = nm_ip4_config_get_num_addresses (config);
-	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
-
-	for (i = 0; i < num_addrs; i++) {
-		NMIP4Address *addr;
-
-		addr = nm_ip4_config_get_address (config, i);
-		g_assert (addr);
-
-		flags = NM_RTNL_ADDR_DEFAULT;
-		if (nm_ip4_address_get_gateway (addr) && !did_gw) {
-			if (nm_ip4_config_get_ptp_address (config))
-				flags |= NM_RTNL_ADDR_PTP_ADDR;
-			did_gw = TRUE;
-		}
-
-		addrs[i] = nm_ip4_config_to_rtnl_addr (config, i, flags);
-		if (!addrs[i]) {
-			nm_warning ("couldn't create rtnl address!\n");
-			continue;
-		}
-		rtnl_addr_set_ifindex (addrs[i], iface_idx);
-	}
-
-	return sync_addresses (iface, iface_idx, AF_INET, addrs, num_addrs);
-}
-
-struct rtnl_route *
-nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config)
-{
-	NMIP4Config *parent_config;
-	guint32 parent_gw = 0, parent_prefix = 0, vpn_gw = 0, i;
-	NMIP4Address *tmp;
-	struct rtnl_route *route = NULL;
-
-	g_return_val_if_fail (NM_IS_DEVICE (parent_device), NULL);
-
-	/* Set up a route to the VPN gateway's public IP address through the default
-	 * network device if the VPN gateway is on a different subnet.
-	 */
-
-	parent_config = nm_device_get_ip4_config (parent_device);
-	g_return_val_if_fail (parent_config != NULL, NULL);
-
-	for (i = 0; i < nm_ip4_config_get_num_addresses (parent_config); i++) {
-		tmp = nm_ip4_config_get_address (parent_config, i);
-		if (nm_ip4_address_get_gateway (tmp)) {
-			parent_gw = nm_ip4_address_get_gateway (tmp);
-			parent_prefix = nm_ip4_address_get_prefix (tmp);
-			break;
-		}
-	}
-
-	for (i = 0; i < nm_ip4_config_get_num_addresses (vpn_config); i++) {
-		tmp = nm_ip4_config_get_address (vpn_config, i);
-		if (nm_ip4_address_get_gateway (tmp)) {
-			vpn_gw = nm_ip4_address_get_gateway (tmp);
-			break;
-		}
-	}
-
-	if (!parent_gw || !vpn_gw)
-		return NULL;
-
-	/* If the VPN gateway is in the same subnet as one of the parent device's
-	 * IP addresses, don't add the host route to it, but a route through the
-	 * parent device.
-	 */
-	if (ip4_dest_in_same_subnet (parent_config, vpn_gw, parent_prefix)) {
-		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
-		                                        vpn_gw, 32, 0, 0, nm_ip4_config_get_mss (parent_config));
-	} else {
-		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
-		                                        vpn_gw, 32, parent_gw, 0, nm_ip4_config_get_mss (parent_config));
-	}
-
-	return route;
-}
-
-/*
- * nm_system_apply_ip4_config
- *
- * Set IPv4 configuration of the device from an NMIP4Config object.
- *
- */
-gboolean
-nm_system_apply_ip4_config (const char *iface,
-                            NMIP4Config *config,
-                            int priority,
-                            NMIP4ConfigCompareFlags flags)
-{
-	int i;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (config != NULL, FALSE);
-
-	if (flags & NM_IP4_COMPARE_FLAG_ADDRESSES) {
-		if (!add_ip4_addresses (config, iface))
-			return FALSE;
-		sleep (1);
-	}
-
-	if (flags & NM_IP4_COMPARE_FLAG_ROUTES) {
-		for (i = 0; i < nm_ip4_config_get_num_routes (config); i++) {
-			NMIP4Route *route = nm_ip4_config_get_route (config, i);
-			struct rtnl_route *tmp;
-
-			/* Don't add the route if it's more specific than one of the subnets
-			 * the device already has an IP address on.
-			 */
-			if (ip4_dest_in_same_subnet (config,
-			                             nm_ip4_route_get_dest (route),
-			                             nm_ip4_route_get_prefix (route)))
-				continue;
-
-			/* Don't add the route if it doesn't have a gateway and the connection
-			 * is never supposed to be the default connection.
-			 */
-			if (   nm_ip4_config_get_never_default (config)
-			    && nm_ip4_route_get_dest (route) == 0)
-				continue;
-
-			tmp = nm_system_device_set_ip4_route (iface,
-			                                      nm_ip4_route_get_dest (route),
-			                                      nm_ip4_route_get_prefix (route),
-			                                      nm_ip4_route_get_next_hop (route),
-			                                      nm_ip4_route_get_metric (route),
-			                                      nm_ip4_config_get_mss (config));
-			rtnl_route_put (tmp);
-		}
-	}
-
-	if (flags & NM_IP4_COMPARE_FLAG_MTU) {
-		if (nm_ip4_config_get_mtu (config))
-			nm_system_device_set_mtu (iface, nm_ip4_config_get_mtu (config));
-	}
-
-	if (priority > 0)
-		nm_system_device_set_priority (iface, config, priority);
-
-	return TRUE;
-}
-
-static struct rtnl_route *
-nm_system_device_set_ip6_route (const char *iface,
-                                const struct in6_addr *ip6_dest,
-                                guint32 ip6_prefix,
-                                const struct in6_addr *ip6_gateway,
-                                guint32 metric,
-                                int mss)
-{
-	struct nl_handle *nlh;
-	struct rtnl_route *route;
-	struct nl_addr *dest_addr;
-	struct nl_addr *gw_addr = NULL;
-	int err, iface_idx;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, NULL);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	g_return_val_if_fail (iface_idx >= 0, NULL);
-
-	route = create_route (iface_idx, mss);
-	g_return_val_if_fail (route != NULL, NULL);
-
-	/* Destination */
-	dest_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_dest, sizeof (*ip6_dest));
-	g_return_val_if_fail (dest_addr != NULL, NULL);
-	nl_addr_set_prefixlen (dest_addr, (int) ip6_prefix);
-
-	rtnl_route_set_dst (route, dest_addr);
-	nl_addr_put (dest_addr);
-
-	/* Gateway */
-	if (ip6_gateway && !IN6_IS_ADDR_UNSPECIFIED (ip6_gateway)) {
-		gw_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_gateway, sizeof (*ip6_gateway));
-		if (gw_addr) {
-			rtnl_route_set_gateway (route, gw_addr);
-			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
-		} else {
-			nm_warning ("Invalid gateway");
-			rtnl_route_put (route);
-			return NULL;
-		}
-	}
-
-	/* Metric */
-	if (metric)
-		rtnl_route_set_prio (route, metric);
-
-	/* Add the route */
-	err = rtnl_route_add (nlh, route, 0);
-	if (err == -ESRCH && ip6_gateway) {
-		/* Gateway might be over a bridge; try adding a route to gateway first */
-		struct rtnl_route *route2;
-
-		route2 = create_route (iface_idx, mss);
-		if (route2) {
-			/* Add route to gateway over bridge */
-			rtnl_route_set_dst (route2, gw_addr);
-			err = rtnl_route_add (nlh, route2, 0);
-			if (!err) {
-				/* Try adding the route again */
-				err = rtnl_route_add (nlh, route, 0);
-				if (err)
-					rtnl_route_del (nlh, route2, 0);
-			}
-			rtnl_route_put (route2);
-		}
-	}
-
-	if (gw_addr)
-		nl_addr_put (gw_addr);
-
-	if (err) {
-		nm_warning ("Failed to set IPv6 route on '%s': %s", iface, nl_geterror ());
-		rtnl_route_put (route);
-		route = NULL;
-	}
-
-	return route;
-}
-
-static gboolean
-add_ip6_addresses (NMIP6Config *config, const char *iface)
-{
-	int num_addrs, i, iface_idx;
-	struct rtnl_addr **addrs;
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-
-	num_addrs = nm_ip6_config_get_num_addresses (config);
-	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
-
-	for (i = 0; i < num_addrs; i++) {
-		NMIP6Address *addr;
-
-		addr = nm_ip6_config_get_address (config, i);
-		g_assert (addr);
-
-		addrs[i] = nm_ip6_config_to_rtnl_addr (config, i, NM_RTNL_ADDR_DEFAULT);
-		if (!addrs[i]) {
-			nm_warning ("couldn't create rtnl address!\n");
-			continue;
-		}
-		rtnl_addr_set_ifindex (addrs[i], iface_idx);
-	}
-
-	return sync_addresses (iface, iface_idx, AF_INET6, addrs, num_addrs);
-}
-
-/*
- * nm_system_apply_ip6_config
- *
- * Set IPv6 configuration of the device from an NMIP6Config object.
- *
- */
-gboolean
-nm_system_apply_ip6_config (const char *iface,
-                            NMIP6Config *config,
-                            int priority,
-                            NMIP6ConfigCompareFlags flags)
-{
-	int i;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (config != NULL, FALSE);
-
-	if (flags & NM_IP6_COMPARE_FLAG_ADDRESSES) {
-		if (!add_ip6_addresses (config, iface))
-			return FALSE;
-		sleep (1); // FIXME?
-	}
-
-	if (flags & NM_IP6_COMPARE_FLAG_ROUTES) {
-		for (i = 0; i < nm_ip6_config_get_num_routes (config); i++) {
-			NMIP6Route *route = nm_ip6_config_get_route (config, i);
-			struct rtnl_route *tmp;
-
-			/* Don't add the route if it doesn't have a gateway and the connection
-			 * is never supposed to be the default connection.
-			 */
-			if (   nm_ip6_config_get_never_default (config)
-			    && IN6_IS_ADDR_UNSPECIFIED(nm_ip6_route_get_dest (route)))
-				continue;
-
-			tmp = nm_system_device_set_ip6_route (iface,
-			                                      nm_ip6_route_get_dest (route),
-			                                      nm_ip6_route_get_prefix (route),
-			                                      nm_ip6_route_get_next_hop (route),
-			                                      nm_ip6_route_get_metric (route),
-			                                      nm_ip6_config_get_mss (config));
-			rtnl_route_put (tmp);
-		}
-	}
-
-// FIXME
-//	if (priority > 0)
-//		nm_system_device_set_priority (iface, config, priority);
-
-	return TRUE;
-}
-
-/*
- * nm_system_device_set_up_down
- *
- * Mark the device as up or down.
- *
- */
-gboolean
-nm_system_device_set_up_down (NMDevice *dev,
-                              gboolean up,
-                              gboolean *no_firmware)
-{
-	g_return_val_if_fail (dev != NULL, FALSE);
-
-	return nm_system_device_set_up_down_with_iface (nm_device_get_ip_iface (dev), up, no_firmware);
-}
-
-gboolean
-nm_system_device_set_up_down_with_iface (const char *iface,
-                                         gboolean up,
-                                         gboolean *no_firmware)
-{
-	struct rtnl_link *request = NULL, *old = NULL;
-	struct nl_handle *nlh;
-	gboolean success = FALSE;
-	guint32 idx;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	if (no_firmware)
-		g_return_val_if_fail (*no_firmware == FALSE, FALSE);
-
-	if (!(request = rtnl_link_alloc ()))
-		goto out;
-
-	if (up)
-		rtnl_link_set_flags (request, IFF_UP);
-	else
-		rtnl_link_unset_flags (request, IFF_UP);
-
-	idx = nm_netlink_iface_to_index (iface);
-	old = nm_netlink_index_to_rtnl_link (idx);
-	if (old) {
-		nlh = nm_netlink_get_default_handle ();
-		if (nlh) {
-			if (rtnl_link_change (nlh, old, request, 0) == 0)
-				success = TRUE;
-			else if ((nl_get_errno () == ENOENT) && no_firmware && up)
-				*no_firmware = TRUE;
-		}
-	}
-
-	rtnl_link_put (old);
-	rtnl_link_put (request);
-
-out:
-	return success;
-}
-
-gboolean
-nm_system_device_is_up (NMDevice *device)
-{
-	g_return_val_if_fail (device != NULL, FALSE);
-
-	return nm_system_device_is_up_with_iface (nm_device_get_ip_iface (device));
-}
-
-gboolean
-nm_system_device_is_up_with_iface (const char *iface)
-{
-	struct ifreq ifr;
-	int fd;
-	gboolean up = FALSE;
-
-	fd = socket (PF_INET, SOCK_DGRAM, 0);
-	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
-		return FALSE;
-	}
-
-	/* Get device's flags */
-	memset (&ifr, 0, sizeof (ifr));
-	strncpy (ifr.ifr_name, iface, IFNAMSIZ);
-	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0) {
-		if (errno != ENODEV) {
-			nm_warning ("%s: could not get flags for device %s.  errno = %d", 
-			            __func__, iface, errno);
-		}
-	} else {
-		up = !!(ifr.ifr_flags & IFF_UP);
-	}
-	close (fd);
-
-	return up;
-}
-
-gboolean
-nm_system_device_set_mtu (const char *iface, guint32 mtu)
-{
-	struct rtnl_link *old;
-	struct rtnl_link *new;
-	gboolean success = FALSE;
-	struct nl_handle *nlh;
-	int iface_idx;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (mtu > 0, FALSE);
-
-	new = rtnl_link_alloc ();
-	if (!new)
-		return FALSE;
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	old = nm_netlink_index_to_rtnl_link (iface_idx);
-	if (old) {
-		rtnl_link_set_mtu (new, mtu);
-		nlh = nm_netlink_get_default_handle ();
-		if (nlh) {
-			rtnl_link_change (nlh, old, new, 0);
-			success = TRUE;
-		}
-		rtnl_link_put (old);
-	}
-
-	rtnl_link_put (new);
-	return success;
-}
-
-static struct rtnl_route *
-add_ip4_route_to_gateway (const char *iface, guint32 gw, guint32 mss)
-{
-	struct nl_handle *nlh;
-	struct rtnl_route *route = NULL;
-	struct nl_addr *gw_addr = NULL;
-	int iface_idx, err;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, NULL);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx < 0)
-		return NULL;
-
-	/* Gateway might be over a bridge; try adding a route to gateway first */
-	route = rtnl_route_alloc ();
-	if (route == NULL)
-		return NULL;
-
-	rtnl_route_set_family (route, AF_INET);
-	rtnl_route_set_table (route, RT_TABLE_MAIN);
-	rtnl_route_set_oif (route, iface_idx);
-	rtnl_route_set_scope (route, RT_SCOPE_LINK);
-
-	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
-	if (!gw_addr)
-		goto error;
-	nl_addr_set_prefixlen (gw_addr, 32);
-	rtnl_route_set_dst (route, gw_addr);
-	nl_addr_put (gw_addr);
-
-	if (mss) {
-		if (rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0)
-			goto error;
-	}
-
-	/* Add direct route to the gateway */
-	err = rtnl_route_add (nlh, route, 0);
-	if (err) {
-		nm_warning ("(%s): failed to add IPv4 route to gateway (%d)", iface, err);
-		goto error;
-	}
-
-	return route;
-
-error:
-	rtnl_route_put (route);
-	return NULL;
-}
-
-static int
-replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
-{
-	struct rtnl_route *route = NULL;
-	struct nl_handle *nlh;
-	struct nl_addr *dst_addr = NULL;
-	guint32 dst = 0;
-	struct nl_addr *gw_addr = NULL;
-	int iface_idx, err = -1;
-
-	g_return_val_if_fail (iface != NULL, -ENODEV);
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, -ENOMEM);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx < 0)
-		return -ENODEV;
-
-	route = rtnl_route_alloc();
-	g_return_val_if_fail (route != NULL, -ENOMEM);
-
-	rtnl_route_set_family (route, AF_INET);
-	rtnl_route_set_table (route, RT_TABLE_MAIN);
-	rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
-	rtnl_route_set_oif (route, iface_idx);
-
-	/* Build up the destination address */
-	dst_addr = nl_addr_build (AF_INET, &dst, sizeof (dst));
-	if (!dst_addr) {
-		err = -ENOMEM;
-		goto out;
-	}
-	nl_addr_set_prefixlen (dst_addr, 0);
-	rtnl_route_set_dst (route, dst_addr);
-
-	/* Build up the gateway address */
-	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
-	if (!gw_addr) {
-		err = -ENOMEM;
-		goto out;
-	}
-	nl_addr_set_prefixlen (gw_addr, 0);
-	rtnl_route_set_gateway (route, gw_addr);
-
-	if (mss > 0) {
-		err = rtnl_route_set_metric (route, RTAX_ADVMSS, mss);
-		if (err < 0)
-			goto out;
-	}
-
-	/* Add the new default route */
-	err = rtnl_route_add (nlh, route, NLM_F_REPLACE);
-
-out:
-	if (dst_addr)
-		nl_addr_put (dst_addr);
-	if (gw_addr)
-		nl_addr_put (gw_addr);
-	rtnl_route_put (route);
-	return err;
-}
-
-/*
- * nm_system_replace_default_ip4_route_vpn
- *
- * Replace default IPv4 route with one via the current device
- *
- */
-gboolean
-nm_system_replace_default_ip4_route_vpn (const char *iface,
-                                         guint32 ext_gw,
-                                         guint32 int_gw,
-                                         guint32 mss,
-                                         const char *parent_iface,
-                                         guint32 parent_mss)
-{
-	struct rtnl_route *gw_route = NULL;
-	struct nl_handle *nlh;
-	gboolean success = FALSE;
-	int err;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, FALSE);
-
-	err = replace_default_ip4_route (iface, int_gw, mss);
-	if (err == 0) {
-		return TRUE;
-	} else if (err != -ESRCH) {
-		nm_warning ("(%s): failed to set IPv4 default route: %d",
-		            iface, err);
-		return FALSE;
-	}
-
-	/* Try adding a direct route to the gateway first */
-	gw_route = add_ip4_route_to_gateway (parent_iface, ext_gw, parent_mss);
-	if (!gw_route)
-		return FALSE;
-
-	/* Try adding the original route again */
-	err = replace_default_ip4_route (iface, int_gw, mss);
-	if (err != 0) {
-		rtnl_route_del (nlh, gw_route, 0);
-		nm_warning ("(%s): failed to set IPv4 default route (pass #2): %d",
-		            iface, err);
-	} else
-		success = TRUE;
-
-	rtnl_route_put (gw_route);
-	return success;
-}
-
-/*
- * nm_system_replace_default_ip4_route
- *
- * Replace default IPv4 route with one via the current device
- *
- */
-gboolean
-nm_system_replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
-{
-	struct rtnl_route *gw_route = NULL;
-	struct nl_handle *nlh;
-	gboolean success = FALSE;
-	int err;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, FALSE);
-
-	err = replace_default_ip4_route (iface, gw, mss);
-	if (err == 0) {
-		return TRUE;
-	} else if (err != -ESRCH) {
-		nm_warning ("(%s): failed to set IPv4 default route: %d",
-		            iface, err);
-		return FALSE;
-	}
-
-	/* Try adding a direct route to the gateway first */
-	gw_route = add_ip4_route_to_gateway (iface, gw, mss);
-	if (!gw_route)
-		return FALSE;
-
-	/* Try adding the original route again */
-	err = replace_default_ip4_route (iface, gw, mss);
-	if (err != 0) {
-		rtnl_route_del (nlh, gw_route, 0);
-		nm_warning ("(%s): failed to set IPv4 default route (pass #2): %d",
-		            iface, err);
-	} else
-		success = TRUE;
-
-	rtnl_route_put (gw_route);
-	return success;
-}
-
-static void flush_addresses (const char *iface, gboolean ipv4_only)
-{
-	int iface_idx;
-
-	g_return_if_fail (iface != NULL);
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx >= 0)
-		sync_addresses (iface, iface_idx, ipv4_only ? AF_INET : 0, NULL, 0);
-}
-
-/*
- * nm_system_device_flush_addresses
- *
- * Flush all network addresses associated with a network device
- *
- */
-void nm_system_device_flush_addresses (NMDevice *dev)
-{
-	g_return_if_fail (dev != NULL);
-
-	flush_addresses (nm_device_get_ip_iface (dev),
-					 nm_device_get_ip6_config (dev) == NULL);
-}
-
-
-/*
- * nm_system_device_flush_addresses_with_iface
- *
- * Flush all network addresses associated with a network device
- *
- */
-void nm_system_device_flush_addresses_with_iface (const char *iface)
-{
-	flush_addresses (iface, FALSE);
-}
-
-
-static void
-foreach_route (void (*callback)(struct nl_object *, gpointer),
-			gpointer user_data)
-{
-	struct nl_handle *nlh;
-	struct nl_cache *route_cache;
-
-	nlh = nm_netlink_get_default_handle ();
-	route_cache = rtnl_route_alloc_cache (nlh);
-	nl_cache_mngt_provide (route_cache);
-	nl_cache_foreach (route_cache, callback, user_data);
-	nl_cache_free (route_cache);
-}
-
-
-typedef struct {
-	const char *iface;
-	int iface_idx;
-	int family;
-} RouteCheckData;
-
-static void
-check_one_route (struct nl_object *object, void *user_data)
-{
-	RouteCheckData *data = (RouteCheckData *) user_data;
-	struct rtnl_route *route = (struct rtnl_route *) object;
-	int err;
-
-	/* Delete all routes from this interface */
-	if (rtnl_route_get_oif (route) != data->iface_idx)
-		return;
-	if (data->family && rtnl_route_get_family (route) != data->family)
-		return;
-
-	err = rtnl_route_del (nm_netlink_get_default_handle (), route, 0);
-	if (err < 0) {
-		nm_warning ("(%s) error %d returned from rtnl_route_del(): %s",
-		            data->iface, err, nl_geterror());
-	}
-}
-
-static void flush_routes (const char *iface, gboolean ipv4_only)
-{
-	int iface_idx;
-	RouteCheckData check_data;
-
-	g_return_if_fail (iface != NULL);
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx >= 0) {
-		memset (&check_data, 0, sizeof (check_data));
-		check_data.iface = iface;
-		check_data.iface_idx = iface_idx;
-		check_data.family = ipv4_only ? AF_INET : 0;
-
-		foreach_route (check_one_route, &check_data);
-	}
-}
-
-/*
- * nm_system_device_flush_routes
- *
- * Flush all network addresses associated with a network device
- *
- */
-void nm_system_device_flush_routes (NMDevice *dev)
-{
-	g_return_if_fail (dev != NULL);
-
-	flush_routes (nm_device_get_ip_iface (dev),
-				  nm_device_get_ip6_config (dev) == NULL);
-}
-
-/*
- * nm_system_device_flush_routes_with_iface
- *
- * Flush all routes associated with a network device
- *
- */
-void nm_system_device_flush_routes_with_iface (const char *iface)
-{
-	flush_routes (iface, FALSE);
-}
-
-typedef struct {
-	struct rtnl_route *route;
-	NMIP4Config *config;
-	int iface;
-} SetPriorityInfo;
-
-static void
-find_route (struct nl_object *object, gpointer user_data)
-{
-	struct rtnl_route *route = (struct rtnl_route *) object;
-	SetPriorityInfo *info = (SetPriorityInfo *) user_data;
-	struct nl_addr *dst;
-	struct in_addr *dst_addr;
-	int num;
-	int i;
-
-	if (info->route ||
-	    rtnl_route_get_oif (route) != info->iface ||
-	    rtnl_route_get_scope (route) != RT_SCOPE_LINK)
-		return;
-
-	dst = rtnl_route_get_dst (route);
-	if (nl_addr_get_family (dst) != AF_INET)
-		return;
-
-	dst_addr = nl_addr_get_binary_addr (dst);
-	num = nm_ip4_config_get_num_addresses (info->config);
-	for (i = 0; i < num; i++) {
-		NMIP4Address *addr = nm_ip4_config_get_address (info->config, i);
-		guint32 prefix = nm_ip4_address_get_prefix (addr);
-		guint32 address = nm_ip4_address_get_address (addr);
-
-		if (prefix == nl_addr_get_prefixlen (dst) &&
-		    (address & nm_utils_ip4_prefix_to_netmask (prefix)) == dst_addr->s_addr) {
-
-			/* Ref the route so it sticks around after the cache is cleared */
-			rtnl_route_get (route);
-			info->route = route;
-			break;
-		}
-	}
-}
-
-static void
-nm_system_device_set_priority (const char *iface,
-						 NMIP4Config *config,
-						 int priority)
-{
-	SetPriorityInfo info;
-
-	info.route = NULL;
-	info.config = config;
-	info.iface = nm_netlink_iface_to_index (iface);
-	g_return_if_fail (info.iface >= 0);
-
-	foreach_route (find_route, &info);
-	if (info.route) {
-		struct nl_handle *nlh;
-
-		nlh = nm_netlink_get_default_handle ();
-		rtnl_route_del (nlh, info.route, 0);
-
-		rtnl_route_set_prio (info.route, priority);
-		rtnl_route_add (nlh, info.route, 0);
-		rtnl_route_put (info.route);
-	}
-}
diff --git a/src/NetworkManagerSystem.h b/src/NetworkManagerSystem.h
deleted file mode 100644
index f2c2693..0000000
--- a/src/NetworkManagerSystem.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2005 - 2008 Novell, Inc.
- */
-
-#ifndef NETWORK_MANAGER_SYSTEM_H
-#define NETWORK_MANAGER_SYSTEM_H
-
-#include <netlink/route/rtnl.h>
-#include <netlink/route/route.h>
-
-#include <glib.h>
-#include "nm-device.h"
-#include "nm-ip4-config.h"
-
-/* Prototypes for system/distribution dependent functions,
- * implemented in the backend files in backends/ directory
- */
-
-void			nm_system_device_flush_routes				(NMDevice *dev);
-void			nm_system_device_flush_routes_with_iface	(const char *iface);
-
-gboolean		nm_system_replace_default_ip4_route   (const char *iface,
-                                                       guint32 gw,
-                                                       guint32 mss);
-
-gboolean		nm_system_replace_default_ip4_route_vpn (const char *iface,
-                                                         guint32 ext_gw,
-                                                         guint32 int_gw,
-                                                         guint32 mss,
-                                                         const char *parent_iface,
-                                                         guint32 parent_mss);
-
-struct rtnl_route *nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config);
-
-
-void			nm_system_device_flush_addresses			(NMDevice *dev);
-void			nm_system_device_flush_addresses_with_iface	(const char *iface);
-
-void			nm_system_enable_loopback				(void);
-void			nm_system_update_dns					(void);
-
-gboolean		nm_system_apply_ip4_config              (const char *iface,
-                                                         NMIP4Config *config,
-                                                         int priority,
-                                                         NMIP4ConfigCompareFlags flags);
-
-gboolean		nm_system_apply_ip6_config              (const char *iface,
-                                                         NMIP6Config *config,
-                                                         int priority,
-                                                         NMIP6ConfigCompareFlags flags);
-
-gboolean		nm_system_device_set_up_down				(NMDevice *dev,
-                                                             gboolean up,
-                                                             gboolean *no_firmware);
-gboolean		nm_system_device_set_up_down_with_iface		(const char *iface,
-                                                             gboolean up,
-                                                             gboolean *no_firmware);
-
-gboolean        nm_system_device_is_up (NMDevice *device);
-gboolean        nm_system_device_is_up_with_iface (const char *iface);
-
-gboolean		nm_system_device_set_mtu (const char *iface, guint32 mtu);
-
-#endif
diff --git a/src/NetworkManagerUtils.c b/src/NetworkManagerUtils.c
index 4934d46..4bd57d9 100644
--- a/src/NetworkManagerUtils.c
+++ b/src/NetworkManagerUtils.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
  * Copyright (C) 2005 - 2008 Novell, Inc.
  */
 
@@ -28,6 +28,7 @@
 
 #include "NetworkManagerUtils.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-device.h"
 #include "nm-device-wifi.h"
 #include "nm-device-ethernet.h"
@@ -85,13 +86,13 @@ nm_spawn_process (const char *args)
 	g_return_val_if_fail (args != NULL, -1);
 
 	if (!g_shell_parse_argv (args, &num_args, &argv, &error)) {
-		nm_warning ("could not parse arguments for '%s': %s", args, error->message);
+		nm_log_warn (LOGD_CORE, "could not parse arguments for '%s': %s", args, error->message);
 		g_error_free (error);
 		return -1;
 	}
 
 	if (!g_spawn_sync ("/", argv, NULL, 0, NULL, NULL, NULL, NULL, &status, &error)) {
-		nm_warning ("could not spawn process '%s': %s", args, error->message);
+		nm_log_warn (LOGD_CORE, "could not spawn process '%s': %s", args, error->message);
 		g_error_free (error);
 	}
 
@@ -394,7 +395,7 @@ nm_utils_call_dispatcher (const char *action,
 	                                   NM_DISPATCHER_DBUS_PATH,
 	                                   NM_DISPATCHER_DBUS_IFACE);
 	if (!proxy) {
-		nm_warning ("Error: could not get dispatcher proxy!");
+		nm_log_err (LOGD_CORE, "could not get dispatcher proxy!");
 		g_object_unref (dbus_mgr);
 		return;
 	}
@@ -553,6 +554,20 @@ value_hash_add_uint (GHashTable *hash,
 	value_hash_add (hash, key, value);
 }
 
+void
+value_hash_add_bool (GHashTable *hash,
+					 const char *key,
+					 gboolean val)
+{
+	GValue *value;
+
+	value = g_slice_new0 (GValue);
+	g_value_init (value, G_TYPE_BOOLEAN);
+	g_value_set_boolean (value, val);
+
+	value_hash_add (hash, key, value);
+}
+
 gboolean
 nm_utils_do_sysctl (const char *path, const char *value)
 {
diff --git a/src/NetworkManagerUtils.h b/src/NetworkManagerUtils.h
index 05f3b83..fa8b598 100644
--- a/src/NetworkManagerUtils.h
+++ b/src/NetworkManagerUtils.h
@@ -67,6 +67,10 @@ void        value_hash_add_uint        (GHashTable *hash,
 										const char *key,
 										guint32 val);
 
+void        value_hash_add_bool        (GHashTable *hash,
+					                    const char *key,
+					                    gboolean val);
+
 gboolean nm_utils_do_sysctl (const char *path, const char *value);
 
 #endif /* NETWORK_MANAGER_UTILS_H */
diff --git a/src/backends/Makefile.am b/src/backends/Makefile.am
index 0e037c4..c3485e5 100644
--- a/src/backends/Makefile.am
+++ b/src/backends/Makefile.am
@@ -1,9 +1,11 @@
-INCLUDES = -I${top_srcdir}				\
-		 -I${top_srcdir}/include			\
-		 -I${top_srcdir}/src			\
-		 -I${top_srcdir}/src/vpn-manager	\
-		 -I${top_srcdir}/src/named-manager	\
-		 -I${top_srcdir}/libnm-util
+INCLUDES = \
+	-I${top_srcdir} \
+	-I${top_srcdir}/src/logging \
+	-I${top_srcdir}/include \
+	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/vpn-manager \
+	-I${top_srcdir}/src/named-manager \
+	-I${top_srcdir}/libnm-util
 
 noinst_LTLIBRARIES = libnmbackend.la
 
@@ -53,7 +55,11 @@ if TARGET_PARDUS
 libnmbackend_la_SOURCES += NetworkManagerPardus.c
 endif
 
-libnmbackend_la_LIBADD += $(DBUS_LIBS) $(GLIB_LIBS)
+libnmbackend_la_LIBADD += \
+	$(top_builddir)/src/logging/libnm-logging.la \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS)
+
 libnmbackend_la_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
 	$(GLIB_CFLAGS) \
diff --git a/src/backends/NetworkManagerArch.c b/src/backends/NetworkManagerArch.c
index 3ed5677..c70e245 100644
--- a/src/backends/NetworkManagerArch.c
+++ b/src/backends/NetworkManagerArch.c
@@ -40,7 +40,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 /*
diff --git a/src/backends/NetworkManagerDebian.c b/src/backends/NetworkManagerDebian.c
index 2f6abd1..ef9475a 100644
--- a/src/backends/NetworkManagerDebian.c
+++ b/src/backends/NetworkManagerDebian.c
@@ -32,9 +32,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -57,7 +57,7 @@ void nm_system_enable_loopback (void)
 void nm_system_update_dns (void)
 {
 	if (g_file_test ("/usr/sbin/nscd", G_FILE_TEST_IS_EXECUTABLE)) {
-		nm_info ("Clearing nscd hosts cache.");
+		nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
 		nm_spawn_process ("/usr/sbin/nscd -i hosts");
 	}
 }
diff --git a/src/backends/NetworkManagerFrugalware.c b/src/backends/NetworkManagerFrugalware.c
index 492bf19..dfe6292 100644
--- a/src/backends/NetworkManagerFrugalware.c
+++ b/src/backends/NetworkManagerFrugalware.c
@@ -27,7 +27,7 @@
 #include <string.h>
 #include <stdlib.h>
 
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 /* Provided by the frugalwareutils package on Frugalware */
 #include <libfwnetconfig.h> 
diff --git a/src/backends/NetworkManagerGeneric.c b/src/backends/NetworkManagerGeneric.c
index 7984f2c..4f8336d 100644
--- a/src/backends/NetworkManagerGeneric.c
+++ b/src/backends/NetworkManagerGeneric.c
@@ -1,3 +1,4 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /* NetworkManager -- Network link manager
  *
  * Timothee Lecomte <timothee.lecomte@ens.fr>
@@ -33,10 +34,10 @@
 #include <string.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 #include "nm-netlink.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /* Because of a bug in libnl, rtnl.h should be included before route.h */
 #include <netlink/route/rtnl.h>
@@ -93,8 +94,9 @@ void nm_generic_enable_loopback (void)
 	rtnl_addr_set_label (addr, "lo");
 
 	if ((err = rtnl_addr_add (nlh, addr, 0)) < 0) {
-		if (err != -EEXIST)
-			nm_warning ("error %d returned from rtnl_addr_add():\n%s", err, nl_geterror());
+		if (err != -EEXIST) {
+			nm_log_warn (LOGD_CORE, "error %d returned from rtnl_addr_add():\n%s", err, nl_geterror());
+		}
 	}
 out:
 	if (addr)
diff --git a/src/backends/NetworkManagerGentoo.c b/src/backends/NetworkManagerGentoo.c
index 7fa1207..8d9e68c 100644
--- a/src/backends/NetworkManagerGentoo.c
+++ b/src/backends/NetworkManagerGentoo.c
@@ -32,8 +32,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -57,11 +58,9 @@ void nm_system_enable_loopback (void)
  */
 void nm_system_update_dns (void)
 {
- #ifdef NM_NO_NAMED
-	if (nm_spawn_process ("/etc/init.d/nscd status") == 0)
-		nm_spawn_process ("/etc/init.d/nscd restart");
- #else
-	nm_spawn_process("/usr/bin/killall -q nscd");
- #endif
+	if (g_file_test ("/usr/sbin/nscd", G_FILE_TEST_IS_EXECUTABLE)) {
+		nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
+		nm_spawn_process ("/usr/sbin/nscd -i hosts");
+	}
 }
 
diff --git a/src/backends/NetworkManagerMandriva.c b/src/backends/NetworkManagerMandriva.c
index 527a25d..8209ff4 100644
--- a/src/backends/NetworkManagerMandriva.c
+++ b/src/backends/NetworkManagerMandriva.c
@@ -30,7 +30,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 /*
diff --git a/src/backends/NetworkManagerPaldo.c b/src/backends/NetworkManagerPaldo.c
index 0147a3b..0c67e5b 100644
--- a/src/backends/NetworkManagerPaldo.c
+++ b/src/backends/NetworkManagerPaldo.c
@@ -31,9 +31,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -55,7 +55,7 @@ void nm_system_enable_loopback (void)
  */
 void nm_system_update_dns (void)
 {
-	nm_info ("Clearing nscd hosts cache.");
+	nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
 	nm_spawn_process ("/usr/sbin/nscd -i hosts");
 }
 
diff --git a/src/backends/NetworkManagerPardus.c b/src/backends/NetworkManagerPardus.c
index 52703e2..d952cf3 100644
--- a/src/backends/NetworkManagerPardus.c
+++ b/src/backends/NetworkManagerPardus.c
@@ -29,7 +29,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 /*
  * nm_system_enable_loopback
diff --git a/src/backends/NetworkManagerRedHat.c b/src/backends/NetworkManagerRedHat.c
index 1e3f7e9..954e58a 100644
--- a/src/backends/NetworkManagerRedHat.c
+++ b/src/backends/NetworkManagerRedHat.c
@@ -28,7 +28,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 /*
diff --git a/src/backends/NetworkManagerSlackware.c b/src/backends/NetworkManagerSlackware.c
index 8d7c5bf..a35e1bb 100644
--- a/src/backends/NetworkManagerSlackware.c
+++ b/src/backends/NetworkManagerSlackware.c
@@ -29,7 +29,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 /*
  * nm_system_enable_loopback
diff --git a/src/backends/NetworkManagerSuSE.c b/src/backends/NetworkManagerSuSE.c
index a0cd1cb..6c8ec1a 100644
--- a/src/backends/NetworkManagerSuSE.c
+++ b/src/backends/NetworkManagerSuSE.c
@@ -32,9 +32,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -56,7 +56,7 @@ void nm_system_enable_loopback (void)
  */
 void nm_system_update_dns (void)
 {
-	nm_info ("Clearing nscd hosts cache.");
+	nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
 	nm_spawn_process ("/usr/sbin/nscd -i hosts");
 }
 
diff --git a/src/bluez-manager/Makefile.am b/src/bluez-manager/Makefile.am
index a96cbe8..6c199e8 100644
--- a/src/bluez-manager/Makefile.am
+++ b/src/bluez-manager/Makefile.am
@@ -3,6 +3,7 @@ INCLUDES = \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_builddir}/marshallers \
 	-I$(top_srcdir)/src/nm-bluez-manager
 
@@ -30,6 +31,7 @@ libbluez_manager_la_CPPFLAGS = \
 
 libbluez_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS) \
 	$(BLUEZ_LIBS)
diff --git a/src/bluez-manager/nm-bluez-adapter.c b/src/bluez-manager/nm-bluez-adapter.c
index ba8f711..27a85e7 100644
--- a/src/bluez-manager/nm-bluez-adapter.c
+++ b/src/bluez-manager/nm-bluez-adapter.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <glib.h>
@@ -27,7 +27,7 @@
 #include "nm-bluez-device.h"
 #include "nm-bluez-common.h"
 #include "nm-dbus-glib-types.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 
 G_DEFINE_TYPE (NMBluezAdapter, nm_bluez_adapter, G_TYPE_OBJECT)
@@ -175,8 +175,8 @@ get_properties_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call, &err,
 	                            DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("bluez error getting adapter properties: %s",
-		            err && err->message ? err->message : "(unknown)");
+		nm_log_warn (LOGD_BT, "bluez error getting adapter properties: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		goto done;
 	}
@@ -209,8 +209,8 @@ query_properties (NMBluezAdapter *self)
 	                                self,
 	                                NULL, G_TYPE_INVALID);
 	if (!call) {
-		nm_warning ("failed to request Bluetooth adapter properties for %s.",
-		            priv->path);
+		nm_log_warn (LOGD_BT, "failed to request Bluetooth adapter properties for %s.",
+		             priv->path);
 	}
 }
 
diff --git a/src/bluez-manager/nm-bluez-device.c b/src/bluez-manager/nm-bluez-device.c
index 6ecd6b4..72acaa6 100644
--- a/src/bluez-manager/nm-bluez-device.c
+++ b/src/bluez-manager/nm-bluez-device.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <glib.h>
@@ -26,7 +26,7 @@
 #include "nm-bluez-device.h"
 #include "nm-bluez-common.h"
 #include "nm-dbus-glib-types.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 
 
@@ -228,8 +228,8 @@ get_properties_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call, &err,
 	                            DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("bluez error getting device properties: %s",
-		            err && err->message ? err->message : "(unknown)");
+		nm_log_warn (LOGD_BT, "bluez error getting device properties: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		g_signal_emit (self, signals[INITIALIZED], 0, FALSE);
 		return;
@@ -270,8 +270,8 @@ query_properties (NMBluezDevice *self)
 	                                self,
 	                                NULL, G_TYPE_INVALID);
 	if (!call) {
-		nm_warning ("failed to request Bluetooth device properties for %s.",
-		            priv->path);
+		nm_log_warn (LOGD_BT, "failed to request Bluetooth device properties for %s.",
+		             priv->path);
 	}
 }
 
diff --git a/src/bluez-manager/nm-bluez-manager.c b/src/bluez-manager/nm-bluez-manager.c
index 96cb3e7..fe027c4 100644
--- a/src/bluez-manager/nm-bluez-manager.c
+++ b/src/bluez-manager/nm-bluez-manager.c
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2009 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <signal.h>
@@ -24,7 +24,7 @@
 #include <stdlib.h>
 #include <dbus/dbus-glib.h>
 
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-dbus-glib-types.h"
 #include "nm-marshal.h"
 #include "nm-bluez-manager.h"
@@ -181,8 +181,8 @@ default_adapter_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call, &err,
 	                            DBUS_TYPE_G_OBJECT_PATH, &default_adapter,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("bluez error getting default adapter: %s",
-		            err && err->message ? err->message : "(unknown)");
+		nm_log_warn (LOGD_BT, "bluez error getting default adapter: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		return;
 	}
@@ -201,7 +201,7 @@ query_default_adapter (NMBluezManager *self)
 	                                self,
 	                                NULL, G_TYPE_INVALID);
 	if (!call)
-		nm_warning ("failed to request default Bluetooth adapter.");
+		nm_log_warn (LOGD_BT, "failed to request default Bluetooth adapter.");
 }
 
 static void
diff --git a/src/dhcp-manager/Makefile.am b/src/dhcp-manager/Makefile.am
index b7b0c65..f75e6b3 100644
--- a/src/dhcp-manager/Makefile.am
+++ b/src/dhcp-manager/Makefile.am
@@ -2,6 +2,7 @@ INCLUDES = \
 	-I${top_srcdir} \
 	-I${top_srcdir}/include \
 	-I${top_builddir}/marshallers \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/libnm-util \
 	-I${top_srcdir}/src \
 	-I${top_srcdir}/src/named-manager
@@ -9,9 +10,14 @@ INCLUDES = \
 noinst_LTLIBRARIES = libdhcp-manager.la
 
 libdhcp_manager_la_SOURCES = \
+	nm-dhcp-client.c \
+	nm-dhcp-client.h \
 	nm-dhcp-manager.c \
 	nm-dhcp-manager.h \
-	nm-dhcp-@DHCP_CLIENT@.c
+	nm-dhcp-dhclient.h \
+	nm-dhcp-dhclient.c \
+	nm-dhcp-dhcpcd.h \
+	nm-dhcp-dhcpcd.c
 
 libdhcp_manager_la_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
@@ -22,13 +28,12 @@ libdhcp_manager_la_CPPFLAGS = \
 	-DSYSCONFDIR=\"$(sysconfdir)\" \
 	-DLIBEXECDIR=\"$(libexecdir)\" \
 	-DLOCALSTATEDIR=\"$(localstatedir)\" \
-	-DDHCP_CLIENT_PATH=\"$(DHCP_CLIENT_PATH)\"
+	-DDHCLIENT_PATH=\"$(DHCLIENT_PATH)\" \
+	-DDHCPCD_PATH=\"$(DHCPCD_PATH)\"
 
 libdhcp_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
 
-EXTRA_DIST = \
-	     nm-dhcp-dhclient.c \
-	     nm-dhcp-dhcpcd.c
diff --git a/src/dhcp-manager/nm-dhcp-client.c b/src/dhcp-manager/nm-dhcp-client.c
new file mode 100644
index 0000000..888e7c5
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-client.c
@@ -0,0 +1,1132 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ *
+ */
+
+#include <glib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+
+#include "nm-utils.h"
+#include "nm-logging.h"
+#include "nm-dbus-glib-types.h"
+#include "nm-dhcp-client.h"
+
+typedef struct {
+	char *       iface;
+	gboolean     ipv6;
+	char *       uuid;
+	guint32      timeout;
+
+	guchar       state;
+	GPid         pid;
+	guint        timeout_id;
+	guint        watch_id;
+	GHashTable * options;
+} NMDHCPClientPrivate;
+
+#define NM_DHCP_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_CLIENT, NMDHCPClientPrivate))
+
+G_DEFINE_TYPE_EXTENDED (NMDHCPClient, nm_dhcp_client, G_TYPE_OBJECT, G_TYPE_FLAG_ABSTRACT, {})
+
+enum {
+	STATE_CHANGED,
+	TIMEOUT,
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum {
+	PROP_0,
+	PROP_IFACE,
+	PROP_IPV6,
+	PROP_UUID,
+	PROP_TIMEOUT,
+	LAST_PROP
+};
+
+/********************************************/
+
+GPid
+nm_dhcp_client_get_pid (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, -1);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), -1);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->pid;
+}
+
+const char *
+nm_dhcp_client_get_iface (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->iface;
+}
+
+gboolean
+nm_dhcp_client_get_ipv6 (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->ipv6;
+}
+
+const char *
+nm_dhcp_client_get_uuid (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->uuid;
+}
+
+/********************************************/
+
+static void
+timeout_cleanup (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+}
+
+static void
+watch_cleanup (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (priv->watch_id) {
+		g_source_remove (priv->watch_id);
+		priv->watch_id = 0;
+	}
+}
+
+static void
+stop_process (GPid pid, const char *iface)
+{
+	int i = 15; /* 3 seconds */
+
+	g_return_if_fail (pid > 0);
+
+	/* Tell it to quit; maybe it wants to send out a RELEASE message */
+	kill (pid, SIGTERM);
+
+	while (i-- > 0) {
+		gint child_status;
+		int ret;
+
+		ret = waitpid (pid, &child_status, WNOHANG);
+		if (ret > 0)
+			break;
+
+		if (ret == -1) {
+			/* Child already exited */
+			if (errno == ECHILD)
+				break;
+			/* Took too long; shoot it in the head */
+			i = 0;
+			break;
+		}
+		g_usleep (G_USEC_PER_SEC / 5);
+	}
+
+	if (i <= 0) {
+		if (iface) {
+			nm_log_warn (LOGD_DHCP, "(%s): DHCP client pid %d didn't exit, will kill it.",
+			             iface, pid);
+		}
+		kill (pid, SIGKILL);
+
+		nm_log_dbg (LOGD_DHCP, "waiting for DHCP client pid %d to exit", pid);
+		waitpid (pid, NULL, 0);
+		nm_log_dbg (LOGD_DHCP, "DHCP client pid %d cleaned up", pid);
+	}
+}
+
+static void
+real_stop (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DHCP_CLIENT (self));
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_if_fail (priv->pid > 0);
+
+	/* Clean up the watch handler since we're explicitly killing the daemon */
+	watch_cleanup (self);
+
+	stop_process (priv->pid, priv->iface);
+}
+
+static gboolean
+daemon_timeout (gpointer user_data)
+{
+	NMDHCPClient *self = NM_DHCP_CLIENT (user_data);
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (priv->ipv6) {
+		nm_log_warn (LOGD_DHCP6, "(%s): DHCPv6 request timed out.", priv->iface);
+	} else {
+		nm_log_warn (LOGD_DHCP4, "(%s): DHCPv4 request timed out.", priv->iface);
+	}
+	g_signal_emit (G_OBJECT (self), signals[TIMEOUT], 0);
+	return FALSE;
+}
+
+static void
+daemon_watch_cb (GPid pid, gint status, gpointer user_data)
+{
+	NMDHCPClient *self = NM_DHCP_CLIENT (user_data);
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (!WIFEXITED (status)) {
+		priv->state = DHC_ABEND;
+		nm_log_warn (LOGD_DHCP, "DHCP client died abnormally");
+	}
+	priv->pid = 0;
+
+	watch_cleanup (self);
+	timeout_cleanup (self);
+
+	g_signal_emit (G_OBJECT (self), signals[STATE_CHANGED], 0, priv->state);
+}
+
+static void
+start_monitor (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	g_return_if_fail (priv->pid > 0);
+
+	/* Set up a timeout on the transaction to kill it after the timeout */
+	priv->timeout_id = g_timeout_add_seconds (priv->timeout,
+	                                          daemon_timeout,
+	                                          self);
+	priv->watch_id = g_child_watch_add (priv->pid,
+	                                    (GChildWatchFunc) daemon_watch_cb,
+	                                    self);
+}
+
+gboolean
+nm_dhcp_client_start_ip4 (NMDHCPClient *self,
+                          NMSettingIP4Config *s_ip4,
+                          guint8 *dhcp_anycast_addr)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->pid == -1, FALSE);
+	g_return_val_if_fail (priv->ipv6 == FALSE, FALSE);
+	g_return_val_if_fail (priv->uuid != NULL, FALSE);
+
+	nm_log_info (LOGD_DHCP, "Activation (%s) Beginning DHCPv4 transaction (timeout in %d seconds)",
+	             priv->iface, priv->timeout);
+
+	priv->pid = NM_DHCP_CLIENT_GET_CLASS (self)->ip4_start (self, s_ip4, dhcp_anycast_addr);
+	if (priv->pid)
+		start_monitor (self);
+
+	return priv->pid ? TRUE : FALSE;
+}
+
+gboolean
+nm_dhcp_client_start_ip6 (NMDHCPClient *self,
+                          NMSettingIP6Config *s_ip6,
+                          guint8 *dhcp_anycast_addr,
+                          gboolean info_only)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->pid == -1, FALSE);
+	g_return_val_if_fail (priv->ipv6 == TRUE, FALSE);
+	g_return_val_if_fail (priv->uuid != NULL, FALSE);
+
+	nm_log_info (LOGD_DHCP, "Activation (%s) Beginning DHCPv6 transaction (timeout in %d seconds)",
+	             priv->iface, priv->timeout);
+
+	priv->pid = NM_DHCP_CLIENT_GET_CLASS (self)->ip6_start (self, s_ip6, dhcp_anycast_addr, info_only);
+	if (priv->pid > 0)
+		start_monitor (self);
+
+	return priv->pid ? TRUE : FALSE;
+}
+
+void
+nm_dhcp_client_stop_existing (const char *pid_file, const char *binary_name)
+{
+	char *pid_contents = NULL, *proc_contents = NULL, *proc_path = NULL;
+	long int tmp;
+
+	/* Check for an existing instance and stop it */
+	if (!g_file_get_contents (pid_file, &pid_contents, NULL, NULL))
+		return;
+
+	errno = 0;
+	tmp = strtol (pid_contents, NULL, 10);
+	if ((errno == 0) && (tmp > 1)) {
+		const char *exe;
+
+		/* Ensure the process is a DHCP client */
+		proc_path = g_strdup_printf ("/proc/%ld/cmdline", tmp);
+		if (g_file_get_contents (proc_path, &proc_contents, NULL, NULL)) {
+			exe = strrchr (proc_contents, '/');
+			if (exe)
+				exe++;
+			else
+				exe = proc_contents;
+
+			if (!strcmp (exe, binary_name))
+				stop_process ((GPid) tmp, NULL);
+		}
+	}
+
+	remove (pid_file);
+	g_free (proc_path);
+	g_free (pid_contents);
+	g_free (proc_contents);
+}
+
+void
+nm_dhcp_client_stop (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DHCP_CLIENT (self));
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	/* Kill the DHCP client */
+	if (priv->pid > 0) {
+		NM_DHCP_CLIENT_GET_CLASS (self)->stop (self);
+
+		nm_log_info (LOGD_DHCP, "(%s): canceled DHCP transaction, DHCP client pid %d",
+		             priv->iface, priv->pid);
+	}
+
+	/* And clean stuff up */
+
+	priv->pid = -1;
+	priv->state = DHC_END;
+
+	g_hash_table_remove_all (priv->options);
+
+	timeout_cleanup (self);
+	watch_cleanup (self);
+}
+
+/********************************************/
+
+static gboolean
+state_is_bound (guint32 state)
+{
+	if (   (state == DHC_BOUND4)
+	    || (state == DHC_BOUND6)
+	    || (state == DHC_RENEW4)
+	    || (state == DHC_RENEW6)
+	    || (state == DHC_REBOOT)
+	    || (state == DHC_REBIND4)
+	    || (state == DHC_REBIND6)
+	    || (state == DHC_IPV4LL))
+		return TRUE;
+
+	return FALSE;
+}
+
+typedef struct {
+	NMDHCPState state;
+	const char *name;
+} DhcState;
+
+#define STATE_TABLE_SIZE (sizeof (state_table) / sizeof (state_table[0]))
+
+static DhcState state_table[] = {
+	{ DHC_NBI,     "nbi" },
+	{ DHC_PREINIT, "preinit" },
+	{ DHC_PREINIT6,"preinit6" },
+	{ DHC_BOUND4,  "bound" },
+	{ DHC_BOUND6,  "bound6" },
+	{ DHC_IPV4LL,  "ipv4ll" },
+	{ DHC_RENEW4,  "renew" },
+	{ DHC_RENEW6,  "renew6" },
+	{ DHC_REBOOT,  "reboot" },
+	{ DHC_REBIND4, "rebind" },
+	{ DHC_REBIND6, "rebind6" },
+	{ DHC_STOP,    "stop" },
+	{ DHC_MEDIUM,  "medium" },
+	{ DHC_TIMEOUT, "timeout" },
+	{ DHC_FAIL,    "fail" },
+	{ DHC_EXPIRE,  "expire" },
+	{ DHC_RELEASE, "release" },
+	{ DHC_START,   "start" },
+	{ DHC_ABEND,   "abend" },
+	{ DHC_END,     "end" },
+	{ DHC_DEPREF6, "depref6" },
+};
+
+static inline const char *
+state_to_string (guint32 state)
+{
+	int i;
+
+	for (i = 0; i < STATE_TABLE_SIZE; i++) {
+		if (state == state_table[i].state)
+			return state_table[i].name;
+	}
+
+	return NULL;
+}
+
+static inline NMDHCPState
+string_to_state (const char *name)
+{
+	int i;
+
+	for (i = 0; i < STATE_TABLE_SIZE; i++) {
+		if (!strcasecmp (name, state_table[i].name))
+			return state_table[i].state;
+	}
+
+	return 255;
+}
+
+static char *
+garray_to_string (GArray *array, const char *key)
+{
+	GString *str;
+	int i;
+	unsigned char c;
+	char *converted = NULL;
+
+	g_return_val_if_fail (array != NULL, NULL);
+
+	/* Since the DHCP options come through environment variables, they should
+	 * already be UTF-8 safe, but just make sure.
+	 */
+	str = g_string_sized_new (array->len);
+	for (i = 0; i < array->len; i++) {
+		c = array->data[i];
+
+		/* Convert NULLs to spaces and non-ASCII characters to ? */
+		if (c == '\0')
+			c = ' ';
+		else if (c > 127)
+			c = '?';
+		str = g_string_append_c (str, c);
+	}
+	str = g_string_append_c (str, '\0');
+
+	converted = str->str;
+	if (!g_utf8_validate (converted, -1, NULL))
+		nm_log_warn (LOGD_DHCP, "DHCP option '%s' couldn't be converted to UTF-8", key);
+	g_string_free (str, FALSE);
+	return converted;
+}
+
+static void
+copy_option (gpointer key,
+             gpointer value,
+             gpointer user_data)
+{
+	GHashTable *hash = user_data;
+	const char *str_key = (const char *) key;
+	char *str_value = NULL;
+
+	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
+		nm_log_warn (LOGD_DHCP, "unexpected key %s value type was not "
+		             "DBUS_TYPE_G_UCHAR_ARRAY",
+		             str_key);
+		return;
+	}
+
+	str_value = garray_to_string ((GArray *) g_value_get_boxed (value), str_key);
+	if (str_value)
+		g_hash_table_insert (hash, g_strdup (str_key), str_value);
+}
+
+void
+nm_dhcp_client_new_options (NMDHCPClient *self,
+                            GHashTable *options,
+                            const char *reason)
+{
+	NMDHCPClientPrivate *priv;
+	guint32 old_state;
+	guint32 new_state;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DHCP_CLIENT (self));
+	g_return_if_fail (options != NULL);
+	g_return_if_fail (reason != NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	old_state = priv->state;
+	new_state = string_to_state (reason);
+
+	/* Clear old and save new DHCP options */
+	g_hash_table_remove_all (priv->options);
+	g_hash_table_foreach (options, copy_option, priv->options);
+
+	if (old_state == new_state)
+		return;
+
+	/* Handle changed device state */
+	if (state_is_bound (new_state)) {
+		/* Cancel the timeout if the DHCP client is now bound */
+		timeout_cleanup (self);
+	}
+
+	priv->state = new_state;
+	if (priv->ipv6) {
+		nm_log_info (LOGD_DHCP6, "(%s): DHCPv6 state changed %s -> %s",
+		            priv->iface,
+		            state_to_string (old_state),
+		            state_to_string (priv->state));
+	} else {
+		nm_log_info (LOGD_DHCP4, "(%s): DHCPv4 state changed %s -> %s",
+		            priv->iface,
+		            state_to_string (old_state),
+		            state_to_string (priv->state));
+	}
+
+	g_signal_emit (G_OBJECT (self),
+	               signals[STATE_CHANGED],
+	               0,
+	               priv->state);
+}
+
+#define NEW_TAG "new_"
+#define OLD_TAG "old_"
+
+typedef struct {
+	GHFunc func;
+	gpointer user_data;
+} DhcpForeachInfo;
+
+static void
+iterate_dhcp_config_option (gpointer key,
+                            gpointer value,
+                            gpointer user_data)
+{
+	DhcpForeachInfo *info = (DhcpForeachInfo *) user_data;
+	char *tmp_key = NULL;
+	const char **p;
+	static const char *filter_options[] = {
+		"interface", "pid", "reason", "dhcp_message_type", NULL
+	};
+	
+	/* Filter out stuff that's not actually new DHCP options */
+	for (p = filter_options; *p; p++) {
+		if (!strcmp (*p, (const char *) key))
+			return;
+		if (!strncmp ((const char *) key, OLD_TAG, strlen (OLD_TAG)))
+			return;
+	}
+
+	/* Remove the "new_" prefix that dhclient passes back */
+	if (!strncmp ((const char *) key, NEW_TAG, strlen (NEW_TAG)))
+		tmp_key = g_strdup ((const char *) (key + strlen (NEW_TAG)));
+	else
+		tmp_key = g_strdup ((const char *) key);
+
+	(*info->func) ((gpointer) tmp_key, value, info->user_data);
+	g_free (tmp_key);
+}
+
+gboolean
+nm_dhcp_client_foreach_option (NMDHCPClient *self,
+                               GHFunc func,
+                               gpointer user_data)
+{
+	NMDHCPClientPrivate *priv;
+	DhcpForeachInfo info = { NULL, NULL };
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+	g_return_val_if_fail (func != NULL, FALSE);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (!state_is_bound (priv->state)) {
+		if (priv->ipv6) {
+			nm_log_warn (LOGD_DHCP6, "(%s): DHCPv6 client didn't bind to a lease.", priv->iface);
+		} else {
+			nm_log_warn (LOGD_DHCP4, "(%s): DHCPv4 client didn't bind to a lease.", priv->iface);
+		}
+		return FALSE;
+	}
+
+	info.func = func;
+	info.user_data = user_data;
+	g_hash_table_foreach (priv->options, iterate_dhcp_config_option, &info);
+	return TRUE;
+}
+
+/********************************************/
+
+static void
+process_classful_routes (GHashTable *options, NMIP4Config *ip4_config)
+{
+	const char *str;
+	char **searches, **s;
+
+	str = g_hash_table_lookup (options, "new_static_routes");
+	if (!str)
+		return;
+
+	searches = g_strsplit (str, " ", 0);
+	if ((g_strv_length (searches) % 2)) {
+		nm_log_info (LOGD_DHCP, "  static routes provided, but invalid");
+		goto out;
+	}
+
+	for (s = searches; *s; s += 2) {
+		NMIP4Route *route;
+		struct in_addr rt_addr;
+		struct in_addr rt_route;
+
+		if (inet_pton (AF_INET, *s, &rt_addr) <= 0) {
+			nm_log_warn (LOGD_DHCP, "DHCP provided invalid static route address: '%s'", *s);
+			continue;
+		}
+		if (inet_pton (AF_INET, *(s + 1), &rt_route) <= 0) {
+			nm_log_warn (LOGD_DHCP, "DHCP provided invalid static route gateway: '%s'", *(s + 1));
+			continue;
+		}
+
+		// FIXME: ensure the IP addresse and route are sane
+
+		route = nm_ip4_route_new ();
+		nm_ip4_route_set_dest (route, (guint32) rt_addr.s_addr);
+		nm_ip4_route_set_prefix (route, 32); /* 255.255.255.255 */
+		nm_ip4_route_set_next_hop (route, (guint32) rt_route.s_addr);
+
+		nm_ip4_config_take_route (ip4_config, route);
+		nm_log_info (LOGD_DHCP, "  static route %s gw %s", *s, *(s + 1));
+	}
+
+out:
+	g_strfreev (searches);
+}
+
+static void
+process_domain_search (const char *str, GFunc add_func, gpointer user_data)
+{
+	char **searches, **s;
+	char *unescaped, *p;
+	int i;
+
+	g_return_if_fail (str != NULL);
+	g_return_if_fail (add_func != NULL);
+
+	p = unescaped = g_strdup (str);
+	do {
+		p = strstr (p, "\\032");
+		if (!p)
+			break;
+
+		/* Clear the escaped space with real spaces */
+		for (i = 0; i < 4; i++)
+			*p++ = ' ';
+	} while (*p++);
+
+	if (strchr (unescaped, '\\')) {
+		nm_log_warn (LOGD_DHCP, "  invalid domain search: '%s'", unescaped);
+		goto out;
+	}
+
+	searches = g_strsplit (unescaped, " ", 0);
+	for (s = searches; *s; s++) {
+		if (strlen (*s)) {
+			nm_log_info (LOGD_DHCP, "  domain search '%s'", *s);
+			add_func (*s, user_data);
+		}
+	}
+	g_strfreev (searches);
+
+out:
+	g_free (unescaped);
+}
+
+static void
+ip4_add_domain_search (gpointer data, gpointer user_data)
+{
+	nm_ip4_config_add_search (NM_IP4_CONFIG (user_data), (const char *) data);
+}
+
+/* Given a table of DHCP options from the client, convert into an IP4Config */
+static NMIP4Config *
+ip4_options_to_config (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+	NMIP4Config *ip4_config = NULL;
+	struct in_addr tmp_addr;
+	NMIP4Address *addr = NULL;
+	char *str = NULL;
+	guint32 gwaddr = 0, prefix = 0;
+	gboolean have_classless = FALSE;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->options != NULL, NULL);
+
+	ip4_config = nm_ip4_config_new ();
+	if (!ip4_config) {
+		nm_log_warn (LOGD_DHCP4, "(%s): couldn't allocate memory for an IP4Config!", priv->iface);
+		return NULL;
+	}
+
+	addr = nm_ip4_address_new ();
+	if (!addr) {
+		nm_log_warn (LOGD_DHCP4, "(%s): couldn't allocate memory for an IP4 Address!", priv->iface);
+		goto error;
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_ip_address");
+	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
+		nm_ip4_address_set_address (addr, tmp_addr.s_addr);
+		nm_log_info (LOGD_DHCP4, "  address %s", str);
+	} else
+		goto error;
+
+	str = g_hash_table_lookup (priv->options, "new_subnet_mask");
+	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
+		prefix = nm_utils_ip4_netmask_to_prefix (tmp_addr.s_addr);
+		nm_log_info (LOGD_DHCP4, "  prefix %d (%s)", prefix, str);
+	} else {
+		/* Get default netmask for the IP according to appropriate class. */
+		prefix = nm_utils_ip4_get_default_prefix (nm_ip4_address_get_address (addr));
+		nm_log_info (LOGD_DHCP4, "  prefix %d (default)", prefix);
+	}
+	nm_ip4_address_set_prefix (addr, prefix);
+
+	/* Routes: if the server returns classless static routes, we MUST ignore
+	 * the 'static_routes' option.
+	 */
+	if (NM_DHCP_CLIENT_GET_CLASS (self)->ip4_process_classless_routes) {
+		have_classless = NM_DHCP_CLIENT_GET_CLASS (self)->ip4_process_classless_routes (self,
+		                                                                                priv->options,
+		                                                                                ip4_config,
+		                                                                                &gwaddr);
+	}
+
+	if (!have_classless) {
+		gwaddr = 0;  /* Ensure client code doesn't lie */
+		process_classful_routes (priv->options, ip4_config);
+	}
+
+	if (gwaddr) {
+		char buf[INET_ADDRSTRLEN + 1];
+
+		inet_ntop (AF_INET, &gwaddr, buf, sizeof (buf));
+		nm_log_info (LOGD_DHCP4, "  gateway %s", buf);
+		nm_ip4_address_set_gateway (addr, gwaddr);
+	} else {
+		/* If the gateway wasn't provided as a classless static route with a
+		 * subnet length of 0, try to find it using the old-style 'routers' option.
+		 */
+		str = g_hash_table_lookup (priv->options, "new_routers");
+		if (str) {
+			char **routers = g_strsplit (str, " ", 0);
+			char **s;
+
+			for (s = routers; *s; s++) {
+				/* FIXME: how to handle multiple routers? */
+				if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
+					nm_ip4_address_set_gateway (addr, tmp_addr.s_addr);
+					nm_log_info (LOGD_DHCP4, "  gateway %s", *s);
+					break;
+				} else
+					nm_log_warn (LOGD_DHCP4, "ignoring invalid gateway '%s'", *s);
+			}
+			g_strfreev (routers);
+		}
+	}
+
+	nm_ip4_config_take_address (ip4_config, addr);
+	addr = NULL;
+
+	str = g_hash_table_lookup (priv->options, "new_host_name");
+	if (str)
+		nm_log_info (LOGD_DHCP4, "  hostname '%s'", str);
+
+	str = g_hash_table_lookup (priv->options, "new_domain_name_servers");
+	if (str) {
+		char **searches = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = searches; *s; s++) {
+			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
+				nm_ip4_config_add_nameserver (ip4_config, tmp_addr.s_addr);
+				nm_log_info (LOGD_DHCP4, "  nameserver '%s'", *s);
+			} else
+				nm_log_warn (LOGD_DHCP4, "ignoring invalid nameserver '%s'", *s);
+		}
+		g_strfreev (searches);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_domain_name");
+	if (str) {
+		char **domains = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = domains; *s; s++) {
+			nm_log_info (LOGD_DHCP4, "  domain name '%s'", *s);
+			nm_ip4_config_add_domain (ip4_config, *s);
+		}
+		g_strfreev (domains);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_domain_search");
+	if (str)
+		process_domain_search (str, ip4_add_domain_search, ip4_config);
+
+	str = g_hash_table_lookup (priv->options, "new_netbios_name_servers");
+	if (str) {
+		char **searches = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = searches; *s; s++) {
+			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
+				nm_ip4_config_add_wins (ip4_config, tmp_addr.s_addr);
+				nm_log_info (LOGD_DHCP4, "  wins '%s'", *s);
+			} else
+				nm_log_warn (LOGD_DHCP4, "ignoring invalid WINS server '%s'", *s);
+		}
+		g_strfreev (searches);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_interface_mtu");
+	if (str) {
+		int int_mtu;
+
+		errno = 0;
+		int_mtu = strtol (str, NULL, 10);
+		if ((errno == EINVAL) || (errno == ERANGE))
+			goto error;
+
+		if (int_mtu > 576)
+			nm_ip4_config_set_mtu (ip4_config, int_mtu);
+	}
+
+	return ip4_config;
+
+error:
+	if (addr)
+		nm_ip4_address_unref (addr);
+	g_object_unref (ip4_config);
+	return NULL;
+}
+
+NMIP4Config *
+nm_dhcp_client_get_ip4_config (NMDHCPClient *self, gboolean test)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (test && !state_is_bound (priv->state)) {
+		nm_log_warn (LOGD_DHCP4, "(%s): DHCP client didn't bind to a lease.", priv->iface);
+		return NULL;
+	}
+
+	return ip4_options_to_config (self);
+}
+
+/********************************************/
+
+static void
+ip6_add_domain_search (gpointer data, gpointer user_data)
+{
+	nm_ip6_config_add_search (NM_IP6_CONFIG (user_data), (const char *) data);
+}
+
+/* Given a table of DHCP options from the client, convert into an IP6Config */
+static NMIP6Config *
+ip6_options_to_config (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+	NMIP6Config *ip6_config = NULL;
+	struct in6_addr tmp_addr;
+	NMIP6Address *addr = NULL;
+	char *str = NULL;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->options != NULL, NULL);
+
+	ip6_config = nm_ip6_config_new ();
+	if (!ip6_config) {
+		nm_log_warn (LOGD_DHCP6, "(%s): couldn't allocate memory for an IP6Config!", priv->iface);
+		return NULL;
+	}
+
+	addr = nm_ip6_address_new ();
+	if (!addr) {
+		nm_log_warn (LOGD_DHCP6, "(%s): couldn't allocate memory for an IP6 Address!", priv->iface);
+		goto error;
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_ip6_address");
+	if (str && (inet_pton (AF_INET6, str, &tmp_addr) > 0)) {
+		nm_ip6_address_set_address (addr, &tmp_addr);
+		nm_log_info (LOGD_DHCP6, "  address %s", str);
+	} else
+		goto error;
+
+	str = g_hash_table_lookup (priv->options, "new_ip6_prefixlen");
+	if (str) {
+		long unsigned int prefix;
+
+		errno = 0;
+		prefix = strtoul (str, NULL, 10);
+		if (errno != 0 || prefix > 128)
+			goto error;
+
+		nm_ip6_address_set_prefix (addr, (guint32) prefix);
+		nm_log_info (LOGD_DHCP6, "  prefix %lu", prefix);
+	}
+
+	nm_ip6_config_take_address (ip6_config, addr);
+	addr = NULL;
+
+	str = g_hash_table_lookup (priv->options, "new_host_name");
+	if (str)
+		nm_log_info (LOGD_DHCP6, "  hostname '%s'", str);
+
+	str = g_hash_table_lookup (priv->options, "new_dhcp6_name_servers");
+	if (str) {
+		char **searches = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = searches; *s; s++) {
+			if (inet_pton (AF_INET6, *s, &tmp_addr) > 0) {
+				nm_ip6_config_add_nameserver (ip6_config, &tmp_addr);
+				nm_log_info (LOGD_DHCP6, "  nameserver '%s'", *s);
+			} else
+				nm_log_warn (LOGD_DHCP6, "ignoring invalid nameserver '%s'", *s);
+		}
+		g_strfreev (searches);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_dhcp6_domain_search");
+	if (str)
+		process_domain_search (str, ip6_add_domain_search, ip6_config);
+
+	return ip6_config;
+
+error:
+	if (addr)
+		nm_ip6_address_unref (addr);
+	g_object_unref (ip6_config);
+	return NULL;
+}
+
+NMIP6Config *
+nm_dhcp_client_get_ip6_config (NMDHCPClient *self, gboolean test)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (test && !state_is_bound (priv->state)) {
+		nm_log_warn (LOGD_DHCP6, "(%s): dhcp client didn't bind to a lease.", priv->iface);
+		return NULL;
+	}
+
+	return ip6_options_to_config (self);
+}
+
+/********************************************/
+
+static void
+nm_dhcp_client_init (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+	priv->pid = -1;
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_IFACE:
+		g_value_set_string (value, priv->iface);
+		break;
+	case PROP_IPV6:
+		g_value_set_boolean (value, priv->ipv6);
+		break;
+	case PROP_UUID:
+		g_value_set_string (value, priv->uuid);
+		break;
+	case PROP_TIMEOUT:
+		g_value_set_uint (value, priv->timeout);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (object);
+ 
+	switch (prop_id) {
+	case PROP_IFACE:
+		/* construct-only */
+		priv->iface = g_strdup (g_value_get_string (value));
+		break;
+	case PROP_IPV6:
+		/* construct-only */
+		priv->ipv6 = g_value_get_boolean (value);
+		break;
+	case PROP_UUID:
+		/* construct-only */
+		priv->uuid = g_value_dup_string (value);
+		break;
+	case PROP_TIMEOUT:
+		priv->timeout = g_value_get_uint (value);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDHCPClient *self = NM_DHCP_CLIENT (object);
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	/* Stopping the client is left up to the controlling device
+	 * explicitly since we may want to quit NetworkManager but not terminate
+	 * the DHCP client.
+	 */
+
+	g_hash_table_destroy (priv->options);
+	g_free (priv->iface);
+
+	G_OBJECT_CLASS (nm_dhcp_client_parent_class)->dispose (object);
+}
+
+static void
+nm_dhcp_client_class_init (NMDHCPClientClass *client_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (client_class);
+
+	g_type_class_add_private (client_class, sizeof (NMDHCPClientPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+
+	client_class->stop = real_stop;
+
+	g_object_class_install_property
+		(object_class, PROP_IFACE,
+		 g_param_spec_string (NM_DHCP_CLIENT_INTERFACE,
+		                      "iface",
+		                      "Interface",
+		                      NULL,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_IPV6,
+		 g_param_spec_boolean (NM_DHCP_CLIENT_IPV6,
+		                       "ipv6",
+		                       "IPv6",
+		                       FALSE,
+		                       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_UUID,
+		 g_param_spec_string (NM_DHCP_CLIENT_UUID,
+		                      "uuid",
+		                      "UUID",
+		                      NULL,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_TIMEOUT,
+		 g_param_spec_uint (NM_DHCP_CLIENT_TIMEOUT,
+		                    "timeout",
+		                    "Timeout",
+		                    0, G_MAXUINT, 45,
+		                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	/* signals */
+	signals[STATE_CHANGED] =
+		g_signal_new ("state-changed",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDHCPClientClass, state_changed),
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__UINT,
+					  G_TYPE_NONE, 1, G_TYPE_UINT);
+
+	signals[TIMEOUT] =
+		g_signal_new ("timeout",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDHCPClientClass, timeout),
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__VOID,
+					  G_TYPE_NONE, 0);
+}
+
diff --git a/src/dhcp-manager/nm-dhcp-client.h b/src/dhcp-manager/nm-dhcp-client.h
new file mode 100644
index 0000000..2ebb5a7
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-client.h
@@ -0,0 +1,138 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP_CLIENT_H
+#define NM_DHCP_CLIENT_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include <nm-setting-ip4-config.h>
+#include <nm-setting-ip6-config.h>
+#include <nm-ip4-config.h>
+#include <nm-ip6-config.h>
+
+#define NM_TYPE_DHCP_CLIENT            (nm_dhcp_client_get_type ())
+#define NM_DHCP_CLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_CLIENT, NMDHCPClient))
+#define NM_DHCP_CLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP_CLIENT, NMDHCPClientClass))
+#define NM_IS_DHCP_CLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP_CLIENT))
+#define NM_IS_DHCP_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_CLIENT))
+#define NM_DHCP_CLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_CLIENT, NMDHCPClientClass))
+
+#define NM_DHCP_CLIENT_INTERFACE "iface"
+#define NM_DHCP_CLIENT_IPV6      "ipv6"
+#define NM_DHCP_CLIENT_UUID      "uuid"
+#define NM_DHCP_CLIENT_TIMEOUT   "timeout"
+
+typedef enum {
+	DHC_NBI = 0,     /* no broadcast interfaces found */
+	DHC_PREINIT,     /* configuration started */
+	DHC_PREINIT6,    /* configuration started */
+	DHC_BOUND4,      /* IPv4 lease obtained */
+	DHC_BOUND6,      /* IPv6 lease obtained */
+	DHC_IPV4LL,      /* IPv4LL address obtained */
+	DHC_RENEW4,      /* IPv4 lease renewed */
+	DHC_RENEW6,      /* IPv6 lease renewed */
+	DHC_REBOOT,      /* have valid lease, but now obtained a different one */
+	DHC_REBIND4,     /* IPv4 new/different lease */
+	DHC_REBIND6,     /* IPv6 new/different lease */
+	DHC_DEPREF6,     /* IPv6 lease depreferred */
+	DHC_STOP,        /* remove old lease */
+	DHC_MEDIUM,      /* media selection begun */
+	DHC_TIMEOUT,     /* timed out contacting DHCP server */
+	DHC_FAIL,        /* all attempts to contact server timed out, sleeping */
+	DHC_EXPIRE,      /* lease has expired, renewing */
+	DHC_RELEASE,     /* releasing lease */
+	DHC_START,       /* sent when dhclient started OK */
+	DHC_ABEND,       /* dhclient exited abnormally */
+	DHC_END,         /* dhclient exited normally */
+	DHC_END_OPTIONS, /* last option in subscription sent */
+} NMDHCPState;
+
+typedef struct {
+	GObject parent;
+} NMDHCPClient;
+
+typedef struct {
+	GObjectClass parent;
+
+	/* Methods */
+
+	/* Given the options table, extract any classless routes, add them to
+	 * the IP4 config and return TRUE if any existed.  If a gateway was sent
+	 * as a classless route return that in out_gwaddr.
+	 */
+	gboolean (*ip4_process_classless_routes) (NMDHCPClient *self,
+	                                          GHashTable *options,
+	                                          NMIP4Config *ip4_config,
+	                                          guint32 *out_gwaddr);
+
+	GPid (*ip4_start)                        (NMDHCPClient *self,
+	                                          NMSettingIP4Config *s_ip4,
+	                                          guint8 *anycast_addr);
+
+	GPid (*ip6_start)                        (NMDHCPClient *self,
+	                                          NMSettingIP6Config *s_ip6,
+	                                          guint8 *anycast_addr,
+	                                          gboolean info_only);
+
+	void (*stop)                             (NMDHCPClient *self);
+
+	/* Signals */
+	void (*state_changed) (NMDHCPClient *self, NMDHCPState state);
+	void (*timeout)       (NMDHCPClient *self);
+} NMDHCPClientClass;
+
+GType nm_dhcp_client_get_type (void);
+
+GPid nm_dhcp_client_get_pid (NMDHCPClient *self);
+
+const char *nm_dhcp_client_get_iface (NMDHCPClient *self);
+
+gboolean nm_dhcp_client_get_ipv6 (NMDHCPClient *self);
+
+const char *nm_dhcp_client_get_uuid (NMDHCPClient *self);
+
+gboolean nm_dhcp_client_start_ip4 (NMDHCPClient *self,
+                                   NMSettingIP4Config *s_ip4,
+                                   guint8 *dhcp_anycast_addr);
+
+gboolean nm_dhcp_client_start_ip6 (NMDHCPClient *self,
+                                   NMSettingIP6Config *s_ip6,
+                                   guint8 *dhcp_anycast_addr,
+                                   gboolean info_only);
+
+void nm_dhcp_client_stop (NMDHCPClient *self);
+
+void nm_dhcp_client_new_options (NMDHCPClient *self,
+                                 GHashTable *options,
+                                 const char *reason);
+
+gboolean nm_dhcp_client_foreach_option (NMDHCPClient *self,
+                                        GHFunc func,
+                                        gpointer user_data);
+
+NMIP4Config *nm_dhcp_client_get_ip4_config   (NMDHCPClient *self, gboolean test);
+
+NMIP6Config *nm_dhcp_client_get_ip6_config   (NMDHCPClient *self, gboolean test);
+
+/* Backend helpers */
+void nm_dhcp_client_stop_existing (const char *pid_file, const char *binary_name);
+
+#endif /* NM_DHCP_CLIENT_H */
+
diff --git a/src/dhcp-manager/nm-dhcp-dhclient.c b/src/dhcp-manager/nm-dhcp-dhclient.c
index 478ac29..37543ed 100644
--- a/src/dhcp-manager/nm-dhcp-dhclient.c
+++ b/src/dhcp-manager/nm-dhcp-dhclient.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  */
 
 #define _XOPEN_SOURCE
@@ -36,46 +36,63 @@
 
 #include <config.h>
 
-#include "nm-dhcp-manager.h"
+#include "nm-dhcp-dhclient.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 
+G_DEFINE_TYPE (NMDHCPDhclient, nm_dhcp_dhclient, NM_TYPE_DHCP_CLIENT)
 
-#define NM_DHCP_MANAGER_PID_FILENAME	"dhclient"
-#define NM_DHCP_MANAGER_PID_FILE_EXT	"pid"
+#define NM_DHCP_DHCLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientPrivate))
 
 #if defined(TARGET_DEBIAN)
-#define NM_DHCP_MANAGER_LEASE_DIR       LOCALSTATEDIR "/lib/dhcp3"
+#define NM_DHCLIENT_LEASE_DIR           LOCALSTATEDIR "/lib/dhcp3"
 #elif defined(TARGET_SUSE) || defined(TARGET_MANDRIVA)
-#define NM_DHCP_MANAGER_LEASE_DIR       LOCALSTATEDIR "/lib/dhcp"
+#define NM_DHCLIENT_LEASE_DIR           LOCALSTATEDIR "/lib/dhcp"
 #else
-#define NM_DHCP_MANAGER_LEASE_DIR       LOCALSTATEDIR "/lib/dhclient"
+#define NM_DHCLIENT_LEASE_DIR           LOCALSTATEDIR "/lib/dhclient"
 #endif
-#define NM_DHCP_MANAGER_LEASE_FILENAME	"dhclient"
-#define NM_DHCP_MANAGER_LEASE_FILE_EXT	"lease"
 
 #define ACTION_SCRIPT_PATH	LIBEXECDIR "/nm-dhcp-client.action"
 
+typedef struct {
+	const char *path;
+	char *conf_file;
+	char *lease_file;
+	char *pid_file;
+} NMDHCPDhclientPrivate;
 
-static char *
-get_pidfile_for_iface (const char * iface)
+const char *
+nm_dhcp_dhclient_get_path (const char *try_first)
 {
-	return g_strdup_printf ("%s/%s-%s.%s",
-	                        NM_DHCP_MANAGER_RUN_DIR,
-	                        NM_DHCP_MANAGER_PID_FILENAME,
-	                        iface,
-	                        NM_DHCP_MANAGER_PID_FILE_EXT);
-}
+	static const char *dhclient_paths[] = {
+		"/sbin/dhclient",
+		"/usr/sbin/dhclient",
+		"/usr/pkg/sbin/dhclient",
+		"/usr/local/sbin/dhclient",
+		NULL
+	};
+	const char **path = dhclient_paths;
+
+	if (strlen (try_first) && g_file_test (try_first, G_FILE_TEST_EXISTS))
+		return try_first;
+
+	while (*path != NULL) {
+		if (g_file_test (*path, G_FILE_TEST_EXISTS))
+			break;
+		path++;
+	}
 
+	return *path;
+}
 
 static char *
-get_leasefile_for_iface (const char * iface, const char *uuid)
+get_leasefile_for_iface (const char * iface, const char *uuid, gboolean ipv6)
 {
-	return g_strdup_printf ("%s/%s-%s-%s.%s",
-	                        NM_DHCP_MANAGER_LEASE_DIR,
-	                        NM_DHCP_MANAGER_LEASE_FILENAME,
+	return g_strdup_printf ("%s/dhclient%s-%s-%s.lease",
+	                        NM_DHCLIENT_LEASE_DIR,
+	                        ipv6 ? "6" : "",
 	                        uuid,
-	                        iface,
-	                        NM_DHCP_MANAGER_LEASE_FILE_EXT);
+	                        iface);
 }
 
 static void
@@ -85,7 +102,7 @@ add_lease_option (GHashTable *hash, char *line)
 
 	spc = strchr (line, ' ');
 	if (!spc) {
-		g_warning ("%s: line '%s' did not contain a space", __func__, line);
+		nm_log_warn (LOGD_DHCP, "DHCP lease file line '%s' did not contain a space", line);
 		return;
 	}
 
@@ -93,8 +110,8 @@ add_lease_option (GHashTable *hash, char *line)
 	if (g_str_has_prefix (line, "option ")) {
 		spc = strchr (spc + 1, ' ');
 		if (!spc) {
-			g_warning ("%s: option line '%s' did not contain a second space",
-			           __func__, line);
+			nm_log_warn (LOGD_DHCP, "DHCP lease file option line '%s' did not contain a second space",
+			             line);
 			return;
 		}
 	}
@@ -119,7 +136,7 @@ add_lease_option (GHashTable *hash, char *line)
 }
 
 GSList *
-nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
+nm_dhcp_dhclient_get_lease_config (const char *iface, const char *uuid)
 {
 	GSList *parsed = NULL, *iter, *leases = NULL;
 	char *contents = NULL;
@@ -127,7 +144,7 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 	char **line, **split = NULL;
 	GHashTable *hash = NULL;
 
-	leasefile = get_leasefile_for_iface (iface, uuid);
+	leasefile = get_leasefile_for_iface (iface, uuid, FALSE);
 	if (!leasefile)
 		return NULL;
 
@@ -152,9 +169,9 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 		} else if (!strcmp (*line, "lease {")) {
 			/* Beginning of a new lease */
 			if (hash) {
-				g_warning ("%s: lease file %s malformed; new lease started "
-				           "without ending previous lease",
-				           __func__, leasefile);
+				nm_log_warn (LOGD_DHCP, "DHCP lease file %s malformed; new lease started "
+				             "without ending previous lease",
+				             leasefile);
 				g_hash_table_destroy (hash);
 			}
 
@@ -166,9 +183,9 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 
 	/* Check if the last lease in the file was properly ended */
 	if (hash) {
-		g_warning ("%s: lease file %s malformed; new lease started "
-		           "without ending previous lease",
-		           __func__, leasefile);
+		nm_log_warn (LOGD_DHCP, "DHCP lease file %s malformed; new lease started "
+		             "without ending previous lease",
+		             leasefile);
 		g_hash_table_destroy (hash);
 		hash = NULL;
 	}
@@ -195,8 +212,8 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 
 			/* Read lease expiration (in UTC) */
 			if (!strptime (data, "%w %Y/%m/%d %H:%M:%S", &expire)) {
-				g_warning ("%s: couldn't parse expire time '%s'",
-				           __func__, data);
+				nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file expire time '%s'",
+				             data);
 				continue;
 			}
 
@@ -238,27 +255,30 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 
 		/* IP4 address */
 		if (!inet_pton (AF_INET, data, &tmp)) {
-			g_warning ("%s: couldn't parse IP4 address '%s'", __func__, data);
+			nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file IP4 address '%s'", data);
 			goto error;
 		}
 		nm_ip4_address_set_address (addr, tmp.s_addr);
 
 		/* Netmask */
 		data = g_hash_table_lookup (hash, "option subnet-mask");
-		if (!data)
-			data = "255.255.255.0"; /* FIXME: assume class C? */
-		if (!inet_pton (AF_INET, data, &tmp)) {
-			g_warning ("%s: couldn't parse IP4 subnet mask '%s'", __func__, data);
-			goto error;
+		if (data) {
+			if (!inet_pton (AF_INET, data, &tmp)) {
+				nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file IP4 subnet mask '%s'", data);
+				goto error;
+			}
+			prefix = nm_utils_ip4_netmask_to_prefix (tmp.s_addr);
+		} else {
+			/* Get default netmask for the IP according to appropriate class. */
+			prefix = nm_utils_ip4_get_default_prefix (nm_ip4_address_get_address (addr));
 		}
-		prefix = nm_utils_ip4_netmask_to_prefix (tmp.s_addr);
 		nm_ip4_address_set_prefix (addr, prefix);
 
 		/* Gateway */
 		data = g_hash_table_lookup (hash, "option routers");
 		if (data) {
 			if (!inet_pton (AF_INET, data, &tmp)) {
-				g_warning ("%s: couldn't parse IP4 gateway '%s'", __func__, data);
+				nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file IP4 gateway '%s'", data);
 				goto error;
 			}
 			nm_ip4_address_set_gateway (addr, tmp.s_addr);
@@ -288,28 +308,39 @@ out:
 #define DHCP_HOSTNAME_FORMAT DHCP_HOSTNAME_TAG " \"%s\"; # added by NetworkManager"
 
 static gboolean
-merge_dhclient_config (NMDHCPDevice *device,
+merge_dhclient_config (const char *iface,
+                       const char *conf_file,
                        NMSettingIP4Config *s_ip4,
                        guint8 *anycast_addr,
-                       const char *contents,
-                       const char *orig,
+                       const char *orig_path,
                        GError **error)
 {
 	GString *new_contents;
+	char *orig_contents = NULL;
 	gboolean success = FALSE;
 
-	g_return_val_if_fail (device != NULL, FALSE);
-	g_return_val_if_fail (device->iface != NULL, FALSE);
-	
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (conf_file != NULL, FALSE);
+
 	new_contents = g_string_new (_("# Created by NetworkManager\n"));
 
+	if (g_file_test (orig_path, G_FILE_TEST_EXISTS)) {
+		GError *read_error = NULL;
+
+		if (!g_file_get_contents (orig_path, &orig_contents, NULL, &read_error)) {
+			nm_log_warn (LOGD_DHCP, "(%s): error reading dhclient configuration %s: %s",
+			             iface, orig_path, read_error->message);
+			g_error_free (read_error);
+		}
+	}
+
 	/* Add existing options, if any, but ignore stuff NM will replace. */
-	if (contents) {
+	if (orig_contents) {
 		char **lines = NULL, **line;
 
-		g_string_append_printf (new_contents, _("# Merged from %s\n\n"), orig);
+		g_string_append_printf (new_contents, _("# Merged from %s\n\n"), orig_path);
 
-		lines = g_strsplit_set (contents, "\n\r", 0);
+		lines = g_strsplit_set (orig_contents, "\n\r", 0);
 		for (line = lines; lines && *line; line++) {
 			gboolean ignore = FALSE;
 
@@ -334,6 +365,7 @@ merge_dhclient_config (NMDHCPDevice *device,
 
 		if (lines)
 			g_strfreev (lines);
+		g_free (orig_contents);
 	} else
 		g_string_append_c (new_contents, '\n');
 
@@ -374,14 +406,13 @@ merge_dhclient_config (NMDHCPDevice *device,
 		                        " initial-interval 1; \n"
 		                        " anycast-mac ethernet %02x:%02x:%02x:%02x:%02x:%02x;\n"
 		                        "}\n",
-		                        device->iface,
+		                        iface,
 		                        anycast_addr[0], anycast_addr[1],
 		                        anycast_addr[2], anycast_addr[3],
 		                        anycast_addr[4], anycast_addr[5]);
 	}
 
-	if (g_file_set_contents (device->conf_file, new_contents->str, -1, error))
-		success = TRUE;
+	success = g_file_set_contents (conf_file, new_contents->str, -1, error);
 
 	g_string_free (new_contents, TRUE);
 	return success;
@@ -393,17 +424,16 @@ merge_dhclient_config (NMDHCPDevice *device,
  * read their single config file and merge that into a custom per-interface
  * config file along with the NM options.
  */
-static gboolean
-create_dhclient_config (NMDHCPDevice *device,
+static char *
+create_dhclient_config (const char *iface,
                         NMSettingIP4Config *s_ip4,
                         guint8 *dhcp_anycast_addr)
 {
-	char *orig = NULL, *contents = NULL;
+	char *orig = NULL, *tmp, *conf_file = NULL;
 	GError *error = NULL;
 	gboolean success = FALSE;
-	char *tmp;
 
-	g_return_val_if_fail (device != NULL, FALSE);
+	g_return_val_if_fail (iface != NULL, FALSE);
 
 #if defined(TARGET_SUSE)
 	orig = g_strdup (SYSCONFDIR "/dhclient.conf");
@@ -412,41 +442,28 @@ create_dhclient_config (NMDHCPDevice *device,
 #elif defined(TARGET_GENTOO)
 	orig = g_strdup (SYSCONFDIR "/dhcp/dhclient.conf");
 #else
-	orig = g_strdup_printf (SYSCONFDIR "/dhclient-%s.conf", device->iface);
+	orig = g_strdup_printf (SYSCONFDIR "/dhclient-%s.conf", iface);
 #endif
 
 	if (!orig) {
-		nm_warning ("%s: not enough memory for dhclient options.", device->iface);
+		nm_log_warn (LOGD_DHCP, "(%s): not enough memory for dhclient options.", iface);
 		return FALSE;
 	}
 
-	tmp = g_strdup_printf ("nm-dhclient-%s.conf", device->iface);
-	device->conf_file = g_build_filename ("/var", "run", tmp, NULL);
+	tmp = g_strdup_printf ("nm-dhclient-%s.conf", iface);
+	conf_file = g_build_filename ("/var", "run", tmp, NULL);
 	g_free (tmp);
 
-	if (!g_file_test (orig, G_FILE_TEST_EXISTS))
-		goto out;
-
-	if (!g_file_get_contents (orig, &contents, NULL, &error)) {
-		nm_warning ("%s: error reading dhclient configuration %s: %s",
-		            device->iface, orig, error->message);
-		g_error_free (error);
-		goto out;
-	}
-
-out:
 	error = NULL;
-	if (merge_dhclient_config (device, s_ip4, dhcp_anycast_addr, contents, orig, &error))
-		success = TRUE;
-	else {
-		nm_warning ("%s: error creating dhclient configuration: %s",
-		            device->iface, error->message);
+	success = merge_dhclient_config (iface, conf_file, s_ip4, dhcp_anycast_addr, orig, &error);
+	if (!success) {
+		nm_log_warn (LOGD_DHCP, "(%s): error creating dhclient configuration: %s",
+		             iface, error->message);
 		g_error_free (error);
 	}
 
-	g_free (contents);
 	g_free (orig);
-	return success;
+	return conf_file;
 }
 
 
@@ -458,80 +475,136 @@ dhclient_child_setup (gpointer user_data G_GNUC_UNUSED)
 	setpgid (pid, pid);
 }
 
-
-GPid
-nm_dhcp_client_start (NMDHCPDevice *device,
-                      const char *uuid,
-                      NMSettingIP4Config *s_ip4,
-                      guint8 *dhcp_anycast_addr)
+static GPid
+dhclient_start (NMDHCPClient *client,
+                const char *ip_opt,
+                const char *mode_opt)
 {
-	GPtrArray *dhclient_argv = NULL;
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (client);
+	GPtrArray *argv = NULL;
 	GPid pid = 0;
 	GError *error = NULL;
-	char *pid_contents = NULL;
-
-	if (!g_file_test (DHCP_CLIENT_PATH, G_FILE_TEST_EXISTS)) {
-		nm_warning (DHCP_CLIENT_PATH " does not exist.");
-		goto out;
+	const char *iface, *uuid;
+	char *binary_name, *cmd_str;
+	gboolean ipv6;
+	guint log_domain;
+
+	g_return_val_if_fail (priv->pid_file == NULL, -1);
+	g_return_val_if_fail (ip_opt != NULL, -1);
+
+	iface = nm_dhcp_client_get_iface (client);
+	uuid = nm_dhcp_client_get_uuid (client);
+	ipv6 = nm_dhcp_client_get_ipv6 (client);
+
+	log_domain = ipv6 ? LOGD_DHCP6 : LOGD_DHCP4;
+
+	priv->pid_file = g_strdup_printf (LOCALSTATEDIR "/run/dhclient%s-%s.pid",
+	                                  ipv6 ? "6" : "",
+	                                  iface);
+	if (!priv->pid_file) {
+		nm_log_warn (log_domain, "(%s): not enough memory for dhcpcd options.", iface);
+		return -1;
 	}
 
-	device->pid_file = get_pidfile_for_iface (device->iface);
-	if (!device->pid_file) {
-		nm_warning ("%s: not enough memory for dhclient options.", device->iface);
-		goto out;
+	if (!g_file_test (priv->path, G_FILE_TEST_EXISTS)) {
+		nm_log_warn (log_domain, "%s does not exist.", priv->path);
+		return -1;
 	}
 
-	device->lease_file = get_leasefile_for_iface (device->iface, uuid);
-	if (!device->lease_file) {
-		nm_warning ("%s: not enough memory for dhclient options.", device->iface);
-		goto out;
+	/* Kill any existing dhclient from the pidfile */
+	binary_name = g_path_get_basename (priv->path);
+	nm_dhcp_client_stop_existing (priv->pid_file, binary_name);
+	g_free (binary_name);
+
+	priv->lease_file = get_leasefile_for_iface (iface, uuid, ipv6);
+	if (!priv->lease_file) {
+		nm_log_warn (log_domain, "(%s): not enough memory for dhclient options.", iface);
+		return -1;
 	}
 
-	if (!create_dhclient_config (device, s_ip4, dhcp_anycast_addr))
-		goto out;
+	argv = g_ptr_array_new ();
+	g_ptr_array_add (argv, (gpointer) priv->path);
 
-	/* Kill any existing dhclient bound to this interface */
-	if (g_file_get_contents (device->pid_file, &pid_contents, NULL, NULL)) {
-		unsigned long int tmp = strtoul (pid_contents, NULL, 10);
+	g_ptr_array_add (argv, (gpointer) "-d");
 
-		if (!((tmp == ULONG_MAX) && (errno == ERANGE)))
-			nm_dhcp_client_stop (device, (pid_t) tmp);
-		remove (device->pid_file);
-	}
+	g_ptr_array_add (argv, (gpointer) ip_opt);
 
-	dhclient_argv = g_ptr_array_new ();
-	g_ptr_array_add (dhclient_argv, (gpointer) DHCP_CLIENT_PATH);
+	if (mode_opt)
+		g_ptr_array_add (argv, (gpointer) mode_opt);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-d");
+	g_ptr_array_add (argv, (gpointer) "-sf");	/* Set script file */
+	g_ptr_array_add (argv, (gpointer) ACTION_SCRIPT_PATH );
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-sf");	/* Set script file */
-	g_ptr_array_add (dhclient_argv, (gpointer) ACTION_SCRIPT_PATH );
+	g_ptr_array_add (argv, (gpointer) "-pf");	/* Set pid file */
+	g_ptr_array_add (argv, (gpointer) priv->pid_file);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-pf");	/* Set pid file */
-	g_ptr_array_add (dhclient_argv, (gpointer) device->pid_file);
+	g_ptr_array_add (argv, (gpointer) "-lf");	/* Set lease file */
+	g_ptr_array_add (argv, (gpointer) priv->lease_file);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-lf");	/* Set lease file */
-	g_ptr_array_add (dhclient_argv, (gpointer) device->lease_file);
+	if (priv->conf_file) {
+		g_ptr_array_add (argv, (gpointer) "-cf");	/* Set interface config file */
+		g_ptr_array_add (argv, (gpointer) priv->conf_file);
+	}
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-cf");	/* Set interface config file */
-	g_ptr_array_add (dhclient_argv, (gpointer) device->conf_file);
+	g_ptr_array_add (argv, (gpointer) iface);
+	g_ptr_array_add (argv, NULL);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) device->iface);
-	g_ptr_array_add (dhclient_argv, NULL);
+	cmd_str = g_strjoinv (" ", (gchar **) argv->pdata);
+	nm_log_dbg (log_domain, "running: %s", cmd_str);
+	g_free (cmd_str);
 
-	if (!g_spawn_async (NULL, (char **) dhclient_argv->pdata, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+	if (!g_spawn_async (NULL, (char **) argv->pdata, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
 	                    &dhclient_child_setup, NULL, &pid, &error)) {
-		nm_warning ("dhclient failed to start.  error: '%s'", error->message);
+		nm_log_warn (log_domain, "dhclient failed to start: '%s'", error->message);
 		g_error_free (error);
-		goto out;
+		pid = -1;
+	} else
+		nm_log_info (log_domain, "dhclient started with pid %d", pid);
+
+	g_ptr_array_free (argv, TRUE);
+	return pid;
+}
+
+static GPid
+real_ip4_start (NMDHCPClient *client,
+                NMSettingIP4Config *s_ip4,
+                guint8 *dhcp_anycast_addr)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (client);
+	const char *iface;
+
+	iface = nm_dhcp_client_get_iface (client);
+
+	priv->conf_file = create_dhclient_config (iface, s_ip4, dhcp_anycast_addr);
+	if (!priv->conf_file) {
+		nm_log_warn (LOGD_DHCP4, "(%s): error creating dhclient configuration file.", iface);
+		return -1;
 	}
 
-	nm_info ("dhclient started with pid %d", pid);
+	return dhclient_start (client, "-4", NULL);
+}
 
-out:
-	g_free (pid_contents);
-	g_ptr_array_free (dhclient_argv, TRUE);
-	return pid;
+static GPid
+real_ip6_start (NMDHCPClient *client,
+                NMSettingIP6Config *s_ip6,
+                guint8 *dhcp_anycast_addr,
+                gboolean info_only)
+{
+	return dhclient_start (client, "-6", info_only ? "-S" : "-N");
+}
+
+static void
+real_stop (NMDHCPClient *client)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (client);
+
+	/* Chain up to parent */
+	NM_DHCP_CLIENT_CLASS (nm_dhcp_dhclient_parent_class)->stop (client);
+
+	if (priv->conf_file)
+		remove (priv->conf_file);
+	if (priv->pid_file)
+		remove (priv->pid_file);
 }
 
 static const char **
@@ -595,10 +668,11 @@ error:
 	return o;
 }
 
-gboolean
-nm_dhcp_client_process_classless_routes (GHashTable *options,
-                                         NMIP4Config *ip4_config,
-                                         guint32 *gwaddr)
+static gboolean
+real_ip4_process_classless_routes (NMDHCPClient *client,
+                                   GHashTable *options,
+                                   NMIP4Config *ip4_config,
+                                   guint32 *gwaddr)
 {
 	const char *str;
 	char **octets, **o;
@@ -624,7 +698,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 
 	o = octets = g_strsplit (str, " ", 0);
 	if (g_strv_length (octets) < 5) {
-		nm_warning ("Ignoring invalid classless static routes '%s'", str);
+		nm_log_warn (LOGD_DHCP4, "ignoring invalid classless static routes '%s'", str);
 		goto out;
 	}
 
@@ -632,7 +706,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 		route = NULL;
 		o = (char **) process_rfc3442_route ((const char **) o, &route);
 		if (!route) {
-			nm_warning ("Ignoring invalid classless static routes");
+			nm_log_warn (LOGD_DHCP4, "ignoring invalid classless static routes");
 			break;
 		}
 
@@ -653,8 +727,8 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 			inet_ntop (AF_INET, &tmp, addr, sizeof (addr));
 			tmp.s_addr = nm_ip4_route_get_next_hop (route);
 			inet_ntop (AF_INET, &tmp, nh, sizeof (nh));
-			nm_info ("  classless static route %s/%d gw %s",
-			         addr, nm_ip4_route_get_prefix (route), nh);
+			nm_log_info (LOGD_DHCP4, "  classless static route %s/%d gw %s",
+			             addr, nm_ip4_route_get_prefix (route), nh);
 		}
 	}
 
@@ -663,3 +737,42 @@ out:
 	return have_routes;
 }
 
+/***************************************************/
+
+static void
+nm_dhcp_dhclient_init (NMDHCPDhclient *self)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (self);
+
+	priv->path = nm_dhcp_dhclient_get_path (DHCLIENT_PATH);
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (object);
+
+	g_free (priv->pid_file);
+	g_free (priv->conf_file);
+	g_free (priv->lease_file);
+
+	G_OBJECT_CLASS (nm_dhcp_dhclient_parent_class)->dispose (object);
+}
+
+static void
+nm_dhcp_dhclient_class_init (NMDHCPDhclientClass *dhclient_class)
+{
+	NMDHCPClientClass *client_class = NM_DHCP_CLIENT_CLASS (dhclient_class);
+	GObjectClass *object_class = G_OBJECT_CLASS (dhclient_class);
+
+	g_type_class_add_private (dhclient_class, sizeof (NMDHCPDhclientPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+
+	client_class->ip4_start = real_ip4_start;
+	client_class->ip6_start = real_ip6_start;
+	client_class->stop = real_stop;
+	client_class->ip4_process_classless_routes = real_ip4_process_classless_routes;
+}
+
diff --git a/src/dhcp-manager/nm-dhcp-dhclient.h b/src/dhcp-manager/nm-dhcp-dhclient.h
new file mode 100644
index 0000000..be242de
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-dhclient.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP_DHCLIENT_H
+#define NM_DHCP_DHCLIENT_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nm-dhcp-client.h"
+
+#define NM_TYPE_DHCP_DHCLIENT            (nm_dhcp_dhclient_get_type ())
+#define NM_DHCP_DHCLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclient))
+#define NM_DHCP_DHCLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientClass))
+#define NM_IS_DHCP_DHCLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP_DHCLIENT))
+#define NM_IS_DHCP_DHCLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_DHCLIENT))
+#define NM_DHCP_DHCLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientClass))
+
+typedef struct {
+	NMDHCPClient parent;
+} NMDHCPDhclient;
+
+typedef struct {
+	NMDHCPClientClass parent;
+} NMDHCPDhclientClass;
+
+GType nm_dhcp_dhclient_get_type (void);
+
+GSList *nm_dhcp_dhclient_get_lease_config (const char *iface, const char *uuid);
+
+const char *nm_dhcp_dhclient_get_path (const char *try_first);
+
+#endif /* NM_DHCP_DHCLIENT_H */
+
diff --git a/src/dhcp-manager/nm-dhcp-dhcpcd.c b/src/dhcp-manager/nm-dhcp-dhcpcd.c
index a8d929a..56b7481 100644
--- a/src/dhcp-manager/nm-dhcp-dhcpcd.c
+++ b/src/dhcp-manager/nm-dhcp-dhcpcd.c
@@ -2,6 +2,7 @@
 /* nm-dhcp-dhcpcd.c - dhcpcd specific hooks for NetworkManager
  *
  * Copyright (C) 2008 Roy Marples
+ * Copyright (C) 2010 Dan Williams <dcbw@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,26 +32,47 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 
-#include "nm-dhcp-manager.h"
+#include "nm-dhcp-dhcpcd.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 
-#define NM_DHCP_MANAGER_PID_FILENAME	"dhcpcd"
-#define NM_DHCP_MANAGER_PID_FILE_EXT	"pid"
+G_DEFINE_TYPE (NMDHCPDhcpcd, nm_dhcp_dhcpcd, NM_TYPE_DHCP_DHCPCD)
+
+#define NM_DHCP_DHCPCD_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcdPrivate))
 
 #define ACTION_SCRIPT_PATH	LIBEXECDIR "/nm-dhcp-client.action"
 
+typedef struct {
+	const char *path;
+	char *pid_file;
+} NMDHCPDhcpcdPrivate;
 
-static char *
-get_pidfile_for_iface (const char * iface)
+const char *
+nm_dhcp_dhcpcd_get_path (const char *try_first)
 {
-	return g_strdup_printf ("/var/run/%s-%s.%s",
-	                        NM_DHCP_MANAGER_PID_FILENAME,
-	                        iface,
-	                        NM_DHCP_MANAGER_PID_FILE_EXT);
+	static const char *dhcpcd_paths[] = {
+		"/sbin/dhcpcd",
+		"/usr/sbin/dhcpcd",
+		"/usr/pkg/sbin/dhcpcd",
+		"/usr/local/sbin/dhcpcd",
+		NULL
+	};
+	const char **path = dhcpcd_paths;
+
+	if (strlen (try_first) && g_file_test (try_first, G_FILE_TEST_EXISTS))
+		return try_first;
+
+	while (*path != NULL) {
+		if (g_file_test (*path, G_FILE_TEST_EXISTS))
+			break;
+		path++;
+	}
+
+	return *path;
 }
 
 GSList *
-nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
+nm_dhcp_dhcpcd_get_lease_config (const char *iface, const char *uuid)
 {
 	return NULL;
 }
@@ -63,40 +85,41 @@ dhcpcd_child_setup (gpointer user_data G_GNUC_UNUSED)
 	setpgid (pid, pid);
 }
 
-
-GPid
-nm_dhcp_client_start (NMDHCPDevice *device,
-                      const char *uuid,
-                      NMSettingIP4Config *s_ip4,
-                      guint8 *dhcp_anycast_addr)
+static GPid
+real_ip4_start (NMDHCPClient *client,
+                NMSettingIP4Config *s_ip4,
+                guint8 *dhcp_anycast_addr)
 {
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (client);
 	GPtrArray *argv = NULL;
 	GPid pid = 0;
 	GError *error = NULL;
-	char *pid_contents = NULL;
+	char *pid_contents = NULL, *binary_name, *cmd_str;
+	const char *iface, *uuid, *hostname;
 
-	if (!g_file_test (DHCP_CLIENT_PATH, G_FILE_TEST_EXISTS)) {
-		nm_warning (DHCP_CLIENT_PATH " does not exist.");
-		goto out;
-	}
+	g_return_val_if_fail (priv->pid_file == NULL, -1);
 
-	device->pid_file = get_pidfile_for_iface (device->iface);
-	if (!device->pid_file) {
-		nm_warning ("%s: not enough memory for dhcpcd options.", device->iface);
-		goto out;
-	}
+	iface = nm_dhcp_client_get_iface (client);
+	uuid = nm_dhcp_client_get_uuid (client);
 
-	/* Kill any existing dhcpcd bound to this interface */
-	if (g_file_get_contents (device->pid_file, &pid_contents, NULL, NULL)) {
-		unsigned long int tmp = strtoul (pid_contents, NULL, 10);
+	priv->pid_file = g_strdup_printf (LOCALSTATEDIR "/run/dhcpcd-%s.pid", iface);
+	if (!priv->pid_file) {
+		nm_log_warn (LOGD_DHCP4, "(%s): not enough memory for dhcpcd options.", iface);
+		return -1;
+	}
 
-		if (!((tmp == ULONG_MAX) && (errno == ERANGE)))
-			nm_dhcp_client_stop (device, (pid_t) tmp);
-		remove (device->pid_file);
+	if (!g_file_test (priv->path, G_FILE_TEST_EXISTS)) {
+		nm_log_warn (LOGD_DHCP4, "%s does not exist.", priv->path);
+		return -1;
 	}
 
+	/* Kill any existing dhcpcd from the pidfile */
+	binary_name = g_path_get_basename (priv->path);
+	nm_dhcp_client_stop_existing (priv->pid_file, binary_name);
+	g_free (binary_name);
+
 	argv = g_ptr_array_new ();
-	g_ptr_array_add (argv, (gpointer) DHCP_CLIENT_PATH);
+	g_ptr_array_add (argv, (gpointer) priv->path);
 
 	g_ptr_array_add (argv, (gpointer) "-B");	/* Don't background on lease (disable fork()) */
 
@@ -107,28 +130,58 @@ nm_dhcp_client_start (NMDHCPDevice *device,
 	g_ptr_array_add (argv, (gpointer) "-c");	/* Set script file */
 	g_ptr_array_add (argv, (gpointer) ACTION_SCRIPT_PATH );
 
-	g_ptr_array_add (argv, (gpointer) device->iface);
+	hostname = nm_setting_ip4_config_get_dhcp_hostname (s_ip4);
+	if (hostname && strlen (hostname)) {
+		g_ptr_array_add (argv, (gpointer) "-h");	/* Send hostname to DHCP server */
+		g_ptr_array_add (argv, (gpointer) hostname );
+	}
+
+	g_ptr_array_add (argv, (gpointer) iface);
 	g_ptr_array_add (argv, NULL);
 
+	cmd_str = g_strjoinv (" ", (gchar **) argv->pdata);
+	nm_log_dbg (LOGD_DHCP4, "running: %s", cmd_str);
+	g_free (cmd_str);
+
 	if (!g_spawn_async (NULL, (char **) argv->pdata, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
 	                    &dhcpcd_child_setup, NULL, &pid, &error)) {
-		nm_warning ("dhcpcd failed to start.  error: '%s'", error->message);
+		nm_log_warn (LOGD_DHCP4, "dhcpcd failed to start.  error: '%s'", error->message);
 		g_error_free (error);
-		goto out;
-	}
+	} else
+		nm_log_info (LOGD_DHCP4, "dhcpcd started with pid %d", pid);
 
-	nm_info ("dhcpcd started with pid %d", pid);
-
-out:
 	g_free (pid_contents);
 	g_ptr_array_free (argv, TRUE);
 	return pid;
 }
 
-gboolean
-nm_dhcp_client_process_classless_routes (GHashTable *options,
-                                         NMIP4Config *ip4_config,
-                                         guint32 *gwaddr)
+static GPid
+real_ip6_start (NMDHCPClient *client,
+                NMSettingIP6Config *s_ip6,
+                guint8 *dhcp_anycast_addr,
+                gboolean info_only)
+{
+	nm_log_warn (LOGD_DHCP6, "the dhcpcd backend does not support IPv6.");
+	return -1;
+}
+
+static void
+real_stop (NMDHCPClient *client)
+{
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (client);
+
+	/* Chain up to parent */
+	NM_DHCP_CLIENT_CLASS (nm_dhcp_dhcpcd_parent_class)->stop (client);
+
+	if (priv->pid_file)
+		remove (priv->pid_file);
+}
+
+static gboolean
+real_ip4_process_classless_routes (NMDHCPClient *client,
+                                   GHashTable *options,
+                                   NMIP4Config *ip4_config,
+                                   guint32 *gwaddr)
 {
 	const char *str;
 	char **routes, **r;
@@ -150,7 +203,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 		goto out;
 
 	if ((g_strv_length (routes) % 2) != 0) {
-		nm_info ("  classless static routes provided, but invalid");
+		nm_log_warn (LOGD_DHCP4, "  classless static routes provided, but invalid");
 		goto out;
 	}
 
@@ -167,16 +220,16 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 			errno = 0;
 			rt_cidr = strtol (slash + 1, NULL, 10);
 			if ((errno == EINVAL) || (errno == ERANGE)) {
-				nm_warning ("DHCP provided invalid classless static route cidr: '%s'", slash + 1);
+				nm_log_warn (LOGD_DHCP4, "DHCP provided invalid classless static route cidr: '%s'", slash + 1);
 				continue;
 			}
 		}
 		if (inet_pton (AF_INET, *r, &rt_addr) <= 0) {
-			nm_warning ("DHCP provided invalid classless static route address: '%s'", *r);
+			nm_log_warn (LOGD_DHCP4, "DHCP provided invalid classless static route address: '%s'", *r);
 			continue;
 		}
 		if (inet_pton (AF_INET, *(r + 1), &rt_route) <= 0) {
-			nm_warning ("DHCP provided invalid classless static route gateway: '%s'", *(r + 1));
+			nm_log_warn (LOGD_DHCP4, "DHCP provided invalid classless static route gateway: '%s'", *(r + 1));
 			continue;
 		}
 
@@ -192,7 +245,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 
 
 			nm_ip4_config_take_route (ip4_config, route);
-			nm_info ("  classless static route %s/%d gw %s", *r, rt_cidr, *(r + 1));
+			nm_log_info (LOGD_DHCP4, "  classless static route %s/%d gw %s", *r, rt_cidr, *(r + 1));
 		}
 	}
 
@@ -201,3 +254,40 @@ out:
 	return have_routes;
 }
 
+/***************************************************/
+
+static void
+nm_dhcp_dhcpcd_init (NMDHCPDhcpcd *self)
+{
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (self);
+
+	priv->path = nm_dhcp_dhcpcd_get_path (DHCPCD_PATH);
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (object);
+
+	g_free (priv->pid_file);
+
+	G_OBJECT_CLASS (nm_dhcp_dhcpcd_parent_class)->dispose (object);
+}
+
+static void
+nm_dhcp_dhcpcd_class_init (NMDHCPDhcpcdClass *dhcpcd_class)
+{
+	NMDHCPClientClass *client_class = NM_DHCP_CLIENT_CLASS (dhcpcd_class);
+	GObjectClass *object_class = G_OBJECT_CLASS (dhcpcd_class);
+
+	g_type_class_add_private (dhcpcd_class, sizeof (NMDHCPDhcpcdPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+
+	client_class->ip4_start = real_ip4_start;
+	client_class->ip6_start = real_ip6_start;
+	client_class->stop = real_stop;
+	client_class->ip4_process_classless_routes = real_ip4_process_classless_routes;
+}
+
diff --git a/src/dhcp-manager/nm-dhcp-dhcpcd.h b/src/dhcp-manager/nm-dhcp-dhcpcd.h
new file mode 100644
index 0000000..586c569
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-dhcpcd.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP_DHCPCD_H
+#define NM_DHCP_DHCPCD_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nm-dhcp-client.h"
+
+#define NM_TYPE_DHCP_DHCPCD            (nm_dhcp_dhcpcd_get_type ())
+#define NM_DHCP_DHCPCD(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcd))
+#define NM_DHCP_DHCPCD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcdClass))
+#define NM_IS_DHCP_DHCPCD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP_DHCPCD))
+#define NM_IS_DHCP_DHCPCD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_DHCPCD))
+#define NM_DHCP_DHCPCD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcdClass))
+
+typedef struct {
+	NMDHCPClient parent;
+} NMDHCPDhcpcd;
+
+typedef struct {
+	NMDHCPClientClass parent;
+} NMDHCPDhcpcdClass;
+
+GType nm_dhcp_dhcpcd_get_type (void);
+
+GSList *nm_dhcp_dhcpcd_get_lease_config (const char *iface, const char *uuid);
+
+const char *nm_dhcp_dhcpcd_get_path (const char *try_first);
+
+#endif /* NM_DHCP_DHCPCD_H */
+
diff --git a/src/dhcp-manager/nm-dhcp-manager.c b/src/dhcp-manager/nm-dhcp-manager.c
index c3ca358..94109ad 100644
--- a/src/dhcp-manager/nm-dhcp-manager.c
+++ b/src/dhcp-manager/nm-dhcp-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  *
  */
@@ -25,8 +25,6 @@
 #include <glib/gi18n.h>
 #include <dbus/dbus.h>
 #include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
 #include <sys/wait.h>
 #include <signal.h>
 #include <string.h>
@@ -37,247 +35,67 @@
 #include <stdio.h>
 
 #include "nm-dhcp-manager.h"
+#include "nm-dhcp-dhclient.h"
+#include "nm-dhcp-dhcpcd.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-dbus-manager.h"
 #include "nm-hostname-provider.h"
 #include "nm-dbus-glib-types.h"
 #include "nm-glib-compat.h"
 
-#define NM_DHCP_CLIENT_DBUS_SERVICE "org.freedesktop.nm_dhcp_client"
-#define NM_DHCP_CLIENT_DBUS_IFACE   "org.freedesktop.nm_dhcp_client"
-
-#define NM_DHCP_TIMEOUT   	45 /* DHCP timeout, in seconds */
-
-typedef struct {
-	NMDBusManager * dbus_mgr;
-	GHashTable *	devices;
-	DBusGProxy *	proxy;
-	NMHostnameProvider *hostname_provider;
-} NMDHCPManagerPrivate;
-
-
-#define NM_DHCP_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_MANAGER, NMDHCPManagerPrivate))
-
-G_DEFINE_TYPE (NMDHCPManager, nm_dhcp_manager, G_TYPE_OBJECT)
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
 
-enum {
-	STATE_CHANGED,
-	TIMEOUT,
-	LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-static NMDHCPManager *nm_dhcp_manager_new (void);
-
-static void nm_dhcp_manager_cancel_transaction_real (NMDHCPDevice *device);
-
-static void hostname_provider_destroyed (gpointer data, GObject *destroyed_object);
-
-NMDHCPManager *
-nm_dhcp_manager_get (void)
+GQuark
+nm_dhcp_manager_error_quark (void)
 {
-	static NMDHCPManager *singleton = NULL;
+    static GQuark ret = 0;
 
-	if (!singleton)
-		singleton = nm_dhcp_manager_new ();
-	else
-		g_object_ref (singleton);
+    if (ret == 0)
+        ret = g_quark_from_static_string ("nm_dhcp_manager_error");
 
-	g_assert (singleton);
-	return singleton;
+    return ret;
 }
 
-static void
-nm_dhcp_manager_init (NMDHCPManager *manager)
+GType
+nm_dhcp_manager_error_get_type (void)
 {
-}
-
-static void
-finalize (GObject *object)
-{
-	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (object);
-
-	if (priv->hostname_provider) {
-		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, object);
-		priv->hostname_provider = NULL;
-	}
+    static GType etype = 0;
 
-	g_hash_table_destroy (priv->devices);
-	g_object_unref (priv->proxy);
-	g_object_unref (priv->dbus_mgr);
-
-	G_OBJECT_CLASS (nm_dhcp_manager_parent_class)->finalize (object);
+    if (etype == 0) {
+        static const GEnumValue values[] = {
+            ENUM_ENTRY (NM_DHCP_MANAGER_ERROR_BAD_CLIENT, "BadClient"),
+            ENUM_ENTRY (NM_DHCP_MANAGER_ERROR_INTERNAL,   "InternalError"),
+            { 0, 0, 0 }
+        };
+        etype = g_enum_register_static ("NMDhcpManagerError", values);
+    }
+    return etype;
 }
 
-static void
-nm_dhcp_manager_class_init (NMDHCPManagerClass *manager_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (manager_class);
-
-	g_type_class_add_private (manager_class, sizeof (NMDHCPManagerPrivate));
-
-	/* virtual methods */
-	object_class->finalize = finalize;
-
-	/* signals */
-	signals[STATE_CHANGED] =
-		g_signal_new ("state-changed",
-					  G_OBJECT_CLASS_TYPE (object_class),
-					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMDHCPManagerClass, state_changed),
-					  NULL, NULL,
-					  _nm_marshal_VOID__STRING_UCHAR,
-					  G_TYPE_NONE, 2,
-					  G_TYPE_STRING,
-					  G_TYPE_UCHAR);
-
-	signals[TIMEOUT] =
-		g_signal_new ("timeout",
-					  G_OBJECT_CLASS_TYPE (object_class),
-					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMDHCPManagerClass, timeout),
-					  NULL, NULL,
-					  g_cclosure_marshal_VOID__STRING,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_STRING);
-}
-
-static gboolean state_is_bound (guint8 state)
-{
-	if ((state == DHC_BOUND)
-	    || (state == DHC_RENEW)
-	    || (state == DHC_REBOOT)
-	    || (state == DHC_REBIND)
-	    || (state == DHC_IPV4LL))
-		return TRUE;
-
-	return FALSE;
-}
-
-
-static void
-nm_dhcp_device_timeout_cleanup (NMDHCPDevice * device)
-{
-	if (device->timeout_id) {
-		g_source_remove (device->timeout_id);
-		device->timeout_id = 0;
-	}
-}
-
-static void
-nm_dhcp_device_watch_cleanup (NMDHCPDevice * device)
-{
-	if (device->watch_id) {
-		g_source_remove (device->watch_id);
-		device->watch_id = 0;
-	}
-}
-
-static void
-nm_dhcp_device_destroy (NMDHCPDevice *device)
-{
-	int ignored;
-
-	nm_dhcp_device_timeout_cleanup (device);
+#define NM_DHCP_CLIENT_DBUS_SERVICE "org.freedesktop.nm_dhcp_client"
+#define NM_DHCP_CLIENT_DBUS_IFACE   "org.freedesktop.nm_dhcp_client"
 
-	if (device->pid)
-		nm_dhcp_client_stop (device, device->pid);
+#define DHCP_TIMEOUT 45 /* default DHCP timeout, in seconds */
 
-	if (device->options)
-		g_hash_table_destroy (device->options);
+static NMDHCPManager *singleton = NULL;
 
-	if (device->conf_file) {
-		ignored = unlink (device->conf_file);
-		g_free (device->conf_file);
-	}
+typedef GSList * (*GetLeaseConfigFunc) (const char *iface, const char *uuid);
 
-	g_free (device->pid_file);
-	g_free (device->lease_file);
-	g_free (device->iface);
+typedef struct {
+	GType               client_type;
+	GetLeaseConfigFunc  get_lease_config_func;
 
-	g_slice_free (NMDHCPDevice, device);
-}
+	NMDBusManager *     dbus_mgr;
+	GHashTable *        clients;
+	DBusGProxy *        proxy;
+	NMHostnameProvider *hostname_provider;
+} NMDHCPManagerPrivate;
 
 
-static inline const char *
-state_to_string (guint32 state)
-{
-	switch (state)
-	{
-		case DHC_PREINIT:
-			return "preinit";
-		case DHC_BOUND:
-			return "bound";
-		case DHC_IPV4LL:
-			return "bound (ipv4ll)";
-		case DHC_RENEW:
-			return "renew";
-		case DHC_REBOOT:
-			return "reboot";
-		case DHC_REBIND:
-			return "rebind";
-		case DHC_STOP:
-			return "stop";
-		case DHC_MEDIUM:
-			return "medium";
-		case DHC_TIMEOUT:
-			return "timeout";
-		case DHC_FAIL:
-			return "fail";
-		case DHC_EXPIRE:
-			return "expire";
-		case DHC_RELEASE:
-			return "release";
-		case DHC_START:
-			return "successfully started";
-		case DHC_ABEND:
-			return "abnormal exit";
-		case DHC_END:
-			return "normal exit";
-		default:
-			break;
-	}
-	return NULL;
-}
+#define NM_DHCP_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_MANAGER, NMDHCPManagerPrivate))
 
-static inline guint32
-string_to_state (const char *state)
-{
-	if (strcmp("PREINIT", state) == 0)
-		return DHC_PREINIT;
-	else if (strcmp("BOUND", state) == 0)
-		return DHC_BOUND;
-	else if (strcmp("IPV4LL", state) == 0)
-		return DHC_IPV4LL;
-	else if (strcmp("RENEW", state) == 0)
-		return DHC_RENEW;
-	else if (strcmp("REBOOT", state) == 0)
-		return DHC_REBOOT;
-	else if (strcmp("REBIND", state) == 0)
-		return DHC_REBIND;
-	else if (strcmp("STOP", state) == 0)
-		return DHC_STOP;
-	else if (strcmp("MEDIUM", state) == 0)
-		return DHC_MEDIUM;
-	else if (strcmp("TIMEOUT", state) == 0)
-		return DHC_TIMEOUT;
-	else if (strcmp("FAIL", state) == 0)
-		return DHC_FAIL;
-	else if (strcmp("EXPIRE", state) == 0)
-		return DHC_EXPIRE;
-	else if (strcmp("RELEASE", state) == 0)
-		return DHC_RELEASE;
-	else if (strcmp("START", state) == 0)
-		return DHC_START;
-	else if (strcmp("ABEND", state) == 0)
-		return DHC_ABEND;
-	else if (strcmp("END", state) == 0)
-		return DHC_END;
-	else
-		return 255;
-}
+G_DEFINE_TYPE (NMDHCPManager, nm_dhcp_manager, G_TYPE_OBJECT)
 
 static char *
 garray_to_string (GArray *array, const char *key)
@@ -307,84 +125,78 @@ garray_to_string (GArray *array, const char *key)
 
 	converted = str->str;
 	if (!g_utf8_validate (converted, -1, NULL))
-		nm_warning ("%s: DHCP option '%s' couldn't be converted to UTF-8", __func__, key);
+		nm_log_warn (LOGD_DHCP, "DHCP option '%s' couldn't be converted to UTF-8", key);
 	g_string_free (str, FALSE);
 	return converted;
 }
 
-static char *
-get_option (GHashTable *hash, const char *key)
+static NMDHCPClient *
+get_client_for_pid (NMDHCPManager *manager, GPid pid)
 {
-	GValue *value;
+	NMDHCPManagerPrivate *priv;
+	GHashTableIter iter;
+	gpointer value;
 
-	value = g_hash_table_lookup (hash, key);
-	if (value == NULL)
-		return NULL;
+	g_return_val_if_fail (manager != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), NULL);
 
-	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
-		nm_warning ("Unexpected key %s value type was not "
-		            "DBUS_TYPE_G_UCHAR_ARRAY",
-		            (char *) key);
-		return NULL;
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+
+	g_hash_table_iter_init (&iter, priv->clients);
+	while (g_hash_table_iter_next (&iter, NULL, &value)) {
+		NMDHCPClient *candidate = NM_DHCP_CLIENT (value);
+
+		if (nm_dhcp_client_get_pid (candidate) == pid)
+			return candidate;
 	}
 
-	return garray_to_string ((GArray *) g_value_get_boxed (value), key);
+	return NULL;
 }
 
-static void
-copy_option (gpointer key,
-             gpointer value,
-             gpointer user_data)
+static NMDHCPClient *
+get_client_for_iface (NMDHCPManager *manager,
+                      const char *iface,
+                      gboolean ip6)
 {
-	NMDHCPDevice * device = (NMDHCPDevice *) user_data;
-	const char *str_key = (const char *) key;
-	char *str_value = NULL;
+	NMDHCPManagerPrivate *priv;
+	GHashTableIter iter;
+	gpointer value;
 
-	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
-		nm_warning ("Unexpected key %s value type was not "
-		            "DBUS_TYPE_G_UCHAR_ARRAY",
-		            str_key);
-		return;
+	g_return_val_if_fail (manager != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), NULL);
+	g_return_val_if_fail (iface, NULL);
+
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+
+	g_hash_table_iter_init (&iter, priv->clients);
+	while (g_hash_table_iter_next (&iter, NULL, &value)) {
+		NMDHCPClient *candidate = NM_DHCP_CLIENT (value);
+
+		if (   !strcmp (iface, nm_dhcp_client_get_iface (candidate))
+		    && (nm_dhcp_client_get_ipv6 (candidate) == ip6))
+			return candidate;
 	}
 
-	str_value = garray_to_string ((GArray *) g_value_get_boxed (value), str_key);
-	if (str_value)
-		g_hash_table_insert (device->options, g_strdup (str_key), str_value);
+	return NULL;
 }
 
-static void
-handle_options (NMDHCPManager * manager,
-                NMDHCPDevice * device,
-                GHashTable * options,
-                const char * reason)
+static char *
+get_option (GHashTable *hash, const char *key)
 {
-	guint32 old_state = device->state;
-	guint32 new_state = string_to_state (reason);
-
-	/* Clear old and save new DHCP options */
-	g_hash_table_remove_all (device->options);
-	g_hash_table_foreach (options, copy_option, device);
+	GValue *value;
 
-	if (old_state == new_state)
-		return;
+	value = g_hash_table_lookup (hash, key);
+	if (value == NULL)
+		return NULL;
 
-	/* Handle changed device state */
-	if (state_is_bound (new_state)) {
-		/* Cancel the timeout if the DHCP client is now bound */
-		nm_dhcp_device_timeout_cleanup (device);
+	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
+		nm_log_warn (LOGD_DHCP, "unexpected key %s value type was not "
+		             "DBUS_TYPE_G_UCHAR_ARRAY",
+		             (char *) key);
+		return NULL;
 	}
 
-	device->state = new_state;
-	nm_info ("DHCP: device %s state changed %s -> %s",
-	         device->iface,
-	         state_to_string (old_state),
-	         state_to_string (device->state));
-
-	g_signal_emit (G_OBJECT (device->manager),
-	               signals[STATE_CHANGED],
-	               0,
-	               device->iface,
-	               device->state);
+	return garray_to_string ((GArray *) g_value_get_boxed (value), key);
 }
 
 static void
@@ -392,57 +204,54 @@ nm_dhcp_manager_handle_event (DBusGProxy *proxy,
                               GHashTable *options,
                               gpointer user_data)
 {
-	NMDHCPManager * manager;
-	NMDHCPManagerPrivate * priv;
-	NMDHCPDevice * device;
-	char * iface = NULL;
-	char * pid_str = NULL;
-	char * reason = NULL;
+	NMDHCPManager *manager;
+	NMDHCPManagerPrivate *priv;
+	NMDHCPClient *client;
+	char *iface = NULL;
+	char *pid_str = NULL;
+	char *reason = NULL;
 	unsigned long temp;
-	pid_t pid;
 
 	manager = NM_DHCP_MANAGER (user_data);
 	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
 
 	iface = get_option (options, "interface");
 	if (iface == NULL) {
-		nm_warning ("DHCP event didn't have associated interface.");
-		goto out;
-	}
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (device == NULL) {
-		nm_warning ("Unhandled DHCP event for interface %s", iface);
+		nm_log_warn (LOGD_DHCP, "DHCP event didn't have associated interface.");
 		goto out;
 	}
 
 	pid_str = get_option (options, "pid");
 	if (pid_str == NULL) {
-		nm_warning ("DHCP event didn't have associated PID.");
+		nm_log_warn (LOGD_DHCP, "DHCP event didn't have associated PID.");
 		goto out;
 	}
 
-	temp = strtoul(pid_str, NULL, 10);
+	temp = strtoul (pid_str, NULL, 10);
 	if ((temp == ULONG_MAX) && (errno == ERANGE)) {
-		nm_warning ("Couldn't convert PID");
+		nm_log_warn (LOGD_DHCP, "couldn't convert PID");
+		goto out;
+	}
+
+	client = get_client_for_pid (manager, (GPid) temp);
+	if (client == NULL) {
+		nm_log_warn (LOGD_DHCP, "unhandled DHCP event for interface %s", iface);
 		goto out;
 	}
 
-	pid = (pid_t) temp;
-	if (pid != device->pid) {
-		nm_warning ("Received DHCP event from unexpected PID %u (expected %u)",
-		            pid,
-		            device->pid);
+	if (strcmp (iface, nm_dhcp_client_get_iface (client))) {
+		nm_log_warn (LOGD_DHCP, "received DHCP event from unexpected interface '%s' (expected '%s')",
+		             iface, nm_dhcp_client_get_iface (client));
 		goto out;
 	}
 
 	reason = get_option (options, "reason");
 	if (reason == NULL) {
-		nm_warning ("DHCP event didn't have a reason");
+		nm_log_warn (LOGD_DHCP, "DHCP event didn't have a reason");
 		goto out;
 	}
 
-	handle_options (manager, device, options, reason);
+	nm_dhcp_client_new_options (client, options, reason);
 
 out:
 	g_free (iface);
@@ -450,37 +259,91 @@ out:
 	g_free (reason);
 }
 
-static NMDHCPManager *
-nm_dhcp_manager_new (void)
+static GType
+get_client_type (const char *client, GError **error)
 {
-	NMDHCPManager *manager;
-	NMDHCPManagerPrivate *priv;
-	DBusGConnection * g_connection;
+	const char *dhclient_path = NULL;
+	const char *dhcpcd_path = NULL;
 
-	manager = g_object_new (NM_TYPE_DHCP_MANAGER, NULL);
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+	dhclient_path = nm_dhcp_dhclient_get_path (DHCLIENT_PATH);
+	dhcpcd_path = nm_dhcp_dhcpcd_get_path (DHCPCD_PATH);
 
-	priv->devices = g_hash_table_new_full (g_str_hash, g_str_equal,
-										   NULL,
-										   (GDestroyNotify) nm_dhcp_device_destroy);
-	if (!priv->devices) {
-		nm_warning ("Error: not enough memory to initialize DHCP manager "
-		            "tables");
-		g_object_unref (manager);
-		manager = NULL;
-		goto out;
+	if (!client) {
+		if (dhclient_path)
+			return NM_TYPE_DHCP_DHCLIENT;
+		else if (dhcpcd_path)
+			return NM_TYPE_DHCP_DHCPCD;
+		else {
+			g_set_error_literal (error,
+			                     NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+			                     _("no usable DHCP client could be found."));
+			return 0;
+		}
+	}
+
+	if (!strcmp (client, "dhclient")) {
+		if (!dhclient_path) {
+			g_set_error_literal (error,
+			                     NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+			                     _("'dhclient' could be found."));
+			return 0;
+		}
+		return NM_TYPE_DHCP_DHCLIENT;
+	}
+
+	if (!strcmp (client, "dhcpcd")) {
+		if (!dhcpcd_path) {
+			g_set_error_literal (error,
+			                     NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+			                     _("'dhcpcd' could be found."));
+			return 0;
+		}
+		return NM_TYPE_DHCP_DHCPCD;
 	}
 
+	g_set_error (error,
+	             NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+	             _("unsupported DHCP client '%s'"), client);
+	return 0;
+}
+
+NMDHCPManager *
+nm_dhcp_manager_new (const char *client, GError **error)
+{
+	NMDHCPManagerPrivate *priv;
+	DBusGConnection *g_connection;
+	GType client_type;
+
+	client_type = get_client_type (client, error);
+	if (!client_type)
+		return NULL;
+
+	g_warn_if_fail (singleton == NULL);
+
+	singleton = g_object_new (NM_TYPE_DHCP_MANAGER, NULL);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (singleton);
+
+	/* Client-specific setup */
+	priv->client_type = client_type;
+	if (priv->client_type == NM_TYPE_DHCP_DHCLIENT)
+		priv->get_lease_config_func = nm_dhcp_dhclient_get_lease_config;
+	else if (priv->client_type == NM_TYPE_DHCP_DHCPCD)
+		priv->get_lease_config_func = nm_dhcp_dhcpcd_get_lease_config;
+	else
+		g_assert_not_reached ();
+
+	priv->clients = g_hash_table_new_full (g_direct_hash, g_direct_equal,
+	                                       NULL,
+	                                       (GDestroyNotify) g_object_unref);
+	g_assert (priv->clients);
+
 	priv->dbus_mgr = nm_dbus_manager_get ();
 	g_connection = nm_dbus_manager_get_connection (priv->dbus_mgr);
 	priv->proxy = dbus_g_proxy_new_for_name (g_connection,
 	                                         NM_DHCP_CLIENT_DBUS_SERVICE,
 	                                         "/",
 	                                         NM_DHCP_CLIENT_DBUS_IFACE);
-	if (!priv->proxy) {
-		nm_warning ("Error: could not init DHCP manager proxy");
-		g_object_unref (manager);
-	}
+	g_assert (priv->proxy);
 
 	dbus_g_proxy_add_signal (priv->proxy,
 	                         "Event",
@@ -488,649 +351,303 @@ nm_dhcp_manager_new (void)
 	                         G_TYPE_INVALID);
 
 	dbus_g_proxy_connect_signal (priv->proxy, "Event",
-								 G_CALLBACK (nm_dhcp_manager_handle_event),
-								 manager,
-								 NULL);
+	                             G_CALLBACK (nm_dhcp_manager_handle_event),
+	                             singleton,
+	                             NULL);
 
-out:
-	return manager;
+	return singleton;
 }
 
+#define STATE_ID_TAG "state-id"
+#define TIMEOUT_ID_TAG "timeout-id"
 
-/*
- * nm_dhcp_manager_handle_timeout
- *
- * Called after timeout of a DHCP transaction to notify device of the failure.
- *
- */
-static gboolean
-nm_dhcp_manager_handle_timeout (gpointer user_data)
+static void
+remove_client (NMDHCPManager *self, NMDHCPClient *client)
 {
-	NMDHCPDevice *device = (NMDHCPDevice *) user_data;
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
+	guint id;
 
-	nm_info ("(%s): DHCP transaction took too long, stopping it.", device->iface);
+	id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (client), STATE_ID_TAG));
+	if (id)
+		g_signal_handler_disconnect (client, id);
 
-	nm_dhcp_manager_cancel_transaction (device->manager, device->iface);
+	id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (client), TIMEOUT_ID_TAG));
+	if (id)
+		g_signal_handler_disconnect (client, id);
 
-	g_signal_emit (G_OBJECT (device->manager), signals[TIMEOUT], 0, device->iface);
+	/* Stopping the client is left up to the controlling device
+	 * explicitly since we may want to quit NetworkManager but not terminate
+	 * the DHCP client.
+	 */
 
-	return FALSE;
+	g_hash_table_remove (priv->clients, client);
 }
 
-static NMDHCPDevice *
-nm_dhcp_device_new (NMDHCPManager *manager, const char *iface)
+static void
+client_state_changed (NMDHCPClient *client, NMDHCPState new_state, gpointer user_data)
 {
-	NMDHCPDevice *device;
-	GHashTable * hash = NM_DHCP_MANAGER_GET_PRIVATE (manager)->devices;
-
-	device = g_slice_new0 (NMDHCPDevice);
-	if (!device) {
-		nm_warning ("%s: Out of memory creating DHCP transaction object.", iface);
-		return NULL;
-	}
-
-	device->iface = g_strdup (iface);
-	if (!device) {
-		nm_warning ("%s: Out of memory creating DHCP transaction object "
-		            "property 'iface'.",
-		            iface);
-		goto error;
-	}
-	
-	device->manager = manager;
-
-	/* Do this after the transaction cancel since that clears options out */
-	device->options = g_hash_table_new_full (g_str_hash,
-	                                         g_str_equal,
-	                                         g_free,
-	                                         g_free);
-	if (!device->options) {
-		nm_warning ("%s: Out of memory creating DHCP transaction object "
-		            "property 'options'.",
-		            iface);
-		goto error;
-	}
-
-	g_hash_table_insert (hash, device->iface, device);
-	return device;
-
-error:
-	nm_dhcp_device_destroy (device);
-	return NULL;
+	if (new_state == DHC_ABEND || new_state == DHC_END)
+		remove_client (NM_DHCP_MANAGER (user_data), client);
 }
 
+static void
+client_timeout (NMDHCPClient *client, gpointer user_data)
+{
+	remove_client (NM_DHCP_MANAGER (user_data), client);
+}
 
-/*
- * dhcp_watch_cb
- *
- * Watch our child dhclient process and get notified of events from it.
- *
- */
-static void dhcp_watch_cb (GPid pid, gint status, gpointer user_data)
+static void
+add_client (NMDHCPManager *self, NMDHCPClient *client)
 {
-	NMDHCPDevice *device = (NMDHCPDevice *)user_data;
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
+	guint id;
 
-	if (!WIFEXITED (status)) {
-		device->state = DHC_ABEND;
-		nm_warning ("dhcp client died abnormally");
-	}
-	device->pid = 0;
+	id = g_signal_connect (client, "state-changed", G_CALLBACK (client_state_changed), self);
+	g_object_set_data (G_OBJECT (client), STATE_ID_TAG, GUINT_TO_POINTER (id));
 
-	nm_dhcp_device_watch_cleanup (device);
-	nm_dhcp_device_timeout_cleanup (device);
+	id = g_signal_connect (client, "timeout", G_CALLBACK (client_timeout), self);
+	g_object_set_data (G_OBJECT (client), TIMEOUT_ID_TAG, GUINT_TO_POINTER (id));
 
-	g_signal_emit (G_OBJECT (device->manager), signals[STATE_CHANGED], 0, device->iface, device->state);
+	g_hash_table_insert (priv->clients, client, g_object_ref (client));
 }
 
-gboolean
-nm_dhcp_manager_begin_transaction (NMDHCPManager *manager,
-                                   const char *iface,
-                                   const char *uuid,
-                                   NMSettingIP4Config *s_ip4,
-                                   guint32 timeout,
-                                   guint8 *dhcp_anycast_addr)
+static NMDHCPClient *
+client_start (NMDHCPManager *self,
+              const char *iface,
+              const char *uuid,
+              gboolean ipv6,
+              NMSettingIP4Config *s_ip4,
+              NMSettingIP6Config *s_ip6,
+              guint32 timeout,
+              guint8 *dhcp_anycast_addr,
+              gboolean info_only)
 {
 	NMDHCPManagerPrivate *priv;
-	NMDHCPDevice *device;
-	NMSettingIP4Config *setting;
-
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), FALSE);
-	g_return_val_if_fail (iface != NULL, FALSE);
+	NMDHCPClient *client;
+	gboolean success = FALSE;
 
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+	g_return_val_if_fail (self, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
+	g_return_val_if_fail (iface != NULL, NULL);
+	g_return_val_if_fail (uuid != NULL, NULL);
 
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (!device)
-		device = nm_dhcp_device_new (manager, iface);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
 
-	if (device->pid && (device->state < DHC_ABEND)) {
-		/* Cancel any DHCP transaction already in progress */
-		nm_dhcp_manager_cancel_transaction_real (device);
-	}
+	/* Kill any old client instance */
+	client = get_client_for_iface (self, iface, ipv6);
+	if (client) {
+		nm_dhcp_client_stop (client);
+		remove_client (self, client);
+	}
+
+	/* And make a new one */
+	client = g_object_new (priv->client_type,
+	                       NM_DHCP_CLIENT_INTERFACE, iface,
+	                       NM_DHCP_CLIENT_IPV6, ipv6,
+	                       NM_DHCP_CLIENT_UUID, uuid,
+	                       NM_DHCP_CLIENT_TIMEOUT, timeout ? timeout : DHCP_TIMEOUT,
+	                       NULL);
+	g_return_val_if_fail (client != NULL, NULL);
+	add_client (self, client);
+
+	if (ipv6)
+		success = nm_dhcp_client_start_ip6 (client, s_ip6, dhcp_anycast_addr, info_only);
+	else
+		success = nm_dhcp_client_start_ip4 (client, s_ip4, dhcp_anycast_addr);
 
-	if (s_ip4 && 
-		nm_setting_ip4_config_get_dhcp_send_hostname (s_ip4) &&
-		nm_setting_ip4_config_get_dhcp_hostname (s_ip4) == NULL &&
-		priv->hostname_provider != NULL) {
-		/* We're asked to send the hostname to DHCP server,
-		   the hostname isn't specified,
-		   and a hostname provider is registered: use that */
-
-		setting = NM_SETTING_IP4_CONFIG (nm_setting_duplicate (NM_SETTING (s_ip4)));
-		g_object_set (G_OBJECT (setting),
-					  NM_SETTING_IP4_CONFIG_DHCP_HOSTNAME,
-					  nm_hostname_provider_get_hostname (priv->hostname_provider),
-					  NULL);
-	} else {
-		setting = s_ip4 ? g_object_ref (s_ip4) : NULL;
+	if (!success) {
+		remove_client (self, client);
+		g_object_unref (client);
+		client = NULL;
 	}
 
-	if (timeout == 0)
-		timeout = NM_DHCP_TIMEOUT;
-
-	nm_info ("Activation (%s) Beginning DHCP transaction (timeout in %d seconds)",
-	         iface, timeout);
-	device->pid = nm_dhcp_client_start (device, uuid, setting, dhcp_anycast_addr);
-
-	if (setting)
-		g_object_unref (setting);
-
-	if (device->pid == 0)
-		return FALSE;
-
-	/* Set up a timeout on the transaction to kill it after the timeout */
-	device->timeout_id = g_timeout_add_seconds (timeout,
-	                                            nm_dhcp_manager_handle_timeout,
-	                                            device);
-	device->watch_id = g_child_watch_add (device->pid,
-					      (GChildWatchFunc) dhcp_watch_cb,
-					      device);
-	return TRUE;
+	return client;
 }
 
-void
-nm_dhcp_client_stop (NMDHCPDevice *device, pid_t pid)
+/* Caller owns a reference to the NMDHCPClient on return */
+NMDHCPClient *
+nm_dhcp_manager_start_ip4 (NMDHCPManager *self,
+                           const char *iface,
+                           const char *uuid,
+                           NMSettingIP4Config *s_ip4,
+                           guint32 timeout,
+                           guint8 *dhcp_anycast_addr)
 {
-	int i = 15; /* 3 seconds */
-
-	g_return_if_fail (pid > 0);
-
-	/* Clean up the watch handler since we're explicitly killing
-	 * the daemon
-	 */
-	nm_dhcp_device_watch_cleanup (device);
-
-	/* Tell it to quit; maybe it wants to send out a RELEASE message */
-	kill (pid, SIGTERM);
-
-	while (i-- > 0) {
-		gint child_status;
-		int ret;
-
-		ret = waitpid (pid, &child_status, WNOHANG);
-		if (ret > 0)
-			break;
-
-		if (ret == -1) {
-			/* Child already exited */
-			if (errno == ECHILD)
-				break;
-			/* Took too long; shoot it in the head */
-			i = 0;
-			break;
-		}
-		g_usleep (G_USEC_PER_SEC / 5);
-	}
-
-	if (i <= 0) {
-		nm_warning ("%s: dhcp client pid %d didn't exit, will kill it.", device->iface, pid);
-		kill (pid, SIGKILL);
-
-		nm_debug ("waiting for dhcp client pid %d to exit", pid);
-		waitpid (pid, NULL, 0);
-		nm_debug ("dhcp client pid %d cleaned up", pid);
-	}
-}
+	NMDHCPManagerPrivate *priv;
+	NMDHCPClient *client = NULL;
 
-static void
-nm_dhcp_manager_cancel_transaction_real (NMDHCPDevice *device)
-{
-	g_return_if_fail (device->pid > 0);
+	g_return_val_if_fail (self, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
 
-	nm_dhcp_client_stop (device, device->pid);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
 
-	nm_info ("(%s): canceled DHCP transaction, dhcp client pid %d",
-	         device->iface,
-	         device->pid);
+	if (s_ip4) {
+		if (   nm_setting_ip4_config_get_dhcp_send_hostname (s_ip4)
+		    && (nm_setting_ip4_config_get_dhcp_hostname (s_ip4) == NULL)
+		    && priv->hostname_provider != NULL) {
 
-	device->pid = 0;
-	device->state = DHC_END;
+			s_ip4 = NM_SETTING_IP4_CONFIG (nm_setting_duplicate (NM_SETTING (s_ip4)));
 
-	/* Clean up the pidfile if it got left around */
-	if (device->pid_file) {
-		remove (device->pid_file);
-		g_free (device->pid_file);
-		device->pid_file = NULL;
+			/* We're asked to send the hostname to DHCP server, the hostname
+			 * isn't specified, and a hostname provider is registered: use that
+			 */
+			g_object_set (G_OBJECT (s_ip4),
+						  NM_SETTING_IP4_CONFIG_DHCP_HOSTNAME,
+						  nm_hostname_provider_get_hostname (priv->hostname_provider),
+						  NULL);
+		} else
+			g_object_ref (s_ip4);
 	}
 
-	/* Free leasefile (but don't delete) */
-	if (device->lease_file) {
-		g_free (device->lease_file);
-		device->lease_file = NULL;
-	}
+	client = client_start (self, iface, uuid, FALSE, s_ip4, NULL, timeout, dhcp_anycast_addr, FALSE);
 
-	/* Clean up config file if it got left around */
-	if (device->conf_file) {
-		remove (device->conf_file);
-		g_free (device->conf_file);
-		device->conf_file = NULL;
-	}
+	if (s_ip4)
+		g_object_unref (s_ip4);
 
-	nm_dhcp_device_timeout_cleanup (device);
-	g_hash_table_remove_all (device->options);
+	return client;
 }
 
-
-/*
- * nm_dhcp_manager_cancel_transaction
- *
- * Stop any in-progress DHCP transaction on a particular device.
- *
- */
-void
-nm_dhcp_manager_cancel_transaction (NMDHCPManager *manager,
-                                    const char *iface)
+/* Caller owns a reference to the NMDHCPClient on return */
+NMDHCPClient *
+nm_dhcp_manager_start_ip6 (NMDHCPManager *self,
+                           const char *iface,
+                           const char *uuid,
+                           NMSettingIP6Config *s_ip6,
+                           guint32 timeout,
+                           guint8 *dhcp_anycast_addr,
+                           gboolean info_only)
 {
-	NMDHCPDevice *device;
-	NMDHCPManagerPrivate *priv;
-
-	g_return_if_fail (NM_IS_DHCP_MANAGER (manager));
-	g_return_if_fail (iface != NULL);
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-
-	if (!device || !device->pid)
-		return;
-
-	nm_dhcp_manager_cancel_transaction_real (device);
+	return client_start (self, iface, uuid, TRUE, NULL, s_ip6, timeout, dhcp_anycast_addr, info_only);
 }
 
 static void
-process_classful_routes (GHashTable *options, NMIP4Config *ip4_config)
+hostname_provider_destroyed (gpointer data, GObject *destroyed_object)
 {
-	const char *str;
-	char **searches, **s;
-
-	str = g_hash_table_lookup (options, "new_static_routes");
-	if (!str)
-		return;
-
-	searches = g_strsplit (str, " ", 0);
-	if ((g_strv_length (searches) % 2)) {
-		nm_info ("  static routes provided, but invalid");
-		goto out;
-	}
-
-	for (s = searches; *s; s += 2) {
-		NMIP4Route *route;
-		struct in_addr rt_addr;
-		struct in_addr rt_route;
-
-		if (inet_pton (AF_INET, *s, &rt_addr) <= 0) {
-			nm_warning ("DHCP provided invalid static route address: '%s'", *s);
-			continue;
-		}
-		if (inet_pton (AF_INET, *(s + 1), &rt_route) <= 0) {
-			nm_warning ("DHCP provided invalid static route gateway: '%s'", *(s + 1));
-			continue;
-		}
-
-		// FIXME: ensure the IP addresse and route are sane
-
-		route = nm_ip4_route_new ();
-		nm_ip4_route_set_dest (route, (guint32) rt_addr.s_addr);
-		nm_ip4_route_set_prefix (route, 32); /* 255.255.255.255 */
-		nm_ip4_route_set_next_hop (route, (guint32) rt_route.s_addr);
-
-		nm_ip4_config_take_route (ip4_config, route);
-		nm_info ("  static route %s gw %s", *s, *(s + 1));
-	}
-
-out:
-	g_strfreev (searches);
+	NM_DHCP_MANAGER_GET_PRIVATE (data)->hostname_provider = NULL;
 }
 
-static void
-process_domain_search (NMIP4Config *ip4_config, const char *str)
+void
+nm_dhcp_manager_set_hostname_provider (NMDHCPManager *manager,
+									   NMHostnameProvider *provider)
 {
-	char **searches, **s;
-	char *unescaped, *p;
-	int i;
-
-	g_return_if_fail (str != NULL);
-	g_return_if_fail (ip4_config != NULL);
+	NMDHCPManagerPrivate *priv;
 
-	p = unescaped = g_strdup (str);
-	do {
-		p = strstr (p, "\\032");
-		if (!p)
-			break;
+	g_return_if_fail (NM_IS_DHCP_MANAGER (manager));
 
-		/* Clear the escaped space with real spaces */
-		for (i = 0; i < 4; i++)
-			*p++ = ' ';
-	} while (*p++);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
 
-	if (strchr (unescaped, '\\')) {
-		nm_info ("  invalid domain search: '%s'", unescaped);
-		goto out;
+	if (priv->hostname_provider) {
+		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, manager);
+		priv->hostname_provider = NULL;
 	}
 
-	searches = g_strsplit (unescaped, " ", 0);
-	for (s = searches; *s; s++) {
-		if (strlen (*s)) {
-			nm_info ("  domain search '%s'", *s);
-			nm_ip4_config_add_search (ip4_config, *s);
-		}
+	if (provider) {
+		priv->hostname_provider = provider;
+		g_object_weak_ref (G_OBJECT (provider), hostname_provider_destroyed, manager);
 	}
-	g_strfreev (searches);
-
-out:
-	g_free (unescaped);
 }
 
-/* Given a table of DHCP options from the client, convert into an IP4Config */
-NMIP4Config *
-nm_dhcp_manager_options_to_ip4_config (const char *iface, GHashTable *options)
+GSList *
+nm_dhcp_manager_get_lease_config (NMDHCPManager *self,
+                                  const char *iface,
+                                  const char *uuid)
 {
-	NMIP4Config *ip4_config = NULL;
-	struct in_addr tmp_addr;
-	NMIP4Address *addr = NULL;
-	char *str = NULL;
-	guint32 gwaddr = 0;
-	gboolean have_classless = FALSE;
-
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
 	g_return_val_if_fail (iface != NULL, NULL);
-	g_return_val_if_fail (options != NULL, NULL);
-
-	ip4_config = nm_ip4_config_new ();
-	if (!ip4_config) {
-		nm_warning ("%s: couldn't allocate memory for an IP4Config!", iface);
-		return NULL;
-	}
-
-	addr = nm_ip4_address_new ();
-	if (!addr) {
-		nm_warning ("%s: couldn't allocate memory for an IP4 Address!", iface);
-		goto error;
-	}
-
-	str = g_hash_table_lookup (options, "new_ip_address");
-	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
-		nm_ip4_address_set_address (addr, tmp_addr.s_addr);
-		nm_info ("  address %s", str);
-	} else
-		goto error;
-
-	str = g_hash_table_lookup (options, "new_subnet_mask");
-	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
-		nm_ip4_address_set_prefix (addr, nm_utils_ip4_netmask_to_prefix (tmp_addr.s_addr));
-		nm_info ("  prefix %d (%s)", nm_ip4_address_get_prefix (addr), str);
-	}
-
-	/* Routes: if the server returns classless static routes, we MUST ignore
-	 * the 'static_routes' option.
-	 */
-	have_classless = nm_dhcp_client_process_classless_routes (options, ip4_config, &gwaddr);
-	if (!have_classless) {
-		gwaddr = 0;  /* Ensure client code doesn't lie */
-		process_classful_routes (options, ip4_config);
-	}
-
-	if (gwaddr) {
-		char buf[INET_ADDRSTRLEN + 1];
-
-		inet_ntop (AF_INET, &gwaddr, buf, sizeof (buf));
-		nm_info ("  gateway %s", buf);
-		nm_ip4_address_set_gateway (addr, gwaddr);
-	} else {
-		/* If the gateway wasn't provided as a classless static route with a
-		 * subnet length of 0, try to find it using the old-style 'routers' option.
-		 */
-		str = g_hash_table_lookup (options, "new_routers");
-		if (str) {
-			char **routers = g_strsplit (str, " ", 0);
-			char **s;
-
-			for (s = routers; *s; s++) {
-				/* FIXME: how to handle multiple routers? */
-				if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
-					nm_ip4_address_set_gateway (addr, tmp_addr.s_addr);
-					nm_info ("  gateway %s", *s);
-					break;
-				} else
-					nm_warning ("Ignoring invalid gateway '%s'", *s);
-			}
-			g_strfreev (routers);
-		}
-	}
-
-	nm_ip4_config_take_address (ip4_config, addr);
-	addr = NULL;
-
-	str = g_hash_table_lookup (options, "new_host_name");
-	if (str)
-		nm_info ("  hostname '%s'", str);
-
-	str = g_hash_table_lookup (options, "new_domain_name_servers");
-	if (str) {
-		char **searches = g_strsplit (str, " ", 0);
-		char **s;
-
-		for (s = searches; *s; s++) {
-			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
-				nm_ip4_config_add_nameserver (ip4_config, tmp_addr.s_addr);
-				nm_info ("  nameserver '%s'", *s);
-			} else
-				nm_warning ("Ignoring invalid nameserver '%s'", *s);
-		}
-		g_strfreev (searches);
-	}
-
-	str = g_hash_table_lookup (options, "new_domain_name");
-	if (str) {
-		char **domains = g_strsplit (str, " ", 0);
-		char **s;
-
-		for (s = domains; *s; s++) {
-			nm_info ("  domain name '%s'", *s);
-			nm_ip4_config_add_domain (ip4_config, *s);
-		}
-		g_strfreev (domains);
-	}
-
-	str = g_hash_table_lookup (options, "new_domain_search");
-	if (str)
-		process_domain_search (ip4_config, str);
-
-	str = g_hash_table_lookup (options, "new_netbios_name_servers");
-	if (str) {
-		char **searches = g_strsplit (str, " ", 0);
-		char **s;
-
-		for (s = searches; *s; s++) {
-			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
-				nm_ip4_config_add_wins (ip4_config, tmp_addr.s_addr);
-				nm_info ("  wins '%s'", *s);
-			} else
-				nm_warning ("Ignoring invalid WINS server '%s'", *s);
-		}
-		g_strfreev (searches);
-	}
-
-	str = g_hash_table_lookup (options, "new_interface_mtu");
-	if (str) {
-		int int_mtu;
-
-		errno = 0;
-		int_mtu = strtol (str, NULL, 10);
-		if ((errno == EINVAL) || (errno == ERANGE))
-			goto error;
-
-		if (int_mtu > 576)
-			nm_ip4_config_set_mtu (ip4_config, int_mtu);
-	}
-
-	return ip4_config;
+	g_return_val_if_fail (uuid != NULL, NULL);
 
-error:
-	if (addr)
-		nm_ip4_address_unref (addr);
-	g_object_unref (ip4_config);
-	return NULL;
+	return NM_DHCP_MANAGER_GET_PRIVATE (self)->get_lease_config_func (iface, uuid);
 }
 
-/*
- * nm_dhcp_manager_get_ip4_config
- *
- * Get IP4 configuration values from the DHCP daemon
- *
- */
 NMIP4Config *
-nm_dhcp_manager_get_ip4_config (NMDHCPManager *manager,
-                                const char *iface)
-{
-	NMDHCPManagerPrivate *priv;
-	NMDHCPDevice *device;
-
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), NULL);
-	g_return_val_if_fail (iface != NULL, NULL);
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (!device) {
-		nm_warning ("Device '%s' transaction not started.", iface);
+nm_dhcp_manager_test_ip4_options_to_config (const char *dhcp_client,
+                                            const char *iface,
+                                            GHashTable *options,
+                                            const char *reason)
+{
+	NMDHCPClient *client;
+	NMIP4Config *config;
+	GType client_type;
+	GError *error = NULL;
+
+	client_type = get_client_type (dhcp_client, &error);
+	if (!client_type) {
+		nm_log_err (LOGD_DHCP4, "error: %s", error ? error->message : "(unknown)");
+		g_clear_error (&error);
 		return NULL;
 	}
 
-	if (!state_is_bound (device->state)) {
-		nm_warning ("%s: dhcp client didn't bind to a lease.", device->iface);
-		return NULL;
-	}
+	client = (NMDHCPClient *) g_object_new (client_type,
+	                                        NM_DHCP_CLIENT_INTERFACE, iface,
+	                                        NULL);
+	g_return_val_if_fail (client != NULL, NULL);
+	nm_dhcp_client_new_options (client, options, reason);
+	config = nm_dhcp_client_get_ip4_config (client, TRUE);
+	g_object_unref (client);
 
-	return nm_dhcp_manager_options_to_ip4_config (iface, device->options);
+	return config;
 }
 
-#define NEW_TAG "new_"
-#define OLD_TAG "old_"
+/***************************************************/
 
-typedef struct {
-	GHFunc func;
-	gpointer user_data;
-} Dhcp4ForeachInfo;
+NMDHCPManager *
+nm_dhcp_manager_get (void)
+{
+	g_warn_if_fail (singleton != NULL);
+	return g_object_ref (singleton);
+}
 
 static void
-iterate_dhcp4_config_option (gpointer key,
-                             gpointer value,
-                             gpointer user_data)
+nm_dhcp_manager_init (NMDHCPManager *manager)
 {
-	Dhcp4ForeachInfo *info = (Dhcp4ForeachInfo *) user_data;
-	char *tmp_key = NULL;
-	const char **p;
-	static const char *filter_options[] = {
-		"interface", "pid", "reason", "dhcp_message_type", NULL
-	};
-	
-	/* Filter out stuff that's not actually new DHCP options */
-	for (p = filter_options; *p; p++) {
-		if (!strcmp (*p, (const char *) key))
-			return;
-		if (!strncmp ((const char *) key, OLD_TAG, strlen (OLD_TAG)))
-			return;
-	}
-
-	/* Remove the "new_" prefix that dhclient passes back */
-	if (!strncmp ((const char *) key, NEW_TAG, strlen (NEW_TAG)))
-		tmp_key = g_strdup ((const char *) (key + strlen (NEW_TAG)));
-	else
-		tmp_key = g_strdup ((const char *) key);
-
-	(*info->func) ((gpointer) tmp_key, value, info->user_data);
-	g_free (tmp_key);
 }
 
-gboolean
-nm_dhcp_manager_foreach_dhcp4_option (NMDHCPManager *self,
-                                      const char *iface,
-                                      GHFunc func,
-                                      gpointer user_data)
+static void
+dispose (GObject *object)
 {
-	NMDHCPManagerPrivate *priv;
-	NMDHCPDevice *device;
-	Dhcp4ForeachInfo info = { NULL, NULL };
-
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), FALSE);
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (func != NULL, FALSE);
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (!device) {
-		nm_warning ("Device '%s' transaction not started.", iface);
-		return FALSE;
-	}
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (object);
+	GList *values, *iter;
 
-	if (!state_is_bound (device->state)) {
-		nm_warning ("%s: dhclient didn't bind to a lease.", device->iface);
-		return FALSE;
+	if (priv->clients) {
+		values = g_hash_table_get_values (priv->clients);
+		for (iter = values; iter; iter = g_list_next (iter))
+			remove_client (NM_DHCP_MANAGER (object), NM_DHCP_CLIENT (iter->data));
+		g_list_free (values);
 	}
 
-	info.func = func;
-	info.user_data = user_data;
-	g_hash_table_foreach (device->options, iterate_dhcp4_config_option, &info);
-	return TRUE;
+	G_OBJECT_CLASS (nm_dhcp_manager_parent_class)->dispose (object);
 }
 
 static void
-hostname_provider_destroyed (gpointer data, GObject *destroyed_object)
-{
-	NM_DHCP_MANAGER_GET_PRIVATE (data)->hostname_provider = NULL;
-}
-
-void
-nm_dhcp_manager_set_hostname_provider (NMDHCPManager *manager,
-									   NMHostnameProvider *provider)
+finalize (GObject *object)
 {
-	NMDHCPManagerPrivate *priv;
-
-	g_return_if_fail (NM_IS_DHCP_MANAGER (manager));
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (object);
 
 	if (priv->hostname_provider) {
-		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, manager);
+		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, object);
 		priv->hostname_provider = NULL;
 	}
 
-	if (provider) {
-		priv->hostname_provider = provider;
-		g_object_weak_ref (G_OBJECT (provider), hostname_provider_destroyed, manager);
-	}
+	if (priv->clients)
+		g_hash_table_destroy (priv->clients);
+	if (priv->proxy)
+		g_object_unref (priv->proxy);
+	if (priv->dbus_mgr)
+		g_object_unref (priv->dbus_mgr);
+
+	G_OBJECT_CLASS (nm_dhcp_manager_parent_class)->finalize (object);
 }
 
-GSList *
-nm_dhcp_manager_get_lease_ip4_config (NMDHCPManager *self,
-                                      const char *iface,
-                                      const char *uuid)
+static void
+nm_dhcp_manager_class_init (NMDHCPManagerClass *manager_class)
 {
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
-	g_return_val_if_fail (iface != NULL, NULL);
-	g_return_val_if_fail (uuid != NULL, NULL);
+	GObjectClass *object_class = G_OBJECT_CLASS (manager_class);
+
+	g_type_class_add_private (manager_class, sizeof (NMDHCPManagerPrivate));
 
-	return nm_dhcp_client_get_lease_ip4_config (iface, uuid);
+	/* virtual methods */
+	object_class->finalize = finalize;
+	object_class->dispose = dispose;
 }
 
diff --git a/src/dhcp-manager/nm-dhcp-manager.h b/src/dhcp-manager/nm-dhcp-manager.h
index 1240084..9d83d09 100644
--- a/src/dhcp-manager/nm-dhcp-manager.h
+++ b/src/dhcp-manager/nm-dhcp-manager.h
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -26,12 +26,24 @@
 #include <glib-object.h>
 
 #include <nm-setting-ip4-config.h>
+#include <nm-setting-ip6-config.h>
 
+#include "nm-dhcp-client.h"
 #include "nm-ip4-config.h"
 #include "nm-dhcp4-config.h"
 #include "nm-hostname-provider.h"
 
-#define NM_DHCP_MANAGER_RUN_DIR		LOCALSTATEDIR "/run"
+enum {
+    NM_DHCP_MANAGER_ERROR_BAD_CLIENT = 0,
+    NM_DHCP_MANAGER_ERROR_INTERNAL = 1,
+};
+
+#define NM_DHCP_MANAGER_ERROR (nm_dhcp_manager_error_quark ())
+#define NN_TYPE_DHCP_MANAGER_ERROR (nm_dhcp_manager_error_get_type ())
+
+GQuark nm_dhcp_manager_error_quark    (void);
+GType  nm_dhcp_manager_error_get_type (void);
+
 
 #define NM_TYPE_DHCP_MANAGER            (nm_dhcp_manager_get_type ())
 #define NM_DHCP_MANAGER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_MANAGER, NMDHCPManager))
@@ -40,93 +52,47 @@
 #define NM_IS_DHCP_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_MANAGER))
 #define NM_DHCP_MANAGER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_MANAGER, NMDHCPManagerClass))
 
-typedef enum {
-	DHC_NBI=0,		/* no broadcast interfaces found */
-	DHC_PREINIT,		/* configuration started */
-	DHC_BOUND,		/* lease obtained */
-	DHC_IPV4LL,		/* IPv4LL address obtained */
-	DHC_RENEW,		/* lease renewed */
-	DHC_REBOOT,		/* have valid lease, but now obtained a different one */
-	DHC_REBIND,		/* new, different lease */
-	DHC_STOP,		/* remove old lease */
-	DHC_MEDIUM,		/* media selection begun */
-	DHC_TIMEOUT,		/* timed out contacting DHCP server */
-	DHC_FAIL,		/* all attempts to contact server timed out, sleeping */
-	DHC_EXPIRE,		/* lease has expired, renewing */
-	DHC_RELEASE,		/* releasing lease */
-	DHC_START,		/* sent when dhclient started OK */
-	DHC_ABEND,		/* dhclient exited abnormally */
-	DHC_END,		/* dhclient exited normally */
-	DHC_END_OPTIONS,	/* last option in subscription sent */
-} NMDHCPState;
-
 typedef struct {
 	GObject parent;
 } NMDHCPManager;
 
 typedef struct {
 	GObjectClass parent;
-
-	/* Signals */
-	void (*state_changed) (NMDHCPManager *manager, char *iface, NMDHCPState state);
-	void (*timeout)       (NMDHCPManager *manager, char *iface);
 } NMDHCPManagerClass;
 
-typedef struct {
-        char *			iface;
-        guchar			state;
-        GPid			pid;
-        char *			pid_file;
-        char *			conf_file;
-        char *			lease_file;
-        guint			timeout_id;
-        guint			watch_id;
-        NMDHCPManager *		manager;
-        GHashTable *		options;
-} NMDHCPDevice;
-
 GType nm_dhcp_manager_get_type (void);
 
 NMDHCPManager *nm_dhcp_manager_get                  (void);
+
 void           nm_dhcp_manager_set_hostname_provider(NMDHCPManager *manager,
 													 NMHostnameProvider *provider);
 
-gboolean       nm_dhcp_manager_begin_transaction    (NMDHCPManager *manager,
-                                                     const char *iface,
-                                                     const char *uuid,
-                                                     NMSettingIP4Config *s_ip4,
-                                                     guint32 timeout,
-                                                     guint8 *dhcp_anycast_addr);
-void           nm_dhcp_manager_cancel_transaction   (NMDHCPManager *manager,
-                                                     const char *iface);
-NMIP4Config *  nm_dhcp_manager_get_ip4_config       (NMDHCPManager *manager, const char *iface);
-NMDHCPState    nm_dhcp_manager_get_state_for_device (NMDHCPManager *manager, const char *iface);
-
-gboolean       nm_dhcp_manager_foreach_dhcp4_option (NMDHCPManager *self,
-                                                     const char *iface,
-                                                     GHFunc func,
-                                                     gpointer user_data);
-
-GSList *       nm_dhcp_manager_get_lease_ip4_config (NMDHCPManager *self,
-                                                     const char *iface,
-                                                     const char *uuid);
-
-/* The following are implemented by the DHCP client backends */
-GPid           nm_dhcp_client_start                 (NMDHCPDevice *device,
-                                                     const char *uuid,
-                                                     NMSettingIP4Config *s_ip4,
-                                                     guint8 *anycast_addr);
-void           nm_dhcp_client_stop                  (NMDHCPDevice *device, pid_t pid);
-
-gboolean       nm_dhcp_client_process_classless_routes (GHashTable *options,
-                                                        NMIP4Config *ip4_config,
-                                                        guint32 *gwaddr);
-
-GSList *       nm_dhcp_client_get_lease_ip4_config  (const char *iface,
-                                                     const char *uuid);
-
-/* Test functions */
-NMIP4Config *nm_dhcp_manager_options_to_ip4_config (const char *iface,
-                                                    GHashTable *options);
+NMDHCPClient * nm_dhcp_manager_start_ip4     (NMDHCPManager *manager,
+                                              const char *iface,
+                                              const char *uuid,
+                                              NMSettingIP4Config *s_ip4,
+                                              guint32 timeout,
+                                              guint8 *dhcp_anycast_addr);
+
+NMDHCPClient * nm_dhcp_manager_start_ip6     (NMDHCPManager *manager,
+                                              const char *iface,
+                                              const char *uuid,
+                                              NMSettingIP6Config *s_ip6,
+                                              guint32 timeout,
+                                              guint8 *dhcp_anycast_addr,
+                                              gboolean info_only);
+
+GSList *       nm_dhcp_manager_get_lease_config (NMDHCPManager *self,
+                                                 const char *iface,
+                                                 const char *uuid);
+
+/* For testing only */
+NMIP4Config *nm_dhcp_manager_test_ip4_options_to_config (const char *dhcp_client,
+                                                         const char *iface,
+                                                         GHashTable *options,
+                                                         const char *reason);
+
+/* Only for main.c */
+NMDHCPManager *nm_dhcp_manager_new (const char *client, GError **error);
 
 #endif /* NM_DHCP_MANAGER_H */
diff --git a/src/dnsmasq-manager/Makefile.am b/src/dnsmasq-manager/Makefile.am
index 71d3873..66bbdd8 100644
--- a/src/dnsmasq-manager/Makefile.am
+++ b/src/dnsmasq-manager/Makefile.am
@@ -1,5 +1,6 @@
 INCLUDES = \
 	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/src \
 	-I${top_srcdir}/include
 
@@ -13,4 +14,6 @@ libdnsmasq_manager_la_CPPFLAGS = \
 	$(GLIB_CFLAGS) \
 	-DLOCALSTATEDIR=\"$(localstatedir)\"
 
-libdnsmasq_manager_la_LIBADD = $(GLIB_LIBS)
+libdnsmasq_manager_la_LIBADD = \
+	$(top_builddir)/src/logging/libnm-logging.la \
+	$(GLIB_LIBS)
diff --git a/src/dnsmasq-manager/nm-dnsmasq-manager.c b/src/dnsmasq-manager/nm-dnsmasq-manager.c
index 5538c82..ea529c7 100644
--- a/src/dnsmasq-manager/nm-dnsmasq-manager.c
+++ b/src/dnsmasq-manager/nm-dnsmasq-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <sys/types.h>
@@ -27,7 +27,7 @@
 #include <stdlib.h>
 
 #include "nm-dnsmasq-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-glib-compat.h"
 
 typedef struct {
@@ -168,13 +168,12 @@ nm_cmd_line_add_string (NMCmdLine *cmd, const char *str)
 static inline const char *
 nm_find_dnsmasq (void)
 {
-	static const char *dnsmasq_binary_paths[] =
-		{
-			"/usr/local/sbin/dnsmasq",
-			"/usr/sbin/dnsmasq",
-			"/sbin/dnsmasq",
-			NULL
-		};
+	static const char *dnsmasq_binary_paths[] = {
+		"/usr/local/sbin/dnsmasq",
+		"/usr/sbin/dnsmasq",
+		"/sbin/dnsmasq",
+		NULL
+	};
 
 	const char **dnsmasq_binary = dnsmasq_binary_paths;
 
@@ -214,7 +213,7 @@ dm_exit_code (guint dm_exit_status)
 		break;
 	}
 
-	g_warning ("dnsmasq exited with error: %s (%d)", msg, dm_exit_status);
+	nm_log_warn (LOGD_SHARING, "dnsmasq exited with error: %s (%d)", msg, dm_exit_status);
 }
 
 static void
@@ -228,12 +227,13 @@ dm_watch_cb (GPid pid, gint status, gpointer user_data)
 		err = WEXITSTATUS (status);
 		if (err != 0)
 			dm_exit_code (err);
-	} else if (WIFSTOPPED (status))
-		g_warning ("dnsmasq stopped unexpectedly with signal %d", WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		g_warning ("dnsmasq died with signal %d", WTERMSIG (status));
-	else
-		g_warning ("dnsmasq died from an unknown cause");
+	} else if (WIFSTOPPED (status)) {
+		nm_log_warn (LOGD_SHARING, "dnsmasq stopped unexpectedly with signal %d", WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_warn (LOGD_SHARING, "dnsmasq died with signal %d", WTERMSIG (status));
+	} else {
+		nm_log_warn (LOGD_SHARING, "dnsmasq died from an unknown cause");
+	}
   
 	priv->pid = 0;
 
@@ -288,8 +288,8 @@ create_dm_cmd_line (const char *iface,
 	s = g_string_new ("--listen-address=");
 	addr.s_addr = nm_ip4_address_get_address (tmp);
 	if (!inet_ntop (AF_INET, &addr, &localaddr[0], INET_ADDRSTRLEN)) {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (addr.s_addr));
+		nm_log_warn (LOGD_SHARING, "error converting IP4 address 0x%X",
+		             ntohl (addr.s_addr));
 		goto error;
 	}
 	g_string_append (s, localaddr);
@@ -301,8 +301,8 @@ create_dm_cmd_line (const char *iface,
 	/* Add start of address range */
 	addr.s_addr = nm_ip4_address_get_address (tmp) + htonl (9);
 	if (!inet_ntop (AF_INET, &addr, &buf[0], INET_ADDRSTRLEN)) {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (addr.s_addr));
+		nm_log_warn (LOGD_SHARING, "error converting IP4 address 0x%X",
+		             ntohl (addr.s_addr));
 		goto error;
 	}
 	g_string_append (s, buf);
@@ -312,8 +312,8 @@ create_dm_cmd_line (const char *iface,
 	/* Add end of address range */
 	addr.s_addr = nm_ip4_address_get_address (tmp) + htonl (99);
 	if (!inet_ntop (AF_INET, &addr, &buf[0], INET_ADDRSTRLEN)) {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (addr.s_addr));
+		nm_log_warn (LOGD_SHARING, "error converting IP4 address 0x%X",
+		             ntohl (addr.s_addr));
 		goto error;
 	}
 	g_string_append (s, buf);
@@ -370,7 +370,7 @@ kill_existing_for_iface (const char *iface, const char *pidfile)
 
 	if (strstr (cmdline_contents, "bin/dnsmasq")) {
 		if (kill (pid, 0)) {
-			nm_info ("Killing stale dnsmasq process %ld", pid);
+			nm_log_dbg (LOGD_SHARING, "Killing stale dnsmasq process %ld", pid);
 			kill (pid, SIGKILL);
 		}
 		unlink (pidfile);
@@ -405,10 +405,10 @@ nm_dnsmasq_manager_start (NMDnsMasqManager *manager,
 
 	g_ptr_array_add (dm_cmd->array, NULL);
 
-	nm_info ("Starting dnsmasq...");
+	nm_log_info (LOGD_SHARING, "Starting dnsmasq...");
 
 	cmd_str = nm_cmd_line_to_str (dm_cmd);
-	nm_debug ("Command line: %s", cmd_str);
+	nm_log_dbg (LOGD_SHARING, "Command line: %s", cmd_str);
 	g_free (cmd_str);
 
 	priv->pid = 0;
@@ -419,7 +419,7 @@ nm_dnsmasq_manager_start (NMDnsMasqManager *manager,
 		goto out;
 	}
 
-	nm_debug ("dnsmasq started with pid %d", priv->pid);
+	nm_log_dbg (LOGD_SHARING, "dnsmasq started with pid %d", priv->pid);
 
 	priv->dm_watch_id = g_child_watch_add (priv->pid, (GChildWatchFunc) dm_watch_cb, manager);
 
@@ -439,9 +439,9 @@ ensure_killed (gpointer data)
 		kill (pid, SIGKILL);
 
 	/* ensure the child is reaped */
-	nm_debug ("waiting for dnsmasq pid %d to exit", pid);
+	nm_log_dbg (LOGD_SHARING, "waiting for dnsmasq pid %d to exit", pid);
 	waitpid (pid, NULL, 0);
-	nm_debug ("dnsmasq pid %d cleaned up", pid);
+	nm_log_dbg (LOGD_SHARING, "dnsmasq pid %d cleaned up", pid);
 
 	return FALSE;
 }
@@ -467,9 +467,9 @@ nm_dnsmasq_manager_stop (NMDnsMasqManager *manager)
 			kill (priv->pid, SIGKILL);
 
 			/* ensure the child is reaped */
-			nm_debug ("waiting for dnsmasq pid %d to exit", priv->pid);
+			nm_log_dbg (LOGD_SHARING, "waiting for dnsmasq pid %d to exit", priv->pid);
 			waitpid (priv->pid, NULL, 0);
-			nm_debug ("dnsmasq pid %d cleaned up", priv->pid);
+			nm_log_dbg (LOGD_SHARING, "dnsmasq pid %d cleaned up", priv->pid);
 		}
 
 		priv->pid = 0;
diff --git a/src/ip6-manager/Makefile.am b/src/ip6-manager/Makefile.am
index 50db421..9f5229f 100644
--- a/src/ip6-manager/Makefile.am
+++ b/src/ip6-manager/Makefile.am
@@ -3,6 +3,7 @@ INCLUDES = \
 	-I${top_srcdir}/include \
 	-I${top_builddir}/marshallers \
 	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/src \
 	-I${top_srcdir}/src/named-manager
 
@@ -21,6 +22,8 @@ libip6_manager_la_CPPFLAGS = \
 	-DG_DISABLE_DEPRECATED
 
 libip6_manager_la_LIBADD = \
+	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
-	$(GLIB_LIBS) \
-	$(top_builddir)/marshallers/libmarshallers.la
+	$(GLIB_LIBS)
+
diff --git a/src/ip6-manager/nm-ip6-manager.c b/src/ip6-manager/nm-ip6-manager.c
index f41169c..be85ab0 100644
--- a/src/ip6-manager/nm-ip6-manager.c
+++ b/src/ip6-manager/nm-ip6-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <errno.h>
@@ -28,7 +28,7 @@
 #include "nm-netlink-listener.h"
 #include "NetworkManagerUtils.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /* Pre-DHCP addrconf timeout, in seconds */
 #define NM_IP6_TIMEOUT 10
@@ -165,10 +165,8 @@ nm_ip6_manager_class_init (NMIP6ManagerClass *manager_class)
 					  G_SIGNAL_RUN_FIRST,
 					  G_STRUCT_OFFSET (NMIP6ManagerClass, addrconf_complete),
 					  NULL, NULL,
-					  _nm_marshal_VOID__STRING_BOOLEAN,
-					  G_TYPE_NONE, 2,
-					  G_TYPE_STRING,
-					  G_TYPE_BOOLEAN);
+					  _nm_marshal_VOID__STRING_UINT_BOOLEAN,
+					  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_BOOLEAN);
 
 	signals[CONFIG_CHANGED] =
 		g_signal_new ("config-changed",
@@ -176,9 +174,8 @@ nm_ip6_manager_class_init (NMIP6ManagerClass *manager_class)
 					  G_SIGNAL_RUN_FIRST,
 					  G_STRUCT_OFFSET (NMIP6ManagerClass, config_changed),
 					  NULL, NULL,
-					  g_cclosure_marshal_VOID__STRING,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_STRING);
+					  _nm_marshal_VOID__STRING_UINT,
+					  G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_UINT);
 }
 
 static void
@@ -216,7 +213,7 @@ nm_ip6_manager_new (void)
 	priv = NM_IP6_MANAGER_GET_PRIVATE (manager);
 
 	if (!priv->devices_by_iface || !priv->devices_by_index) {
-		nm_warning ("Error: not enough memory to initialize IP6 manager tables");
+		nm_log_err (LOGD_IP6, "not enough memory to initialize IP6 manager tables");
 		g_object_unref (manager);
 		manager = NULL;
 	}
@@ -233,10 +230,16 @@ nm_ip6_manager_get_device (NMIP6Manager *manager, int ifindex)
 								GINT_TO_POINTER (ifindex));
 }
 
+typedef struct {
+	NMIP6Device *device;
+	guint dhcp_opts;
+} CallbackInfo;
+
 static gboolean
 finish_addrconf (gpointer user_data)
 {
-	NMIP6Device *device = user_data;
+	CallbackInfo *info = user_data;
+	NMIP6Device *device = info->device;
 	NMIP6Manager *manager = device->manager;
 	char *iface_copy;
 
@@ -245,16 +248,16 @@ finish_addrconf (gpointer user_data)
 
 	if (device->state >= device->target_state) {
 		g_signal_emit (manager, signals[ADDRCONF_COMPLETE], 0,
-					   device->iface, TRUE);
+					   device->iface, info->dhcp_opts, TRUE);
 	} else {
-		nm_info ("Device '%s' IP6 addrconf timed out or failed.",
-				 device->iface);
+		nm_log_info (LOGD_IP6, "(%s): IP6 addrconf timed out or failed.",
+				     device->iface);
 
 		iface_copy = g_strdup (device->iface);
 
 		nm_ip6_manager_cancel_addrconf (manager, device->iface);
 		g_signal_emit (manager, signals[ADDRCONF_COMPLETE], 0,
-					   iface_copy, FALSE);
+					   iface_copy, info->dhcp_opts, FALSE);
 
 		g_free (iface_copy);
 	}
@@ -265,11 +268,12 @@ finish_addrconf (gpointer user_data)
 static gboolean
 emit_config_changed (gpointer user_data)
 {
-	NMIP6Device *device = user_data;
+	CallbackInfo *info = user_data;
+	NMIP6Device *device = info->device;
 	NMIP6Manager *manager = device->manager;
 
 	device->config_changed_id = 0;
-	g_signal_emit (manager, signals[CONFIG_CHANGED], 0, device->iface);
+	g_signal_emit (manager, signals[CONFIG_CHANGED], 0, device->iface, info->dhcp_opts);
 	return FALSE;
 }
 
@@ -279,9 +283,10 @@ static gboolean
 rdnss_expired (gpointer user_data)
 {
 	NMIP6Device *device = user_data;
+	CallbackInfo info = { device, IP6_DHCP_OPT_NONE };
 
 	set_rdnss_timeout (device);
-	emit_config_changed (device);
+	emit_config_changed (&info);
 	return FALSE;
 }
 
@@ -323,6 +328,18 @@ set_rdnss_timeout (NMIP6Device *device)
 	}
 }
 
+static CallbackInfo *
+callback_info_new (NMIP6Device *device, guint dhcp_opts)
+{
+	CallbackInfo *info;
+
+	info = g_malloc0 (sizeof (CallbackInfo));
+	info->device = device;
+	info->dhcp_opts = dhcp_opts;
+
+	return info;
+}
+
 static void
 nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 {
@@ -333,6 +350,8 @@ nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 	struct in6_addr *addr;
 	struct rtnl_link *link;
 	guint flags;
+	CallbackInfo *info;
+	guint dhcp_opts = IP6_DHCP_OPT_NONE;
 
 	for (rtnladdr = (struct rtnl_addr *)nl_cache_get_first (priv->addr_cache);
 		 rtnladdr;
@@ -365,8 +384,10 @@ nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 	if ((flags & IF_RA_RCVD) && device->state < NM_IP6_DEVICE_GOT_ROUTER_ADVERTISEMENT)
 		device->state = NM_IP6_DEVICE_GOT_ROUTER_ADVERTISEMENT;
 
-//	if (flags & (IF_RA_MANAGED | IF_RA_OTHERCONF))
-//		device->need_dhcp = TRUE;
+	if (flags & IF_RA_MANAGED)
+		dhcp_opts = IP6_DHCP_OPT_MANAGED;
+	else if (flags & IF_RA_OTHERCONF)
+		dhcp_opts = IP6_DHCP_OPT_OTHERCONF;
 
 	if (!device->addrconf_complete) {
 		if (device->state >= device->target_state ||
@@ -376,13 +397,20 @@ nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 			 */
 			if (device->finish_addrconf_id)
 				g_source_remove (device->finish_addrconf_id);
-			device->finish_addrconf_id = g_idle_add (finish_addrconf,
-													 device);
+
+			info = callback_info_new (device, dhcp_opts);
+			device->finish_addrconf_id = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
+			                                              finish_addrconf,
+			                                              info,
+			                                              (GDestroyNotify) g_free);
 		}
 	} else if (config_changed) {
 		if (!device->config_changed_id) {
-			device->config_changed_id = g_idle_add (emit_config_changed,
-													device);
+			info = callback_info_new (device, dhcp_opts);
+			device->config_changed_id = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
+			                                             emit_config_changed,
+			                                             info,
+			                                             (GDestroyNotify) g_free);
 		}
 	}
 }
@@ -619,13 +647,13 @@ nm_ip6_device_new (NMIP6Manager *manager, const char *iface)
 
 	device = g_slice_new0 (NMIP6Device);
 	if (!device) {
-		nm_warning ("%s: Out of memory creating IP6 addrconf object.", iface);
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 addrconf object.", iface);
 		return NULL;
 	}
 
 	device->iface = g_strdup (iface);
 	if (!device->iface) {
-		nm_warning ("%s: Out of memory creating IP6 addrconf object "
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 addrconf object "
 		            "property 'iface'.",
 		            iface);
 		goto error;
@@ -634,7 +662,7 @@ nm_ip6_device_new (NMIP6Manager *manager, const char *iface)
 
 	device->accept_ra_path = g_strdup_printf ("/proc/sys/net/ipv6/conf/%s/accept_ra", iface);
 	if (!device->accept_ra_path) {
-		nm_warning ("%s: Out of memory creating IP6 addrconf object "
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 addrconf object "
 		            "property 'accept_ra_path'.",
 		            iface);
 		goto error;
@@ -651,10 +679,10 @@ nm_ip6_device_new (NMIP6Manager *manager, const char *iface)
 	 * device is taken down.
 	 */
 	if (!g_file_get_contents (device->accept_ra_path, &contents, NULL, &error)) {
-		nm_warning ("%s: error reading %s: (%d) %s",
-		            iface, device->accept_ra_path,
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_IP6, "(%s): error reading %s: (%d) %s",
+		             iface, device->accept_ra_path,
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 		g_clear_error (&error);
 	} else {
 		long int tmp;
@@ -717,6 +745,7 @@ nm_ip6_manager_begin_addrconf (NMIP6Manager *manager,
 {
 	NMIP6ManagerPrivate *priv;
 	NMIP6Device *device;
+	CallbackInfo *info;
 
 	g_return_if_fail (NM_IS_IP6_MANAGER (manager));
 	g_return_if_fail (iface != NULL);
@@ -726,14 +755,17 @@ nm_ip6_manager_begin_addrconf (NMIP6Manager *manager,
 	device = (NMIP6Device *) g_hash_table_lookup (priv->devices_by_iface, iface);
 	g_return_if_fail (device != NULL);
 
-	nm_info ("Activation (%s) Beginning IP6 addrconf.", iface);
+	nm_log_info (LOGD_IP6, "Activation (%s) Beginning IP6 addrconf.", iface);
 
 	device->addrconf_complete = FALSE;
 
 	/* Set up a timeout on the transaction to kill it after the timeout */
-	device->finish_addrconf_id = g_timeout_add_seconds (NM_IP6_TIMEOUT,
-														finish_addrconf,
-														device);
+	info = callback_info_new (device, 0);
+	device->finish_addrconf_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
+	                                                         NM_IP6_TIMEOUT,
+	                                                         finish_addrconf,
+	                                                         info,
+	                                                         (GDestroyNotify) g_free);
 
 	/* Sync flags, etc, from netlink; this will also notice if the
 	 * device is already fully configured and schedule the
@@ -786,13 +818,13 @@ nm_ip6_manager_get_ip6_config (NMIP6Manager *manager,
 
 	device = (NMIP6Device *) g_hash_table_lookup (priv->devices_by_iface, iface);
 	if (!device) {
-		nm_warning ("Device '%s' addrconf not started.", iface);
+		nm_log_warn (LOGD_IP6, "(%s): addrconf not started.", iface);
 		return NULL;
 	}
 
 	config = nm_ip6_config_new ();
 	if (!config) {
-		nm_warning ("%s: Out of memory creating IP6 config object.",
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 config object.",
 		            iface);
 		return NULL;
 	}
diff --git a/src/ip6-manager/nm-ip6-manager.h b/src/ip6-manager/nm-ip6-manager.h
index 33b2b98..d0cf4b0 100644
--- a/src/ip6-manager/nm-ip6-manager.h
+++ b/src/ip6-manager/nm-ip6-manager.h
@@ -35,6 +35,12 @@
 #define NM_IS_IP6_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_IP6_MANAGER))
 #define NM_IP6_MANAGER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_IP6_MANAGER, NMIP6ManagerClass))
 
+enum {
+	IP6_DHCP_OPT_NONE = 0,
+	IP6_DHCP_OPT_OTHERCONF,
+	IP6_DHCP_OPT_MANAGED
+};
+
 typedef struct {
 	GObject parent;
 } NMIP6Manager;
@@ -47,13 +53,18 @@ typedef struct {
 	/* addrconf_complete is emitted only during initial configuration to indicate
 	 * that the initial configuration is complete.
 	 */
-	void (*addrconf_complete) (NMIP6Manager *manager, char *iface, gboolean success);
+	void (*addrconf_complete) (NMIP6Manager *manager,
+	                           char *iface,
+	                           guint dhcp_opts,
+	                           gboolean success);
 
 	/* config_changed gets emitted only *after* initial configuration is
 	 * complete; it's like DHCP renew and indicates that the existing config
 	 * of the interface has changed.
 	 */
-	void (*config_changed)    (NMIP6Manager *manager, char *iface);
+	void (*config_changed)    (NMIP6Manager *manager,
+	                           char *iface,
+	                           guint dhcp_opts);
 } NMIP6ManagerClass;
 
 GType nm_ip6_manager_get_type (void);
diff --git a/src/ip6-manager/nm-netlink-listener.c b/src/ip6-manager/nm-netlink-listener.c
index bfcc22f..55c4d76 100644
--- a/src/ip6-manager/nm-netlink-listener.c
+++ b/src/ip6-manager/nm-netlink-listener.c
@@ -43,9 +43,8 @@
 #include <glib/gi18n.h>
 
 #include "NetworkManager.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-netlink-listener.h"
-#include "nm-utils.h"
 #include "nm-marshal.h"
 #include "nm-netlink.h"
 
diff --git a/src/logging/Makefile.am b/src/logging/Makefile.am
new file mode 100644
index 0000000..d2e3e25
--- /dev/null
+++ b/src/logging/Makefile.am
@@ -0,0 +1,14 @@
+noinst_LTLIBRARIES = libnm-logging.la
+
+libnm_logging_la_SOURCES = \
+	nm-logging.c \
+	nm-logging.h
+
+libnm_logging_la_CPPFLAGS = \
+	$(GLIB_CFLAGS) \
+	-DLIBEXECDIR=\"$(libexecdir)\" \
+	-DG_DISABLE_DEPRECATED
+
+libnm_logging_la_LIBADD = \
+	$(GLIB_LIBS)
+
diff --git a/src/logging/nm-logging.c b/src/logging/nm-logging.c
new file mode 100644
index 0000000..ac30eb4
--- /dev/null
+++ b/src/logging/nm-logging.c
@@ -0,0 +1,347 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#define _GNU_SOURCE
+#include <dlfcn.h>
+#include <syslog.h>
+#include <execinfo.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <execinfo.h>
+#include <strings.h>
+#include <string.h>
+
+#include <glib/gi18n.h>
+
+#include "nm-logging.h"
+
+static guint32 log_level = LOGL_INFO | LOGL_WARN | LOGL_ERR;
+static guint32 log_domains = \
+	LOGD_HW | LOGD_RFKILL | LOGD_ETHER | LOGD_WIFI | LOGD_BT | LOGD_MB | \
+	LOGD_DHCP4 | LOGD_DHCP6 | LOGD_PPP | LOGD_IP4 | LOGD_IP6 | LOGD_AUTOIP4 | \
+	LOGD_DNS | LOGD_VPN | LOGD_SHARING | LOGD_SUPPLICANT | LOGD_USER_SET | \
+	LOGD_SYS_SET | LOGD_SUSPEND | LOGD_CORE | LOGD_DEVICE | LOGD_OLPC_MESH;
+
+typedef struct {
+	guint32 num;
+	const char *name;
+} LogDesc;
+
+static const LogDesc level_descs[] = {
+	{ LOGL_ERR, "ERR" },
+	{ LOGL_WARN | LOGL_ERR, "WARN" },
+	{ LOGL_INFO | LOGL_WARN | LOGL_ERR, "INFO" },
+	{ LOGL_DEBUG | LOGL_INFO | LOGL_WARN | LOGL_ERR, "DEBUG" },
+	{ 0, NULL }
+};
+
+static const LogDesc domain_descs[] = {
+	{ LOGD_NONE,      "NONE" },
+	{ LOGD_HW,        "HW" },
+	{ LOGD_RFKILL,    "RFKILL" },
+	{ LOGD_ETHER,     "ETHER" },
+	{ LOGD_WIFI,      "WIFI" },
+	{ LOGD_BT,        "BT" },
+	{ LOGD_MB,        "MB" },
+	{ LOGD_DHCP4,     "DHCP4" },
+	{ LOGD_DHCP6,     "DHCP6" },
+	{ LOGD_PPP,       "PPP" },
+	{ LOGD_WIFI_SCAN, "WIFI_SCAN" },
+	{ LOGD_IP4,       "IP4" },
+	{ LOGD_IP6,       "IP6" },
+	{ LOGD_AUTOIP4,   "AUTOIP4" },
+	{ LOGD_DNS,       "DNS" },
+	{ LOGD_VPN,       "VPN" },
+	{ LOGD_SHARING,   "SHARING" },
+	{ LOGD_SUPPLICANT,"SUPPLICANT" },
+	{ LOGD_USER_SET,  "USER_SET" },
+	{ LOGD_SYS_SET,   "SYS_SET" },
+	{ LOGD_SUSPEND,   "SUSPEND" },
+	{ LOGD_CORE,      "CORE" },
+	{ LOGD_DEVICE,    "DEVICE" },
+	{ LOGD_OLPC_MESH, "OLPC" },
+	{ 0, NULL }
+};
+
+/************************************************************************/
+
+enum {
+    NM_LOGGING_ERROR_UNKNOWN_LEVEL = 0,
+    NM_LOGGING_ERROR_UNKNOWN_DOMAIN = 1,
+};
+
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+GQuark
+nm_logging_error_quark (void)
+{
+    static GQuark ret = 0;
+
+    if (ret == 0)
+        ret = g_quark_from_static_string ("nm_logging_error");
+    return ret;
+}
+
+GType
+nm_logging_error_get_type (void)
+{
+    static GType etype = 0;
+
+    if (etype == 0) {
+        static const GEnumValue values[] = {
+            ENUM_ENTRY (NM_LOGGING_ERROR_UNKNOWN_LEVEL,  "UnknownLevel"),
+            ENUM_ENTRY (NM_LOGGING_ERROR_UNKNOWN_DOMAIN, "UnknownDomain"),
+            { 0, 0, 0 }
+        };
+        etype = g_enum_register_static ("NMLoggingError", values);
+    }
+    return etype;
+}
+
+/************************************************************************/
+
+gboolean
+nm_logging_setup (const char *level, const char *domains, GError **error)
+{
+	char **tmp, **iter;
+	guint32 new_domains = 0;
+
+	/* levels */
+	if (level && strlen (level)) {
+		gboolean found = FALSE;
+		const LogDesc *diter;
+
+		for (diter = &level_descs[0]; diter->name; diter++) {
+			if (!strcasecmp (diter->name, level)) {
+				log_level = diter->num;
+				found = TRUE;
+				break;
+			}
+		}
+
+		if (!found) {
+			g_set_error (error, NM_LOGGING_ERROR, NM_LOGGING_ERROR_UNKNOWN_LEVEL,
+			             _("Unknown log level '%s'"), level);
+			return FALSE;
+		}
+	}
+
+	/* domains */
+	if (domains && strlen (domains)) {
+		tmp = g_strsplit_set (domains, ", ", 0);
+		for (iter = tmp; iter && *iter; iter++) {
+			const LogDesc *diter;
+			gboolean found = FALSE;
+
+			if (!strlen (*iter))
+				continue;
+
+			for (diter = &domain_descs[0]; diter->name; diter++) {
+				if (!strcasecmp (diter->name, *iter)) {
+					new_domains |= diter->num;
+					found = TRUE;
+					break;
+				}
+			}
+
+			if (!found) {
+				g_set_error (error, NM_LOGGING_ERROR, NM_LOGGING_ERROR_UNKNOWN_DOMAIN,
+				             _("Unknown log domain '%s'"), *iter);
+				return FALSE;
+			}
+		}
+		g_strfreev (tmp);
+		log_domains = new_domains;
+	}
+
+	return TRUE;
+}
+
+void _nm_log (const char *loc,
+              const char *func,
+              guint32 domain,
+              guint32 level,
+              const char *fmt,
+              ...)
+{
+	va_list args;
+	char *msg;
+	GTimeVal tv;
+
+	if (!(log_level & level) || !(log_domains & domain))
+		return;
+
+	va_start (args, fmt);
+	msg = g_strdup_vprintf (fmt, args);
+	va_end (args);
+
+	if ((log_level & LOGL_DEBUG) && (level == LOGL_DEBUG)) {
+		g_get_current_time (&tv);
+		syslog (LOG_INFO, "<debug> [%ld.%ld] [%s] %s(): %s\n", tv.tv_sec, tv.tv_usec, loc, func, msg);
+	} else if ((log_level & LOGL_INFO) && (level == LOGL_INFO))
+		syslog (LOG_INFO, "<info> %s\n", msg);
+	else if ((log_level & LOGL_WARN) && (level == LOGL_WARN))
+		syslog (LOG_WARNING, "<warn> %s\n", msg);
+	else if ((log_level & LOGL_ERR) && (level == LOGL_ERR)) {
+		g_get_current_time (&tv);
+		syslog (LOG_ERR, "<error> [%ld.%ld] [%s] %s(): %s\n", tv.tv_sec, tv.tv_usec, loc, func, msg);
+	}
+	g_free (msg);
+}
+
+/************************************************************************/
+
+static void
+fallback_get_backtrace (void)
+{
+	void *frames[64];
+	Dl_info info;
+	size_t size;
+	guint32 i;
+	const char *name;
+
+	size = backtrace (frames, G_N_ELEMENTS (frames));
+
+	syslog (LOG_CRIT, "******************* START **********************************");
+	for (i = 0; i < size; i++) {
+		dladdr (frames[i], &info);
+		name = (info.dli_fname && *info.dli_fname) ? info.dli_fname : "(vdso)";
+		if (info.dli_saddr) {
+			syslog (LOG_CRIT, "Frame %d: %s (%s+0x%lx) [%p]",
+			        i, name,
+			        info.dli_sname,
+			        (gulong)(frames[i] - info.dli_saddr),
+			        frames[i]);
+		} else {
+			syslog (LOG_CRIT, "Frame %d: %s (%p+0x%lx) [%p]",
+			        i, name,
+			        info.dli_fbase,
+			        (gulong)(frames[i] - info.dli_saddr),
+			        frames[i]);
+		}
+	}
+	syslog (LOG_CRIT, "******************* END **********************************");
+}
+
+
+static gboolean
+crashlogger_get_backtrace (void)
+{
+	gboolean success = FALSE;
+	int pid;	
+
+	pid = fork();
+	if (pid > 0)
+	{
+		/* Wait for the child to finish */
+		int estatus;
+		if (waitpid (pid, &estatus, 0) != -1)
+		{
+			/* Only succeed if the crashlogger succeeded */
+			if (WIFEXITED (estatus) && (WEXITSTATUS (estatus) == 0))
+				success = TRUE;
+		}
+	}
+	else if (pid == 0)
+	{
+		/* Child process */
+		execl (LIBEXECDIR"/nm-crash-logger",
+				LIBEXECDIR"/nm-crash-logger", NULL);
+	}
+
+	return success;
+}
+
+
+void
+nm_logging_backtrace (void)
+{
+	struct stat s;
+	gboolean fallback = TRUE;
+	
+	/* Try to use gdb via nm-crash-logger if it exists, since
+	 * we get much better information out of it.  Otherwise
+	 * fall back to execinfo.
+	 */
+	if (stat (LIBEXECDIR"/nm-crash-logger", &s) == 0)
+		fallback = crashlogger_get_backtrace () ? FALSE : TRUE;
+
+	if (fallback)
+		fallback_get_backtrace ();
+}
+
+
+static void
+nm_log_handler (const gchar *log_domain,
+                GLogLevelFlags level,
+                const gchar *message,
+                gpointer ignored)
+{
+	int syslog_priority;	
+
+	switch (level) {
+	case G_LOG_LEVEL_ERROR:
+		syslog_priority = LOG_CRIT;
+		break;
+	case G_LOG_LEVEL_CRITICAL:
+		syslog_priority = LOG_ERR;
+		break;
+	case G_LOG_LEVEL_WARNING:
+		syslog_priority = LOG_WARNING;
+		break;
+	case G_LOG_LEVEL_MESSAGE:
+		syslog_priority = LOG_NOTICE;
+		break;
+	case G_LOG_LEVEL_DEBUG:
+		syslog_priority = LOG_DEBUG;
+		break;
+	case G_LOG_LEVEL_INFO:
+	default:
+		syslog_priority = LOG_INFO;
+		break;
+	}
+
+	syslog (syslog_priority, "%s", message);
+}
+
+void
+nm_logging_start (gboolean become_daemon)
+{
+	if (become_daemon)
+		openlog (G_LOG_DOMAIN, 0, LOG_DAEMON);
+	else
+		openlog (G_LOG_DOMAIN, LOG_CONS | LOG_PERROR, LOG_USER);
+
+	g_log_set_handler (G_LOG_DOMAIN, 
+	                   G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION,
+	                   nm_log_handler,
+	                   NULL);
+}
+
+void
+nm_logging_shutdown (void)
+{
+	closelog ();
+}
diff --git a/src/logging/nm-logging.h b/src/logging/nm-logging.h
new file mode 100644
index 0000000..2dc52d1
--- /dev/null
+++ b/src/logging/nm-logging.h
@@ -0,0 +1,108 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#ifndef NM_LOGGING_H
+#define NM_LOGGING_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+/* Log domains */
+enum {
+	LOGD_NONE       = 0x00000000,
+	LOGD_HW         = 0x00000001, /* Hardware detection and info */
+	LOGD_RFKILL     = 0x00000002,
+	LOGD_ETHER      = 0x00000004,
+	LOGD_WIFI       = 0x00000008,
+	LOGD_BT         = 0x00000010,
+	LOGD_MB         = 0x00000020, /* mobile broadband */
+	LOGD_DHCP4      = 0x00000040,
+	LOGD_DHCP6      = 0x00000080,
+	LOGD_PPP        = 0x00000100,
+	LOGD_WIFI_SCAN  = 0x00000200,
+	LOGD_IP4        = 0x00000400,
+	LOGD_IP6        = 0x00000800,
+	LOGD_AUTOIP4    = 0x00001000,
+	LOGD_DNS        = 0x00002000,
+	LOGD_VPN        = 0x00004000,
+	LOGD_SHARING    = 0x00008000, /* Connection sharing/dnsmasq */
+	LOGD_SUPPLICANT = 0x00010000, /* WiFi and 802.1x */
+	LOGD_USER_SET   = 0x00020000, /* User settings */
+	LOGD_SYS_SET    = 0x00040000, /* System settings */
+	LOGD_SUSPEND    = 0x00080000, /* Suspend/Resume */
+	LOGD_CORE       = 0x00100000, /* Core daemon and policy stuff */
+	LOGD_DEVICE     = 0x00200000, /* Device state and activation */
+	LOGD_OLPC_MESH  = 0x00400000,
+};
+
+#define LOGD_DHCP (LOGD_DHCP4 | LOGD_DHCP6)
+
+/* Log levels */
+enum {
+	LOGL_ERR   = 0x00000001,
+	LOGL_WARN  = 0x00000002,
+	LOGL_INFO  = 0x00000004,
+	LOGL_DEBUG = 0x00000008
+};
+
+#define NM_LOGGING_ERROR (nm_logging_error_quark ())
+#define NM_TYPE_LOGGING_ERROR (nm_logging_error_get_type ())
+GQuark nm_logging_error_quark    (void);
+GType  nm_logging_error_get_type (void);
+
+
+#define nm_log_err(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_ERR, fmt, ##args); }
+
+#define nm_log_warn(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_WARN, fmt, ##args); }
+
+#define nm_log_info(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_INFO, fmt, ##args); }
+
+#define nm_log_dbg(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_DEBUG, fmt, ##args); }
+
+#define nm_log(domain, level, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, level, fmt, ##args); }
+
+void _nm_log (const char *loc, const char *func,
+              guint32 domain, guint32 level,
+              const char *fmt, ...);
+
+/* Undefine the nm-utils.h logging stuff to ensure errors */
+#undef nm_print_backtrace
+#undef nm_get_timestamp
+#undef nm_info
+#undef nm_info_str
+#undef nm_debug
+#undef nm_debug_str
+#undef nm_warning
+#undef nm_warning_str
+#undef nm_error
+#undef nm_error_str
+
+gboolean nm_logging_setup     (const char *level, const char *domains, GError **error);
+void     nm_logging_start     (gboolean become_daemon);
+void     nm_logging_backtrace (void);
+void     nm_logging_shutdown  (void);
+
+#endif /* NM_LOGGING_H */
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 0000000..1d0ab53
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,744 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ * Copyright (C) 2005 - 2008 Novell, Inc.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <glib.h>
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib-lowlevel.h>
+#include <dbus/dbus-glib.h>
+#include <getopt.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <glib/gi18n.h>
+#include <gmodule.h>
+#include <string.h>
+
+#include "NetworkManager.h"
+#include "NetworkManagerUtils.h"
+#include "nm-manager.h"
+#include "nm-policy.h"
+#include "nm-system.h"
+#include "nm-named-manager.h"
+#include "nm-dbus-manager.h"
+#include "nm-supplicant-manager.h"
+#include "nm-dhcp-manager.h"
+#include "nm-hostname-provider.h"
+#include "nm-netlink-monitor.h"
+#include "nm-vpn-manager.h"
+#include "nm-logging.h"
+
+#if !defined(NM_DIST_VERSION)
+# define NM_DIST_VERSION VERSION
+#endif
+
+#define NM_DEFAULT_PID_FILE          LOCALSTATEDIR"/run/NetworkManager.pid"
+#define NM_DEFAULT_SYSTEM_CONF_FILE  SYSCONFDIR"/NetworkManager/NetworkManager.conf"
+#define NM_OLD_SYSTEM_CONF_FILE      SYSCONFDIR"/NetworkManager/nm-system-settings.conf"
+#define NM_DEFAULT_SYSTEM_STATE_FILE LOCALSTATEDIR"/lib/NetworkManager/NetworkManager.state"
+
+/*
+ * Globals
+ */
+static NMManager *manager = NULL;
+static GMainLoop *main_loop = NULL;
+
+typedef struct {
+	time_t time;
+	GQuark domain;
+	guint32 code;
+	guint32 count;
+} MonitorInfo;
+
+static gboolean
+detach_monitor (gpointer data)
+{
+	nm_log_warn (LOGD_HW, "detaching netlink event monitor");
+	nm_netlink_monitor_detach (NM_NETLINK_MONITOR (data));
+	return FALSE;
+}
+
+static void
+nm_error_monitoring_device_link_state (NMNetlinkMonitor *monitor,
+									   GError *error,
+									   gpointer user_data)
+{
+	MonitorInfo *info = (MonitorInfo *) user_data;
+	time_t now;
+
+	now = time (NULL);
+
+	if (   (info->domain != error->domain)
+	    || (info->code != error->code)
+	    || (info->time && now > info->time + 10)) {
+		/* FIXME: Try to handle the error instead of just printing it. */
+		nm_log_warn (LOGD_HW, "error monitoring device for netlink events: %s\n", error->message);
+
+		info->time = now;
+		info->domain = error->domain;
+		info->code = error->code;
+		info->count = 0;
+	}
+
+	info->count++;
+	if (info->count > 100) {
+		/* Broken drivers will sometimes cause a flood of netlink errors.
+		 * rh #459205, novell #443429, lp #284507
+		 */
+		nm_log_warn (LOGD_HW, "excessive netlink errors ocurred, disabling netlink monitor.");
+		nm_log_warn (LOGD_HW, "link change events will not be processed.");
+		g_idle_add_full (G_PRIORITY_HIGH, detach_monitor, monitor, NULL);
+	}
+}
+
+static gboolean
+nm_monitor_setup (GError **error)
+{
+	NMNetlinkMonitor *monitor;
+	MonitorInfo *info;
+
+	monitor = nm_netlink_monitor_get ();
+	if (!nm_netlink_monitor_open_connection (monitor, error)) {
+		g_object_unref (monitor);
+		return FALSE;
+	}
+
+	info = g_new0 (MonitorInfo, 1);
+	g_signal_connect_data (G_OBJECT (monitor), "error",
+						   G_CALLBACK (nm_error_monitoring_device_link_state),
+						   info,
+						   (GClosureNotify) g_free,
+						   0);
+	nm_netlink_monitor_attach (monitor);
+
+	/* Request initial status of cards */
+	nm_netlink_monitor_request_status (monitor, NULL);
+
+	return TRUE;
+}
+
+static gboolean quit_early = FALSE;
+
+static void
+nm_signal_handler (int signo)
+{
+	static int in_fatal = 0;
+
+	/* avoid loops */
+	if (in_fatal > 0)
+		return;
+	++in_fatal;
+
+	switch (signo)
+	{
+		case SIGSEGV:
+		case SIGBUS:
+		case SIGILL:
+		case SIGABRT:
+			nm_log_warn (LOGD_CORE, "caught signal %d. Generating backtrace...", signo);
+			nm_logging_backtrace ();
+			exit (1);
+			break;
+
+		case SIGFPE:
+		case SIGPIPE:
+			/* let the fatal signals interrupt us */
+			--in_fatal;
+
+			nm_log_warn (LOGD_CORE, "caught signal %d, shutting down abnormally. Generating backtrace...", signo);
+			nm_logging_backtrace ();
+			g_main_loop_quit (main_loop);
+			break;
+
+		case SIGINT:
+		case SIGTERM:
+			/* let the fatal signals interrupt us */
+			--in_fatal;
+
+			nm_log_info (LOGD_CORE, "caught signal %d, shutting down normally.", signo);
+			quit_early = TRUE;
+			g_main_loop_quit (main_loop);
+			break;
+
+		case SIGHUP:
+			--in_fatal;
+			/* FIXME:
+			 * Reread config stuff like system config files, VPN service files, etc
+			 */
+			break;
+
+		case SIGUSR1:
+			--in_fatal;
+			/* FIXME:
+			 * Play with log levels or something
+			 */
+			break;
+
+		default:
+			signal (signo, nm_signal_handler);
+			break;
+	}
+}
+
+static void
+setup_signals (void)
+{
+	struct sigaction action;
+	sigset_t mask;
+
+	sigemptyset (&mask);
+	action.sa_handler = nm_signal_handler;
+	action.sa_mask = mask;
+	action.sa_flags = 0;
+	sigaction (SIGTERM,  &action, NULL);
+	sigaction (SIGINT,  &action, NULL);
+	sigaction (SIGILL,  &action, NULL);
+	sigaction (SIGBUS,  &action, NULL);
+	sigaction (SIGFPE,  &action, NULL);
+	sigaction (SIGHUP,  &action, NULL);
+	sigaction (SIGSEGV, &action, NULL);
+	sigaction (SIGABRT, &action, NULL);
+	sigaction (SIGUSR1,  &action, NULL);
+}
+
+static gboolean
+write_pidfile (const char *pidfile)
+{
+ 	char pid[16];
+	int fd;
+	gboolean success = FALSE;
+ 
+	if ((fd = open (pidfile, O_CREAT|O_WRONLY|O_TRUNC, 00644)) < 0) {
+		fprintf (stderr, "Opening %s failed: %s\n", pidfile, strerror (errno));
+		return FALSE;
+	}
+
+ 	snprintf (pid, sizeof (pid), "%d", getpid ());
+	if (write (fd, pid, strlen (pid)) < 0)
+		fprintf (stderr, "Writing to %s failed: %s\n", pidfile, strerror (errno));
+	else
+		success = TRUE;
+
+	if (close (fd))
+		fprintf (stderr, "Closing %s failed: %s\n", pidfile, strerror (errno));
+
+	return success;
+}
+
+/* Check whether the pidfile already exists and contains PID of a running NetworkManager
+ *  Returns:  FALSE - specified pidfile doesn't exist or doesn't contain PID of a running NM process
+ *            TRUE  - specified pidfile already exists and contains PID of a running NM process
+ */
+static gboolean
+check_pidfile (const char *pidfile)
+{
+	char *contents = NULL;
+	gsize len = 0;
+	glong pid;
+	char *proc_cmdline = NULL;
+	gboolean nm_running = FALSE;
+	const char *process_name;
+
+	if (!g_file_get_contents (pidfile, &contents, &len, NULL))
+		return FALSE;
+
+	if (len <= 0)
+		goto done;
+
+	errno = 0;
+	pid = strtol (contents, NULL, 10);
+	if (pid <= 0 || pid > 65536 || errno)
+		goto done;
+
+	g_free (contents);
+	proc_cmdline = g_strdup_printf ("/proc/%ld/cmdline", pid);
+	if (!g_file_get_contents (proc_cmdline, &contents, &len, NULL))
+		goto done;
+
+	process_name = strrchr (contents, '/');
+	if (process_name)
+		process_name++;
+	else
+		process_name = contents;
+	if (strcmp (process_name, "NetworkManager") == 0) {
+		/* Check that the process exists */
+		if (kill (pid, 0) == 0) {
+			fprintf (stderr, "NetworkManager is already running (pid %ld)\n", pid);
+			nm_running = TRUE;
+		}
+	}
+
+done:
+	g_free (proc_cmdline);
+	g_free (contents);
+	return nm_running;
+}
+
+static gboolean
+parse_config_file (const char *filename,
+                   char **plugins,
+                   char **dhcp_client,
+                   char **log_level,
+                   char **log_domains,
+                   GError **error)
+{
+	GKeyFile *config;
+
+	config = g_key_file_new ();
+	if (!config) {
+		g_set_error (error, 0, 0,
+		             "Not enough memory to load config file.");
+		return FALSE;
+	}
+
+	g_key_file_set_list_separator (config, ',');
+	if (!g_key_file_load_from_file (config, filename, G_KEY_FILE_NONE, error))
+		return FALSE;
+
+	*plugins = g_key_file_get_value (config, "main", "plugins", error);
+	if (*error)
+		return FALSE;
+
+	*dhcp_client = g_key_file_get_value (config, "main", "dhcp", NULL);
+
+	*log_level = g_key_file_get_value (config, "logging", "level", NULL);
+	*log_domains = g_key_file_get_value (config, "logging", "domains", NULL);
+
+	g_key_file_free (config);
+	return TRUE;
+}
+
+static gboolean
+parse_state_file (const char *filename,
+                  gboolean *net_enabled,
+                  gboolean *wifi_enabled,
+                  gboolean *wwan_enabled,
+                  GError **error)
+{
+	GKeyFile *state_file;
+	GError *tmp_error = NULL;
+	gboolean wifi, net, wwan;
+
+	g_return_val_if_fail (net_enabled != NULL, FALSE);
+	g_return_val_if_fail (wifi_enabled != NULL, FALSE);
+	g_return_val_if_fail (wwan_enabled != NULL, FALSE);
+
+	state_file = g_key_file_new ();
+	if (!state_file) {
+		g_set_error (error, 0, 0,
+		             "Not enough memory to load state file.");
+		return FALSE;
+	}
+
+	g_key_file_set_list_separator (state_file, ',');
+	if (!g_key_file_load_from_file (state_file, filename, G_KEY_FILE_KEEP_COMMENTS, &tmp_error)) {
+		/* This is kinda ugly; create the file and directory if it doesn't
+		 * exist yet.  We can't rely on distros necessarily creating the
+		 * /var/lib/NetworkManager for us since we have to ensure that
+		 * users upgrading NM get this working too.
+		 */
+		if (   tmp_error->domain == G_FILE_ERROR
+		    && tmp_error->code == G_FILE_ERROR_NOENT) {
+			char *data, *dirname;
+			gsize len = 0;
+			gboolean ret = FALSE;
+
+			/* try to create the directory if it doesn't exist */
+			dirname = g_path_get_dirname (filename);
+			errno = 0;
+			if (mkdir (dirname, 0755) != 0) {
+				if (errno != EEXIST) {
+					g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_ACCES,
+					             "Error creating state directory %s: %d", dirname, errno);
+					g_free (dirname);
+					return FALSE;
+				}
+			}
+			g_free (dirname);
+
+			/* Write out the initial state to the state file */
+			g_key_file_set_boolean (state_file, "main", "NetworkingEnabled", *net_enabled);
+			g_key_file_set_boolean (state_file, "main", "WirelessEnabled", *wifi_enabled);
+			g_key_file_set_boolean (state_file, "main", "WWANEnabled", *wwan_enabled);
+
+			data = g_key_file_to_data (state_file, &len, NULL);
+			if (data)
+				ret = g_file_set_contents (filename, data, len, error);
+			g_free (data);
+
+			return ret;
+		} else {
+			g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+			g_clear_error (&tmp_error);
+		}
+
+		/* Otherwise, file probably corrupt or inaccessible */
+		return FALSE;
+	}
+
+	/* Reading state bits of NetworkManager; an error leaves the passed-in state
+	 * value unchanged.
+	 */
+	net = g_key_file_get_boolean (state_file, "main", "NetworkingEnabled", &tmp_error);
+	if (tmp_error)
+		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+	else
+		*net_enabled = net;
+	g_clear_error (&tmp_error);
+
+	wifi = g_key_file_get_boolean (state_file, "main", "WirelessEnabled", &tmp_error);
+	if (tmp_error) {
+		g_clear_error (error);
+		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+	} else
+		*wifi_enabled = wifi;
+	g_clear_error (&tmp_error);
+
+	wwan = g_key_file_get_boolean (state_file, "main", "WWANEnabled", &tmp_error);
+	if (tmp_error) {
+		g_clear_error (error);
+		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+	} else
+		*wwan_enabled = wwan;
+	g_clear_error (&tmp_error);
+
+	g_key_file_free (state_file);
+
+	return TRUE;
+}
+
+/*
+ * main
+ *
+ */
+int
+main (int argc, char *argv[])
+{
+	GOptionContext *opt_ctx = NULL;
+	gboolean become_daemon = FALSE;
+	gboolean g_fatal_warnings = FALSE;
+	char *pidfile = NULL, *state_file = NULL, *dhcp = NULL;
+	char *config = NULL, *plugins = NULL, *conf_plugins = NULL;
+	char *log_level = NULL, *log_domains = NULL;
+	gboolean wifi_enabled = TRUE, net_enabled = TRUE, wwan_enabled = TRUE;
+	gboolean success;
+	NMPolicy *policy = NULL;
+	NMVPNManager *vpn_manager = NULL;
+	NMNamedManager *named_mgr = NULL;
+	NMDBusManager *dbus_mgr = NULL;
+	NMSupplicantManager *sup_mgr = NULL;
+	NMDHCPManager *dhcp_mgr = NULL;
+	GError *error = NULL;
+	gboolean wrote_pidfile = FALSE;
+	char *cfg_log_level = NULL, *cfg_log_domains = NULL;
+
+	GOptionEntry options[] = {
+		{ "no-daemon", 0, 0, G_OPTION_ARG_NONE, &become_daemon, "Don't become a daemon", NULL },
+		{ "g-fatal-warnings", 0, 0, G_OPTION_ARG_NONE, &g_fatal_warnings, "Make all warnings fatal", NULL },
+		{ "pid-file", 0, 0, G_OPTION_ARG_FILENAME, &pidfile, "Specify the location of a PID file", "filename" },
+		{ "state-file", 0, 0, G_OPTION_ARG_FILENAME, &state_file, "State file location", "/path/to/state.file" },
+		{ "config", 0, 0, G_OPTION_ARG_FILENAME, &config, "Config file location", "/path/to/config.file" },
+		{ "plugins", 0, 0, G_OPTION_ARG_STRING, &plugins, "List of plugins separated by ','", "plugin1,plugin2" },
+		{ "log-level", 0, 0, G_OPTION_ARG_STRING, &log_level, "Log level: one of [ERR, WARN, INFO, DEBUG]", "INFO" },
+		{ "log-domains", 0, 0, G_OPTION_ARG_STRING, &log_domains,
+		        "Log domains separated by ',': any combination of [NONE,HW,RKILL,ETHER,WIFI,BT,MB,DHCP4,DHCP6,PPP,WIFI_SCAN,IP4,IP6,AUTOIP4,DNS,VPN,SHARING,SUPPLICANT,USER_SET,SYS_SET,SUSPEND,CORE,DEVICE,OLPC]",
+		        "HW,RFKILL,WIFI" },
+		{NULL}
+	};
+
+	if (getuid () != 0) {
+		fprintf (stderr, "You must be root to run NetworkManager!\n");
+		exit (1);
+	}
+
+	if (!g_module_supported ()) {
+		fprintf (stderr, "GModules are not supported on your platform!\n");
+		exit (1);
+	}
+
+	bindtextdomain (GETTEXT_PACKAGE, NMLOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+	textdomain (GETTEXT_PACKAGE);
+
+	/* Parse options */
+	opt_ctx = g_option_context_new ("");
+	g_option_context_set_translation_domain (opt_ctx, "UTF-8");
+	g_option_context_set_ignore_unknown_options (opt_ctx, FALSE);
+	g_option_context_set_help_enabled (opt_ctx, TRUE);
+	g_option_context_add_main_entries (opt_ctx, options, NULL);
+
+	g_option_context_set_summary (opt_ctx,
+		"NetworkManager monitors all network connections and automatically\nchooses the best connection to use.  It also allows the user to\nspecify wireless access points which wireless cards in the computer\nshould associate with.");
+
+	success = g_option_context_parse (opt_ctx, &argc, &argv, NULL);
+	g_option_context_free (opt_ctx);
+
+	if (!success) {
+		fprintf (stderr, _("Invalid option.  Please use --help to see a list of valid options.\n"));
+		exit (1);
+	}
+
+	pidfile = pidfile ? pidfile : g_strdup (NM_DEFAULT_PID_FILE);
+	state_file = state_file ? state_file : g_strdup (NM_DEFAULT_SYSTEM_STATE_FILE);
+
+	/* check pid file */
+	if (check_pidfile (pidfile))
+		exit (1);
+
+	/* Parse the config file */
+	if (config) {
+		if (!parse_config_file (config, &conf_plugins, &dhcp, &cfg_log_level, &cfg_log_domains, &error)) {
+			fprintf (stderr, "Config file %s invalid: (%d) %s\n",
+			         config,
+			         error ? error->code : -1,
+			         (error && error->message) ? error->message : "unknown");
+			exit (1);
+		}
+	} else {
+		gboolean parsed = FALSE;
+
+		/* Try NetworkManager.conf first */
+		if (g_file_test (NM_DEFAULT_SYSTEM_CONF_FILE, G_FILE_TEST_EXISTS)) {
+			config = g_strdup (NM_DEFAULT_SYSTEM_CONF_FILE);
+			parsed = parse_config_file (config, &conf_plugins, &dhcp, &cfg_log_level, &cfg_log_domains, &error);
+			if (!parsed) {
+				fprintf (stderr, "Default config file %s invalid: (%d) %s\n",
+				         config,
+				         error ? error->code : -1,
+				         (error && error->message) ? error->message : "unknown");
+				g_free (config);
+				config = NULL;
+				g_clear_error (&error);
+				/* Not a hard failure */
+			}
+		}
+
+		/* Try old nm-system-settings.conf next */
+		if (!parsed) {
+			config = g_strdup (NM_OLD_SYSTEM_CONF_FILE);
+			if (!parse_config_file (config, &conf_plugins, &dhcp, &cfg_log_level, &cfg_log_domains, &error)) {
+				fprintf (stderr, "Default config file %s invalid: (%d) %s\n",
+				         config,
+				         error ? error->code : -1,
+				         (error && error->message) ? error->message : "unknown");
+				g_free (config);
+				config = NULL;
+				g_clear_error (&error);
+				/* Not a hard failure */
+			}
+		}
+	}
+
+	/* Logging setup */
+	if (!nm_logging_setup (log_level ? log_level : cfg_log_level,
+	                       log_domains ? log_domains : cfg_log_domains,
+	                       &error)) {
+		fprintf (stderr,
+		         _("%s.  Please use --help to see a list of valid options.\n"),
+		         error->message);
+		exit (1);
+	}
+
+	/* Plugins specified with '--plugins' override those of config file */
+	plugins = plugins ? plugins : g_strdup (conf_plugins);
+	g_free (conf_plugins);
+
+	/* Parse the state file */
+	if (!parse_state_file (state_file, &net_enabled, &wifi_enabled, &wwan_enabled, &error)) {
+		fprintf (stderr, "State file %s parsing failed: (%d) %s\n",
+		         state_file,
+		         error ? error->code : -1,
+		         (error && error->message) ? error->message : "unknown");
+		/* Not a hard failure */
+	}
+	g_clear_error (&error);
+
+	/* Tricky: become_daemon is FALSE by default, so unless it's TRUE because
+	 * of a CLI option, it'll become TRUE after this
+	 */
+	become_daemon = !become_daemon;
+	if (become_daemon) {
+		if (daemon (0, 0) < 0) {
+			int saved_errno;
+
+			saved_errno = errno;
+			fprintf (stderr, "Could not daemonize: %s [error %u]\n",
+			         g_strerror (saved_errno),
+			         saved_errno);
+			exit (1);
+		}
+		if (write_pidfile (pidfile))
+			wrote_pidfile = TRUE;
+	}
+
+	if (g_fatal_warnings) {
+		GLogLevelFlags fatal_mask;
+
+		fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
+		fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
+		g_log_set_always_fatal (fatal_mask);
+	}
+
+	/*
+	 * Set the umask to 0022, which results in 0666 & ~0022 = 0644.
+	 * Otherwise, if root (or an su'ing user) has a wacky umask, we could
+	 * write out an unreadable resolv.conf.
+	 */
+	umask (022);
+
+	g_type_init ();
+	if (!g_thread_supported ())
+		g_thread_init (NULL);
+	dbus_g_thread_init ();
+
+	setup_signals ();
+
+	nm_logging_start (become_daemon);
+
+	nm_log_info (LOGD_CORE, "NetworkManager (version " NM_DIST_VERSION ") is starting...");
+	success = FALSE;
+
+	main_loop = g_main_loop_new (NULL, FALSE);
+
+	/* Create watch functions that monitor cards for link status. */
+	if (!nm_monitor_setup (&error)) {
+		nm_log_err (LOGD_CORE, "failed to start monitoring devices: %s.",
+		            error && error->message ? error->message : "(unknown)");
+		goto done;
+	}
+
+	/* Initialize our DBus service & connection */
+	dbus_mgr = nm_dbus_manager_get ();
+
+	vpn_manager = nm_vpn_manager_get ();
+	if (!vpn_manager) {
+		nm_log_err (LOGD_CORE, "failed to start the VPN manager.");
+		goto done;
+	}
+
+	named_mgr = nm_named_manager_get ();
+	if (!named_mgr) {
+		nm_log_err (LOGD_CORE, "failed to start the named manager.");
+		goto done;
+	}
+
+	manager = nm_manager_get (config,
+	                          plugins,
+	                          state_file,
+	                          net_enabled,
+	                          wifi_enabled,
+	                          wwan_enabled,
+	                          &error);
+	if (manager == NULL) {
+		nm_log_err (LOGD_CORE, "failed to initialize the network manager: %s",
+		          error && error->message ? error->message : "(unknown)");
+		goto done;
+	}
+
+	policy = nm_policy_new (manager, vpn_manager);
+	if (policy == NULL) {
+		nm_log_err (LOGD_CORE, "failed to initialize the policy.");
+		goto done;
+	}
+
+	/* Initialize the supplicant manager */
+	sup_mgr = nm_supplicant_manager_get ();
+	if (!sup_mgr) {
+		nm_log_err (LOGD_CORE, "failed to initialize the supplicant manager.");
+		goto done;
+	}
+
+	/* Initialize DHCP manager */
+	dhcp_mgr = nm_dhcp_manager_new (dhcp, &error);
+	if (!dhcp_mgr) {
+		nm_log_err (LOGD_CORE, "failed to start the DHCP manager: %s.", error->message);
+		goto done;
+	}
+
+	nm_dhcp_manager_set_hostname_provider (dhcp_mgr, NM_HOSTNAME_PROVIDER (manager));
+
+	/* Start our DBus service */
+	if (!nm_dbus_manager_start_service (dbus_mgr)) {
+		nm_log_err (LOGD_CORE, "failed to start the dbus service.");
+		goto done;
+	}
+
+	nm_manager_start (manager);
+
+	/* Bring up the loopback interface. */
+	nm_system_enable_loopback ();
+
+	success = TRUE;
+
+	/* Told to quit before getting to the mainloop by the signal handler */
+	if (quit_early == TRUE)
+		goto done;
+
+	g_main_loop_run (main_loop);
+
+done:
+	if (policy)
+		nm_policy_destroy (policy);
+
+	if (manager)
+		g_object_unref (manager);
+
+	if (vpn_manager)
+		g_object_unref (vpn_manager);
+
+	if (named_mgr)
+		g_object_unref (named_mgr);
+
+	if (dhcp_mgr)
+		g_object_unref (dhcp_mgr);
+
+	if (sup_mgr)
+		g_object_unref (sup_mgr);
+
+	if (dbus_mgr)
+		g_object_unref (dbus_mgr);
+
+	nm_logging_shutdown ();
+
+	if (pidfile && wrote_pidfile)
+		unlink (pidfile);
+
+	/* Free options */
+	g_free (pidfile);
+	g_free (state_file);
+	g_free (config);
+	g_free (plugins);
+	g_free (dhcp);
+	g_free (log_level);
+	g_free (log_domains);
+	g_free (cfg_log_level);
+	g_free (cfg_log_domains);
+
+	nm_log_info (LOGD_CORE, "exiting (%s)", success ? "success" : "error");
+	exit (success ? 0 : 1);
+}
diff --git a/src/modem-manager/Makefile.am b/src/modem-manager/Makefile.am
index fef879a..a0f65c1 100644
--- a/src/modem-manager/Makefile.am
+++ b/src/modem-manager/Makefile.am
@@ -1,5 +1,6 @@
 INCLUDES = \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_builddir}/marshallers
@@ -7,12 +8,12 @@ INCLUDES = \
 noinst_LTLIBRARIES = libmodem-manager.la
 
 libmodem_manager_la_SOURCES = \
+	nm-modem.c \
+	nm-modem.h \
 	nm-modem-cdma.c \
 	nm-modem-cdma.h \
 	nm-modem-gsm.c \
 	nm-modem-gsm.h \
-	nm-modem.c \
-	nm-modem.h \
 	nm-modem-manager.h \
 	nm-modem-manager.c \
 	nm-modem-types.h
@@ -22,20 +23,13 @@ libmodem_manager_la_CPPFLAGS = \
 
 libmodem_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS)
 
-nm-device-cdma-glue.h: $(top_srcdir)/introspection/nm-device-cdma.xml
-	dbus-binding-tool --prefix=nm_device_cdma --mode=glib-server --output=$@ $<
-
-nm-device-gsm-glue.h: $(top_srcdir)/introspection/nm-device-gsm.xml
-	dbus-binding-tool --prefix=nm_device_gsm --mode=glib-server --output=$@ $<
-
 nm-serial-device-glue.h: $(top_srcdir)/introspection/nm-device-serial.xml
 	dbus-binding-tool --prefix=nm_serial_device --mode=glib-server --output=$@ $<
 
 BUILT_SOURCES = \
-	nm-device-cdma-glue.h \
-	nm-device-gsm-glue.h \
 	nm-serial-device-glue.h
 
 CLEANFILES = $(BUILT_SOURCES)
diff --git a/src/modem-manager/nm-modem-cdma.c b/src/modem-manager/nm-modem-cdma.c
index 5e8405b..c32c182 100644
--- a/src/modem-manager/nm-modem-cdma.c
+++ b/src/modem-manager/nm-modem-cdma.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  */
 
@@ -24,18 +24,23 @@
 #include "nm-dbus-glib-types.h"
 #include "nm-modem-cdma.h"
 #include "nm-modem-types.h"
-#include "nm-device-interface.h"
-#include "nm-device-private.h"
+#include "nm-device.h"
 #include "nm-dbus-manager.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-cdma.h"
-#include "nm-utils.h"
 #include "NetworkManagerUtils.h"
-
-#include "nm-device-cdma-glue.h"
+#include "nm-logging.h"
 
 G_DEFINE_TYPE (NMModemCdma, nm_modem_cdma, NM_TYPE_MODEM)
 
+#define NM_MODEM_CDMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM_CDMA, NMModemCdmaPrivate))
+
+typedef struct {
+	DBusGProxyCall *call;
+
+	GHashTable *connect_properties;
+} NMModemCdmaPrivate;
+
 
 typedef enum {
 	NM_CDMA_ERROR_CONNECTION_NOT_CDMA = 0,
@@ -79,43 +84,77 @@ nm_cdma_error_get_type (void)
 }
 
 
-NMDevice *
+NMModem *
 nm_modem_cdma_new (const char *path,
                    const char *device,
                    const char *data_device,
-                   const char *driver)
+                   guint32 ip_method)
 {
 	g_return_val_if_fail (path != NULL, NULL);
 	g_return_val_if_fail (device != NULL, NULL);
 	g_return_val_if_fail (data_device != NULL, NULL);
-	g_return_val_if_fail (driver != NULL, NULL);
-
-	return (NMDevice *) g_object_new (NM_TYPE_MODEM_CDMA,
-	                                  NM_DEVICE_INTERFACE_UDI, path,
-	                                  NM_DEVICE_INTERFACE_IFACE, data_device,
-	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
-	                                  NM_MODEM_PATH, path,
-	                                  NM_MODEM_DEVICE, device,
-	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "CDMA",
-	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_CDMA,
-	                                  NULL);
+
+	return (NMModem *) g_object_new (NM_TYPE_MODEM_CDMA,
+	                                 NM_MODEM_PATH, path,
+	                                 NM_MODEM_DEVICE, device,
+	                                 NM_MODEM_IFACE, data_device,
+	                                 NM_MODEM_IP_METHOD, ip_method,
+	                                 NULL);
 }
 
 static void
-stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModemCdma *self = NM_MODEM_CDMA (user_data);
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
 	GError *error = NULL;
 
-	dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID);
-	if (!error)
-		nm_device_activate_schedule_stage2_device_config (device);
+	priv->call = NULL;
+
+	if (priv->connect_properties) {
+		g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = NULL;
+	}
+
+	if (dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID))
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, TRUE, NM_DEVICE_STATE_REASON_NONE);
 	else {
-		nm_warning ("CDMA modem connection failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_MB, "CDMA connection failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 		g_error_free (error);
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_NONE);
+	}
+}
+
+static void
+do_connect (NMModemCdma *self)
+{
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
+	DBusGProxy *proxy;
+
+	proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM_SIMPLE);
+	priv->call = dbus_g_proxy_begin_call_with_timeout (proxy,
+	                                                   "Connect", stage1_prepare_done,
+	                                                   self, NULL, 120000,
+	                                                   DBUS_TYPE_G_MAP_OF_VARIANT, priv->connect_properties,
+	                                                   G_TYPE_INVALID);
+}
+
+static void
+stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModemCdma *self = NM_MODEM_CDMA (user_data);
+	GError *error = NULL;
+
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
+		do_connect (self);
+	else {
+		nm_log_warn (LOGD_MB, "CDMA modem enable failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		g_error_free (error);
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
 	}
 }
 
@@ -136,61 +175,48 @@ create_connect_properties (NMConnection *connection)
 	return properties;
 }
 
-static void
-do_connect (NMModem *modem)
+static NMActStageReturn
+real_act_stage1_prepare (NMModem *modem,
+                         NMActRequest *req,
+                         GPtrArray **out_hints,
+                         const char **out_setting_name,
+                         NMDeviceStateReason *reason)
 {
+	NMModemCdma *self = NM_MODEM_CDMA (modem);
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
 	NMConnection *connection;
-	GHashTable *properties;
 
-	connection = nm_act_request_get_connection (nm_device_get_act_request (NM_DEVICE (modem)));
+	connection = nm_act_request_get_connection (req);
 	g_assert (connection);
 
-	properties = create_connect_properties (connection);
-	dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE),
-	                                      "Connect", stage1_prepare_done,
-	                                      modem, NULL, 120000,
-	                                      DBUS_TYPE_G_MAP_OF_VARIANT, properties,
-	                                      G_TYPE_INVALID);
-	g_hash_table_destroy (properties);
-}
-
-static void
-stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	GError *error = NULL;
-
-	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
-		do_connect (NM_MODEM (device));
-	else {
-		nm_warning ("CDMA modem enable failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
-		g_error_free (error);
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
-	}
-}
-
-static NMActStageReturn
-real_act_stage1_prepare (NMDevice *device, NMDeviceStateReason *reason)
-{
-	gboolean enabled = nm_modem_get_mm_enabled (NM_MODEM (device));
-
-	if (enabled)
-		do_connect (NM_MODEM (device));
-	else {
-		dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (NM_MODEM (device), MM_DBUS_INTERFACE_MODEM),
-		                                      "Enable", stage1_enable_done,
-		                                      device, NULL, 20000,
-		                                      G_TYPE_BOOLEAN, TRUE,
-		                                      G_TYPE_INVALID);
+	*out_setting_name = nm_connection_need_secrets (connection, out_hints);
+	if (!*out_setting_name) {
+		gboolean enabled = nm_modem_get_mm_enabled (modem);
+		DBusGProxy *proxy;
+
+		if (priv->connect_properties)
+			g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = create_connect_properties (connection);
+
+		if (enabled)
+			do_connect (self);
+		else {
+			proxy = nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM);
+			dbus_g_proxy_begin_call_with_timeout (proxy,
+			                                      "Enable", stage1_enable_done,
+			                                      modem, NULL, 20000,
+			                                      G_TYPE_BOOLEAN, TRUE,
+			                                      G_TYPE_INVALID);
+		}
+	} else {
+		/* NMModem will handle requesting secrets... */
 	}
 
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
 static NMConnection *
-real_get_best_auto_connection (NMDevice *dev,
+real_get_best_auto_connection (NMModem *modem,
 							   GSList *connections,
 							   char **specific_object)
 {
@@ -214,71 +240,8 @@ real_get_best_auto_connection (NMDevice *dev,
 	return NULL;
 }
 
-static void
-real_connection_secrets_updated (NMDevice *dev,
-								 NMConnection *connection,
-								 GSList *updated_settings,
-								 RequestSecretsCaller caller)
-{
-	NMActRequest *req;
-	gboolean found = FALSE;
-	GSList *iter;
-
-	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (dev)));
-
-	if (caller == SECRETS_CALLER_PPP) {
-		NMPPPManager *ppp_manager;
-		NMSettingCdma *s_cdma = NULL;
-
-		ppp_manager = nm_modem_get_ppp_manager (NM_MODEM (dev));
-		g_return_if_fail (ppp_manager != NULL);
-
-		s_cdma = (NMSettingCdma *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CDMA);
-		if (!s_cdma) {
-			/* Shouldn't ever happen */
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   NULL,
-										   NULL,
-										   "missing CDMA setting; no secrets could be found.");
-		} else {
-			const char *username = nm_setting_cdma_get_username (s_cdma);
-			const char *password = nm_setting_cdma_get_password (s_cdma);
-
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   username ? username : "",
-										   password ? password : "",
-										   NULL);
-		}
-		return;
-	}
-
-	g_return_if_fail (caller == SECRETS_CALLER_CDMA);
-	g_return_if_fail (nm_device_get_state (dev) == NM_DEVICE_STATE_NEED_AUTH);
-
-	for (iter = updated_settings; iter; iter = g_slist_next (iter)) {
-		const char *setting_name = (const char *) iter->data;
-
-		if (!strcmp (setting_name, NM_SETTING_CDMA_SETTING_NAME))
-			found = TRUE;
-		else
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
-	}
-
-	if (!found)
-		return;
-
-	req = nm_device_get_act_request (dev);
-	g_assert (req);
-
-	g_return_if_fail (nm_act_request_get_connection (req) == connection);
-
-	nm_device_activate_schedule_stage1_device_prepare (dev);
-}
-
 static gboolean
-real_check_connection_compatible (NMDevice *device,
+real_check_connection_compatible (NMModem *modem,
                                   NMConnection *connection,
                                   GError **error)
 {
@@ -306,15 +269,46 @@ real_check_connection_compatible (NMDevice *device,
 	return TRUE;
 }
 
-static const char *
-real_get_ppp_name (NMModem *device, NMConnection *connection)
+static gboolean
+real_get_user_pass (NMModem *modem,
+                    NMConnection *connection,
+                    const char **user,
+                    const char **pass)
 {
 	NMSettingCdma *s_cdma;
 
 	s_cdma = (NMSettingCdma *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CDMA);
-	g_assert (s_cdma);
+	if (!s_cdma)
+		return FALSE;
 
-	return nm_setting_cdma_get_username (s_cdma);
+	if (user)
+		*user = nm_setting_cdma_get_username (s_cdma);
+	if (pass)
+		*pass = nm_setting_cdma_get_password (s_cdma);
+
+	return TRUE;
+}
+
+static const char *
+real_get_setting_name (NMModem *modem)
+{
+	return NM_SETTING_CDMA_SETTING_NAME;
+}
+
+static void
+real_deactivate_quickly (NMModem *modem, NMDevice *device)
+{
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (modem);
+
+	if (priv->call) {
+		DBusGProxy *proxy;
+
+		proxy = nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE);
+		dbus_g_proxy_cancel_call (proxy, priv->call);
+		priv->call = NULL;
+	}
+
+	NM_MODEM_CLASS (nm_modem_cdma_parent_class)->deactivate_quickly (modem, device);	
 }
 
 /*****************************************************************************/
@@ -325,21 +319,33 @@ nm_modem_cdma_init (NMModemCdma *self)
 }
 
 static void
+dispose (GObject *object)
+{
+	NMModemCdma *self = NM_MODEM_CDMA (object);
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
+
+	if (priv->connect_properties)
+		g_hash_table_destroy (priv->connect_properties);
+
+	G_OBJECT_CLASS (nm_modem_cdma_parent_class)->dispose (object);
+}
+
+static void
 nm_modem_cdma_class_init (NMModemCdmaClass *klass)
 {
-	NMDeviceClass *device_class = NM_DEVICE_CLASS (klass);
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMModemClass *modem_class = NM_MODEM_CLASS (klass);
 
-	/* Virtual methods */
-	device_class->get_best_auto_connection = real_get_best_auto_connection;
-	device_class->connection_secrets_updated = real_connection_secrets_updated;
-	device_class->act_stage1_prepare = real_act_stage1_prepare;
-	device_class->check_connection_compatible = real_check_connection_compatible;
+	g_type_class_add_private (object_class, sizeof (NMModemCdmaPrivate));
 
-	modem_class->get_ppp_name = real_get_ppp_name;
-
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
-	                                 &dbus_glib_nm_device_cdma_object_info);
+	/* Virtual methods */
+	object_class->dispose = dispose;
+	modem_class->get_user_pass = real_get_user_pass;
+	modem_class->get_setting_name = real_get_setting_name;
+	modem_class->get_best_auto_connection = real_get_best_auto_connection;
+	modem_class->check_connection_compatible = real_check_connection_compatible;
+	modem_class->act_stage1_prepare = real_act_stage1_prepare;
+	modem_class->deactivate_quickly = real_deactivate_quickly;
 
 	dbus_g_error_domain_register (NM_CDMA_ERROR, NULL, NM_TYPE_CDMA_ERROR);
 }
diff --git a/src/modem-manager/nm-modem-cdma.h b/src/modem-manager/nm-modem-cdma.h
index 7c98ab2..0abe4e0 100644
--- a/src/modem-manager/nm-modem-cdma.h
+++ b/src/modem-manager/nm-modem-cdma.h
@@ -46,10 +46,10 @@ typedef struct {
 
 GType nm_modem_cdma_get_type (void);
 
-NMDevice *nm_modem_cdma_new (const char *path,
-                             const char *device,
-                             const char *data_device,
-                             const char *driver);
+NMModem *nm_modem_cdma_new (const char *path,
+                            const char *device,
+                            const char *data_device,
+                            guint32 ip_method);
 
 G_END_DECLS
 
diff --git a/src/modem-manager/nm-modem-gsm.c b/src/modem-manager/nm-modem-gsm.c
index fcc811f..abb96db 100644
--- a/src/modem-manager/nm-modem-gsm.c
+++ b/src/modem-manager/nm-modem-gsm.c
@@ -15,46 +15,58 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  */
 
 #include <string.h>
 #include "nm-dbus-glib-types.h"
 #include "nm-modem-gsm.h"
-#include "nm-device-private.h"
-#include "nm-device-interface.h"
+#include "nm-device.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-gsm.h"
 #include "nm-modem-types.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
 
-#include "nm-device-gsm-glue.h"
+typedef enum {
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_ANY = 0,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_GPRS,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_EDGE,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_UMTS,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSDPA,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_PREFERRED,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_PREFERRED,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_ONLY,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_ONLY,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSUPA,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSPA,
+
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_LAST = MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSPA
+} MMModemDeprecatedMode;
 
 typedef enum {
-    MM_MODEM_GSM_MODE_UNKNOWN      = 0x00000000,
-    MM_MODEM_GSM_MODE_ANY          = 0x00000001,
-    MM_MODEM_GSM_MODE_GPRS         = 0x00000002,
-    MM_MODEM_GSM_MODE_EDGE         = 0x00000004,
-    MM_MODEM_GSM_MODE_UMTS         = 0x00000008,
-    MM_MODEM_GSM_MODE_HSDPA        = 0x00000010,
-    MM_MODEM_GSM_MODE_2G_PREFERRED = 0x00000020,
-    MM_MODEM_GSM_MODE_3G_PREFERRED = 0x00000040,
-    MM_MODEM_GSM_MODE_2G_ONLY      = 0x00000080,
-    MM_MODEM_GSM_MODE_3G_ONLY      = 0x00000100,
-    MM_MODEM_GSM_MODE_HSUPA        = 0x00000200,
-    MM_MODEM_GSM_MODE_HSPA         = 0x00000400,
-
-    MM_MODEM_GSM_MODE_LAST = MM_MODEM_GSM_MODE_HSPA
-} MMModemGsmMode;
-
-
-#define GSM_SECRETS_TRIES "gsm-secrets-tries"
-#define PIN_TRIES "pin-tries"
+    MM_MODEM_GSM_ALLOWED_MODE_ANY          = 0,
+    MM_MODEM_GSM_ALLOWED_MODE_2G_PREFERRED = 1,
+    MM_MODEM_GSM_ALLOWED_MODE_3G_PREFERRED = 2,
+    MM_MODEM_GSM_ALLOWED_MODE_2G_ONLY      = 3,
+    MM_MODEM_GSM_ALLOWED_MODE_3G_ONLY      = 4,
+
+    MM_MODEM_GSM_ALLOWED_MODE_LAST = MM_MODEM_GSM_ALLOWED_MODE_3G_ONLY
+} MMModemGsmAllowedMode;
+
 
 G_DEFINE_TYPE (NMModemGsm, nm_modem_gsm, NM_TYPE_MODEM)
 
+#define NM_MODEM_GSM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM_GSM, NMModemGsmPrivate))
+
+typedef struct {
+	DBusGProxyCall *call;
+
+	GHashTable *connect_properties;
+	guint32 pin_tries;
+} NMModemGsmPrivate;
+
 
 typedef enum {
 	NM_GSM_ERROR_CONNECTION_NOT_GSM = 0,
@@ -98,28 +110,22 @@ nm_gsm_error_get_type (void)
 }
 
 
-NMDevice *
+NMModem *
 nm_modem_gsm_new (const char *path,
                   const char *device,
                   const char *data_device,
-                  const char *driver,
                   guint32 ip_method)
 {
 	g_return_val_if_fail (path != NULL, NULL);
 	g_return_val_if_fail (device != NULL, NULL);
 	g_return_val_if_fail (data_device != NULL, NULL);
-	g_return_val_if_fail (driver != NULL, NULL);
-
-	return (NMDevice *) g_object_new (NM_TYPE_MODEM_GSM,
-	                                  NM_DEVICE_INTERFACE_UDI, path,
-	                                  NM_DEVICE_INTERFACE_IFACE, data_device,
-	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
-	                                  NM_MODEM_PATH, path,
-	                                  NM_MODEM_IP_METHOD, ip_method,
-	                                  NM_MODEM_DEVICE, device,
-	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "GSM",
-	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_GSM,
-	                                  NULL);
+
+	return (NMModem *) g_object_new (NM_TYPE_MODEM_GSM,
+	                                 NM_MODEM_PATH, path,
+	                                 NM_MODEM_DEVICE, device,
+	                                 NM_MODEM_IFACE, data_device,
+	                                 NM_MODEM_IP_METHOD, ip_method,
+	                                 NULL);
 }
 
 static NMDeviceStateReason
@@ -158,93 +164,159 @@ translate_mm_error (GError *error)
 }
 
 static void
-clear_pin (NMDevice *device)
+ask_for_pin (NMModemGsm *self, gboolean always_ask)
 {
-	NMActRequest *req;
-	NMConnection *connection;
-	NMSettingGsm *setting;
+	NMModemGsmPrivate *priv;
+	guint32 tries = 0;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-	setting = NM_SETTING_GSM (nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM));
-	g_assert (setting);
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM_GSM (self));
+
+	priv = NM_MODEM_GSM_GET_PRIVATE (self);
 
-	g_object_set (G_OBJECT (setting), NM_SETTING_GSM_PIN, NULL, NULL);
+	if (!always_ask)
+		tries = priv->pin_tries++;
+
+	g_signal_emit_by_name (self, NM_MODEM_NEED_AUTH,
+	                       NM_SETTING_GSM_SETTING_NAME,
+	                       (tries || always_ask) ? TRUE : FALSE,
+	                       SECRETS_CALLER_MOBILE_BROADBAND,
+	                       NM_SETTING_GSM_PIN,
+	                       NULL);
 }
 
 static void
-request_secrets (NMDevice *device,
-                 const char *setting_name,
-                 const char *hint1,
-                 const char *hint2,
-                 const char *tries_tag,
-                 gboolean always_ask)
+stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 {
-	NMActRequest *req;
-	NMConnection *connection;
-	guint32 tries = 0;
+	NMModemGsm *self = NM_MODEM_GSM (user_data);
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+	GError *error = NULL;
 
-	g_return_if_fail (device != NULL);
-	g_return_if_fail (hint1 || hint2);
+	priv->call = NULL;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
+	if (priv->connect_properties) {
+		g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = NULL;
+	}
 
-	nm_device_state_changed (device, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
+	if (dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID))
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, TRUE, NM_DEVICE_STATE_REASON_NONE);
+	else {
+		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN))
+			ask_for_pin (self, FALSE);
+		else if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_WRONG))
+			ask_for_pin (self, TRUE);
+		else {
+			nm_log_warn (LOGD_MB, "GSM connection failed: (%d) %s",
+			             error ? error->code : -1,
+			             error && error->message ? error->message : "(unknown)");
 
-	if (!always_ask)
-		tries = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (connection), tries_tag));
+			g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, translate_mm_error (error));
+		}
 
-	nm_act_request_get_secrets (req,
-	                            setting_name ? setting_name : NM_SETTING_GSM_SETTING_NAME,
-	                            (tries || always_ask) ? TRUE : FALSE,
-	                            SECRETS_CALLER_GSM,
-	                            hint1,
-	                            hint2);
+		g_error_free (error);
+	}
+}
 
-	if (!always_ask)
-		g_object_set_data (G_OBJECT (connection), tries_tag, GUINT_TO_POINTER (++tries));
+static void
+do_connect (NMModemGsm *self)
+{
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+	DBusGProxy *proxy;
+
+	proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM_SIMPLE);
+	dbus_g_proxy_begin_call_with_timeout (proxy,
+	                                      "Connect", stage1_prepare_done,
+	                                      self, NULL, 120000,
+	                                      DBUS_TYPE_G_MAP_OF_VARIANT, priv->connect_properties,
+	                                      G_TYPE_INVALID);
+}
+
+static void stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data);
+
+static void
+do_enable (NMModemGsm *self)
+{
+	DBusGProxy *proxy;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM_GSM (self));
+
+	proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM);
+	dbus_g_proxy_begin_call_with_timeout (proxy,
+	                                      "Enable", stage1_enable_done,
+	                                      self, NULL, 20000,
+	                                      G_TYPE_BOOLEAN, TRUE,
+	                                      G_TYPE_INVALID);
 }
 
 static void
-stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+stage1_pin_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModemGsm *self = NM_MODEM_GSM (user_data);
 	GError *error = NULL;
 
-	dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID);
-	if (!error)
-		nm_device_activate_schedule_stage2_device_config (device);
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
+		/* Success; go back and try the enable again */
+		do_enable (self);
+	} else {
+		nm_log_warn (LOGD_MB, "GSM PIN unlock failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		g_error_free (error);
+
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
+	}
+}
+
+static void
+handle_enable_pin_required (NMModemGsm *self)
+{
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+	const char *pin = NULL;
+	GValue *value;
+	DBusGProxy *proxy;
+
+	/* See if we have a PIN already */
+	value = g_hash_table_lookup (priv->connect_properties, "pin");
+	if (value && G_VALUE_HOLDS_STRING (value))
+		pin = g_value_get_string (value);
+
+	/* If we do, send it */
+	if (pin) {
+		proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM_GSM_CARD);
+		dbus_g_proxy_begin_call_with_timeout (proxy,
+		                                      "SendPin", stage1_pin_done,
+		                                      self, NULL, 10000,
+		                                      G_TYPE_STRING, pin,
+		                                      G_TYPE_INVALID);
+	} else
+		ask_for_pin (self, FALSE);
+}
+
+static void
+stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModemGsm *self = NM_MODEM_GSM (user_data);
+	GError *error = NULL;
+
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
+		do_connect (self);
 	else {
-		const char *required_secret = NULL;
-		gboolean retry_secret = FALSE;
-
-		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN)) {
-			clear_pin (device);
-			required_secret = NM_SETTING_GSM_PIN;
-		} else if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_WRONG)) {
-			clear_pin (device);
-			required_secret = NM_SETTING_GSM_PIN;
-			retry_secret = TRUE;
-		} else {
-			nm_warning ("GSM modem connection failed: (%d) %s",
-			            error ? error->code : -1,
-			            error && error->message ? error->message : "(unknown)");
-		}
+		nm_log_warn (LOGD_MB, "GSM modem enable failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 
-		if (required_secret)
-			request_secrets (device, NULL, required_secret, NULL, PIN_TRIES, retry_secret);
+		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN))
+			handle_enable_pin_required (self);
 		else
-			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, translate_mm_error (error));
+			g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
 
 		g_error_free (error);
 	}
 }
 
+
 static GHashTable *
 create_connect_properties (NMConnection *connection)
 {
@@ -279,171 +351,72 @@ create_connect_properties (NMConnection *connection)
 	if (str)
 		value_hash_add_str (properties, "password", str);
 
+	/* Add both old and new preferred modes */
 	switch (nm_setting_gsm_get_network_type (setting)) {
 	case NM_SETTING_GSM_NETWORK_TYPE_UMTS_HSPA:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_3G_ONLY);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_ONLY);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_3G_ONLY);
 		break;
 	case NM_SETTING_GSM_NETWORK_TYPE_GPRS_EDGE:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_2G_ONLY);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_ONLY);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_2G_ONLY);
 		break;
 	case NM_SETTING_GSM_NETWORK_TYPE_PREFER_UMTS_HSPA:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_3G_PREFERRED);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_PREFERRED);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_3G_PREFERRED);
 		break;
 	case NM_SETTING_GSM_NETWORK_TYPE_PREFER_GPRS_EDGE:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_2G_PREFERRED);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_PREFERRED);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_2G_PREFERRED);
 		break;
 	default:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_ANY);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_ANY);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_ANY);
 		break;
 	}
 
-	/* FIXME: band */
-	return properties;
-}
-
-static void
-do_connect (NMModem *modem)
-{
-	NMConnection *connection;
-	GHashTable *properties;
-
-	connection = nm_act_request_get_connection (nm_device_get_act_request (NM_DEVICE (modem)));
-	g_assert (connection);
-
-	properties = create_connect_properties (connection);
-	dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE),
-	                                      "Connect", stage1_prepare_done,
-	                                      modem, NULL, 120000,
-	                                      DBUS_TYPE_G_MAP_OF_VARIANT, properties,
-	                                      G_TYPE_INVALID);
-	g_hash_table_destroy (properties);
-}
-
-static void
-stage1_pin_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	GError *error = NULL;
-
-	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
-		/* Success; go back and try the enable again */
-		nm_device_activate_schedule_stage1_device_prepare (device);
-	} else {
-		nm_warning ("GSM PIN unlock failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
-		g_error_free (error);
-
-		clear_pin (device);
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED);
-	}
-}
-
-static void
-handle_enable_pin_required (NMDevice *device)
-{
-	NMActRequest *req;
-	NMConnection *connection;
-	NMSettingGsm *s_gsm;
-	const char *pin = NULL;
-
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-
-	/* See if we have a PIN already */
-	s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-	if (s_gsm)
-		pin = nm_setting_gsm_get_pin (s_gsm);
-
-	/* If we do, send it */
-	if (pin) {
-		NMModem *modem = NM_MODEM (device);
-
-		dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_GSM_CARD),
-		                                      "SendPin", stage1_pin_done,
-		                                      modem, NULL, 10000,
-		                                      G_TYPE_STRING, pin,
-		                                      G_TYPE_INVALID);
-	} else {
-		/* Otherwise try to get the PIN */
-		request_secrets (device, NULL, NM_SETTING_GSM_PIN, NULL, PIN_TRIES, FALSE);
-	}
-}
-
-static void
-stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	GError *error = NULL;
-
-	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
-		do_connect (NM_MODEM (device));
-	else {
-		nm_warning ("GSM modem enable failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
+	/* Roaming */
+	if (nm_setting_gsm_get_home_only (setting))
+		value_hash_add_bool (properties, "home_only", TRUE);
 
-		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN))
-			handle_enable_pin_required (device);
-		else
-			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, translate_mm_error (error));
-
-		g_error_free (error);
-	}
+	return properties;
 }
 
 static NMActStageReturn
-real_act_stage1_prepare (NMDevice *device, NMDeviceStateReason *reason)
+real_act_stage1_prepare (NMModem *modem,
+                         NMActRequest *req,
+                         GPtrArray **out_hints,
+                         const char **out_setting_name,
+                         NMDeviceStateReason *reason)
 {
-	NMActRequest *req;
+	NMModemGsm *self = NM_MODEM_GSM (modem);
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
 	NMConnection *connection;
-	const char *setting_name;
-	GPtrArray *hints = NULL;
-	const char *hint1 = NULL, *hint2 = NULL;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
 	connection = nm_act_request_get_connection (req);
 	g_assert (connection);
 
-	setting_name = nm_connection_need_secrets (connection, &hints);
-	if (!setting_name) {
-		NMModem *modem = NM_MODEM (device);
+	*out_setting_name = nm_connection_need_secrets (connection, out_hints);
+	if (!*out_setting_name) {
 		gboolean enabled = nm_modem_get_mm_enabled (modem);
 
-		if (enabled)
-			do_connect (modem);
-		else {
-			dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM),
-			                                      "Enable", stage1_enable_done,
-			                                      modem, NULL, 20000,
-			                                      G_TYPE_BOOLEAN, TRUE,
-			                                      G_TYPE_INVALID);
-		}
+		if (priv->connect_properties)
+			g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = create_connect_properties (connection);
 
-		return NM_ACT_STAGE_RETURN_POSTPONE;
-	}
-
-	/* Get the required secrets */
-	if (hints) {
-		if (hints->len > 0)
-			hint1 = g_ptr_array_index (hints, 0);
-		if (hints->len > 1)
-			hint2 = g_ptr_array_index (hints, 1);
+		if (enabled)
+			do_connect (self);
+		else
+			do_enable (self);
+	} else {
+		/* NMModem will handle requesting secrets... */
 	}
 
-	request_secrets (device, setting_name, hint1, hint2, GSM_SECRETS_TRIES, FALSE);
-
-	if (hints)
-		g_ptr_array_free (hints, TRUE);
-
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
 static NMConnection *
-real_get_best_auto_connection (NMDevice *dev,
+real_get_best_auto_connection (NMModem *modem,
 							   GSList *connections,
 							   char **specific_object)
 {
@@ -467,112 +440,8 @@ real_get_best_auto_connection (NMDevice *dev,
 	return NULL;
 }
 
-static void
-real_connection_secrets_updated (NMDevice *dev,
-								 NMConnection *connection,
-								 GSList *updated_settings,
-								 RequestSecretsCaller caller)
-{
-	NMActRequest *req;
-	gboolean found = FALSE;
-	GSList *iter;
-
-	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (dev)));
-
-	if (caller == SECRETS_CALLER_PPP) {
-		NMPPPManager *ppp_manager;
-		NMSettingGsm *s_gsm = NULL;
-
-		ppp_manager = nm_modem_get_ppp_manager (NM_MODEM (dev));
-		g_return_if_fail (ppp_manager != NULL);
-
-		s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-		if (!s_gsm) {
-			/* Shouldn't ever happen */
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   NULL,
-										   NULL,
-										   "missing GSM setting; no secrets could be found.");
-		} else {
-			const char *username = nm_setting_gsm_get_username (s_gsm);
-			const char *password = nm_setting_gsm_get_password (s_gsm);
-
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   username ? username : "",
-										   password ? password : "",
-										   NULL);
-		}
-		return;
-	}
-
-	g_return_if_fail (caller == SECRETS_CALLER_GSM);
-	g_return_if_fail (nm_device_get_state (dev) == NM_DEVICE_STATE_NEED_AUTH);
-
-	for (iter = updated_settings; iter; iter = g_slist_next (iter)) {
-		const char *setting_name = (const char *) iter->data;
-
-		if (!strcmp (setting_name, NM_SETTING_GSM_SETTING_NAME))
-			found = TRUE;
-		else
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
-	}
-
-	if (!found)
-		return;
-
-	req = nm_device_get_act_request (dev);
-	g_assert (req);
-
-	g_return_if_fail (nm_act_request_get_connection (req) == connection);
-
-	nm_device_activate_schedule_stage1_device_prepare (dev);
-}
-
-static NMActStageReturn
-real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
-{
-	NMActRequest *req;
-	NMConnection *connection;
-
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-
-	/* Clear secrets tries counter since secrets were successfully used
-	 * already if we get here.
-	 */
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-	g_object_set_data (G_OBJECT (connection), GSM_SECRETS_TRIES, NULL);
-
-	if (NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->act_stage2_config)
-		return NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->act_stage2_config (device, reason);
-
-	return NM_ACT_STAGE_RETURN_SUCCESS;
-}
-
-static void
-real_deactivate_quickly (NMDevice *device)
-{
-	NMActRequest *req;
-	NMConnection *connection;
-
-	req = nm_device_get_act_request (device);
-	if (req) {
-		/* Clear the secrets attempts counter */
-		connection = nm_act_request_get_connection (req);
-		g_assert (connection);
-		g_object_set_data (G_OBJECT (connection), GSM_SECRETS_TRIES, NULL);
-		g_object_set_data (G_OBJECT (connection), PIN_TRIES, NULL);
-	}
-
-	if (NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->deactivate_quickly)
-		NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->deactivate_quickly (device);
-}
-
 static gboolean
-real_check_connection_compatible (NMDevice *device,
+real_check_connection_compatible (NMModem *modem,
                                   NMConnection *connection,
                                   GError **error)
 {
@@ -600,17 +469,51 @@ real_check_connection_compatible (NMDevice *device,
 	return TRUE;
 }
 
-static const char *
-real_get_ppp_name (NMModem *device, NMConnection *connection)
+static gboolean
+real_get_user_pass (NMModem *modem,
+                    NMConnection *connection,
+                    const char **user,
+                    const char **pass)
 {
 	NMSettingGsm *s_gsm;
 
 	s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-	g_assert (s_gsm);
+	if (!s_gsm)
+		return FALSE;
+
+	if (user)
+		*user = nm_setting_gsm_get_username (s_gsm);
+	if (pass)
+		*pass = nm_setting_gsm_get_password (s_gsm);
+
+	return TRUE;
+}
+
+static const char *
+real_get_setting_name (NMModem *modem)
+{
+	return NM_SETTING_GSM_SETTING_NAME;
+}
+
+static void
+real_deactivate_quickly (NMModem *modem, NMDevice *device)
+{
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (modem);
+
+	if (priv->call) {
+		DBusGProxy *proxy;
 
-	return nm_setting_gsm_get_username (s_gsm);
+		proxy = nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE);
+		dbus_g_proxy_cancel_call (proxy, priv->call);
+		priv->call = NULL;
+	}
+
+	priv->pin_tries = 0;
+
+	NM_MODEM_CLASS (nm_modem_gsm_parent_class)->deactivate_quickly (modem, device);	
 }
 
+
 /*****************************************************************************/
 
 static void
@@ -619,23 +522,33 @@ nm_modem_gsm_init (NMModemGsm *self)
 }
 
 static void
+dispose (GObject *object)
+{
+	NMModemGsm *self = NM_MODEM_GSM (object);
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+
+	if (priv->connect_properties)
+		g_hash_table_destroy (priv->connect_properties);
+
+	G_OBJECT_CLASS (nm_modem_gsm_parent_class)->dispose (object);
+}
+
+static void
 nm_modem_gsm_class_init (NMModemGsmClass *klass)
 {
-	NMDeviceClass *device_class = NM_DEVICE_CLASS (klass);
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMModemClass *modem_class = NM_MODEM_CLASS (klass);
 
-	/* Virtual methods */
-	device_class->get_best_auto_connection = real_get_best_auto_connection;
-	device_class->connection_secrets_updated = real_connection_secrets_updated;
-	device_class->act_stage1_prepare = real_act_stage1_prepare;
-	device_class->act_stage2_config = real_act_stage2_config;
-	device_class->deactivate_quickly = real_deactivate_quickly;
-	device_class->check_connection_compatible = real_check_connection_compatible;
-
-	modem_class->get_ppp_name = real_get_ppp_name;
+	g_type_class_add_private (object_class, sizeof (NMModemGsmPrivate));
 
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
-									 &dbus_glib_nm_device_gsm_object_info);
+	/* Virtual methods */
+	object_class->dispose = dispose;
+	modem_class->get_user_pass = real_get_user_pass;
+	modem_class->get_setting_name = real_get_setting_name;
+	modem_class->get_best_auto_connection = real_get_best_auto_connection;
+	modem_class->check_connection_compatible = real_check_connection_compatible;
+	modem_class->act_stage1_prepare = real_act_stage1_prepare;
+	modem_class->deactivate_quickly = real_deactivate_quickly;
 
 	dbus_g_error_domain_register (NM_GSM_ERROR, NULL, NM_TYPE_GSM_ERROR);
 }
diff --git a/src/modem-manager/nm-modem-gsm.h b/src/modem-manager/nm-modem-gsm.h
index 8479473..f481bdb 100644
--- a/src/modem-manager/nm-modem-gsm.h
+++ b/src/modem-manager/nm-modem-gsm.h
@@ -46,11 +46,10 @@ typedef struct {
 
 GType nm_modem_gsm_get_type (void);
 
-NMDevice *nm_modem_gsm_new (const char *path,
-                            const char *device,
-                            const char *data_device,
-                            const char *driver,
-                            guint32 ip_method);
+NMModem *nm_modem_gsm_new (const char *path,
+                           const char *device,
+                           const char *data_device,
+                           guint32 ip_method);
 
 G_END_DECLS
 
diff --git a/src/modem-manager/nm-modem-manager.c b/src/modem-manager/nm-modem-manager.c
index 94e1a11..28f7b94 100644
--- a/src/modem-manager/nm-modem-manager.c
+++ b/src/modem-manager/nm-modem-manager.c
@@ -15,19 +15,20 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  * Copyright (C) 2009 Canonical Ltd.
  */
 
 #include <string.h>
 #include "nm-modem-manager.h"
+#include "nm-logging.h"
 #include "nm-modem.h"
 #include "nm-modem-gsm.h"
 #include "nm-modem-cdma.h"
 #include "nm-dbus-manager.h"
-#include "nm-utils.h"
 #include "nm-modem-types.h"
+#include "nm-marshal.h"
 
 #define MODEM_POKE_INTERVAL 120
 
@@ -44,8 +45,8 @@ typedef struct {
 } NMModemManagerPrivate;
 
 enum {
-	DEVICE_ADDED,
-	DEVICE_REMOVED,
+	MODEM_ADDED,
+	MODEM_REMOVED,
 
 	LAST_SIGNAL
 };
@@ -67,25 +68,6 @@ nm_modem_manager_get (void)
 	return singleton;
 }
 
-gboolean
-nm_modem_manager_has_modem_for_iface (NMModemManager *manager,
-                                      const gchar *iface)
-{
-	NMModemManagerPrivate *priv = NM_MODEM_MANAGER_GET_PRIVATE (manager);
-	GList *iter;
-	g_assert (manager);
-	g_assert (NM_IS_MODEM_MANAGER(manager));
-	g_assert (iface);
-
-	for (iter = g_hash_table_get_values(priv->modems); iter != NULL; iter = iter->next) {
-		NMDevice *device = NM_DEVICE(iter->data);
-		const gchar *device_iface = nm_device_get_iface (device);
-		if (!g_strcmp0 (iface, device_iface))
-			return TRUE;
-	}
-	return FALSE;
-}
-
 static gboolean
 get_modem_properties (DBusGConnection *connection,
 					  const char *path,
@@ -113,7 +95,7 @@ get_modem_properties (DBusGConnection *connection,
 		*type = g_value_get_uint (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get device type: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get device type: %s", err->message);
 		goto out;
 	}
 
@@ -126,7 +108,7 @@ get_modem_properties (DBusGConnection *connection,
 		*device = g_value_dup_string (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get device: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get device: %s", err->message);
 		goto out;
 	}
 
@@ -139,7 +121,7 @@ get_modem_properties (DBusGConnection *connection,
 		*ip_method = g_value_get_uint (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get IP method: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get IP method: %s", err->message);
 		goto out;
 	}
 
@@ -152,7 +134,7 @@ get_modem_properties (DBusGConnection *connection,
 		*data_device = g_value_dup_string (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get modem data device: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get modem data device: %s", err->message);
 		goto out;
 	}
 
@@ -165,7 +147,7 @@ get_modem_properties (DBusGConnection *connection,
 		*driver = g_value_dup_string (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get modem driver: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get modem driver: %s", err->message);
 		goto out;
 	}
 
@@ -182,13 +164,13 @@ static void
 create_modem (NMModemManager *manager, const char *path)
 {
 	NMModemManagerPrivate *priv = NM_MODEM_MANAGER_GET_PRIVATE (manager);
-	NMDevice *device;
+	NMModem *modem = NULL;
 	char *data_device = NULL, *driver = NULL, *master_device = NULL;
 	uint modem_type = MM_MODEM_TYPE_UNKNOWN;
 	uint ip_method = MM_MODEM_IP_METHOD_PPP;
 
 	if (g_hash_table_lookup (priv->modems, path)) {
-		nm_warning ("Modem with path %s already exists, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s already exists, ignoring", path);
 		return;
 	}
 
@@ -198,39 +180,40 @@ create_modem (NMModemManager *manager, const char *path)
 		return;
 
 	if (modem_type == MM_MODEM_TYPE_UNKNOWN) {
-		nm_warning ("Modem with path %s has unknown type, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown type, ignoring", path);
 		return;
 	}
 
 	if (!master_device || !strlen (master_device)) {
-		nm_warning ("Modem with path %s has unknown device, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown device, ignoring", path);
 		return;
 	}
 
 	if (!driver || !strlen (driver)) {
-		nm_warning ("Modem with path %s has unknown driver, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown driver, ignoring", path);
 		return;
 	}
 
 	if (!data_device || !strlen (data_device)) {
-		nm_warning ("Modem with path %s has unknown data device, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown data device, ignoring", path);
 		return;
 	}
 
 	if (modem_type == MM_MODEM_TYPE_GSM)
-		device = nm_modem_gsm_new (path, master_device, data_device, driver, ip_method);
+		modem = nm_modem_gsm_new (path, master_device, data_device, ip_method);
 	else if (modem_type == MM_MODEM_TYPE_CDMA)
-		device = nm_modem_cdma_new (path, master_device, data_device, driver);
+		modem = nm_modem_cdma_new (path, master_device, data_device, ip_method);
 	else
-		g_error ("Invalid modem type");
+		nm_log_warn (LOGD_MB, "unknown modem type '%d'", modem_type);
 
 	g_free (data_device);
-	g_free (driver);
 
-	if (device) {
-		g_hash_table_insert (priv->modems, g_strdup (path), device);
-		g_signal_emit (manager, signals[DEVICE_ADDED], 0, device);
+	if (modem) {
+		g_hash_table_insert (priv->modems, g_strdup (path), modem);
+		g_signal_emit (manager, signals[MODEM_ADDED], 0, modem, driver);
 	}
+
+	g_free (driver);
 }
 
 static void
@@ -247,7 +230,7 @@ modem_removed (DBusGProxy *proxy, const char *path, gpointer user_data)
 
 	modem = (NMModem *) g_hash_table_lookup (priv->modems, path);
 	if (modem) {
-		g_signal_emit (user_data, signals[DEVICE_REMOVED], 0, modem);
+		g_signal_emit (user_data, signals[MODEM_REMOVED], 0, modem);
 		g_hash_table_remove (priv->modems, path);
 	}
 }
@@ -282,7 +265,7 @@ enumerate_devices_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer dat
 	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
 								dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &modems,
 								G_TYPE_INVALID)) {
-		nm_warning ("Could not get modem list: %s", error->message);
+		nm_log_warn (LOGD_MB, "could not get modem list: %s", error->message);
 		g_error_free (error);
 	} else {
 		int i;
@@ -308,7 +291,7 @@ modem_manager_appeared (NMModemManager *self, gboolean enumerate_devices)
 		priv->poke_id = 0;
 	}
 
-	nm_info ("modem-manager is now available");
+	nm_log_info (LOGD_MB, "modem-manager is now available");
 
 	priv->proxy = dbus_g_proxy_new_for_name (nm_dbus_manager_get_connection (priv->dbus_mgr),
 											 MM_DBUS_SERVICE, MM_DBUS_PATH, MM_DBUS_INTERFACE);
@@ -330,7 +313,7 @@ modem_manager_appeared (NMModemManager *self, gboolean enumerate_devices)
 static gboolean
 remove_one_modem (gpointer key, gpointer value, gpointer user_data)
 {
-	g_signal_emit (user_data, signals[DEVICE_REMOVED], 0, value);
+	g_signal_emit (user_data, signals[MODEM_REMOVED], 0, value);
 
 	return TRUE;
 }
@@ -348,7 +331,7 @@ modem_manager_disappeared (NMModemManager *self)
 	}
 
 	/* Try to activate the modem-manager */
-	nm_info ("Trying to start the modem-manager...");
+	nm_log_info (LOGD_MB, "trying to start the modem manager...");
 	poke_modem_cb (self);
 	priv->poke_id = g_timeout_add_seconds (MODEM_POKE_INTERVAL, poke_modem_cb, self);
 }
@@ -373,7 +356,7 @@ nm_modem_manager_name_owner_changed (NMDBusManager *dbus_mgr,
 	if (!old_owner_good && new_owner_good) {
 		modem_manager_appeared (NM_MODEM_MANAGER (user_data), FALSE);
 	} else if (old_owner_good && !new_owner_good) {
-		nm_info ("modem manager disappeared");
+		nm_log_info (LOGD_MB, "the modem manager disappeared");
 		modem_manager_disappeared (NM_MODEM_MANAGER (user_data));
 	}
 }
@@ -440,23 +423,21 @@ nm_modem_manager_class_init (NMModemManagerClass *klass)
 	object_class->dispose = dispose;
 
 	/* signals */
-	signals[DEVICE_ADDED] =
-		g_signal_new ("device-added",
+	signals[MODEM_ADDED] =
+		g_signal_new ("modem-added",
 					  G_OBJECT_CLASS_TYPE (object_class),
 					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMModemManagerClass, device_added),
+					  G_STRUCT_OFFSET (NMModemManagerClass, modem_added),
 					  NULL, NULL,
-					  g_cclosure_marshal_VOID__OBJECT,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_OBJECT);
+					  _nm_marshal_VOID__OBJECT_STRING,
+					  G_TYPE_NONE, 2, G_TYPE_OBJECT, G_TYPE_STRING);
 
-	signals[DEVICE_REMOVED] =
-		g_signal_new ("device-removed",
+	signals[MODEM_REMOVED] =
+		g_signal_new ("modem-removed",
 					  G_OBJECT_CLASS_TYPE (object_class),
 					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMModemManagerClass, device_removed),
+					  G_STRUCT_OFFSET (NMModemManagerClass, modem_removed),
 					  NULL, NULL,
 					  g_cclosure_marshal_VOID__OBJECT,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_OBJECT);
+					  G_TYPE_NONE, 1, G_TYPE_OBJECT);
 }
diff --git a/src/modem-manager/nm-modem-manager.h b/src/modem-manager/nm-modem-manager.h
index f9d8ded..56427ba 100644
--- a/src/modem-manager/nm-modem-manager.h
+++ b/src/modem-manager/nm-modem-manager.h
@@ -24,7 +24,7 @@
 #define NM_MODEM_MANAGER_H
 
 #include <glib-object.h>
-#include "nm-device.h"
+#include "nm-modem.h"
 
 #define NM_TYPE_MODEM_MANAGER				(nm_modem_manager_get_type ())
 #define NM_MODEM_MANAGER(obj)				(G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_MODEM_MANAGER, NMModemManager))
@@ -41,18 +41,13 @@ typedef struct {
 	GObjectClass parent;
 
 	/* Signals */
-	void (*device_added) (NMModemManager *manager,
-						  NMDevice *device);
+	void (*modem_added) (NMModemManager *manager, NMModem *modem, const char *driver);
 
-	void (*device_removed) (NMModemManager *manager,
-							NMDevice *device);
+	void (*modem_removed) (NMModemManager *manager, NMModem *modem);
 } NMModemManagerClass;
 
 GType nm_modem_manager_get_type (void);
 
 NMModemManager *nm_modem_manager_get (void);
 
-gboolean nm_modem_manager_has_modem_for_iface (NMModemManager *manager,
-                                               const gchar *iface);
-
 #endif /* NM_MODEM_MANAGER_H */
diff --git a/src/modem-manager/nm-modem.c b/src/modem-manager/nm-modem.c
index 5b001ee..d9413ed 100644
--- a/src/modem-manager/nm-modem.c
+++ b/src/modem-manager/nm-modem.c
@@ -15,37 +15,34 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  */
 
 #include <string.h>
 #include "nm-modem.h"
-#include "nm-device-private.h"
-#include "NetworkManagerSystem.h"
-#include "nm-device-interface.h"
+#include "nm-system.h"
 #include "nm-dbus-manager.h"
 #include "nm-setting-connection.h"
-#include "nm-setting-gsm.h"
-#include "nm-setting-cdma.h"
 #include "nm-marshal.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-modem-types.h"
-#include "nm-utils.h"
-#include "nm-serial-device-glue.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
+#include "nm-device-private.h"
+#include "nm-device-interface.h"
 #include "nm-dbus-glib-types.h"
 
-static void device_interface_init (NMDeviceInterface *iface_class);
+#include "nm-serial-device-glue.h"
 
-G_DEFINE_TYPE_EXTENDED (NMModem, nm_modem, NM_TYPE_DEVICE, 0,
-                        G_IMPLEMENT_INTERFACE (NM_TYPE_DEVICE_INTERFACE, device_interface_init))
+G_DEFINE_TYPE (NMModem, nm_modem, G_TYPE_OBJECT)
 
 #define NM_MODEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM, NMModemPrivate))
 
 enum {
 	PROP_0,
 	PROP_DEVICE,
+	PROP_IFACE,
 	PROP_PATH,
 	PROP_IP_METHOD,
 	PROP_ENABLED,
@@ -63,6 +60,11 @@ typedef struct {
 	NMIP4Config	 *pending_ip4_config;
 	guint32 ip_method;
 	char *device;
+	char *iface;
+
+	guint32 secrets_tries;
+
+	DBusGProxyCall *call;
 
 	gboolean mm_enabled;
 
@@ -73,7 +75,10 @@ typedef struct {
 
 enum {
 	PPP_STATS,
-	PROPERTIES_CHANGED,
+	PPP_FAILED,
+	PREPARE_RESULT,
+	IP4_CONFIG_RESULT,
+	NEED_AUTH,
 
 	LAST_SIGNAL
 };
@@ -120,17 +125,19 @@ nm_modem_get_proxy (NMModem *self,
 	return priv->proxy;
 }
 
-const char *
-nm_modem_get_ppp_name (NMModem *self,
-					   NMConnection *connection)
+static void
+merge_ip4_config (NMActRequest *req, NMIP4Config *config)
 {
-	g_return_val_if_fail (NM_IS_MODEM (self), NULL);
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+	NMConnection *connection;
+	NMSettingIP4Config *s_ip4;
 
-	if (NM_MODEM_GET_CLASS (self)->get_ppp_name)
-		return NM_MODEM_GET_CLASS (self)->get_ppp_name (self, connection);
+	/* Merge user-defined overrides into the IP4Config to be applied */
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
 
-	return NULL;
+	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
+	if (s_ip4)
+		nm_utils_merge_ip4_config (config, s_ip4);
 }
 
 /*****************************************************************************/
@@ -139,14 +146,12 @@ nm_modem_get_ppp_name (NMModem *self,
 static void
 ppp_state_changed (NMPPPManager *ppp_manager, NMPPPStatus status, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
-
 	switch (status) {
 	case NM_PPP_STATUS_DISCONNECT:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_DISCONNECT);
+		g_signal_emit (NM_MODEM (user_data), signals[PPP_FAILED], 0, NM_DEVICE_STATE_REASON_PPP_DISCONNECT);
 		break;
 	case NM_PPP_STATUS_DEAD:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_FAILED);
+		g_signal_emit (NM_MODEM (user_data), signals[PPP_FAILED], 0, NM_DEVICE_STATE_REASON_PPP_FAILED);
 		break;
 	default:
 		break;
@@ -159,7 +164,8 @@ ppp_ip4_config (NMPPPManager *ppp_manager,
 				NMIP4Config *config,
 				gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModem *self = NM_MODEM (user_data);
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	guint32 i, num;
 	guint32 bad_dns1 = htonl (0x0A0B0C0D);
 	guint32 good_dns1 = htonl (0x04020201);  /* GTE nameserver */
@@ -167,10 +173,6 @@ ppp_ip4_config (NMPPPManager *ppp_manager,
 	guint32 good_dns2 = htonl (0x04020202);  /* GTE nameserver */
 	gboolean dns_workaround = FALSE;
 
-	/* Ignore PPP IP4 events that come in after initial configuration */
-	if (nm_device_get_state (device) != NM_DEVICE_STATE_IP_CONFIG)
-		return;
-
 	/* Work around a PPP bug (#1732) which causes many mobile broadband
 	 * providers to return 10.11.12.13 and 10.11.12.14 for the DNS servers.
 	 * Apparently fixed in ppp-2.4.5 but we've had some reports that this is
@@ -201,14 +203,14 @@ ppp_ip4_config (NMPPPManager *ppp_manager,
 	}
 
 	if (!num || dns_workaround) {
+		nm_log_warn (LOGD_PPP, "compensating for invalid PPP-provided nameservers");
 		nm_ip4_config_reset_nameservers (config);
 		nm_ip4_config_add_nameserver (config, good_dns1);
 		nm_ip4_config_add_nameserver (config, good_dns2);
 	}
 
-	nm_device_set_ip_iface (device, iface);
-	NM_MODEM_GET_PRIVATE (device)->pending_ip4_config = g_object_ref (config);
-	nm_device_activate_schedule_stage4_ip4_config_get (device);
+	priv->pending_ip4_config = g_object_ref (config);
+	g_signal_emit (self, signals[IP4_CONFIG_RESULT], 0, iface, config, NULL);
 }
 
 static void
@@ -229,36 +231,47 @@ ppp_stats (NMPPPManager *ppp_manager,
 }
 
 static NMActStageReturn
-ppp_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+ppp_stage3_ip4_config_start (NMModem *self,
+                             NMActRequest *req,
+                             NMDeviceStateReason *reason)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
-	NMActRequest *req;
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	const char *ppp_name = NULL;
-	GError *err = NULL;
+	GError *error = NULL;
 	NMActStageReturn ret;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (req != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason !=	NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
-	ppp_name = nm_modem_get_ppp_name (NM_MODEM (device),
-									  nm_act_request_get_connection (req));
+	if (NM_MODEM_GET_CLASS (self)->get_user_pass) {
+		NMConnection *connection = nm_act_request_get_connection (req);
 
-	priv->ppp_manager = nm_ppp_manager_new (nm_device_get_iface (device));
-	if (nm_ppp_manager_start (priv->ppp_manager, req, ppp_name, 20, &err)) {
+		g_assert (connection);
+		if (!NM_MODEM_GET_CLASS (self)->get_user_pass (self, connection, &ppp_name, NULL))
+			return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	priv->ppp_manager = nm_ppp_manager_new (priv->iface);
+	if (nm_ppp_manager_start (priv->ppp_manager, req, ppp_name, 20, &error)) {
 		g_signal_connect (priv->ppp_manager, "state-changed",
 						  G_CALLBACK (ppp_state_changed),
-						  device);
+						  self);
 		g_signal_connect (priv->ppp_manager, "ip4-config",
 						  G_CALLBACK (ppp_ip4_config),
-						  device);
+						  self);
 		g_signal_connect (priv->ppp_manager, "stats",
 						  G_CALLBACK (ppp_stats),
-						  device);
+						  self);
 
 		ret = NM_ACT_STAGE_RETURN_POSTPONE;
 	} else {
-		nm_warning ("%s", err->message);
-		g_error_free (err);
+		nm_log_err (LOGD_PPP, "error starting PPP: (%d) %s",
+		            error ? error->code : -1,
+		            error && error->message ? error->message : "(unknown)");
+		g_error_free (error);
 
 		g_object_unref (priv->ppp_manager);
 		priv->ppp_manager = NULL;
@@ -271,20 +284,17 @@ ppp_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
 }
 
 static NMActStageReturn
-ppp_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
+ppp_stage4 (NMModem *self,
+            NMActRequest *req,
+            NMIP4Config **config,
+            NMDeviceStateReason *reason)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
-	NMConnection *connection;
-	NMSettingIP4Config *s_ip4;
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 
 	*config = priv->pending_ip4_config;
 	priv->pending_ip4_config = NULL;
 
-	/* Merge user-defined overrides into the IP4Config to be applied */
-	connection = nm_act_request_get_connection (nm_device_get_act_request (device));
-	g_assert (connection);
-	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-	nm_utils_merge_ip4_config (*config, s_ip4);
+	merge_ip4_config (req, *config);
 
 	return NM_ACT_STAGE_RETURN_SUCCESS;
 }
@@ -293,57 +303,75 @@ ppp_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
 /* IP method static */
 
 static void
-static_stage3_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+static_stage3_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModem *self = NM_MODEM (user_data);
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	GValueArray *ret_array = NULL;
 	GError *error = NULL;
+	NMIP4Config *config = NULL;
+
+	priv->call = NULL;
 
-	if (dbus_g_proxy_end_call (proxy, call_id, &error,
+	if (dbus_g_proxy_end_call (proxy, call, &error,
 							   G_TYPE_VALUE_ARRAY, &ret_array,
 							   G_TYPE_INVALID)) {
-
-		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
 		NMIP4Address *addr;
 		int i;
 
+		config = nm_ip4_config_new ();
+
 		addr = nm_ip4_address_new ();
 		nm_ip4_address_set_address (addr, g_value_get_uint (g_value_array_get_nth (ret_array, 0)));
 		nm_ip4_address_set_prefix (addr, 32);
+		nm_ip4_config_take_address (config, addr);
 
-		priv->pending_ip4_config = nm_ip4_config_new ();
-		nm_ip4_config_take_address (priv->pending_ip4_config, addr);
-
-		for (i = 1; i < ret_array->n_values; i++)
-			nm_ip4_config_add_nameserver (priv->pending_ip4_config,
-										  g_value_get_uint (g_value_array_get_nth (ret_array, i)));
+		for (i = 0; i < ret_array->n_values; i++) {
+			GValue *value = g_value_array_get_nth (ret_array, i);
 
+			nm_ip4_config_add_nameserver (config, g_value_get_uint (value));
+		}
 		g_value_array_free (ret_array);
-		nm_device_activate_schedule_stage4_ip4_config_get (device);
-	} else {
-		nm_warning ("Retrieving IP4 configuration failed: %s", error->message);
-		g_error_free (error);
-		nm_device_state_changed (device,
-								 NM_DEVICE_STATE_FAILED,
-								 NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);
+
+		priv->pending_ip4_config = g_object_ref (config);
+		g_signal_emit (self, signals[IP4_CONFIG_RESULT], 0, NULL, config, NULL);
 	}
+
+	g_signal_emit (self, signals[IP4_CONFIG_RESULT], 0, NULL, config, error);
+	g_clear_error (&error);
 }
 
 static NMActStageReturn
-static_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+static_stage3_ip4_config_start (NMModem *self,
+                                NMActRequest *req,
+                                NMDeviceStateReason *reason)
 {
-	dbus_g_proxy_begin_call (nm_modem_get_proxy (NM_MODEM (device), MM_DBUS_INTERFACE_MODEM),
-							 "GetIP4Config", static_stage3_done,
-							 device, NULL,
-							 G_TYPE_INVALID);
+	NMModemPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (req != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason !=	NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+
+	priv->call = dbus_g_proxy_begin_call (nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM),
+	                                      "GetIP4Config", static_stage3_done,
+	                                      self, NULL,
+	                                      G_TYPE_INVALID);
 
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
 static NMActStageReturn
-static_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
+static_stage4 (NMModem *self,
+               NMActRequest *req,
+               NMDevice *device,
+               NMIP4Config **config,
+               NMDeviceStateReason *reason)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	gboolean no_firmware = FALSE;
 
 	if (!nm_device_hw_bring_up (device, TRUE, &no_firmware)) {
@@ -357,28 +385,47 @@ static_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reas
 	*config = priv->pending_ip4_config;
 	priv->pending_ip4_config = NULL;
 
+	merge_ip4_config (req, *config);
+
 	return NM_ACT_STAGE_RETURN_SUCCESS;
 }
 
 /*****************************************************************************/
 
-static NMActStageReturn
-real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+NMActStageReturn
+nm_modem_stage3_ip4_config_start (NMModem *self,
+                                  NMDevice *device,
+                                  NMDeviceClass *device_class,
+                                  NMDeviceStateReason *reason)
 {
+	NMModemPrivate *priv;
+	NMActRequest *req;
 	NMActStageReturn ret;
 
-	switch (NM_MODEM_GET_PRIVATE (device)->ip_method) {
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE (device), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device_class != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE_CLASS (device_class), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+	switch (priv->ip_method) {
 	case MM_MODEM_IP_METHOD_PPP:
-		ret = ppp_stage3_ip4_config_start (device, reason);
+		ret = ppp_stage3_ip4_config_start (self, req, reason);
 		break;
 	case MM_MODEM_IP_METHOD_STATIC:
-		ret = static_stage3_ip4_config_start (device, reason);
+		ret = static_stage3_ip4_config_start (self, req, reason);
 		break;
 	case MM_MODEM_IP_METHOD_DHCP:
-		ret = NM_DEVICE_CLASS (nm_modem_parent_class)->act_stage3_ip4_config_start (device, reason);
+		ret = device_class->act_stage3_ip4_config_start (device, reason);
 		break;
 	default:
-		g_warning ("Invalid IP method");
+		nm_log_err (LOGD_MB, "unknown IP method %d", priv->ip_method);
 		ret = NM_ACT_STAGE_RETURN_FAILURE;
 		break;
 	}
@@ -386,25 +433,41 @@ real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
 	return ret;
 }
 
-static NMActStageReturn
-real_act_stage4_get_ip4_config (NMDevice *device,
+NMActStageReturn
+nm_modem_stage4_get_ip4_config (NMModem *self,
+                                NMDevice *device,
+                                NMDeviceClass *device_class,
 								NMIP4Config **config,
 								NMDeviceStateReason *reason)
 {
+	NMModemPrivate *priv;
+	NMActRequest *req;
 	NMActStageReturn ret;
 
-	switch (NM_MODEM_GET_PRIVATE (device)->ip_method) {
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE (device), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device_class != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE_CLASS (device_class), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+	switch (priv->ip_method) {
 	case MM_MODEM_IP_METHOD_PPP:
-		ret = ppp_stage4 (device, config, reason);
+		ret = ppp_stage4 (self, req, config, reason);
 		break;
 	case MM_MODEM_IP_METHOD_STATIC:
-		ret = static_stage4 (device, config, reason);
+		ret = static_stage4 (self, req, device, config, reason);
 		break;
 	case MM_MODEM_IP_METHOD_DHCP:
-		ret = NM_DEVICE_CLASS (nm_modem_parent_class)->act_stage4_get_ip4_config (device, config, reason);
+		ret = device_class->act_stage4_get_ip4_config (device, config, reason);
 		break;
 	default:
-		g_warning ("Invalid IP method");
+		nm_log_err (LOGD_MB, "unknown IP method %d", priv->ip_method);
 		ret = NM_ACT_STAGE_RETURN_FAILURE;
 		break;
 	}
@@ -412,12 +475,175 @@ real_act_stage4_get_ip4_config (NMDevice *device,
 	return ret;
 }
 
+gboolean
+nm_modem_connection_secrets_updated (NMModem *self,
+                                     NMActRequest *req,
+                                     NMConnection *connection,
+                                     GSList *updated_settings,
+                                     RequestSecretsCaller caller)
+{
+	NMModemPrivate *priv;
+	gboolean found = FALSE;
+	const char *setting_name;
+	GSList *iter;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM (self), FALSE);
+	g_return_val_if_fail (req != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), FALSE);
+	g_return_val_if_fail (connection != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), FALSE);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+
+	if (caller == SECRETS_CALLER_PPP) {
+		const char *user = NULL;
+		const char *pass = NULL;
+
+		g_return_val_if_fail (priv->ppp_manager != NULL, FALSE);
+
+		if (!NM_MODEM_GET_CLASS (self)->get_user_pass (self, connection, &user, &pass)) {
+			/* Shouldn't ever happen */
+			nm_ppp_manager_update_secrets (priv->ppp_manager,
+										   priv->iface,
+										   NULL,
+										   NULL,
+										   "missing GSM/CDMA setting; no secrets could be found.");
+		} else {
+			nm_ppp_manager_update_secrets (priv->ppp_manager,
+										   priv->iface,
+										   user ? user : "",
+										   pass ? pass : "",
+										   NULL);
+		}
+		return TRUE;
+	}
+
+	g_return_val_if_fail (caller == SECRETS_CALLER_MOBILE_BROADBAND, FALSE);
+
+	g_assert (NM_MODEM_GET_CLASS (self)->get_setting_name);
+	setting_name = NM_MODEM_GET_CLASS (self)->get_setting_name (self);
+
+	for (iter = updated_settings; iter; iter = g_slist_next (iter)) {
+		const char *candidate_setting_name = (const char *) iter->data;
+
+		if (!strcmp (candidate_setting_name, setting_name))
+			found = TRUE;
+		else {
+			nm_log_warn (LOGD_MB, "ignoring updated secrets for setting '%s'.",
+			            candidate_setting_name);
+		}
+	}
+
+	return found;
+}
+
+static NMActStageReturn
+real_act_stage1_prepare (NMModem *modem,
+                         NMActRequest *req,
+                         GPtrArray **out_hints,
+                         const char **out_setting_name,
+                         NMDeviceStateReason *reason)
+{
+	*reason = NM_DEVICE_STATE_REASON_UNKNOWN;
+	return NM_ACT_STAGE_RETURN_FAILURE;
+}
+
+NMActStageReturn
+nm_modem_act_stage1_prepare (NMModem *self,
+                             NMActRequest *req,
+                             NMDeviceStateReason *reason)
+{
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
+	NMActStageReturn ret;
+	GPtrArray *hints = NULL;
+	const char *setting_name = NULL;
+
+	ret = NM_MODEM_GET_CLASS (self)->act_stage1_prepare (self,
+	                                                     req,
+	                                                     &hints,
+	                                                     &setting_name,
+	                                                     reason);
+	if ((ret == NM_ACT_STAGE_RETURN_POSTPONE) && setting_name) {
+		const char *hint1 = NULL, *hint2 = NULL;
+
+		/* Need some secrets */
+		if (hints) {
+			if (hints->len > 0)
+				hint1 = g_ptr_array_index (hints, 0);
+			if (hints->len > 1)
+				hint2 = g_ptr_array_index (hints, 1);
+		}
+
+		g_signal_emit (self, signals[NEED_AUTH], 0,
+		               setting_name, 
+	                   priv->secrets_tries++ ? TRUE : FALSE,
+	                   SECRETS_CALLER_MOBILE_BROADBAND,
+	                   hint1,
+	                   hint2);
+
+		if (hints)
+			g_ptr_array_free (hints, TRUE);
+	}
+	
+	return ret;
+}
+
+NMActStageReturn
+nm_modem_act_stage2_config (NMModem *self,
+                            NMActRequest *req,
+                            NMDeviceStateReason *reason)
+{
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
+
+	/* Clear secrets tries counter since secrets were successfully used
+	 * already if we get here.
+	 */
+	priv->secrets_tries = 0;
+
+	return NM_ACT_STAGE_RETURN_SUCCESS;
+}
+
+NMConnection *
+nm_modem_get_best_auto_connection (NMModem *self,
+                                   GSList *connections,
+                                   char **specific_object)
+{
+	if (NM_MODEM_GET_CLASS (self)->get_best_auto_connection)
+		return NM_MODEM_GET_CLASS (self)->get_best_auto_connection (self, connections, specific_object);
+	return NULL;
+}
+
+gboolean
+nm_modem_check_connection_compatible (NMModem *self,
+                                      NMConnection *connection,
+                                      GError **error)
+{
+	if (NM_MODEM_GET_CLASS (self)->check_connection_compatible)
+		return NM_MODEM_GET_CLASS (self)->check_connection_compatible (self, connection, error);
+	return FALSE;
+}
+
 static void
-real_deactivate_quickly (NMDevice *device)
+real_deactivate_quickly (NMModem *self, NMDevice *device)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+	NMModemPrivate *priv;
 	const char *iface;
 
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM (self));
+	g_return_if_fail (device != NULL);
+	g_return_if_fail (NM_IS_DEVICE (device));
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+
+	priv->secrets_tries = 0;
+
+	if (priv->call) {
+		dbus_g_proxy_cancel_call (priv->proxy, priv->call);
+		priv->call = NULL;
+	}
+
 	if (priv->pending_ip4_config) {
 		g_object_unref (priv->pending_ip4_config);
 		priv->pending_ip4_config = NULL;
@@ -425,7 +651,7 @@ real_deactivate_quickly (NMDevice *device)
 
 	priv->in_bytes = priv->out_bytes = 0;
 
-	switch (NM_MODEM_GET_PRIVATE (device)->ip_method) {
+	switch (priv->ip_method) {
 	case MM_MODEM_IP_METHOD_PPP:
 		if (priv->ppp_manager) {
 			g_object_unref (priv->ppp_manager);
@@ -434,45 +660,53 @@ real_deactivate_quickly (NMDevice *device)
 		break;
 	case MM_MODEM_IP_METHOD_STATIC:
 	case MM_MODEM_IP_METHOD_DHCP:
-		iface = nm_device_get_iface (device);
-
+		iface = nm_device_get_ip_iface (device);
 		nm_system_device_flush_routes_with_iface (iface);
 		nm_system_device_flush_addresses_with_iface (iface);
 		nm_system_device_set_up_down_with_iface (iface, FALSE, NULL);
 		break;
 	default:
-		g_warning ("Invalid IP method");
+		nm_log_err (LOGD_MB, "unknown IP method %d", priv->ip_method);
 		break;
 	}
-
-	if (NM_DEVICE_CLASS (nm_modem_parent_class)->deactivate)
-		NM_DEVICE_CLASS (nm_modem_parent_class)->deactivate (device);
 }
 
-static guint32
-real_get_generic_capabilities (NMDevice *dev)
+void
+nm_modem_deactivate_quickly (NMModem *self, NMDevice *device)
 {
-	return NM_DEVICE_CAP_NM_SUPPORTED;
+	NM_MODEM_GET_CLASS (self)->deactivate_quickly (self, device);
 }
 
 static void
-device_state_changed (NMDeviceInterface *device,
-					  NMDeviceState new_state,
-					  NMDeviceState old_state,
-					  NMDeviceStateReason reason,
-					  gpointer user_data)
+disconnect_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	GError *error = NULL;
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
+		nm_log_info (LOGD_MB, "disconnect failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+	}
+}
+
+void
+nm_modem_device_state_changed (NMModem *self,
+                               NMDeviceState new_state,
+                               NMDeviceState old_state,
+                               NMDeviceStateReason reason)
 {
-	NMModem *self = NM_MODEM (user_data);
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	gboolean was_connected = FALSE;
 
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM (self));
+
 	if (IS_ACTIVATING_STATE (old_state) || (old_state == NM_DEVICE_STATE_ACTIVATED))
 		was_connected = TRUE;
 
 	/* Make sure we don't leave the serial device open */
 	switch (new_state) {
 	case NM_DEVICE_STATE_NEED_AUTH:
-		if (priv->ppp_manager)
+		if (NM_MODEM_GET_PRIVATE (self)->ppp_manager)
 			break;
 		/* else fall through */
 	case NM_DEVICE_STATE_UNMANAGED:
@@ -480,9 +714,12 @@ device_state_changed (NMDeviceInterface *device,
 	case NM_DEVICE_STATE_FAILED:
 	case NM_DEVICE_STATE_DISCONNECTED:
 		if (was_connected) {
-			dbus_g_proxy_call_no_reply (nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM),
-			                            "Disconnect",
-			                            G_TYPE_INVALID);
+			dbus_g_proxy_begin_call (nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM),
+			                         "Disconnect",
+			                         disconnect_done,
+			                         self,
+			                         NULL,
+			                         G_TYPE_INVALID);
 		}
 		break;
 	default:
@@ -490,13 +727,13 @@ device_state_changed (NMDeviceInterface *device,
 	}
 }
 
-static gboolean
-real_hw_is_up (NMDevice *device)
+gboolean
+nm_modem_hw_is_up (NMModem *self, NMDevice *device)
 {
-	guint32 ip_method = NM_MODEM_GET_PRIVATE (device)->ip_method;
+	guint32 ip_method = NM_MODEM_GET_PRIVATE (self)->ip_method;
 
 	if (ip_method == MM_MODEM_IP_METHOD_STATIC || ip_method == MM_MODEM_IP_METHOD_DHCP) {
-		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 		NMDeviceState state;
 
 		state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
@@ -507,13 +744,13 @@ real_hw_is_up (NMDevice *device)
 	return TRUE;
 }
 
-static gboolean
-real_hw_bring_up (NMDevice *device, gboolean *no_firmware)
+gboolean
+nm_modem_hw_bring_up (NMModem *self, NMDevice *device, gboolean *no_firmware)
 {
-	guint32 ip_method = NM_MODEM_GET_PRIVATE (device)->ip_method;
+	guint32 ip_method = NM_MODEM_GET_PRIVATE (self)->ip_method;
 
 	if (ip_method == MM_MODEM_IP_METHOD_STATIC || ip_method == MM_MODEM_IP_METHOD_DHCP) {
-		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 		NMDeviceState state;
 
 		state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
@@ -524,6 +761,24 @@ real_hw_bring_up (NMDevice *device, gboolean *no_firmware)
 	return TRUE;
 }
 
+const char *
+nm_modem_get_iface (NMModem *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM (self), NULL);
+
+	return NM_MODEM_GET_PRIVATE (self)->iface;
+}
+
+const char *
+nm_modem_get_path (NMModem *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM (self), NULL);
+
+	return NM_MODEM_GET_PRIVATE (self)->path;
+}
+
 static void
 get_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
@@ -534,10 +789,9 @@ get_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_d
 	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
 	                            G_TYPE_VALUE, &value,
 	                            G_TYPE_INVALID)) {
-		g_warning ("%s: failed get modem enabled state: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_MB, "failed get modem enabled state: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 		return;
 	}
 
@@ -545,7 +799,7 @@ get_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_d
 		NM_MODEM_GET_PRIVATE (self)->mm_enabled = g_value_get_boolean (&value);
 		g_object_notify (G_OBJECT (self), NM_MODEM_ENABLED);
 	} else
-		g_warning ("%s: failed get modem enabled state: unexpected reply type", __func__);
+		nm_log_warn (LOGD_MB, "failed get modem enabled state: unexpected reply type");
 
 	g_value_unset (&value);
 }
@@ -567,21 +821,24 @@ set_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_d
 	GError *error = NULL;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
-		g_warning ("%s: failed to enable/disable modem: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_MB, "failed to enable/disable modem: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 	}
 
 	/* Update enabled/disabled state again */
 	query_mm_enabled (NM_MODEM (user_data));
 }
 
-static void
-real_set_enabled (NMDeviceInterface *device, gboolean enabled)
+void
+nm_modem_set_mm_enabled (NMModem *self, gboolean enabled)
 {
-	NMModem *self = NM_MODEM (device);
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
+	NMModemPrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM (self));
+
+	priv = NM_MODEM_GET_PRIVATE (self);
 
 	/* FIXME: For now this just toggles the ModemManager enabled state.  In the
 	 * future we want to tie this into rfkill state instead so that the user can
@@ -591,10 +848,10 @@ real_set_enabled (NMDeviceInterface *device, gboolean enabled)
 	if (priv->mm_enabled != enabled) {
 		DBusGProxy *proxy;
 
-		proxy = nm_modem_get_proxy (NM_MODEM (device), MM_DBUS_INTERFACE_MODEM);
+		proxy = nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM);
 		dbus_g_proxy_begin_call (proxy,
 		                         "Enable", set_mm_enabled_done,
-		                         device, NULL,
+		                         self, NULL,
 		                         G_TYPE_BOOLEAN, enabled,
 		                         G_TYPE_INVALID);
 	}
@@ -615,31 +872,14 @@ modem_properties_changed (DBusGProxy *proxy,
 
 	value = g_hash_table_lookup (props, "Enabled");
 	if (value && G_VALUE_HOLDS_BOOLEAN (value)) {
-		NMDeviceState state;
-
 		priv->mm_enabled = g_value_get_boolean (value);
 		g_object_notify (G_OBJECT (self), NM_MODEM_ENABLED);
-
-		if (priv->mm_enabled == FALSE) {
-			state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-			if (state == NM_DEVICE_STATE_ACTIVATED) {
-				nm_device_state_changed (NM_DEVICE (self),
-				                         NM_DEVICE_STATE_DISCONNECTED,
-				                         NM_DEVICE_STATE_REASON_NONE);
-			}
-		}
 	}
 }
 
 /*****************************************************************************/
 
 static void
-device_interface_init (NMDeviceInterface *iface_class)
-{
-    iface_class->set_enabled = real_set_enabled;
-}
-
-static void
 nm_modem_init (NMModem *self)
 {
 	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
@@ -665,12 +905,17 @@ constructor (GType type,
 	priv = NM_MODEM_GET_PRIVATE (object);
 
 	if (!priv->device) {
-		g_warning ("Modem device not provided");
+		nm_log_err (LOGD_HW, "modem parent device not provided");
+		goto err;
+	}
+
+	if (!priv->device) {
+		nm_log_err (LOGD_HW, "modem command interface not provided");
 		goto err;
 	}
 
 	if (!priv->path) {
-		g_warning ("DBus path not provided");
+		nm_log_err (LOGD_HW, "D-Bus path not provided");
 		goto err;
 	}
 
@@ -696,8 +941,6 @@ constructor (GType type,
 	                             object,
 	                             NULL);
 
-	g_signal_connect (object, "state-changed", G_CALLBACK (device_state_changed), object);
-
 	query_mm_enabled (NM_MODEM (object));
 
 	return object;
@@ -720,6 +963,9 @@ get_property (GObject *object, guint prop_id,
 	case PROP_DEVICE:
 		g_value_set_string (value, priv->device);
 		break;
+	case PROP_IFACE:
+		g_value_set_string (value, priv->iface);
+		break;
 	case PROP_IP_METHOD:
 		g_value_set_uint (value, priv->ip_method);
 		break;
@@ -748,7 +994,12 @@ set_property (GObject *object, guint prop_id,
 		/* Construct only */
 		priv->device = g_value_dup_string (value);
 		break;
+	case PROP_IFACE:
+		/* Construct only */
+		priv->iface = g_value_dup_string (value);
+		break;
 	case PROP_IP_METHOD:
+		/* Construct only */
 		priv->ip_method = g_value_get_uint (value);
 		break;
 	case PROP_ENABLED:
@@ -772,6 +1023,7 @@ finalize (GObject *object)
 
 	g_object_unref (priv->dbus_mgr);
 
+	g_free (priv->iface);
 	g_free (priv->path);
 	g_free (priv->device);
 
@@ -782,7 +1034,6 @@ static void
 nm_modem_class_init (NMModemClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-	NMDeviceClass *device_class = NM_DEVICE_CLASS (klass);
 
 	g_type_class_add_private (object_class, sizeof (NMModemPrivate));
 
@@ -792,12 +1043,8 @@ nm_modem_class_init (NMModemClass *klass)
 	object_class->get_property = get_property;
 	object_class->finalize = finalize;
 
-	device_class->get_generic_capabilities = real_get_generic_capabilities;
-	device_class->act_stage3_ip4_config_start = real_act_stage3_ip4_config_start;
-	device_class->act_stage4_get_ip4_config = real_act_stage4_get_ip4_config;
-	device_class->deactivate_quickly = real_deactivate_quickly;
-	device_class->hw_is_up = real_hw_is_up;
-	device_class->hw_bring_up = real_hw_bring_up;
+	klass->act_stage1_prepare = real_act_stage1_prepare;
+	klass->deactivate_quickly = real_deactivate_quickly;
 
 	/* Properties */
 	g_object_class_install_property
@@ -806,7 +1053,7 @@ nm_modem_class_init (NMModemClass *klass)
 							  "DBus path",
 							  "DBus path",
 							  NULL,
-							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
 	g_object_class_install_property
 		(object_class, PROP_DEVICE,
@@ -814,7 +1061,15 @@ nm_modem_class_init (NMModemClass *klass)
 		                      "Device",
 		                      "Master modem parent device",
 		                      NULL,
-		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_IFACE,
+		 g_param_spec_string (NM_MODEM_IFACE,
+		                      "Interface",
+		                      "Modem command interface",
+		                      NULL,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
 	g_object_class_install_property
 		(object_class, PROP_IP_METHOD,
@@ -824,7 +1079,7 @@ nm_modem_class_init (NMModemClass *klass)
 							MM_MODEM_IP_METHOD_PPP,
 							MM_MODEM_IP_METHOD_DHCP,
 							MM_MODEM_IP_METHOD_PPP,
-							G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+							G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
 	g_object_class_install_property
 		(object_class, PROP_ENABLED,
@@ -845,10 +1100,47 @@ nm_modem_class_init (NMModemClass *klass)
 					  G_TYPE_NONE, 2,
 					  G_TYPE_UINT, G_TYPE_UINT);
 
-	signals[PROPERTIES_CHANGED] = 
-		nm_properties_changed_signal_new (object_class,
-										  G_STRUCT_OFFSET (NMModemClass, properties_changed));
+	signals[PPP_FAILED] =
+		g_signal_new ("ppp-failed",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, ppp_failed),
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__UINT,
+					  G_TYPE_NONE, 1, G_TYPE_UINT);
+
+	signals[IP4_CONFIG_RESULT] =
+		g_signal_new (NM_MODEM_IP4_CONFIG_RESULT,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, ip4_config_result),
+					  NULL, NULL,
+					  _nm_marshal_VOID__STRING_OBJECT_POINTER,
+					  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_OBJECT, G_TYPE_POINTER);
 
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
-									 &dbus_glib_nm_serial_device_object_info);
+	signals[PREPARE_RESULT] =
+		g_signal_new (NM_MODEM_PREPARE_RESULT,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, prepare_result),
+					  NULL, NULL,
+					  _nm_marshal_VOID__BOOLEAN_UINT,
+					  G_TYPE_NONE, 2, G_TYPE_BOOLEAN, G_TYPE_UINT);
+
+	signals[NEED_AUTH] =
+		g_signal_new (NM_MODEM_NEED_AUTH,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, need_auth),
+					  NULL, NULL,
+					  _nm_marshal_VOID__STRING_BOOLEAN_UINT_STRING_STRING,
+					  G_TYPE_NONE, 5,
+					  G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRING);
 }
+
+const DBusGObjectInfo *
+nm_modem_get_serial_dbus_info (void)
+{
+	return &dbus_glib_nm_serial_device_object_info;
+}
+
diff --git a/src/modem-manager/nm-modem.h b/src/modem-manager/nm-modem.h
index 0a72276..a2aed57 100644
--- a/src/modem-manager/nm-modem.h
+++ b/src/modem-manager/nm-modem.h
@@ -23,8 +23,9 @@
 #define NM_MODEM_H
 
 #include <dbus/dbus-glib.h>
-#include <nm-device.h>
+#include <glib-object.h>
 #include "ppp-manager/nm-ppp-manager.h"
+#include "nm-device.h"
 
 G_BEGIN_DECLS
 
@@ -37,36 +38,119 @@ G_BEGIN_DECLS
 
 #define NM_MODEM_PATH      "path"
 #define NM_MODEM_DEVICE    "device"
+#define NM_MODEM_IFACE     "iface"
 #define NM_MODEM_IP_METHOD "ip-method"
 #define NM_MODEM_ENABLED   "enabled"
 
+#define NM_MODEM_PPP_STATS         "ppp-stats"
+#define NM_MODEM_PPP_FAILED        "ppp-failed"
+#define NM_MODEM_PREPARE_RESULT    "prepare-result"
+#define NM_MODEM_IP4_CONFIG_RESULT "ip4-config-result"
+#define NM_MODEM_NEED_AUTH         "need-auth"
+
 typedef struct {
-	NMDevice parent;
+	GObject parent;
 } NMModem;
 
 typedef struct {
-	NMDeviceClass parent;
+	GObjectClass parent;
+
+	gboolean (*get_user_pass)                  (NMModem *modem,
+	                                            NMConnection *connection,
+	                                            const char **user,
+	                                            const char **pass);
+
+	const char * (*get_setting_name)           (NMModem *modem);
+
+	gboolean (*check_connection_compatible)    (NMModem *modem,
+	                                            NMConnection *connection,
+	                                            GError **error);
+
+	NMConnection * (*get_best_auto_connection) (NMModem *modem,
+	                                            GSList *connections,
+	                                            char **specific_object);
 
-	const char *(*get_ppp_name) (NMModem *self,
-								 NMConnection *connection);
+	NMActStageReturn (*act_stage1_prepare)     (NMModem *modem,
+	                                            NMActRequest *req,
+	                                            GPtrArray **out_hints,
+	                                            const char **out_setting_name,
+	                                            NMDeviceStateReason *reason);
+
+	void (*deactivate_quickly)                 (NMModem *self, NMDevice *device);
 
 	/* Signals */
-	void (*ppp_stats) (NMModem *self, guint32 in_bytes, guint32 out_bytes);
-	void (*properties_changed) (NMModem *self, GHashTable *properties);
+	void (*ppp_stats)  (NMModem *self, guint32 in_bytes, guint32 out_bytes);
+	void (*ppp_failed) (NMModem *self, NMDeviceStateReason reason);
+
+	void (*prepare_result)    (NMModem *self, gboolean success, NMDeviceStateReason reason);
+	void (*ip4_config_result) (NMModem *self, const char *iface, NMIP4Config *config, GError *error);
+
+	void (*need_auth)  (NMModem *self,
+	                    const char *setting_name,
+	                    gboolean retry,
+	                    RequestSecretsCaller caller,
+	                    const char *hint1,
+	                    const char *hint2);
 } NMModemClass;
 
 GType nm_modem_get_type (void);
 
 /* Protected */
 
-NMPPPManager *nm_modem_get_ppp_manager (NMModem *self);
-DBusGProxy	 *nm_modem_get_proxy	   (NMModem *self,
-										const char *interface);
+NMPPPManager *nm_modem_get_ppp_manager (NMModem *modem);
+DBusGProxy *  nm_modem_get_proxy       (NMModem *modem, const char *interface);
+const char *  nm_modem_get_iface       (NMModem *modem);
+const char *  nm_modem_get_path        (NMModem *modem);
+
+NMConnection *nm_modem_get_best_auto_connection (NMModem *self,
+                                                 GSList *connections,
+                                                 char **specific_object);
+
+gboolean nm_modem_check_connection_compatible (NMModem *self,
+                                               NMConnection *connection,
+                                               GError **error);
+
+NMActStageReturn nm_modem_act_stage1_prepare (NMModem *modem,
+                                              NMActRequest *req,
+                                              NMDeviceStateReason *reason);
+
+NMActStageReturn nm_modem_act_stage2_config (NMModem *modem,
+                                             NMActRequest *req,
+                                             NMDeviceStateReason *reason);
+
+NMActStageReturn nm_modem_stage3_ip4_config_start (NMModem *modem,
+                                                   NMDevice *device,
+                                                   NMDeviceClass *device_class,
+                                                   NMDeviceStateReason *reason);
+
+NMActStageReturn nm_modem_stage4_get_ip4_config (NMModem *modem,
+                                                 NMDevice *device,
+                                                 NMDeviceClass *device_class,
+                                                 NMIP4Config **config,
+                                                 NMDeviceStateReason *reason);
+
+void nm_modem_deactivate_quickly (NMModem *modem, NMDevice *device);
+
+void nm_modem_device_state_changed (NMModem *modem,
+                                    NMDeviceState new_state,
+                                    NMDeviceState old_state,
+                                    NMDeviceStateReason reason);
+
+gboolean nm_modem_hw_is_up (NMModem *modem, NMDevice *device);
+
+gboolean nm_modem_hw_bring_up (NMModem *modem, NMDevice *device, gboolean *no_firmware);
+
+gboolean nm_modem_connection_secrets_updated (NMModem *modem,
+                                              NMActRequest *req,
+                                              NMConnection *connection,
+                                              GSList *updated_settings,
+                                              RequestSecretsCaller caller);
+
+const DBusGObjectInfo *nm_modem_get_serial_dbus_info (void);
 
-const char	 *nm_modem_get_ppp_name	   (NMModem *self,
-										NMConnection *connection);
+gboolean      nm_modem_get_mm_enabled (NMModem *self);
 
-gboolean      nm_modem_get_mm_enabled  (NMModem *self);
+void          nm_modem_set_mm_enabled (NMModem *self, gboolean enabled);
 
 G_END_DECLS
 
diff --git a/src/named-manager/Makefile.am b/src/named-manager/Makefile.am
index fe1ec91..a33f7d5 100644
--- a/src/named-manager/Makefile.am
+++ b/src/named-manager/Makefile.am
@@ -1,4 +1,8 @@
-INCLUDES = -I${top_srcdir}/libnm-util -I${top_srcdir}/src -I${top_srcdir}/include
+INCLUDES = \
+	-I${top_srcdir}/src/logging \
+	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src \
+	-I${top_srcdir}/include
 
 noinst_LTLIBRARIES = libnamed-manager.la
 
@@ -10,4 +14,8 @@ libnamed_manager_la_CPPFLAGS = \
 	-DNM_PKGDATADIR=\"$(pkgdatadir)\" \
 	-DNM_LOCALSTATEDIR=\"$(localstatedir)\"
 
-libnamed_manager_la_LIBADD = $(DBUS_LIBS) $(GLIB_LIBS)
+libnamed_manager_la_LIBADD = \
+	$(top_builddir)/src/logging/libnm-logging.la \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS)
+
diff --git a/src/named-manager/nm-named-manager.c b/src/named-manager/nm-named-manager.c
index c96a2e6..2963652 100644
--- a/src/named-manager/nm-named-manager.c
+++ b/src/named-manager/nm-named-manager.c
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2004 - 2005 Colin Walters <walters@redhat.com>
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
  * Copyright (C) 2005 - 2008 Novell, Inc.
  *   and others
  */
@@ -38,8 +38,8 @@
 
 #include "nm-named-manager.h"
 #include "nm-ip4-config.h"
-#include "nm-utils.h"
-#include "NetworkManagerSystem.h"
+#include "nm-logging.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 #ifdef HAVE_SELINUX
@@ -60,9 +60,9 @@ G_DEFINE_TYPE(NMNamedManager, nm_named_manager, G_TYPE_OBJECT)
 
 
 struct NMNamedManagerPrivate {
-	NMIP4Config *   vpn_config;
-	NMIP4Config *   device_config;
-	GSList *        configs;
+	NMIP4Config *vpn_config;
+	NMIP4Config *device_config;
+	GSList *configs;
 };
 
 
@@ -71,11 +71,10 @@ nm_named_manager_get (void)
 {
 	static NMNamedManager * singleton = NULL;
 
-	if (!singleton) {
+	if (!singleton)
 		singleton = NM_NAMED_MANAGER (g_object_new (NM_TYPE_NAMED_MANAGER, NULL));
-	} else {
+	else
 		g_object_ref (singleton);
-	}
 
 	g_assert (singleton);
 	return singleton;
@@ -185,7 +184,7 @@ run_netconfig (GError **error, gint *stdin_fd)
 	argv[4] = NULL;
 
 	tmp = g_strjoinv (" ", argv);
-	nm_debug ("Spawning '%s'", tmp);
+	nm_log_debug (LOGD_DNS, "spawning '%s'", tmp);
 	g_free (tmp);
 
 	if (!g_spawn_async_with_pipes (NULL, argv, NULL, 0, netconfig_child_setup,
@@ -202,7 +201,7 @@ write_to_netconfig (gint fd, const char *key, const char *value)
 	int x;
 
 	str = g_strdup_printf ("%s='%s'\n", key, value);
-	nm_debug ("Writing to netconfig: %s", str);
+	nm_log_debug (LOGD_DNS, "writing to netconfig: %s", str);
 	x = write (fd, str, strlen (str));
 	g_free (str);
 }
@@ -327,7 +326,7 @@ write_resolv_conf (FILE *f, const char *domain,
 	}
 
 	if (fprintf (f, "%s%s%s",
-		     domain_str ? domain_str : "",
+	             domain_str ? domain_str : "",
 	             searches_str ? searches_str : "",
 	             nameservers_str ? nameservers_str : "") != -1)
 		retval = TRUE;
@@ -356,7 +355,7 @@ dispatch_resolvconf (const char *domain,
 
 	if (domain || searches || nameservers) {
 		cmd = g_strconcat (RESOLVCONF_PATH, " -a ", "NetworkManager", NULL);
-		nm_info ("(%s): writing resolv.conf to %s", iface, RESOLVCONF_PATH);
+		nm_log_info (LOGD_DNS, "(%s): writing resolv.conf to %s", iface, RESOLVCONF_PATH);
 		if ((f = popen (cmd, "w")) == NULL)
 			g_set_error (error,
 				     NM_NAMED_MANAGER_ERROR,
@@ -370,7 +369,7 @@ dispatch_resolvconf (const char *domain,
 		}
 	} else {
 		cmd = g_strconcat (RESOLVCONF_PATH, " -d ", "NetworkManager", NULL);
-		nm_info ("(%s): removing resolv.conf from %s", iface, RESOLVCONF_PATH);
+		nm_log_info (LOGD_DNS, "(%s): removing resolv.conf from %s", iface, RESOLVCONF_PATH);
 		if (nm_spawn_process (cmd) == 0)
 			retval = TRUE;
 	}
@@ -587,7 +586,7 @@ nm_named_manager_add_ip4_config (NMNamedManager *mgr,
 		priv->configs = g_slist_append (priv->configs, g_object_ref (config));
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		g_error_free (error);
 	}
 
@@ -623,7 +622,7 @@ nm_named_manager_remove_ip4_config (NMNamedManager *mgr,
 	g_object_unref (config);
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		if (error)
 			g_error_free (error);
 	}
@@ -653,7 +652,7 @@ nm_named_manager_add_ip6_config (NMNamedManager *mgr,
 		priv->configs = g_slist_append (priv->configs, g_object_ref (config));
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		g_error_free (error);
 	}
 
@@ -683,7 +682,7 @@ nm_named_manager_remove_ip6_config (NMNamedManager *mgr,
 	g_object_unref (config);	
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		if (error)
 			g_error_free (error);
 	}
diff --git a/src/nm-activation-request.c b/src/nm-activation-request.c
index f85c12d..1335c35 100644
--- a/src/nm-activation-request.c
+++ b/src/nm-activation-request.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2007 - 2008 Novell, Inc.
  */
 
@@ -27,7 +27,7 @@
 
 #include "nm-activation-request.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-setting-wireless-security.h"
 #include "nm-setting-8021x.h"
 #include "nm-dbus-manager.h"
@@ -418,9 +418,9 @@ secrets_update_setting (NMSecretsProviderInterface *interface,
 		nm_connection_add_setting (priv->connection, setting);
 	else {
 		if (!nm_connection_update_secrets (priv->connection, setting_name, new, &error)) {
-			nm_warning ("Failed to update connection secrets: %d %s",
-			            error ? error->code : -1,
-			            error && error->message ? error->message : "(none)");
+			nm_log_warn (LOGD_DEVICE, "Failed to update connection secrets: %d %s",
+			             error ? error->code : -1,
+			             error && error->message ? error->message : "(none)");
 			g_clear_error (&error);
 		}
 	}
@@ -591,15 +591,17 @@ nm_act_request_set_shared (NMActRequest *req, gboolean shared)
 			int status;
 			GError *error = NULL;
 
-			nm_info ("Executing: %s", cmd);
+			nm_log_info (LOGD_SHARING, "Executing: %s", cmd);
 			if (!g_spawn_sync ("/", argv, envp, G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
 			                   share_child_setup, NULL, NULL, NULL, &status, &error)) {
-				nm_info ("Error executing command: (%d) %s",
-				         error ? error->code : -1,
-				         (error && error->message) ? error->message : "(unknown)");
+				nm_log_warn (LOGD_SHARING, "Error executing command: (%d) %s",
+				             error ? error->code : -1,
+				             (error && error->message) ? error->message : "(unknown)");
 				g_clear_error (&error);
-			} else if (WEXITSTATUS (status))
-				nm_info ("** Command returned exit status %d.", WEXITSTATUS (status));
+			} else if (WEXITSTATUS (status)) {
+				nm_log_warn (LOGD_SHARING, "** Command returned exit status %d.",
+				             WEXITSTATUS (status));
+			}
 		}
 		g_free (cmd);
 		if (argv)
diff --git a/src/nm-active-connection.c b/src/nm-active-connection.c
index 019b5c3..4207e14 100644
--- a/src/nm-active-connection.c
+++ b/src/nm-active-connection.c
@@ -15,13 +15,14 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <glib.h>
 #include "nm-active-connection.h"
 #include "NetworkManager.h"
 #include "nm-active-connection-glue.h"
+#include "nm-logging.h"
 
 char *
 nm_active_connection_get_next_object_path (void)
@@ -54,7 +55,7 @@ nm_active_connection_scope_to_value (NMConnection *connection, GValue *value)
 		g_value_set_string (value, NM_DBUS_SERVICE_USER_SETTINGS);
 		break;
 	default:
-		g_warning ("%s: unknown connection scope!", __func__);
+		nm_log_err (LOGD_CORE, "unknown connection scope!");
 		break;
 	}
 }
diff --git a/src/nm-call-store.c b/src/nm-call-store.c
index 837edf0..df400d0 100644
--- a/src/nm-call-store.c
+++ b/src/nm-call-store.c
@@ -16,10 +16,11 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 Novell, Inc.
+ * Copyright (C) 2010 Red Hat, Inc.
  */
 
 #include "nm-call-store.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 NMCallStore *
 nm_call_store_new (void)
@@ -68,12 +69,12 @@ nm_call_store_remove (NMCallStore *store,
 
 	call_ids_hash = g_hash_table_lookup (store, object);
 	if (!call_ids_hash) {
-		nm_warning ("Trying to remove a non-existant call id.");
+		nm_log_warn (LOGD_CORE, "Trying to remove a non-existant call id.");
 		return;
 	}
 
 	if (!g_hash_table_remove (call_ids_hash, call_id))
-		nm_warning ("Trying to remove a non-existant call id.");
+		nm_log_warn (LOGD_CORE, "Trying to remove a non-existant call id.");
 
 	if (g_hash_table_size (call_ids_hash) == 0) {
 		g_hash_table_remove (store, object);
@@ -162,7 +163,7 @@ nm_call_store_foreach (NMCallStore *store,
 
 		call_ids_hash = g_hash_table_lookup (store, object);
 		if (!call_ids_hash) {
-			nm_warning ("Object not in store");
+			nm_log_warn (LOGD_CORE, "Object not in store");
 			return -1;
 		}
 
diff --git a/src/nm-dbus-manager.c b/src/nm-dbus-manager.c
index 37039f1..9b621b4 100644
--- a/src/nm-dbus-manager.c
+++ b/src/nm-dbus-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -29,7 +29,7 @@
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <string.h>
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 enum {
 	DBUS_CONNECTION_CHANGED = 0,
@@ -158,7 +158,7 @@ nm_dbus_manager_reconnect (gpointer user_data)
 
 	if (nm_dbus_manager_init_bus (self)) {
 		if (nm_dbus_manager_start_service (self)) {
-			nm_info ("reconnected to the system bus.");
+			nm_log_info (LOGD_CORE, "reconnected to the system bus.");
 			g_signal_emit (self, signals[DBUS_CONNECTION_CHANGED],
 			               0, priv->connection);
 			priv->reconnect_id = 0;
@@ -223,8 +223,8 @@ nm_dbus_manager_name_has_owner (NMDBusManager *self,
 					    G_TYPE_INVALID,
 					    G_TYPE_BOOLEAN, &has_owner,
 					    G_TYPE_INVALID)) {
-		nm_warning ("NameHasOwner request failed: %s",
-		            (err && err->message) ? err->message : "(unknown)");
+		nm_log_warn (LOGD_CORE, "NameHasOwner request failed: %s",
+		             (err && err->message) ? err->message : "(unknown)");
 		g_clear_error (&err);
 	}
 
@@ -248,7 +248,7 @@ destroy_cb (DBusGProxy *proxy, gpointer user_data)
 	NMDBusManager *self = NM_DBUS_MANAGER (user_data);
 
 	/* Clean up existing connection */
-	nm_info ("disconnected by the system bus.");
+	nm_log_warn (LOGD_CORE, "disconnected by the system bus.");
 	NM_DBUS_MANAGER_GET_PRIVATE (self)->proxy = NULL;
 
 	nm_dbus_manager_cleanup (self, FALSE);
@@ -265,7 +265,7 @@ nm_dbus_manager_init_bus (NMDBusManager *self)
 	GError *err = NULL;
 
 	if (priv->connection) {
-		nm_warning ("DBus Manager already has a valid connection.");
+		nm_log_warn (LOGD_CORE, "DBus Manager already has a valid connection.");
 		return FALSE;
 	}
 
@@ -273,7 +273,7 @@ nm_dbus_manager_init_bus (NMDBusManager *self)
 
 	priv->g_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &err);
 	if (!priv->g_connection) {
-		nm_warning ("Could not get the system bus.  Make sure "
+		nm_log_err (LOGD_CORE, "Could not get the system bus.  Make sure "
 		            "the message bus daemon is running!  Message: %s",
 		            err->message);
 		g_error_free (err);
@@ -317,7 +317,7 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 	priv = NM_DBUS_MANAGER_GET_PRIVATE (self);
 
 	if (priv->started) {
-		nm_warning ("Service has already started.");
+		nm_log_err (LOGD_CORE, "Service has already started.");
 		return FALSE;
 	}
 
@@ -327,7 +327,7 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 	                        G_TYPE_INVALID,
 	                        G_TYPE_UINT, &result,
 	                        G_TYPE_INVALID)) {
-		nm_warning ("Could not acquire the NetworkManager service.\n"
+		nm_log_err (LOGD_CORE, "Could not acquire the NetworkManager service.\n"
 		            "  Error: '%s'",
 		            (err && err->message) ? err->message : "(unknown)");
 		g_error_free (err);
@@ -335,7 +335,7 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 	}
 
 	if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		nm_warning ("Could not acquire the NetworkManager service as it is already taken.");
+		nm_log_err (LOGD_CORE, "Could not acquire the NetworkManager service as it is already taken.");
 		return FALSE;
 	}
 
@@ -345,15 +345,15 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 							G_TYPE_INVALID,
 							G_TYPE_UINT, &result,
 							G_TYPE_INVALID)) {
-		g_warning ("Could not acquire the NetworkManagerSystemSettings service.\n"
-		           "  Message: '%s'", err->message);
+		nm_log_warn (LOGD_CORE, "Could not acquire the NetworkManagerSystemSettings service.\n"
+		             "  Message: '%s'", err->message);
 		g_error_free (err);
 		return FALSE;
 	}
 
 	if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		g_warning ("Could not acquire the NetworkManagerSystemSettings service "
-		           "as it is already taken.");
+		nm_log_warn (LOGD_CORE, "Could not acquire the NetworkManagerSystemSettings service "
+		             "as it is already taken.");
 		return FALSE;
 	}
 
diff --git a/src/nm-device-bt.c b/src/nm-device-bt.c
index 444c7ff..8cf179e 100644
--- a/src/nm-device-bt.c
+++ b/src/nm-device-bt.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <stdio.h>
@@ -28,7 +28,7 @@
 #include "nm-device-bt.h"
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "ppp-manager/nm-ppp-manager.h"
 #include "nm-properties-changed-signal.h"
@@ -51,14 +51,16 @@ typedef struct {
 	char *name;
 	guint32 capabilities;
 
+	gboolean connected;
+	gboolean have_iface;
+
 	DBusGProxy *type_proxy;
+	DBusGProxy *dev_proxy;
 
-	NMPPPManager *ppp_manager;
 	char *rfcomm_iface;
-	guint32 in_bytes;
-	guint32 out_bytes;
+	NMModem *modem;
+	guint32 timeout_id;
 
-	NMIP4Config *pending_ip4_config;
 	guint32 bt_type;  /* BT type of the current connection */
 } NMDeviceBtPrivate;
 
@@ -122,31 +124,6 @@ nm_bt_error_get_type (void)
 }
 
 
-NMDevice *
-nm_device_bt_new (const char *udi,
-                  const char *bdaddr,
-                  const char *name,
-                  guint32 capabilities,
-                  gboolean managed)
-{
-	g_return_val_if_fail (udi != NULL, NULL);
-	g_return_val_if_fail (bdaddr != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	g_return_val_if_fail (capabilities != NM_BT_CAPABILITY_NONE, NULL);
-
-	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_BT,
-	                                  NM_DEVICE_INTERFACE_UDI, udi,
-	                                  NM_DEVICE_INTERFACE_IFACE, bdaddr,
-	                                  NM_DEVICE_INTERFACE_DRIVER, "bluez",
-	                                  NM_DEVICE_BT_HW_ADDRESS, bdaddr,
-	                                  NM_DEVICE_BT_NAME, name,
-	                                  NM_DEVICE_BT_CAPABILITIES, capabilities,
-	                                  NM_DEVICE_INTERFACE_MANAGED, managed,
-	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "Bluetooth",
-	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_BT,
-	                                  NULL);
-}
-
 guint32 nm_device_bt_get_capabilities (NMDeviceBt *self)
 {
 	g_return_val_if_fail (self != NULL, NM_BT_CAPABILITY_NONE);
@@ -281,16 +258,26 @@ real_get_generic_capabilities (NMDevice *dev)
 /* IP method PPP */
 
 static void
-ppp_state_changed (NMPPPManager *ppp_manager, NMPPPStatus status, gpointer user_data)
+ppp_stats (NMModem *modem,
+		   guint32 in_bytes,
+		   guint32 out_bytes,
+		   gpointer user_data)
+{
+	g_signal_emit (NM_DEVICE_BT (user_data), signals[PPP_STATS], 0, in_bytes, out_bytes);
+}
+
+static void
+ppp_failed (NMModem *modem, NMDeviceStateReason reason, gpointer user_data)
 {
 	NMDevice *device = NM_DEVICE (user_data);
 
-	switch (status) {
-	case NM_PPP_STATUS_DISCONNECT:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_DISCONNECT);
-		break;
-	case NM_PPP_STATUS_DEAD:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_FAILED);
+	switch (nm_device_interface_get_state (NM_DEVICE_INTERFACE (device))) {
+	case NM_DEVICE_STATE_PREPARE:
+	case NM_DEVICE_STATE_CONFIG:
+	case NM_DEVICE_STATE_NEED_AUTH:
+	case NM_DEVICE_STATE_IP_CONFIG:
+	case NM_DEVICE_STATE_ACTIVATED:
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
 		break;
 	default:
 		break;
@@ -298,68 +285,127 @@ ppp_state_changed (NMPPPManager *ppp_manager, NMPPPStatus status, gpointer user_
 }
 
 static void
-ppp_ip4_config (NMPPPManager *ppp_manager,
-                const char *iface,
-                NMIP4Config *config,
-                gpointer user_data)
+modem_need_auth (NMModem *modem,
+	             const char *setting_name,
+	             gboolean retry,
+	             RequestSecretsCaller caller,
+	             const char *hint1,
+	             const char *hint2,
+	             gpointer user_data)
+{
+	NMDeviceBt *self = NM_DEVICE_BT (user_data);
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_assert (req);
+
+	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
+	nm_act_request_get_secrets (req, setting_name, retry, caller, hint1, hint2);
+}
+
+static void
+modem_prepare_result (NMModem *modem,
+                      gboolean success,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
 {
 	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
 
-	/* Ignore PPP IP4 events that come in after initial configuration */
-	if (nm_device_get_state (device) != NM_DEVICE_STATE_IP_CONFIG)
-		return;
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_CONFIG || state == NM_DEVICE_STATE_NEED_AUTH);
 
-	nm_device_set_ip_iface (device, iface);
-	NM_DEVICE_BT_GET_PRIVATE (device)->pending_ip4_config = g_object_ref (config);
-	nm_device_activate_schedule_stage4_ip4_config_get (device);
+	if (success) {
+		NMActRequest *req;
+		NMActStageReturn ret;
+		NMDeviceStateReason stage2_reason = NM_DEVICE_STATE_REASON_NONE;
+
+		req = nm_device_get_act_request (device);
+		g_assert (req);
+
+		ret = nm_modem_act_stage2_config (modem, req, &stage2_reason);
+		switch (ret) {
+		case NM_ACT_STAGE_RETURN_POSTPONE:
+			break;
+		case NM_ACT_STAGE_RETURN_SUCCESS:
+			nm_device_activate_schedule_stage3_ip_config_start (device);
+			break;
+		case NM_ACT_STAGE_RETURN_FAILURE:
+		default:
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, stage2_reason);
+			break;
+		}
+	} else
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
 }
 
 static void
-ppp_stats (NMPPPManager *ppp_manager,
-           guint32 in_bytes,
-           guint32 out_bytes,
-           gpointer user_data)
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
 {
-	NMDeviceBt *self = NM_DEVICE_BT (user_data);
-	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
+	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
+
+	if (priv->modem)
+		nm_modem_device_state_changed (priv->modem, new_state, old_state, reason);
+}
+
+static void
+modem_ip4_config_result (NMModem *self,
+                         const char *iface,
+                         NMIP4Config *config,
+                         GError *error,
+                         gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_IP_CONFIG);
 
-	if (priv->in_bytes != in_bytes || priv->out_bytes != out_bytes) {
-		priv->in_bytes = in_bytes;
-		priv->out_bytes = out_bytes;
+	if (error) {
+		nm_log_warn (LOGD_MB | LOGD_IP4 | LOGD_BT,
+		             "(%s): retrieving IP4 configuration failed: (%d) %s",
+		             nm_device_get_ip_iface (device),
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 
-		g_signal_emit (self, signals[PPP_STATS], 0, in_bytes, out_bytes);
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);
+	} else {
+		if (iface)
+			nm_device_set_ip_iface (device, iface);
+
+		nm_device_activate_schedule_stage4_ip4_config_get (device);
 	}
 }
 
 static gboolean
-get_ppp_credentials (NMConnection *connection,
-                     const char **username,
-                     const char **password)
-{
-	NMSettingGsm *s_gsm;
-	NMSettingCdma *s_cdma = NULL;
-
-	s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-	if (s_gsm) {
-		if (username)
-			*username = nm_setting_gsm_get_username (s_gsm);
-		if (password)
-			*password = nm_setting_gsm_get_password (s_gsm);
-	} else {
-		/* Try CDMA then */
-		s_cdma = (NMSettingCdma *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CDMA);
-		if (s_cdma) {
-			if (username)
-				*username = nm_setting_cdma_get_username (s_cdma);
-			if (password)
-				*password = nm_setting_cdma_get_password (s_cdma);
-		}
+modem_stage1 (NMDeviceBt *self, NMModem *modem, NMDeviceStateReason *reason)
+{
+	NMActRequest *req;
+	NMActStageReturn ret;
+
+	g_return_val_if_fail (reason != NULL, FALSE);
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_assert (req);
+
+	ret = nm_modem_act_stage1_prepare (modem, req, reason);
+	switch (ret) {
+	case NM_ACT_STAGE_RETURN_POSTPONE:
+	case NM_ACT_STAGE_RETURN_SUCCESS:
+		/* Success, wait for the 'prepare-result' signal */
+		return TRUE;
+	case NM_ACT_STAGE_RETURN_FAILURE:
+	default:
+		break;
 	}
 
-	return (s_cdma || s_gsm) ? TRUE : FALSE;
+	return FALSE;
 }
 
-
 static void
 real_connection_secrets_updated (NMDevice *device,
                                  NMConnection *connection,
@@ -369,111 +415,181 @@ real_connection_secrets_updated (NMDevice *device,
 	NMDeviceBt *self = NM_DEVICE_BT (device);
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
 	NMActRequest *req;
-	const char *username = NULL, *password = NULL;
-	gboolean success = FALSE;
-
-	if (caller != SECRETS_CALLER_PPP)
-		return;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
-	g_return_if_fail (priv->ppp_manager);
+	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (device)));
 
 	req = nm_device_get_act_request (device);
 	g_assert (req);
 
-	success = get_ppp_credentials (nm_act_request_get_connection (req),
-	                               &username,
-	                               &password);
-	if (success) {
-		nm_ppp_manager_update_secrets (priv->ppp_manager,
-		                               nm_device_get_ip_iface (device),
-		                               username ? username : "",
-		                               password ? password : "",
-		                               NULL);
+	if (!nm_modem_connection_secrets_updated (priv->modem,
+                                              req,
+                                              connection,
+                                              updated_settings,
+                                              caller)) {
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
 		return;
 	}
 
-	/* Shouldn't ever happen */
-	nm_ppp_manager_update_secrets (priv->ppp_manager,
-	                               nm_device_get_ip_iface (device),
-	                               NULL,
-	                               NULL,
-	                               "missing GSM/CDMA setting; no secrets could be found.");
+	/* PPP handles stuff itself... */
+	if (caller == SECRETS_CALLER_PPP)
+		return;
+
+	/* Otherwise, on success for GSM/CDMA secrets we need to schedule modem stage1 again */
+	g_return_if_fail (nm_device_get_state (device) == NM_DEVICE_STATE_NEED_AUTH);
+	if (!modem_stage1 (self, priv->modem, &reason))
+		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, reason);
 }
 
-static NMActStageReturn
-ppp_stage3_start (NMDevice *device, NMDeviceStateReason *reason)
+/*****************************************************************************/
+
+gboolean
+nm_device_bt_modem_added (NMDeviceBt *self,
+                          NMModem *modem,
+                          const char *driver)
 {
-	NMDeviceBt *self = NM_DEVICE_BT (device);
-	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
-	NMActRequest *req;
-	const char *ppp_name = NULL;
-	GError *err = NULL;
-	NMActStageReturn ret;
-	gboolean success;
+	NMDeviceBtPrivate *priv;
+	const char *modem_iface;
+	char *base;
+	NMDeviceState state;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DEVICE_BT (self), FALSE);
+	g_return_val_if_fail (modem != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM (modem), FALSE);
 
-	success = get_ppp_credentials (nm_act_request_get_connection (req),
-	                               &ppp_name,
-	                               NULL);
-	if (!success) {
-		// FIXME: set reason to something plausible
-		return NM_ACT_STAGE_RETURN_FAILURE;
+	priv = NM_DEVICE_BT_GET_PRIVATE (self);
+	modem_iface = nm_modem_get_iface (modem);
+	g_return_val_if_fail (modem_iface != NULL, FALSE);
+
+	if (!priv->rfcomm_iface)
+		return FALSE;
+
+	base = g_path_get_basename (priv->rfcomm_iface);
+	if (strcmp (base, modem_iface)) {
+		g_free (base);
+		return FALSE;
 	}
+	g_free (base);
 
-	priv->ppp_manager = nm_ppp_manager_new (priv->rfcomm_iface);
-	if (nm_ppp_manager_start (priv->ppp_manager, req, ppp_name, 20, &err)) {
-		g_signal_connect (priv->ppp_manager, "state-changed",
-						  G_CALLBACK (ppp_state_changed),
-						  device);
-		g_signal_connect (priv->ppp_manager, "ip4-config",
-						  G_CALLBACK (ppp_ip4_config),
-						  device);
-		g_signal_connect (priv->ppp_manager, "stats",
-						  G_CALLBACK (ppp_stats),
-						  device);
-
-		ret = NM_ACT_STAGE_RETURN_POSTPONE;
-	} else {
-		nm_warning ("%s", err->message);
-		g_error_free (err);
+	/* Got the modem */
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+
+	/* Can only accept the modem in stage2, but since the interface matched
+	 * what we were expecting, don't let anything else claim the modem either.
+	 */
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
+	if (state != NM_DEVICE_STATE_CONFIG) {
+		nm_log_warn (LOGD_BT | LOGD_MB,
+		             "(%s): modem found but device not in correct state (%d)",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             nm_device_get_state (NM_DEVICE (self)));
+		return TRUE;
+	}
 
-		g_object_unref (priv->ppp_manager);
-		priv->ppp_manager = NULL;
+	nm_log_info (LOGD_BT | LOGD_MB,
+	             "Activation (%s/bluetooth) Stage 2 of 5 (Device Configure) modem found.",
+	             nm_device_get_iface (NM_DEVICE (self)));
 
-		*reason = NM_DEVICE_STATE_REASON_PPP_START_FAILED;
-		ret = NM_ACT_STAGE_RETURN_FAILURE;
+	if (priv->modem) {
+		g_warn_if_reached ();
+		g_object_unref (priv->modem);
 	}
 
-	return ret;
+	priv->modem = g_object_ref (modem);
+	g_signal_connect (modem, NM_MODEM_PPP_STATS, G_CALLBACK (ppp_stats), self);
+	g_signal_connect (modem, NM_MODEM_PPP_FAILED, G_CALLBACK (ppp_failed), self);
+	g_signal_connect (modem, NM_MODEM_PREPARE_RESULT, G_CALLBACK (modem_prepare_result), self);
+	g_signal_connect (modem, NM_MODEM_IP4_CONFIG_RESULT, G_CALLBACK (modem_ip4_config_result), self);
+	g_signal_connect (modem, NM_MODEM_NEED_AUTH, G_CALLBACK (modem_need_auth), self);
+
+	/* Kick off the modem connection */
+	if (!modem_stage1 (self, modem, &reason))
+		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, reason);
+
+	return TRUE;
 }
 
-static NMActStageReturn
-ppp_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
+gboolean
+nm_device_bt_modem_removed (NMDeviceBt *self, NMModem *modem)
 {
-	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
-	NMConnection *connection;
-	NMSettingIP4Config *s_ip4;
+	NMDeviceBtPrivate *priv;
+	NMDeviceState state;
 
-	*config = priv->pending_ip4_config;
-	priv->pending_ip4_config = NULL;
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DEVICE_BT (self), FALSE);
+	g_return_val_if_fail (modem != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM (modem), FALSE);
 
-	/* Merge user-defined overrides into the IP4Config to be applied */
-	connection = nm_act_request_get_connection (nm_device_get_act_request (device));
-	g_assert (connection);
-	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-	nm_utils_merge_ip4_config (*config, s_ip4);
+	priv = NM_DEVICE_BT_GET_PRIVATE (self);
+
+	if (modem != priv->modem)
+		return FALSE;
 
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+	state = nm_device_get_state (NM_DEVICE (self));
+	nm_modem_device_state_changed (priv->modem,
+	                               NM_DEVICE_STATE_DISCONNECTED,
+	                               state,
+	                               NM_DEVICE_STATE_REASON_USER_REQUESTED);
+
+	g_object_unref (priv->modem);
+	priv->modem = NULL;
+	return TRUE;
 }
 
-/*****************************************************************************/
+static gboolean
+modem_find_timeout (gpointer user_data)
+{
+	NMDeviceBt *self = NM_DEVICE_BT (user_data);
+
+	NM_DEVICE_BT_GET_PRIVATE (self)->timeout_id = 0;
+	nm_device_state_changed (NM_DEVICE (self),
+	                         NM_DEVICE_STATE_FAILED,
+	                         NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND);
+	return FALSE;
+}
 
 static void
-nm_device_bt_connect_cb (DBusGProxy       *proxy,
-                         DBusGProxyCall   *call_id,
-                         void             *user_data)
+check_connect_continue (NMDeviceBt *self)
+{
+	NMDevice *device = NM_DEVICE (self);
+	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
+	gboolean pan = (priv->bt_type == NM_BT_CAPABILITY_NAP);
+	gboolean dun = (priv->bt_type == NM_BT_CAPABILITY_DUN);
+
+	if (!priv->connected || !priv->have_iface)
+		return;
+
+	nm_log_info (LOGD_BT, "Activation (%s %s/bluetooth) Stage 2 of 5 (Device Configure) "
+	             "successful.  Will connect via %s.",
+	             nm_device_get_iface (device),
+	             nm_device_get_ip_iface (device),
+	             dun ? "DUN" : (pan ? "PAN" : "unknown"));
+
+	if (pan) {
+		/* Bluez says we're connected now.  Start IP config. */
+		nm_device_activate_schedule_stage3_ip_config_start (device);
+	} else if (dun) {
+		/* Wait for ModemManager to find the modem */
+		if (priv->timeout_id)
+			g_source_remove (priv->timeout_id);
+		priv->timeout_id = g_timeout_add_seconds (20, modem_find_timeout, self);
+
+		nm_log_info (LOGD_BT | LOGD_MB, "Activation (%s/bluetooth) Stage 2 of 5 (Device Configure) "
+		             "waiting for modem to appear.",
+		             nm_device_get_iface (device));
+	} else
+		g_assert_not_reached ();
+}
+
+static void
+bluez_connect_cb (DBusGProxy *proxy,
+                  DBusGProxyCall *call_id,
+                  void *user_data)
 {
 	NMDeviceBt *self = NM_DEVICE_BT (user_data);
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
@@ -481,22 +597,24 @@ nm_device_bt_connect_cb (DBusGProxy       *proxy,
 	char *device;
 
 	if (dbus_g_proxy_end_call (proxy, call_id, &error,
-				   G_TYPE_STRING, &device,
-				   G_TYPE_INVALID) == FALSE) {
-		nm_warning ("Error connecting with bluez: %s",
-		            error && error->message ? error->message : "(unknown)");
+	                           G_TYPE_STRING, &device,
+	                           G_TYPE_INVALID) == FALSE) {
+		nm_log_warn (LOGD_BT, "Error connecting with bluez: %s",
+		             error && error->message ? error->message : "(unknown)");
 		g_clear_error (&error);
 
-		// FIXME: get a better reason code
-		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
+		nm_device_state_changed (NM_DEVICE (self),
+		                         NM_DEVICE_STATE_FAILED,
+		                         NM_DEVICE_STATE_REASON_BT_FAILED);
 		return;
 	}
 
 	if (!device || !strlen (device)) {
-		nm_warning ("Invalid network device returned by bluez");
+		nm_log_warn (LOGD_BT, "Invalid network device returned by bluez");
 
-		// FIXME: get a better reason code
-		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
+		nm_device_state_changed (NM_DEVICE (self),
+		                         NM_DEVICE_STATE_FAILED,
+		                         NM_DEVICE_STATE_REASON_BT_FAILED);
 	}
 
 	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
@@ -508,6 +626,8 @@ nm_device_bt_connect_cb (DBusGProxy       *proxy,
 	}
 
 	/* Stage 3 gets scheduled when Bluez says we're connected */
+	priv->have_iface = TRUE;
+	check_connect_continue (self);
 }
 
 static void
@@ -528,18 +648,9 @@ bluez_property_changed (DBusGProxy *proxy,
 	state = nm_device_get_state (device);
 	connected = g_value_get_boolean (value);
 	if (connected) {
-		/* Bluez says we're connected now.  Start IP config. */
-
 		if (state == NM_DEVICE_STATE_CONFIG) {
-			gboolean pan = (priv->bt_type == NM_BT_CAPABILITY_NAP);
-			gboolean dun = (priv->bt_type == NM_BT_CAPABILITY_DUN);
-
-			nm_info ("Activation (%s/bluetooth) Stage 2 of 5 (Device Configure) "
-			         "successful.  Connected via %s.",
-			         nm_device_get_iface (device),
-			         dun ? "DUN" : (pan ? "PAN" : "unknown"));
-
-			nm_device_activate_schedule_stage3_ip_config_start (device);
+			priv->connected = TRUE;
+			check_connect_continue (self);
 		}
 	} else {
 		gboolean fail = FALSE;
@@ -547,19 +658,35 @@ bluez_property_changed (DBusGProxy *proxy,
 		/* Bluez says we're disconnected from the device.  Suck. */
 
 		if (nm_device_is_activating (device)) {
-			nm_info ("Activation (%s/bluetooth): bluetooth link disconnected.",
-			         nm_device_get_iface (device));
+			nm_log_info (LOGD_BT,
+			             "Activation (%s/bluetooth): bluetooth link disconnected.",
+			             nm_device_get_iface (device));
 			fail = TRUE;
 		} else if (state == NM_DEVICE_STATE_ACTIVATED) {
-			nm_info ("%s: bluetooth link disconnected.", nm_device_get_iface (device));
+			nm_log_info (LOGD_BT, "(%s): bluetooth link disconnected.",
+			             nm_device_get_iface (device));
 			fail = TRUE;
 		}
 
-		if (fail)
+		if (fail) {
 			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_CARRIER);
+			priv->connected = FALSE;
+		}
 	}
 }
 
+static gboolean
+bt_connect_timeout (gpointer user_data)
+{
+	NMDeviceBt *self = NM_DEVICE_BT (user_data);
+
+	NM_DEVICE_BT_GET_PRIVATE (self)->timeout_id = 0;
+	nm_device_state_changed (NM_DEVICE (self),
+	                         NM_DEVICE_STATE_FAILED,
+	                         NM_DEVICE_STATE_REASON_BT_FAILED);
+	return FALSE;
+}
+
 static NMActStageReturn
 real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
 {
@@ -567,6 +694,7 @@ real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
 	NMActRequest *req;
 	NMDBusManager *dbus_mgr;
 	DBusGConnection *g_connection;
+	gboolean dun = FALSE;
 
 	req = nm_device_get_act_request (device);
 	g_assert (req);
@@ -581,53 +709,54 @@ real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
 	g_connection = nm_dbus_manager_get_connection (dbus_mgr);
 	g_object_unref (dbus_mgr);
 
-	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
-		priv->type_proxy = dbus_g_proxy_new_for_name (g_connection,
-							      BLUEZ_SERVICE,
-							      nm_device_get_udi (device),
-							      BLUEZ_SERIAL_INTERFACE);
-		if (!priv->type_proxy) {
-			// FIXME: set a reason code
-			return NM_ACT_STAGE_RETURN_FAILURE;
-		}
-
-		dbus_g_proxy_begin_call_with_timeout (priv->type_proxy, "Connect",
-		                                      nm_device_bt_connect_cb,
-		                                      device,
-		                                      NULL,
-		                                      20000,
-		                                      G_TYPE_STRING, BLUETOOTH_DUN_UUID,
-		                                      G_TYPE_INVALID);
-	} else if (priv->bt_type == NM_BT_CAPABILITY_NAP) {
-		priv->type_proxy = dbus_g_proxy_new_for_name (g_connection,
-							      BLUEZ_SERVICE,
-							      nm_device_get_udi (device),
-							      BLUEZ_NETWORK_INTERFACE);
-		if (!priv->type_proxy) {
-			// FIXME: set a reason code
-			return NM_ACT_STAGE_RETURN_FAILURE;
-		}
-
-		dbus_g_proxy_begin_call_with_timeout (priv->type_proxy, "Connect",
-		                                      nm_device_bt_connect_cb,
-		                                      device,
-		                                      NULL,
-		                                      20000,
-		                                      G_TYPE_STRING, BLUETOOTH_NAP_UUID,
-		                                      G_TYPE_INVALID);
-	} else
+	if (priv->bt_type == NM_BT_CAPABILITY_DUN)
+		dun = TRUE;
+	else if (priv->bt_type == NM_BT_CAPABILITY_NAP)
+		dun = FALSE;
+	else
 		g_assert_not_reached ();
 
+	priv->dev_proxy = dbus_g_proxy_new_for_name (g_connection,
+	                                               BLUEZ_SERVICE,
+	                                               nm_device_get_udi (device),
+	                                               BLUEZ_DEVICE_INTERFACE);
+	if (!priv->dev_proxy) {
+		// FIXME: set a reason code
+		return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
 	/* Watch for BT device property changes */
 	dbus_g_object_register_marshaller (_nm_marshal_VOID__STRING_BOXED,
 	                                   G_TYPE_NONE,
 	                                   G_TYPE_STRING, G_TYPE_VALUE,
 	                                   G_TYPE_INVALID);
-	dbus_g_proxy_add_signal (priv->type_proxy, "PropertyChanged",
+	dbus_g_proxy_add_signal (priv->dev_proxy, "PropertyChanged",
 	                         G_TYPE_STRING, G_TYPE_VALUE, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (priv->type_proxy, "PropertyChanged",
+	dbus_g_proxy_connect_signal (priv->dev_proxy, "PropertyChanged",
 	                             G_CALLBACK (bluez_property_changed), device, NULL);
 
+	priv->type_proxy = dbus_g_proxy_new_for_name (g_connection,
+	                                              BLUEZ_SERVICE,
+	                                              nm_device_get_udi (device),
+	                                              dun ? BLUEZ_SERIAL_INTERFACE : BLUEZ_NETWORK_INTERFACE);
+	if (!priv->type_proxy) {
+		// FIXME: set a reason code
+		return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	/* Connect to the BT device */
+	dbus_g_proxy_begin_call_with_timeout (priv->type_proxy, "Connect",
+	                                      bluez_connect_cb,
+	                                      device,
+	                                      NULL,
+	                                      20000,
+	                                      G_TYPE_STRING, dun ? BLUETOOTH_DUN_UUID : BLUETOOTH_NAP_UUID,
+	                                      G_TYPE_INVALID);
+
+	if (priv->timeout_id)
+		g_source_remove (priv->timeout_id);
+	priv->timeout_id = g_timeout_add_seconds (30, bt_connect_timeout, device);
+
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
@@ -637,9 +766,12 @@ real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
 	NMActStageReturn ret;
 
-	if (priv->bt_type == NM_BT_CAPABILITY_DUN)
-		ret = ppp_stage3_start (device, reason);
-	else
+	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
+		ret = nm_modem_stage3_ip4_config_start (NM_DEVICE_BT_GET_PRIVATE (device)->modem,
+		                                        device,
+		                                        NM_DEVICE_CLASS (nm_device_bt_parent_class),
+		                                        reason);
+	} else
 		ret = NM_DEVICE_CLASS (nm_device_bt_parent_class)->act_stage3_ip4_config_start (device, reason);
 
 	return ret;
@@ -653,9 +785,13 @@ real_act_stage4_get_ip4_config (NMDevice *device,
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
 	NMActStageReturn ret;
 
-	if (priv->bt_type == NM_BT_CAPABILITY_DUN)
-		ret = ppp_stage4 (device, config, reason);
-	else
+	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
+		ret = nm_modem_stage4_get_ip4_config (NM_DEVICE_BT_GET_PRIVATE (device)->modem,
+		                                      device,
+		                                      NM_DEVICE_CLASS (nm_device_bt_parent_class),
+		                                      config,
+		                                      reason);
+	} else
 		ret = NM_DEVICE_CLASS (nm_device_bt_parent_class)->act_stage4_get_ip4_config (device, config, reason);
 
 	return ret;
@@ -666,17 +802,23 @@ real_deactivate_quickly (NMDevice *device)
 {
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
 
-	if (priv->pending_ip4_config) {
-		g_object_unref (priv->pending_ip4_config);
-		priv->pending_ip4_config = NULL;
-	}
-
-	priv->in_bytes = priv->out_bytes = 0;
+	priv->have_iface = FALSE;
+	priv->connected = FALSE;
 
 	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
-		if (priv->ppp_manager) {
-			g_object_unref (priv->ppp_manager);
-			priv->ppp_manager = NULL;
+
+		if (priv->modem) {
+			nm_modem_deactivate_quickly (priv->modem, device);
+
+			/* Since we're killing the Modem object before it'll get the
+			 * state change signal, simulate the state change here.
+			 */
+			nm_modem_device_state_changed (priv->modem,
+			                               NM_DEVICE_STATE_DISCONNECTED,
+			                               NM_DEVICE_STATE_ACTIVATED,
+			                               NM_DEVICE_STATE_REASON_USER_REQUESTED);
+			g_object_unref (priv->modem);
+			priv->modem = NULL;
 		}
 
 		if (priv->type_proxy) {
@@ -700,6 +842,16 @@ real_deactivate_quickly (NMDevice *device)
 		}
 	}
 
+	if (priv->dev_proxy) {
+		g_object_unref (priv->dev_proxy);
+		priv->dev_proxy = NULL;
+	}
+
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+
 	priv->bt_type = NM_BT_CAPABILITY_NONE;
 
 	g_free (priv->rfcomm_iface);
@@ -709,6 +861,39 @@ real_deactivate_quickly (NMDevice *device)
 		NM_DEVICE_CLASS (nm_device_bt_parent_class)->deactivate_quickly (device);
 }
 
+/*****************************************************************************/
+
+NMDevice *
+nm_device_bt_new (const char *udi,
+                  const char *bdaddr,
+                  const char *name,
+                  guint32 capabilities,
+                  gboolean managed)
+{
+	NMDevice *device;
+
+	g_return_val_if_fail (udi != NULL, NULL);
+	g_return_val_if_fail (bdaddr != NULL, NULL);
+	g_return_val_if_fail (name != NULL, NULL);
+	g_return_val_if_fail (capabilities != NM_BT_CAPABILITY_NONE, NULL);
+
+	device = (NMDevice *) g_object_new (NM_TYPE_DEVICE_BT,
+	                                    NM_DEVICE_INTERFACE_UDI, udi,
+	                                    NM_DEVICE_INTERFACE_IFACE, bdaddr,
+	                                    NM_DEVICE_INTERFACE_DRIVER, "bluez",
+	                                    NM_DEVICE_BT_HW_ADDRESS, bdaddr,
+	                                    NM_DEVICE_BT_NAME, name,
+	                                    NM_DEVICE_BT_CAPABILITIES, capabilities,
+	                                    NM_DEVICE_INTERFACE_MANAGED, managed,
+	                                    NM_DEVICE_INTERFACE_TYPE_DESC, "Bluetooth",
+	                                    NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_BT,
+	                                    NULL);
+	if (device)
+		g_signal_connect (device, "state-changed", G_CALLBACK (device_state_changed), device);
+
+	return device;
+}
+
 static void
 nm_device_bt_init (NMDeviceBt *self)
 {
@@ -766,9 +951,21 @@ finalize (GObject *object)
 {
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (object);
 
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+
 	if (priv->type_proxy)
 		g_object_unref (priv->type_proxy);
 
+	if (priv->dev_proxy)
+		g_object_unref (priv->dev_proxy);
+
+	if (priv->modem)
+		g_object_unref (priv->modem);
+
+	g_free (priv->rfcomm_iface);
 	g_free (priv->bdaddr);
 	g_free (priv->name);
 
diff --git a/src/nm-device-bt.h b/src/nm-device-bt.h
index 67ef6f5..d3187d7 100644
--- a/src/nm-device-bt.h
+++ b/src/nm-device-bt.h
@@ -22,6 +22,7 @@
 #define NM_DEVICE_BT_H
 
 #include <nm-device.h>
+#include "nm-modem.h"
 
 G_BEGIN_DECLS
 
@@ -60,6 +61,12 @@ guint32 nm_device_bt_get_capabilities (NMDeviceBt *device);
 
 const char *nm_device_bt_get_hw_address (NMDeviceBt *device);
 
+gboolean nm_device_bt_modem_added (NMDeviceBt *device,
+                                   NMModem *modem,
+                                   const char *driver);
+
+gboolean nm_device_bt_modem_removed (NMDeviceBt *device, NMModem *modem);
+
 G_END_DECLS
 
 #endif /* NM_GSM_DEVICE_H */
diff --git a/src/nm-device-cdma.c b/src/nm-device-cdma.c
new file mode 100644
index 0000000..45771f4
--- /dev/null
+++ b/src/nm-device-cdma.c
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+
+#include "nm-modem-cdma.h"
+#include "nm-device-interface.h"
+#include "nm-device-cdma.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-rfkill.h"
+
+#include "nm-device-cdma-glue.h"
+
+G_DEFINE_TYPE (NMDeviceCdma, nm_device_cdma, NM_TYPE_DEVICE_MODEM)
+
+enum {
+	PROPERTIES_CHANGED,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+NMDevice *
+nm_device_cdma_new (NMModemCdma *modem, const char *driver)
+{
+	g_return_val_if_fail (modem != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM_CDMA (modem), NULL);
+	g_return_val_if_fail (driver != NULL, NULL);
+
+	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_CDMA,
+	                                  NM_DEVICE_INTERFACE_UDI, nm_modem_get_path (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_IFACE, nm_modem_get_iface (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
+	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "CDMA",
+	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_CDMA,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE, RFKILL_TYPE_WWAN,
+	                                  NM_DEVICE_MODEM_MODEM, modem,
+	                                  NULL);
+}
+
+static void
+nm_device_cdma_init (NMDeviceCdma *self)
+{
+}
+
+static void
+nm_device_cdma_class_init (NMDeviceCdmaClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+		                                  G_STRUCT_OFFSET (NMDeviceCdmaClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
+	                                 &dbus_glib_nm_device_cdma_object_info);
+}
+
diff --git a/src/nm-device-cdma.h b/src/nm-device-cdma.h
new file mode 100644
index 0000000..f0bf345
--- /dev/null
+++ b/src/nm-device-cdma.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_CDMA_H
+#define NM_DEVICE_CDMA_H
+
+#include "nm-device-modem.h"
+#include "nm-modem-cdma.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_CDMA            (nm_device_cdma_get_type ())
+#define NM_DEVICE_CDMA(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_CDMA, NMDeviceCdma))
+#define NM_DEVICE_CDMA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_DEVICE_CDMA, NMDeviceCdmaClass))
+#define NM_IS_DEVICE_CDMA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_CDMA))
+#define NM_IS_DEVICE_CDMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_DEVICE_CDMA))
+#define NM_DEVICE_CDMA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_DEVICE_CDMA, NMDeviceCdmaClass))
+
+typedef struct {
+	NMDeviceModem parent;
+} NMDeviceCdma;
+
+typedef struct {
+	NMDeviceModemClass parent;
+
+	/* Signals */
+	void (*signal_quality) (NMDeviceCdma *self, guint32 quality);
+
+	void (*properties_changed) (NMDeviceCdma *self, GHashTable *properties);
+} NMDeviceCdmaClass;
+
+GType nm_device_cdma_get_type (void);
+
+NMDevice *nm_device_cdma_new (NMModemCdma *modem, const char *driver);
+
+G_END_DECLS
+
+#endif /* NM_DEVICE_CDMA_H */
diff --git a/src/nm-device-ethernet.c b/src/nm-device-ethernet.c
index 037d603..f4581e9 100644
--- a/src/nm-device-ethernet.c
+++ b/src/nm-device-ethernet.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -45,13 +45,13 @@
 #include "nm-supplicant-config.h"
 #include "nm-netlink.h"
 #include "nm-netlink-monitor.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-wired.h"
 #include "nm-setting-8021x.h"
 #include "nm-setting-pppoe.h"
 #include "ppp-manager/nm-ppp-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-dhcp-manager.h"
 
@@ -227,11 +227,11 @@ set_carrier (NMDeviceEthernet *self,
 	g_object_notify (G_OBJECT (self), NM_DEVICE_ETHERNET_CARRIER);
 
 	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-	nm_info ("(%s): carrier now %s (device state %d%s)",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         carrier ? "ON" : "OFF",
-	         state,
-	         defer_action ? ", deferring action for 4 seconds" : "");
+	nm_log_info (LOGD_HW | LOGD_ETHER, "(%s): carrier now %s (device state %d%s)",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             carrier ? "ON" : "OFF",
+	             state,
+	             defer_action ? ", deferring action for 4 seconds" : "");
 
 	if (defer_action)
 		priv->carrier_action_defer_id = g_timeout_add_seconds (4, carrier_action_defer_cb, self);
@@ -311,6 +311,9 @@ constructor (GType type,
 	self = NM_DEVICE (object);
 	priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_HW | LOGD_OLPC_MESH, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (self)), priv->ifindex);
+
 	caps = nm_device_get_capabilities (self);
 	if (caps & NM_DEVICE_CAP_CARRIER_DETECT) {
 		GError *error = NULL;
@@ -331,30 +334,36 @@ constructor (GType type,
 		                                        priv->ifindex,
 		                                        &ifflags,
 		                                        &error)) {
-			nm_warning ("couldn't get initial carrier state: (%d) %s",
-			            error ? error->code : -1,
-			            (error && error->message) ? error->message : "unknown");
+			nm_log_warn (LOGD_HW | LOGD_ETHER,
+			             "(%s): couldn't get initial carrier state: (%d) %s",
+			             nm_device_get_iface (NM_DEVICE (self)),
+			             error ? error->code : -1,
+			             (error && error->message) ? error->message : "unknown");
 			g_clear_error (&error);
 		} else
 			priv->carrier = !!(ifflags & IFF_LOWER_UP);
 
-		nm_info ("(%s): carrier is %s",
-		         nm_device_get_iface (NM_DEVICE (self)),
-		         priv->carrier ? "ON" : "OFF");
+		nm_log_info (LOGD_HW | LOGD_ETHER,
+		             "(%s): carrier is %s",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             priv->carrier ? "ON" : "OFF");
 
 		/* Request link state again just in case an error occurred getting the
 		 * initial link state.
 		 */
 		if (!nm_netlink_monitor_request_status (priv->monitor, &error)) {
-			nm_warning ("couldn't request carrier state: (%d) %s",
-			            error ? error->code : -1,
-			            (error && error->message) ? error->message : "unknown");
+			nm_log_warn (LOGD_HW | LOGD_ETHER,
+			             "(%s): couldn't request carrier state: (%d) %s",
+			             nm_device_get_iface (NM_DEVICE (self)),
+			             error ? error->code : -1,
+			             (error && error->message) ? error->message : "unknown");
 			g_clear_error (&error);
 		}
 	} else {
-		nm_info ("(%s): driver '%s' does not support carrier detection.",
-		         nm_device_get_iface (self),
-		         nm_device_get_driver (self));
+		nm_log_info (LOGD_HW | LOGD_ETHER,
+		             "(%s): driver '%s' does not support carrier detection.",
+		             nm_device_get_iface (self),
+		             nm_device_get_driver (self));
 		priv->carrier = TRUE;
 	}
 
@@ -473,7 +482,7 @@ nm_device_ethernet_get_speed (NMDeviceEthernet *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_warn (LOGD_HW, "couldn't open control socket.");
 		return 0;
 	}
 
@@ -508,15 +517,16 @@ real_update_hw_address (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_warn (LOGD_HW, "couldn't open control socket.");
 		return;
 	}
 
 	memset (&req, 0, sizeof (struct ifreq));
 	strncpy (req.ifr_name, nm_device_get_iface (dev), IFNAMSIZ);
 	if (ioctl (fd, SIOCGIFHWADDR, &req) < 0) {
-		nm_warning ("%s: (%s) error getting hardware address: %d",
-		            __func__, nm_device_get_iface (dev), errno);
+		nm_log_err (LOGD_HW | LOGD_ETHER,
+		            "(%s) error getting hardware address: %d",
+		            nm_device_get_iface (dev), errno);
 		goto out;
 	}
 
@@ -670,7 +680,8 @@ real_connection_secrets_updated (NMDevice *dev,
 		if (!strcmp (setting_name, NM_SETTING_802_1X_SETTING_NAME)) {
 			valid = TRUE;
 		} else {
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
+			nm_log_warn (LOGD_DEVICE, "Ignoring updated secrets for setting '%s'.",
+			             setting_name);
 		}
 	}
 
@@ -827,8 +838,10 @@ link_timeout_cb (gpointer user_data)
 	if (!setting_name)
 		goto time_out;
 
-	nm_info ("Activation (%s/wired): disconnected during authentication,"
-	         " asking for new key.", nm_device_get_iface (dev));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "Activation (%s/wired): disconnected during authentication,"
+	             " asking for new key.",
+	             nm_device_get_iface (dev));
 	supplicant_interface_release (self);
 
 	nm_device_state_changed (dev, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
@@ -842,7 +855,8 @@ link_timeout_cb (gpointer user_data)
 	return FALSE;
 
 time_out:
-	nm_info ("%s: link timed out.", nm_device_get_iface (dev));
+	nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s): link timed out.", nm_device_get_iface (dev));
 	nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
 
 	return FALSE;
@@ -863,7 +877,7 @@ schedule_state_handler (NMDeviceEthernet *self,
 
 	task = g_slice_new0 (SupplicantStateTask);
 	if (!task) {
-		nm_warning ("Not enough memory to process supplicant manager state change.");
+		nm_log_err (LOGD_DEVICE, "Not enough memory to process supplicant manager state change.");
 		return FALSE;
 	}
 
@@ -906,10 +920,11 @@ supplicant_mgr_state_cb (NMSupplicantInterface * iface,
                          guint32 old_state,
                          gpointer user_data)
 {
-	nm_info ("(%s): supplicant manager state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (user_data)),
-	         nm_supplicant_manager_state_to_string (old_state),
-	         nm_supplicant_manager_state_to_string (new_state));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s): supplicant manager state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (user_data)),
+	             nm_supplicant_manager_state_to_string (old_state),
+	             nm_supplicant_manager_state_to_string (new_state));
 
 	schedule_state_handler (NM_DEVICE_ETHERNET (user_data),
 	                        supplicant_mgr_state_cb_handler,
@@ -936,7 +951,7 @@ build_supplicant_config (NMDeviceEthernet *self)
 
 	security = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));
 	if (!nm_supplicant_config_add_setting_8021x (config, security, con_path, TRUE)) {
-		nm_warning ("Couldn't add 802.1X security setting to supplicant config.");
+		nm_log_warn (LOGD_DEVICE, "Couldn't add 802.1X security setting to supplicant config.");
 		g_object_unref (config);
 		config = NULL;
 	}
@@ -962,11 +977,17 @@ supplicant_iface_state_cb_handler (gpointer user_data)
 			success = nm_supplicant_interface_set_config (priv->supplicant.iface, config);
 			g_object_unref (config);
 
-			if (!success)
-				nm_warning ("Activation (%s/wired): couldn't send security "
-						  "configuration to the supplicant.", iface);
-		} else
-			nm_warning ("Activation (%s/wired): couldn't build security configuration.", iface);
+			if (!success) {
+				nm_log_err (LOGD_DEVICE | LOGD_ETHER,
+				            "Activation (%s/wired): couldn't send security "
+						    "configuration to the supplicant.",
+						    iface);
+			}
+		} else {
+			nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+			             "Activation (%s/wired): couldn't build security configuration.",
+			             iface);
+		}
 
 		if (!success)
 			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED);
@@ -990,10 +1011,11 @@ supplicant_iface_state_cb (NMSupplicantInterface * iface,
                            gpointer user_data)
 {
 
-	nm_info ("(%s): supplicant interface state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (user_data)),
-	         nm_supplicant_interface_state_to_string (old_state),
-	         nm_supplicant_interface_state_to_string (new_state));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s): supplicant interface state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (user_data)),
+	             nm_supplicant_interface_state_to_string (old_state),
+	             nm_supplicant_interface_state_to_string (new_state));
 
 	schedule_state_handler (NM_DEVICE_ETHERNET (user_data),
 	                        supplicant_iface_state_cb_handler,
@@ -1016,8 +1038,9 @@ supplicant_iface_connection_state_cb_handler (gpointer user_data)
 		 * schedule the next activation stage.
 		 */
 		if (nm_device_get_state (dev) == NM_DEVICE_STATE_CONFIG) {
-			nm_info ("Activation (%s/wired) Stage 2 of 5 (Device Configure) successful.",
-				    nm_device_get_iface (dev));
+			nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+			             "Activation (%s/wired) Stage 2 of 5 (Device Configure) successful.",
+				         nm_device_get_iface (dev));
 			nm_device_activate_schedule_stage3_ip_config_start (dev);
 		}
 	} else if (task->new_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED) {
@@ -1040,10 +1063,11 @@ supplicant_iface_connection_state_cb (NMSupplicantInterface * iface,
                                       guint32 old_state,
                                       gpointer user_data)
 {
-	nm_info ("(%s) supplicant connection state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (user_data)),
-	         nm_supplicant_interface_connection_state_to_string (old_state),
-	         nm_supplicant_interface_connection_state_to_string (new_state));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s) supplicant connection state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (user_data)),
+	             nm_supplicant_interface_connection_state_to_string (old_state),
+	             nm_supplicant_interface_connection_state_to_string (new_state));
 
 	schedule_state_handler (NM_DEVICE_ETHERNET (user_data),
 	                        supplicant_iface_connection_state_cb_handler,
@@ -1075,8 +1099,9 @@ supplicant_iface_connection_error_cb (NMSupplicantInterface *iface,
 	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
 	guint id;
 
-	nm_info ("Activation (%s/wired): association request to the supplicant failed: %s - %s",
-	         nm_device_get_iface (NM_DEVICE (self)), name, message);
+	nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+	             "Activation (%s/wired): association request to the supplicant failed: %s - %s",
+	             nm_device_get_iface (NM_DEVICE (self)), name, message);
 
 	if (priv->supplicant.iface_con_error_cb_id)
 		g_source_remove (priv->supplicant.iface_con_error_cb_id);
@@ -1120,8 +1145,9 @@ handle_auth_or_fail (NMDeviceEthernet *self,
 		                            NULL);
 
 		g_object_set_data (G_OBJECT (connection), WIRED_SECRETS_TRIES, GUINT_TO_POINTER (++tries));
-	} else
-		nm_warning ("Cleared secrets, but setting didn't need any secrets.");
+	} else {
+		nm_log_info (LOGD_DEVICE, "Cleared secrets, but setting didn't need any secrets.");
+	}
 
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
@@ -1140,15 +1166,17 @@ supplicant_connection_timeout_cb (gpointer user_data)
 	iface = nm_device_get_iface (device);
 
 	/* Authentication failed, encryption key is probably bad */
-	nm_info ("Activation (%s/wired): association took too long.", iface);
+	nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+	             "Activation (%s/wired): association took too long.", iface);
 
 	supplicant_interface_release (self);
 	req = nm_device_get_act_request (device);
 	g_assert (req);
 
-	if (handle_auth_or_fail (self, req, TRUE) == NM_ACT_STAGE_RETURN_POSTPONE)
-		nm_info ("Activation (%s/wired): asking for new secrets", iface);
-	else
+	if (handle_auth_or_fail (self, req, TRUE) == NM_ACT_STAGE_RETURN_POSTPONE) {
+		nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+		             "Activation (%s/wired): asking for new secrets", iface);
+	} else
 		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
 
 	return FALSE;
@@ -1165,7 +1193,9 @@ supplicant_interface_init (NMDeviceEthernet *self)
 	/* Create supplicant interface */
 	priv->supplicant.iface = nm_supplicant_manager_get_iface (priv->supplicant.mgr, iface, FALSE);
 	if (!priv->supplicant.iface) {
-		nm_warning ("Couldn't initialize supplicant interface for %s.", iface);
+		nm_log_err (LOGD_DEVICE | LOGD_ETHER,
+		            "Couldn't initialize supplicant interface for %s.",
+		            iface);
 		supplicant_interface_release (self);
 
 		return FALSE;
@@ -1213,7 +1243,7 @@ nm_8021x_stage2_config (NMDeviceEthernet *self, NMDeviceStateReason *reason)
 	connection = nm_act_request_get_connection (nm_device_get_act_request (NM_DEVICE (self)));
 	security = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));
 	if (!security) {
-		nm_warning ("Invalid or missing 802.1X security");
+		nm_log_err (LOGD_DEVICE, "Invalid or missing 802.1X security");
 		*reason = NM_DEVICE_STATE_REASON_CONFIG_FAILED;
 		return ret;
 	}
@@ -1226,15 +1256,17 @@ nm_8021x_stage2_config (NMDeviceEthernet *self, NMDeviceStateReason *reason)
 	if (setting_name) {
 		NMActRequest *req = nm_device_get_act_request (NM_DEVICE (self));
 
-		nm_info ("Activation (%s/wired): connection '%s' has security, but secrets are required.",
-				 iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+		             "Activation (%s/wired): connection '%s' has security, but secrets are required.",
+				     iface, nm_setting_connection_get_id (s_connection));
 
 		ret = handle_auth_or_fail (self, req, FALSE);
 		if (ret != NM_ACT_STAGE_RETURN_POSTPONE)
 			*reason = NM_DEVICE_STATE_REASON_NO_SECRETS;
 	} else {
-		nm_info ("Activation (%s/wired): connection '%s' requires no security. No secrets needed.",
-				 iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+		             "Activation (%s/wired): connection '%s' requires no security. No secrets needed.",
+				     iface, nm_setting_connection_get_id (s_connection));
 
 		if (supplicant_interface_init (self))
 			ret = NM_ACT_STAGE_RETURN_POSTPONE;
@@ -1311,8 +1343,8 @@ pppoe_stage3_ip4_config_start (NMDeviceEthernet *self, NMDeviceStateReason *reas
 					   self);
 		ret = NM_ACT_STAGE_RETURN_POSTPONE;
 	} else {
-		nm_warning ("(%s): PPPoE failed to start: %s",
-		            nm_device_get_iface (NM_DEVICE (self)), err->message);
+		nm_log_warn (LOGD_DEVICE, "(%s): PPPoE failed to start: %s",
+		             nm_device_get_iface (NM_DEVICE (self)), err->message);
 		g_error_free (err);
 
 		g_object_unref (priv->ppp_manager);
@@ -1608,9 +1640,9 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 
 	/* Get any saved leases that apply to this connection */
 	dhcp_mgr = nm_dhcp_manager_get ();
-	leases = nm_dhcp_manager_get_lease_ip4_config (dhcp_mgr,
-	                                               nm_device_get_iface (self),
-	                                               nm_setting_connection_get_uuid (s_con));
+	leases = nm_dhcp_manager_get_lease_config (dhcp_mgr,
+	                                           nm_device_get_iface (self),
+	                                           nm_setting_connection_get_uuid (s_con));
 	g_object_unref (dhcp_mgr);
 
 	method = nm_setting_ip4_config_get_method (s_ip4);
@@ -1880,7 +1912,7 @@ supports_ethtool_carrier_detect (NMDeviceEthernet *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_err (LOGD_HW, "couldn't open control socket.");
 		return FALSE;
 	}
 
@@ -1890,13 +1922,18 @@ supports_ethtool_carrier_detect (NMDeviceEthernet *self)
 	edata.cmd = ETHTOOL_GLINK;
 	ifr.ifr_data = (char *) &edata;
 
-	if (ioctl (fd, SIOCETHTOOL, &ifr) < 0)
+	errno = 0;
+	if (ioctl (fd, SIOCETHTOOL, &ifr) < 0) {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCETHTOOL failed: %d", errno);
 		goto out;
+	}
 
 	supports_ethtool = TRUE;
 
 out:
 	close (fd);
+	nm_log_dbg (LOGD_HW | LOGD_ETHER, "ethtool %s supported",
+	            supports_ethtool ? "is" : "not");
 	return supports_ethtool;
 }
 
@@ -1920,8 +1957,13 @@ mdio_read (NMDeviceEthernet *self, int fd, struct ifreq *ifr, int location)
 	mii = (struct mii_ioctl_data *) &ifr->ifr_ifru;
 	mii->reg_num = location;
 
-	if (ioctl (fd, SIOCGMIIREG, ifr) == 0)
+	errno = 0;
+	if (ioctl (fd, SIOCGMIIREG, ifr) == 0) {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCGMIIREG result 0x%X", mii->val_out);
 		val = mii->val_out;
+	} else {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCGMIIREG failed: %d", errno);
+	}
 
 	return val;
 }
@@ -1937,19 +1979,24 @@ supports_mii_carrier_detect (NMDeviceEthernet *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_err (LOGD_HW, "couldn't open control socket.");
 		return 0;
 	}
 
 	memset (&ifr, 0, sizeof (struct ifreq));
 	strncpy (ifr.ifr_name, nm_device_get_iface (NM_DEVICE (self)), IFNAMSIZ);
 
-	if (ioctl (fd, SIOCGMIIPHY, &ifr) < 0)
+	errno = 0;
+	if (ioctl (fd, SIOCGMIIPHY, &ifr) < 0) {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCGMIIPHY failed: %d", errno);
 		goto out;
+	}
 
 	/* If we can read the BMSR register, we assume that the card supports MII link detection */
 	bmsr = mdio_read (self, fd, &ifr, MII_BMSR);
 	supports_mii = (bmsr != -1) ? TRUE : FALSE;
+	nm_log_dbg (LOGD_HW | LOGD_ETHER, "MII %s supported",
+	            supports_mii ? "is" : "not");
 
 out:
 	close (fd);
diff --git a/src/nm-device-gsm.c b/src/nm-device-gsm.c
new file mode 100644
index 0000000..2a98a41
--- /dev/null
+++ b/src/nm-device-gsm.c
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+
+#include "nm-modem-gsm.h"
+#include "nm-device-interface.h"
+#include "nm-device-gsm.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-rfkill.h"
+
+#include "nm-device-gsm-glue.h"
+
+G_DEFINE_TYPE (NMDeviceGsm, nm_device_gsm, NM_TYPE_DEVICE_MODEM)
+
+enum {
+	PROPERTIES_CHANGED,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+NMDevice *
+nm_device_gsm_new (NMModemGsm *modem, const char *driver)
+{
+	g_return_val_if_fail (modem != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM_GSM (modem), NULL);
+	g_return_val_if_fail (driver != NULL, NULL);
+
+	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_GSM,
+	                                  NM_DEVICE_INTERFACE_UDI, nm_modem_get_path (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_IFACE, nm_modem_get_iface (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
+	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "GSM",
+	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_GSM,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE, RFKILL_TYPE_WWAN,
+	                                  NM_DEVICE_MODEM_MODEM, modem,
+	                                  NULL);
+}
+
+static void
+nm_device_gsm_init (NMDeviceGsm *self)
+{
+}
+
+static void
+nm_device_gsm_class_init (NMDeviceGsmClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+		                                  G_STRUCT_OFFSET (NMDeviceGsmClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
+	                                 &dbus_glib_nm_device_gsm_object_info);
+}
+
diff --git a/src/nm-device-gsm.h b/src/nm-device-gsm.h
new file mode 100644
index 0000000..9b403c6
--- /dev/null
+++ b/src/nm-device-gsm.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_GSM_H
+#define NM_DEVICE_GSM_H
+
+#include "nm-device-modem.h"
+#include "nm-modem-gsm.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_GSM            (nm_device_gsm_get_type ())
+#define NM_DEVICE_GSM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_GSM, NMDeviceGsm))
+#define NM_DEVICE_GSM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_DEVICE_GSM, NMDeviceGsmClass))
+#define NM_IS_DEVICE_GSM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_GSM))
+#define NM_IS_DEVICE_GSM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_DEVICE_GSM))
+#define NM_DEVICE_GSM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_DEVICE_GSM, NMDeviceGsmClass))
+
+typedef struct {
+	NMDeviceModem parent;
+} NMDeviceGsm;
+
+typedef struct {
+	NMDeviceModemClass parent;
+
+	/* Signals */
+	void (*signal_quality) (NMDeviceGsm *self, guint32 quality);
+
+	void (*properties_changed) (NMDeviceGsm *self, GHashTable *properties);
+} NMDeviceGsmClass;
+
+GType nm_device_gsm_get_type (void);
+
+NMDevice *nm_device_gsm_new (NMModemGsm *modem, const char *driver);
+
+G_END_DECLS
+
+#endif /* NM_DEVICE_GSM_H */
diff --git a/src/nm-device-interface.c b/src/nm-device-interface.c
index 70cce8b..4040626 100644
--- a/src/nm-device-interface.c
+++ b/src/nm-device-interface.c
@@ -22,8 +22,9 @@
 #include "nm-marshal.h"
 #include "nm-setting-connection.h"
 #include "nm-device-interface.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-properties-changed-signal.h"
+#include "nm-rfkill.h"
 
 static gboolean impl_device_disconnect (NMDeviceInterface *device,
                                         GError **error);
@@ -139,6 +140,14 @@ nm_device_interface_init (gpointer g_iface)
 
 	g_object_interface_install_property
 		(g_iface,
+		 g_param_spec_boxed (NM_DEVICE_INTERFACE_DHCP6_CONFIG,
+							  "DHCP6 Config",
+							  "DHCP6 Config",
+							  DBUS_TYPE_G_OBJECT_PATH,
+							  G_PARAM_READWRITE));
+
+	g_object_interface_install_property
+		(g_iface,
 		 g_param_spec_uint (NM_DEVICE_INTERFACE_STATE,
 							"State",
 							"State",
@@ -168,6 +177,15 @@ nm_device_interface_init (gpointer g_iface)
 							  NULL,
 							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
 
+	g_object_interface_install_property
+		(g_iface, g_param_spec_uint (NM_DEVICE_INTERFACE_RFKILL_TYPE,
+	                                 "Rfkill Type",
+	                                 "Type of rfkill switch (if any) supported by this device",
+	                                 RFKILL_TYPE_WLAN,
+	                                 RFKILL_TYPE_MAX,
+	                                 RFKILL_TYPE_UNKNOWN,
+	                                 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+
 	/* Signals */
 	g_signal_new ("state-changed",
 				  iface_type,
@@ -264,8 +282,8 @@ nm_device_interface_activate (NMDeviceInterface *device,
 	g_assert (s_con);
 
 	iface = nm_device_interface_get_iface (device);
-	nm_info ("Activation (%s) starting connection '%s'", iface,
-			 nm_setting_connection_get_id (s_con));
+	nm_log_info (LOGD_DEVICE, "Activation (%s) starting connection '%s'", iface,
+			     nm_setting_connection_get_id (s_con));
 	g_free (iface);
 
 	success = NM_DEVICE_INTERFACE_GET_INTERFACE (device)->activate (device, req, error);
@@ -361,6 +379,16 @@ nm_device_interface_set_enabled (NMDeviceInterface *device, gboolean enabled)
 	g_return_if_fail (NM_IS_DEVICE_INTERFACE (device));
 
 	if (NM_DEVICE_INTERFACE_GET_INTERFACE (device)->set_enabled)
-		return NM_DEVICE_INTERFACE_GET_INTERFACE (device)->set_enabled (device, enabled);
+		NM_DEVICE_INTERFACE_GET_INTERFACE (device)->set_enabled (device, enabled);
+}
+
+gboolean
+nm_device_interface_get_enabled (NMDeviceInterface *device)
+{
+	g_return_val_if_fail (NM_IS_DEVICE_INTERFACE (device), FALSE);
+
+	if (NM_DEVICE_INTERFACE_GET_INTERFACE (device)->get_enabled)
+		return NM_DEVICE_INTERFACE_GET_INTERFACE (device)->get_enabled (device);
+	return TRUE;
 }
 
diff --git a/src/nm-device-interface.h b/src/nm-device-interface.h
index 0ec5e3d..adbafca 100644
--- a/src/nm-device-interface.h
+++ b/src/nm-device-interface.h
@@ -53,10 +53,12 @@ typedef enum
 #define NM_DEVICE_INTERFACE_IP4_CONFIG   "ip4-config"
 #define NM_DEVICE_INTERFACE_DHCP4_CONFIG "dhcp4-config"
 #define NM_DEVICE_INTERFACE_IP6_CONFIG   "ip6-config"
+#define NM_DEVICE_INTERFACE_DHCP6_CONFIG "dhcp6-config"
 #define NM_DEVICE_INTERFACE_STATE        "state"
 #define NM_DEVICE_INTERFACE_DEVICE_TYPE  "device-type" /* ugh */
 #define NM_DEVICE_INTERFACE_MANAGED      "managed"
 #define NM_DEVICE_INTERFACE_TYPE_DESC    "type-desc"  /* Internal only */
+#define NM_DEVICE_INTERFACE_RFKILL_TYPE  "rfkill-type"  /* Internal only */
 
 typedef enum {
 	NM_DEVICE_INTERFACE_PROP_FIRST = 0x1000,
@@ -69,10 +71,12 @@ typedef enum {
 	NM_DEVICE_INTERFACE_PROP_IP4_CONFIG,
 	NM_DEVICE_INTERFACE_PROP_DHCP4_CONFIG,
 	NM_DEVICE_INTERFACE_PROP_IP6_CONFIG,
+	NM_DEVICE_INTERFACE_PROP_DHCP6_CONFIG,
 	NM_DEVICE_INTERFACE_PROP_STATE,
 	NM_DEVICE_INTERFACE_PROP_DEVICE_TYPE,
 	NM_DEVICE_INTERFACE_PROP_MANAGED,
 	NM_DEVICE_INTERFACE_PROP_TYPE_DESC,
+	NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE,
 } NMDeviceInterfaceProp;
 
 
@@ -99,6 +103,8 @@ struct _NMDeviceInterface {
 
 	void (*set_enabled) (NMDeviceInterface *device, gboolean enabled);
 
+	gboolean (*get_enabled) (NMDeviceInterface *device);
+
 	/* Signals */
 	void (*state_changed) (NMDeviceInterface *device,
 	                       NMDeviceState new_state,
@@ -133,6 +139,8 @@ NMConnection * nm_device_interface_connection_match_config (NMDeviceInterface *d
 
 gboolean nm_device_interface_can_assume_connection (NMDeviceInterface *device);
 
+gboolean nm_device_interface_get_enabled (NMDeviceInterface *device);
+
 void nm_device_interface_set_enabled (NMDeviceInterface *device, gboolean enabled);
 
 #endif /* NM_DEVICE_INTERFACE_H */
diff --git a/src/nm-device-modem.c b/src/nm-device-modem.c
new file mode 100644
index 0000000..b13ce6c
--- /dev/null
+++ b/src/nm-device-modem.c
@@ -0,0 +1,453 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <glib.h>
+
+#include "nm-device-modem.h"
+#include "nm-device-interface.h"
+#include "nm-modem.h"
+#include "nm-device-private.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-marshal.h"
+#include "nm-logging.h"
+
+static void device_interface_init (NMDeviceInterface *iface_class);
+
+G_DEFINE_TYPE_EXTENDED (NMDeviceModem, nm_device_modem, NM_TYPE_DEVICE, G_TYPE_FLAG_ABSTRACT,
+                        G_IMPLEMENT_INTERFACE (NM_TYPE_DEVICE_INTERFACE, device_interface_init))
+
+#define NM_DEVICE_MODEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE_MODEM, NMDeviceModemPrivate))
+
+typedef struct {
+	NMModem *modem;
+} NMDeviceModemPrivate;
+
+enum {
+	PROP_0,
+	PROP_MODEM
+};
+
+enum {
+	PPP_STATS,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static void real_set_enabled (NMDeviceInterface *device, gboolean enabled);
+
+/*****************************************************************************/
+
+static void
+ppp_stats (NMModem *modem,
+		   guint32 in_bytes,
+		   guint32 out_bytes,
+		   gpointer user_data)
+{
+	g_signal_emit (G_OBJECT (user_data), signals[PPP_STATS], 0, in_bytes, out_bytes);
+}
+
+static void
+ppp_failed (NMModem *modem, NMDeviceStateReason reason, gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+
+	switch (nm_device_interface_get_state (NM_DEVICE_INTERFACE (device))) {
+	case NM_DEVICE_STATE_PREPARE:
+	case NM_DEVICE_STATE_CONFIG:
+	case NM_DEVICE_STATE_NEED_AUTH:
+	case NM_DEVICE_STATE_IP_CONFIG:
+	case NM_DEVICE_STATE_ACTIVATED:
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+modem_prepare_result (NMModem *modem,
+                      gboolean success,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_PREPARE);
+
+	if (success)
+		nm_device_activate_schedule_stage2_device_config (device);
+	else
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+}
+
+static void
+modem_need_auth (NMModem *modem,
+	             const char *setting_name,
+	             gboolean retry,
+	             RequestSecretsCaller caller,
+	             const char *hint1,
+	             const char *hint2,
+	             gpointer user_data)
+{
+	NMDeviceModem *self = NM_DEVICE_MODEM (user_data);
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_assert (req);
+
+	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
+	nm_act_request_get_secrets (req, setting_name, retry, caller, hint1, hint2);
+}
+
+static void
+modem_ip4_config_result (NMModem *self,
+                         const char *iface,
+                         NMIP4Config *config,
+                         GError *error,
+                         gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_IP_CONFIG);
+
+	if (error) {
+		nm_log_warn (LOGD_MB | LOGD_IP4, "retrieving IP4 configuration failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);
+	} else {
+		if (iface)
+			nm_device_set_ip_iface (device, iface);
+
+		nm_device_activate_schedule_stage4_ip4_config_get (device);
+	}
+}
+
+static void
+modem_enabled_cb (NMModem *modem, GParamSpec *pspec, gpointer user_data)
+{
+	NMDeviceModem *self = NM_DEVICE_MODEM (user_data);
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (self);
+
+	real_set_enabled (NM_DEVICE_INTERFACE (self), nm_modem_get_mm_enabled (priv->modem));
+}
+
+/*****************************************************************************/
+
+NMModem *
+nm_device_modem_get_modem (NMDeviceModem *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE_MODEM (self), NULL);
+
+	return NM_DEVICE_MODEM_GET_PRIVATE (self)->modem;
+}
+
+/*****************************************************************************/
+
+static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	nm_modem_device_state_changed (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem,
+	                               new_state,
+	                               old_state,
+	                               reason);
+}
+
+static guint32
+real_get_generic_capabilities (NMDevice *device)
+{
+	return NM_DEVICE_CAP_NM_SUPPORTED;
+}
+
+static NMConnection *
+real_get_best_auto_connection (NMDevice *device,
+							   GSList *connections,
+							   char **specific_object)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (device);
+
+	return nm_modem_get_best_auto_connection (priv->modem, connections, specific_object);
+}
+
+static void
+real_connection_secrets_updated (NMDevice *device,
+								 NMConnection *connection,
+								 GSList *updated_settings,
+								 RequestSecretsCaller caller)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (device);
+	NMActRequest *req;
+
+	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (device)));
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	if (!nm_modem_connection_secrets_updated (priv->modem,
+                                              req,
+                                              connection,
+                                              updated_settings,
+                                              caller)) {
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
+		return;
+	}
+
+	/* PPP handles stuff itself... */
+	if (caller == SECRETS_CALLER_PPP)
+		return;
+
+	/* Otherwise, on success for modem secrets we need to schedule stage1 again */
+	g_return_if_fail (nm_device_get_state (device) == NM_DEVICE_STATE_NEED_AUTH);
+	nm_device_activate_schedule_stage1_device_prepare (device);
+}
+
+static gboolean
+real_check_connection_compatible (NMDevice *device,
+                                  NMConnection *connection,
+                                  GError **error)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (device);
+
+	return nm_modem_check_connection_compatible (priv->modem, connection, error);
+}
+
+static gboolean
+real_hw_is_up (NMDevice *device)
+{
+	return nm_modem_hw_is_up (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, device);
+}
+
+static gboolean
+real_hw_bring_up (NMDevice *device, gboolean *no_firmware)
+{
+	return nm_modem_hw_bring_up (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, device, no_firmware);
+}
+
+static void
+real_deactivate_quickly (NMDevice *device)
+{
+	nm_modem_deactivate_quickly (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, device);
+}
+
+static NMActStageReturn
+real_act_stage1_prepare (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	return nm_modem_act_stage1_prepare (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, req, reason);
+}
+
+static NMActStageReturn
+real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	return nm_modem_act_stage2_config (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, req, reason);
+}
+
+static NMActStageReturn
+real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+{
+	return nm_modem_stage3_ip4_config_start (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem,
+	                                         device,
+	                                         NM_DEVICE_CLASS (nm_device_modem_parent_class),
+	                                         reason);
+}
+
+static NMActStageReturn
+real_act_stage4_get_ip4_config (NMDevice *device,
+                                NMIP4Config **config,
+                                NMDeviceStateReason *reason)
+{
+	return nm_modem_stage4_get_ip4_config (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem,
+	                                       device,
+	                                       NM_DEVICE_CLASS (nm_device_modem_parent_class),
+	                                       config,
+	                                       reason);
+}
+
+/*****************************************************************************/
+
+static gboolean
+real_get_enabled (NMDeviceInterface *device)
+{
+	return nm_modem_get_mm_enabled (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem);
+}
+
+static void
+real_set_enabled (NMDeviceInterface *device, gboolean enabled)
+{
+	NMDeviceModem *self = NM_DEVICE_MODEM (device);
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (self);
+	NMDeviceState state;
+
+	if (priv->modem) {
+		nm_modem_set_mm_enabled (priv->modem, enabled);
+
+		if (enabled == FALSE) {
+			state = nm_device_interface_get_state (device);
+			if (state == NM_DEVICE_STATE_ACTIVATED) {
+				nm_device_state_changed (NM_DEVICE (device),
+				                         NM_DEVICE_STATE_DISCONNECTED,
+				                         NM_DEVICE_STATE_REASON_NONE);
+			}
+		}
+	}
+}
+
+/*****************************************************************************/
+
+static void
+device_interface_init (NMDeviceInterface *iface_class)
+{
+    iface_class->get_enabled = real_get_enabled;
+    iface_class->set_enabled = real_set_enabled;
+}
+
+static void
+nm_device_modem_init (NMDeviceModem *self)
+{
+	g_signal_connect (self, "state-changed", G_CALLBACK (device_state_changed), self);
+}
+
+static void
+set_modem (NMDeviceModem *self, NMModem *modem)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (self);
+
+	g_return_if_fail (modem != NULL);
+
+	priv->modem = g_object_ref (modem);
+
+	g_signal_connect (modem, NM_MODEM_PPP_STATS, G_CALLBACK (ppp_stats), self);
+	g_signal_connect (modem, NM_MODEM_PPP_FAILED, G_CALLBACK (ppp_failed), self);
+	g_signal_connect (modem, NM_MODEM_PREPARE_RESULT, G_CALLBACK (modem_prepare_result), self);
+	g_signal_connect (modem, NM_MODEM_IP4_CONFIG_RESULT, G_CALLBACK (modem_ip4_config_result), self);
+	g_signal_connect (modem, NM_MODEM_NEED_AUTH, G_CALLBACK (modem_need_auth), self);
+	g_signal_connect (modem, "notify::" NM_MODEM_ENABLED, G_CALLBACK (modem_enabled_cb), self);
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	case PROP_MODEM:
+		/* construct-only */
+		set_modem (NM_DEVICE_MODEM (object), g_value_get_object (value));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_MODEM:
+		g_value_set_object (value, priv->modem);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (object);
+
+	g_object_unref (priv->modem);
+	priv->modem = NULL;
+
+	G_OBJECT_CLASS (nm_device_modem_parent_class)->finalize (object);
+}
+
+static void
+nm_device_modem_class_init (NMDeviceModemClass *mclass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (mclass);
+	NMDeviceClass *device_class = NM_DEVICE_CLASS (mclass);
+
+	g_type_class_add_private (object_class, sizeof (NMDeviceModemPrivate));
+
+	/* Virtual methods */
+	object_class->finalize = finalize;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+
+	device_class->get_generic_capabilities = real_get_generic_capabilities;
+	device_class->get_best_auto_connection = real_get_best_auto_connection;
+	device_class->connection_secrets_updated = real_connection_secrets_updated;
+	device_class->check_connection_compatible = real_check_connection_compatible;
+	device_class->hw_is_up = real_hw_is_up;
+	device_class->hw_bring_up = real_hw_bring_up;
+	device_class->deactivate_quickly = real_deactivate_quickly;
+	device_class->act_stage1_prepare = real_act_stage1_prepare;
+	device_class->act_stage2_config = real_act_stage2_config;
+	device_class->act_stage3_ip4_config_start = real_act_stage3_ip4_config_start;
+	device_class->act_stage4_get_ip4_config = real_act_stage4_get_ip4_config;
+
+	/* Properties */
+	g_object_class_install_property
+		(object_class, PROP_MODEM,
+		 g_param_spec_object (NM_DEVICE_MODEM_MODEM,
+		                      "Modem",
+		                      "Modem",
+		                      NM_TYPE_MODEM,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+
+	/* Signals */
+	signals[PPP_STATS] =
+		g_signal_new ("ppp-stats",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDeviceModemClass, ppp_stats),
+					  NULL, NULL,
+					  _nm_marshal_VOID__UINT_UINT,
+					  G_TYPE_NONE, 2,
+					  G_TYPE_UINT, G_TYPE_UINT);
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (mclass),
+	                                 nm_modem_get_serial_dbus_info ());
+}
+
diff --git a/src/nm-device-modem.h b/src/nm-device-modem.h
new file mode 100644
index 0000000..40e89d4
--- /dev/null
+++ b/src/nm-device-modem.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_MODEM_H
+#define NM_DEVICE_MODEM_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nm-device.h"
+#include "nm-modem.h"
+
+#define NM_TYPE_DEVICE_MODEM            (nm_device_modem_get_type ())
+#define NM_DEVICE_MODEM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_MODEM, NMDeviceModem))
+#define NM_DEVICE_MODEM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DEVICE_MODEM, NMDeviceModemClass))
+#define NM_IS_DEVICE_MODEM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_MODEM))
+#define NM_IS_DEVICE_MODEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DEVICE_MODEM))
+#define NM_DEVICE_MODEM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DEVICE_MODEM, NMDeviceModemClass))
+
+#define NM_DEVICE_MODEM_MODEM "modem"
+
+typedef struct {
+	NMDevice parent;
+} NMDeviceModem;
+
+typedef struct {
+	NMDeviceClass parent;
+
+	void (*ppp_stats) (NMDeviceModem *self, guint32 in_bytes, guint32 out_bytes);
+} NMDeviceModemClass;
+
+GType nm_device_modem_get_type (void);
+
+/* Private for subclases */
+NMModem *nm_device_modem_get_modem (NMDeviceModem *self);
+
+#endif /* NM_DEVICE_MODEM_H */
diff --git a/src/nm-device-olpc-mesh.c b/src/nm-device-olpc-mesh.c
index 8be4632..2093a8e 100644
--- a/src/nm-device-olpc-mesh.c
+++ b/src/nm-device-olpc-mesh.c
@@ -19,7 +19,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2005 - 2008 Red Hat, Inc.
+ * (C) Copyright 2005 - 2010 Red Hat, Inc.
  * (C) Copyright 2008 Collabora Ltd.
  * (C) Copyright 2009 One Laptop per Child
  */
@@ -42,15 +42,19 @@
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
-#include "NetworkManagerPolicy.h"
 #include "nm-activation-request.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-olpc-mesh.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-manager.h"
 
+/* This is a bug; but we can't really change API now... */
+#include "NetworkManagerVPN.h"
+
+
 #include "nm-device-olpc-mesh-glue.h"
 
 static void nm_device_olpc_mesh_set_ssid (NMDeviceOlpcMesh *self, const GByteArray * ssid);
@@ -106,7 +110,7 @@ struct _NMDeviceOlpcMeshPrivate
 
 	NMDevice *        companion;
 	gboolean          stage1_waiting;
-	guint             device_added_cb;
+	guint             device_added_id;
 };
 
 static GQuark
@@ -154,7 +158,7 @@ real_get_generic_capabilities (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_warn (LOGD_OLPC_MESH, "couldn't open control socket.");
 		goto out;
 	}
 
@@ -165,13 +169,14 @@ real_get_generic_capabilities (NMDevice *dev)
 	wrq.u.data.length = sizeof (struct iw_range);
 
 	if (ioctl (fd, SIOCGIWRANGE, &wrq) < 0) {
-		nm_warning ("couldn't get driver range information.");
+		nm_log_warn (LOGD_OLPC_MESH, "couldn't get driver range information.");
 		goto out;
 	}
 
 	if ((wrq.u.data.length < 300) || (range.we_version_compiled < 16)) {
-		nm_warning ("%s: driver's Wireless Extensions version (%d) is too old.",
-		            iface, range.we_version_compiled);
+		nm_log_warn (LOGD_OLPC_MESH,
+		             "(%s): driver's Wireless Extensions version (%d) is too old.",
+		             iface, range.we_version_compiled);
 		goto out;
 	} else {
 		caps |= NM_DEVICE_CAP_NM_SUPPORTED;
@@ -257,6 +262,9 @@ constructor (GType type,
 	self = NM_DEVICE_OLPC_MESH (object);
 	priv = NM_DEVICE_OLPC_MESH_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_HW | LOGD_OLPC_MESH, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (self)), priv->ifindex);
+
 	iface = nm_device_get_iface (NM_DEVICE (self));
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0)
@@ -342,9 +350,7 @@ device_cleanup (NMDeviceOlpcMesh *self)
 static void
 real_take_down (NMDevice *dev)
 {
-	NMDeviceOlpcMesh *self = NM_DEVICE_OLPC_MESH (dev);
-
-	device_cleanup (self);
+	device_cleanup (NM_DEVICE_OLPC_MESH (dev));
 }
 
 static gboolean
@@ -403,7 +409,7 @@ create_socket_with_request (NMDevice *self, struct iwreq *req)
 
 	sk = socket (AF_INET, SOCK_DGRAM, 0);
 	if (!sk) {
-		nm_error ("Couldn't create socket: %d.", errno);
+		nm_log_err (LOGD_OLPC_MESH, "Couldn't create socket: %d.", errno);
 		return -1;
 	}
 
@@ -429,8 +435,8 @@ nm_device_olpc_mesh_get_channel (NMDeviceOlpcMesh *self)
 		return 0;
 
 	if ((ioctl (sk, SIOCGIWFREQ, &req)) != 0) {
-		nm_warning ("%s: failed to get channel (errno: %d))",
-		            nm_device_get_iface (NM_DEVICE (self)), errno);
+		nm_log_warn (LOGD_OLPC_MESH, "(%s): failed to get channel (errno: %d)",
+		             nm_device_get_iface (NM_DEVICE (self)), errno);
 		goto out;
 	}
 
@@ -468,10 +474,10 @@ nm_device_olpc_mesh_set_channel (NMDeviceOlpcMesh *self, guint32 channel)
 		req.u.freq.m = channel;
 	}
 
-	if (ioctl (sk, SIOCSIWFREQ, &req) != 0)
-		nm_warning ("%s: failed to set to channel %d (errno: %d))",
-		            nm_device_get_iface (NM_DEVICE (self)), channel, errno);
-	else
+	if (ioctl (sk, SIOCSIWFREQ, &req) != 0) {
+		nm_log_warn (LOGD_OLPC_MESH, "(%s): failed to set to channel %d (errno: %d)",
+		             nm_device_get_iface (NM_DEVICE (self)), channel, errno);
+	} else
 		g_object_notify (G_OBJECT (self), NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL);
 
 	close (sk);
@@ -491,7 +497,7 @@ nm_device_olpc_mesh_set_ssid (NMDeviceOlpcMesh *self, const GByteArray * ssid)
 
 	sk = socket (AF_INET, SOCK_DGRAM, 0);
 	if (!sk) {
-		nm_error ("Couldn't create socket: %d.", errno);
+		nm_log_err (LOGD_OLPC_MESH, "Couldn't create socket: %d.", errno);
 		return;
 	}
 
@@ -523,9 +529,10 @@ nm_device_olpc_mesh_set_ssid (NMDeviceOlpcMesh *self, const GByteArray * ssid)
 
 	if (ioctl (sk, SIOCSIWESSID, &wrq) < 0) {
 		if (errno != ENODEV) {
-			nm_warning ("error setting SSID to '%s' for device %s: %s",
+			nm_log_err (LOGD_OLPC_MESH, "(%s): error setting SSID to '%s': %s",
+			            iface,
 			            ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(null)",
-			            iface, strerror (errno));
+			            strerror (errno));
 		}
     }
 
@@ -553,7 +560,7 @@ real_update_hw_address (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		g_warning ("could not open control socket.");
+		nm_log_warn (LOGD_OLPC_MESH, "could not open control socket.");
 		return;
 	}
 
@@ -561,8 +568,8 @@ real_update_hw_address (NMDevice *dev)
 	strncpy (req.ifr_name, nm_device_get_iface (dev), IFNAMSIZ);
 	ret = ioctl (fd, SIOCGIFHWADDR, &req);
 	if (ret) {
-		nm_warning ("%s: (%s) error getting hardware address: %d",
-		            __func__, nm_device_get_iface (dev), errno);
+		nm_log_warn (LOGD_OLPC_MESH, "(%s): error getting hardware address: %d",
+		             nm_device_get_iface (dev), errno);
 		goto out;
 	}
 
@@ -584,16 +591,20 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 
 	/* disconnect companion device, if it is connected */
 	if (nm_device_get_act_request (NM_DEVICE (priv->companion))) {
-		nm_warning ("disconnecting companion device");
+		nm_log_info (LOGD_OLPC_MESH, "(%s): disconnecting companion device %s",
+		             nm_device_get_iface (dev),
+		             nm_device_get_iface (priv->companion));
+		/* FIXME: VPN stuff here is a bug; but we can't really change API now... */
 		nm_device_state_changed (NM_DEVICE (priv->companion),
 		                         NM_DEVICE_STATE_DISCONNECTED,
 		                         NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED);
-		nm_warning ("companion disconnected");
+		nm_log_info (LOGD_OLPC_MESH, "(%s): companion %s disconnected",
+		             nm_device_get_iface (dev),
+		             nm_device_get_iface (priv->companion));
 	}
 
 
-	/* wait with continuing configuration untill the companion device is done
-	 * scanning */
+	/* wait with continuing configuration untill the companion device is done scanning */
 	g_object_get (priv->companion, "scanning", &scanning, NULL);
 	if (scanning) {
 		priv->stage1_waiting = TRUE;
@@ -646,24 +657,24 @@ real_act_stage4_ip4_config_timeout (NMDevice *dev,
 
 
 static void
-nm_device_olpc_mesh_dispose (GObject *object)
+dispose (GObject *object)
 {
 	NMDeviceOlpcMesh *self = NM_DEVICE_OLPC_MESH (object);
 	NMDeviceOlpcMeshPrivate *priv = NM_DEVICE_OLPC_MESH_GET_PRIVATE (self);
+	NMManager *manager;
 
 	if (priv->dispose_has_run) {
 		G_OBJECT_CLASS (nm_device_olpc_mesh_parent_class)->dispose (object);
 		return;
 	}
-
 	priv->dispose_has_run = TRUE;
 
 	device_cleanup (self);
 
-	if (priv->device_added_cb != 0)
-		g_source_remove (priv->device_added_cb);
-
-	priv->device_added_cb = 0;
+	manager = nm_manager_get (NULL, NULL, NULL, FALSE, FALSE, FALSE, NULL);
+	if (priv->device_added_id)
+		g_signal_handler_disconnect (manager, priv->device_added_id);
+	g_object_unref (manager);
 
 	G_OBJECT_CLASS (nm_device_olpc_mesh_parent_class)->dispose (object);
 }
@@ -727,7 +738,7 @@ nm_device_olpc_mesh_class_init (NMDeviceOlpcMeshClass *klass)
 	object_class->constructor = constructor;
 	object_class->get_property = get_property;
 	object_class->set_property = set_property;
-	object_class->dispose = nm_device_olpc_mesh_dispose;
+	object_class->dispose = dispose;
 
 	parent_class->get_type_capabilities = NULL;
 	parent_class->get_generic_capabilities = real_get_generic_capabilities;
@@ -821,7 +832,9 @@ companion_state_changed_cb (NMDeviceWifi *companion,
 	    || state > NM_DEVICE_STATE_ACTIVATED)
 		return;
 
-	nm_debug ("disconnecting mesh due to companion connectivity");
+	nm_log_dbg (LOGD_OLPC_MESH, "(%s): disconnecting mesh due to companion connectivity",
+	            nm_device_get_iface (NM_DEVICE (self)));
+	/* FIXME: VPN stuff here is a bug; but we can't really change API now... */
 	nm_device_state_changed (NM_DEVICE (self),
 	                         NM_DEVICE_STATE_DISCONNECTED,
 	                         NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED);
@@ -857,6 +870,7 @@ is_companion (NMDeviceOlpcMesh *self, NMDevice *other)
 {
 	NMDeviceOlpcMeshPrivate *priv = NM_DEVICE_OLPC_MESH_GET_PRIVATE (self);
 	struct ether_addr their_addr;
+	NMManager *manager;
 
 	if (!NM_IS_DEVICE_WIFI (other))
 		return FALSE;
@@ -871,14 +885,21 @@ is_companion (NMDeviceOlpcMesh *self, NMDevice *other)
 	/* FIXME detect when our companion leaves */
 	priv->companion = other;
 
-	g_source_remove (priv->device_added_cb);
-	priv->device_added_cb = 0;
+	/* When we've found the companion, stop listening for other devices */
+	manager = nm_manager_get (NULL, NULL, NULL, FALSE, FALSE, FALSE, NULL);
+	if (priv->device_added_id) {
+		g_signal_handler_disconnect (manager, priv->device_added_id);
+		priv->device_added_id = 0;
+	}
+	g_object_unref (manager);
 
 	nm_device_state_changed (NM_DEVICE (self),
 	                         NM_DEVICE_STATE_DISCONNECTED,
 	                         NM_DEVICE_STATE_REASON_NONE);
 
-	nm_debug ("Found companion device: %s", nm_device_get_iface (other));
+	nm_log_info (LOGD_OLPC_MESH, "(%s): found companion WiFi device %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             nm_device_get_iface (other));
 
 	g_signal_connect (G_OBJECT (other), "state-changed",
 	                  G_CALLBACK (companion_state_changed_cb), self);
@@ -917,18 +938,19 @@ check_companion_cb (gpointer user_data)
 		return FALSE;
 	}
 
-	if (priv->device_added_cb != 0)
+	if (priv->device_added_id != 0)
 		return FALSE;
 
 	manager = nm_manager_get (NULL, NULL, NULL, FALSE, FALSE, FALSE, NULL);
 
-	priv->device_added_cb = g_signal_connect (manager, "device-added",
+	priv->device_added_id = g_signal_connect (manager, "device-added",
 	                                          G_CALLBACK (device_added_cb), self);
 
-	list = nm_manager_get_devices (manager);
-	for (; list != NULL ; list = list->next)
+	/* Try to find the companion if it's already known to the NMManager */
+	for (list = nm_manager_get_devices (manager); list ; list = g_slist_next (list)) {
 		if (is_companion (self, NM_DEVICE (list->data)))
 			break;
+	}
 
 	g_object_unref (manager);
 
diff --git a/src/nm-device-wifi.c b/src/nm-device-wifi.c
index e44ac96..cccaf11 100644
--- a/src/nm-device-wifi.c
+++ b/src/nm-device-wifi.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2009 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -37,9 +37,9 @@
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "NetworkManagerUtils.h"
-#include "NetworkManagerPolicy.h"
 #include "nm-activation-request.h"
 #include "nm-supplicant-manager.h"
 #include "nm-supplicant-interface.h"
@@ -51,7 +51,7 @@
 #include "nm-setting-8021x.h"
 #include "nm-setting-ip4-config.h"
 #include "nm-setting-ip6-config.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 static gboolean impl_device_get_access_points (NMDeviceWifi *device,
                                                GPtrArray **aps,
@@ -60,8 +60,6 @@ static gboolean impl_device_get_access_points (NMDeviceWifi *device,
 #include "nm-device-wifi-glue.h"
 
 
-/* #define IW_QUAL_DEBUG */
-
 /* All of these are in seconds */
 #define SCAN_INTERVAL_MIN 0
 #define SCAN_INTERVAL_STEP 20
@@ -183,10 +181,6 @@ struct _NMDeviceWifiPrivate {
 
 static guint32 nm_device_wifi_get_frequency (NMDeviceWifi *self);
 
-#if DEBUG
-static void nm_device_wifi_ap_list_print (NMDeviceWifi *self);
-#endif
-
 static gboolean request_wireless_scan (gpointer user_data);
 
 static void schedule_scan (NMDeviceWifi *self, gboolean backoff);
@@ -275,6 +269,7 @@ nm_device_wifi_get_ipw_rfkill_state (NMDeviceWifi *self)
 	NMDeviceWifiPrivate *priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 	char *contents = NULL;
 	RfKillState state = RFKILL_UNBLOCKED;
+	const char *str_state = NULL;
 
 	if (   priv->ipw_rfkill_path
 	    && g_file_get_contents (priv->ipw_rfkill_path, &contents, NULL, NULL)) {
@@ -288,16 +283,23 @@ nm_device_wifi_get_ipw_rfkill_state (NMDeviceWifi *self)
 		switch (contents[0]) {
 		case '1':
 			state = RFKILL_SOFT_BLOCKED;
+			str_state = "soft-blocked";
 			break;
 		case '2':
 		case '3':
 			state = RFKILL_HARD_BLOCKED;
+			str_state = "hard-blocked";
 			break;
 		case '0':
+			str_state = "unblocked";
 		default:
 			break;
 		}
 		g_free (contents);
+
+		nm_log_dbg (LOGD_RFKILL, "(%s): ipw rfkill state '%s'",
+		            nm_device_get_iface (NM_DEVICE (self)),
+		            str_state ? str_state : "(unknown)");
 	}
 
 	return state;
@@ -377,7 +379,7 @@ wireless_get_range (NMDeviceWifi *self,
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("(%s): couldn't open control socket.", iface);
+		nm_log_err (LOGD_HW, "(%s): couldn't open control socket.", iface);
 		return FALSE;
 	}
 
@@ -397,15 +399,20 @@ wireless_get_range (NMDeviceWifi *self,
 			success = TRUE;
 			break;
 		} else if (errno != EAGAIN) {
-			nm_warning ("(%s): couldn't get driver range information (%d).", iface, errno);
+			nm_log_err (LOGD_HW | LOGD_WIFI,
+			            "(%s): couldn't get driver range information (%d).",
+			            iface, errno);
 			break;
 		}
 
 		g_usleep (G_USEC_PER_SEC / 4);
 	}
 
-	if (i <= 0)
-		nm_warning ("(%s): driver took too long to respond to IWRANGE query.", iface);
+	if (i <= 0) {
+		nm_log_warn (LOGD_HW | LOGD_WIFI,
+		             "(%s): driver took too long to respond to IWRANGE query.",
+		             iface);
+	}
 
 	close (fd);
 	return success;
@@ -428,14 +435,15 @@ real_get_generic_capabilities (NMDevice *dev)
 
 	/* Check for Wireless Extensions support >= 16 for wireless devices */
 	if ((response_len < 300) || (range.we_version_compiled < 16)) {
-		nm_warning ("(%s): driver's Wireless Extensions version (%d) is too old.",
+		nm_log_err (LOGD_HW | LOGD_WIFI,
+		            "(%s): driver's Wireless Extensions version (%d) is too old.",
 					iface, range.we_version_compiled);
 		return NM_DEVICE_CAP_NONE;
 	}
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("(%s): couldn't open control socket.", iface);
+		nm_log_err (LOGD_HW, "(%s): couldn't open control socket.", iface);
 		goto out;
 	}
 
@@ -493,16 +501,16 @@ get_wireless_capabilities (NMDeviceWifi *self,
 		/* Check for cipher support but not WPA support */
 		if (    (caps & (NM_WIFI_DEVICE_CAP_CIPHER_TKIP | NM_WIFI_DEVICE_CAP_CIPHER_CCMP))
 		    && !(caps & (NM_WIFI_DEVICE_CAP_WPA | NM_WIFI_DEVICE_CAP_RSN))) {
-			nm_warning ("%s: device supports WPA ciphers but not WPA protocol; "
-			            "WPA unavailable.", iface);
+			nm_log_warn (LOGD_WIFI, "%s: device supports WPA ciphers but not WPA protocol; "
+			             "WPA unavailable.", iface);
 			caps &= ~WPA_CAPS;
 		}
 
 		/* Check for WPA support but not cipher support */
 		if (    (caps & (NM_WIFI_DEVICE_CAP_WPA | NM_WIFI_DEVICE_CAP_RSN))
 		    && !(caps & (NM_WIFI_DEVICE_CAP_CIPHER_TKIP | NM_WIFI_DEVICE_CAP_CIPHER_CCMP))) {
-			nm_warning ("%s: device supports WPA protocol but not WPA ciphers; "
-			            "WPA unavailable.", iface);
+			nm_log_warn (LOGD_WIFI, "%s: device supports WPA protocol but not WPA ciphers; "
+			             "WPA unavailable.", iface);
 			caps &= ~WPA_CAPS;
 		}
 	}
@@ -570,6 +578,9 @@ constructor (GType type,
 	self = NM_DEVICE_WIFI (object);
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_HW | LOGD_WIFI, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (self)), priv->ifindex);
+
 	memset (&range, 0, sizeof (struct iw_range));
 	success = wireless_get_range (NM_DEVICE_WIFI (object), &range, &response_len);
 	if (!success)
@@ -593,13 +604,15 @@ constructor (GType type,
 	scan_capa_range = (struct iw_range_with_scan_capa *) &range;
 	if (scan_capa_range->scan_capa & NM_IW_SCAN_CAPA_ESSID) {
 		priv->has_scan_capa_ssid = TRUE;
-		nm_info ("(%s): driver supports SSID scans (scan_capa 0x%02X).",
-		         nm_device_get_iface (NM_DEVICE (self)),
-		         scan_capa_range->scan_capa);
+		nm_log_info (LOGD_HW | LOGD_WIFI,
+		             "(%s): driver supports SSID scans (scan_capa 0x%02X).",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             scan_capa_range->scan_capa);
 	} else {
-		nm_info ("(%s): driver does not support SSID scans (scan_capa 0x%02X).",
-		         nm_device_get_iface (NM_DEVICE (self)),
-		         scan_capa_range->scan_capa);
+		nm_log_info (LOGD_HW | LOGD_WIFI,
+		             "(%s): driver does not support SSID scans (scan_capa 0x%02X).",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             scan_capa_range->scan_capa);
 	}
 
 	/* 802.11 wireless-specific capabilities */
@@ -653,7 +666,7 @@ supplicant_interface_acquire (NMDeviceWifi *self)
 	                                                          nm_device_get_iface (NM_DEVICE (self)),
 	                                                          TRUE);
 	if (priv->supplicant.iface == NULL) {
-		nm_warning ("Couldn't initialize supplicant interface for %s.",
+		nm_log_err (LOGD_WIFI, "Couldn't initialize supplicant interface for %s.",
 		            nm_device_get_iface (NM_DEVICE (self)));
 		return FALSE;
 	}
@@ -753,6 +766,8 @@ supplicant_interface_release (NMDeviceWifi *self)
 
 	/* Reset the scan interval to be pretty frequent when disconnected */
 	priv->scan_interval = SCAN_INTERVAL_MIN + SCAN_INTERVAL_STEP;
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): reset scanning interval to %d seconds",
+	            nm_device_get_iface (NM_DEVICE (self)));
 
 	remove_supplicant_interface_error_handler (self);
 
@@ -810,35 +825,30 @@ get_active_ap (NMDeviceWifi *self,
 	const GByteArray *ssid;
 	GSList *iter;
 	int i = 0;
-	gboolean ap_debug = getenv ("NM_ACTIVE_AP_DEBUG") ? TRUE : FALSE;
 
 	nm_device_wifi_get_bssid (self, &bssid);
-	if (G_UNLIKELY (ap_debug)) {
-		nm_debug ("(%s) BSSID: %02x:%02x:%02x:%02x:%02x:%02x",
-		          iface,
-		          bssid.ether_addr_octet[0], bssid.ether_addr_octet[1],
-		          bssid.ether_addr_octet[2], bssid.ether_addr_octet[3],
-		          bssid.ether_addr_octet[4], bssid.ether_addr_octet[5]);
-	}
+	nm_log_dbg (LOGD_WIFI, "(%s): active BSSID: %02x:%02x:%02x:%02x:%02x:%02x",
+	            iface,
+	            bssid.ether_addr_octet[0], bssid.ether_addr_octet[1],
+	            bssid.ether_addr_octet[2], bssid.ether_addr_octet[3],
+	            bssid.ether_addr_octet[4], bssid.ether_addr_octet[5]);
+
 	if (!nm_ethernet_address_is_valid (&bssid))
 		return NULL;
 
 	ssid = nm_device_wifi_get_ssid (self);
-	if G_UNLIKELY (ap_debug) {
-		nm_debug ("(%s) SSID: %s%s%s",
-		          iface,
-		          ssid ? "'" : "",
-		          ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)",
-		          ssid ? "'" : "");
-	}
+	nm_log_dbg (LOGD_WIFI, "(%s): active SSID: %s%s%s",
+	            iface,
+	            ssid ? "'" : "",
+	            ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)",
+	            ssid ? "'" : "");
 
 	/* When matching hidden APs, do a second pass that ignores the SSID check,
 	 * because NM might not yet know the SSID of the hidden AP in the scan list
 	 * and therefore it won't get matched the first time around.
 	 */
 	while (i++ < (match_hidden ? 2 : 1)) {
-		if G_UNLIKELY (ap_debug)
-			nm_debug ("  Pass #%d %s", i, i > 1 ? "(ignoring SSID)" : "");
+		nm_log_dbg (LOGD_WIFI, "  Pass #%d %s", i, i > 1 ? "(ignoring SSID)" : "");
 
 		/* Find this SSID + BSSID in the device's AP list */
 		for (iter = priv->ap_list; iter; iter = g_slist_next (iter)) {
@@ -848,63 +858,52 @@ get_active_ap (NMDeviceWifi *self,
 			NM80211Mode devmode, apmode;
 			guint32 devfreq, apfreq;
 
-			if G_UNLIKELY (ap_debug) {
-				nm_debug ("    AP: %s%s%s  %02x:%02x:%02x:%02x:%02x:%02x",
-				          ap_ssid ? "'" : "",
-				          ap_ssid ? nm_utils_escape_ssid (ap_ssid->data, ap_ssid->len) : "(none)",
-				          ap_ssid ? "'" : "",
-				          ap_bssid->ether_addr_octet[0], ap_bssid->ether_addr_octet[1],
-				          ap_bssid->ether_addr_octet[2], ap_bssid->ether_addr_octet[3],
-				          ap_bssid->ether_addr_octet[4], ap_bssid->ether_addr_octet[5]);
-			}
+			nm_log_dbg (LOGD_WIFI, "    AP: %s%s%s  %02x:%02x:%02x:%02x:%02x:%02x",
+			            ap_ssid ? "'" : "",
+			            ap_ssid ? nm_utils_escape_ssid (ap_ssid->data, ap_ssid->len) : "(none)",
+			            ap_ssid ? "'" : "",
+			            ap_bssid->ether_addr_octet[0], ap_bssid->ether_addr_octet[1],
+			            ap_bssid->ether_addr_octet[2], ap_bssid->ether_addr_octet[3],
+			            ap_bssid->ether_addr_octet[4], ap_bssid->ether_addr_octet[5]);
 
 			if (ignore_ap && (ap == ignore_ap)) {
-				if G_UNLIKELY (ap_debug)
-					nm_debug ("      ignored");
+				nm_log_dbg (LOGD_WIFI, "      ignored");
 				continue;
 			}
 
 			if (memcmp (bssid.ether_addr_octet, ap_bssid->ether_addr_octet, ETH_ALEN)) {
-				if G_UNLIKELY (ap_debug)
-					nm_debug ("      BSSID mismatch");
+				nm_log_dbg (LOGD_WIFI, "      BSSID mismatch");
 				continue;
 			}
 
 			if ((i == 0) && !nm_utils_same_ssid (ssid, ap_ssid, TRUE)) {
-				if G_UNLIKELY (ap_debug)
-					nm_debug ("      SSID mismatch");
+				nm_log_dbg (LOGD_WIFI, "      SSID mismatch");
 				continue;
 			}
 
 			devmode = nm_device_wifi_get_mode (self);
 			apmode = nm_ap_get_mode (ap);
 			if (devmode != apmode) {
-				if G_UNLIKELY (ap_debug) {
-					nm_debug ("      mode mismatch (device %d, ap %d)",
-					          devmode, apmode);
-				}
+				nm_log_dbg (LOGD_WIFI, "      mode mismatch (device %d, ap %d)",
+				            devmode, apmode);
 				continue;
 			}
 
 			devfreq = nm_device_wifi_get_frequency (self);
 			apfreq = nm_ap_get_freq (ap);
 			if (devfreq != apfreq) {
-				if G_UNLIKELY (ap_debug) {
-					nm_debug ("      frequency mismatch (device %u, ap %u)",
-					          devfreq, apfreq);
-				}
+				nm_log_dbg (LOGD_WIFI, "      frequency mismatch (device %u, ap %u)",
+				            devfreq, apfreq);
 				continue;
 			}
 
 			// FIXME: handle security settings here too
-			if G_UNLIKELY (ap_debug)
-				nm_debug ("      matched");
+			nm_log_dbg (LOGD_WIFI, "      matched");
 			return ap;
 		}
 	}
 
-	if G_UNLIKELY (ap_debug)
-		nm_debug ("  No matching AP found.");
+	nm_log_dbg (LOGD_WIFI, "  No matching AP found.");
 	return NULL;
 }
 
@@ -997,11 +996,12 @@ periodic_update (NMDeviceWifi *self)
 			old_ssid = nm_ap_get_ssid (priv->current_ap);
 		}
 
-		nm_debug ("Roamed from BSSID %s (%s) to %s (%s)",
-		          old_addr ? old_addr : "(none)",
-		          old_ssid ? nm_utils_escape_ssid (old_ssid->data, old_ssid->len) : "(none)",
-		          new_addr ? new_addr : "(none)",
-		          new_ssid ? nm_utils_escape_ssid (new_ssid->data, new_ssid->len) : "(none)");
+		nm_log_info (LOGD_WIFI, "(%s): roamed from BSSID %s (%s) to %s (%s)",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             old_addr ? old_addr : "(none)",
+		             old_ssid ? nm_utils_escape_ssid (old_ssid->data, old_ssid->len) : "(none)",
+		             new_addr ? new_addr : "(none)",
+		             new_ssid ? nm_utils_escape_ssid (new_ssid->data, new_ssid->len) : "(none)");
 		g_free (old_addr);
 		g_free (new_addr);
 
@@ -1211,16 +1211,25 @@ real_is_available (NMDevice *dev)
 	NMSupplicantInterface *sup_iface;
 	guint32 state;
 
-	if (!priv->enabled)
+	if (!priv->enabled) {
+		nm_log_dbg (LOGD_WIFI, "(%s): not available because not enabled",
+		            nm_device_get_iface (dev));
 		return FALSE;
+	}
 
 	sup_iface = priv->supplicant.iface;
-	if (!sup_iface)
+	if (!sup_iface) {
+		nm_log_dbg (LOGD_WIFI, "(%s): not available because supplicant not running",
+		            nm_device_get_iface (dev));
 		return FALSE;
+	}
 
 	state = nm_supplicant_interface_get_state (sup_iface);
-	if (state != NM_SUPPLICANT_INTERFACE_STATE_READY)
+	if (state != NM_SUPPLICANT_INTERFACE_STATE_READY) {
+		nm_log_dbg (LOGD_WIFI, "(%s): not available because supplicant interface not ready",
+		            nm_device_get_iface (dev));
 		return FALSE;
+	}
 
 	return TRUE;
 }
@@ -1298,7 +1307,6 @@ nm_device_wifi_get_address (NMDeviceWifi *self,
 	memcpy (addr, &(priv->hw_addr), sizeof (struct ether_addr));
 }
 
-#if DEBUG
 static void
 nm_device_wifi_ap_list_print (NMDeviceWifi *self)
 {
@@ -1308,14 +1316,13 @@ nm_device_wifi_ap_list_print (NMDeviceWifi *self)
 
 	g_return_if_fail (NM_IS_DEVICE_WIFI (self));
 
-	nm_info ("AP_LIST_PRINT:");
+	nm_log_dbg (LOGD_WIFI_SCAN, "Current AP list:");
 	for (elt = priv->ap_list; elt; elt = g_slist_next (elt), i++) {
 		NMAccessPoint * ap = NM_AP (elt->data);
-		nm_ap_print_self (ap, "::\t");
+		nm_ap_print_self (ap, "AP: ");
 	}
-	nm_info ("AP_LIST_PRINT: done");
+	nm_log_dbg (LOGD_WIFI_SCAN, "Current AP list: done");
 }
-#endif
 
 static gboolean
 impl_device_get_access_points (NMDeviceWifi *self,
@@ -1372,8 +1379,11 @@ nm_device_wifi_get_mode (NMDeviceWifi *self)
 			break;
 		}
 	} else {
-		if (errno != ENODEV)
-			nm_warning ("error getting card mode on %s: %s", iface, strerror (errno));
+		if (errno != ENODEV) {
+			nm_log_warn (LOGD_HW | LOGD_WIFI,
+			             "(%s): error %d getting card mode",
+			             iface, strerror (errno));
+		}
 	}
 	close (fd);
 
@@ -1423,7 +1433,8 @@ nm_device_wifi_set_mode (NMDeviceWifi *self, const NM80211Mode mode)
 
 	if (ioctl (fd, SIOCSIWMODE, &wrq) < 0) {
 		if (errno != ENODEV) {
-			nm_warning ("error setting card %s to mode %d: %s",
+			nm_log_err (LOGD_HW | LOGD_WIFI,
+			            "(%s): error setting mode %d",
 			            iface, mode, strerror (errno));
 		}
 	} else
@@ -1459,9 +1470,11 @@ nm_device_wifi_get_frequency (NMDeviceWifi *self)
 	iface = nm_device_get_iface (NM_DEVICE (self));
 	strncpy (wrq.ifr_name, iface, IFNAMSIZ);
 
-	if (ioctl (fd, SIOCGIWFREQ, &wrq) < 0)
-		nm_warning ("(%s): error getting frequency: %s", iface, strerror (errno));
-	else
+	if (ioctl (fd, SIOCGIWFREQ, &wrq) < 0) {
+		nm_log_warn (LOGD_HW | LOGD_WIFI,
+		             "(%s): error getting frequency: %s",
+		             iface, strerror (errno));
+	} else
 		freq = iw_freq_to_uint32 (&wrq.u.freq);
 
 	close (fd);
@@ -1485,17 +1498,16 @@ wireless_qual_to_percent (const struct iw_quality *qual,
 	g_return_val_if_fail (qual != NULL, -1);
 	g_return_val_if_fail (max_qual != NULL, -1);
 
-#ifdef IW_QUAL_DEBUG
-nm_debug ("QL: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X  ** MAX: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X",
-(__s8)qual->qual, qual->qual, qual->qual,
-(__s8)qual->level, qual->level, qual->level,
-(__s8)qual->noise, qual->noise, qual->noise,
-qual->updated,
-(__s8)max_qual->qual, max_qual->qual, max_qual->qual,
-(__s8)max_qual->level, max_qual->level, max_qual->level,
-(__s8)max_qual->noise, max_qual->noise, max_qual->noise,
-max_qual->updated);
-#endif
+	nm_log_dbg (LOGD_WIFI,
+	            "QL: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X  ** MAX: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X",
+	            (__s8) qual->qual, qual->qual, qual->qual,
+	            (__s8) qual->level, qual->level, qual->level,
+	            (__s8) qual->noise, qual->noise, qual->noise,
+	            qual->updated,
+	            (__s8) max_qual->qual, max_qual->qual, max_qual->qual,
+	            (__s8) max_qual->level, max_qual->level, max_qual->level,
+	            (__s8) max_qual->noise, max_qual->noise, max_qual->noise,
+	            max_qual->updated);
 
 	/* Try using the card's idea of the signal quality first as long as it tells us what the max quality is.
 	 * Drivers that fill in quality values MUST treat them as percentages, ie the "Link Quality" MUST be 
@@ -1520,8 +1532,7 @@ max_qual->updated);
 		&& !(qual->updated & IW_QUAL_LEVEL_INVALID)                                     /* Must have valid qual->level */
 		&& (    ((max_qual->noise > 0) && !(max_qual->updated & IW_QUAL_NOISE_INVALID)) /* Must have valid max_qual->noise */
 			|| ((qual->noise > 0) && !(qual->updated & IW_QUAL_NOISE_INVALID)))     /*    OR valid qual->noise */
-	   )
-	{
+	   ) {
 		/* Absolute power values (dBm) */
 
 		/* Reasonable fallbacks for dumb drivers that don't specify either level. */
@@ -1543,9 +1554,8 @@ max_qual->updated);
 		level_percent = (int)(100 - 70 *(
 		                                ((double)max_level - (double)level) /
 		                                ((double)max_level - (double)noise)));
-#ifdef IW_QUAL_DEBUG
-		nm_debug ("QL1: level_percent is %d.  max_level %d, level %d, noise_floor %d.", level_percent, max_level, level, noise);
-#endif
+		nm_log_dbg (LOGD_WIFI, "QL1: level_percent is %d.  max_level %d, level %d, noise_floor %d.",
+		            level_percent, max_level, level, noise);
 	} else if (   (max_qual->level != 0)
 	           && !(max_qual->updated & IW_QUAL_LEVEL_INVALID) /* Valid max_qual->level as upper bound */
 	           && !(qual->updated & IW_QUAL_LEVEL_INVALID)) {
@@ -1556,24 +1566,18 @@ max_qual->updated);
 		/* Signal level is relavtive (0 -> max_qual->level) */
 		level = CLAMP (level, 0, max_qual->level);
 		level_percent = (int)(100 * ((double)level / (double)max_qual->level));
-#ifdef IW_QUAL_DEBUG
-		nm_debug ("QL2: level_percent is %d.  max_level %d, level %d.", level_percent, max_qual->level, level);
-#endif
-	}
-	else if (percent == -1)
-	{
-#ifdef IW_QUAL_DEBUG
-		nm_debug ("QL: Could not get quality %% value from driver.  Driver is probably buggy.");
-#endif
+		nm_log_dbg (LOGD_WIFI, "QL2: level_percent is %d.  max_level %d, level %d.",
+		            level_percent, max_qual->level, level);
+	} else if (percent == -1) {
+		nm_log_dbg (LOGD_WIFI, "QL: Could not get quality %% value from driver.  Driver is probably buggy.");
 	}
 
 	/* If the quality percent was 0 or doesn't exist, then try to use signal levels instead */
 	if ((percent < 1) && (level_percent >= 0))
 		percent = level_percent;
 
-#ifdef IW_QUAL_DEBUG
-	nm_debug ("QL: Final quality percent is %d (%d).", percent, CLAMP (percent, 0, 100));
-#endif
+	nm_log_dbg (LOGD_WIFI, "QL: Final quality percent is %d (%d).",
+	            percent, CLAMP (percent, 0, 100));
 	return (CLAMP (percent, 0, 100));
 }
 
@@ -1598,7 +1602,7 @@ nm_device_wifi_get_ssid (NMDeviceWifi *self)
 
 	sk = socket (AF_INET, SOCK_DGRAM, 0);
 	if (!sk) {
-		nm_error ("Couldn't create socket: %d.", errno);
+		nm_log_err (LOGD_HW, "couldn't create socket: %d.", errno);
 		return NULL;
 	}
 
@@ -1609,7 +1613,8 @@ nm_device_wifi_get_ssid (NMDeviceWifi *self)
 	strncpy (wrq.ifr_name, nm_device_get_iface (NM_DEVICE (self)), IFNAMSIZ);
 
 	if (ioctl (sk, SIOCGIWESSID, &wrq) < 0) {
-		nm_warning ("Couldn't get SSID: %d", errno);
+		nm_log_err (LOGD_HW | LOGD_WIFI, "(%s): couldn't get SSID: %d",
+		            nm_device_get_iface (NM_DEVICE (self)), errno);
 		goto out;
 	}
 
@@ -1684,7 +1689,7 @@ nm_device_wifi_get_bssid (NMDeviceWifi *self,
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		g_warning ("failed to open control socket.");
+		nm_log_err (LOGD_WIFI, "failed to open control socket.");
 		return;
 	}
 
@@ -1791,10 +1796,16 @@ request_wireless_scan (gpointer user_data)
 	gboolean backoff = FALSE;
 
 	if (check_scanning_allowed (self)) {
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scanning requested",
+		            nm_device_get_iface (NM_DEVICE (self)));
+
 		if (nm_supplicant_interface_request_scan (priv->supplicant.iface)) {
 			/* success */
 			backoff = TRUE;
 		}
+	} else {
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scan requested but not allowed at this time",
+		            nm_device_get_iface (NM_DEVICE (self)));
 	}
 
 	priv->pending_scan_id = 0;
@@ -1824,13 +1835,13 @@ schedule_scan (NMDeviceWifi *self, gboolean backoff)
 	}
 
 	if (!priv->pending_scan_id) {
-		guint factor = 2;
+		guint factor = 2, next_scan = priv->scan_interval;
 
 		if (    nm_device_is_activating (NM_DEVICE (self))
 		    || (nm_device_get_state (NM_DEVICE (self)) == NM_DEVICE_STATE_ACTIVATED))
 			factor = 1;
 
-		priv->pending_scan_id = g_timeout_add_seconds (priv->scan_interval,
+		priv->pending_scan_id = g_timeout_add_seconds (next_scan,
 		                                               request_wireless_scan,
 		                                               self);
 
@@ -1847,6 +1858,12 @@ schedule_scan (NMDeviceWifi *self, gboolean backoff)
 			 */
 			priv->scan_interval = 5;
 		}
+
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scheduled scan in %d seconds (interval now %d seconds)",
+		            nm_device_get_iface (NM_DEVICE (self)),
+		            next_scan,
+		            priv->scan_interval);
+
 	}
 }
 
@@ -1868,6 +1885,10 @@ supplicant_iface_scan_request_result_cb (NMSupplicantInterface *iface,
                                          gboolean success,
                                          NMDeviceWifi *self)
 {
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scan request %s",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            success ? "successful" : "failed");
+
 	if (check_scanning_allowed (self))
 		schedule_scan (self, TRUE);
 }
@@ -1877,11 +1898,15 @@ supplicant_iface_scan_results_cb (NMSupplicantInterface *iface,
                                   guint32 num_results,
                                   NMDeviceWifi *self)
 {
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scan results available (%d APs found)",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            num_results);
 	if (num_results == 0) {
 		/* ensure that old APs get culled, which otherwise only
 		 * happens when there are actual scan results to process.
 		 */
 		cull_scan_list (self);
+		nm_device_wifi_ap_list_print (self);
 	}
 }
 
@@ -2035,11 +2060,12 @@ static void
 cull_scan_list (NMDeviceWifi *self)
 {
 	NMDeviceWifiPrivate *priv;
-	GTimeVal        cur_time;
-	GSList *        outdated_list = NULL;
-	GSList *        elt;
-	NMActRequest *  req;
-	const char *    cur_ap_path = NULL;
+	GTimeVal cur_time;
+	GSList *outdated_list = NULL;
+	GSList *elt;
+	NMActRequest *req;
+	const char *cur_ap_path = NULL;
+	guint32 removed = 0, total = 0;
 
 	g_return_if_fail (self != NULL);
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
@@ -2050,10 +2076,13 @@ cull_scan_list (NMDeviceWifi *self)
 	if (req)
 		cur_ap_path = nm_act_request_get_specific_object (req);
 
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): checking scan list for outdated APs",
+	            nm_device_get_iface (NM_DEVICE (self)));
+
 	/* Walk the access point list and remove any access points older than
 	 * three times the inactive scan interval.
 	 */
-	for (elt = priv->ap_list; elt; elt = g_slist_next (elt)) {
+	for (elt = priv->ap_list; elt; elt = g_slist_next (elt), total++) {
 		NMAccessPoint * ap = NM_AP (elt->data);
 		const glong     ap_time = nm_ap_get_last_seen (ap);
 		gboolean        keep = FALSE;
@@ -2071,13 +2100,31 @@ cull_scan_list (NMDeviceWifi *self)
 
 	/* Remove outdated APs */
 	for (elt = outdated_list; elt; elt = g_slist_next (elt)) {
-		NMAccessPoint * outdated_ap = NM_AP (elt->data);
+		NMAccessPoint *outdated_ap = NM_AP (elt->data);
+		const struct ether_addr *bssid;
+		const GByteArray *ssid;
+
+		bssid = nm_ap_get_address (outdated_ap);
+		ssid = nm_ap_get_ssid (outdated_ap);
+		nm_log_dbg (LOGD_WIFI_SCAN,
+		            "   removing %02x:%02x:%02x:%02x:%02x:%02x (%s%s%s)",
+		            bssid->ether_addr_octet[0], bssid->ether_addr_octet[1],
+		            bssid->ether_addr_octet[2], bssid->ether_addr_octet[3],
+		            bssid->ether_addr_octet[4], bssid->ether_addr_octet[5],
+		            ssid ? "'" : "",
+		            ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)",
+		            ssid ? "'" : "");
 
 		access_point_removed (self, outdated_ap);
 		priv->ap_list = g_slist_remove (priv->ap_list, outdated_ap);
 		g_object_unref (outdated_ap);
+		removed++;
 	}
 	g_slist_free (outdated_list);
+
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): removed %d APs (of %d)",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            removed, total);
 }
 
 #define SET_QUALITY_MEMBER(qual_item, lc_member, uc_member) \
@@ -2136,18 +2183,23 @@ supplicant_iface_scanned_ap_cb (NMSupplicantInterface *iface,
 		return;
 
 	ap = nm_ap_new_from_properties (properties);
-	if (!ap)
-		return;
+	if (ap) {
+		set_ap_strength_from_properties (self, ap, properties);
 
-	set_ap_strength_from_properties (self, ap, properties);
+		nm_ap_print_self (ap, "AP: ");
 
-	/* Add the AP to the device's AP list */
-	merge_scanned_ap (self, ap);
+		/* Add the AP to the device's AP list */
+		merge_scanned_ap (self, ap);
+		g_object_unref (ap);
 
-	/* Remove outdated access points */
-	cull_scan_list (self);
+		/* Remove outdated access points */
+		cull_scan_list (self);
 
-	g_object_unref (ap);
+		nm_device_wifi_ap_list_print (self);
+	} else {
+		nm_log_warn (LOGD_WIFI_SCAN, "(%s): invalid AP properties received",
+		             nm_device_get_iface (NM_DEVICE (self)));
+	}
 }
 
 
@@ -2204,7 +2256,7 @@ link_timeout_cb (gpointer user_data)
 	ap = nm_device_wifi_get_activation_ap (self);
 	if (req == NULL || ap == NULL) {
 		/* shouldn't ever happen */
-		nm_warning ("couldn't get activation request or activation AP.");
+		nm_log_err (LOGD_WIFI, "couldn't get activation request or activation AP.");
 		if (nm_device_is_activating (dev)) {
 			cleanup_association_attempt (self, TRUE);
 			nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
@@ -2251,8 +2303,9 @@ link_timeout_cb (gpointer user_data)
 		 * bad encryption key and the authenticating entity (AP, RADIUS server, etc)
 		 * denied the association due to bad credentials.
 		 */
-		nm_info ("Activation (%s/wireless): disconnected during association,"
-		         " asking for new key.", nm_device_get_iface (dev));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): disconnected during association,"
+		             " asking for new key.", nm_device_get_iface (dev));
 		cleanup_association_attempt (self, TRUE);
 		nm_device_state_changed (dev, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
 		nm_act_request_get_secrets (req,
@@ -2266,7 +2319,7 @@ link_timeout_cb (gpointer user_data)
 	}
 
 time_out:
-	nm_info ("%s: link timed out.", nm_device_get_iface (dev));
+	nm_log_warn (LOGD_WIFI, "(%s): link timed out.", nm_device_get_iface (dev));
 	return FALSE;
 }
 
@@ -2290,7 +2343,7 @@ schedule_state_handler (NMDeviceWifi *self,
 
 	task = g_slice_new0 (SupplicantStateTask);
 	if (!task) {
-		nm_warning ("Not enough memory to process supplicant manager state change.");
+		nm_log_err (LOGD_WIFI, "Not enough memory to process supplicant manager state change.");
 		return FALSE;
 	}
 
@@ -2320,10 +2373,10 @@ supplicant_iface_state_cb_handler (gpointer user_data)
 	self = task->self;
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 
-	nm_info ("(%s): supplicant interface state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         nm_supplicant_interface_state_to_string (task->old_state),
-	         nm_supplicant_interface_state_to_string (task->new_state));
+	nm_log_info (LOGD_WIFI, "(%s): supplicant interface state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             nm_supplicant_interface_state_to_string (task->old_state),
+	             nm_supplicant_interface_state_to_string (task->new_state));
 
 	if (task->new_state == NM_SUPPLICANT_INTERFACE_STATE_READY) {
 		priv->scan_interval = SCAN_INTERVAL_MIN;
@@ -2337,6 +2390,9 @@ supplicant_iface_state_cb_handler (gpointer user_data)
 			                         NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE);
 		}
 
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): supplicant ready, requesting initial scan",
+		            nm_device_get_iface (NM_DEVICE (self)));
+
 		/* Request a scan to get latest results */
 		cancel_pending_scan (self);
 		request_wireless_scan (self);
@@ -2382,10 +2438,10 @@ supplicant_iface_connection_state_cb_handler (gpointer user_data)
 		goto out;
 	}
 
-	nm_info ("(%s): supplicant connection state:  %s -> %s",
-	         nm_device_get_iface (dev),
-	         nm_supplicant_interface_connection_state_to_string (task->old_state),
-	         nm_supplicant_interface_connection_state_to_string (task->new_state));
+	nm_log_info (LOGD_WIFI, "(%s): supplicant connection state:  %s -> %s",
+	             nm_device_get_iface (dev),
+	             nm_supplicant_interface_connection_state_to_string (task->old_state),
+	             nm_supplicant_interface_connection_state_to_string (task->new_state));
 
 	scanning = nm_supplicant_interface_get_scanning (priv->supplicant.iface);
 
@@ -2400,10 +2456,11 @@ supplicant_iface_connection_state_cb_handler (gpointer user_data)
 			NMAccessPoint *ap = nm_device_wifi_get_activation_ap (self);
 			const GByteArray * ssid = nm_ap_get_ssid (ap);
 
-			nm_info ("Activation (%s/wireless) Stage 2 of 5 (Device Configure) "
-			         "successful.  Connected to wireless network '%s'.",
-			         nm_device_get_iface (dev),
-			         ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
+			nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+			             "Activation (%s/wireless) Stage 2 of 5 (Device Configure) "
+			             "successful.  Connected to wireless network '%s'.",
+			             nm_device_get_iface (dev),
+			             ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
 			nm_device_activate_schedule_stage3_ip_config_start (dev);
 		}
 	} else if (task->new_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED) {
@@ -2456,10 +2513,10 @@ supplicant_mgr_state_cb_handler (gpointer user_data)
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 	dev = NM_DEVICE (self);
 
-	nm_info ("(%s): supplicant manager state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         nm_supplicant_manager_state_to_string (task->old_state),
-	         nm_supplicant_manager_state_to_string (task->new_state));
+	nm_log_info (LOGD_WIFI, "(%s): supplicant manager state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             nm_supplicant_manager_state_to_string (task->old_state),
+	             nm_supplicant_manager_state_to_string (task->new_state));
 
 	/* If the supplicant went away, release the supplicant interface */
 	if (task->new_state == NM_SUPPLICANT_MANAGER_STATE_DOWN) {
@@ -2530,11 +2587,12 @@ supplicant_iface_connection_error_cb_handler (gpointer user_data)
 	if (!nm_device_is_activating (NM_DEVICE (self)))
 		goto out;
 
-	nm_info ("Activation (%s/wireless): association request to the supplicant "
-	         "failed: %s - %s",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         cb_data->name,
-	         cb_data->message);
+	nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+	             "Activation (%s/wireless): association request to the supplicant "
+	             "failed: %s - %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             cb_data->name,
+	             cb_data->message);
 
 	cleanup_association_attempt (self, TRUE);
 	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED);
@@ -2563,7 +2621,7 @@ supplicant_iface_connection_error_cb (NMSupplicantInterface * iface,
 
 	cb_data = g_slice_new0 (struct iface_con_error_cb_data);
 	if (cb_data == NULL) {
-		nm_warning ("Not enough memory to process supplicant connection error.");
+		nm_log_err (LOGD_WIFI, "Not enough memory to process supplicant connection error.");
 		return;
 	}
 
@@ -2579,10 +2637,17 @@ supplicant_iface_connection_error_cb (NMSupplicantInterface * iface,
 }
 
 static void
-supplicant_iface_notify_scanning_cb (NMSupplicantInterface * iface,
-                                     GParamSpec * pspec,
-                                     NMDeviceWifi * self)
+supplicant_iface_notify_scanning_cb (NMSupplicantInterface *iface,
+                                     GParamSpec *pspec,
+                                     NMDeviceWifi *self)
 {
+	gboolean scanning;
+
+	scanning = nm_supplicant_interface_get_scanning (iface);
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): now %s",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            scanning ? "scanning" : "not scanning");
+
 	g_object_notify (G_OBJECT (self), "scanning");
 }
 
@@ -2644,7 +2709,7 @@ handle_auth_or_fail (NMDeviceWifi *self,
 
 		g_object_set_data (G_OBJECT (connection), WIRELESS_SECRETS_TRIES, GUINT_TO_POINTER (++tries));
 	} else {
-		nm_warning ("Cleared secrets, but setting didn't need any secrets.");
+		nm_log_warn (LOGD_DEVICE, "Cleared secrets, but setting didn't need any secrets.");
 	}
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
@@ -2687,19 +2752,22 @@ supplicant_connection_timeout_cb (gpointer user_data)
 
 	auth_enforced = ap_auth_enforced (connection, ap, &encrypted);
 	if (!encrypted) {
-		nm_info ("Activation (%s/wireless): association took too long, "
-		         "failing activation.",
-		         nm_device_get_iface (dev));
+		nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): association took too long, "
+		             "failing activation.",
+		             nm_device_get_iface (dev));
 		nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED,
 		                         NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT);
 	} else {
 		/* Authentication failed, encryption key is probably bad */
-		nm_info ("Activation (%s/wireless): association took too long.",
-		         nm_device_get_iface (dev));
+		nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): association took too long.",
+		             nm_device_get_iface (dev));
 
 		if (handle_auth_or_fail (self, req, TRUE) == NM_ACT_STAGE_RETURN_POSTPONE) {
-			nm_info ("Activation (%s/wireless): asking for new secrets",
-			         nm_device_get_iface (dev));
+			nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+			             "Activation (%s/wireless): asking for new secrets",
+			             nm_device_get_iface (dev));
 		} else {
 			nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED,
 			                         NM_DEVICE_STATE_REASON_NO_SECRETS);
@@ -2722,8 +2790,9 @@ start_supplicant_connection_timeout (NMDeviceWifi *self)
 
 	/* Set up a timeout on the connection attempt to fail it after 25 seconds */
 	id = g_timeout_add_seconds (25, supplicant_connection_timeout_cb, self);
-	if (id <= 0) {
-		nm_warning ("Activation (%s/wireless): couldn't start supplicant "
+	if (id == 0) {
+		nm_log_err (LOGD_DEVICE | LOGD_WIFI,
+		            "Activation (%s/wireless): couldn't start supplicant "
 		            "timeout timer.",
 		            nm_device_get_iface (NM_DEVICE (self)));
 		return FALSE;
@@ -2809,7 +2878,7 @@ build_supplicant_config (NMDeviceWifi *self,
 	                                                nm_ap_get_broadcast (ap),
 	                                                adhoc_freq,
 	                                                priv->has_scan_capa_ssid)) {
-		nm_warning ("Couldn't add 802-11-wireless setting to supplicant config.");
+		nm_log_err (LOGD_WIFI, "Couldn't add 802-11-wireless setting to supplicant config.");
 		goto error;
 	}
 
@@ -2824,13 +2893,13 @@ build_supplicant_config (NMDeviceWifi *self,
 		                                                         s_wireless_sec,
 		                                                         s_8021x,
 		                                                         con_path)) {
-			nm_warning ("Couldn't add 802-11-wireless-security setting to "
+			nm_log_err (LOGD_WIFI, "Couldn't add 802-11-wireless-security setting to "
 			            "supplicant config.");
 			goto error;
 		}
 	} else {
 		if (!nm_supplicant_config_add_no_security (config)) {
-			nm_warning ("Couldn't add unsecured option to supplicant config.");
+			nm_log_err (LOGD_WIFI, "Couldn't add unsecured option to supplicant config.");
 			goto error;
 		}
 	}
@@ -2854,15 +2923,15 @@ real_update_hw_address (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		g_warning ("could not open control socket.");
+		nm_log_err (LOGD_HW, "could not open control socket.");
 		return;
 	}
 
 	memset (&req, 0, sizeof (struct ifreq));
 	strncpy (req.ifr_name, nm_device_get_iface (dev), IFNAMSIZ);
 	if (ioctl (fd, SIOCGIFHWADDR, &req) < 0) {
-		nm_warning ("%s: (%s) error getting hardware address: %d",
-		            __func__, nm_device_get_iface (dev), errno);
+		nm_log_err (LOGD_HW | LOGD_WIFI, "(%s) error getting hardware address: %d",
+		            nm_device_get_iface (dev), errno);
 		goto out;
 	}
 
@@ -2963,7 +3032,8 @@ real_connection_secrets_updated (NMDevice *dev,
 		    || !strcmp (setting_name, NM_SETTING_802_1X_SETTING_NAME)) {
 			valid = TRUE;
 		} else {
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
+			nm_log_warn (LOGD_DEVICE, "Ignoring updated secrets for setting '%s'.",
+			             setting_name);
 		}
 	}
 
@@ -3013,9 +3083,10 @@ real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 	/* If we need secrets, get them */
 	setting_name = nm_connection_need_secrets (connection, NULL);
 	if (setting_name) {
-		nm_info ("Activation (%s/wireless): access point '%s' has security,"
-		         " but secrets are required.",
-		         iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): access point '%s' has security,"
+		             " but secrets are required.",
+		             iface, nm_setting_connection_get_id (s_connection));
 
 		ret = handle_auth_or_fail (self, req, FALSE);
 		if (ret == NM_ACT_STAGE_RETURN_FAILURE)
@@ -3025,19 +3096,22 @@ real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 
 	/* have secrets, or no secrets required */
 	if (nm_setting_wireless_get_security (s_wireless)) {
-		nm_info ("Activation (%s/wireless): connection '%s' has security"
-		         ", and secrets exist.  No new secrets needed.",
-		         iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): connection '%s' has security"
+		             ", and secrets exist.  No new secrets needed.",
+		             iface, nm_setting_connection_get_id (s_connection));
 	} else {
-		nm_info ("Activation (%s/wireless): connection '%s' requires no "
-		         "security.  No secrets needed.",
-		         iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): connection '%s' requires no "
+		             "security.  No secrets needed.",
+		             iface, nm_setting_connection_get_id (s_connection));
 	}
 
 	config = build_supplicant_config (self, connection, ap);
 	if (config == NULL) {
-		nm_warning ("Activation (%s/wireless): couldn't build wireless "
-			"configuration.", iface);
+		nm_log_err (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): couldn't build wireless configuration.",
+		             iface);
 		*reason = NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED;
 		goto out;
 	}
@@ -3050,8 +3124,9 @@ real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 	priv->supplicant.iface_error_id = id;
 
 	if (!nm_supplicant_interface_set_config (priv->supplicant.iface, config)) {
-		nm_warning ("Activation (%s/wireless): couldn't send wireless "
-			"configuration to the supplicant.", iface);
+		nm_log_err (LOGD_DEVICE | LOGD_WIFI,
+		            "Activation (%s/wireless): couldn't send wireless "
+		            "configuration to the supplicant.", iface);
 		*reason = NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED;
 		goto out;
 	}
@@ -3143,14 +3218,16 @@ real_act_stage4_ip4_config_timeout (NMDevice *dev,
 		s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
 
 		/* Activation failed, we must have bad encryption key */
-		nm_info ("Activation (%s/wireless): could not get IP configuration for "
-		          "connection '%s'.",
-				 nm_device_get_iface (dev), nm_setting_connection_get_id (s_con));
+		nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): could not get IP configuration for "
+		             "connection '%s'.",
+				     nm_device_get_iface (dev), nm_setting_connection_get_id (s_con));
 
 		ret = handle_auth_or_fail (self, req, TRUE);
 		if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
-			nm_info ("Activation (%s/wireless): asking for new secrets",
-			         nm_device_get_iface (dev));
+			nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+			             "Activation (%s/wireless): asking for new secrets",
+			             nm_device_get_iface (dev));
 		} else {
 			*reason = NM_DEVICE_STATE_REASON_NO_SECRETS;
 		}
@@ -3277,9 +3354,10 @@ activation_failure_handler (NMDevice *dev)
 	}
 
 	ssid = nm_ap_get_ssid (ap);
-	nm_info ("Activation (%s) failed for access point (%s)",
-	         nm_device_get_iface (dev),
-	         ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
+	nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+	             "Activation (%s) failed for access point (%s)",
+	             nm_device_get_iface (dev),
+	             ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
 }
 
 static gboolean
@@ -3433,18 +3511,29 @@ real_set_enabled (NMDeviceInterface *device, gboolean enabled)
 
 	priv->enabled = enabled;
 
+	nm_log_dbg (LOGD_WIFI, "(%s): device now %s",
+	            nm_device_get_iface (NM_DEVICE (device)),
+	            enabled ? "enabled" : "disabled");
+
 	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-	if (state < NM_DEVICE_STATE_UNAVAILABLE)
+	if (state < NM_DEVICE_STATE_UNAVAILABLE) {
+		nm_log_dbg (LOGD_WIFI, "(%s): %s blocked by UNMANAGED state",
+		            enabled ? "enable" : "disable",
+		            nm_device_get_iface (NM_DEVICE (device)));
 		return;
+	}
 
 	if (enabled) {
 		gboolean no_firmware = FALSE, success;
 		struct iw_range range;
 
 		if (state != NM_DEVICE_STATE_UNAVAILABLE)
-			nm_warning ("not in expected unavailable state!");
+			nm_log_warn (LOGD_CORE, "not in expected unavailable state!");
 
 		if (!nm_device_hw_bring_up (NM_DEVICE (self), TRUE, &no_firmware)) {
+			nm_log_dbg (LOGD_WIFI, "(%s): enable blocked by failure to bring device up",
+			            nm_device_get_iface (NM_DEVICE (device)));
+
 			/* The device sucks, or HAL was lying to us about the killswitch state */
 			priv->enabled = FALSE;
 			return;
@@ -3459,6 +3548,8 @@ real_set_enabled (NMDeviceInterface *device, gboolean enabled)
 			supplicant_interface_release (self);
 
 		supplicant_interface_acquire (self);
+		nm_log_dbg (LOGD_WIFI, "(%s): enable waiting on supplicant state",
+		            nm_device_get_iface (NM_DEVICE (device)));
 	} else {
 		nm_device_state_changed (NM_DEVICE (self),
 		                         NM_DEVICE_STATE_UNAVAILABLE,
@@ -3486,6 +3577,7 @@ nm_device_wifi_new (const char *udi,
 	                                  NM_DEVICE_WIFI_IFINDEX, ifindex,
 	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "802.11 WiFi",
 	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_WIFI,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE, RFKILL_TYPE_WLAN,
 	                                  NULL);
 }
 
diff --git a/src/nm-device-wifi.h b/src/nm-device-wifi.h
index c793844..45b573a 100644
--- a/src/nm-device-wifi.h
+++ b/src/nm-device-wifi.h
@@ -28,7 +28,7 @@
 
 #include "nm-rfkill.h"
 #include "nm-device.h"
-#include "NetworkManagerAP.h"
+#include "nm-wifi-ap.h"
 
 struct NMAccessPointList;
 
diff --git a/src/nm-device.c b/src/nm-device.c
index 6c0f99c..280d4e4 100644
--- a/src/nm-device.c
+++ b/src/nm-device.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -38,13 +38,13 @@
 #include "nm-device-interface.h"
 #include "nm-device.h"
 #include "nm-device-private.h"
-#include "NetworkManagerPolicy.h"
 #include "NetworkManagerUtils.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-dhcp-manager.h"
 #include "nm-dbus-manager.h"
 #include "nm-named-manager.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-netlink.h"
 #include "nm-setting-ip4-config.h"
 #include "nm-setting-ip6-config.h"
@@ -53,6 +53,7 @@
 #include "nm-dhcp4-config.h"
 #include "nm-ip6-manager.h"
 #include "nm-marshal.h"
+#include "nm-rfkill.h"
 
 #define NM_ACT_REQUEST_IP4_CONFIG "nm-act-request-ip4-config"
 #define NM_ACT_REQUEST_IP6_CONFIG "nm-act-request-ip6-config"
@@ -88,6 +89,7 @@ typedef struct {
 	guint32       capabilities;
 	char *        driver;
 	gboolean      managed; /* whether managed by NM or not */
+	RfKillType    rfkill_type;
 
 	guint32         ip4_address;
 
@@ -102,13 +104,16 @@ typedef struct {
 	gboolean        ip4_ready;
 	gboolean        ip6_ready;
 
-	/* IP4 configuration info */
-	NMIP4Config *   ip4_config;			/* Config from DHCP, PPP, or system config files */
+	/* Generic DHCP stuff */
 	NMDHCPManager * dhcp_manager;
 	guint32         dhcp_timeout;
-	gulong          dhcp_state_sigid;
-	gulong          dhcp_timeout_sigid;
 	GByteArray *    dhcp_anycast_address;
+
+	/* IP4 configuration info */
+	NMIP4Config *   ip4_config;			/* Config from DHCP, PPP, or system config files */
+	NMDHCPClient *  dhcp4_client;
+	gulong          dhcp4_state_sigid;
+	gulong          dhcp4_timeout_sigid;
 	NMDHCP4Config * dhcp4_config;
 
 	/* dnsmasq stuff for shared connections */
@@ -127,6 +132,12 @@ typedef struct {
 	gulong         ip6_addrconf_sigid;
 	gulong         ip6_config_changed_sigid;
 	gboolean       ip6_waiting_for_config;
+	guint32        ip6_dhcp_opt;
+
+	NMDHCPClient *  dhcp6_client;
+	gulong          dhcp6_state_sigid;
+	gulong          dhcp6_timeout_sigid;
+	NMDHCP6Config * dhcp6_config;
 
 	/* inhibit autoconnect feature */
 	gboolean	autoconnect_inhibit;
@@ -159,6 +170,11 @@ static gboolean nm_device_set_ip6_config (NMDevice *dev,
                                           gboolean assumed,
                                           NMDeviceStateReason *reason);
 
+static NMActStageReturn dhcp6_start (NMDevice *self,
+                                     NMConnection *connection,
+                                     guint32 dhcp_opt,
+                                     NMDeviceStateReason *reason);
+
 static void
 device_interface_init (NMDeviceInterface *device_interface_class)
 {
@@ -181,6 +197,7 @@ nm_device_init (NMDevice *self)
 	priv->capabilities = NM_DEVICE_CAP_NONE;
 	priv->state = NM_DEVICE_STATE_UNMANAGED;
 	priv->dhcp_timeout = 0;
+	priv->rfkill_type = RFKILL_TYPE_UNKNOWN;
 }
 
 static GObject*
@@ -202,24 +219,26 @@ constructor (GType type,
 	priv = NM_DEVICE_GET_PRIVATE (dev);
 
 	if (!priv->udi) {
-		nm_warning ("No device udi provided, ignoring");
+		nm_log_err (LOGD_DEVICE, "No device udi provided, ignoring");
 		goto error;
 	}
 
 	if (!priv->iface) {
-		nm_warning ("No device interface provided, ignoring");
+		nm_log_err (LOGD_DEVICE, "No device interface provided, ignoring");
 		goto error;
 	}
 
 	priv->capabilities |= NM_DEVICE_GET_CLASS (dev)->get_generic_capabilities (dev);
 	if (!(priv->capabilities & NM_DEVICE_CAP_NM_SUPPORTED)) {
-		nm_warning ("(%s): Device unsupported, ignoring.", priv->iface);
+		nm_log_warn (LOGD_DEVICE, "(%s): Device unsupported, ignoring.", priv->iface);
 		goto error;
 	}
 
 	if (NM_DEVICE_GET_CLASS (dev)->update_hw_address)
 		NM_DEVICE_GET_CLASS (dev)->update_hw_address (dev);
 
+	priv->dhcp_manager = nm_dhcp_manager_get ();
+
 	priv->initialized = TRUE;
 	return object;
 
@@ -508,8 +527,9 @@ activation_source_schedule (NMDevice *self, GSourceFunc func, int family)
 		act_source_func = &priv->act_source_func;
 	}
 
-	if (*act_source_id)
-		nm_warning ("activation stage already scheduled");
+	if (*act_source_id) {
+		nm_log_err (LOGD_DEVICE, "activation stage already scheduled");
+	}
 
 	/* Don't bother rescheduling the same function that's about to
 	 * run anyway.  Fixes issues with crappy wireless drivers sending
@@ -525,31 +545,78 @@ activation_source_schedule (NMDevice *self, GSourceFunc func, int family)
 
 static void
 ip6_addrconf_complete (NMIP6Manager *ip6_manager,
-					   const char *iface,
-					   gboolean success,
-					   gpointer user_data)
+                       const char *iface,
+                       guint dhcp_opts,
+                       gboolean success,
+                       gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActRequest *req;
+	NMConnection *connection;
+	NMActStageReturn ret;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+	NMDeviceState state;
 
 	if (strcmp (nm_device_get_ip_iface (self), iface) != 0)
 		return;
-	if (!nm_device_get_act_request (self))
+	req = nm_device_get_act_request (self);
+	if (!req)
 		return;
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
 
-	if (priv->ip6_waiting_for_config) {
-		priv->ip6_waiting_for_config = FALSE;
-		if (success)
-			nm_device_activate_schedule_stage4_ip6_config_get (self);
-		else
-			nm_device_activate_schedule_stage4_ip6_config_timeout (self);
+	if (!priv->ip6_waiting_for_config)
+		return;
+
+	priv->ip6_waiting_for_config = FALSE;
+
+	if (!success) {
+		nm_device_activate_schedule_stage4_ip6_config_timeout (self);
+		return;
+	}
+
+	priv->ip6_dhcp_opt = dhcp_opts;
+
+	/* If addrconf is all that's required, we're done */
+	if (dhcp_opts == IP6_DHCP_OPT_NONE) {
+		nm_device_activate_schedule_stage4_ip6_config_get (self);
+		return;
+	}
+
+	/* If the router said to use DHCP for managed or otherconf, do it */
+
+	/* Don't re-start DHCPv6 if it's already in progress */
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
+	if ((state != NM_DEVICE_STATE_IP_CONFIG) || priv->dhcp6_client)
+		return;
+
+	nm_log_info (LOGD_DEVICE | LOGD_DHCP6,
+	             "Activation (%s) Stage 3 of 5 (IP Configure Start) starting DHCPv6"
+	             " as requested by IPv6 router...",
+	             priv->iface);
+
+	ret = dhcp6_start (self, connection, dhcp_opts, &reason);
+	switch (ret) {
+	case NM_ACT_STAGE_RETURN_SUCCESS:
+		/* Shouldn't get this, but handle it anyway */
+		g_warn_if_reached ();
+		nm_device_activate_schedule_stage4_ip6_config_get (self);
+		break;
+	case NM_ACT_STAGE_RETURN_POSTPONE:
+		/* Success; wait for DHCPv6 to complete */
+		break;
+	default:
+		nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);
+		break;
 	}
 }
 
 static void
 ip6_config_changed (NMIP6Manager *ip6_manager,
-					const char *iface,
-					gpointer user_data)
+                    const char *iface,
+                    guint dhcp_opts,
+                    gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
 
@@ -561,49 +628,58 @@ ip6_config_changed (NMIP6Manager *ip6_manager,
 	nm_device_activate_schedule_stage4_ip6_config_get (self);
 }
 
+static gboolean
+ip6_method_matches (NMConnection *connection, const char *match)
+{
+	NMSettingIP6Config *s_ip6;
+	const char *method = NULL;
+
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
+	if (s_ip6)
+		method = nm_setting_ip6_config_get_method (s_ip6);
+
+	return method && !strcmp (method, match);
+}
+
 static void
-nm_device_setup_ip6 (NMDevice *self)
+addrconf6_setup (NMDevice *self)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	NMActRequest *req;
 	NMConnection *connection;
-	const char *ip_iface, *method = NULL;
+	const char *ip_iface;
 	NMSettingIP6Config *s_ip6;
 
+	priv->ip6_waiting_for_config = FALSE;
+	priv->ip6_dhcp_opt = IP6_DHCP_OPT_NONE;
+
 	req = nm_device_get_act_request (self);
-	if (!req)
-		return;
+	g_assert (req);
 	connection = nm_act_request_get_connection (req);
-	if (!connection)
-		return;
-
-	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
-	if (s_ip6)
-		method = nm_setting_ip6_config_get_method (s_ip6);
+	g_assert (connection);
 
-	if (!method || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE))
+	if (!ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_AUTO))
 		return;
 
 	if (!priv->ip6_manager) {
 		priv->ip6_manager = nm_ip6_manager_get ();
 		priv->ip6_addrconf_sigid = g_signal_connect (priv->ip6_manager,
-													 "addrconf-complete",
-													 G_CALLBACK (ip6_addrconf_complete),
-													 self);
+		                                             "addrconf-complete",
+		                                             G_CALLBACK (ip6_addrconf_complete),
+		                                             self);
 		priv->ip6_config_changed_sigid = g_signal_connect (priv->ip6_manager,
-														   "config-changed",
-														   G_CALLBACK (ip6_config_changed),
-														   self);
+		                                                   "config-changed",
+		                                                   G_CALLBACK (ip6_config_changed),
+		                                                   self);
 	}
 
-	priv->ip6_waiting_for_config = FALSE;
-
 	ip_iface = nm_device_get_ip_iface (self);
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
 	nm_ip6_manager_prepare_interface (priv->ip6_manager, ip_iface, s_ip6);
 }
 
 static void
-nm_device_cleanup_ip6 (NMDevice *self)
+addrconf6_cleanup (NMDevice *self)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
@@ -625,6 +701,13 @@ nm_device_cleanup_ip6 (NMDevice *self)
 	priv->ip6_manager = NULL;
 }
 
+static NMActStageReturn
+real_act_stage1_prepare (NMDevice *self, NMDeviceStateReason *reason)
+{
+	addrconf6_setup (self);
+	return NM_ACT_STAGE_RETURN_SUCCESS;
+}
+
 /*
  * nm_device_activate_stage1_device_prepare
  *
@@ -635,6 +718,7 @@ static gboolean
 nm_device_activate_stage1_device_prepare (gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	const char *iface;
 	NMActStageReturn ret;
 	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
@@ -642,12 +726,12 @@ nm_device_activate_stage1_device_prepare (gpointer user_data)
 	/* Clear the activation source ID now that this stage has run */
 	activation_source_clear (self, FALSE, 0);
 
+	priv->ip4_ready = priv->ip6_ready = FALSE;
+
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 1 of 5 (Device Prepare) started...", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 1 of 5 (Device Prepare) started...", iface);
 	nm_device_state_changed (self, NM_DEVICE_STATE_PREPARE, NM_DEVICE_STATE_REASON_NONE);
 
-	nm_device_setup_ip6 (self);
-
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage1_prepare (self, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
 		goto out;
@@ -660,7 +744,7 @@ nm_device_activate_stage1_device_prepare (gpointer user_data)
 	nm_device_activate_schedule_stage2_device_config (self);
 
 out:
-	nm_info ("Activation (%s) Stage 1 of 5 (Device Prepare) complete.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 1 of 5 (Device Prepare) complete.", iface);
 	return FALSE;
 }
 
@@ -683,15 +767,8 @@ nm_device_activate_schedule_stage1_device_prepare (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage1_device_prepare, 0);
 
-	nm_info ("Activation (%s) Stage 1 of 5 (Device Prepare) scheduled...",
-	         nm_device_get_iface (self));
-}
-
-static NMActStageReturn
-real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
-{
-	/* Nothing to do */
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 1 of 5 (Device Prepare) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 static NMActStageReturn
@@ -721,7 +798,7 @@ nm_device_activate_stage2_device_config (gpointer user_data)
 	activation_source_clear (self, FALSE, 0);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) starting...", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) starting...", iface);
 	nm_device_state_changed (self, NM_DEVICE_STATE_CONFIG, NM_DEVICE_STATE_REASON_NONE);
 
 	if (!nm_device_bring_up (self, FALSE, &no_firmware)) {
@@ -742,12 +819,12 @@ nm_device_activate_stage2_device_config (gpointer user_data)
 	}
 	g_assert (ret == NM_ACT_STAGE_RETURN_SUCCESS);	
 
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) successful.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) successful.", iface);
 
 	nm_device_activate_schedule_stage3_ip_config_start (self);
 
 out:
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) complete.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) complete.", iface);
 	return FALSE;
 }
 
@@ -770,7 +847,7 @@ nm_device_activate_schedule_stage2_device_config (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage2_device_config, 0);
 
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) scheduled...",
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) scheduled...",
 	         nm_device_get_iface (self));
 }
 
@@ -799,9 +876,9 @@ aipd_cleanup (NMDevice *self)
 		kill (priv->aipd_pid, SIGKILL);
 
 		/* ensure the child is reaped */
-		nm_debug ("waiting for ppp pid %d to exit", priv->aipd_pid);
+		nm_log_dbg (LOGD_AUTOIP4, "waiting for avahi-autoipd pid %d to exit", priv->aipd_pid);
 		waitpid (priv->aipd_pid, NULL, 0);
-		nm_debug ("ppp pid %d cleaned up", priv->aipd_pid);
+		nm_log_dbg (LOGD_AUTOIP4, "avahi-autoip pid %d cleaned up", priv->aipd_pid);
 
 		priv->aipd_pid = -1;
 	}
@@ -845,7 +922,7 @@ handle_autoip_change (NMDevice *self, NMDeviceStateReason *reason)
 
 	config = aipd_get_ip4_config (self, reason);
 	if (!config) {
-		nm_warning ("failed to get autoip config for rebind");
+		nm_log_err (LOGD_AUTOIP4, "failed to get autoip config for rebind");
 		return FALSE;
 	}
 
@@ -857,7 +934,7 @@ handle_autoip_change (NMDevice *self, NMDeviceStateReason *reason)
 	g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP4_CONFIG, config);
 
 	if (!nm_device_set_ip4_config (self, config, FALSE, reason)) {
-		nm_warning ("(%s): failed to update IP4 config in response to autoip event.",
+		nm_log_err (LOGD_AUTOIP4, "(%s): failed to update IP4 config in response to autoip event.",
 		            nm_device_get_iface (self));
 		return FALSE;
 	}
@@ -906,14 +983,14 @@ nm_device_handle_autoip4_event (NMDevice *self,
 		NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
 		if (inet_pton (AF_INET, address, &ip) <= 0) {
-			nm_warning ("(%s): invalid address %s received from avahi-autoipd.",
+			nm_log_err (LOGD_AUTOIP4, "(%s): invalid address %s received from avahi-autoipd.",
 			            iface, address);
 			nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_ERROR);
 			return;
 		}
 
 		if ((ip.s_addr & IPV4LL_NETMASK) != IPV4LL_NETWORK) {
-			nm_warning ("(%s): invalid address %s received from avahi-autoipd.",
+			nm_log_err (LOGD_AUTOIP4, "(%s): invalid address %s received from avahi-autoipd (not link-local).",
 			            iface, address);
 			nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_ERROR);
 			return;
@@ -922,7 +999,7 @@ nm_device_handle_autoip4_event (NMDevice *self,
 		switch (state) {
 		case NM_DEVICE_STATE_IP_CONFIG:
 			if (priv->aipd_addr) {
-				nm_warning ("(%s): already have autoip address!", iface);
+				nm_log_warn (LOGD_AUTOIP4, "(%s): already have autoip address!", iface);
 				return;
 			}
 
@@ -936,12 +1013,12 @@ nm_device_handle_autoip4_event (NMDevice *self,
 				nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);
 			break;
 		default:
-			nm_warning ("(%s): unexpected avahi-autoip event %s for %s.",
+			nm_log_warn (LOGD_AUTOIP4, "(%s): unexpected avahi-autoip event %s for %s.",
 			            iface, event, address);
 			break;
 		}
 	} else {
-		nm_warning ("%s: autoip address %s no longer valid because '%s'.",
+		nm_log_warn (LOGD_AUTOIP4, "(%s): autoip address %s no longer valid because '%s'.",
 		            iface, address, event);
 
 		/* The address is gone; terminate the connection or fail activation */
@@ -963,14 +1040,18 @@ aipd_watch_cb (GPid pid, gint status, gpointer user_data)
 
 	iface = nm_device_get_iface (self);
 
-	if (WIFEXITED (status))
-		nm_warning ("%s: avahi-autoipd exited with error code %d", iface, WEXITSTATUS (status));
-	else if (WIFSTOPPED (status)) 
-		nm_warning ("%s: avahi-autoipd stopped unexpectedly with signal %d", iface, WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		nm_warning ("%s: avahi-autoipd died with signal %d", iface, WTERMSIG (status));
-	else
-		nm_warning ("%s: avahi-autoipd died from an unknown cause", iface);
+	if (WIFEXITED (status)) {
+		nm_log_dbg (LOGD_AUTOIP4, "(%s): avahi-autoipd exited with error code %d",
+		            iface, WEXITSTATUS (status));
+	} else if (WIFSTOPPED (status)) {
+		nm_log_warn (LOGD_AUTOIP4, "(%s): avahi-autoipd stopped unexpectedly with signal %d",
+		            iface, WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_warn (LOGD_AUTOIP4, "(%s): avahi-autoipd died with signal %d",
+		             iface, WTERMSIG (status));
+	} else {
+		nm_log_warn (LOGD_AUTOIP4, "(%s): avahi-autoipd died from an unknown cause", iface);
+	}
 
 	aipd_cleanup (self);
 
@@ -989,7 +1070,7 @@ aipd_timeout_cb (gpointer user_data)
 		return FALSE;
 	priv->aipd_timeout = 0;
 
-	nm_info ("%s: avahi-autoipd timed out.", nm_device_get_iface (self));
+	nm_log_info (LOGD_AUTOIP4, "(%s): avahi-autoipd timed out.", nm_device_get_iface (self));
 	aipd_cleanup (self);
 
 	if (nm_device_get_state (self) == NM_DEVICE_STATE_IP_CONFIG)
@@ -1057,6 +1138,169 @@ aipd_exec (NMDevice *self, GError **error)
 	return TRUE;
 }
 
+static void
+dhcp4_add_option_cb (gpointer key, gpointer value, gpointer user_data)
+{
+	nm_dhcp4_config_add_option (NM_DHCP4_CONFIG (user_data),
+	                            (const char *) key,
+	                            (const char *) value);
+}
+
+static void
+dhcp6_add_option_cb (gpointer key, gpointer value, gpointer user_data)
+{
+	nm_dhcp6_config_add_option (NM_DHCP6_CONFIG (user_data),
+	                            (const char *) key,
+	                            (const char *) value);
+}
+
+static void
+handle_dhcp_lease_change (NMDevice *device, gboolean ipv6)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
+	NMIP4Config *ip4_config;
+	NMSettingIP4Config *s_ip4;
+	NMIP6Config *ip6_config;
+	NMSettingIP6Config *s_ip6;
+	NMConnection *connection;
+	NMActRequest *req;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+	gboolean assumed;
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
+	assumed = nm_act_request_get_assumed (req);
+
+	if (ipv6) {
+		ip6_config = nm_dhcp_client_get_ip6_config (priv->dhcp6_client, FALSE);
+		if (!ip6_config) {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to get DHCPv6 config for rebind",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
+			return;
+		}
+
+		s_ip6 = NM_SETTING_IP6_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG));
+		nm_utils_merge_ip6_config (ip6_config, s_ip6);
+
+		g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP6_CONFIG, ip6_config);
+
+		if (nm_device_set_ip6_config (device, ip6_config, assumed, &reason)) {
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+			nm_dhcp_client_foreach_option (priv->dhcp6_client,
+			                               dhcp6_add_option_cb,
+			                               priv->dhcp6_config);
+		} else {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to update IPv6 config in response to DHCP event.",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+		}
+	} else {
+		ip4_config = nm_dhcp_client_get_ip4_config (priv->dhcp4_client, FALSE);
+		if (!ip4_config) {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to get DHCPv4 config for rebind",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
+			return;
+		}
+
+		s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
+		nm_utils_merge_ip4_config (ip4_config, s_ip4);
+
+		g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP4_CONFIG, ip4_config);
+
+		if (nm_device_set_ip4_config (device, ip4_config, assumed, &reason)) {
+			nm_dhcp4_config_reset (priv->dhcp4_config);
+			nm_dhcp_client_foreach_option (priv->dhcp4_client,
+			                               dhcp4_add_option_cb,
+			                               priv->dhcp4_config);
+		} else {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to update IPv4 config in response to DHCP event.",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+		}
+	}
+}
+
+static void
+dhcp_state_changed (NMDHCPClient *client,
+					NMDHCPState state,
+					gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
+	NMDeviceState dev_state;
+	gboolean ipv6;
+
+	ipv6 = nm_dhcp_client_get_ipv6 (client);
+	dev_state = nm_device_get_state (device);
+
+	switch (state) {
+	case DHC_BOUND4:     /* lease obtained */
+	case DHC_BOUND6:
+	case DHC_RENEW4:     /* lease renewed */
+	case DHC_RENEW6:     /* lease renewed */
+	case DHC_REBOOT:     /* have valid lease, but now obtained a different one */
+	case DHC_REBIND4:    /* new, different lease */
+	case DHC_REBIND6:    /* new, different lease */
+		if (dev_state == NM_DEVICE_STATE_IP_CONFIG) {
+			if (ipv6)
+				nm_device_activate_schedule_stage4_ip6_config_get (device);
+			else
+				nm_device_activate_schedule_stage4_ip4_config_get (device);
+		} else if (dev_state == NM_DEVICE_STATE_ACTIVATED)
+			handle_dhcp_lease_change (device, ipv6);
+		break;
+	case DHC_TIMEOUT: /* timed out contacting DHCP server */
+		if (ipv6) {
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+			if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
+				nm_device_activate_schedule_stage4_ip6_config_timeout (device);
+		} else {
+			nm_dhcp4_config_reset (priv->dhcp4_config);
+			if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
+				nm_device_activate_schedule_stage4_ip4_config_timeout (device);
+		}
+		break;
+	case DHC_FAIL: /* all attempts to contact server timed out, sleeping */
+	case DHC_ABEND: /* dhclient exited abnormally */
+	case DHC_END: /* dhclient exited normally */
+		if (ipv6)
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+		else
+			nm_dhcp4_config_reset (priv->dhcp4_config);
+
+		/* dhclient quit and can't get/renew a lease; so kill the connection */
+		if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DHCP_FAILED);
+		else if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED)
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+dhcp_timeout (NMDHCPClient *client, gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+
+	if (!nm_device_get_act_request (device))
+		return;
+
+	nm_dhcp_client_stop (client);
+
+	if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG) {
+		if (nm_dhcp_client_get_ipv6 (client))
+			nm_device_activate_schedule_stage4_ip6_config_timeout (device);
+		else
+			nm_device_activate_schedule_stage4_ip4_config_timeout (device);
+	}
+}
+
 static NMActStageReturn
 real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 {
@@ -1090,22 +1334,34 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 
 	if (!s_ip4 || !method || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)) {
 		NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-		gboolean success;
 		guint8 *anycast = NULL;
 
+		/* Begin a DHCP transaction on the interface */
+
 		if (priv->dhcp_anycast_address)
 			anycast = priv->dhcp_anycast_address->data;
 
-		/* Begin a DHCP transaction on the interface */
-		nm_device_set_use_dhcp (self, TRUE);
+		/* Clear old exported DHCP options */
+		if (priv->dhcp4_config)
+			g_object_unref (priv->dhcp4_config);
+		priv->dhcp4_config = nm_dhcp4_config_new ();
 
-		/* DHCP manager will cancel any transaction already in progress and we do not
-		   want to cancel this activation if we get "down" state from that. */
-		g_signal_handler_block (priv->dhcp_manager, priv->dhcp_state_sigid);
-		success = nm_dhcp_manager_begin_transaction (priv->dhcp_manager, ip_iface, uuid, s_ip4, priv->dhcp_timeout, anycast);
-		g_signal_handler_unblock (priv->dhcp_manager, priv->dhcp_state_sigid);
+		priv->dhcp4_client = nm_dhcp_manager_start_ip4 (priv->dhcp_manager,
+		                                                ip_iface,
+		                                                uuid,
+		                                                s_ip4,
+		                                                priv->dhcp_timeout,
+		                                                anycast);
+		if (priv->dhcp4_client) {
+			priv->dhcp4_state_sigid = g_signal_connect (priv->dhcp4_client,
+			                                            "state-changed",
+			                                            G_CALLBACK (dhcp_state_changed),
+			                                            self);
+			priv->dhcp4_timeout_sigid = g_signal_connect (priv->dhcp4_client,
+			                                              "timeout",
+			                                              G_CALLBACK (dhcp_timeout),
+			                                              self);
 
-		if (success) {
 			/* DHCP devices will be notified by the DHCP manager when
 			 * stuff happens.	
 			 */
@@ -1120,12 +1376,14 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 
 		/* Start avahi-autoipd */
 		if (aipd_exec (self, &error)) {
-			nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) started"
-			         " avahi-autoipd...", iface);
+			nm_log_info (LOGD_DEVICE | LOGD_AUTOIP4,
+			             "Activation (%s) Stage 3 of 5 (IP Configure Start) started"
+			             " avahi-autoipd...", iface);
 			ret = NM_ACT_STAGE_RETURN_POSTPONE;
 		} else {
-			nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) failed"
-			         " to start avahi-autoipd: %s", iface, error->message);
+			nm_log_info (LOGD_DEVICE | LOGD_AUTOIP4,
+			             "Activation (%s) Stage 3 of 5 (IP Configure Start) failed"
+			             " to start avahi-autoipd: %s", iface, error->message);
 			g_error_free (error);
 			aipd_cleanup (self);
 			*reason = NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED;
@@ -1137,23 +1395,98 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 }
 
 static NMActStageReturn
+dhcp6_start (NMDevice *self,
+             NMConnection *connection,
+             guint32 dhcp_opt,
+             NMDeviceStateReason *reason)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;
+	guint8 *anycast = NULL;
+	NMSettingIP6Config *s_ip6;
+	NMSettingConnection *s_con;
+	const char *uuid;
+	const char *ip_iface;
+
+	if (!connection) {
+		NMActRequest *req;
+
+		req = nm_device_get_act_request (self);
+		g_assert (req);
+		connection = nm_act_request_get_connection (req);
+		g_assert (connection);
+	}
+
+	/* Begin a DHCP transaction on the interface */
+
+	if (priv->dhcp_anycast_address)
+		anycast = priv->dhcp_anycast_address->data;
+
+	/* Clear old exported DHCP options */
+	if (priv->dhcp6_config)
+		g_object_unref (priv->dhcp6_config);
+	priv->dhcp6_config = nm_dhcp6_config_new ();
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_assert (s_con);
+	uuid = nm_setting_connection_get_uuid (s_con);
+
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
+
+	ip_iface = nm_device_get_ip_iface (self);
+	priv->dhcp6_client = nm_dhcp_manager_start_ip6 (priv->dhcp_manager,
+	                                                ip_iface,
+	                                                uuid,
+	                                                s_ip6,
+	                                                priv->dhcp_timeout,
+	                                                anycast,
+	                                                (dhcp_opt == IP6_DHCP_OPT_OTHERCONF) ? TRUE : FALSE);
+	if (priv->dhcp6_client) {
+		priv->dhcp6_state_sigid = g_signal_connect (priv->dhcp6_client,
+		                                            "state-changed",
+		                                            G_CALLBACK (dhcp_state_changed),
+		                                            self);
+		priv->dhcp6_timeout_sigid = g_signal_connect (priv->dhcp6_client,
+		                                              "timeout",
+		                                              G_CALLBACK (dhcp_timeout),
+		                                              self);
+
+		/* DHCP devices will be notified by the DHCP manager when stuff happens */
+		ret = NM_ACT_STAGE_RETURN_POSTPONE;
+	} else {
+		*reason = NM_DEVICE_STATE_REASON_DHCP_START_FAILED;
+		ret = NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	return ret;
+}
+
+static NMActStageReturn
 real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-	const char *ip_iface = nm_device_get_ip_iface (self);
+	const char *ip_iface;
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
+	NMActRequest *req;
+	NMConnection *connection;
 
 	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
-	/* If we are ignoring IPv6 on this interface then we can go right
-	 * to stage 4.
-	 */
-	if (!priv->ip6_manager)
-		return NM_ACT_STAGE_RETURN_SUCCESS;
+	req = nm_device_get_act_request (self);
+	g_assert (req);
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
 
-	priv->ip6_waiting_for_config = TRUE;
-	nm_ip6_manager_begin_addrconf (priv->ip6_manager, ip_iface);
+	ip_iface = nm_device_get_ip_iface (self);
+
+	if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
+		priv->ip6_waiting_for_config = TRUE;
+		nm_ip6_manager_begin_addrconf (priv->ip6_manager, ip_iface);
+		ret = NM_ACT_STAGE_RETURN_POSTPONE;
+	} else if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_DHCP))
+		ret = dhcp6_start (self, connection, IP6_DHCP_OPT_MANAGED, reason);
 
-	return NM_ACT_STAGE_RETURN_POSTPONE;
+	return ret;
 }
 
 
@@ -1167,7 +1500,6 @@ static gboolean
 nm_device_activate_stage3_ip_config_start (gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	const char *iface;
 	NMActStageReturn ret;
 	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
@@ -1175,10 +1507,8 @@ nm_device_activate_stage3_ip_config_start (gpointer user_data)
 	/* Clear the activation source ID now that this stage has run */
 	activation_source_clear (self, FALSE, 0);
 
-	priv->ip4_ready = priv->ip6_ready = FALSE;
-
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) started...", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) started...", iface);
 	nm_device_state_changed (self, NM_DEVICE_STATE_IP_CONFIG, NM_DEVICE_STATE_REASON_NONE);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage3_ip4_config_start (self, &reason);
@@ -1200,7 +1530,7 @@ nm_device_activate_stage3_ip_config_start (gpointer user_data)
 		g_assert (ret == NM_ACT_STAGE_RETURN_POSTPONE);
 
 out:
-	nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
 	return FALSE;
 }
 
@@ -1222,8 +1552,8 @@ nm_device_activate_schedule_stage3_ip_config_start (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage3_ip_config_start, 0);
 
-	nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) scheduled.",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) scheduled.",
+	             nm_device_get_iface (self));
 }
 
 static GHashTable *shared_ips = NULL;
@@ -1243,7 +1573,7 @@ reserve_shared_ip (void)
 	while (g_hash_table_lookup (shared_ips, GUINT_TO_POINTER (start + count))) {
 		count += ntohl (0x100);
 		if (count > ntohl (0xFE00)) {
-			nm_warning ("%s: ran out of shared IP addresses!", __func__);
+			nm_log_err (LOGD_SHARING, "ran out of shared IP addresses!");
 			return 0;
 		}
 	}
@@ -1283,14 +1613,6 @@ nm_device_new_ip4_shared_config (NMDevice *self, NMDeviceStateReason *reason)
 	return config;
 }
 
-static void
-dhcp4_add_option_cb (gpointer key, gpointer value, gpointer user_data)
-{
-	nm_dhcp4_config_add_option (NM_DHCP4_CONFIG (user_data),
-	                            (const char *) key,
-	                            (const char *) value);
-}
-
 static NMActStageReturn
 real_act_stage4_get_ip4_config (NMDevice *self,
                                 NMIP4Config **config,
@@ -1314,23 +1636,24 @@ real_act_stage4_get_ip4_config (NMDevice *self,
 
 	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
 
-	if (nm_device_get_use_dhcp (self)) {
-		*config = nm_dhcp_manager_get_ip4_config (priv->dhcp_manager, ip_iface);
+	if (priv->dhcp4_client) {
+		/* DHCP */
+		*config = nm_dhcp_client_get_ip4_config (priv->dhcp4_client, FALSE);
 		if (*config) {
 			/* Merge user-defined overrides into the IP4Config to be applied */
 			nm_utils_merge_ip4_config (*config, s_ip4);
 
 			nm_dhcp4_config_reset (priv->dhcp4_config);
-			nm_dhcp_manager_foreach_dhcp4_option (priv->dhcp_manager,
-			                                      ip_iface,
-			                                      dhcp4_add_option_cb,
-			                                      priv->dhcp4_config);
+			nm_dhcp_client_foreach_option (priv->dhcp4_client,
+			                               dhcp4_add_option_cb,
+			                               priv->dhcp4_config);
 
 			/* Notify of new DHCP4 config */
 			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
 		} else
 			*reason = NM_DEVICE_STATE_REASON_DHCP_ERROR;
 	} else {
+		/* Not DHCP */
 		const char *method;
 
 		g_assert (s_ip4);
@@ -1382,7 +1705,9 @@ nm_device_activate_stage4_ip4_config_get (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Get) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Get) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_get_ip4_config (self, &ip4_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE)
@@ -1400,7 +1725,9 @@ nm_device_activate_stage4_ip4_config_get (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Get) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Get) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1423,8 +1750,9 @@ nm_device_activate_schedule_stage4_ip4_config_get (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip4_config_get, AF_INET);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Get) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Get) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 
@@ -1464,7 +1792,9 @@ nm_device_activate_stage4_ip4_config_timeout (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_ip4_config_timeout (self, &ip4_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
@@ -1482,7 +1812,9 @@ nm_device_activate_stage4_ip4_config_timeout (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1505,8 +1837,9 @@ nm_device_activate_schedule_stage4_ip4_config_timeout (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip4_config_timeout, AF_INET);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 static NMActStageReturn
@@ -1514,11 +1847,11 @@ real_act_stage4_get_ip6_config (NMDevice *self,
                                 NMIP6Config **config,
                                 NMDeviceStateReason *reason)
 {
-	NMDevicePrivate *priv;
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;
 	NMConnection *connection;
 	NMSettingIP6Config *s_ip6;
 	const char *ip_iface;
-	const char *method = NULL;
 
 	g_return_val_if_fail (config != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 	g_return_val_if_fail (*config == NULL, NM_ACT_STAGE_RETURN_FAILURE);
@@ -1531,25 +1864,45 @@ real_act_stage4_get_ip6_config (NMDevice *self,
 	g_assert (connection);
 
 	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
-	if (s_ip6)
-		method = nm_setting_ip6_config_get_method (s_ip6);
 
-	if (!method || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
-		*config = NULL;
-		return NM_ACT_STAGE_RETURN_SUCCESS;
-	}
+	if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
+		*config = nm_ip6_manager_get_ip6_config (priv->ip6_manager, ip_iface);
+		if (*config) {
+			/* Merge user-defined overrides into the IP6Config to be applied */
+			nm_utils_merge_ip6_config (*config, s_ip6);
+			ret = NM_ACT_STAGE_RETURN_SUCCESS;
+		} else {
+			*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
+			goto out;
+		}
+	} else if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_DHCP))
+		g_assert (priv->dhcp6_client);  /* sanity check */
 
-	priv = NM_DEVICE_GET_PRIVATE (self);
-	*config = nm_ip6_manager_get_ip6_config (priv->ip6_manager, ip_iface);
-	if (!*config) {
-		*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
-		return NM_ACT_STAGE_RETURN_FAILURE;
-	}
+	/* Autoconf might have triggered DHCPv6 too */
+	if (priv->dhcp6_client) {
+		*config = nm_dhcp_client_get_ip6_config (priv->dhcp6_client, FALSE);
+		if (*config) {
+			/* Merge user-defined overrides into the IP4Config to be applied */
+			nm_utils_merge_ip6_config (*config, s_ip6);
 
-	/* Merge user-defined overrides into the IP6Config to be applied */
-	nm_utils_merge_ip6_config (*config, s_ip6);
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+			nm_dhcp_client_foreach_option (priv->dhcp6_client,
+			                               dhcp6_add_option_cb,
+			                               priv->dhcp6_config);
 
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+			/* Notify of new DHCP4 config */
+			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+			ret = NM_ACT_STAGE_RETURN_SUCCESS;
+		} else {
+			*reason = NM_DEVICE_STATE_REASON_DHCP_ERROR;
+		}
+	} else {
+		*config = NULL;
+		ret = NM_ACT_STAGE_RETURN_SUCCESS;
+	}
+
+out:
+	return ret;
 }
 
 /*
@@ -1571,7 +1924,9 @@ nm_device_activate_stage4_ip6_config_get (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET6);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Get) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Get) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_get_ip6_config (self, &ip6_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE)
@@ -1589,7 +1944,9 @@ nm_device_activate_stage4_ip6_config_get (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET6);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Get) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Get) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1612,8 +1969,9 @@ nm_device_activate_schedule_stage4_ip6_config_get (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip6_config_get, AF_INET6);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Get) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Get) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 
@@ -1625,6 +1983,9 @@ real_act_stage4_ip6_config_timeout (NMDevice *self,
 	g_return_val_if_fail (config != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 	g_return_val_if_fail (*config == NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
+	/* Notify of invalid DHCP6 config object */
+	g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+
 	*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
 	return NM_ACT_STAGE_RETURN_FAILURE;
 }
@@ -1649,7 +2010,9 @@ nm_device_activate_stage4_ip6_config_timeout (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET6);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_ip6_config_timeout (self, &ip6_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
@@ -1667,7 +2030,9 @@ nm_device_activate_stage4_ip6_config_timeout (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET6);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1690,8 +2055,9 @@ nm_device_activate_schedule_stage4_ip6_config_timeout (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip6_config_timeout, AF_INET6);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 static void
@@ -1712,14 +2078,14 @@ share_init (void)
 	char **iter;
 
 	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_forward", "1\n")) {
-		nm_warning ("%s: Error starting IP forwarding: (%d) %s",
-					__func__, errno, strerror (errno));
+		nm_log_err (LOGD_SHARING, "Error starting IP forwarding: (%d) %s",
+					errno, strerror (errno));
 		return FALSE;
 	}
 
 	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_dynaddr", "1\n")) {
-		nm_warning ("%s: Error starting IP forwarding: (%d) %s",
-					__func__, errno, strerror (errno));
+		nm_log_err (LOGD_SHARING, "error starting IP forwarding: (%d) %s",
+					errno, strerror (errno));
 	}
 
 	for (iter = modules; *iter; iter++) {
@@ -1729,9 +2095,9 @@ share_init (void)
 
 		if (!g_spawn_sync ("/", argv, envp, G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
 		                   share_child_setup, NULL, NULL, NULL, &status, &error)) {
-			nm_info ("%s: Error loading NAT module %s: (%d) %s",
-			         __func__, *iter, error ? error->code : 0,
-			         (error && error->message) ? error->message : "unknown");
+			nm_log_err (LOGD_SHARING, "error loading NAT module %s: (%d) %s",
+			            *iter, error ? error->code : 0,
+			            (error && error->message) ? error->message : "unknown");
 			if (error)
 				g_error_free (error);
 		}
@@ -1805,7 +2171,7 @@ start_sharing (NMDevice *self)
 	nm_act_request_set_shared (req, TRUE);
 
 	if (!nm_dnsmasq_manager_start (priv->dnsmasq_manager, ip4_config, &error)) {
-		nm_warning ("(%s/%s): failed to start dnsmasq: %s",
+		nm_log_err (LOGD_SHARING, "(%s/%s): failed to start dnsmasq: %s",
 		            nm_device_get_iface (self), ip_iface, error->message);
 		g_error_free (error);
 		nm_act_request_set_shared (req, FALSE);
@@ -1859,8 +2225,8 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 	activation_source_clear (self, FALSE, 0);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) started...",
-	         iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 5 of 5 (IP Configure Commit) started...",
+	             iface);
 
 	assumed = nm_act_request_get_assumed (priv->act_request);
 
@@ -1870,8 +2236,9 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 	}
 
 	if (ip6_config && !nm_device_set_ip6_config (self, ip6_config, assumed, &reason)) {
-		nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) IPv6 failed",
-				 iface);
+		nm_log_info (LOGD_DEVICE | LOGD_IP6,
+		             "Activation (%s) Stage 5 of 5 (IP Configure Commit) IPv6 failed",
+				     iface);
 	}
 
 	connection = nm_act_request_get_connection (nm_device_get_act_request (self));
@@ -1883,7 +2250,7 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 
 		if (s_ip4 && !strcmp (method, "shared")) {
 			if (!start_sharing (self)) {
-				nm_warning ("Activation (%s) Stage 5 of 5 (IP Configure Commit) start sharing failed.", iface);
+				nm_log_warn (LOGD_SHARING, "Activation (%s) Stage 5 of 5 (IP Configure Commit) start sharing failed.", iface);
 				nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SHARED_START_FAILED);
 				goto out;
 			}
@@ -1893,8 +2260,8 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 	nm_device_state_changed (self, NM_DEVICE_STATE_ACTIVATED, NM_DEVICE_STATE_REASON_NONE);
 
 out:
-	nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) complete.",
-	         iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 5 of 5 (IP Configure Commit) complete.",
+	             iface);
 
 	/* Balance IP config creation; device takes ownership in set_ip*_config() */
 	if (ip4_config)
@@ -1936,8 +2303,9 @@ nm_device_activate_schedule_stage5_ip_config_commit (NMDevice *self, int family)
 
 	activation_source_schedule (self, nm_device_activate_stage5_ip_config_commit, 0);
 
-	nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE,
+	             "Activation (%s) Stage 5 of 5 (IP Configure Commit) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 
@@ -1977,15 +2345,98 @@ delayed_transitions_clear (NMDevice *self)
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
 	if (priv->failed_to_disconnected_id) {
+		nm_log_dbg (LOGD_DEVICE, "(%s): clearing failed->disconnected transition",
+		            nm_device_get_iface (self));
 		g_source_remove (priv->failed_to_disconnected_id);
 		priv->failed_to_disconnected_id = 0;
 	}
 	if (priv->unavailable_to_disconnected_id) {
+		nm_log_dbg (LOGD_DEVICE, "(%s): clearing unavailable->disconnected transition",
+		            nm_device_get_iface (self));
 		g_source_remove (priv->unavailable_to_disconnected_id);
 		priv->unavailable_to_disconnected_id = 0;
 	}
 }
 
+static void
+dhcp4_cleanup (NMDevice *self, gboolean stop)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (priv->dhcp4_config) {
+		g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
+		g_object_unref (priv->dhcp4_config);
+		priv->dhcp4_config = NULL;
+	}
+
+	if (priv->dhcp4_client) {
+		/* Stop any ongoing DHCP transaction on this device */
+		if (priv->dhcp4_state_sigid) {
+			g_signal_handler_disconnect (priv->dhcp4_client, priv->dhcp4_state_sigid);
+			priv->dhcp4_state_sigid = 0;
+		}
+
+		if (priv->dhcp4_timeout_sigid) {
+			g_signal_handler_disconnect (priv->dhcp4_client, priv->dhcp4_timeout_sigid);
+			priv->dhcp4_timeout_sigid = 0;
+		}
+
+		if (stop)
+			nm_dhcp_client_stop (priv->dhcp4_client);
+
+		g_object_unref (priv->dhcp4_client);
+		priv->dhcp4_client = NULL;
+	}
+}
+
+static void
+dhcp6_cleanup (NMDevice *self, gboolean stop)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (priv->dhcp6_config) {
+		g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+		g_object_unref (priv->dhcp6_config);
+		priv->dhcp6_config = NULL;
+	}
+
+	if (priv->dhcp6_client) {
+		if (priv->dhcp6_state_sigid) {
+			g_signal_handler_disconnect (priv->dhcp6_client, priv->dhcp6_state_sigid);
+			priv->dhcp6_state_sigid = 0;
+		}
+
+		if (priv->dhcp6_timeout_sigid) {
+			g_signal_handler_disconnect (priv->dhcp6_client, priv->dhcp6_timeout_sigid);
+			priv->dhcp6_timeout_sigid = 0;
+		}
+
+		if (stop)
+			nm_dhcp_client_stop (priv->dhcp6_client);
+
+		g_object_unref (priv->dhcp6_client);
+		priv->dhcp6_client = NULL;
+	}
+}
+
+static void
+dnsmasq_cleanup (NMDevice *self)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (!priv->dnsmasq_manager)
+		return;
+
+	if (priv->dnsmasq_state_id) {
+		g_signal_handler_disconnect (priv->dnsmasq_manager, priv->dnsmasq_state_id);
+		priv->dnsmasq_state_id = 0;
+	}
+
+	nm_dnsmasq_manager_stop (priv->dnsmasq_manager);
+	g_object_unref (priv->dnsmasq_manager);
+	priv->dnsmasq_manager = NULL;
+}
+
 /*
  * nm_device_deactivate_quickly
  *
@@ -2010,27 +2461,11 @@ nm_device_deactivate_quickly (NMDevice *self)
 	/* Clear any delayed transitions */
 	delayed_transitions_clear (self);
 
-	/* Stop any ongoing DHCP transaction on this device */
-	if (nm_device_get_act_request (self)) {
-		if (nm_device_get_use_dhcp (self)) {
-			nm_dhcp_manager_cancel_transaction (priv->dhcp_manager, nm_device_get_ip_iface (self));
-			nm_device_set_use_dhcp (self, FALSE);
-			/* Notify of invalid DHCP4 config */
-			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
-		} else if (priv->dnsmasq_manager) {
-			if (priv->dnsmasq_state_id) {
-				g_signal_handler_disconnect (priv->dnsmasq_manager, priv->dnsmasq_state_id);
-				priv->dnsmasq_state_id = 0;
-			}
-
-			nm_dnsmasq_manager_stop (priv->dnsmasq_manager);
-			g_object_unref (priv->dnsmasq_manager);
-			priv->dnsmasq_manager = NULL;
-		}
-	}
-
+	dhcp4_cleanup (self, TRUE);
+	dhcp6_cleanup (self, TRUE);
+	addrconf6_cleanup (self);
+	dnsmasq_cleanup (self);
 	aipd_cleanup (self);
-	nm_device_cleanup_ip6 (self);
 
 	/* Call device type-specific deactivation */
 	if (NM_DEVICE_GET_CLASS (self)->deactivate_quickly)
@@ -2056,9 +2491,8 @@ nm_device_deactivate (NMDeviceInterface *device, NMDeviceStateReason reason)
 
 	g_return_if_fail (self != NULL);
 
-	nm_info ("(%s): deactivating device (reason: %d).",
-	         nm_device_get_iface (self),
-	         reason);
+	nm_log_info (LOGD_DEVICE, "(%s): deactivating device (reason: %d).",
+	             nm_device_get_iface (self), reason);
 
 	nm_device_deactivate_quickly (self);
 
@@ -2246,193 +2680,20 @@ nm_device_can_interrupt_activation (NMDevice *self)
 
 /* IP Configuration stuff */
 
-static void
-handle_dhcp_lease_change (NMDevice *device)
-{
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
-	NMIP4Config *config;
-	NMSettingIP4Config *s_ip4;
-	NMConnection *connection;
-	NMActRequest *req;
-	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
-	const char *ip_iface;
-	gboolean assumed;
-
-	if (!nm_device_get_use_dhcp (device)) {
-		nm_warning ("got DHCP rebind for device that wasn't using DHCP.");
-		return;
-	}
-
-	ip_iface = nm_device_get_ip_iface (device);
-
-	config = nm_dhcp_manager_get_ip4_config (priv->dhcp_manager, ip_iface);
-	if (!config) {
-		nm_warning ("failed to get DHCP config for rebind");
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
-		return;
-	}
-
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-
-	s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
-	nm_utils_merge_ip4_config (config, s_ip4);
-
-	g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP4_CONFIG, config);
-
-	assumed = nm_act_request_get_assumed (req);
-	if (nm_device_set_ip4_config (device, config, assumed, &reason)) {
-		nm_dhcp4_config_reset (priv->dhcp4_config);
-		nm_dhcp_manager_foreach_dhcp4_option (priv->dhcp_manager,
-		                                      ip_iface,
-		                                      dhcp4_add_option_cb,
-		                                      priv->dhcp4_config);
-	} else {
-		nm_warning ("Failed to update IP4 config in response to DHCP event.");
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
-	}
-}
-
-static void
-dhcp_state_changed (NMDHCPManager *dhcp_manager,
-					const char *iface,
-					NMDHCPState state,
-					gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
-	NMDeviceState dev_state;
-
-	if (strcmp (nm_device_get_ip_iface (device), iface) != 0)
-		return;
-
-	if (!nm_device_get_act_request (device))
-		return;
-
-	dev_state = nm_device_get_state (device);
-
-	switch (state) {
-	case DHC_BOUND:	/* lease obtained */
-	case DHC_RENEW:	/* lease renewed */
-	case DHC_REBOOT:	/* have valid lease, but now obtained a different one */
-	case DHC_REBIND:	/* new, different lease */
-		if (dev_state == NM_DEVICE_STATE_IP_CONFIG)
-			nm_device_activate_schedule_stage4_ip4_config_get (device);
-		else if (dev_state == NM_DEVICE_STATE_ACTIVATED)
-			handle_dhcp_lease_change (device);
-		break;
-	case DHC_TIMEOUT: /* timed out contacting DHCP server */
-		nm_dhcp4_config_reset (priv->dhcp4_config);
-
-		if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
-			nm_device_activate_schedule_stage4_ip4_config_timeout (device);
-		break;
-	case DHC_FAIL: /* all attempts to contact server timed out, sleeping */
-	case DHC_ABEND: /* dhclient exited abnormally */
-	case DHC_END: /* dhclient exited normally */
-		nm_dhcp4_config_reset (priv->dhcp4_config);
-
-		if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG) {
-			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DHCP_FAILED);
-		} else if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED) {
-			if (nm_device_get_use_dhcp (device)) {
-				/* dhclient quit and therefore can't renew our lease, kill the conneciton */
-				nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
-			}
-		}
-		break;
-	default:
-		break;
-	}
-}
-
-static void
-dhcp_timeout (NMDHCPManager *dhcp_manager,
-              const char *iface,
-              gpointer user_data)
-{
-	NMDevice * device = NM_DEVICE (user_data);
-
-	if (strcmp (nm_device_get_ip_iface (device), iface) != 0)
-		return;
-
-	if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
-		nm_device_activate_schedule_stage4_ip4_config_timeout (device);
-}
-
-gboolean
-nm_device_get_use_dhcp (NMDevice *self)
-{
-	g_return_val_if_fail (NM_IS_DEVICE (self), FALSE);
-
-	return NM_DEVICE_GET_PRIVATE (self)->dhcp_manager ? TRUE : FALSE;
-}
-
-void
-nm_device_set_use_dhcp (NMDevice *self,
-                        gboolean use_dhcp)
-{
-	NMDevicePrivate *priv;
-
-	g_return_if_fail (NM_IS_DEVICE (self));
-
-	priv = NM_DEVICE_GET_PRIVATE (self);
-
-	if (use_dhcp) {
-		/* New exported DHCP4 config */
-		if (priv->dhcp4_config)
-			g_object_unref (priv->dhcp4_config);
-		priv->dhcp4_config = nm_dhcp4_config_new ();
-
-		if (!priv->dhcp_manager) {
-			priv->dhcp_manager = nm_dhcp_manager_get ();
-			priv->dhcp_state_sigid = g_signal_connect (priv->dhcp_manager,
-			                                           "state-changed",
-			                                           G_CALLBACK (dhcp_state_changed),
-			                                           self);
-			priv->dhcp_timeout_sigid = g_signal_connect (priv->dhcp_manager,
-			                                             "timeout",
-			                                             G_CALLBACK (dhcp_timeout),
-			                                             self);
-		}
-	} else {
-		if (priv->dhcp4_config) {
-			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
-			g_object_unref (priv->dhcp4_config);
-			priv->dhcp4_config = NULL;
-		}
-
-		if (priv->dhcp_manager) {
-			g_signal_handler_disconnect (priv->dhcp_manager, priv->dhcp_state_sigid);
-			priv->dhcp_state_sigid = 0;
-			g_signal_handler_disconnect (priv->dhcp_manager, priv->dhcp_timeout_sigid);
-			priv->dhcp_timeout_sigid = 0;
-			g_object_unref (priv->dhcp_manager);
-			priv->dhcp_manager = NULL;
-		}
-	}
-}
-
 NMDHCP4Config *
 nm_device_get_dhcp4_config (NMDevice *self)
 {
-	NMDevicePrivate *priv;
-
-	g_return_val_if_fail (NM_IS_DEVICE (self), FALSE);
-
-	priv = NM_DEVICE_GET_PRIVATE (self);
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
 
-	if (priv->dhcp_manager)
-		return priv->dhcp4_config;
-	return NULL;
+	return NM_DEVICE_GET_PRIVATE (self)->dhcp4_config;
 }
 
 NMIP4Config *
 nm_device_get_ip4_config (NMDevice *self)
 {
 	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
 
 	return NM_DEVICE_GET_PRIVATE (self)->ip4_config;
 }
@@ -2527,7 +2788,7 @@ nm_device_update_ip4_address (NMDevice *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_err (LOGD_IP4, "couldn't open control socket.");
 		return;
 	}
 
@@ -2602,10 +2863,20 @@ nm_device_set_ip6_config (NMDevice *self,
 	return success;
 }
 
+NMDHCP6Config *
+nm_device_get_dhcp6_config (NMDevice *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
+
+	return NM_DEVICE_GET_PRIVATE (self)->dhcp6_config;
+}
+
 NMIP6Config *
 nm_device_get_ip6_config (NMDevice *self)
 {
 	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
 
 	return NM_DEVICE_GET_PRIVATE (self)->ip6_config;
 }
@@ -2632,7 +2903,7 @@ nm_device_hw_bring_up (NMDevice *self, gboolean block, gboolean *no_firmware)
 	if (nm_device_hw_is_up (self))
 		goto out;
 
-	nm_info ("(%s): bringing up device.", nm_device_get_iface (self));
+	nm_log_info (LOGD_HW, "(%s): bringing up device.", nm_device_get_iface (self));
 
 	if (NM_DEVICE_GET_CLASS (self)->hw_bring_up) {
 		success = NM_DEVICE_GET_CLASS (self)->hw_bring_up (self, no_firmware);
@@ -2645,7 +2916,7 @@ nm_device_hw_bring_up (NMDevice *self, gboolean block, gboolean *no_firmware)
 		g_usleep (200);
 
 	if (!nm_device_hw_is_up (self)) {
-		nm_warning ("(%s): device not up after timeout!", nm_device_get_iface (self));
+		nm_log_warn (LOGD_HW, "(%s): device not up after timeout!", nm_device_get_iface (self));
 		return FALSE;
 	}
 
@@ -2668,7 +2939,7 @@ nm_device_hw_take_down (NMDevice *self, gboolean block)
 	if (!nm_device_hw_is_up (self))
 		return;
 
-	nm_info ("(%s): taking down device.", nm_device_get_iface (self));
+	nm_log_info (LOGD_HW, "(%s): taking down device.", nm_device_get_iface (self));
 
 	if (NM_DEVICE_GET_CLASS (self)->hw_take_down)
 		NM_DEVICE_GET_CLASS (self)->hw_take_down (self);
@@ -2691,7 +2962,7 @@ nm_device_bring_up (NMDevice *self, gboolean block, gboolean *no_firmware)
 	if (nm_device_is_up (self))
 		return TRUE;
 
-	nm_info ("(%s): preparing device.", nm_device_get_iface (self));
+	nm_log_info (LOGD_HW, "(%s): preparing device.", nm_device_get_iface (self));
 
 	if (NM_DEVICE_GET_CLASS (self)->bring_up)
 		success = NM_DEVICE_GET_CLASS (self)->bring_up (self);
@@ -2708,7 +2979,7 @@ nm_device_take_down (NMDevice *self, gboolean block, NMDeviceStateReason reason)
 		nm_device_interface_deactivate (NM_DEVICE_INTERFACE (self), reason);
 
 	if (nm_device_is_up (self)) {
-		nm_info ("(%s): cleaning up...", nm_device_get_iface (self));
+		nm_log_info (LOGD_HW, "(%s): cleaning up...", nm_device_get_iface (self));
 
 		if (NM_DEVICE_GET_CLASS (self)->take_down)
 			NM_DEVICE_GET_CLASS (self)->take_down (self);
@@ -2761,6 +3032,13 @@ dispose (GObject *object)
 	/* Clear any delayed transitions */
 	delayed_transitions_clear (self);
 
+	/* Clean up and stop DHCP */
+	dhcp4_cleanup (self, take_down);
+	dhcp6_cleanup (self, take_down);
+	addrconf6_cleanup (self);
+	dnsmasq_cleanup (self);
+
+	/* Take the device itself down and clear its IPv4 configuration */
 	if (priv->managed && take_down) {
 		NMDeviceStateReason ignored = NM_DEVICE_STATE_REASON_NONE;
 
@@ -2768,26 +3046,10 @@ dispose (GObject *object)
 		nm_device_set_ip4_config (self, NULL, FALSE, &ignored);
 	}
 
-	clear_act_request (self);
-
 	activation_source_clear (self, TRUE, AF_INET);
 	activation_source_clear (self, TRUE, AF_INET6);
 
-	if (!take_down) {
-		nm_device_set_use_dhcp (self, FALSE);
-		nm_device_cleanup_ip6 (self);
-	}
-
-	if (priv->dnsmasq_manager) {
-		if (priv->dnsmasq_state_id) {
-			g_signal_handler_disconnect (priv->dnsmasq_manager, priv->dnsmasq_state_id);
-			priv->dnsmasq_state_id = 0;
-		}
-
-		nm_dnsmasq_manager_stop (priv->dnsmasq_manager);
-		g_object_unref (priv->dnsmasq_manager);
-		priv->dnsmasq_manager = NULL;
-	}
+	clear_act_request (self);
 
 out:
 	G_OBJECT_CLASS (nm_device_parent_class)->dispose (object);
@@ -2799,6 +3061,8 @@ finalize (GObject *object)
 	NMDevice *self = NM_DEVICE (object);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	g_object_unref (priv->dhcp_manager);
+
 	g_free (priv->udi);
 	g_free (priv->iface);
 	g_free (priv->ip_iface);
@@ -2846,6 +3110,9 @@ set_property (GObject *object, guint prop_id,
 		g_free (priv->type_desc);
 		priv->type_desc = g_value_dup_string (value);
 		break;
+	case NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE:
+		priv->rfkill_type = g_value_get_uint (value);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -2889,7 +3156,7 @@ get_property (GObject *object, guint prop_id,
 		break;
 	case NM_DEVICE_INTERFACE_PROP_DHCP4_CONFIG:
 		if (   ((state == NM_DEVICE_STATE_ACTIVATED) || (state == NM_DEVICE_STATE_IP_CONFIG))
-		    && nm_device_get_use_dhcp (self))
+		    && priv->dhcp4_client)
 			g_value_set_boxed (value, nm_dhcp4_config_get_dbus_path (priv->dhcp4_config));
 		else
 			g_value_set_boxed (value, "/");
@@ -2903,6 +3170,13 @@ get_property (GObject *object, guint prop_id,
 		}
 		g_value_set_boxed (value, "/");
 		break;
+	case NM_DEVICE_INTERFACE_PROP_DHCP6_CONFIG:
+		if (   ((state == NM_DEVICE_STATE_ACTIVATED) || (state == NM_DEVICE_STATE_IP_CONFIG))
+		    && priv->dhcp6_client)
+			g_value_set_boxed (value, nm_dhcp6_config_get_dbus_path (priv->dhcp6_config));
+		else
+			g_value_set_boxed (value, "/");
+		break;
 	case NM_DEVICE_INTERFACE_PROP_STATE:
 		g_value_set_uint (value, priv->state);
 		break;
@@ -2915,6 +3189,9 @@ get_property (GObject *object, guint prop_id,
 	case NM_DEVICE_INTERFACE_PROP_TYPE_DESC:
 		g_value_set_string (value, priv->type_desc);
 		break;
+	case NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE:
+		g_value_set_uint (value, priv->rfkill_type);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -2982,6 +3259,10 @@ nm_device_class_init (NMDeviceClass *klass)
 									  NM_DEVICE_INTERFACE_IP6_CONFIG);
 
 	g_object_class_override_property (object_class,
+	                                  NM_DEVICE_INTERFACE_PROP_DHCP6_CONFIG,
+	                                  NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+
+	g_object_class_override_property (object_class,
 									  NM_DEVICE_INTERFACE_PROP_STATE,
 									  NM_DEVICE_INTERFACE_STATE);
 
@@ -2997,6 +3278,10 @@ nm_device_class_init (NMDeviceClass *klass)
 									  NM_DEVICE_INTERFACE_PROP_TYPE_DESC,
 									  NM_DEVICE_INTERFACE_TYPE_DESC);
 
+	g_object_class_override_property (object_class,
+	                                  NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE);
+
 	signals[AUTOCONNECT_ALLOWED] =
 		g_signal_new ("autoconnect-allowed",
 		              G_OBJECT_CLASS_TYPE (object_class),
@@ -3013,6 +3298,8 @@ failed_to_disconnected (gpointer user_data)
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_DEVICE, "(%s): running failed->disconnected transition",
+	            nm_device_get_iface (self));
 	priv->failed_to_disconnected_id = 0;
 	nm_device_state_changed (self, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
 	return FALSE;
@@ -3024,6 +3311,8 @@ unavailable_to_disconnected (gpointer user_data)
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_DEVICE, "(%s): running unavailable->disconnected transition",
+	            nm_device_get_iface (self));
 	priv->unavailable_to_disconnected_id = 0;
 	nm_device_state_changed (self, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
 	return FALSE;
@@ -3047,8 +3336,8 @@ nm_device_state_changed (NMDevice *device,
 	old_state = priv->state;
 	priv->state = state;
 
-	nm_info ("(%s): device state change: %d -> %d (reason %d)",
-	         nm_device_get_iface (device), old_state, state, reason);
+	nm_log_info (LOGD_DEVICE, "(%s): device state change: %d -> %d (reason %d)",
+	             nm_device_get_iface (device), old_state, state, reason);
 
 	/* Clear any delayed transitions */
 	delayed_transitions_clear (device);
@@ -3066,8 +3355,9 @@ nm_device_state_changed (NMDevice *device,
 		break;
 	case NM_DEVICE_STATE_UNAVAILABLE:
 		if (old_state == NM_DEVICE_STATE_UNMANAGED) {
-			if (!nm_device_bring_up (device, TRUE, &no_firmware) && no_firmware)
-				nm_warning ("%s: firmware may be missing.", nm_device_get_iface (device));
+			if (!nm_device_bring_up (device, TRUE, &no_firmware) && no_firmware) {
+				nm_log_warn (LOGD_HW, "%s: firmware may be missing.", nm_device_get_iface (device));
+			}
 		}
 		/* Ensure the device gets deactivated in response to stuff like
 		 * carrier changes or rfkill.  But don't deactivate devices that are
@@ -3099,15 +3389,22 @@ nm_device_state_changed (NMDevice *device,
 		 * we can't change states again from the state handler for a variety of
 		 * reasons.
 		 */
-		if (nm_device_is_available (device))
+		if (nm_device_is_available (device)) {
+			nm_log_dbg (LOGD_DEVICE, "(%s): device is available, will transition to DISCONNECTED",
+			            nm_device_get_iface (device));
 			priv->unavailable_to_disconnected_id = g_idle_add (unavailable_to_disconnected, device);
+		} else {
+			nm_log_dbg (LOGD_DEVICE, "(%s): device not yet available for transition to DISCONNECTED",
+			            nm_device_get_iface (device));
+		}
 		break;
 	case NM_DEVICE_STATE_ACTIVATED:
-		nm_info ("Activation (%s) successful, device activated.", nm_device_get_iface (device));
+		nm_log_info (LOGD_DEVICE, "Activation (%s) successful, device activated.",
+		             nm_device_get_iface (device));
 		nm_utils_call_dispatcher ("up", nm_act_request_get_connection (req), device, NULL);
 		break;
 	case NM_DEVICE_STATE_FAILED:
-		nm_info ("Activation (%s) failed.", nm_device_get_iface (device));
+		nm_log_warn (LOGD_DEVICE, "Activation (%s) failed.", nm_device_get_iface (device));
 		/* Schedule the transition to DISCONNECTED.  The device can't transition
 		 * immediately becuase we can't change states again from the state
 		 * handler for a variety of reasons.
@@ -3156,7 +3453,9 @@ nm_device_set_managed (NMDevice *device,
 		return;
 
 	priv->managed = managed;
-	nm_info ("(%s): now %s", nm_device_get_iface (device), managed ? "managed" : "unmanaged");
+	nm_log_info (LOGD_DEVICE, "(%s): now %s",
+	             nm_device_get_iface (device),
+	             managed ? "managed" : "unmanaged");
 
 	g_object_notify (G_OBJECT (device), NM_DEVICE_INTERFACE_MANAGED);
 
diff --git a/src/nm-device.h b/src/nm-device.h
index b81c460..5fcde5c 100644
--- a/src/nm-device.h
+++ b/src/nm-device.h
@@ -31,6 +31,7 @@
 #include "nm-ip4-config.h"
 #include "nm-ip6-config.h"
 #include "nm-dhcp4-config.h"
+#include "nm-dhcp6-config.h"
 #include "nm-connection.h"
 
 typedef enum NMActStageReturn
@@ -140,10 +141,8 @@ int			nm_device_get_priority (NMDevice *dev);
 guint32			nm_device_get_ip4_address	(NMDevice *dev);
 void				nm_device_update_ip4_address	(NMDevice *dev);
 
-gboolean		nm_device_get_use_dhcp	(NMDevice *dev);
-void			nm_device_set_use_dhcp	(NMDevice *dev,
-								 gboolean use_dhcp);
 NMDHCP4Config * nm_device_get_dhcp4_config (NMDevice *dev);
+NMDHCP6Config * nm_device_get_dhcp6_config (NMDevice *dev);
 
 NMIP4Config *	nm_device_get_ip4_config	(NMDevice *dev);
 NMIP6Config *	nm_device_get_ip6_config	(NMDevice *dev);
diff --git a/src/nm-dhcp6-config.c b/src/nm-dhcp6-config.c
new file mode 100644
index 0000000..fb6ccce
--- /dev/null
+++ b/src/nm-dhcp6-config.c
@@ -0,0 +1,192 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ */
+
+#include <glib.h>
+#include <string.h>
+
+#include "NetworkManager.h"
+#include "nm-dbus-manager.h"
+#include "nm-dhcp6-config.h"
+#include "nm-dhcp6-config-glue.h"
+#include "nm-dbus-glib-types.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-utils.h"
+
+
+G_DEFINE_TYPE (NMDHCP6Config, nm_dhcp6_config, G_TYPE_OBJECT)
+
+#define NM_DHCP6_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigPrivate))
+
+typedef struct {
+	char *dbus_path;
+	GHashTable *options;
+} NMDHCP6ConfigPrivate;
+
+
+enum {
+	PROP_0,
+	PROP_OPTIONS,
+
+	LAST_PROP
+};
+
+enum {
+	PROPERTIES_CHANGED,
+
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+
+NMDHCP6Config *
+nm_dhcp6_config_new (void)
+{
+	return NM_DHCP6_CONFIG (g_object_new (NM_TYPE_DHCP6_CONFIG, NULL));
+}
+
+void
+nm_dhcp6_config_add_option (NMDHCP6Config *self,
+                            const char *key,
+                            const char *option)
+{
+	GValue *svalue;
+
+	g_return_if_fail (NM_IS_DHCP6_CONFIG (self));
+	g_return_if_fail (key != NULL);
+	g_return_if_fail (option != NULL);
+
+	svalue = g_slice_new0 (GValue);
+	g_value_init (svalue, G_TYPE_STRING);
+	g_value_set_string (svalue, option);
+	g_hash_table_insert (NM_DHCP6_CONFIG_GET_PRIVATE (self)->options, g_strdup (key), svalue);
+	g_object_notify (G_OBJECT (self), NM_DHCP6_CONFIG_OPTIONS);
+}
+
+void
+nm_dhcp6_config_reset (NMDHCP6Config *self)
+{
+	g_return_if_fail (NM_IS_DHCP6_CONFIG (self));
+
+	g_hash_table_remove_all (NM_DHCP6_CONFIG_GET_PRIVATE (self)->options);
+	g_object_notify (G_OBJECT (self), NM_DHCP6_CONFIG_OPTIONS);
+}
+
+const char *
+nm_dhcp6_config_get_option (NMDHCP6Config *self, const char *key)
+{
+	GValue *value;
+
+	g_return_val_if_fail (NM_IS_DHCP6_CONFIG (self), NULL);
+	g_return_val_if_fail (key != NULL, NULL);
+
+	value = g_hash_table_lookup (NM_DHCP6_CONFIG_GET_PRIVATE (self)->options, key);
+	return value ? g_value_get_string (value) : NULL;
+}
+
+const char *
+nm_dhcp6_config_get_dbus_path (NMDHCP6Config *self)
+{
+	g_return_val_if_fail (NM_IS_DHCP6_CONFIG (self), NULL);
+
+	return NM_DHCP6_CONFIG_GET_PRIVATE (self)->dbus_path;
+}
+
+static void
+nm_gvalue_destroy (gpointer data)
+{
+	GValue *value = (GValue *) data;
+
+	g_value_unset (value);
+	g_slice_free (GValue, value);
+}
+
+static void
+nm_dhcp6_config_init (NMDHCP6Config *self)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (self);
+	static guint32 counter = 0;
+	DBusGConnection *connection;
+	NMDBusManager *dbus_mgr;
+
+	dbus_mgr = nm_dbus_manager_get ();
+	connection = nm_dbus_manager_get_connection (dbus_mgr);
+	priv->dbus_path = g_strdup_printf (NM_DBUS_PATH "/DHCP6Config/%d", counter++);
+	dbus_g_connection_register_g_object (connection, priv->dbus_path, G_OBJECT (self));
+	g_object_unref (dbus_mgr);
+
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, nm_gvalue_destroy);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+
+	g_free (priv->dbus_path);
+	g_hash_table_destroy (priv->options);
+
+	G_OBJECT_CLASS (nm_dhcp6_config_parent_class)->finalize (object);
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_OPTIONS:
+		g_value_set_boxed (value, priv->options);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_dhcp6_config_class_init (NMDHCP6ConfigClass *config_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (config_class);
+
+	g_type_class_add_private (config_class, sizeof (NMDHCP6ConfigPrivate));
+
+	/* virtual methods */
+	object_class->get_property = get_property;
+	object_class->finalize = finalize;
+
+	/* properties */
+	g_object_class_install_property
+		(object_class, PROP_OPTIONS,
+		 g_param_spec_boxed (NM_DHCP6_CONFIG_OPTIONS,
+		                     "Options",
+		                     "DHCP configuration options returned by the server",
+		                     DBUS_TYPE_G_MAP_OF_VARIANT,
+		                     G_PARAM_READABLE));
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+								    G_STRUCT_OFFSET (NMDHCP6ConfigClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (config_class),
+									 &dbus_glib_nm_dhcp6_config_object_info);
+}
diff --git a/src/nm-dhcp6-config.h b/src/nm-dhcp6-config.h
new file mode 100644
index 0000000..90eb10f
--- /dev/null
+++ b/src/nm-dhcp6-config.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP6_CONFIG_H
+#define NM_DHCP6_CONFIG_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define NM_TYPE_DHCP6_CONFIG            (nm_dhcp6_config_get_type ())
+#define NM_DHCP6_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP6_CONFIG, NMDHCP6Config))
+#define NM_DHCP6_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigClass))
+#define NM_IS_DHCP6_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+#define NM_IS_DHCP6_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+#define NM_DHCP6_CONFIG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigClass))
+
+typedef struct {
+	GObject parent;
+} NMDHCP6Config;
+
+typedef struct {
+	GObjectClass parent;
+
+	/* Signals */
+	void (*properties_changed) (NMDHCP6Config *config, GHashTable *properties);
+} NMDHCP6ConfigClass;
+
+#define NM_DHCP6_CONFIG_OPTIONS "options"
+
+GType nm_dhcp6_config_get_type (void);
+
+NMDHCP6Config *nm_dhcp6_config_new (void);
+
+const char *nm_dhcp6_config_get_dbus_path (NMDHCP6Config *config);
+
+void nm_dhcp6_config_add_option (NMDHCP6Config *config,
+                                 const char *key,
+                                 const char *option);
+
+void nm_dhcp6_config_reset (NMDHCP6Config *config);
+
+const char *nm_dhcp6_config_get_option (NMDHCP6Config *config, const char *option);
+
+#endif /* NM_DHCP6_CONFIG_H */
diff --git a/src/nm-logging.c b/src/nm-logging.c
deleted file mode 100644
index f474615..0000000
--- a/src/nm-logging.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#define _GNU_SOURCE
-#include <dlfcn.h>
-#include <syslog.h>
-#include <execinfo.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/stat.h>
-#include <execinfo.h>
-
-#include "nm-logging.h"
-#include "nm-utils.h"
-
-static void
-fallback_get_backtrace (void)
-{
-	void *frames[64];
-	Dl_info info;
-	size_t size;
-	guint32 i;
-	const char *name;
-
-	size = backtrace (frames, G_N_ELEMENTS (frames));
-
-	syslog (LOG_CRIT, "******************* START **********************************");
-	for (i = 0; i < size; i++) {
-		dladdr (frames[i], &info);
-		name = (info.dli_fname && *info.dli_fname) ? info.dli_fname : "(vdso)";
-		if (info.dli_saddr) {
-			syslog (LOG_CRIT, "Frame %d: %s (%s+0x%lx) [%p]",
-			        i, name,
-			        info.dli_sname,
-			        (gulong)(frames[i] - info.dli_saddr),
-			        frames[i]);
-		} else {
-			syslog (LOG_CRIT, "Frame %d: %s (%p+0x%lx) [%p]",
-			        i, name,
-			        info.dli_fbase,
-			        (gulong)(frames[i] - info.dli_saddr),
-			        frames[i]);
-		}
-	}
-	syslog (LOG_CRIT, "******************* END **********************************");
-}
-
-
-static gboolean
-crashlogger_get_backtrace (void)
-{
-	gboolean success = FALSE;
-	int pid;	
-
-	pid = fork();
-	if (pid > 0)
-	{
-		/* Wait for the child to finish */
-		int estatus;
-		if (waitpid (pid, &estatus, 0) != -1)
-		{
-			/* Only succeed if the crashlogger succeeded */
-			if (WIFEXITED (estatus) && (WEXITSTATUS (estatus) == 0))
-				success = TRUE;
-		}
-	}
-	else if (pid == 0)
-	{
-		/* Child process */
-		execl (LIBEXECDIR"/nm-crash-logger",
-				LIBEXECDIR"/nm-crash-logger", NULL);
-	}
-
-	return success;
-}
-
-
-void
-nm_logging_backtrace (void)
-{
-	struct stat s;
-	gboolean fallback = TRUE;
-	
-	/* Try to use gdb via nm-crash-logger if it exists, since
-	 * we get much better information out of it.  Otherwise
-	 * fall back to execinfo.
-	 */
-	if (stat (LIBEXECDIR"/nm-crash-logger", &s) == 0)
-		fallback = crashlogger_get_backtrace () ? FALSE : TRUE;
-
-	if (fallback)
-		fallback_get_backtrace ();
-}
-
-
-static void
-nm_log_handler (const gchar *		log_domain,
-			  GLogLevelFlags	log_level,
-			  const gchar *	message,
-			  gpointer		ignored)
-{
-	int syslog_priority;	
-
-	switch (log_level)
-	{
-		case G_LOG_LEVEL_ERROR:
-			syslog_priority = LOG_CRIT;
-			break;
-
-		case G_LOG_LEVEL_CRITICAL:
-			syslog_priority = LOG_ERR;
-			break;
-
-		case G_LOG_LEVEL_WARNING:
-			syslog_priority = LOG_WARNING;
-			break;
-
-		case G_LOG_LEVEL_MESSAGE:
-			syslog_priority = LOG_NOTICE;
-			break;
-
-		case G_LOG_LEVEL_DEBUG:
-			syslog_priority = LOG_DEBUG;
-			break;
-
-		case G_LOG_LEVEL_INFO:
-		default:
-			syslog_priority = LOG_INFO;
-			break;
-	}
-
-	syslog (syslog_priority, "%s", message);
-}
-
-
-void
-nm_logging_setup (gboolean become_daemon)
-{
-	if (become_daemon)
-		openlog (G_LOG_DOMAIN, 0, LOG_DAEMON);
-	else
-		openlog (G_LOG_DOMAIN, LOG_CONS | LOG_PERROR, LOG_USER);
-
-	g_log_set_handler (G_LOG_DOMAIN, 
-				    G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION,
-				    nm_log_handler,
-				    NULL);
-}
-
-void
-nm_logging_shutdown (void)
-{
-	closelog ();
-}
diff --git a/src/nm-logging.h b/src/nm-logging.h
deleted file mode 100644
index 70979fa..0000000
--- a/src/nm-logging.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#ifndef NM_LOGGING_H
-#define NM_LOGGING_H
-
-#include <glib.h>
-
-void nm_logging_setup     (gboolean become_daemon);
-void nm_logging_backtrace (void);
-void nm_logging_shutdown  (void);
-
-#endif /* NM_LOGGING_H */
diff --git a/src/nm-manager.c b/src/nm-manager.c
index ff75355..6eaf6a5 100644
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2009 Novell, Inc.
- * Copyright (C) 2007 - 2009 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <netinet/ether.h>
@@ -26,18 +26,19 @@
 
 #include "nm-glib-compat.h"
 #include "nm-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-dbus-manager.h"
 #include "nm-vpn-manager.h"
 #include "nm-modem-manager.h"
-#include "nm-modem.h"
 #include "nm-device-bt.h"
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
 #include "nm-device-ethernet.h"
 #include "nm-device-wifi.h"
 #include "nm-device-olpc-mesh.h"
-#include "NetworkManagerSystem.h"
+#include "nm-device-cdma.h"
+#include "nm-device-gsm.h"
+#include "nm-system.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-setting-bluetooth.h"
 #include "nm-setting-connection.h"
@@ -78,6 +79,11 @@ static gboolean impl_manager_deactivate_connection (NMManager *manager,
 
 static gboolean impl_manager_sleep (NMManager *manager, gboolean sleep, GError **err);
 
+static gboolean impl_manager_set_logging (NMManager *manager,
+                                          const char *level,
+                                          const char *domains,
+                                          GError **error);
+
 /* Legacy 0.6 compatibility interface */
 
 static gboolean impl_manager_legacy_sleep (NMManager *manager, GError **err);
@@ -127,15 +133,15 @@ static const char *internal_activate_device (NMManager *manager,
                                              gboolean assumed,
                                              GError **error);
 
-static NMDevice *
-find_device_by_iface (NMManager *self, const gchar *iface);
+static NMDevice *find_device_by_iface (NMManager *self, const gchar *iface);
 
-static GSList *
-remove_one_device (NMManager *manager,
-                   GSList *list,
-                   NMDevice *device,
-                   gboolean quitting,
-                   gboolean force_unmanage);
+static GSList * remove_one_device (NMManager *manager,
+                                   GSList *list,
+                                   NMDevice *device,
+                                   gboolean quitting,
+                                   gboolean force_unmanage);
+
+static NMDevice *nm_manager_get_device_by_udi (NMManager *manager, const char *udi);
 
 #define SSD_POKE_INTERVAL 120
 #define ORIGDEV_TAG "originating-device"
@@ -152,16 +158,12 @@ typedef struct {
 typedef struct {
 	gboolean enabled;
 	gboolean hw_enabled;
+	RfKillType rtype;
 	const char *desc;
 	const char *key;
 	const char *prop;
 	const char *hw_prop;
-	/* Hack for WWAN for 0.8 release; we'll start using udev
-	 * after 0.8 gets out.
-	 */
-	gboolean ignore_udev;
 	RfKillState (*other_enabled_func) (NMManager *);
-	gboolean (*object_filter_func) (GObject *);
 } RadioState;
 
 typedef struct {
@@ -310,26 +312,17 @@ vpn_manager_connection_deactivated_cb (NMVPNManager *manager,
 
 static void
 modem_added (NMModemManager *modem_manager,
-			 NMDevice *modem,
+			 NMModem *modem,
+			 const char *driver,
 			 gpointer user_data)
 {
-	NMManagerPrivate *priv;
-	NMDeviceType type;
-	NMDevice *replace_device;
-	const char *type_name;
+	NMManager *self = NM_MANAGER (user_data);
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMDevice *replace_device, *device = NULL;
 	const char *ip_iface;
+	GSList *iter;
 
-	priv = NM_MANAGER_GET_PRIVATE (user_data);
-
-	type = nm_device_get_device_type (NM_DEVICE (modem));
-	if (type == NM_DEVICE_TYPE_GSM)
-		type_name = "GSM modem";
-	else if (type == NM_DEVICE_TYPE_CDMA)
-		type_name = "CDMA modem";
-	else
-		type_name = "Unknown modem";
-
-	ip_iface = nm_device_get_ip_iface (modem);
+	ip_iface = nm_modem_get_iface (modem);
 
 	replace_device = find_device_by_iface (NM_MANAGER (user_data), ip_iface);
 	if (replace_device) {
@@ -340,7 +333,33 @@ modem_added (NMModemManager *modem_manager,
 		                                   TRUE);
 	}
 
-	add_device (NM_MANAGER (user_data), NM_DEVICE (g_object_ref (modem)));
+	/* Give Bluetooth DUN devices first chance to claim the modem */
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		if (NM_IS_DEVICE_BT (iter->data)) {
+			if (nm_device_bt_modem_added (NM_DEVICE_BT (iter->data), modem, driver))
+				return;
+		}
+	}
+
+	/* If it was a Bluetooth modem and no bluetooth device claimed it, ignore
+	 * it.  The rfcomm port (and thus the modem) gets created automatically
+	 * by the Bluetooth code during the connection process.
+	 */
+	if (driver && !strcmp (driver, "bluetooth")) {
+		nm_log_info (LOGD_MB, "ignoring modem '%s' (no associated Bluetooth device)", ip_iface);
+		return;
+	}
+
+	/* Otherwise make a new top-level NMDevice for it */
+	if (NM_IS_MODEM_GSM (modem))
+		device = nm_device_gsm_new (NM_MODEM_GSM (modem), driver);
+	else if (NM_IS_MODEM_CDMA (modem))
+		device = nm_device_cdma_new (NM_MODEM_CDMA (modem), driver);
+	else
+		nm_log_info (LOGD_MB, "unhandled modem '%s'", ip_iface);
+
+	if (device)
+		add_device (self, device);
 }
 
 static void
@@ -438,13 +457,26 @@ remove_one_device (NMManager *manager,
 
 static void
 modem_removed (NMModemManager *modem_manager,
-			   NMDevice *modem,
+			   NMModem *modem,
 			   gpointer user_data)
 {
 	NMManager *self = NM_MANAGER (user_data);
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMDevice *found;
+	GSList *iter;
+
+	/* Give Bluetooth DUN devices first chance to handle the modem removal */
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		if (NM_IS_DEVICE_BT (iter->data)) {
+			if (nm_device_bt_modem_removed (NM_DEVICE_BT (iter->data), modem))
+				return;
+		}
+	}
 
-	priv->devices = remove_one_device (self, priv->devices, modem, FALSE, TRUE);
+	/* Otherwise remove the standalone modem */
+	found = nm_manager_get_device_by_udi (self, nm_modem_get_path (modem));
+	if (found)
+		priv->devices = remove_one_device (self, priv->devices, found, FALSE, TRUE);
 }
 
 static void
@@ -460,7 +492,7 @@ aipd_handle_event (DBusGProxy *proxy,
 	gboolean handled = FALSE;
 
 	if (!event || !iface) {
-		nm_warning ("Incomplete message received from avahi-autoipd");
+		nm_log_warn (LOGD_AUTOIP4, "incomplete message received from avahi-autoipd");
 		return;
 	}
 
@@ -468,7 +500,7 @@ aipd_handle_event (DBusGProxy *proxy,
 	    && (strcmp (event, "CONFLICT") != 0)
 	    && (strcmp (event, "UNBIND") != 0)
 	    && (strcmp (event, "STOP") != 0)) {
-		nm_warning ("Unknown event '%s' received from avahi-autoipd", event);
+		nm_log_warn (LOGD_AUTOIP4, "unknown event '%s' received from avahi-autoipd", event);
 		return;
 	}
 
@@ -483,7 +515,7 @@ aipd_handle_event (DBusGProxy *proxy,
 	}
 
 	if (!handled)
-		nm_warning ("Unhandled avahi-autoipd event for '%s'", iface);
+		nm_log_warn (LOGD_AUTOIP4, "(%s): unhandled avahi-autoipd event", iface);
 }
 
 static const char *
@@ -665,7 +697,8 @@ user_connection_get_settings_cb  (DBusGProxy *proxy,
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, &settings,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("Couldn't retrieve connection settings: %s.", err->message);
+		nm_log_info (LOGD_USER_SET, "couldn't retrieve connection settings: %s.",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		goto out;
 	}
@@ -680,10 +713,9 @@ user_connection_get_settings_cb  (DBusGProxy *proxy,
 
 		connection = nm_connection_new_from_hash (settings, &error);
 		if (connection == NULL) {
-			nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-			            __func__,
-			            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
-			            error->message, error->code);
+			nm_log_warn (LOGD_USER_SET, "invalid connection: '%s' / '%s' invalid: %d",
+			             g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+			             error->message, error->code);
 			g_error_free (error);
 			goto out;
 		}
@@ -726,7 +758,7 @@ user_connection_get_settings_cb  (DBusGProxy *proxy,
 		}
 	} else {
 		// FIXME: merge settings? or just replace?
-		nm_warning ("%s (#%d): implement merge settings", __func__, __LINE__);
+		nm_log_dbg (LOGD_USER_SET, "implement merge settings");
 	}
 
 out:
@@ -774,10 +806,9 @@ user_connection_updated_cb (DBusGProxy *proxy,
 	new_connection = nm_connection_new_from_hash (settings, &error);
 	if (!new_connection) {
 		/* New connection invalid, remove existing connection */
-		nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-		            __func__,
-		            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
-		            error->message, error->code);
+		nm_log_warn (LOGD_USER_SET, "invalid connection: '%s' / '%s' invalid: %d",
+		             g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+		             error->message, error->code);
 		g_error_free (error);
 		remove_connection (manager, old_connection, priv->user_connections);
 		return;
@@ -814,7 +845,7 @@ user_internal_new_connection_cb (DBusGProxy *proxy,
 	                                       path,
 	                                       NM_DBUS_IFACE_SETTINGS_CONNECTION);
 	if (!con_proxy) {
-		nm_warning ("Error: could not init user connection proxy");
+		nm_log_err (LOGD_USER_SET, "could not init user connection proxy");
 		return;
 	}
 
@@ -860,7 +891,8 @@ user_list_connections_cb  (DBusGProxy *proxy,
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_ARRAY_OF_OBJECT_PATH, &ops,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("Couldn't retrieve connections: %s.", err->message);
+		nm_log_warn (LOGD_USER_SET, "couldn't retrieve connections: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		goto out;
 	}
@@ -906,7 +938,7 @@ user_query_connections (NMManager *manager)
 		                                              NM_DBUS_PATH_SETTINGS,
 		                                              NM_DBUS_IFACE_SETTINGS);
 		if (!priv->user_proxy) {
-			nm_warning ("Error: could not init settings proxy");
+			nm_log_err (LOGD_USER_SET, "could not init user settings proxy");
 			return;
 		}
 
@@ -949,16 +981,15 @@ system_connection_updated_cb (NMSettingsConnectionInterface *connection,
 	if (!existing)
 		return;
 	if (existing != connection) {
-		g_warning ("%s: existing connection didn't matched updated.", __func__);
+		nm_log_warn (LOGD_SYS_SET, "existing connection didn't matched updated.");
 		return;
 	}
 
 	if (!nm_connection_verify (NM_CONNECTION (existing), &error)) {
 		/* Updated connection invalid, remove existing connection */
-		nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-		            __func__,
-		            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
-		            error->message, error->code);
+		nm_log_warn (LOGD_SYS_SET, "invalid connection: '%s' / '%s' invalid: %d",
+		             g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+		             error->message, error->code);
 		g_error_free (error);
 		remove_connection (manager, NM_CONNECTION (existing), priv->system_connections);
 		return;
@@ -1200,10 +1231,10 @@ manager_set_radio_enabled (NMManager *manager,
 		                                "main", rstate->key,
 		                                G_TYPE_BOOLEAN, (gpointer) &enabled,
 		                                &error)) {
-			g_warning ("Writing to state file %s failed: (%d) %s.",
-			           priv->state_file,
-			           error ? error->code : -1,
-			           (error && error->message) ? error->message : "unknown");
+			nm_log_warn (LOGD_CORE, "writing to state file %s failed: (%d) %s.",
+			             priv->state_file,
+			             error ? error->code : -1,
+			             (error && error->message) ? error->message : "unknown");
 		}
 	}
 
@@ -1213,9 +1244,15 @@ manager_set_radio_enabled (NMManager *manager,
 
 	/* enable/disable wireless devices as required */
 	for (iter = priv->devices; iter; iter = iter->next) {
-		if (   rstate->object_filter_func
-			&& rstate->object_filter_func (G_OBJECT (iter->data)))
+		RfKillType devtype = RFKILL_TYPE_UNKNOWN;
+
+		g_object_get (G_OBJECT (iter->data), NM_DEVICE_INTERFACE_RFKILL_TYPE, &devtype, NULL);
+		if (devtype == rstate->rtype) {
+			nm_log_dbg (LOGD_RFKILL, "(%s): setting radio %s",
+			            nm_device_get_iface (NM_DEVICE (iter->data)),
+			            enabled ? "enabled" : "disabled");
 			nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (iter->data), enabled);
+		}
 	}
 }
 
@@ -1314,9 +1351,11 @@ nm_manager_get_modem_enabled_state (NMManager *self)
 	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
 		NMDevice *candidate = NM_DEVICE (iter->data);
 		RfKillState candidate_state = RFKILL_UNBLOCKED;
+		RfKillType devtype = RFKILL_TYPE_UNKNOWN;
 
-		if (NM_IS_MODEM (candidate)) {
-			if (nm_modem_get_mm_enabled (NM_MODEM (candidate)) == FALSE)
+		g_object_get (G_OBJECT (candidate), NM_DEVICE_INTERFACE_RFKILL_TYPE, &devtype, NULL);
+		if (devtype == RFKILL_TYPE_WWAN) {
+			if (!nm_device_interface_get_enabled (NM_DEVICE_INTERFACE (candidate)))
 				candidate_state = RFKILL_SOFT_BLOCKED;
 
 			if (candidate_state > wwan_state)
@@ -1327,18 +1366,6 @@ nm_manager_get_modem_enabled_state (NMManager *self)
 	return wwan_state;
 }
 
-static gboolean
-rfkill_wlan_filter (GObject *object)
-{
-	return NM_IS_DEVICE_WIFI (object);
-}
-
-static gboolean
-rfkill_wwan_filter (GObject *object)
-{
-	return NM_IS_MODEM (object);
-}
-
 static void
 manager_rfkill_update_one_type (NMManager *self,
                                 RadioState *rstate,
@@ -1350,8 +1377,7 @@ manager_rfkill_update_one_type (NMManager *self,
 	RfKillState composite;
 	gboolean new_e = TRUE, new_he = TRUE;
 
-	if (!rstate->ignore_udev)
-		udev_state = nm_udev_manager_get_rfkill_state (priv->udev_mgr, rtype);
+	udev_state = nm_udev_manager_get_rfkill_state (priv->udev_mgr, rtype);
 
 	if (rstate->other_enabled_func)
 		other_state = rstate->other_enabled_func (self);
@@ -1381,13 +1407,19 @@ manager_rfkill_update_one_type (NMManager *self,
 		break;
 	}
 
+	if (rstate->desc) {
+		nm_log_dbg (LOGD_RFKILL, "%s hw-enabled %d enabled %d",
+		            rstate->desc, new_he, new_e);
+	}
+
 	if (new_he != rstate->hw_enabled) {
-		nm_info ("%s now %s by radio killswitch",
-		         rstate->desc,
-		         (new_e && new_he) ? "enabled" : "disabled");
+		nm_log_info (LOGD_RFKILL, "%s now %s by radio killswitch",
+		             rstate->desc,
+		             (new_e && new_he) ? "enabled" : "disabled");
 
 		rstate->hw_enabled = new_he;
-		g_object_notify (G_OBJECT (self), rstate->hw_prop);
+		if (rstate->hw_prop)
+			g_object_notify (G_OBJECT (self), rstate->hw_prop);
 	}
 	manager_set_radio_enabled (self, rstate, new_e);
 }
@@ -1440,7 +1472,7 @@ add_device (NMManager *self, NMDevice *device)
 	iface = nm_device_get_ip_iface (device);
 	g_assert (iface);
 
-	if (!NM_IS_MODEM(device) && nm_modem_manager_has_modem_for_iface (priv->modem_manager, iface)) {
+	if (!NM_IS_DEVICE_MODEM (device) && find_device_by_iface (self, iface)) {
 		g_object_unref (device);
 		return;
 	}
@@ -1472,7 +1504,7 @@ add_device (NMManager *self, NMDevice *device)
 		nm_manager_rfkill_update (self, RFKILL_TYPE_WLAN);
 		nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (device),
 		                                 priv->radio_states[RFKILL_TYPE_WLAN].enabled);
-	} else if (NM_IS_MODEM (device)) {
+	} else if (NM_IS_DEVICE_MODEM (device)) {
 		g_signal_connect (device, "notify::" NM_MODEM_ENABLED,
 		                  G_CALLBACK (manager_modem_enabled_changed),
 		                  self);
@@ -1491,14 +1523,14 @@ add_device (NMManager *self, NMDevice *device)
 	driver = nm_device_get_driver (device);
 	if (!driver)
 		driver = "unknown";
-	nm_info ("(%s): new %s device (driver: '%s')", iface, type_desc, driver);
+	nm_log_info (LOGD_HW, "(%s): new %s device (driver: '%s')", iface, type_desc, driver);
 
 	path = g_strdup_printf ("/org/freedesktop/NetworkManager/Devices/%d", devcount++);
 	nm_device_set_path (device, path);
 	dbus_g_connection_register_g_object (nm_dbus_manager_get_connection (priv->dbus_mgr),
 	                                     path,
 	                                     G_OBJECT (device));
-	nm_info ("(%s): exported as %s", iface, path);
+	nm_log_info (LOGD_CORE, "(%s): exported as %s", iface, path);
 	g_free (path);
 
 	/* Check if we should assume the device's active connection by matching its
@@ -1513,6 +1545,15 @@ add_device (NMManager *self, NMDevice *device)
 		existing = nm_device_interface_connection_match_config (NM_DEVICE_INTERFACE (device),
 		                                                        (const GSList *) connections);
 		g_slist_free (connections);
+
+		if (existing) {
+			NMSettingConnection *s_con;
+
+			s_con = (NMSettingConnection *) nm_connection_get_setting (existing, NM_TYPE_SETTING_CONNECTION);
+			nm_log_dbg (LOGD_DEVICE, "(%s): found existing device connection '%s'",
+			            nm_device_get_iface (device),
+			            nm_setting_connection_get_id (s_con));
+		}
 	}
 
 	/* Start the device if it's supposed to be managed */
@@ -1534,15 +1575,18 @@ add_device (NMManager *self, NMDevice *device)
 		const char *ac_path;
 		GError *error = NULL;
 
+		nm_log_dbg (LOGD_DEVICE, "(%s): will attempt to assume existing connection",
+		            nm_device_get_iface (device));
+
 		ac_path = internal_activate_device (self, device, existing, NULL, FALSE, TRUE, &error);
 		if (ac_path)
 			g_object_notify (G_OBJECT (self), NM_MANAGER_ACTIVE_CONNECTIONS);
 		else {
-			nm_warning ("Assumed connection (%d) %s failed to activate: (%d) %s",
-			            nm_connection_get_scope (existing),
-			            nm_connection_get_path (existing),
-			            error ? error->code : -1,
-			            error && error->message ? error->message : "(unknown)");
+			nm_log_warn (LOGD_DEVICE, "assumed connection (%d) %s failed to activate: (%d) %s",
+			             nm_connection_get_scope (existing),
+			             nm_connection_get_path (existing),
+			             error ? error->code : -1,
+			             error && error->message ? error->message : "(unknown)");
 			g_error_free (error);
 		}
 	}
@@ -1691,13 +1735,12 @@ bluez_manager_bdaddr_added_cb (NMBluezManager *bluez_mgr,
 
 	device = nm_device_bt_new (object_path, bdaddr, name, capabilities, FALSE);
 	if (device) {
-		g_message ("%s: BT device %s (%s) added (%s%s%s)",
-		           __func__,
-		           name,
-		           bdaddr,
-		           has_dun ? "DUN" : "",
-		           has_dun && has_nap ? " " : "",
-		           has_nap ? "NAP" : "");
+		nm_log_info (LOGD_HW, "BT device %s (%s) added (%s%s%s)",
+		             name,
+		             bdaddr,
+		             has_dun ? "DUN" : "",
+		             has_dun && has_nap ? " " : "",
+		             has_nap ? "NAP" : "");
 
 		add_device (manager, device);
 	}
@@ -1716,7 +1759,7 @@ bluez_manager_bdaddr_removed_cb (NMBluezManager *bluez_mgr,
 	g_return_if_fail (bdaddr != NULL);
 	g_return_if_fail (object_path != NULL);
 
-	g_message ("%s: BT device %s removed", __func__, bdaddr);
+	nm_log_info (LOGD_HW, "BT device %s removed", bdaddr);
 
 	for (iter = priv->devices; iter; iter = iter->next) {
 		NMDevice *device = NM_DEVICE (iter->data);
@@ -1733,12 +1776,14 @@ find_device_by_iface (NMManager *self, const gchar *iface)
 {
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
 	GSList *iter;
+
 	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
 		NMDevice *device = NM_DEVICE (iter->data);
 		const gchar *d_iface = nm_device_get_ip_iface (device);
 		if (!strcmp (d_iface, iface))
 			return device;
 	}
+
 	return NULL;
 }
 
@@ -1989,7 +2034,7 @@ user_get_secrets (NMManager *self,
 	                                         nm_connection_get_path (connection),
 	                                         NM_DBUS_IFACE_SETTINGS_CONNECTION_SECRETS);
 	if (!info->proxy) {
-		nm_warning ("%s: could not create user connection secrets proxy", __func__);
+		nm_log_warn (LOGD_USER_SET, "could not create user connection secrets proxy");
 		g_free (info);
 		return NULL;
 	}
@@ -2054,7 +2099,9 @@ system_get_secrets_idle_cb (gpointer user_data)
 	connection = nm_settings_interface_get_connection_by_path (NM_SETTINGS_INTERFACE (priv->sys_settings), 
 	                                                           info->connection_path);
 	if (!connection) {
-		error = g_error_new_literal (0, 0, "unknown connection (not exported by system settings)");
+		error = g_error_new_literal (NM_MANAGER_ERROR,
+		                             NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
+		                             "unknown connection (not exported by system settings)");
 		nm_secrets_provider_interface_get_secrets_result (info->provider,
 		                                                  info->setting_name,
 		                                                  info->caller,
@@ -2204,8 +2251,8 @@ wait_for_connection_expired (gpointer data)
 	g_set_error (&error,
 	             NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
 	             "%s", "Connection was not provided by any settings service");
-	nm_warning ("Connection (%d) %s failed to activate (timeout): (%d) %s",
-	            info->scope, info->connection_path, error->code, error->message);
+	nm_log_warn (LOGD_CORE, "connection (%d) %s failed to activate (timeout): (%d) %s",
+	             info->scope, info->connection_path, error->code, error->message);
 	dbus_g_method_return_error (info->context, error);
 	g_error_free (error);
 
@@ -2356,8 +2403,8 @@ connection_added_default_handler (NMManager *manager,
 		g_object_notify (G_OBJECT (manager), NM_MANAGER_ACTIVE_CONNECTIONS);
 	} else {
 		dbus_g_method_return_error (info->context, error);
-		nm_warning ("Connection (%d) %s failed to activate: (%d) %s",
-		            scope, info->connection_path, error->code, error->message);
+		nm_log_warn (LOGD_CORE, "connection (%d) %s failed to activate: (%d) %s",
+		             scope, info->connection_path, error->code, error->message);
 		g_error_free (error);
 	}
 
@@ -2540,8 +2587,8 @@ impl_manager_activate_connection (NMManager *manager,
  err:
 	if (error) {
 		dbus_g_method_return_error (context, error);
-		nm_warning ("Connection (%d) %s failed to activate: (%d) %s",
-		            scope, connection_path, error->code, error->message);
+		nm_log_warn (LOGD_CORE, "connection (%d) %s failed to activate: (%d) %s",
+		             scope, connection_path, error->code, error->message);
 		g_error_free (error);
 	}
 
@@ -2635,16 +2682,16 @@ impl_manager_sleep (NMManager *self, gboolean sleep, GError **error)
 		                                "main", "NetworkingEnabled",
 		                                G_TYPE_BOOLEAN, (gpointer) &networking_enabled,
 		                                &err)) {
-			g_warning ("Writing to state file %s failed: (%d) %s.",
-			           priv->state_file,
-			           err ? err->code : -1,
-			           (err && err->message) ? err->message : "unknown");
+			nm_log_warn (LOGD_SUSPEND, "writing to state file %s failed: (%d) %s.",
+			             priv->state_file,
+			             err ? err->code : -1,
+			             (err && err->message) ? err->message : "unknown");
 		}
 
 	}
 
 	if (sleep) {
-		nm_info ("Sleeping...");
+		nm_log_info (LOGD_SUSPEND, "sleeping...");
 
 		/* Just deactivate and down all devices from the device list,
 		 * we'll remove them in 'wake' for speed's sake.
@@ -2654,7 +2701,7 @@ impl_manager_sleep (NMManager *self, gboolean sleep, GError **error)
 	} else {
 		const GSList *unmanaged_specs;
 
-		nm_info  ("Waking up...");
+		nm_log_info (LOGD_SUSPEND, "waking up...");
 
 		unmanaged_specs = nm_sysconfig_settings_get_unmanaged_specs (priv->sys_settings);
 
@@ -2674,11 +2721,17 @@ impl_manager_sleep (NMManager *self, gboolean sleep, GError **error)
 			for (i = 0; i < RFKILL_TYPE_MAX; i++) {
 				RadioState *rstate = &priv->radio_states[i];
 				gboolean enabled = (rstate->hw_enabled && rstate->enabled);
+				RfKillType devtype = RFKILL_TYPE_UNKNOWN;
 
-				if (   rstate->object_filter_func
-				    && rstate->object_filter_func (G_OBJECT (device))) {
-					nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (device), enabled);
+				if (rstate->desc) {
+					nm_log_dbg (LOGD_RFKILL, "%s %s devices (hw_enabled %d, enabled %d)",
+					            enabled ? "enabling" : "disabling",
+					            rstate->desc, rstate->hw_enabled, rstate->enabled);
 				}
+
+				g_object_get (G_OBJECT (device), NM_DEVICE_INTERFACE_RFKILL_TYPE, &devtype, NULL);
+				if (devtype == rstate->rtype)
+					nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (device), enabled);
 			}
 
 			nm_device_clear_autoconnect_inhibit (device);
@@ -2722,6 +2775,18 @@ impl_manager_legacy_state (NMManager *manager, guint32 *state, GError **err)
 	return TRUE;
 }
 
+static gboolean
+impl_manager_set_logging (NMManager *manager,
+                          const char *level,
+                          const char *domains,
+                          GError **error)
+{
+	if (nm_logging_setup (level, domains, error)) {
+		nm_log_info (LOGD_CORE, "logging: level '%s' domains '%s'", level, domains);
+		return TRUE;
+	}
+	return FALSE;
+}
 
 /* Connections */
 
@@ -2777,7 +2842,7 @@ nm_manager_get_connections (NMManager *manager,
 	else if (scope == NM_CONNECTION_SCOPE_SYSTEM)
 		g_hash_table_foreach (priv->system_connections, connections_to_slist, &list);
 	else
-		nm_warning ("Unknown NMConnectionScope %d", scope);	
+		nm_log_err (LOGD_CORE, "unknown NMConnectionScope %d", scope);
 	return list;
 }
 
@@ -2798,7 +2863,7 @@ nm_manager_get_connection_by_object_path (NMManager *manager,
 	else if (scope == NM_CONNECTION_SCOPE_SYSTEM)
 		connection = (NMConnection *) g_hash_table_lookup (priv->system_connections, path);
 	else
-		nm_warning ("Unknown NMConnectionScope %d", scope);
+		nm_log_err (LOGD_CORE, "unknown NMConnectionScope %d", scope);
 	return connection;
 }
 
@@ -2823,33 +2888,35 @@ nm_manager_start (NMManager *self)
 		if (!rstate->desc)
 			continue;
 
-		if (!rstate->ignore_udev) {
-			switch (nm_udev_manager_get_rfkill_state (priv->udev_mgr, i)) {
-			case RFKILL_UNBLOCKED:
-				enabled = TRUE;
-				hw_enabled = TRUE;
-				break;
-			case RFKILL_SOFT_BLOCKED:
-				enabled = FALSE;
-				hw_enabled = TRUE;
-				break;
-			case RFKILL_HARD_BLOCKED:
-				enabled = FALSE;
-				hw_enabled = FALSE;
-				break;
-			default:
-				break;
-			}
+		switch (nm_udev_manager_get_rfkill_state (priv->udev_mgr, i)) {
+		case RFKILL_UNBLOCKED:
+			enabled = TRUE;
+			hw_enabled = TRUE;
+			break;
+		case RFKILL_SOFT_BLOCKED:
+			enabled = FALSE;
+			hw_enabled = TRUE;
+			break;
+		case RFKILL_HARD_BLOCKED:
+			enabled = FALSE;
+			hw_enabled = FALSE;
+			break;
+		default:
+			break;
 		}
 
 		rstate->hw_enabled = hw_enabled;
-		nm_info ("%s %s by radio killswitch; %s by state file",
-		         rstate->desc,
-		         (rstate->hw_enabled && enabled) ? "enabled" : "disabled",
-		         (rstate->enabled) ? "enabled" : "disabled");
+		nm_log_info (LOGD_RFKILL, "%s %s by radio killswitch; %s by state file",
+		             rstate->desc,
+		             (rstate->hw_enabled && enabled) ? "enabled" : "disabled",
+		             (rstate->enabled) ? "enabled" : "disabled");
 		manager_set_radio_enabled (self, rstate, rstate->enabled && enabled);
 	}
 
+	/* Log overall networking status - asleep/running */
+	nm_log_info (LOGD_CORE, "Networking is %s by state file",
+	             priv->sleeping ? "disabled" : "enabled");
+
 	system_unmanaged_devices_changed_cb (priv->sys_settings, NULL, self);
 	system_hostname_changed_cb (priv->sys_settings, NULL, self);
 	system_query_connections (self);
@@ -3095,7 +3162,7 @@ nm_manager_init (NMManager *manager)
 	priv->radio_states[RFKILL_TYPE_WLAN].hw_prop = NM_MANAGER_WIRELESS_HARDWARE_ENABLED;
 	priv->radio_states[RFKILL_TYPE_WLAN].desc = "WiFi";
 	priv->radio_states[RFKILL_TYPE_WLAN].other_enabled_func = nm_manager_get_ipw_rfkill_state;
-	priv->radio_states[RFKILL_TYPE_WLAN].object_filter_func = rfkill_wlan_filter;
+	priv->radio_states[RFKILL_TYPE_WLAN].rtype = RFKILL_TYPE_WLAN;
 
 	priv->radio_states[RFKILL_TYPE_WWAN].enabled = TRUE;
 	priv->radio_states[RFKILL_TYPE_WWAN].key = "WWANEnabled";
@@ -3103,7 +3170,15 @@ nm_manager_init (NMManager *manager)
 	priv->radio_states[RFKILL_TYPE_WWAN].hw_prop = NM_MANAGER_WWAN_HARDWARE_ENABLED;
 	priv->radio_states[RFKILL_TYPE_WWAN].desc = "WWAN";
 	priv->radio_states[RFKILL_TYPE_WWAN].other_enabled_func = nm_manager_get_modem_enabled_state;
-	priv->radio_states[RFKILL_TYPE_WWAN].object_filter_func = rfkill_wwan_filter;
+	priv->radio_states[RFKILL_TYPE_WWAN].rtype = RFKILL_TYPE_WWAN;
+
+	priv->radio_states[RFKILL_TYPE_WIMAX].enabled = TRUE;
+	priv->radio_states[RFKILL_TYPE_WIMAX].key = "WiMAXEnabled";
+	priv->radio_states[RFKILL_TYPE_WIMAX].prop = NULL;
+	priv->radio_states[RFKILL_TYPE_WIMAX].hw_prop = NULL;
+	priv->radio_states[RFKILL_TYPE_WIMAX].desc = "WiMAX";
+	priv->radio_states[RFKILL_TYPE_WIMAX].other_enabled_func = NULL;
+	priv->radio_states[RFKILL_TYPE_WIMAX].rtype = RFKILL_TYPE_WIMAX;
 
 	for (i = 0; i < RFKILL_TYPE_MAX; i++)
 		priv->radio_states[i].hw_enabled = TRUE;
@@ -3124,9 +3199,9 @@ nm_manager_init (NMManager *manager)
 	                                                  g_object_unref);
 
 	priv->modem_manager = nm_modem_manager_get ();
-	priv->modem_added_id = g_signal_connect (priv->modem_manager, "device-added",
+	priv->modem_added_id = g_signal_connect (priv->modem_manager, "modem-added",
 	                                         G_CALLBACK (modem_added), manager);
-	priv->modem_removed_id = g_signal_connect (priv->modem_manager, "device-removed",
+	priv->modem_removed_id = g_signal_connect (priv->modem_manager, "modem-removed",
 	                                           G_CALLBACK (modem_removed), manager);
 
 	priv->vpn_manager = nm_vpn_manager_get ();
@@ -3157,7 +3232,7 @@ nm_manager_init (NMManager *manager)
 		                             manager,
 		                             NULL);
 	} else
-		nm_warning ("%s: could not initialize avahi-autoipd D-Bus proxy", __func__);
+		nm_log_warn (LOGD_AUTOIP4, "could not initialize avahi-autoipd D-Bus proxy");
 }
 
 static void
@@ -3321,5 +3396,6 @@ nm_manager_class_init (NMManagerClass *manager_class)
 	                                 &dbus_glib_nm_manager_object_info);
 
 	dbus_g_error_domain_register (NM_MANAGER_ERROR, NULL, NM_TYPE_MANAGER_ERROR);
+	dbus_g_error_domain_register (NM_LOGGING_ERROR, "org.freedesktop.NetworkManager.Logging", NM_TYPE_LOGGING_ERROR);
 }
 
diff --git a/src/nm-netlink-monitor.c b/src/nm-netlink-monitor.c
index 2c3987c..918d637 100644
--- a/src/nm-netlink-monitor.c
+++ b/src/nm-netlink-monitor.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2005 - 2008 Novell, Inc.
  * Copyright (C) 2005 Ray Strode
  *
@@ -41,9 +41,9 @@
 #include <glib/gi18n.h>
 
 #include "NetworkManager.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-netlink-monitor.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "nm-netlink.h"
 
@@ -186,6 +186,7 @@ netlink_object_message_handler (struct nl_object *obj, void *arg)
 	struct rtnl_link *filter;
 	struct rtnl_link *link_obj;
 	guint flags;
+	guint ifidx;
 
 	filter = rtnl_link_alloc ();
 	if (!filter) {
@@ -206,19 +207,17 @@ netlink_object_message_handler (struct nl_object *obj, void *arg)
 
 	link_obj = (struct rtnl_link *) obj;
 	flags = rtnl_link_get_flags (link_obj);
+	ifidx = rtnl_link_get_ifindex (link_obj);
+
+	nm_log_dbg (LOGD_HW, "netlink link message: iface idx %d flags 0x%X", ifidx, flags);
 
 	/* IFF_LOWER_UP is the indicator of carrier status since kernel commit
 	 * b00055aacdb172c05067612278ba27265fcd05ce in 2.6.17.
 	 */
-	if (flags & IFF_LOWER_UP) {
-		g_signal_emit (G_OBJECT (monitor),
-		               signals[CARRIER_ON],
-		               0, rtnl_link_get_ifindex (link_obj));
-	} else {
-		g_signal_emit (G_OBJECT (monitor),
-		               signals[CARRIER_OFF],
-		               0, rtnl_link_get_ifindex (link_obj));
-	}
+	if (flags & IFF_LOWER_UP)
+		g_signal_emit (G_OBJECT (monitor), signals[CARRIER_ON], 0, ifidx);
+	else
+		g_signal_emit (G_OBJECT (monitor), signals[CARRIER_OFF], 0, ifidx);
 
 out:
 	rtnl_link_put (filter);
@@ -407,9 +406,9 @@ deferred_emit_carrier_state (gpointer user_data)
 	/* Update the link cache with latest state, and if there are no errors
 	 * emit the link states for all the interfaces in the cache.
 	 */
-	if (nl_cache_refill (priv->nlh, priv->nlh_link_cache))
-		nm_warning ("error updating link cache: %s", nl_geterror ());
-	else {
+	if (nl_cache_refill (priv->nlh, priv->nlh_link_cache)) {
+		nm_log_err (LOGD_HW, "error updating link cache: %s", nl_geterror ());
+	} else {
 		nl_cache_foreach_filter (priv->nlh_link_cache,
 		                         NULL,
 		                         netlink_object_message_handler,
diff --git a/src/nm-netlink.c b/src/nm-netlink.c
index ad68790..c55c093 100644
--- a/src/nm-netlink.c
+++ b/src/nm-netlink.c
@@ -21,7 +21,7 @@
 #include "config.h"
 
 #include "nm-netlink.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 #include <glib.h>
 #include <signal.h>
@@ -40,7 +40,7 @@ get_link_cache (void)
 
 	nlh = nm_netlink_get_default_handle ();
 	if (G_UNLIKELY (!nlh)) {
-		nm_warning ("couldn't allocate netlink handle.");
+		nm_log_err (LOGD_HW, "couldn't allocate netlink handle.");
 		return NULL;
 	}
 
@@ -48,7 +48,7 @@ get_link_cache (void)
 		link_cache = rtnl_link_alloc_cache (nlh);
 
 	if (G_UNLIKELY (!link_cache)) {
-		nm_warning ("couldn't allocate netlink link cache: %s", nl_geterror ());
+		nm_log_err (LOGD_HW, "couldn't allocate netlink link cache: %s", nl_geterror ());
 		return NULL;
 	}
 
@@ -71,12 +71,12 @@ nm_netlink_get_default_handle (void)
 	cb = nl_cb_alloc(NL_CB_VERBOSE);
 	def_nl_handle = nl_handle_alloc_cb (cb);
 	if (!def_nl_handle) {
-		nm_warning ("couldn't allocate netlink handle.");
+		nm_log_err (LOGD_HW, "couldn't allocate netlink handle.");
 		return NULL;
 	}
 
 	if (nl_connect (def_nl_handle, NETLINK_ROUTE) < 0) {
-		nm_error ("couldn't connect to netlink: %s", nl_geterror ());
+		nm_log_err (LOGD_HW, "couldn't connect to netlink: %s", nl_geterror ());
 		return NULL;
 	}
 
@@ -123,7 +123,7 @@ nm_netlink_index_to_iface (int idx)
 
 	buf = g_malloc0 (MAX_IFACE_LEN);
 	if (buf == NULL) {
-		nm_warning ("Not enough memory to allocate interface name buffer.");
+		nm_log_warn (LOGD_HW, "Not enough memory to allocate interface name buffer.");
 		return NULL;
 	}
 
diff --git a/src/nm-policy-hosts.c b/src/nm-policy-hosts.c
new file mode 100644
index 0000000..35a0b9d
--- /dev/null
+++ b/src/nm-policy-hosts.c
@@ -0,0 +1,173 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <netdb.h>
+#include <ctype.h>
+
+#include "nm-policy-hosts.h"
+
+gboolean
+nm_policy_hosts_find_token (const char *line, const char *token)
+{
+	const char *start = line, *p = line;
+
+	g_return_val_if_fail (line != NULL, FALSE);
+	g_return_val_if_fail (token != NULL, FALSE);
+	g_return_val_if_fail (strlen (token) > 0, FALSE);
+
+	/* Walk through the line to find the next whitespace character */
+	while (p <= line + strlen (line)) {
+		if (isblank (*p) || (*p == '\0')) {
+			/* Token starts with 'start' and ends with 'end' */
+			if ((p > start) && *start && (p - start == strlen (token)) && !strncmp (start, token, (p - start)))
+				return TRUE; /* found */
+
+			/* not found; advance start and continue looking */
+			start = p + 1;
+		}
+		p++;
+	}
+
+	return FALSE;
+}
+
+static gboolean
+is_local_mapping (const char *str, const char *hostname)
+{
+	return (   !strncmp (str, "127.0.0.1", strlen ("127.0.0.1"))
+	        && nm_policy_hosts_find_token (str, hostname ? hostname : "localhost"));
+}
+
+GString *
+nm_policy_get_etc_hosts (const char **lines,
+                         gsize existing_len,
+                         const char *hostname,
+                         const char *fallback_hostname,
+                         GError **error)
+{
+	GString *contents = NULL;
+	const char **line;
+	gboolean found_host_nonlocal = FALSE;
+	gboolean found_host = FALSE;
+	gboolean found_localhost = FALSE;
+	gboolean initial_comments = TRUE;
+	gboolean added = FALSE;
+
+	g_return_val_if_fail (lines != NULL, FALSE);
+	g_return_val_if_fail (hostname != NULL, FALSE);
+
+	/* /etc/hosts needs at least two things:
+	 *
+	 * 1) current hostname mapped to any address
+	 * 2) 'localhost' mapped to 127.0.0.1
+	 *
+	 * If both these conditions exist in /etc/hosts, we don't need to bother
+	 * updating the file.
+	 */
+
+	/* Look for the two cases from above */
+	for (line = lines; lines && *line; line++) {
+		if (strlen (*line) && (*line[0] != '#')) {
+			if (nm_policy_hosts_find_token (*line, hostname)) {
+				if (!is_local_mapping (*line, "localhost")) {
+					/* hostname is not on a 127.0.0.1 line or the line does not
+					 * contain 'localhost'.
+					 */
+					found_host_nonlocal = TRUE;
+				}
+				found_host = TRUE;
+			}
+
+			if (is_local_mapping (*line, "localhost")) {
+				/* a 127.0.0.1 line containing 'localhost' */
+				found_localhost = TRUE;
+			}
+		}
+
+		if (found_localhost && found_host)
+			return NULL;  /* No update required */
+	}
+
+	contents = g_string_sized_new (existing_len ? existing_len + 100 : 200);
+	if (!contents) {
+		g_set_error_literal (error, 0, 0, "not enough memory");
+		return NULL;
+	}
+
+	/* Construct the new hosts file; replace any 127.0.0.1 entry that is at the
+	 * beginning of the file or right after initial comments and contains
+	 * the string 'localhost'.  If there is no 127.0.0.1 entry at the beginning
+	 * or after initial comments that contains 'localhost', add one there
+	 * and ignore any other 127.0.0.1 entries that contain 'localhost'.
+	 */
+	for (line = lines, initial_comments = TRUE; lines && *line; line++) {
+		gboolean add_line = TRUE;
+
+		/* This is the first line after the initial comments */
+		if (strlen (*line) && initial_comments && (*line[0] != '#')) {
+			initial_comments = FALSE;
+
+			/* If some other line contained the hostname but not 'localhost',
+			 * make a simple localhost mapping and assume the user knows what
+			 * they are doing with their manual hostname entry.  Otherwise if
+			 * the hostname wasn't found somewhere else, add it to the localhost
+			 * mapping line to make sure it's mapped to something.
+			 */
+			if (found_host_nonlocal)
+				g_string_append (contents, "127.0.0.1");
+			else
+				g_string_append_printf (contents, "127.0.0.1\t%s", hostname);
+
+			if (strcmp (hostname, fallback_hostname)) {
+				g_string_append_printf (contents, "\t%s", fallback_hostname);
+				/* Don't add a standalone 'localhost.localdomain' 127 mapping */
+				if (is_local_mapping (*line, fallback_hostname))
+					add_line = FALSE;
+			}
+
+			g_string_append (contents, "\tlocalhost\n");
+			added = TRUE;
+
+			/* Don't add the original line if it is a 'localhost' mapping */
+			if (is_local_mapping (*line, "localhost"))
+				add_line = FALSE;
+		}
+
+		if (add_line) {
+			g_string_append (contents, *line);
+			/* Only append the new line if this isn't the last line in the file */
+			if (*(line+1))
+				g_string_append_c (contents, '\n');
+		}
+	}
+
+	/* Hmm, /etc/hosts was empty for some reason */
+	if (!added) {
+		g_string_append (contents, "# Do not remove the following line, or various programs\n");
+		g_string_append (contents, "# that require network functionality will fail.\n");
+		g_string_append_printf (contents, "127.0.0.1\t%s\tlocalhost\n", fallback_hostname);
+	}
+
+	return contents;
+}
+
diff --git a/src/nm-policy-hosts.h b/src/nm-policy-hosts.h
new file mode 100644
index 0000000..4130ad0
--- /dev/null
+++ b/src/nm-policy-hosts.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_POLICY_HOSTS_H
+#define NM_POLICT_HOSTS_H
+
+#include <glib.h>
+
+GString *nm_policy_get_etc_hosts (const char **lines,
+                                  gsize existing_len,
+                                  const char *hostname,
+                                  const char *fallback_hostname,
+                                  GError **error);
+
+/* Only for testcases; don't use outside of nm-policy-hosts.c */
+gboolean nm_policy_hosts_find_token (const char *line, const char *token);
+
+#endif /* NM_POLICY_HOSTS_H */
+
diff --git a/src/nm-policy.c b/src/nm-policy.c
new file mode 100644
index 0000000..7159eaf
--- /dev/null
+++ b/src/nm-policy.c
@@ -0,0 +1,1119 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ * Copyright (C) 2007 - 2008 Novell, Inc.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <netdb.h>
+#include <ctype.h>
+
+#include "nm-policy.h"
+#include "NetworkManagerUtils.h"
+#include "nm-wifi-ap.h"
+#include "nm-activation-request.h"
+#include "nm-logging.h"
+#include "nm-device-interface.h"
+#include "nm-device.h"
+#include "nm-device-wifi.h"
+#include "nm-device-ethernet.h"
+#include "nm-device-modem.h"
+#include "nm-dbus-manager.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-connection.h"
+#include "nm-system.h"
+#include "nm-named-manager.h"
+#include "nm-vpn-manager.h"
+#include "nm-policy-hosts.h"
+
+typedef struct LookupThread LookupThread;
+
+typedef void (*LookupCallback) (LookupThread *thread, gpointer user_data);
+
+struct LookupThread {
+	GThread *thread;
+
+	GMutex *lock;
+	gboolean die;
+	int ret;
+
+	guint32 ip4_addr;
+	char hostname[NI_MAXHOST + 1];
+
+	LookupCallback callback;
+	gpointer user_data;
+};
+
+struct NMPolicy {
+	NMManager *manager;
+	guint update_state_id;
+	GSList *pending_activation_checks;
+	GSList *signal_ids;
+	GSList *dev_signal_ids;
+
+	NMVPNManager *vpn_manager;
+	gulong vpn_activated_id;
+	gulong vpn_deactivated_id;
+
+	NMDevice *default_device;
+
+	LookupThread *lookup;
+
+	char *orig_hostname; /* hostname at NM start time */
+};
+
+static gboolean
+lookup_thread_run_cb (gpointer user_data)
+{
+	LookupThread *thread = (LookupThread *) user_data;
+
+	(*thread->callback) (thread, thread->user_data);
+	return FALSE;
+}
+
+static gpointer
+lookup_thread_worker (gpointer data)
+{
+	LookupThread *thread = (LookupThread *) data;
+	struct sockaddr_in addr;
+
+	g_mutex_lock (thread->lock);
+	if (thread->die) {
+		g_mutex_unlock (thread->lock);
+		return (gpointer) NULL;
+	}
+	g_mutex_unlock (thread->lock);
+
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = thread->ip4_addr;
+
+	thread->ret = getnameinfo ((struct sockaddr *) &addr, sizeof (struct sockaddr_in),
+	                           thread->hostname, NI_MAXHOST, NULL, 0,
+	                           NI_NAMEREQD);
+	if (thread->ret == 0) {
+		int i;
+
+		for (i = 0; i < strlen (thread->hostname); i++)
+			thread->hostname[i] = tolower (thread->hostname[i]);
+	}
+
+	/* Don't track the idle handler ID because by the time the g_idle_add()
+	 * returns the ID, the handler may already have run and freed the
+	 * LookupThread.
+	 */
+	g_idle_add (lookup_thread_run_cb, thread);
+	return (gpointer) TRUE;
+}
+
+static void
+lookup_thread_free (LookupThread *thread)
+{
+	g_return_if_fail (thread != NULL);
+
+	g_mutex_free (thread->lock);
+	memset (thread, 0, sizeof (LookupThread));
+	g_free (thread);
+}
+
+static LookupThread *
+lookup_thread_new (guint32 ip4_addr, LookupCallback callback, gpointer user_data)
+{
+	LookupThread *thread;
+
+	thread = g_malloc0 (sizeof (LookupThread));
+	if (!thread)
+		return NULL;
+
+	thread->lock = g_mutex_new ();
+	thread->callback = callback;
+	thread->user_data = user_data;
+	thread->ip4_addr = ip4_addr;
+
+	thread->thread = g_thread_create (lookup_thread_worker, thread, FALSE, NULL);
+	if (!thread->thread) {
+		lookup_thread_free (thread);
+		return NULL;
+	}
+
+	return thread;
+}
+
+static void
+lookup_thread_die (LookupThread *thread)
+{
+	g_return_if_fail (thread != NULL);
+
+	g_mutex_lock (thread->lock);
+	thread->die = TRUE;
+	g_mutex_unlock (thread->lock);
+}
+
+#define INVALID_TAG "invalid"
+
+static const char *
+get_connection_id (NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_return_val_if_fail (s_con != NULL, NULL);
+
+	return nm_setting_connection_get_id (s_con);
+}
+
+static NMDevice *
+get_best_device (NMManager *manager, NMActRequest **out_req)
+{
+	GSList *devices, *iter;
+	NMDevice *best = NULL;
+	int best_prio = G_MAXINT;
+
+	g_return_val_if_fail (manager != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
+	g_return_val_if_fail (out_req != NULL, NULL);
+	g_return_val_if_fail (*out_req == NULL, NULL);
+
+	devices = nm_manager_get_devices (manager);
+	for (iter = devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *dev = NM_DEVICE (iter->data);
+		NMActRequest *req;
+		NMConnection *connection;
+		NMIP4Config *ip4_config;
+		NMSettingIP4Config *s_ip4;
+		int prio;
+		guint i;
+		gboolean can_default = FALSE;
+		const char *method = NULL;
+
+		if (nm_device_get_state (dev) != NM_DEVICE_STATE_ACTIVATED)
+			continue;
+
+		ip4_config = nm_device_get_ip4_config (dev);
+		if (!ip4_config)
+			continue;
+
+		req = nm_device_get_act_request (dev);
+		g_assert (req);
+		connection = nm_act_request_get_connection (req);
+		g_assert (connection);
+
+		/* Never set the default route through an IPv4LL-addressed device */
+		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
+		if (s_ip4)
+			method = nm_setting_ip4_config_get_method (s_ip4);
+
+		if (s_ip4 && !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
+			continue;
+
+		/* Make sure at least one of this device's IP addresses has a gateway */
+		for (i = 0; i < nm_ip4_config_get_num_addresses (ip4_config); i++) {
+			NMIP4Address *addr;
+
+			addr = nm_ip4_config_get_address (ip4_config, i);
+			if (nm_ip4_address_get_gateway (addr)) {
+				can_default = TRUE;
+				break;
+			}
+		}
+
+		if (!can_default && !NM_IS_DEVICE_MODEM (dev))
+			continue;
+
+		/* 'never-default' devices can't ever be the default */
+		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
+			continue;
+
+		prio = nm_device_get_priority (dev);
+		if (prio > 0 && prio < best_prio) {
+			best = dev;
+			best_prio = prio;
+			*out_req = req;
+		}
+	}
+
+	return best;
+}
+
+#define FALLBACK_HOSTNAME "localhost.localdomain"
+
+static gboolean
+update_etc_hosts (const char *hostname, gboolean *out_changed)
+{
+	char *contents = NULL;
+	char **lines = NULL;
+	GError *error = NULL;
+	GString *new_contents = NULL;
+	gsize contents_len = 0;
+	gboolean success = FALSE;
+
+	g_return_val_if_fail (hostname != NULL, FALSE);
+	g_return_val_if_fail (out_changed != NULL, FALSE);
+
+	if (!g_file_get_contents (SYSCONFDIR "/hosts", &contents, &contents_len, &error)) {
+		nm_log_warn (LOGD_DNS, "couldn't read " SYSCONFDIR "/hosts: (%d) %s",
+		             error ? error->code : 0,
+		             (error && error->message) ? error->message : "(unknown)");
+		g_clear_error (&error);
+		return FALSE;
+	}
+
+	/* Get the new /etc/hosts contents */
+	lines = g_strsplit_set (contents, "\n\r", 0);
+	new_contents = nm_policy_get_etc_hosts ((const char **) lines,
+	                                        contents_len,
+	                                        hostname,
+	                                        FALLBACK_HOSTNAME,
+	                                        &error);
+	g_strfreev (lines);
+	g_free (contents);
+
+	if (new_contents) {
+		nm_log_info (LOGD_DNS, "Updating /etc/hosts with new system hostname");
+
+		g_clear_error (&error);
+		/* And actually update /etc/hosts */
+		if (!g_file_set_contents (SYSCONFDIR "/hosts", new_contents->str, -1, &error)) {
+			nm_log_warn (LOGD_DNS, "couldn't update " SYSCONFDIR "/hosts: (%d) %s",
+			             error ? error->code : 0,
+			             (error && error->message) ? error->message : "(unknown)");
+			g_clear_error (&error);
+		} else {
+			success = TRUE;
+			*out_changed = TRUE;
+		}
+
+		g_string_free (new_contents, TRUE);
+	} else if (!error) {
+		/* No change required */
+		success = TRUE;
+	} else {
+		nm_log_warn (LOGD_DNS, "couldn't read " SYSCONFDIR "/hosts: (%d) %s",
+		             error->code, error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+	}
+
+	return success;
+}
+
+static void
+set_system_hostname (const char *new_hostname, const char *msg)
+{
+	char old_hostname[HOST_NAME_MAX + 1];
+	int ret = 0;
+	const char *name = new_hostname ? new_hostname : FALLBACK_HOSTNAME;
+	gboolean set_hostname = TRUE, changed = FALSE;
+
+	old_hostname[HOST_NAME_MAX] = '\0';
+	errno = 0;
+	ret = gethostname (old_hostname, HOST_NAME_MAX);
+	if (ret != 0) {
+		nm_log_warn (LOGD_DNS, "couldn't get the system hostname: (%d) %s",
+		             errno, strerror (errno));
+	} else {
+		/* Don't set the hostname if it isn't actually changing */
+		if (   (new_hostname && !strcmp (old_hostname, new_hostname))
+		    || (!new_hostname && !strcmp (old_hostname, FALLBACK_HOSTNAME)))
+			set_hostname = FALSE;
+	}
+
+	if (set_hostname) {
+		nm_log_info (LOGD_DNS, "Setting system hostname to '%s' (%s)", name, msg);
+		ret = sethostname (name, strlen (name));
+		if (ret != 0) {
+			nm_log_warn (LOGD_DNS, "couldn't set the system hostname to '%s': (%d) %s",
+			             name, errno, strerror (errno));
+			return;
+		}
+	}
+
+	/* But still always try updating /etc/hosts just in case the hostname
+	 * changed while NM wasn't running; we need to make sure that /etc/hosts
+	 * has valid mappings for '127.0.0.1' and the current system hostname.  If
+	 * those exist, update_etc_hosts() will just return and won't touch
+	 * /etc/hosts at all.
+	 */
+	if (!update_etc_hosts (name, &changed)) {
+		/* error updating /etc/hosts; fallback to localhost.localdomain */
+		nm_log_info (LOGD_DNS, "Setting system hostname to '" FALLBACK_HOSTNAME "' (error updating /etc/hosts)");
+		ret = sethostname (FALLBACK_HOSTNAME, strlen (FALLBACK_HOSTNAME));
+		if (ret != 0) {
+			nm_log_warn (LOGD_DNS, "couldn't set the fallback system hostname (%s): (%d) %s",
+			             FALLBACK_HOSTNAME, errno, strerror (errno));
+		}
+	}
+
+	if (changed)
+		nm_utils_call_dispatcher ("hostname", NULL, NULL, NULL);
+}
+
+static void
+lookup_callback (LookupThread *thread, gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+
+	/* If the thread was told to die or it's not the current in-progress
+	 * hostname lookup, nothing to do.
+	 */
+	if (thread->die || (thread != policy->lookup))
+		goto done;
+
+	policy->lookup = NULL;
+	if (!strlen (thread->hostname)) {
+		char *msg;
+
+		/* No valid IP4 config (!!); fall back to localhost.localdomain */
+		msg = g_strdup_printf ("address lookup failed: %d", thread->ret);
+		set_system_hostname (NULL, msg);
+		g_free (msg);
+	} else
+		set_system_hostname (thread->hostname, "from address lookup");
+
+done:
+	lookup_thread_free (thread);
+}
+
+static void
+update_system_hostname (NMPolicy *policy, NMDevice *best)
+{
+	char *configured_hostname = NULL;
+	NMActRequest *best_req = NULL;
+	NMDHCP4Config *dhcp4_config;
+	NMIP4Config *ip4_config;
+	NMIP4Address *addr;
+
+	g_return_if_fail (policy != NULL);
+
+	if (policy->lookup) {
+		lookup_thread_die (policy->lookup);
+		policy->lookup = NULL;
+	}
+
+	/* Hostname precedence order:
+	 *
+	 * 1) a configured hostname (from system-settings)
+	 * 2) automatic hostname from the default device's config (DHCP, VPN, etc)
+	 * 3) the original hostname when NM started
+	 * 4) reverse-DNS of the best device's IPv4 address
+	 *
+	 */
+
+	/* Try a persistent hostname first */
+	g_object_get (G_OBJECT (policy->manager), NM_MANAGER_HOSTNAME, &configured_hostname, NULL);
+	if (configured_hostname) {
+		set_system_hostname (configured_hostname, "from system configuration");
+		g_free (configured_hostname);
+		return;
+	}
+
+	/* Try automatically determined hostname from the best device's IP config */
+	if (!best)
+		best = get_best_device (policy->manager, &best_req);
+
+	if (!best) {
+		/* No best device; fall back to original hostname or if there wasn't
+		 * one, 'localhost.localdomain'
+		 */
+		set_system_hostname (policy->orig_hostname, "no default device");
+		return;
+	}
+
+	/* Grab a hostname out of the device's DHCP4 config */
+	dhcp4_config = nm_device_get_dhcp4_config (best);
+	if (dhcp4_config) {
+		const char *dhcp4_hostname, *p;
+
+		p = dhcp4_hostname = nm_dhcp4_config_get_option (dhcp4_config, "host_name");
+		if (dhcp4_hostname && strlen (dhcp4_hostname)) {
+			/* Sanity check */
+			while (*p) {
+				if (!isblank (*p++)) {
+					set_system_hostname (dhcp4_hostname, "from DHCP");
+					return;
+				}
+			}
+			nm_log_warn (LOGD_DNS, "DHCP-provided hostname '%s' looks invalid; ignoring it",
+			             dhcp4_hostname);
+		}
+	}
+
+	/* If no automatically-configured hostname, try using the hostname from
+	 * when NM started up.
+	 */
+	if (policy->orig_hostname) {
+		set_system_hostname (policy->orig_hostname, "from system startup");
+		return;
+	}
+
+	/* No configured hostname, no automatically determined hostname, and
+	 * no bootup hostname. Start reverse DNS of the current IP address.
+	 */
+	ip4_config = nm_device_get_ip4_config (best);
+	if (   !ip4_config
+	    || (nm_ip4_config_get_num_nameservers (ip4_config) == 0)
+	    || (nm_ip4_config_get_num_addresses (ip4_config) == 0)) {
+		/* No valid IP4 config (!!); fall back to localhost.localdomain */
+		set_system_hostname (NULL, "no IPv4 config");
+		return;
+	}
+
+	addr = nm_ip4_config_get_address (ip4_config, 0);
+	g_assert (addr); /* checked for > 1 address above */
+
+	/* Start the hostname lookup thread */
+	policy->lookup = lookup_thread_new (nm_ip4_address_get_address (addr), lookup_callback, policy);
+	if (!policy->lookup) {
+		/* Fall back to 'localhost.localdomain' */
+		set_system_hostname (NULL, "error starting hostname thread");
+	}
+}
+
+static void
+update_routing_and_dns (NMPolicy *policy, gboolean force_update)
+{
+	NMNamedIPConfigType dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
+	NMDevice *best = NULL;
+	NMActRequest *best_req = NULL;
+	NMNamedManager *named_mgr;
+	GSList *devices = NULL, *iter, *vpns;
+	NMIP4Config *ip4_config = NULL;
+	NMIP4Address *addr;
+	const char *ip_iface = NULL;
+	NMConnection *connection = NULL;
+	NMSettingConnection *s_con = NULL;
+	const char *connection_id;
+
+	best = get_best_device (policy->manager, &best_req);
+	if (!best)
+		goto out;
+	if (!force_update && (best == policy->default_device))
+		goto out;
+
+	/* If a VPN connection is active, it is preferred */
+	vpns = nm_vpn_manager_get_active_connections (policy->vpn_manager);
+	for (iter = vpns; iter; iter = g_slist_next (iter)) {
+		NMVPNConnection *candidate = NM_VPN_CONNECTION (iter->data);
+		NMConnection *vpn_connection;
+		NMSettingIP4Config *s_ip4;
+		gboolean can_default = TRUE;
+		NMVPNConnectionState vpn_state;
+
+		/* If it's marked 'never-default', don't make it default */
+		vpn_connection = nm_vpn_connection_get_connection (candidate);
+		g_assert (vpn_connection);
+		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (vpn_connection, NM_TYPE_SETTING_IP4_CONFIG);
+		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
+			can_default = FALSE;
+
+		vpn_state = nm_vpn_connection_get_vpn_state (candidate);
+		if (can_default && (vpn_state == NM_VPN_CONNECTION_STATE_ACTIVATED)) {
+			NMIP4Config *parent_ip4;
+			NMDevice *parent;
+
+			ip_iface = nm_vpn_connection_get_ip_iface (candidate);
+			connection = nm_vpn_connection_get_connection (candidate);
+			ip4_config = nm_vpn_connection_get_ip4_config (candidate);
+			addr = nm_ip4_config_get_address (ip4_config, 0);
+
+			parent = nm_vpn_connection_get_parent_device (candidate);
+			parent_ip4 = nm_device_get_ip4_config (parent);
+
+			nm_system_replace_default_ip4_route_vpn (ip_iface,
+			                                         nm_ip4_address_get_gateway (addr),
+			                                         nm_vpn_connection_get_ip4_internal_gateway (candidate),
+			                                         nm_ip4_config_get_mss (ip4_config),
+			                                         nm_device_get_ip_iface (parent),
+			                                         nm_ip4_config_get_mss (parent_ip4));
+
+			dns_type = NM_NAMED_IP_CONFIG_TYPE_VPN;
+		}
+		g_object_unref (candidate);
+	}
+	g_slist_free (vpns);
+
+	/* The best device gets the default route if a VPN connection didn't */
+	if (!ip_iface || !ip4_config) {
+		connection = nm_act_request_get_connection (best_req);
+		ip_iface = nm_device_get_ip_iface (best);
+		ip4_config = nm_device_get_ip4_config (best);
+		g_assert (ip4_config);
+		addr = nm_ip4_config_get_address (ip4_config, 0);
+
+		nm_system_replace_default_ip4_route (ip_iface, nm_ip4_address_get_gateway (addr), nm_ip4_config_get_mss (ip4_config));
+
+		dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
+	}
+
+	if (!ip_iface || !ip4_config) {
+		nm_log_warn (LOGD_CORE, "couldn't determine IP interface (%p) or IPv4 config (%p)!",
+		             ip_iface, ip4_config);
+		goto out;
+	}
+
+	/* Update the default active connection.  Only mark the new default
+	 * active connection after setting default = FALSE on all other connections
+	 * first.  The order is important, we don't want two connections marked
+	 * default at the same time ever.
+	 */
+	devices = nm_manager_get_devices (policy->manager);
+	for (iter = devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *dev = NM_DEVICE (iter->data);
+		NMActRequest *req;
+
+		req = nm_device_get_act_request (dev);
+		if (req && (req != best_req))
+			nm_act_request_set_default (req, FALSE);
+	}
+
+	named_mgr = nm_named_manager_get ();
+	nm_named_manager_add_ip4_config (named_mgr, ip_iface, ip4_config, dns_type);
+	g_object_unref (named_mgr);
+
+	/* Now set new default active connection _after_ updating DNS info, so that
+	 * if the connection is shared dnsmasq picks up the right stuff.
+	 */
+	if (best_req)
+		nm_act_request_set_default (best_req, TRUE);
+
+	if (connection)
+		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+
+	connection_id = s_con ? nm_setting_connection_get_id (s_con) : NULL;
+	if (connection_id) {
+		nm_log_info (LOGD_CORE, "Policy set '%s' (%s) as default for routing and DNS.", connection_id, ip_iface);
+	} else {
+		nm_log_info (LOGD_CORE, "Policy set (%s) as default for routing and DNS.", ip_iface);
+	}
+
+out:
+	/* Update the system hostname */
+	update_system_hostname (policy, best);
+
+	policy->default_device = best;	
+}
+
+typedef struct {
+	NMPolicy *policy;
+	NMDevice *device;
+	guint id;
+} ActivateData;
+
+static gboolean
+auto_activate_device (gpointer user_data)
+{
+	ActivateData *data = (ActivateData *) user_data;
+	NMPolicy *policy;
+	NMConnection *best_connection;
+	char *specific_object = NULL;
+	GSList *connections, *iter;
+
+	g_assert (data);
+	policy = data->policy;
+
+	// FIXME: if a device is already activating (or activated) with a connection
+	// but another connection now overrides the current one for that device,
+	// deactivate the device and activate the new connection instead of just
+	// bailing if the device is already active
+	if (nm_device_get_act_request (data->device))
+		goto out;
+
+	/* System connections first, then user connections */
+	connections = nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_SYSTEM);
+	connections = g_slist_concat (connections, nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_USER));
+
+	/* Remove connections that are in the invalid list. */
+	iter = connections;
+	while (iter) {
+		NMConnection *iter_connection = NM_CONNECTION (iter->data);
+		GSList *next = g_slist_next (iter);
+
+		if (g_object_get_data (G_OBJECT (iter_connection), INVALID_TAG)) {
+			connections = g_slist_remove_link (connections, iter);
+			g_object_unref (iter_connection);
+			g_slist_free (iter);
+		}
+		iter = next;
+	}
+
+	best_connection = nm_device_get_best_auto_connection (data->device, connections, &specific_object);
+	if (best_connection) {
+		GError *error = NULL;
+		const char *device_path;
+
+		device_path = nm_device_get_path (data->device);
+		if (!nm_manager_activate_connection (policy->manager,
+		                                     best_connection,
+		                                     specific_object,
+		                                     device_path,
+		                                     FALSE,
+		                                     &error)) {
+			NMSettingConnection *s_con;
+
+			s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (best_connection, NM_TYPE_SETTING_CONNECTION));
+			g_assert (s_con);
+
+			nm_log_info (LOGD_DEVICE, "Connection '%s' auto-activation failed: (%d) %s",
+			             nm_setting_connection_get_id (s_con), error->code, error->message);
+			g_error_free (error);
+		}
+	}
+
+	g_slist_foreach (connections, (GFunc) g_object_unref, NULL);
+	g_slist_free (connections);
+
+ out:
+	/* Remove this call's handler ID */
+	policy->pending_activation_checks = g_slist_remove (policy->pending_activation_checks, data);
+	g_object_unref (data->device);
+	g_free (data);
+
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+static void
+vpn_connection_activated (NMVPNManager *manager,
+                          NMVPNConnection *vpn,
+                          gpointer user_data)
+{
+	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
+}
+
+static void
+vpn_connection_deactivated (NMVPNManager *manager,
+                            NMVPNConnection *vpn,
+                            NMVPNConnectionState state,
+                            NMVPNConnectionStateReason reason,
+                            gpointer user_data)
+{
+	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
+}
+
+static void
+global_state_changed (NMManager *manager, NMState state, gpointer user_data)
+{
+}
+
+static void
+hostname_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
+{
+	update_system_hostname ((NMPolicy *) user_data, NULL);
+}
+
+static void
+sleeping_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
+{
+	gboolean sleeping = FALSE;
+	GSList *connections, *iter;
+
+	g_object_get (G_OBJECT (manager), NM_MANAGER_SLEEPING, &sleeping, NULL);
+
+	/* Clear the invalid flag on all connections so they'll get retried on wakeup */
+	if (sleeping) {
+		connections = nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_SYSTEM);
+		connections = g_slist_concat (connections, nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_USER));
+		for (iter = connections; iter; iter = g_slist_next (iter))
+			g_object_set_data (G_OBJECT (iter->data), INVALID_TAG, NULL);
+		g_slist_free (connections);
+	}
+}
+
+static void
+schedule_activate_check (NMPolicy *policy, NMDevice *device, guint delay_seconds)
+{
+	ActivateData *data;
+	GSList *iter;
+	NMDeviceState state;
+
+	if (nm_manager_get_state (policy->manager) == NM_STATE_ASLEEP)
+		return;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	if (state < NM_DEVICE_STATE_DISCONNECTED)
+		return;
+
+	if (!nm_device_autoconnect_allowed (device))
+		return;
+
+	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
+		/* Only one pending activation check at a time */
+		if (((ActivateData *) iter->data)->device == device)
+			return;
+	}
+
+	data = g_malloc0 (sizeof (ActivateData));
+	g_return_if_fail (data != NULL);
+
+	data->policy = policy;
+	data->device = g_object_ref (device);
+	data->id = delay_seconds ? g_timeout_add_seconds (delay_seconds, auto_activate_device, data) : g_idle_add (auto_activate_device, data);
+	policy->pending_activation_checks = g_slist_append (policy->pending_activation_checks, data);
+}
+
+static NMConnection *
+get_device_connection (NMDevice *device)
+{
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (device);
+	if (!req)
+		return NULL;
+
+	return nm_act_request_get_connection (req);
+}
+
+static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+	NMConnection *connection = get_device_connection (device);
+
+	switch (new_state) {
+	case NM_DEVICE_STATE_FAILED:
+		/* Mark the connection invalid if it failed during activation so that
+		 * it doesn't get automatically chosen over and over and over again.
+		 */
+		if (connection && IS_ACTIVATING_STATE (old_state)) {
+			g_object_set_data (G_OBJECT (connection), INVALID_TAG, GUINT_TO_POINTER (TRUE));
+			nm_log_info (LOGD_DEVICE, "Marking connection '%s' invalid.", get_connection_id (connection));
+			nm_connection_clear_secrets (connection);
+		}
+		schedule_activate_check (policy, device, 3);
+		break;
+	case NM_DEVICE_STATE_ACTIVATED:
+		if (connection) {
+			/* Clear the invalid tag on the connection */
+			g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
+
+			/* And clear secrets so they will always be requested from the
+			 * settings service when the next connection is made.
+			 */
+			nm_connection_clear_secrets (connection);
+		}
+
+		update_routing_and_dns (policy, FALSE);
+		break;
+	case NM_DEVICE_STATE_UNMANAGED:
+	case NM_DEVICE_STATE_UNAVAILABLE:
+	case NM_DEVICE_STATE_DISCONNECTED:
+		update_routing_and_dns (policy, FALSE);
+		schedule_activate_check (policy, device, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+device_ip4_config_changed (NMDevice *device,
+                           GParamSpec *pspec,
+                           gpointer user_data)
+{
+	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
+}
+
+static void
+wireless_networks_changed (NMDeviceWifi *device, NMAccessPoint *ap, gpointer user_data)
+{
+	schedule_activate_check ((NMPolicy *) user_data, NM_DEVICE (device), 0);
+}
+
+typedef struct {
+	gulong id;
+	NMDevice *device;
+} DeviceSignalID;
+
+static GSList *
+add_device_signal_id (GSList *list, gulong id, NMDevice *device)
+{
+	DeviceSignalID *data;
+
+	data = g_malloc0 (sizeof (DeviceSignalID));
+	if (!data)
+		return list;
+
+	data->id = id;
+	data->device = device;
+	return g_slist_append (list, data);
+}
+
+static void
+device_added (NMManager *manager, NMDevice *device, gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+	gulong id;
+
+	id = g_signal_connect (device, "state-changed",
+	                       G_CALLBACK (device_state_changed),
+	                       policy);
+	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+
+	id = g_signal_connect (device, "notify::" NM_DEVICE_INTERFACE_IP4_CONFIG,
+	                       G_CALLBACK (device_ip4_config_changed),
+	                       policy);
+	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+
+	if (NM_IS_DEVICE_WIFI (device)) {
+		id = g_signal_connect (device, "access-point-added",
+		                       G_CALLBACK (wireless_networks_changed),
+		                       policy);
+		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+
+		id = g_signal_connect (device, "access-point-removed",
+		                       G_CALLBACK (wireless_networks_changed),
+		                       policy);
+		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+	}
+}
+
+static void
+device_removed (NMManager *manager, NMDevice *device, gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+	GSList *iter;
+
+	/* Clear any idle callbacks for this device */
+	iter = policy->pending_activation_checks;
+	while (iter) {
+		ActivateData *data = (ActivateData *) iter->data;
+		GSList *next = g_slist_next (iter);
+
+		if (data->device == device) {
+			g_source_remove (data->id);
+			g_object_unref (data->device);
+			g_free (data);
+			policy->pending_activation_checks = g_slist_delete_link (policy->pending_activation_checks, iter);
+		}
+		iter = next;
+	}
+
+	/* Clear any signal handlers for this device */
+	iter = policy->dev_signal_ids;
+	while (iter) {
+		DeviceSignalID *data = (DeviceSignalID *) iter->data;
+		GSList *next = g_slist_next (iter);
+
+		if (data->device == device) {
+			g_signal_handler_disconnect (data->device, data->id);
+			g_free (data);
+			policy->dev_signal_ids = g_slist_delete_link (policy->dev_signal_ids, iter);
+		}
+		iter = next;
+	}
+
+	update_routing_and_dns (policy, FALSE);
+}
+
+static void
+schedule_activate_all (NMPolicy *policy)
+{
+	GSList *iter, *devices;
+
+	devices = nm_manager_get_devices (policy->manager);
+	for (iter = devices; iter; iter = g_slist_next (iter))
+		schedule_activate_check (policy, NM_DEVICE (iter->data), 0);
+}
+
+static void
+connections_added (NMManager *manager,
+                   NMConnectionScope scope,
+                   gpointer user_data)
+{
+	schedule_activate_all ((NMPolicy *) user_data);
+}
+
+static void
+connection_added (NMManager *manager,
+                  NMConnection *connection,
+                  NMConnectionScope scope,
+                  gpointer user_data)
+{
+	schedule_activate_all ((NMPolicy *) user_data);
+}
+
+static void
+connection_updated (NMManager *manager,
+                    NMConnection *connection,
+                    NMConnectionScope scope,
+                    gpointer user_data)
+{
+	/* Clear the invalid tag on the connection if it got updated. */
+	g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
+
+	schedule_activate_all ((NMPolicy *) user_data);
+}
+
+static void
+connection_removed (NMManager *manager,
+                    NMConnection *connection,
+                    NMConnectionScope scope,
+                    gpointer user_data)
+{
+	NMSettingConnection *s_con;
+	GPtrArray *list;
+	int i;
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	if (!s_con)
+		return;
+
+	list = nm_manager_get_active_connections_by_connection (manager, connection);
+	if (!list)
+		return;
+
+	for (i = 0; i < list->len; i++) {
+		char *path = g_ptr_array_index (list, i);
+		GError *error = NULL;
+
+		if (!nm_manager_deactivate_connection (manager, path, NM_DEVICE_STATE_REASON_CONNECTION_REMOVED, &error)) {
+			nm_log_warn (LOGD_DEVICE, "Connection '%s' disappeared, but error deactivating it: (%d) %s",
+			             nm_setting_connection_get_id (s_con), error->code, error->message);
+			g_error_free (error);
+		}
+		g_free (path);
+	}
+	g_ptr_array_free (list, TRUE);
+}
+
+NMPolicy *
+nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager)
+{
+	NMPolicy *policy;
+	static gboolean initialized = FALSE;
+	gulong id;
+	char hostname[HOST_NAME_MAX + 2];
+
+	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
+	g_return_val_if_fail (initialized == FALSE, NULL);
+
+	policy = g_malloc0 (sizeof (NMPolicy));
+	policy->manager = g_object_ref (manager);
+	policy->update_state_id = 0;
+
+	/* Grab hostname on startup and use that if nothing provides one */
+	memset (hostname, 0, sizeof (hostname));
+	if (gethostname (&hostname[0], HOST_NAME_MAX) == 0) {
+		/* only cache it if it's a valid hostname */
+		if (strlen (hostname) && strcmp (hostname, "localhost") && strcmp (hostname, "localhost.localdomain"))
+			policy->orig_hostname = g_strdup (hostname);
+	}
+
+	policy->vpn_manager = g_object_ref (vpn_manager);
+	id = g_signal_connect (policy->vpn_manager, "connection-activated",
+	                       G_CALLBACK (vpn_connection_activated), policy);
+	policy->vpn_activated_id = id;
+	id = g_signal_connect (policy->vpn_manager, "connection-deactivated",
+	                       G_CALLBACK (vpn_connection_deactivated), policy);
+	policy->vpn_deactivated_id = id;
+
+	id = g_signal_connect (manager, "state-changed",
+	                       G_CALLBACK (global_state_changed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "notify::" NM_MANAGER_HOSTNAME,
+	                       G_CALLBACK (hostname_changed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "notify::" NM_MANAGER_SLEEPING,
+	                       G_CALLBACK (sleeping_changed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "device-added",
+	                       G_CALLBACK (device_added), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "device-removed",
+	                       G_CALLBACK (device_removed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	/* Large batch of connections added, manager doesn't want us to
+	 * process each one individually.
+	 */
+	id = g_signal_connect (manager, "connections-added",
+	                       G_CALLBACK (connections_added), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	/* Single connection added */
+	id = g_signal_connect (manager, "connection-added",
+	                       G_CALLBACK (connection_added), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "connection-updated",
+	                       G_CALLBACK (connection_updated), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "connection-removed",
+	                       G_CALLBACK (connection_removed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	return policy;
+}
+
+void
+nm_policy_destroy (NMPolicy *policy)
+{
+	GSList *iter;
+
+	g_return_if_fail (policy != NULL);
+
+	/* Tell any existing hostname lookup thread to die, it'll get cleaned up
+	 * by the lookup thread callback.
+	  */
+	if (policy->lookup) {
+		lookup_thread_die (policy->lookup);
+		policy->lookup = NULL;
+	}
+
+	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
+		ActivateData *data = (ActivateData *) iter->data;
+
+		g_source_remove (data->id);
+		g_object_unref (data->device);
+		g_free (data);
+	}
+	g_slist_free (policy->pending_activation_checks);
+
+	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_activated_id);
+	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_deactivated_id);
+
+	for (iter = policy->signal_ids; iter; iter = g_slist_next (iter))
+		g_signal_handler_disconnect (policy->manager, (gulong) iter->data);
+	g_slist_free (policy->signal_ids);
+
+	for (iter = policy->dev_signal_ids; iter; iter = g_slist_next (iter)) {
+		DeviceSignalID *data = (DeviceSignalID *) iter->data;
+
+		g_signal_handler_disconnect (data->device, data->id);
+		g_free (data);
+	}
+	g_slist_free (policy->dev_signal_ids);
+
+	g_free (policy->orig_hostname);
+
+	g_object_unref (policy->manager);
+	g_free (policy);
+}
+
diff --git a/src/nm-policy.h b/src/nm-policy.h
new file mode 100644
index 0000000..7d99613
--- /dev/null
+++ b/src/nm-policy.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2007 - 2008 Novell, Inc.
+ */
+
+#ifndef NETWORK_MANAGER_POLICY_H
+#define NETWORK_MANAGER_POLICY_H
+
+#include "NetworkManager.h"
+#include "nm-manager.h"
+#include "nm-vpn-manager.h"
+#include "nm-device.h"
+#include "nm-activation-request.h"
+
+typedef struct NMPolicy NMPolicy;
+
+NMPolicy *nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager);
+void nm_policy_destroy (NMPolicy *policy);
+
+#endif /* NETWORK_MANAGER_POLICY_H */
diff --git a/src/nm-properties-changed-signal.c b/src/nm-properties-changed-signal.c
index 8d6c3a4..4a9db8a 100644
--- a/src/nm-properties-changed-signal.c
+++ b/src/nm-properties-changed-signal.c
@@ -106,7 +106,7 @@ properties_changed (gpointer data)
 	{
 		char buf[2048] = { 0, };
 		g_hash_table_foreach (info->hash, add_to_string, &buf);
-		g_message ("%s: %s -> %s", __func__, G_OBJECT_TYPE_NAME (object), buf);
+		nm_log_dbg (LOGD_CORE, "%s -> %s", G_OBJECT_TYPE_NAME (object), buf);
 	}
 #endif
 
diff --git a/src/nm-secrets-provider-interface.c b/src/nm-secrets-provider-interface.c
index 9bbde7a..47b8e57 100644
--- a/src/nm-secrets-provider-interface.c
+++ b/src/nm-secrets-provider-interface.c
@@ -25,7 +25,7 @@
 
 #include <nm-setting-8021x.h>
 #include <nm-setting-wireless-security.h>
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 static void
 nm_secrets_provider_interface_init (gpointer g_iface)
@@ -108,7 +108,7 @@ nm_secrets_provider_interface_get_secrets (NMSecretsProviderInterface *self,
 	                       connection, setting_name, request_new, caller, hint1, hint2,
 	                       &success);
 	if (!success) {
-		nm_warning ("failed to get connection secrets.");
+		nm_log_warn (LOGD_CORE, "failed to get connection secrets.");
 		return FALSE;
 	}
 
@@ -193,7 +193,7 @@ nm_secrets_provider_interface_get_secrets_result (NMSecretsProviderInterface *se
 
 		hash = g_hash_table_lookup (settings, name);
 		if (!hash) {
-			nm_warning ("couldn't get setting secrets for '%s'", name);
+			nm_log_warn (LOGD_CORE, "couldn't get setting secrets for '%s'", name);
 			continue;
 		}
 
diff --git a/src/nm-secrets-provider-interface.h b/src/nm-secrets-provider-interface.h
index 299e8c2..3d9e08b 100644
--- a/src/nm-secrets-provider-interface.h
+++ b/src/nm-secrets-provider-interface.h
@@ -28,8 +28,7 @@ typedef enum {
 	SECRETS_CALLER_NONE = 0,
 	SECRETS_CALLER_ETHERNET,
 	SECRETS_CALLER_WIFI,
-	SECRETS_CALLER_GSM,
-	SECRETS_CALLER_CDMA,
+	SECRETS_CALLER_MOBILE_BROADBAND,
 	SECRETS_CALLER_PPP,
 	SECRETS_CALLER_VPN
 } RequestSecretsCaller;
diff --git a/src/nm-system.c b/src/nm-system.c
new file mode 100644
index 0000000..bd5f57f
--- /dev/null
+++ b/src/nm-system.c
@@ -0,0 +1,1130 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ * Copyright (C) 2005 - 2008 Novell, Inc.
+ * Copyright (C) 1996 - 1997 Yoichi Hariguchi <yoichi@fore.com>
+ * Copyright (C) January, 1998 Sergei Viznyuk <sv@phystech.com>
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+#include <net/route.h>
+#include <arpa/nameser.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <resolv.h>
+#include <netdb.h>
+#include <glib.h>
+#include <ctype.h>
+#include <net/if.h>
+
+#include "nm-system.h"
+#include "nm-device.h"
+#include "nm-named-manager.h"
+#include "NetworkManagerUtils.h"
+#include "nm-utils.h"
+#include "nm-logging.h"
+#include "nm-netlink.h"
+
+/* Because of a bug in libnl, rtnl.h should be included before route.h */
+#include <netlink/route/rtnl.h>
+
+#include <netlink/route/addr.h>
+#include <netlink/route/route.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/link.h>
+
+static void nm_system_device_set_priority (const char *iface,
+								   NMIP4Config *config,
+								   int priority);
+
+static gboolean
+ip4_dest_in_same_subnet (NMIP4Config *config, guint32 dest, guint32 dest_prefix)
+{
+	int num;
+	int i;
+
+	num = nm_ip4_config_get_num_addresses (config);
+	for (i = 0; i < num; i++) {
+		NMIP4Address *addr = nm_ip4_config_get_address (config, i);
+		guint32 prefix = nm_ip4_address_get_prefix (addr);
+		guint32 address = nm_ip4_address_get_address (addr);
+
+		if (prefix <= dest_prefix) {
+			guint32 masked_addr = ntohl(address) >> (32 - prefix);
+			guint32 masked_dest = ntohl(dest) >> (32 - prefix);
+
+			if (masked_addr == masked_dest)
+				return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static struct rtnl_route *
+create_route (int iface_idx, int mss)
+{
+	struct rtnl_route *route;
+
+	route = rtnl_route_alloc ();
+	if (route) {
+		rtnl_route_set_oif (route, iface_idx);
+
+		if (mss && rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0) {
+			nm_log_warn (LOGD_DEVICE, "could not set mss");
+		}
+	} else
+		nm_log_err (LOGD_DEVICE, "could not allocate route");
+
+	return route;
+}
+
+static struct rtnl_route *
+nm_system_device_set_ip4_route (const char *iface, 
+                                guint32 ip4_dest,
+                                guint32 ip4_prefix,
+                                guint32 ip4_gateway,
+                                guint32 metric,
+                                int mss)
+{
+	struct nl_handle *nlh;
+	struct rtnl_route *route;
+	struct nl_addr *dest_addr;
+	struct nl_addr *gw_addr = NULL;
+	int err, iface_idx;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, NULL);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	g_return_val_if_fail (iface_idx >= 0, NULL);
+
+	route = create_route (iface_idx, mss);
+	g_return_val_if_fail (route != NULL, NULL);
+
+	/* Destination */
+	dest_addr = nl_addr_build (AF_INET, &ip4_dest, sizeof (ip4_dest));
+	g_return_val_if_fail (dest_addr != NULL, NULL);
+	nl_addr_set_prefixlen (dest_addr, (int) ip4_prefix);
+
+	rtnl_route_set_dst (route, dest_addr);
+	nl_addr_put (dest_addr);
+
+	/* Gateway */
+	if (ip4_gateway) {
+		gw_addr = nl_addr_build (AF_INET, &ip4_gateway, sizeof (ip4_gateway));
+		if (gw_addr) {
+			rtnl_route_set_gateway (route, gw_addr);
+			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
+		} else {
+			nm_log_err (LOGD_DEVICE | LOGD_IP4, "Invalid gateway 0x%X", ip4_gateway);
+			rtnl_route_put (route);
+			return NULL;
+		}
+	}
+
+	/* Metric */
+	if (metric)
+		rtnl_route_set_prio (route, metric);
+
+	/* Add the route */
+	err = rtnl_route_add (nlh, route, 0);
+	if (err == -ESRCH && ip4_gateway) {
+		/* Gateway might be over a bridge; try adding a route to gateway first */
+		struct rtnl_route *route2;
+
+		route2 = create_route (iface_idx, mss);
+		if (route2) {
+			/* Add route to gateway over bridge */
+			rtnl_route_set_dst (route2, gw_addr);
+			err = rtnl_route_add (nlh, route2, 0);
+			if (!err) {
+				/* Try adding the route again */
+				err = rtnl_route_add (nlh, route, 0);
+				if (err)
+					rtnl_route_del (nlh, route2, 0);
+			}
+			rtnl_route_put (route2);
+		}
+	}
+
+	if (gw_addr)
+		nl_addr_put (gw_addr);
+
+	if (err) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 route: %s",
+		            iface, nl_geterror ());
+		rtnl_route_put (route);
+		route = NULL;
+	}
+
+	return route;
+}
+
+static gboolean
+sync_addresses (const char *iface, int ifindex, int family,
+				struct rtnl_addr **addrs, int num_addrs)
+{
+	struct nl_handle *nlh;
+	struct nl_cache *addr_cache;
+	struct rtnl_addr *filter_addr, *match_addr;
+	struct nl_object *match;
+	int i, err;
+	guint32 log_domain = (family == AF_INET) ? LOGD_IP4 : LOGD_IP6;
+
+	log_domain |= LOGD_DEVICE;
+
+	nlh = nm_netlink_get_default_handle ();
+	if (!nlh)
+		return FALSE;
+
+	addr_cache = rtnl_addr_alloc_cache (nlh);
+	if (!addr_cache)
+		return FALSE;
+
+	filter_addr = rtnl_addr_alloc ();
+	if (!filter_addr) {
+		nl_cache_free (addr_cache);
+		return FALSE;
+	}
+	rtnl_addr_set_ifindex (filter_addr, ifindex);
+	if (family)
+		rtnl_addr_set_family (filter_addr, family);
+
+	/* Walk through the cache, comparing the addresses already on
+	 * the interface to the addresses in addrs.
+	 */
+	for (match = nl_cache_get_first (addr_cache); match; match = nl_cache_get_next (match)) {
+		match_addr = (struct rtnl_addr *)match;
+
+		/* Skip addresses not on our interface */
+		if (!nl_object_match_filter (match, (struct nl_object *)filter_addr))
+			continue;
+
+		if (addrs) {
+			for (i = 0; i < num_addrs; i++) {
+				if (addrs[i] &&
+					nl_object_identical (match, (struct nl_object *)addrs[i]))
+					break;
+			}
+
+			if (addrs[i]) {
+				/* match == addrs[i], so remove it from addrs so we don't
+				 * try to add it to the interface again below.
+				 */
+				rtnl_addr_put (addrs[i]);
+				addrs[i] = NULL;
+				continue;
+			}
+		}
+
+		/* Don't delete IPv6 link-local addresses; they don't belong to NM */
+		if (rtnl_addr_get_family (match_addr) == AF_INET6 &&
+			rtnl_addr_get_scope (match_addr) == RT_SCOPE_LINK) {
+			continue;
+		}
+
+		/* Otherwise, match_addr should be removed from the interface. */
+		err = rtnl_addr_delete (nlh, match_addr, 0);
+		if (err < 0) {
+			nm_log_err (log_domain, "(%s): error %d returned from rtnl_addr_delete(): %s",
+						iface, err, nl_geterror ());
+		}
+	}
+
+	rtnl_addr_put (filter_addr);
+	nl_cache_free (addr_cache);
+
+	/* Now add the remaining new addresses */
+	for (i = 0; i < num_addrs; i++) {
+		if (!addrs[i])
+			continue;
+
+		err = rtnl_addr_add (nlh, addrs[i], 0);
+		if (err < 0) {
+			nm_log_err (log_domain,
+			            "(%s): error %d returned from rtnl_addr_add():\n%s",
+						iface, err, nl_geterror ());
+		}
+
+		rtnl_addr_put (addrs[i]);
+	}
+	g_free (addrs);
+
+	return TRUE;
+}
+
+static gboolean
+add_ip4_addresses (NMIP4Config *config, const char *iface)
+{
+	int num_addrs, i, iface_idx;
+	guint32 flags = 0;
+	gboolean did_gw = FALSE;
+	struct rtnl_addr **addrs;
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+
+	num_addrs = nm_ip4_config_get_num_addresses (config);
+	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
+
+	for (i = 0; i < num_addrs; i++) {
+		NMIP4Address *addr;
+
+		addr = nm_ip4_config_get_address (config, i);
+		g_assert (addr);
+
+		flags = NM_RTNL_ADDR_DEFAULT;
+		if (nm_ip4_address_get_gateway (addr) && !did_gw) {
+			if (nm_ip4_config_get_ptp_address (config))
+				flags |= NM_RTNL_ADDR_PTP_ADDR;
+			did_gw = TRUE;
+		}
+
+		addrs[i] = nm_ip4_config_to_rtnl_addr (config, i, flags);
+		if (!addrs[i]) {
+			nm_log_warn (LOGD_DEVICE | LOGD_IP4,
+			             "(%s): couldn't create rtnl address!",
+			             iface);
+			continue;
+		}
+		rtnl_addr_set_ifindex (addrs[i], iface_idx);
+	}
+
+	return sync_addresses (iface, iface_idx, AF_INET, addrs, num_addrs);
+}
+
+struct rtnl_route *
+nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config)
+{
+	NMIP4Config *parent_config;
+	guint32 parent_gw = 0, parent_prefix = 0, vpn_gw = 0, i;
+	NMIP4Address *tmp;
+	struct rtnl_route *route = NULL;
+
+	g_return_val_if_fail (NM_IS_DEVICE (parent_device), NULL);
+
+	/* Set up a route to the VPN gateway's public IP address through the default
+	 * network device if the VPN gateway is on a different subnet.
+	 */
+
+	parent_config = nm_device_get_ip4_config (parent_device);
+	g_return_val_if_fail (parent_config != NULL, NULL);
+
+	for (i = 0; i < nm_ip4_config_get_num_addresses (parent_config); i++) {
+		tmp = nm_ip4_config_get_address (parent_config, i);
+		if (nm_ip4_address_get_gateway (tmp)) {
+			parent_gw = nm_ip4_address_get_gateway (tmp);
+			parent_prefix = nm_ip4_address_get_prefix (tmp);
+			break;
+		}
+	}
+
+	for (i = 0; i < nm_ip4_config_get_num_addresses (vpn_config); i++) {
+		tmp = nm_ip4_config_get_address (vpn_config, i);
+		if (nm_ip4_address_get_gateway (tmp)) {
+			vpn_gw = nm_ip4_address_get_gateway (tmp);
+			break;
+		}
+	}
+
+	if (!parent_gw || !vpn_gw)
+		return NULL;
+
+	/* If the VPN gateway is in the same subnet as one of the parent device's
+	 * IP addresses, don't add the host route to it, but a route through the
+	 * parent device.
+	 */
+	if (ip4_dest_in_same_subnet (parent_config, vpn_gw, parent_prefix)) {
+		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
+		                                        vpn_gw, 32, 0, 0, nm_ip4_config_get_mss (parent_config));
+	} else {
+		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
+		                                        vpn_gw, 32, parent_gw, 0, nm_ip4_config_get_mss (parent_config));
+	}
+
+	return route;
+}
+
+/*
+ * nm_system_apply_ip4_config
+ *
+ * Set IPv4 configuration of the device from an NMIP4Config object.
+ *
+ */
+gboolean
+nm_system_apply_ip4_config (const char *iface,
+                            NMIP4Config *config,
+                            int priority,
+                            NMIP4ConfigCompareFlags flags)
+{
+	int i;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (config != NULL, FALSE);
+
+	if (flags & NM_IP4_COMPARE_FLAG_ADDRESSES) {
+		if (!add_ip4_addresses (config, iface))
+			return FALSE;
+		sleep (1);
+	}
+
+	if (flags & NM_IP4_COMPARE_FLAG_ROUTES) {
+		for (i = 0; i < nm_ip4_config_get_num_routes (config); i++) {
+			NMIP4Route *route = nm_ip4_config_get_route (config, i);
+			struct rtnl_route *tmp;
+
+			/* Don't add the route if it's more specific than one of the subnets
+			 * the device already has an IP address on.
+			 */
+			if (ip4_dest_in_same_subnet (config,
+			                             nm_ip4_route_get_dest (route),
+			                             nm_ip4_route_get_prefix (route)))
+				continue;
+
+			/* Don't add the route if it doesn't have a gateway and the connection
+			 * is never supposed to be the default connection.
+			 */
+			if (   nm_ip4_config_get_never_default (config)
+			    && nm_ip4_route_get_dest (route) == 0)
+				continue;
+
+			tmp = nm_system_device_set_ip4_route (iface,
+			                                      nm_ip4_route_get_dest (route),
+			                                      nm_ip4_route_get_prefix (route),
+			                                      nm_ip4_route_get_next_hop (route),
+			                                      nm_ip4_route_get_metric (route),
+			                                      nm_ip4_config_get_mss (config));
+			rtnl_route_put (tmp);
+		}
+	}
+
+	if (flags & NM_IP4_COMPARE_FLAG_MTU) {
+		if (nm_ip4_config_get_mtu (config))
+			nm_system_device_set_mtu (iface, nm_ip4_config_get_mtu (config));
+	}
+
+	if (priority > 0)
+		nm_system_device_set_priority (iface, config, priority);
+
+	return TRUE;
+}
+
+static struct rtnl_route *
+nm_system_device_set_ip6_route (const char *iface,
+                                const struct in6_addr *ip6_dest,
+                                guint32 ip6_prefix,
+                                const struct in6_addr *ip6_gateway,
+                                guint32 metric,
+                                int mss)
+{
+	struct nl_handle *nlh;
+	struct rtnl_route *route;
+	struct nl_addr *dest_addr;
+	struct nl_addr *gw_addr = NULL;
+	int err, iface_idx;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, NULL);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	g_return_val_if_fail (iface_idx >= 0, NULL);
+
+	route = create_route (iface_idx, mss);
+	g_return_val_if_fail (route != NULL, NULL);
+
+	/* Destination */
+	dest_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_dest, sizeof (*ip6_dest));
+	g_return_val_if_fail (dest_addr != NULL, NULL);
+	nl_addr_set_prefixlen (dest_addr, (int) ip6_prefix);
+
+	rtnl_route_set_dst (route, dest_addr);
+	nl_addr_put (dest_addr);
+
+	/* Gateway */
+	if (ip6_gateway && !IN6_IS_ADDR_UNSPECIFIED (ip6_gateway)) {
+		gw_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_gateway, sizeof (*ip6_gateway));
+		if (gw_addr) {
+			rtnl_route_set_gateway (route, gw_addr);
+			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
+		} else {
+			nm_log_warn (LOGD_DEVICE | LOGD_IP6, "Invalid gateway");
+			rtnl_route_put (route);
+			return NULL;
+		}
+	}
+
+	/* Metric */
+	if (metric)
+		rtnl_route_set_prio (route, metric);
+
+	/* Add the route */
+	err = rtnl_route_add (nlh, route, 0);
+	if (err == -ESRCH && ip6_gateway) {
+		/* Gateway might be over a bridge; try adding a route to gateway first */
+		struct rtnl_route *route2;
+
+		route2 = create_route (iface_idx, mss);
+		if (route2) {
+			/* Add route to gateway over bridge */
+			rtnl_route_set_dst (route2, gw_addr);
+			err = rtnl_route_add (nlh, route2, 0);
+			if (!err) {
+				/* Try adding the route again */
+				err = rtnl_route_add (nlh, route, 0);
+				if (err)
+					rtnl_route_del (nlh, route2, 0);
+			}
+			rtnl_route_put (route2);
+		}
+	}
+
+	if (gw_addr)
+		nl_addr_put (gw_addr);
+
+	if (err) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP6,
+		            "(%s): failed to set IPv6 route: %s",
+		            iface, nl_geterror ());
+		rtnl_route_put (route);
+		route = NULL;
+	}
+
+	return route;
+}
+
+static gboolean
+add_ip6_addresses (NMIP6Config *config, const char *iface)
+{
+	int num_addrs, i, iface_idx;
+	struct rtnl_addr **addrs;
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+
+	num_addrs = nm_ip6_config_get_num_addresses (config);
+	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
+
+	for (i = 0; i < num_addrs; i++) {
+		NMIP6Address *addr;
+
+		addr = nm_ip6_config_get_address (config, i);
+		g_assert (addr);
+
+		addrs[i] = nm_ip6_config_to_rtnl_addr (config, i, NM_RTNL_ADDR_DEFAULT);
+		if (!addrs[i]) {
+			nm_log_warn (LOGD_DEVICE | LOGD_IP6,
+			             "(%s): couldn't create rtnl address!",
+			             iface);
+			continue;
+		}
+		rtnl_addr_set_ifindex (addrs[i], iface_idx);
+	}
+
+	return sync_addresses (iface, iface_idx, AF_INET6, addrs, num_addrs);
+}
+
+/*
+ * nm_system_apply_ip6_config
+ *
+ * Set IPv6 configuration of the device from an NMIP6Config object.
+ *
+ */
+gboolean
+nm_system_apply_ip6_config (const char *iface,
+                            NMIP6Config *config,
+                            int priority,
+                            NMIP6ConfigCompareFlags flags)
+{
+	int i;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (config != NULL, FALSE);
+
+	if (flags & NM_IP6_COMPARE_FLAG_ADDRESSES) {
+		if (!add_ip6_addresses (config, iface))
+			return FALSE;
+		sleep (1); // FIXME?
+	}
+
+	if (flags & NM_IP6_COMPARE_FLAG_ROUTES) {
+		for (i = 0; i < nm_ip6_config_get_num_routes (config); i++) {
+			NMIP6Route *route = nm_ip6_config_get_route (config, i);
+			struct rtnl_route *tmp;
+
+			/* Don't add the route if it doesn't have a gateway and the connection
+			 * is never supposed to be the default connection.
+			 */
+			if (   nm_ip6_config_get_never_default (config)
+			    && IN6_IS_ADDR_UNSPECIFIED(nm_ip6_route_get_dest (route)))
+				continue;
+
+			tmp = nm_system_device_set_ip6_route (iface,
+			                                      nm_ip6_route_get_dest (route),
+			                                      nm_ip6_route_get_prefix (route),
+			                                      nm_ip6_route_get_next_hop (route),
+			                                      nm_ip6_route_get_metric (route),
+			                                      nm_ip6_config_get_mss (config));
+			rtnl_route_put (tmp);
+		}
+	}
+
+// FIXME
+//	if (priority > 0)
+//		nm_system_device_set_priority (iface, config, priority);
+
+	return TRUE;
+}
+
+/*
+ * nm_system_device_set_up_down
+ *
+ * Mark the device as up or down.
+ *
+ */
+gboolean
+nm_system_device_set_up_down (NMDevice *dev,
+                              gboolean up,
+                              gboolean *no_firmware)
+{
+	g_return_val_if_fail (dev != NULL, FALSE);
+
+	return nm_system_device_set_up_down_with_iface (nm_device_get_ip_iface (dev), up, no_firmware);
+}
+
+gboolean
+nm_system_device_set_up_down_with_iface (const char *iface,
+                                         gboolean up,
+                                         gboolean *no_firmware)
+{
+	struct rtnl_link *request = NULL, *old = NULL;
+	struct nl_handle *nlh;
+	gboolean success = FALSE;
+	guint32 idx;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	if (no_firmware)
+		g_return_val_if_fail (*no_firmware == FALSE, FALSE);
+
+	if (!(request = rtnl_link_alloc ()))
+		goto out;
+
+	if (up)
+		rtnl_link_set_flags (request, IFF_UP);
+	else
+		rtnl_link_unset_flags (request, IFF_UP);
+
+	idx = nm_netlink_iface_to_index (iface);
+	old = nm_netlink_index_to_rtnl_link (idx);
+	if (old) {
+		nlh = nm_netlink_get_default_handle ();
+		if (nlh) {
+			if (rtnl_link_change (nlh, old, request, 0) == 0)
+				success = TRUE;
+			else if ((nl_get_errno () == ENOENT) && no_firmware && up)
+				*no_firmware = TRUE;
+		}
+	}
+
+	rtnl_link_put (old);
+	rtnl_link_put (request);
+
+out:
+	return success;
+}
+
+gboolean
+nm_system_device_is_up (NMDevice *device)
+{
+	g_return_val_if_fail (device != NULL, FALSE);
+
+	return nm_system_device_is_up_with_iface (nm_device_get_ip_iface (device));
+}
+
+gboolean
+nm_system_device_is_up_with_iface (const char *iface)
+{
+	struct ifreq ifr;
+	int fd;
+	gboolean up = FALSE;
+
+	fd = socket (PF_INET, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		nm_log_err (LOGD_HW, "couldn't open control socket.");
+		return FALSE;
+	}
+
+	/* Get device's flags */
+	memset (&ifr, 0, sizeof (ifr));
+	strncpy (ifr.ifr_name, iface, IFNAMSIZ);
+	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0) {
+		if (errno != ENODEV) {
+			nm_log_err (LOGD_HW, "(%s): could not get flags: errno %d",
+			            iface, errno);
+		}
+	} else {
+		up = !!(ifr.ifr_flags & IFF_UP);
+	}
+	close (fd);
+
+	return up;
+}
+
+gboolean
+nm_system_device_set_mtu (const char *iface, guint32 mtu)
+{
+	struct rtnl_link *old;
+	struct rtnl_link *new;
+	gboolean success = FALSE;
+	struct nl_handle *nlh;
+	int iface_idx;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (mtu > 0, FALSE);
+
+	new = rtnl_link_alloc ();
+	if (!new)
+		return FALSE;
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	old = nm_netlink_index_to_rtnl_link (iface_idx);
+	if (old) {
+		rtnl_link_set_mtu (new, mtu);
+		nlh = nm_netlink_get_default_handle ();
+		if (nlh) {
+			rtnl_link_change (nlh, old, new, 0);
+			success = TRUE;
+		}
+		rtnl_link_put (old);
+	}
+
+	rtnl_link_put (new);
+	return success;
+}
+
+static struct rtnl_route *
+add_ip4_route_to_gateway (const char *iface, guint32 gw, guint32 mss)
+{
+	struct nl_handle *nlh;
+	struct rtnl_route *route = NULL;
+	struct nl_addr *gw_addr = NULL;
+	int iface_idx, err;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, NULL);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx < 0)
+		return NULL;
+
+	/* Gateway might be over a bridge; try adding a route to gateway first */
+	route = rtnl_route_alloc ();
+	if (route == NULL)
+		return NULL;
+
+	rtnl_route_set_family (route, AF_INET);
+	rtnl_route_set_table (route, RT_TABLE_MAIN);
+	rtnl_route_set_oif (route, iface_idx);
+	rtnl_route_set_scope (route, RT_SCOPE_LINK);
+
+	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
+	if (!gw_addr)
+		goto error;
+	nl_addr_set_prefixlen (gw_addr, 32);
+	rtnl_route_set_dst (route, gw_addr);
+	nl_addr_put (gw_addr);
+
+	if (mss) {
+		if (rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0)
+			goto error;
+	}
+
+	/* Add direct route to the gateway */
+	err = rtnl_route_add (nlh, route, 0);
+	if (err) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to add IPv4 route to gateway (%d)",
+		            iface, err);
+		goto error;
+	}
+
+	return route;
+
+error:
+	rtnl_route_put (route);
+	return NULL;
+}
+
+static int
+replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
+{
+	struct rtnl_route *route = NULL;
+	struct nl_handle *nlh;
+	struct nl_addr *dst_addr = NULL;
+	guint32 dst = 0;
+	struct nl_addr *gw_addr = NULL;
+	int iface_idx, err = -1;
+
+	g_return_val_if_fail (iface != NULL, -ENODEV);
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, -ENOMEM);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx < 0)
+		return -ENODEV;
+
+	route = rtnl_route_alloc();
+	g_return_val_if_fail (route != NULL, -ENOMEM);
+
+	rtnl_route_set_family (route, AF_INET);
+	rtnl_route_set_table (route, RT_TABLE_MAIN);
+	rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
+	rtnl_route_set_oif (route, iface_idx);
+
+	/* Build up the destination address */
+	dst_addr = nl_addr_build (AF_INET, &dst, sizeof (dst));
+	if (!dst_addr) {
+		err = -ENOMEM;
+		goto out;
+	}
+	nl_addr_set_prefixlen (dst_addr, 0);
+	rtnl_route_set_dst (route, dst_addr);
+
+	/* Build up the gateway address */
+	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
+	if (!gw_addr) {
+		err = -ENOMEM;
+		goto out;
+	}
+	nl_addr_set_prefixlen (gw_addr, 0);
+	rtnl_route_set_gateway (route, gw_addr);
+
+	if (mss > 0) {
+		err = rtnl_route_set_metric (route, RTAX_ADVMSS, mss);
+		if (err < 0)
+			goto out;
+	}
+
+	/* Add the new default route */
+	err = rtnl_route_add (nlh, route, NLM_F_REPLACE);
+
+out:
+	if (dst_addr)
+		nl_addr_put (dst_addr);
+	if (gw_addr)
+		nl_addr_put (gw_addr);
+	rtnl_route_put (route);
+	return err;
+}
+
+/*
+ * nm_system_replace_default_ip4_route_vpn
+ *
+ * Replace default IPv4 route with one via the current device
+ *
+ */
+gboolean
+nm_system_replace_default_ip4_route_vpn (const char *iface,
+                                         guint32 ext_gw,
+                                         guint32 int_gw,
+                                         guint32 mss,
+                                         const char *parent_iface,
+                                         guint32 parent_mss)
+{
+	struct rtnl_route *gw_route = NULL;
+	struct nl_handle *nlh;
+	gboolean success = FALSE;
+	int err;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, FALSE);
+
+	err = replace_default_ip4_route (iface, int_gw, mss);
+	if (err == 0) {
+		return TRUE;
+	} else if (err != -ESRCH) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route: %d",
+		            iface, err);
+		return FALSE;
+	}
+
+	/* Try adding a direct route to the gateway first */
+	gw_route = add_ip4_route_to_gateway (parent_iface, ext_gw, parent_mss);
+	if (!gw_route)
+		return FALSE;
+
+	/* Try adding the original route again */
+	err = replace_default_ip4_route (iface, int_gw, mss);
+	if (err != 0) {
+		rtnl_route_del (nlh, gw_route, 0);
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route (pass #2): %d",
+		            iface, err);
+	} else
+		success = TRUE;
+
+	rtnl_route_put (gw_route);
+	return success;
+}
+
+/*
+ * nm_system_replace_default_ip4_route
+ *
+ * Replace default IPv4 route with one via the current device
+ *
+ */
+gboolean
+nm_system_replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
+{
+	struct rtnl_route *gw_route = NULL;
+	struct nl_handle *nlh;
+	gboolean success = FALSE;
+	int err;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, FALSE);
+
+	err = replace_default_ip4_route (iface, gw, mss);
+	if (err == 0) {
+		return TRUE;
+	} else if (err != -ESRCH) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route: %d",
+		            iface, err);
+		return FALSE;
+	}
+
+	/* Try adding a direct route to the gateway first */
+	gw_route = add_ip4_route_to_gateway (iface, gw, mss);
+	if (!gw_route)
+		return FALSE;
+
+	/* Try adding the original route again */
+	err = replace_default_ip4_route (iface, gw, mss);
+	if (err != 0) {
+		rtnl_route_del (nlh, gw_route, 0);
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route (pass #2): %d",
+		            iface, err);
+	} else
+		success = TRUE;
+
+	rtnl_route_put (gw_route);
+	return success;
+}
+
+static void flush_addresses (const char *iface, gboolean ipv4_only)
+{
+	int iface_idx;
+
+	g_return_if_fail (iface != NULL);
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx >= 0)
+		sync_addresses (iface, iface_idx, ipv4_only ? AF_INET : 0, NULL, 0);
+}
+
+/*
+ * nm_system_device_flush_addresses
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_addresses (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	flush_addresses (nm_device_get_ip_iface (dev),
+					 nm_device_get_ip6_config (dev) == NULL);
+}
+
+
+/*
+ * nm_system_device_flush_addresses_with_iface
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_addresses_with_iface (const char *iface)
+{
+	flush_addresses (iface, FALSE);
+}
+
+
+static void
+foreach_route (void (*callback)(struct nl_object *, gpointer),
+			gpointer user_data)
+{
+	struct nl_handle *nlh;
+	struct nl_cache *route_cache;
+
+	nlh = nm_netlink_get_default_handle ();
+	route_cache = rtnl_route_alloc_cache (nlh);
+	nl_cache_mngt_provide (route_cache);
+	nl_cache_foreach (route_cache, callback, user_data);
+	nl_cache_free (route_cache);
+}
+
+
+typedef struct {
+	const char *iface;
+	int iface_idx;
+	int family;
+} RouteCheckData;
+
+static void
+check_one_route (struct nl_object *object, void *user_data)
+{
+	RouteCheckData *data = (RouteCheckData *) user_data;
+	struct rtnl_route *route = (struct rtnl_route *) object;
+	int err;
+
+	/* Delete all routes from this interface */
+	if (rtnl_route_get_oif (route) != data->iface_idx)
+		return;
+	if (data->family && rtnl_route_get_family (route) != data->family)
+		return;
+
+	err = rtnl_route_del (nm_netlink_get_default_handle (), route, 0);
+	if (err < 0) {
+		nm_log_err (LOGD_DEVICE,
+		            "(%s): error %d returned from rtnl_route_del(): %s",
+		            data->iface, err, nl_geterror());
+	}
+}
+
+static void flush_routes (const char *iface, gboolean ipv4_only)
+{
+	int iface_idx;
+	RouteCheckData check_data;
+
+	g_return_if_fail (iface != NULL);
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx >= 0) {
+		memset (&check_data, 0, sizeof (check_data));
+		check_data.iface = iface;
+		check_data.iface_idx = iface_idx;
+		check_data.family = ipv4_only ? AF_INET : 0;
+
+		foreach_route (check_one_route, &check_data);
+	}
+}
+
+/*
+ * nm_system_device_flush_routes
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_routes (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	flush_routes (nm_device_get_ip_iface (dev),
+				  nm_device_get_ip6_config (dev) == NULL);
+}
+
+/*
+ * nm_system_device_flush_routes_with_iface
+ *
+ * Flush all routes associated with a network device
+ *
+ */
+void nm_system_device_flush_routes_with_iface (const char *iface)
+{
+	flush_routes (iface, FALSE);
+}
+
+typedef struct {
+	struct rtnl_route *route;
+	NMIP4Config *config;
+	int iface;
+} SetPriorityInfo;
+
+static void
+find_route (struct nl_object *object, gpointer user_data)
+{
+	struct rtnl_route *route = (struct rtnl_route *) object;
+	SetPriorityInfo *info = (SetPriorityInfo *) user_data;
+	struct nl_addr *dst;
+	struct in_addr *dst_addr;
+	int num;
+	int i;
+
+	if (info->route ||
+	    rtnl_route_get_oif (route) != info->iface ||
+	    rtnl_route_get_scope (route) != RT_SCOPE_LINK)
+		return;
+
+	dst = rtnl_route_get_dst (route);
+	if (nl_addr_get_family (dst) != AF_INET)
+		return;
+
+	dst_addr = nl_addr_get_binary_addr (dst);
+	num = nm_ip4_config_get_num_addresses (info->config);
+	for (i = 0; i < num; i++) {
+		NMIP4Address *addr = nm_ip4_config_get_address (info->config, i);
+		guint32 prefix = nm_ip4_address_get_prefix (addr);
+		guint32 address = nm_ip4_address_get_address (addr);
+
+		if (prefix == nl_addr_get_prefixlen (dst) &&
+		    (address & nm_utils_ip4_prefix_to_netmask (prefix)) == dst_addr->s_addr) {
+
+			/* Ref the route so it sticks around after the cache is cleared */
+			rtnl_route_get (route);
+			info->route = route;
+			break;
+		}
+	}
+}
+
+static void
+nm_system_device_set_priority (const char *iface,
+						 NMIP4Config *config,
+						 int priority)
+{
+	SetPriorityInfo info;
+
+	info.route = NULL;
+	info.config = config;
+	info.iface = nm_netlink_iface_to_index (iface);
+	g_return_if_fail (info.iface >= 0);
+
+	foreach_route (find_route, &info);
+	if (info.route) {
+		struct nl_handle *nlh;
+
+		nlh = nm_netlink_get_default_handle ();
+		rtnl_route_del (nlh, info.route, 0);
+
+		rtnl_route_set_prio (info.route, priority);
+		rtnl_route_add (nlh, info.route, 0);
+		rtnl_route_put (info.route);
+	}
+}
diff --git a/src/nm-system.h b/src/nm-system.h
new file mode 100644
index 0000000..f2c2693
--- /dev/null
+++ b/src/nm-system.h
@@ -0,0 +1,81 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2008 Novell, Inc.
+ */
+
+#ifndef NETWORK_MANAGER_SYSTEM_H
+#define NETWORK_MANAGER_SYSTEM_H
+
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+
+#include <glib.h>
+#include "nm-device.h"
+#include "nm-ip4-config.h"
+
+/* Prototypes for system/distribution dependent functions,
+ * implemented in the backend files in backends/ directory
+ */
+
+void			nm_system_device_flush_routes				(NMDevice *dev);
+void			nm_system_device_flush_routes_with_iface	(const char *iface);
+
+gboolean		nm_system_replace_default_ip4_route   (const char *iface,
+                                                       guint32 gw,
+                                                       guint32 mss);
+
+gboolean		nm_system_replace_default_ip4_route_vpn (const char *iface,
+                                                         guint32 ext_gw,
+                                                         guint32 int_gw,
+                                                         guint32 mss,
+                                                         const char *parent_iface,
+                                                         guint32 parent_mss);
+
+struct rtnl_route *nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config);
+
+
+void			nm_system_device_flush_addresses			(NMDevice *dev);
+void			nm_system_device_flush_addresses_with_iface	(const char *iface);
+
+void			nm_system_enable_loopback				(void);
+void			nm_system_update_dns					(void);
+
+gboolean		nm_system_apply_ip4_config              (const char *iface,
+                                                         NMIP4Config *config,
+                                                         int priority,
+                                                         NMIP4ConfigCompareFlags flags);
+
+gboolean		nm_system_apply_ip6_config              (const char *iface,
+                                                         NMIP6Config *config,
+                                                         int priority,
+                                                         NMIP6ConfigCompareFlags flags);
+
+gboolean		nm_system_device_set_up_down				(NMDevice *dev,
+                                                             gboolean up,
+                                                             gboolean *no_firmware);
+gboolean		nm_system_device_set_up_down_with_iface		(const char *iface,
+                                                             gboolean up,
+                                                             gboolean *no_firmware);
+
+gboolean        nm_system_device_is_up (NMDevice *device);
+gboolean        nm_system_device_is_up_with_iface (const char *iface);
+
+gboolean		nm_system_device_set_mtu (const char *iface, guint32 mtu);
+
+#endif
diff --git a/src/nm-udev-manager.c b/src/nm-udev-manager.c
index 956068d..1e84c04 100644
--- a/src/nm-udev-manager.c
+++ b/src/nm-udev-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <signal.h>
@@ -33,7 +33,7 @@
 
 #include "nm-udev-manager.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
 #include "nm-device-wifi.h"
 #include "nm-device-olpc-mesh.h"
@@ -82,6 +82,30 @@ nm_udev_manager_get_rfkill_state (NMUdevManager *self, RfKillType rtype)
 	return NM_UDEV_MANAGER_GET_PRIVATE (self)->rfkill_states[rtype];
 }
 
+static const char *
+rfkill_type_to_desc (RfKillType rtype)
+{
+	if (rtype == 0)
+		return "WiFi";
+	else if (rtype == 1)
+		return "WWan";
+	else if (rtype == 2)
+		return "WiMAX";
+	return "unknown";
+}
+
+static const char *
+rfkill_state_to_desc (RfKillState rstate)
+{
+	if (rstate == 0)
+		return "unblocked";
+	else if (rstate == 1)
+		return "soft-blocked";
+	else if (rstate == 2)
+		return "hard-blocked";
+	return "unknown";
+}
+
 static Killswitch *
 killswitch_new (GUdevDevice *device, RfKillType rtype)
 {
@@ -139,7 +163,7 @@ sysfs_state_to_nm_state (gint sysfs_state)
 	case 2:
 		return RFKILL_HARD_BLOCKED;
 	default:
-		g_warning ("%s: Unhandled rfkill state %d", __func__, sysfs_state);
+		nm_log_warn (LOGD_RFKILL, "unhandled rfkill state %d", sysfs_state);
 		break;
 	}
 	return RFKILL_UNBLOCKED;
@@ -175,6 +199,10 @@ recheck_killswitches (NMUdevManager *self)
 
 	for (i = 0; i < RFKILL_TYPE_MAX; i++) {
 		if (poll_states[i] != priv->rfkill_states[i]) {
+			nm_log_dbg (LOGD_RFKILL, "%s rfkill state now '%s'",
+			            rfkill_type_to_desc (i),
+			            rfkill_state_to_desc (poll_states[i]));
+
 			priv->rfkill_states[i] = poll_states[i];
 			g_signal_emit (self, signals[RFKILL_CHANGED], 0, i, priv->rfkill_states[i]);
 		}
@@ -229,11 +257,11 @@ add_one_killswitch (NMUdevManager *self, GUdevDevice *device)
 	ks = killswitch_new (device, rtype);
 	priv->killswitches = g_slist_prepend (priv->killswitches, ks);
 
-	nm_info ("Found %s radio killswitch %s (at %s) (driver %s)",
-	         str_type,
-	         ks->name,
-	         ks->path,
-	         ks->driver ? ks->driver : "<unknown>");
+	nm_log_info (LOGD_RFKILL, "found %s radio killswitch %s (at %s) (driver %s)",
+	             rfkill_type_to_desc (rtype),
+	             ks->name,
+	             ks->path,
+	             ks->driver ? ks->driver : "<unknown>");
 }
 
 static void
@@ -265,7 +293,7 @@ rfkill_remove (NMUdevManager *self,
 		Killswitch *ks = iter->data;
 
 		if (!strcmp (ks->name, name)) {
-			nm_info ("Radio killswitch %s disappeared", ks->path);
+			nm_log_info (LOGD_RFKILL, "radio killswitch %s disappeared", ks->path);
 			priv->killswitches = g_slist_remove (priv->killswitches, ks);
 			killswitch_destroy (ks);
 			break;
@@ -322,7 +350,7 @@ device_creator (NMUdevManager *manager,
 
 	path = g_udev_device_get_sysfs_path (udev_device);
 	if (!path) {
-		nm_warning ("couldn't determine device path; ignoring...");
+		nm_log_warn (LOGD_HW, "couldn't determine device path; ignoring...");
 		return NULL;
 	}
 
@@ -345,13 +373,13 @@ device_creator (NMUdevManager *manager,
 	}
 
 	if (!driver) {
-		nm_warning ("%s: couldn't determine device driver; ignoring...", path);
+		nm_log_warn (LOGD_HW, "%s: couldn't determine device driver; ignoring...", path);
 		goto out;
 	}
 
 	ifindex = g_udev_device_get_sysfs_attr_as_int (udev_device, "ifindex");
 	if (ifindex <= 0) {
-		nm_warning ("%s: device had invalid ifindex %d; ignoring...", path, (guint32) ifindex);
+		nm_log_warn (LOGD_HW, "%s: device had invalid ifindex %d; ignoring...", path, (guint32) ifindex);
 		goto out;
 	}
 
@@ -373,18 +401,36 @@ out:
 static void
 net_add (NMUdevManager *self, GUdevDevice *device)
 {
-	gint devtype;
+	gint etype;
 	const char *iface;
+	const char *devtype;
 
 	g_return_if_fail (device != NULL);
 
-	devtype = g_udev_device_get_sysfs_attr_as_int (device, "type");
-	if (devtype != 1)
+	etype = g_udev_device_get_sysfs_attr_as_int (device, "type");
+	if (etype != 1) {
+		nm_log_dbg (LOGD_HW, "ignoring interface with type %d", etype);
 		return; /* Not using ethernet encapsulation, don't care */
+	}
+
+	/* Not all ethernet devices are immediately usable; newer mobile broadband
+	 * devices (Ericsson, Option, Sierra) require setup on the tty before the
+	 * ethernet device is usable.  2.6.33 and later kernels set the 'DEVTYPE'
+	 * uevent variable which we can use to ignore the interface as a NMDevice
+	 * subclass.  ModemManager will pick it up though and so we'll handle it
+	 * through the mobile broadband stuff.
+	 */
+	devtype = g_udev_device_get_property (device, "DEVTYPE");
+	if (devtype && !strcmp (devtype, "wwan")) {
+		nm_log_dbg (LOGD_HW, "ignoring interface with devtype '%s'", devtype);
+		return;
+	}
 
 	iface = g_udev_device_get_name (device);
-	if (!iface)
+	if (!iface) {
+		nm_log_dbg (LOGD_HW, "failed to get device's interface");
 		return;
+	}
 
 	g_signal_emit (self, signals[DEVICE_ADDED], 0, device, device_creator);
 }
@@ -427,6 +473,9 @@ handle_uevent (GUdevClient *client,
 	subsys = g_udev_device_get_subsystem (device);
 	g_return_if_fail (subsys != NULL);
 
+	nm_log_dbg (LOGD_HW, "UDEV event: action '%s' subsys '%s' device '%s'",
+	            action, subsys, g_udev_device_get_name (device));
+
 	g_return_if_fail (!strcmp (subsys, "rfkill") || !strcmp (subsys, "net"));
 
 	if (!strcmp (action, "add")) {
diff --git a/src/nm-wifi-ap.c b/src/nm-wifi-ap.c
new file mode 100644
index 0000000..c7b5d8a
--- /dev/null
+++ b/src/nm-wifi-ap.c
@@ -0,0 +1,1477 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#include "wireless-helper.h"
+
+#include <string.h>
+
+#include "nm-wifi-ap.h"
+#include "NetworkManagerUtils.h"
+#include "nm-utils.h"
+#include "nm-logging.h"
+#include "nm-dbus-manager.h"
+#include "wpa.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-setting-wireless.h"
+
+#include "nm-access-point-glue.h"
+
+/*
+ * Encapsulates Access Point information
+ */
+typedef struct
+{
+	char *dbus_path;
+
+	/* Scanned or cached values */
+	GByteArray *	ssid;
+	struct ether_addr	address;
+	NM80211Mode		mode;
+	gint8			strength;
+	guint32			freq;		/* Frequency in MHz; ie 2412 (== 2.412 GHz) */
+	guint32			max_bitrate;/* Maximum bitrate of the AP in Kbit/s (ie 54000 Kb/s == 54Mbit/s) */
+
+	guint32			flags;		/* General flags */
+	guint32			wpa_flags;	/* WPA-related flags */
+	guint32			rsn_flags;	/* RSN (WPA2) -related flags */
+
+	/* Non-scanned attributes */
+	gboolean			fake;	/* Whether or not the AP is from a scan */
+	gboolean			broadcast;	/* Whether or not the AP is broadcasting (hidden) */
+	gboolean			user_created;	/* Whether or not the AP was created
+										 * by the user with "Create network..."
+										 * A subset of Ad-Hoc mode.  user_created
+										 * implies Ad-Hoc, but not necessarily
+										 * the other way around.
+										 */
+	glong				last_seen;	/* Last time the AP was seen in a scan in seconds */
+
+	/* Things from user prefs/NetworkManagerInfo */
+	GTimeVal			timestamp;
+	GSList *			user_addresses;
+} NMAccessPointPrivate;
+
+#define NM_AP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_AP, NMAccessPointPrivate))
+
+G_DEFINE_TYPE (NMAccessPoint, nm_ap, G_TYPE_OBJECT)
+
+enum {
+	PROPERTIES_CHANGED,
+
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum {
+	PROP_0,
+	PROP_FLAGS,
+	PROP_WPA_FLAGS,
+	PROP_RSN_FLAGS,
+	PROP_SSID,
+	PROP_FREQUENCY,
+	PROP_HW_ADDRESS,
+	PROP_MODE,
+	PROP_MAX_BITRATE,
+	PROP_STRENGTH,
+	LAST_PROP
+};
+
+static void
+nm_ap_init (NMAccessPoint *ap)
+{
+	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (ap);
+
+	priv->dbus_path = NULL;
+	priv->mode = NM_802_11_MODE_INFRA;
+	priv->flags = NM_802_11_AP_FLAGS_NONE;
+	priv->wpa_flags = NM_802_11_AP_SEC_NONE;
+	priv->rsn_flags = NM_802_11_AP_SEC_NONE;
+	priv->broadcast = TRUE;
+}
+
+static void
+finalize (GObject *object)
+{
+	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
+
+	g_free (priv->dbus_path);
+	if (priv->ssid)
+		g_byte_array_free (priv->ssid, TRUE);
+	g_slist_foreach (priv->user_addresses, (GFunc)g_free, NULL);
+	g_slist_free (priv->user_addresses);
+
+	G_OBJECT_CLASS (nm_ap_parent_class)->finalize (object);
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+		    const GValue *value, GParamSpec *pspec)
+{
+	NMAccessPoint *ap = NM_AP (object);
+
+	switch (prop_id) {
+	case PROP_FLAGS:
+		nm_ap_set_flags (ap, g_value_get_uint (value));
+		break;
+	case PROP_WPA_FLAGS:
+		nm_ap_set_wpa_flags (ap, g_value_get_uint (value));
+		break;
+	case PROP_RSN_FLAGS:
+		nm_ap_set_rsn_flags (ap, g_value_get_uint (value));
+		break;
+	case PROP_SSID:
+		nm_ap_set_ssid (ap, (GByteArray *) g_value_get_boxed (value));
+		break;
+	case PROP_FREQUENCY:
+		nm_ap_set_freq (ap, g_value_get_uint (value));
+		break;
+	case PROP_MODE:
+		nm_ap_set_mode (ap, g_value_get_uint (value));
+		break;
+	case PROP_MAX_BITRATE:
+		nm_ap_set_max_bitrate (ap, g_value_get_uint (value));
+		break;
+	case PROP_STRENGTH:
+		nm_ap_set_strength (ap, g_value_get_char (value));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
+	GArray * ssid;
+	int len;
+	int i;
+
+	switch (prop_id) {
+	case PROP_FLAGS:
+		g_value_set_uint (value, priv->flags);
+		break;
+	case PROP_WPA_FLAGS:
+		g_value_set_uint (value, priv->wpa_flags);
+		break;
+	case PROP_RSN_FLAGS:
+		g_value_set_uint (value, priv->rsn_flags);
+		break;
+	case PROP_SSID:
+		len = priv->ssid ? priv->ssid->len : 0;
+		ssid = g_array_sized_new (FALSE, TRUE, sizeof (unsigned char), len);
+		for (i = 0; i < len; i++)
+			g_array_append_val (ssid, priv->ssid->data[i]);
+		g_value_set_boxed (value, ssid);
+		g_array_free (ssid, TRUE);
+		break;
+	case PROP_FREQUENCY:
+		g_value_set_uint (value, priv->freq);
+		break;
+	case PROP_HW_ADDRESS:
+		g_value_take_string (value, nm_ether_ntop (&priv->address));
+		break;
+	case PROP_MODE:
+		g_value_set_uint (value, priv->mode);
+		break;
+	case PROP_MAX_BITRATE:
+		g_value_set_uint (value, priv->max_bitrate);
+		break;
+	case PROP_STRENGTH:
+		g_value_set_char (value, priv->strength);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_ap_class_init (NMAccessPointClass *ap_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (ap_class);
+	guint32 all_sec_flags;
+
+	g_type_class_add_private (ap_class, sizeof (NMAccessPointPrivate));
+
+	/* virtual methods */
+	object_class->set_property = set_property;
+	object_class->get_property = get_property;
+	object_class->finalize = finalize;
+
+	/* properties */
+
+	all_sec_flags =   NM_802_11_AP_SEC_NONE
+	                | NM_802_11_AP_SEC_PAIR_WEP40
+	                | NM_802_11_AP_SEC_PAIR_WEP104
+	                | NM_802_11_AP_SEC_PAIR_TKIP
+	                | NM_802_11_AP_SEC_PAIR_CCMP
+	                | NM_802_11_AP_SEC_GROUP_WEP40
+	                | NM_802_11_AP_SEC_GROUP_WEP104
+	                | NM_802_11_AP_SEC_GROUP_TKIP
+	                | NM_802_11_AP_SEC_GROUP_CCMP
+	                | NM_802_11_AP_SEC_KEY_MGMT_PSK
+	                | NM_802_11_AP_SEC_KEY_MGMT_802_1X;
+
+	g_object_class_install_property
+		(object_class, PROP_FLAGS,
+		 g_param_spec_uint (NM_AP_FLAGS,
+							"Flags",
+							"Flags",
+							NM_802_11_AP_FLAGS_NONE,
+							NM_802_11_AP_FLAGS_PRIVACY,
+							NM_802_11_AP_FLAGS_NONE,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_WPA_FLAGS,
+		 g_param_spec_uint (NM_AP_WPA_FLAGS,
+							"WPA Flags",
+							"WPA Flags",
+							NM_802_11_AP_SEC_NONE,
+							all_sec_flags,
+							NM_802_11_AP_SEC_NONE,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_RSN_FLAGS,
+		 g_param_spec_uint (NM_AP_RSN_FLAGS,
+							"RSN Flags",
+							"RSN Flags",
+							NM_802_11_AP_SEC_NONE,
+							all_sec_flags,
+							NM_802_11_AP_SEC_NONE,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_SSID,
+	     g_param_spec_boxed (NM_AP_SSID,
+	                         "SSID",
+	                         "SSID",
+	                         DBUS_TYPE_G_UCHAR_ARRAY,
+	                         G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_FREQUENCY,
+		 g_param_spec_uint (NM_AP_FREQUENCY,
+							"Frequency",
+							"Frequency",
+							0, 10000, 0,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_HW_ADDRESS,
+		 g_param_spec_string (NM_AP_HW_ADDRESS,
+							  "MAC Address",
+							  "Hardware MAC address",
+							  NULL,
+							  G_PARAM_READABLE));
+	
+	g_object_class_install_property
+		(object_class, PROP_MODE,
+		 g_param_spec_uint (NM_AP_MODE,
+						   "Mode",
+						   "Mode",
+						   NM_802_11_MODE_ADHOC, NM_802_11_MODE_INFRA, NM_802_11_MODE_INFRA,
+						   G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_MAX_BITRATE,
+		 g_param_spec_uint (NM_AP_MAX_BITRATE,
+							"Max Bitrate",
+							"Max Bitrate",
+							0, G_MAXUINT16, 0,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_STRENGTH,
+		 g_param_spec_char (NM_AP_STRENGTH,
+							"Strength",
+							"Strength",
+							G_MININT8, G_MAXINT8, 0,
+							G_PARAM_READWRITE));
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+								    G_STRUCT_OFFSET (NMAccessPointClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (ap_class),
+							   &dbus_glib_nm_access_point_object_info);
+}
+
+void
+nm_ap_export_to_dbus (NMAccessPoint *ap)
+{
+	NMAccessPointPrivate *priv;
+	NMDBusManager *mgr;
+	DBusGConnection *g_connection;
+	static guint32 counter = 0;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->dbus_path) {
+		nm_log_err (LOGD_CORE, "Tried to export AP %s twice.", priv->dbus_path);
+		return;
+	}
+
+	mgr = nm_dbus_manager_get ();
+	g_assert (mgr);
+
+	g_connection = nm_dbus_manager_get_connection (mgr);
+	g_assert (g_connection);
+
+	priv->dbus_path = g_strdup_printf (NM_DBUS_PATH_ACCESS_POINT "/%d", counter++);
+	dbus_g_connection_register_g_object (g_connection, priv->dbus_path, G_OBJECT (ap));
+
+	g_object_unref (mgr);
+}
+
+/*
+ * nm_ap_new
+ *
+ * Create a new, blank user access point info structure
+ *
+ */
+NMAccessPoint *nm_ap_new (void)
+{
+	GObject *object;
+
+	object = g_object_new (NM_TYPE_AP, NULL);
+	if (!object)
+		return NULL;
+
+	return (NMAccessPoint *) object;
+}
+
+
+#define IEEE80211_CAP_ESS       0x0001
+#define IEEE80211_CAP_IBSS      0x0002
+#define IEEE80211_CAP_PRIVACY   0x0010
+
+static void
+foreach_property_cb (gpointer key, gpointer value, gpointer user_data)
+{
+	GValue *variant = (GValue *) value;
+	NMAccessPoint *ap = (NMAccessPoint *) user_data;
+
+	if (G_VALUE_HOLDS_BOXED (variant)) {
+		GArray *array = g_value_get_boxed (variant);
+
+		if (!strcmp (key, "ssid")) {
+			guint32 len = MIN (IW_ESSID_MAX_SIZE, array->len);
+			GByteArray * ssid;
+
+			/* Stupid ieee80211 layer uses <hidden> */
+			if (((len == 8) || (len == 9))
+				&& (memcmp (array->data, "<hidden>", 8) == 0))
+				return;
+
+			if (nm_utils_is_empty_ssid ((const guint8 *) array->data, len))
+				return;
+
+			ssid = g_byte_array_sized_new (len);
+			g_byte_array_append (ssid, (const guint8 *) array->data, len);
+			nm_ap_set_ssid (ap, ssid);
+			g_byte_array_free (ssid, TRUE);
+		} else if (!strcmp (key, "bssid")) {
+			struct ether_addr addr;
+
+			if (array->len != ETH_ALEN)
+				return;
+			memset (&addr, 0, sizeof (struct ether_addr));
+			memcpy (&addr, array->data, ETH_ALEN);
+			nm_ap_set_address (ap, &addr);
+		} else if (!strcmp (key, "wpaie")) {
+			guint8 * ie = (guint8 *) array->data;
+			guint32 flags = nm_ap_get_wpa_flags (ap);
+
+			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
+				return;
+			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
+			nm_ap_set_wpa_flags (ap, flags);
+		} else if (!strcmp (key, "rsnie")) {
+			guint8 * ie = (guint8 *) array->data;
+			guint32 flags = nm_ap_get_rsn_flags (ap);
+
+			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
+				return;
+			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
+			nm_ap_set_rsn_flags (ap, flags);
+		}
+	} else if (G_VALUE_HOLDS_INT (variant)) {
+		gint32 int_val = g_value_get_int (variant);
+
+		if (!strcmp (key, "frequency")) {
+			nm_ap_set_freq (ap, (guint32) int_val);
+		} else if (!strcmp (key, "maxrate")) {
+			/* Supplicant reports as b/s, we use Kb/s internally */
+			nm_ap_set_max_bitrate (ap, int_val / 1000);
+		}
+	} else if (G_VALUE_HOLDS_UINT (variant)) {
+		guint32 val = g_value_get_uint (variant);
+
+		if (!strcmp (key, "capabilities")) {
+			if (val & IEEE80211_CAP_ESS) {
+				nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
+			} else if (val & IEEE80211_CAP_IBSS) {
+				nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
+			}
+
+			if (val & IEEE80211_CAP_PRIVACY) {
+				guint32 flags = nm_ap_get_flags (ap);
+				nm_ap_set_flags (ap, flags | NM_802_11_AP_FLAGS_PRIVACY);
+			}
+		}
+	}
+}
+
+
+NMAccessPoint *
+nm_ap_new_from_properties (GHashTable *properties)
+{
+	NMAccessPoint *ap;
+	GTimeVal cur_time;
+	const struct ether_addr * addr;
+	const char bad_bssid1[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	const char bad_bssid2[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+	g_return_val_if_fail (properties != NULL, NULL);
+
+	ap = nm_ap_new ();
+
+	g_object_freeze_notify (G_OBJECT (ap));
+	g_hash_table_foreach (properties, foreach_property_cb, ap);
+
+	/* ignore APs with invalid BSSIDs */
+	addr = nm_ap_get_address (ap);
+	if (   !(memcmp (addr->ether_addr_octet, bad_bssid1, ETH_ALEN))
+	    || !(memcmp (addr->ether_addr_octet, bad_bssid2, ETH_ALEN))) {
+		g_object_unref (ap);
+		return NULL;
+	}
+
+	g_get_current_time (&cur_time);
+	nm_ap_set_last_seen (ap, cur_time.tv_sec);
+
+	if (!nm_ap_get_ssid (ap))
+		nm_ap_set_broadcast (ap, FALSE);
+
+	g_object_thaw_notify (G_OBJECT (ap));
+
+	return ap;
+}
+
+#define PROTO_WPA "wpa"
+#define PROTO_RSN "rsn"
+
+static gboolean
+has_proto (NMSettingWirelessSecurity *sec, const char *proto)
+{
+	guint32 num_protos = nm_setting_wireless_security_get_num_protos (sec);
+	guint32 i;
+
+	if (num_protos == 0)
+		return TRUE; /* interpret no protos as "all" */
+
+	for (i = 0; i < num_protos; i++) {
+		if (!strcmp (nm_setting_wireless_security_get_proto (sec, i), proto))
+			return TRUE;
+	}
+	return FALSE;
+}
+
+static void
+add_pair_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
+{
+	guint32 num = nm_setting_wireless_security_get_num_pairwise (sec);
+	guint32 flags = NM_802_11_AP_SEC_NONE;
+	guint32 i;
+
+	/* If no ciphers are specified, that means "all" WPA ciphers */
+	if (num == 0) {
+		flags |= NM_802_11_AP_SEC_PAIR_TKIP | NM_802_11_AP_SEC_PAIR_CCMP;
+	} else {
+		for (i = 0; i < num; i++) {
+			const char *cipher = nm_setting_wireless_security_get_pairwise (sec, i);
+
+			if (!strcmp (cipher, "tkip"))
+				flags |= NM_802_11_AP_SEC_PAIR_TKIP;
+			else if (!strcmp (cipher, "ccmp"))
+				flags |= NM_802_11_AP_SEC_PAIR_CCMP;
+		}
+	}
+
+	if (has_proto (sec, PROTO_WPA))
+		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
+	if (has_proto (sec, PROTO_RSN))
+		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
+}
+
+static void
+add_group_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
+{
+	guint32 num = nm_setting_wireless_security_get_num_groups (sec);
+	guint32 flags = NM_802_11_AP_SEC_NONE;
+	guint32 i;
+
+	/* If no ciphers are specified, that means "all" WPA ciphers */
+	if (num == 0) {
+		flags |= NM_802_11_AP_SEC_GROUP_TKIP | NM_802_11_AP_SEC_GROUP_CCMP;
+	} else {
+		for (i = 0; i < num; i++) {
+			const char *cipher = nm_setting_wireless_security_get_group (sec, i);
+
+			if (!strcmp (cipher, "wep40"))
+				flags |= NM_802_11_AP_SEC_GROUP_WEP40;
+			else if (!strcmp (cipher, "wep104"))
+				flags |= NM_802_11_AP_SEC_GROUP_WEP104;
+			else if (!strcmp (cipher, "tkip"))
+				flags |= NM_802_11_AP_SEC_GROUP_TKIP;
+			else if (!strcmp (cipher, "ccmp"))
+				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
+		}
+	}
+
+	if (has_proto (sec, PROTO_WPA))
+		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
+	if (has_proto (sec, PROTO_RSN))
+		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
+}
+
+NMAccessPoint *
+nm_ap_new_fake_from_connection (NMConnection *connection)
+{
+	NMAccessPoint *ap;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wireless_sec;
+	const GByteArray *ssid;
+	const char *mode, *band, *key_mgmt;
+	guint32 channel, flags;
+	gboolean psk = FALSE, eap = FALSE;
+
+	g_return_val_if_fail (connection != NULL, NULL);
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	g_return_val_if_fail (s_wireless != NULL, NULL);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_return_val_if_fail (ssid != NULL, NULL);
+	g_return_val_if_fail (ssid->len > 0, NULL);
+
+	ap = nm_ap_new ();
+	nm_ap_set_fake (ap, TRUE);
+	nm_ap_set_ssid (ap, ssid);
+
+	// FIXME: bssid too?
+
+	mode = nm_setting_wireless_get_mode (s_wireless);
+	if (mode) {
+		if (!strcmp (mode, "infrastructure"))
+			nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
+		else if (!strcmp (mode, "adhoc"))
+			nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
+		else
+			goto error;
+	} else {
+		nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
+	}
+
+	band = nm_setting_wireless_get_band (s_wireless);
+	channel = nm_setting_wireless_get_channel (s_wireless);
+
+	if (band && channel) {
+		guint32 freq = channel_to_freq (channel, band);
+
+		if (freq == 0)
+			goto error;
+
+		nm_ap_set_freq (ap, freq);
+	}
+
+	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY);
+	/* Assume presence of a security setting means the AP is encrypted */
+	if (!s_wireless_sec)
+		goto done;
+
+	key_mgmt = nm_setting_wireless_security_get_key_mgmt (s_wireless_sec);
+
+	/* Everything below here uses encryption */
+	nm_ap_set_flags (ap, nm_ap_get_flags (ap) | NM_802_11_AP_FLAGS_PRIVACY);
+
+	/* Static & Dynamic WEP */
+	if (!strcmp (key_mgmt, "none") || !strcmp (key_mgmt, "ieee8021x"))
+		goto done;
+
+	psk = !strcmp (key_mgmt, "wpa-psk");
+	eap = !strcmp (key_mgmt, "wpa-eap");
+	if (psk || eap) {
+		if (has_proto (s_wireless_sec, PROTO_WPA)) {
+			flags = nm_ap_get_wpa_flags (ap);
+			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
+			nm_ap_set_wpa_flags (ap, flags);
+		}
+		if (has_proto (s_wireless_sec, PROTO_RSN)) {
+			flags = nm_ap_get_rsn_flags (ap);
+			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
+			nm_ap_set_rsn_flags (ap, flags);
+		}
+
+		add_pair_ciphers (ap, s_wireless_sec);
+		add_group_ciphers (ap, s_wireless_sec);
+	} else if (!strcmp (key_mgmt, "wpa-none")) {
+		guint32 i;
+
+		/* Ad-Hoc has special requirements: proto=WPA, pairwise=(none), and
+		 * group=TKIP/CCMP (but not both).
+		 */
+
+		flags = nm_ap_get_wpa_flags (ap);
+		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
+
+		/* Clear ciphers; pairwise must be unset anyway, and group gets set below */
+		flags &= ~(  NM_802_11_AP_SEC_PAIR_WEP40
+		           | NM_802_11_AP_SEC_PAIR_WEP104
+		           | NM_802_11_AP_SEC_PAIR_TKIP
+		           | NM_802_11_AP_SEC_PAIR_CCMP
+		           | NM_802_11_AP_SEC_GROUP_WEP40
+		           | NM_802_11_AP_SEC_GROUP_WEP104
+		           | NM_802_11_AP_SEC_GROUP_TKIP
+		           | NM_802_11_AP_SEC_GROUP_CCMP);
+
+		for (i = 0; i < nm_setting_wireless_security_get_num_groups (s_wireless_sec); i++) {
+			if (!strcmp (nm_setting_wireless_security_get_group (s_wireless_sec, i), "ccmp")) {
+				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
+				break;
+			}
+		}
+
+		/* Default to TKIP since not all WPA-capable cards can do CCMP */
+		if (!(flags & NM_802_11_AP_SEC_GROUP_CCMP))
+			flags |= NM_802_11_AP_SEC_GROUP_TKIP;
+
+		nm_ap_set_wpa_flags (ap, flags);
+
+		/* Don't use Ad-Hoc RSN yet */
+		nm_ap_set_rsn_flags (ap, NM_802_11_AP_SEC_NONE);
+	}
+
+done:
+	return ap;
+
+error:
+	g_object_unref (ap);
+	return NULL;
+}
+
+
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((guint8*)(x))[0],((guint8*)(x))[1],((guint8*)(x))[2],((guint8*)(x))[3],((guint8*)(x))[4],((guint8*)(x))[5]
+
+void
+nm_ap_print_self (NMAccessPoint *ap,
+                  const char * prefix)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (ap != NULL);
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	nm_log_dbg (LOGD_WIFI_SCAN, "%s'%s' (%p)",
+	            prefix,
+	            priv->ssid ? nm_utils_escape_ssid (priv->ssid->data, priv->ssid->len) : "(none)",
+	            ap);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    BSSID     " MAC_FMT, MAC_ARG (priv->address.ether_addr_octet));
+	nm_log_dbg (LOGD_WIFI_SCAN, "    mode      %d", priv->mode);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    timestamp %ld", priv->timestamp.tv_sec);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    flags     0x%X", priv->flags);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    wpa flags 0x%X", priv->wpa_flags);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    rsn flags 0x%X", priv->rsn_flags);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    quality   %d", priv->strength);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    frequency %d", priv->freq);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    max rate  %d", priv->max_bitrate);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    last-seen %ld", priv->last_seen);
+}
+
+const char *
+nm_ap_get_dbus_path (NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	return NM_AP_GET_PRIVATE (ap)->dbus_path;
+}
+
+
+/*
+ * Get/set functions for timestamp
+ *
+ */
+const GTimeVal *nm_ap_get_timestamp (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	return (&NM_AP_GET_PRIVATE (ap)->timestamp);
+}
+
+void nm_ap_set_timestamp (NMAccessPoint *ap, glong sec, glong usec)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	priv->timestamp.tv_sec = sec;
+	priv->timestamp.tv_usec = usec;
+}
+
+void nm_ap_set_timestamp_via_timestamp (NMAccessPoint *ap, const GTimeVal *timestamp)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->timestamp = *timestamp;
+}
+
+/*
+ * Get/set functions for ssid
+ *
+ */
+const GByteArray * nm_ap_get_ssid (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	return NM_AP_GET_PRIVATE (ap)->ssid;
+}
+
+void
+nm_ap_set_ssid (NMAccessPoint *ap, const GByteArray * ssid)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if ((ssid == priv->ssid) && ssid == NULL)
+		return;
+
+	/* same SSID */
+	if ((ssid && priv->ssid) && (ssid->len == priv->ssid->len)) {
+		if (!memcmp (ssid->data, priv->ssid->data, ssid->len))
+			return;
+	}
+
+	if (priv->ssid) {
+		g_byte_array_free (priv->ssid, TRUE);
+		priv->ssid = NULL;
+	}
+
+	if (ssid) {
+		priv->ssid = g_byte_array_sized_new (ssid->len);
+		priv->ssid->len = ssid->len;
+		memcpy (priv->ssid->data, ssid->data, ssid->len);
+	}
+
+	g_object_notify (G_OBJECT (ap), NM_AP_SSID);
+}
+
+
+guint32
+nm_ap_get_flags (NMAccessPoint *ap)
+{
+	guint32 flags;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_FLAGS_NONE);
+
+	g_object_get (ap, NM_AP_FLAGS, &flags, NULL);
+
+	return flags;
+}
+
+
+void
+nm_ap_set_flags (NMAccessPoint *ap, guint32 flags)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->flags != flags) {
+		priv->flags = flags;
+		g_object_notify (G_OBJECT (ap), NM_AP_FLAGS);
+	}
+}
+
+guint32
+nm_ap_get_wpa_flags (NMAccessPoint *ap)
+{
+	guint32 flags;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
+
+	g_object_get (ap, NM_AP_WPA_FLAGS, &flags, NULL);
+
+	return flags;
+}
+
+
+void
+nm_ap_set_wpa_flags (NMAccessPoint *ap, guint32 flags)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->wpa_flags != flags) {
+		priv->wpa_flags = flags;
+		g_object_notify (G_OBJECT (ap), NM_AP_WPA_FLAGS);
+	}
+}
+
+guint32
+nm_ap_get_rsn_flags (NMAccessPoint *ap)
+{
+	guint32 flags;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
+
+	g_object_get (ap, NM_AP_RSN_FLAGS, &flags, NULL);
+
+	return flags;
+}
+
+
+void
+nm_ap_set_rsn_flags (NMAccessPoint *ap, guint32 flags)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->rsn_flags != flags) {
+		priv->rsn_flags = flags;
+		g_object_notify (G_OBJECT (ap), NM_AP_RSN_FLAGS);
+	}
+}
+
+/*
+ * Get/set functions for address
+ *
+ */
+const struct ether_addr * nm_ap_get_address (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	return &NM_AP_GET_PRIVATE (ap)->address;
+}
+
+void nm_ap_set_address (NMAccessPoint *ap, const struct ether_addr * addr)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+	g_return_if_fail (addr != NULL);
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (memcmp (addr, &priv->address, sizeof (priv->address))) {
+		memcpy (&NM_AP_GET_PRIVATE (ap)->address, addr, sizeof (struct ether_addr));
+		g_object_notify (G_OBJECT (ap), NM_AP_HW_ADDRESS);
+	}
+}
+
+
+/*
+ * Get/set functions for mode (ie Ad-Hoc, Infrastructure, etc)
+ *
+ */
+NM80211Mode nm_ap_get_mode (NMAccessPoint *ap)
+{
+	NM80211Mode mode;
+
+	g_return_val_if_fail (NM_IS_AP (ap), -1);
+
+	g_object_get (ap, NM_AP_MODE, &mode, NULL);
+
+	return mode;
+}
+
+void nm_ap_set_mode (NMAccessPoint *ap, const NM80211Mode mode)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	if (mode == NM_802_11_MODE_ADHOC || mode == NM_802_11_MODE_INFRA) {
+		priv = NM_AP_GET_PRIVATE (ap);
+
+		if (priv->mode != mode) {
+			priv->mode = mode;
+			g_object_notify (G_OBJECT (ap), NM_AP_MODE);
+		}
+	} else
+		nm_log_warn (LOGD_WIFI, "Invalid AP mode '%d'", mode);
+}
+
+
+/*
+ * Get/set functions for strength
+ *
+ */
+gint8 nm_ap_get_strength (NMAccessPoint *ap)
+{
+	gint8 strength;
+
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	g_object_get (ap, NM_AP_STRENGTH, &strength, NULL);
+
+	return strength;
+}
+
+void nm_ap_set_strength (NMAccessPoint *ap, const gint8 strength)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->strength != strength) {
+		priv->strength = strength;
+		g_object_notify (G_OBJECT (ap), NM_AP_STRENGTH);
+	}
+}
+
+
+/*
+ * Get/set functions for frequency
+ *
+ */
+guint32
+nm_ap_get_freq (NMAccessPoint *ap)
+{
+	guint32 freq;
+
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	g_object_get (ap, NM_AP_FREQUENCY, &freq, NULL);
+
+	return freq;
+}
+
+void
+nm_ap_set_freq (NMAccessPoint *ap,
+                const guint32 freq)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->freq != freq) {
+		priv->freq = freq;
+		g_object_notify (G_OBJECT (ap), NM_AP_FREQUENCY);
+	}
+}
+
+
+/*
+ * Get/set functions for max bitrate
+ *
+ */
+guint32 nm_ap_get_max_bitrate (NMAccessPoint *ap)
+{
+	guint32 rate;
+
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	g_object_get (ap, NM_AP_MAX_BITRATE, &rate, NULL);
+
+	return rate;
+}
+
+void
+nm_ap_set_max_bitrate (NMAccessPoint *ap, guint32 bitrate)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->max_bitrate != bitrate) {
+		priv->max_bitrate = bitrate;
+		g_object_notify (G_OBJECT (ap), NM_AP_MAX_BITRATE);
+	}
+}
+
+/*
+ * Get/Set functions to indicate that an access point is 'fake', ie whether
+ * or not it was created from scan results
+ */
+gboolean nm_ap_get_fake (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
+
+	return NM_AP_GET_PRIVATE (ap)->fake;
+}
+
+void nm_ap_set_fake (NMAccessPoint *ap, gboolean fake)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->fake = fake;
+}
+
+
+/*
+ * Get/Set functions to indicate whether an AP broadcasts its SSID.
+ */
+gboolean nm_ap_get_broadcast (NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), TRUE);
+
+	return NM_AP_GET_PRIVATE (ap)->broadcast;
+}
+
+
+void nm_ap_set_broadcast (NMAccessPoint *ap, gboolean broadcast)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->broadcast = broadcast;
+}
+
+
+/*
+ * Get/Set functions for how long ago the AP was last seen in a scan.
+ * APs older than a certain date are dropped from the list.
+ *
+ */
+glong nm_ap_get_last_seen (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
+
+	return NM_AP_GET_PRIVATE (ap)->last_seen;
+}
+
+void nm_ap_set_last_seen (NMAccessPoint *ap, const glong last_seen)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->last_seen = last_seen;
+}
+
+
+/*
+ * Get/Set functions to indicate that an access point is
+ * user-created, ie whether or not its a network filled with
+ * information from the user and intended to create a new Ad-Hoc
+ * wireless network.
+ *
+ */
+gboolean nm_ap_get_user_created (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
+
+	return NM_AP_GET_PRIVATE (ap)->user_created;
+}
+
+void nm_ap_set_user_created (NMAccessPoint *ap, gboolean user_created)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->user_created = user_created;
+}
+
+
+/*
+ * Get/Set functions for user address list
+ *
+ * The internal address list is always "owned" by the AP and
+ * the list returned by nm_ap_get_user_addresses() is a deep copy.
+ * Likewise, when setting the list, a deep copy is made for the
+ * ap's actual list.
+ *
+ */
+GSList *nm_ap_get_user_addresses (const NMAccessPoint *ap)
+{
+	GSList	*new = NULL;
+	GSList	*elt = NULL;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	for (elt = NM_AP_GET_PRIVATE (ap)->user_addresses; elt; elt = g_slist_next (elt))
+	{
+		if (elt->data)
+			new = g_slist_append (new, g_strdup (elt->data));
+	}
+
+	/* Return a _deep__copy_ of the address list */
+	return new;
+}
+
+void nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list)
+{
+	NMAccessPointPrivate *priv;
+	GSList	*elt = NULL;
+	GSList	*new = NULL;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	/* Free existing list */
+	g_slist_foreach (priv->user_addresses, (GFunc) g_free, NULL);
+
+	/* Copy new list and set as our own */
+	for (elt = list; elt; elt = g_slist_next (elt))
+	{
+		if (elt->data)
+			new = g_slist_append (new, g_ascii_strup (elt->data, -1));
+	}
+
+	priv->user_addresses = new;
+}
+
+
+guint32
+nm_ap_add_security_from_ie (guint32 flags,
+                            const guint8 *wpa_ie,
+                            guint32 length)
+{
+	wpa_ie_data * cap_data;
+
+	if (!(cap_data = wpa_parse_wpa_ie (wpa_ie, length)))
+		return NM_802_11_AP_SEC_NONE;
+
+	/* Pairwise cipher flags */
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP40)
+		flags |= NM_802_11_AP_SEC_PAIR_WEP40;
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP104)
+		flags |= NM_802_11_AP_SEC_PAIR_WEP104;
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_TKIP)
+		flags |= NM_802_11_AP_SEC_PAIR_TKIP;
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_CCMP)
+		flags |= NM_802_11_AP_SEC_PAIR_CCMP;
+
+	/* Group cipher flags */
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP40)
+		flags |= NM_802_11_AP_SEC_GROUP_WEP40;
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP104)
+		flags |= NM_802_11_AP_SEC_GROUP_WEP104;
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_TKIP)
+		flags |= NM_802_11_AP_SEC_GROUP_TKIP;
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_CCMP)
+		flags |= NM_802_11_AP_SEC_GROUP_CCMP;
+
+	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_802_1X)
+		flags |= NM_802_11_AP_SEC_KEY_MGMT_802_1X;
+	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_PSK)
+		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
+
+	g_slice_free (wpa_ie_data, cap_data);
+	return flags;
+}
+
+gboolean
+nm_ap_check_compatible (NMAccessPoint *self,
+                        NMConnection *connection)
+{
+	NMAccessPointPrivate *priv;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wireless_sec;
+	const char *mode;
+	const char *band;
+	const GByteArray *bssid;
+	guint32 channel;
+
+	g_return_val_if_fail (NM_IS_AP (self), FALSE);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
+
+	priv = NM_AP_GET_PRIVATE (self);
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	if (s_wireless == NULL)
+		return FALSE;
+	
+	if (!nm_utils_same_ssid (nm_setting_wireless_get_ssid (s_wireless), priv->ssid, TRUE))
+		return FALSE;
+
+	bssid = nm_setting_wireless_get_bssid (s_wireless);
+	if (bssid && memcmp (bssid->data, &priv->address, ETH_ALEN))
+		return FALSE;
+
+	mode = nm_setting_wireless_get_mode (s_wireless);
+	if (mode) {
+		if (!strcmp (mode, "infrastructure") && (priv->mode != NM_802_11_MODE_INFRA))
+			return FALSE;
+		if (!strcmp (mode, "adhoc") && (priv->mode != NM_802_11_MODE_ADHOC))
+			return FALSE;
+	}
+
+	band = nm_setting_wireless_get_band (s_wireless);
+	if (band) {
+		if (!strcmp (band, "a")) {
+			if (priv->freq < 4915 || priv->freq > 5825)
+				return FALSE;
+		} else if (!strcmp (band, "bg")) {
+			if (priv->freq < 2412 || priv->freq > 2484)
+				return FALSE;
+		}
+	}
+
+	channel = nm_setting_wireless_get_channel (s_wireless);
+	if (channel) {
+		guint32 ap_chan = freq_to_channel (priv->freq);
+
+		if (channel != ap_chan)
+			return FALSE;
+	}
+
+	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection,
+															    NM_TYPE_SETTING_WIRELESS_SECURITY);
+
+	return nm_setting_wireless_ap_security_compatible (s_wireless,
+											 s_wireless_sec,
+											 nm_ap_get_flags (self),
+											 nm_ap_get_wpa_flags (self),
+											 nm_ap_get_rsn_flags (self),
+											 nm_ap_get_mode (self));
+}
+
+static gboolean
+capabilities_compatible (guint32 a_flags, guint32 b_flags)
+{
+	if (a_flags == b_flags)
+		return TRUE;
+
+	/* Make sure there's a common key management method */
+	if (!((a_flags & 0x300) & (b_flags & 0x300)))
+		return FALSE;
+
+	/* Ensure common pairwise ciphers */
+	if (!((a_flags & 0xF) & (b_flags & 0xF)))
+		return FALSE;
+
+	/* Ensure common group ciphers */
+	if (!((a_flags & 0xF0) & (b_flags & 0xF0)))
+		return FALSE;
+
+	return TRUE;
+}
+
+NMAccessPoint *
+nm_ap_match_in_list (NMAccessPoint *find_ap,
+                     GSList *ap_list,
+                     gboolean strict_match)
+{
+	GSList *iter;
+
+	g_return_val_if_fail (find_ap != NULL, NULL);
+
+	for (iter = ap_list; iter; iter = g_slist_next (iter)) {
+		NMAccessPoint * list_ap = NM_AP (iter->data);
+		const GByteArray * list_ssid = nm_ap_get_ssid (list_ap);
+		const struct ether_addr * list_addr = nm_ap_get_address (list_ap);
+
+		const GByteArray * find_ssid = nm_ap_get_ssid (find_ap);
+		const struct ether_addr * find_addr = nm_ap_get_address (find_ap);
+
+		/* SSID match; if both APs are hiding their SSIDs,
+		 * let matching continue on BSSID and other properties
+		 */
+		if (   (!list_ssid && find_ssid)
+		    || (list_ssid && !find_ssid)
+		    || !nm_utils_same_ssid (list_ssid, find_ssid, TRUE))
+			continue;
+
+		/* BSSID match */
+		if (   (strict_match || nm_ethernet_address_is_valid (find_addr))
+		    && nm_ethernet_address_is_valid (list_addr)
+		    && memcmp (list_addr->ether_addr_octet, 
+		               find_addr->ether_addr_octet,
+		               ETH_ALEN) != 0) {
+			continue;
+		}
+
+		/* mode match */
+		if (nm_ap_get_mode (list_ap) != nm_ap_get_mode (find_ap))
+			continue;
+
+		/* Frequency match */
+		if (nm_ap_get_freq (list_ap) != nm_ap_get_freq (find_ap))
+			continue;
+
+		/* AP flags */
+		if (nm_ap_get_flags (list_ap) != nm_ap_get_flags (find_ap))
+			continue;
+
+		if (strict_match) {
+			if (nm_ap_get_wpa_flags (list_ap) != nm_ap_get_wpa_flags (find_ap))
+				continue;
+
+			if (nm_ap_get_rsn_flags (list_ap) != nm_ap_get_rsn_flags (find_ap))
+				continue;
+		} else {
+			guint32 list_wpa_flags = nm_ap_get_wpa_flags (list_ap);
+			guint32 find_wpa_flags = nm_ap_get_wpa_flags (find_ap);
+			guint32 list_rsn_flags = nm_ap_get_rsn_flags (list_ap);
+			guint32 find_rsn_flags = nm_ap_get_rsn_flags (find_ap);
+
+			/* Just ensure that there is overlap in the capabilities */
+			if (   !capabilities_compatible (list_wpa_flags, find_wpa_flags)
+			    && !capabilities_compatible (list_rsn_flags, find_rsn_flags))
+				continue;
+		}
+
+		return list_ap;
+	}
+
+	return NULL;
+}
+
+
+struct cf_pair {
+	guint32 chan;
+	guint32 freq;
+};
+
+static struct cf_pair a_table[] = {
+	/* A band */
+	{  7, 5035 },
+	{  8, 5040 },
+	{  9, 5045 },
+	{ 11, 5055 },
+	{ 12, 5060 },
+	{ 16, 5080 },
+	{ 34, 5170 },
+	{ 36, 5180 },
+	{ 38, 5190 },
+	{ 40, 5200 },
+	{ 42, 5210 },
+	{ 44, 5220 },
+	{ 46, 5230 },
+	{ 48, 5240 },
+	{ 50, 5250 },
+	{ 52, 5260 },
+	{ 56, 5280 },
+	{ 58, 5290 },
+	{ 60, 5300 },
+	{ 64, 5320 },
+	{ 100, 5500 },
+	{ 104, 5520 },
+	{ 108, 5540 },
+	{ 112, 5560 },
+	{ 116, 5580 },
+	{ 120, 5600 },
+	{ 124, 5620 },
+	{ 128, 5640 },
+	{ 132, 5660 },
+	{ 136, 5680 },
+	{ 140, 5700 },
+	{ 149, 5745 },
+	{ 152, 5760 },
+	{ 153, 5765 },
+	{ 157, 5785 },
+	{ 160, 5800 },
+	{ 161, 5805 },
+	{ 165, 5825 },
+	{ 183, 4915 },
+	{ 184, 4920 },
+	{ 185, 4925 },
+	{ 187, 4935 },
+	{ 188, 4945 },
+	{ 192, 4960 },
+	{ 196, 4980 },
+	{ 0, -1 }
+};
+
+static struct cf_pair bg_table[] = {
+	/* B/G band */
+	{ 1, 2412 },
+	{ 2, 2417 },
+	{ 3, 2422 },
+	{ 4, 2427 },
+	{ 5, 2432 },
+	{ 6, 2437 },
+	{ 7, 2442 },
+	{ 8, 2447 },
+	{ 9, 2452 },
+	{ 10, 2457 },
+	{ 11, 2462 },
+	{ 12, 2467 },
+	{ 13, 2472 },
+	{ 14, 2484 },
+	{ 0, -1 }
+};
+
+guint32
+freq_to_channel (guint32 freq)
+{
+	int i = 0;
+
+	if (freq > 4900) {
+		while (a_table[i].chan && (a_table[i].freq != freq))
+			i++;
+		return a_table[i].chan;
+	} else {
+		while (bg_table[i].chan && (bg_table[i].freq != freq))
+			i++;
+		return bg_table[i].chan;
+	}
+
+	return 0;
+}
+
+guint32
+channel_to_freq (guint32 channel, const char *band)
+{
+	int i = 0;
+
+	if (!strcmp (band, "a")) {
+		while (a_table[i].chan && (a_table[i].chan != channel))
+			i++;
+		return a_table[i].freq;
+	} else if (!strcmp (band, "bg")) {
+		while (bg_table[i].chan && (bg_table[i].chan != channel))
+			i++;
+		return bg_table[i].freq;
+	}
+
+	return 0;
+}
+
diff --git a/src/nm-wifi-ap.h b/src/nm-wifi-ap.h
new file mode 100644
index 0000000..edc9e56
--- /dev/null
+++ b/src/nm-wifi-ap.h
@@ -0,0 +1,129 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#ifndef NM_ACCESS_POINT_H
+#define NM_ACCESS_POINT_H
+
+#include <glib.h>
+#include <glib-object.h>
+#include <time.h>
+#include "NetworkManager.h"
+#include "nm-connection.h"
+
+#define NM_TYPE_AP            (nm_ap_get_type ())
+#define NM_AP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_AP, NMAccessPoint))
+#define NM_AP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_AP, NMAccessPointClass))
+#define NM_IS_AP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_AP))
+#define NM_IS_AP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_AP))
+#define NM_AP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_AP, NMAccessPointClass))
+
+#define NM_AP_FLAGS "flags"
+#define NM_AP_WPA_FLAGS "wpa-flags"
+#define NM_AP_RSN_FLAGS "rsn-flags"
+#define NM_AP_SSID "ssid"
+#define NM_AP_FREQUENCY "frequency"
+#define NM_AP_HW_ADDRESS "hw-address"
+#define NM_AP_MODE "mode"
+#define NM_AP_MAX_BITRATE "max-bitrate"
+#define NM_AP_STRENGTH "strength"
+
+typedef struct {
+	GObject parent;
+} NMAccessPoint;
+
+typedef struct {
+	GObjectClass parent;
+
+	/* Signals */
+	void (*properties_changed) (NMAccessPoint *ap, GHashTable *properties);
+} NMAccessPointClass;
+
+GType nm_ap_get_type (void);
+
+NMAccessPoint *	nm_ap_new				(void);
+NMAccessPoint * nm_ap_new_from_properties (GHashTable *properties);
+NMAccessPoint * nm_ap_new_fake_from_connection (NMConnection *connection);
+void            nm_ap_export_to_dbus    (NMAccessPoint *ap);
+
+const char *		nm_ap_get_dbus_path (NMAccessPoint *ap);
+const GTimeVal *	nm_ap_get_timestamp				(const NMAccessPoint *ap);
+void				nm_ap_set_timestamp				(NMAccessPoint *ap, glong sec, glong usec);
+void				nm_ap_set_timestamp_via_timestamp	(NMAccessPoint *ap, const GTimeVal *timestamp);
+
+const GByteArray *	nm_ap_get_ssid (const NMAccessPoint * ap);
+void				nm_ap_set_ssid (NMAccessPoint * ap, const GByteArray * ssid);
+
+guint32			nm_ap_get_flags	(NMAccessPoint *ap);
+void				nm_ap_set_flags	(NMAccessPoint *ap, guint32 flags);
+
+guint32			nm_ap_get_wpa_flags	(NMAccessPoint *ap);
+void				nm_ap_set_wpa_flags	(NMAccessPoint *ap, guint32 flags);
+
+guint32			nm_ap_get_rsn_flags	(NMAccessPoint *ap);
+void				nm_ap_set_rsn_flags	(NMAccessPoint *ap, guint32 flags);
+
+const struct ether_addr * nm_ap_get_address	(const NMAccessPoint *ap);
+void				nm_ap_set_address		(NMAccessPoint *ap, const struct ether_addr *addr);
+
+NM80211Mode			nm_ap_get_mode			(NMAccessPoint *ap);
+void				nm_ap_set_mode			(NMAccessPoint *ap, const NM80211Mode mode);
+
+gint8			nm_ap_get_strength		(NMAccessPoint *ap);
+void				nm_ap_set_strength		(NMAccessPoint *ap, gint8 strength);
+
+guint32			nm_ap_get_freq			(NMAccessPoint *ap);
+void				nm_ap_set_freq			(NMAccessPoint *ap, guint32 freq);
+
+guint32			nm_ap_get_max_bitrate			(NMAccessPoint *ap);
+void				nm_ap_set_max_bitrate		(NMAccessPoint *ap, guint32 bitrate);
+
+gboolean			nm_ap_get_fake	(const NMAccessPoint *ap);
+void				nm_ap_set_fake	(NMAccessPoint *ap, gboolean fake);
+
+gboolean			nm_ap_get_broadcast		(NMAccessPoint *ap);
+void				nm_ap_set_broadcast		(NMAccessPoint *ap, gboolean broadcast);
+
+glong			nm_ap_get_last_seen		(const NMAccessPoint *ap);
+void				nm_ap_set_last_seen		(NMAccessPoint *ap, const glong last_seen);
+
+gboolean			nm_ap_get_user_created	(const NMAccessPoint *ap);
+void				nm_ap_set_user_created	(NMAccessPoint *ap, gboolean user_created);
+
+GSList *			nm_ap_get_user_addresses	(const NMAccessPoint *ap);
+void				nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list);
+
+guint32				nm_ap_add_security_from_ie (guint32 flags,
+                                                const guint8 *wpa_ie,
+                                                guint32 length);
+
+gboolean			nm_ap_check_compatible (NMAccessPoint *self,
+                                            NMConnection *connection);
+
+NMAccessPoint *     nm_ap_match_in_list (NMAccessPoint *find_ap,
+                                         GSList *ap_list,
+                                         gboolean strict_match);
+
+void				nm_ap_print_self (NMAccessPoint *ap, const char * prefix);
+
+guint32 freq_to_channel (guint32 freq);
+guint32 channel_to_freq (guint32 channel, const char *band);
+
+#endif /* NM_ACCESS_POINT_H */
diff --git a/src/ppp-manager/Makefile.am b/src/ppp-manager/Makefile.am
index 41cb537..2dc7ad9 100644
--- a/src/ppp-manager/Makefile.am
+++ b/src/ppp-manager/Makefile.am
@@ -3,6 +3,7 @@ INCLUDES = \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_builddir}/marshallers
 
 noinst_LTLIBRARIES = libppp-manager.la
@@ -28,6 +29,7 @@ libppp_manager_la_CPPFLAGS = \
 
 libppp_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
 
diff --git a/src/ppp-manager/nm-ppp-manager.c b/src/ppp-manager/nm-ppp-manager.c
index d3c9f6e..de905b4 100644
--- a/src/ppp-manager/nm-ppp-manager.c
+++ b/src/ppp-manager/nm-ppp-manager.c
@@ -49,7 +49,7 @@
 #include "nm-setting-gsm.h"
 #include "nm-setting-cdma.h"
 #include "nm-dbus-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 
 static void impl_ppp_manager_need_secrets (NMPPPManager *manager,
@@ -296,12 +296,13 @@ monitor_cb (gpointer user_data)
 	req.stats_ptr = (caddr_t) &req.stats;
 
 	strncpy (req.ifr__name, priv->ip_iface, sizeof (req.ifr__name));
-	if (ioctl (priv->monitor_fd, SIOCGPPPSTATS, &req) < 0)
-		nm_warning ("Could not read ppp stats: %s", strerror (errno));
-	else
+	if (ioctl (priv->monitor_fd, SIOCGPPPSTATS, &req) < 0) {
+		nm_log_warn (LOGD_PPP, "could not read ppp stats: %s", strerror (errno));
+	} else {
 		g_signal_emit (manager, signals[STATS], 0, 
-					req.stats.p.ppp_ibytes,
-					req.stats.p.ppp_obytes);
+		               req.stats.p.ppp_ibytes,
+		               req.stats.p.ppp_obytes);
+	}
 
 	return TRUE;
 }
@@ -315,7 +316,7 @@ monitor_stats (NMPPPManager *manager)
 	if (priv->monitor_fd > 0)
 		priv->monitor_id = g_timeout_add_seconds (5, monitor_cb, manager);
 	else
-		nm_warning ("Could not open pppd monitor: %s", strerror (errno));
+		nm_log_warn (LOGD_PPP, "could not monitor PPP stats: %s", strerror (errno));
 }
 
 /*******************************************/
@@ -387,8 +388,8 @@ impl_ppp_manager_need_secrets (NMPPPManager *manager,
 			GError *err = NULL;
 
 			g_set_error (&err, NM_PPP_MANAGER_ERROR, NM_PPP_MANAGER_ERROR_UNKOWN,
-					   "Missing type-specific setting; no secrets could be found.");
-			nm_warning ("%s", err->message);
+			             "Missing type-specific setting; no secrets could be found.");
+			nm_log_warn (LOGD_PPP, "%s", err->message);
 			dbus_g_method_return_error (context, err);
 		}
 		return;
@@ -442,7 +443,7 @@ impl_ppp_manager_set_ip4_config (NMPPPManager *manager,
 	GValue *val;
 	int i;
 
-	nm_info ("PPP manager(IP Config Get) reply received.");
+	nm_log_info (LOGD_PPP, "PPP manager(IP Config Get) reply received.");
 
 	remove_timeout_handler (manager);
 
@@ -467,7 +468,7 @@ impl_ppp_manager_set_ip4_config (NMPPPManager *manager,
 	if (nm_ip4_address_get_address (addr) && nm_ip4_address_get_prefix (addr)) {
 		nm_ip4_config_take_address (config, addr);
 	} else {
-		nm_warning ("%s: invalid IPv4 address received!", __func__);
+		nm_log_err (LOGD_PPP, "invalid IPv4 address received!");
 		nm_ip4_address_unref (addr);
 		goto out;
 	}
@@ -490,7 +491,7 @@ impl_ppp_manager_set_ip4_config (NMPPPManager *manager,
 
 	val = (GValue *) g_hash_table_lookup (config_hash, NM_PPP_IP4_CONFIG_INTERFACE);
 	if (!val || !G_VALUE_HOLDS_STRING (val)) {
-		nm_warning ("No interface");
+		nm_log_err (LOGD_PPP, "no interface received!");
 		goto out;
 	}
 	priv->ip_iface = g_value_dup_string (val);
@@ -582,13 +583,12 @@ nm_cmd_line_add_int (NMCmdLine *cmd, int i)
 static inline const char *
 nm_find_pppd (void)
 {
-	static const char *pppd_binary_paths[] =
-		{
-			"/usr/local/sbin/pppd",
-			"/usr/sbin/pppd",
-			"/sbin/pppd",
-			NULL
-		};
+	static const char *pppd_binary_paths[] = {
+		"/usr/local/sbin/pppd",
+		"/usr/sbin/pppd",
+		"/sbin/pppd",
+		NULL
+	};
 
 	const char  **pppd_binary = pppd_binary_paths;
 
@@ -670,7 +670,7 @@ ppp_exit_code (guint pppd_exit_status, GPid pid)
 		msg = "Unknown error";
 	}
 
-	nm_warning ("ppp pid %d exited with error: %s", pid, msg);
+	nm_log_warn (LOGD_PPP, "pppd pid %d exited with error: %s", pid, msg);
 }
 
 static void
@@ -686,14 +686,14 @@ ppp_watch_cb (GPid pid, gint status, gpointer user_data)
 		err = WEXITSTATUS (status);
 		if (err != 0)
 			ppp_exit_code (err, priv->pid);
-	} else if (WIFSTOPPED (status))
-		nm_warning ("ppp pid %d stopped unexpectedly with signal %d", priv->pid, WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		nm_warning ("ppp pid %d died with signal %d", priv->pid, WTERMSIG (status));
-	else
-		nm_warning ("ppp pid %d died from an unknown cause", priv->pid);
-
-	nm_debug ("ppp pid %d cleaned up", priv->pid);
+	} else if (WIFSTOPPED (status)) {
+		nm_log_info (LOGD_PPP, "pppd pid %d stopped unexpectedly with signal %d", priv->pid, WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_info (LOGD_PPP, "pppd pid %d died with signal %d", priv->pid, WTERMSIG (status));
+	} else
+		nm_log_info (LOGD_PPP, "pppd pid %d died from an unknown cause", priv->pid);
+
+	nm_log_dbg (LOGD_PPP, "pppd pid %d cleaned up", priv->pid);
 	priv->pid = 0;
 	g_signal_emit (manager, signals[STATE_CHANGED], 0, NM_PPP_STATUS_DEAD);
 }
@@ -703,7 +703,7 @@ pppd_timed_out (gpointer data)
 {
 	NMPPPManager *manager = NM_PPP_MANAGER (data);
 
-	nm_warning ("Looks like pppd didn't initialize our dbus module");
+	nm_log_warn (LOGD_PPP, "pppd timed out or didn't initialize our dbus module");
 	nm_ppp_manager_stop (manager);
 
 	g_signal_emit (manager, signals[STATE_CHANGED], 0, NM_PPP_STATUS_DEAD);
@@ -913,10 +913,10 @@ nm_ppp_manager_start (NMPPPManager *manager,
 
 	priv = NM_PPP_MANAGER_GET_PRIVATE (manager);
 
-	nm_info ("Starting pppd connection");
+	nm_log_info (LOGD_PPP, "starting PPP connection");
 
 	cmd_str = nm_cmd_line_to_str (ppp_cmd);
-	nm_debug ("Command line: %s", cmd_str);
+	nm_log_dbg (LOGD_PPP, "command line: %s", cmd_str);
 	g_free (cmd_str);
 
 	priv->pid = 0;
@@ -927,7 +927,7 @@ nm_ppp_manager_start (NMPPPManager *manager,
 		goto out;
 	}
 
-	nm_debug ("ppp started with pid %d", priv->pid);
+	nm_log_info (LOGD_PPP, "pppd started with pid %d", priv->pid);
 
 	priv->ppp_watch_id = g_child_watch_add (priv->pid, (GChildWatchFunc) ppp_watch_cb, manager);
 	priv->ppp_timeout_handler = g_timeout_add_seconds (timeout_secs, pppd_timed_out, manager);
@@ -965,7 +965,7 @@ nm_ppp_manager_update_secrets (NMPPPManager *manager,
 		GError *err = NULL;
 
 		g_set_error (&err, NM_PPP_MANAGER_ERROR, NM_PPP_MANAGER_ERROR_UNKOWN, "%s", error_message);
-		nm_warning ("%s", error_message);
+		nm_log_warn (LOGD_PPP, "%s", error_message);
 		dbus_g_method_return_error (priv->pending_secrets_context, err);
 		g_error_free (err);
 	} else {
@@ -989,9 +989,9 @@ ensure_killed (gpointer data)
 		kill (pid, SIGKILL);
 
 	/* ensure the child is reaped */
-	nm_debug ("waiting for ppp pid %d to exit", pid);
+	nm_log_dbg (LOGD_PPP, "waiting for pppd pid %d to exit", pid);
 	waitpid (pid, NULL, 0);
-	nm_debug ("ppp pid %d cleaned up", pid);
+	nm_log_dbg (LOGD_PPP, "pppd pid %d cleaned up", pid);
 
 	return FALSE;
 }
@@ -1034,9 +1034,9 @@ nm_ppp_manager_stop (NMPPPManager *manager)
 			kill (priv->pid, SIGKILL);
 
 			/* ensure the child is reaped */
-			nm_debug ("waiting for ppp pid %d to exit", priv->pid);
+			nm_log_dbg (LOGD_PPP, "waiting for pppd pid %d to exit", priv->pid);
 			waitpid (priv->pid, NULL, 0);
-			nm_debug ("ppp pid %d cleaned up", priv->pid);
+			nm_log_dbg (LOGD_PPP, "pppd pid %d cleaned up", priv->pid);
 		}
 
 		priv->pid = 0;
diff --git a/src/ppp-manager/nm-pppd-plugin.c b/src/ppp-manager/nm-pppd-plugin.c
index b98ec28..c64bb87 100644
--- a/src/ppp-manager/nm-pppd-plugin.c
+++ b/src/ppp-manager/nm-pppd-plugin.c
@@ -34,7 +34,6 @@
 #include "nm-pppd-plugin.h"
 #include "nm-ppp-status.h"
 #include "nm-dbus-glib-types.h"
-#include "nm-utils.h"
 
 int plugin_init (void);
 
diff --git a/src/supplicant-manager/Makefile.am b/src/supplicant-manager/Makefile.am
index 540ef76..e59ae84 100644
--- a/src/supplicant-manager/Makefile.am
+++ b/src/supplicant-manager/Makefile.am
@@ -2,6 +2,7 @@ SUBDIRS=. tests
 
 INCLUDES = \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_builddir}/marshallers \
@@ -28,6 +29,7 @@ libsupplicant_manager_la_CPPFLAGS = \
 
 libsupplicant_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
 
diff --git a/src/supplicant-manager/nm-supplicant-config.c b/src/supplicant-manager/nm-supplicant-config.c
index 5f8c4f4..b516de5 100644
--- a/src/supplicant-manager/nm-supplicant-config.c
+++ b/src/supplicant-manager/nm-supplicant-config.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
  * Copyright (C) 2007 - 2008 Novell, Inc.
  */
 
@@ -31,7 +31,7 @@
 
 #include "nm-supplicant-config.h"
 #include "nm-supplicant-settings-verify.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-setting.h"
 #include "NetworkManagerUtils.h"
 
@@ -123,26 +123,26 @@ nm_supplicant_config_add_option_with_type (NMSupplicantConfig *self,
 			char buf[255];
 			memset (&buf[0], 0, sizeof (buf));
 			memcpy (&buf[0], value, len > 254 ? 254 : len);
-			nm_debug ("Key '%s' and/or value '%s' invalid.", key, buf);
+			nm_log_warn (LOGD_SUPPLICANT, "Key '%s' and/or value '%s' invalid.", key, buf);
 			return FALSE;
 		}
 	}
 
 	old_opt = (ConfigOption *) g_hash_table_lookup (priv->config, key);
 	if (old_opt) {
-		nm_debug ("Key '%s' already in table.", key);
+		nm_log_warn (LOGD_SUPPLICANT, "Key '%s' already in table.", key);
 		return FALSE;
 	}
 
 	opt = g_slice_new0 (ConfigOption);
 	if (opt == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option.");
 		return FALSE;
 	}
 
 	opt->value = g_malloc0 ((sizeof (char) * len) + 1);
 	if (opt->value == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option value.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option value.");
 		g_slice_free (ConfigOption, opt);
 		return FALSE;
 	}
@@ -151,12 +151,13 @@ nm_supplicant_config_add_option_with_type (NMSupplicantConfig *self,
 	opt->len = len;
 	opt->type = type;	
 
-{
-char buf[255];
-memset (&buf[0], 0, sizeof (buf));
-memcpy (&buf[0], opt->value, opt->len > 254 ? 254 : opt->len);
-nm_info ("Config: added '%s' value '%s'", key, secret ? "<omitted>" : &buf[0]);
-}
+	{
+		char buf[255];
+		memset (&buf[0], 0, sizeof (buf));
+		memcpy (&buf[0], opt->value, opt->len > 254 ? 254 : opt->len);
+		nm_log_info (LOGD_SUPPLICANT, "Config: added '%s' value '%s'", key, secret ? "<omitted>" : &buf[0]);
+	}
+
 	g_hash_table_insert (priv->config, g_strdup (key), opt);
 
 	return TRUE;
@@ -194,33 +195,33 @@ nm_supplicant_config_add_blob (NMSupplicantConfig *self,
 
 	type = nm_supplicant_settings_verify_setting (key, (const char *) value->data, value->len);
 	if (type == TYPE_INVALID) {
-		nm_debug ("Key '%s' and/or it's contained value is invalid.", key);
+		nm_log_warn (LOGD_SUPPLICANT, "Key '%s' and/or it's contained value is invalid.", key);
 		return FALSE;
 	}
 
 	old_opt = (ConfigOption *) g_hash_table_lookup (priv->config, key);
 	if (old_opt) {
-		nm_debug ("Key '%s' already in table.", key);
+		nm_log_warn (LOGD_SUPPLICANT, "Key '%s' already in table.", key);
 		return FALSE;
 	}
 
 	blob = g_byte_array_sized_new (value->len);
 	if (!blob) {
-		nm_debug ("Couldn't allocate memory for new config blob.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config blob.");
 		return FALSE;
 	}
 	g_byte_array_append (blob, value->data, value->len);
 
 	opt = g_slice_new0 (ConfigOption);
 	if (opt == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option.");
 		g_byte_array_free (blob, TRUE);
 		return FALSE;
 	}
 
 	opt->value = g_strdup_printf ("blob://%s", blobid);
 	if (opt->value == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option value.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option value.");
 		g_byte_array_free (blob, TRUE);
 		g_slice_free (ConfigOption, opt);
 		return FALSE;
@@ -229,7 +230,7 @@ nm_supplicant_config_add_blob (NMSupplicantConfig *self,
 	opt->len = strlen (opt->value);
 	opt->type = type;	
 
-nm_info ("Config: added '%s' value '%s'", key, opt->value);
+	nm_log_info (LOGD_SUPPLICANT, "Config: added '%s' value '%s'", key, opt->value);
 
 	g_hash_table_insert (priv->config, g_strdup (key), opt);
 	g_hash_table_insert (priv->blobs, g_strdup (blobid), blob);
@@ -378,13 +379,13 @@ nm_supplicant_config_add_setting_wireless (NMSupplicantConfig * self,
 
 	id = nm_setting_wireless_get_ssid (setting);
 	if (!nm_supplicant_config_add_option (self, "ssid", (char *) id->data, id->len, FALSE)) {
-		nm_warning ("Error adding SSID to supplicant config.");
+		nm_log_warn (LOGD_SUPPLICANT, "Error adding SSID to supplicant config.");
 		return FALSE;
 	}
 
 	if (is_adhoc) {
 		if (!nm_supplicant_config_add_option (self, "mode", "1", -1, FALSE)) {
-			nm_warning ("Error adding mode to supplicant config.");
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding mode to supplicant config.");
 			return FALSE;
 		}
 
@@ -394,7 +395,7 @@ nm_supplicant_config_add_setting_wireless (NMSupplicantConfig * self,
 			str_freq = g_strdup_printf ("%u", adhoc_freq);
 			if (!nm_supplicant_config_add_option (self, "frequency", str_freq, -1, FALSE)) {
 				g_free (str_freq);
-				nm_warning ("Error adding Ad-Hoc frequency to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding Ad-Hoc frequency to supplicant config.");
 				return FALSE;
 			}
 			g_free (str_freq);
@@ -418,7 +419,7 @@ nm_supplicant_config_add_setting_wireless (NMSupplicantConfig * self,
 		                                      str_bssid, strlen (str_bssid),
 		                                      FALSE)) {
 			g_free (str_bssid);
-			nm_warning ("Error adding BSSID to supplicant config.");
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding BSSID to supplicant config.");
 			return FALSE;
 		}
 		g_free (str_bssid);
@@ -445,7 +446,7 @@ add_string_val (NMSupplicantConfig *self,
 	value = ucase ? g_ascii_strup (field, -1) : g_strdup (field);
 	success = nm_supplicant_config_add_option (self, name, value, strlen (field), secret);
 	if (!success)
-		nm_warning ("Error adding %s to supplicant config.", name);
+		nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 	g_free (value);
 	return success;
 }
@@ -471,7 +472,7 @@ add_string_val (NMSupplicantConfig *self,
 			success = TRUE; \
 		g_string_free (str, TRUE); \
 		if (!success) { \
-			nm_warning ("Error adding %s to supplicant config.", name); \
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name); \
 			return FALSE; \
 		} \
 	}
@@ -494,7 +495,7 @@ get_blob_id (const char *name, const char *seed_uid)
 		success = nm_supplicant_config_add_blob (self, name, field, uid); \
 		g_free (uid); \
 		if (!success) { \
-			nm_warning ("Error adding %s to supplicant config.", name); \
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name); \
 			return FALSE; \
 		} \
 	}
@@ -550,16 +551,16 @@ add_wep_key (NMSupplicantConfig *self,
 			success = nm_supplicant_config_add_option (self, name, value, key_len / 2, TRUE);
 			g_free (value);
 			if (!success) {
-				nm_warning ("Error adding %s to supplicant config.", name);
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 				return FALSE;
 			}
 		} else if ((key_len == 5) || (key_len == 13)) {
 			if (!nm_supplicant_config_add_option (self, name, key, key_len, TRUE)) {
-				nm_warning ("Error adding %s to supplicant config.", name);
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 				return FALSE;
 			}
 		} else {
-			nm_warning ("Invalid WEP key '%s'", name);
+			nm_log_warn (LOGD_SUPPLICANT, "Invalid WEP key '%s'", name);
 			return FALSE;
 		}
 	} else if (wep_type == NM_WEP_KEY_TYPE_PASSPHRASE) {
@@ -570,7 +571,7 @@ add_wep_key (NMSupplicantConfig *self,
 		if (success)
 			success = nm_supplicant_config_add_option (self, name, (const char *) digest, digest_len, TRUE);
 		if (!success) {
-			nm_warning ("Error adding %s to supplicant config.", name);
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 			return FALSE;
 		}
 	}
@@ -611,7 +612,7 @@ nm_supplicant_config_add_setting_wireless_security (NMSupplicantConfig *self,
 			success = nm_supplicant_config_add_option (self, "psk", value, psk_len / 2, TRUE);
 			g_free (value);
 			if (!success) {
-				nm_warning ("Error adding 'psk' to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding 'psk' to supplicant config.");
 				return FALSE;
 			}
 		} else if (psk_len >= 8 && psk_len <= 63) {
@@ -621,12 +622,12 @@ nm_supplicant_config_add_setting_wireless_security (NMSupplicantConfig *self,
 			 * passphrase and not a hex key.
 			 */
 			if (!nm_supplicant_config_add_option_with_type (self, "psk", psk, -1, TYPE_STRING, TRUE)) {
-				nm_warning ("Error adding 'psk' to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding 'psk' to supplicant config.");
 				return FALSE;
 			}
 		} else {
 			/* Invalid PSK */
-			nm_warning ("Invalid PSK length %u: not between 8 and 63 characters inclusive.", (guint32) psk_len);
+			nm_log_warn (LOGD_SUPPLICANT, "Invalid PSK length %u: not between 8 and 63 characters inclusive.", (guint32) psk_len);
 			return FALSE;
 		}
 	}
@@ -662,7 +663,7 @@ nm_supplicant_config_add_setting_wireless_security (NMSupplicantConfig *self,
 			success = nm_supplicant_config_add_option (self, "wep_tx_keyidx", value, -1, FALSE);
 			g_free (value);
 			if (!success) {
-				nm_warning ("Error adding wep_tx_keyidx to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding wep_tx_keyidx to supplicant config.");
 				return FALSE;
 			}
 		}
diff --git a/src/supplicant-manager/nm-supplicant-interface.c b/src/supplicant-manager/nm-supplicant-interface.c
index 00f0c30..a65a458 100644
--- a/src/supplicant-manager/nm-supplicant-interface.c
+++ b/src/supplicant-manager/nm-supplicant-interface.c
@@ -25,7 +25,7 @@
 
 #include "nm-supplicant-interface.h"
 #include "nm-supplicant-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "nm-supplicant-config.h"
 #include "nm-dbus-manager.h"
@@ -144,6 +144,7 @@ typedef struct {
 	DBusGProxy *proxy;
 	NMCallStore *store;
 	DBusGProxyCall *call;
+	gboolean disposing;
 } NMSupplicantInfo;
 
 static NMSupplicantInfo *
@@ -164,10 +165,11 @@ nm_supplicant_info_new (NMSupplicantInterface *interface,
 static void
 nm_supplicant_info_set_call (NMSupplicantInfo *info, DBusGProxyCall *call)
 {
-	if (call) {
-		nm_call_store_add (info->store, G_OBJECT (info->proxy), (gpointer) call);
-		info->call = call;
-	}
+	g_return_if_fail (info != NULL);
+	g_return_if_fail (call != NULL);
+
+	nm_call_store_add (info->store, G_OBJECT (info->proxy), (gpointer) call);
+	info->call = call;
 }
 
 static void
@@ -175,13 +177,30 @@ nm_supplicant_info_destroy (gpointer user_data)
 {
 	NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
 
-	if (info->call)
-		nm_call_store_remove (info->store, G_OBJECT (info->proxy), info->call);
+	/* Guard against double-disposal; since DBusGProxy doesn't guard against
+	 * double-disposal, we could infinite loop here if we're in the middle of
+	 * some wpa_supplicant D-Bus calls.  When the supplicant dies we'll dispose
+	 * of the proxy, which kills all its pending calls, which brings us here.
+	 * Then when we unref the proxy here, its dispose() function will get called
+	 * again, and we get right back here until we segfault because our callstack
+	 * is too long.
+	 */
+	if (!info->disposing) {
+		info->disposing = TRUE;
 
-	g_object_unref (info->proxy);
-	g_object_unref (info->interface);
+		if (info->call) {
+			nm_call_store_remove (info->store, G_OBJECT (info->proxy), info->call);
+			info->call = NULL;
+		}
 
-	g_slice_free (NMSupplicantInfo, info);
+		g_object_unref (info->proxy);
+		info->proxy = NULL;
+		g_object_unref (info->interface);
+		info->interface = NULL;
+
+		memset (info, 0, sizeof (NMSupplicantInfo));
+		g_slice_free (NMSupplicantInfo, info);
+	}
 }
 
 
@@ -498,8 +517,10 @@ bssid_properties_cb  (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_MAP_OF_VARIANT, &hash,
 	                            G_TYPE_INVALID)) {
-		if (!strstr (err->message, "The BSSID requested was invalid"))
-			nm_warning ("Couldn't retrieve BSSID properties: %s.", err->message);
+		if (!strstr (err->message, "The BSSID requested was invalid")) {
+			nm_log_warn (LOGD_SUPPLICANT, "Couldn't retrieve BSSID properties: %s.",
+			             err->message);
+		}
 		g_error_free (err);
 	} else {
 		g_signal_emit (info->interface,
@@ -543,7 +564,7 @@ scan_results_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_ARRAY_OF_OBJECT_PATH, &array,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("could not get scan results: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "could not get scan results: %s.", err->message);
 		g_error_free (err);
 	} else {
 		int i;
@@ -672,7 +693,7 @@ iface_state_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            G_TYPE_STRING, &state_str,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("could not get interface state: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "could not get interface state: %s.", err->message);
 		g_error_free (err);
 	} else {
 		NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
@@ -766,6 +787,7 @@ static void
 nm_supplicant_interface_add_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
 	NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
 	GError *err = NULL;
 	char *path = NULL;
 
@@ -780,12 +802,13 @@ nm_supplicant_interface_add_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpoi
 			/* Interface already added, just try to get the interface */
 			nm_supplicant_interface_add_to_supplicant (info->interface, TRUE);
 		} else {
-			nm_warning ("Unexpected supplicant error getting interface: %s", err->message);
+			nm_log_err (LOGD_SUPPLICANT, "(%s): error getting interface: %s",
+			            priv->dev, err->message);
 		}
 
 		g_error_free (err);
 	} else {
-		NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
+		nm_log_dbg (LOGD_SUPPLICANT, "(%s): interface added to supplicant", priv->dev);
 
 		priv->object_path = path;
 
@@ -884,6 +907,8 @@ nm_supplicant_interface_start (NMSupplicantInterface * self)
 	/* Can only start the interface from INIT state */
 	g_return_if_fail (priv->state == NM_SUPPLICANT_INTERFACE_STATE_INIT);
 
+	nm_log_dbg (LOGD_SUPPLICANT, "(%s): adding interface to supplicant", priv->dev);
+
 	state = nm_supplicant_manager_get_state (priv->smgr);
 	if (state == NM_SUPPLICANT_MANAGER_STATE_IDLE) {
 		nm_supplicant_interface_set_state (self, NM_SUPPLICANT_INTERFACE_STATE_STARTING);
@@ -893,7 +918,7 @@ nm_supplicant_interface_start (NMSupplicantInterface * self)
 		 * that its state has changed.
 		 */
 	} else
-		nm_warning ("Unknown supplicant manager state!");
+		nm_log_warn (LOGD_SUPPLICANT, "Unknown supplicant manager state!");
 }
 
 static void
@@ -914,7 +939,7 @@ nm_supplicant_interface_handle_supplicant_manager_idle_state (NMSupplicantInterf
 			/* Don't do anything here; interface can't get out of DOWN state */
 			break;
 		default:
-			nm_warning ("Unknown supplicant interface state!");
+			nm_log_warn (LOGD_SUPPLICANT, "Unknown supplicant interface state!");
 			break;
 	}
 }
@@ -970,7 +995,7 @@ nm_supplicant_interface_smgr_state_changed (NMSupplicantManager * smgr,
 			nm_supplicant_interface_handle_supplicant_manager_idle_state (self);
 			break;
 		default:
-			nm_warning ("Unknown supplicant manager state!");
+			nm_log_warn (LOGD_SUPPLICANT, "Unknown supplicant manager state!");
 			break;
 	}
 }
@@ -983,7 +1008,8 @@ remove_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_dat
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't remove network from supplicant interface: %s.", err->message);
+		nm_log_dbg (LOGD_SUPPLICANT, "Couldn't remove network from supplicant interface: %s.",
+		            err->message);
 		g_error_free (err);
 	}
 }
@@ -995,7 +1021,8 @@ disconnect_cb  (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't disconnect supplicant interface: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't disconnect supplicant interface: %s.",
+		             err->message);
 		g_error_free (err);
 	}
 }
@@ -1057,7 +1084,7 @@ select_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_dat
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't select network config: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't select network config: %s.", err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	}
@@ -1072,7 +1099,7 @@ set_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't set network config: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't set network config: %s.", err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	} else {
@@ -1116,7 +1143,7 @@ set_blobs_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't set network blobs: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't set network certificates: %s.", err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	} else {
@@ -1165,7 +1192,8 @@ call_set_blobs (NMSupplicantInfo *info, GHashTable *orig_blobs)
 	                               (GDestroyNotify) blob_free);
 	if (!blobs) {
 		const char *msg = "Not enough memory to create blob table.";
-		nm_warning ("%s", msg);
+
+		nm_log_warn (LOGD_SUPPLICANT, "%s", msg);
 		g_signal_emit (info->interface,
 		               nm_supplicant_interface_signals[CONNECTION_ERROR],
 		               0, "SendBlobError", msg);
@@ -1194,7 +1222,8 @@ add_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_OBJECT_PATH, &path,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("Couldn't add a network to the supplicant interface: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't add a network to the supplicant interface: %s.",
+		             err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	} else {
@@ -1225,22 +1254,21 @@ static void
 set_ap_scan_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
 	NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
 	GError *err = NULL;
 	guint32 tmp;
 	DBusGProxyCall *call;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't send AP scan mode to the supplicant interface: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't send AP scan mode to the supplicant interface: %s.",
+		             err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 		return;
 	}
 
-{
-NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
-int ap_scan = nm_supplicant_config_get_ap_scan (priv->cfg);
-nm_info ("Config: set interface ap_scan to %d", ap_scan);
-}
+	nm_log_info (LOGD_SUPPLICANT, "Config: set interface ap_scan to %d",
+	             nm_supplicant_config_get_ap_scan (priv->cfg));
 
 	info = nm_supplicant_info_new (info->interface, proxy, info->store);
 	call = dbus_g_proxy_begin_call (proxy, "addNetwork",
@@ -1306,7 +1334,7 @@ scan_request_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            G_TYPE_UINT, &success,
 	                            G_TYPE_INVALID)) {
-		nm_warning  ("Could not get scan request result: %s", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Could not get scan request result: %s", err->message);
 		g_error_free (err);
 	} 
 
diff --git a/src/supplicant-manager/nm-supplicant-manager.c b/src/supplicant-manager/nm-supplicant-manager.c
index 7a177ab..a2cf58e 100644
--- a/src/supplicant-manager/nm-supplicant-manager.c
+++ b/src/supplicant-manager/nm-supplicant-manager.c
@@ -27,7 +27,7 @@
 #include "nm-supplicant-interface.h"
 #include "nm-dbus-manager.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-glib-compat.h"
 
 #define SUPPLICANT_POKE_INTERVAL 120
@@ -97,11 +97,11 @@ poke_supplicant_cb (gpointer user_data)
 	                                   WPAS_DBUS_PATH,
 	                                   WPAS_DBUS_INTERFACE);
 	if (!proxy) {
-		nm_warning ("Error: could not init wpa_supplicant proxy");
+		nm_log_warn (LOGD_SUPPLICANT, "Error: could not init wpa_supplicant proxy");
 		goto out;
 	}
 
-	nm_info ("Trying to start the supplicant...");
+	nm_log_info (LOGD_SUPPLICANT, "Trying to start the supplicant...");
 	dbus_g_proxy_call_no_reply (proxy, "getInterface", G_TYPE_STRING, tmp, G_TYPE_INVALID);
 	g_object_unref (proxy);
 
@@ -288,9 +288,12 @@ nm_supplicant_manager_get_iface (NMSupplicantManager * self,
 	}
 
 	if (!iface) {
+		nm_log_dbg (LOGD_SUPPLICANT, "(%s): creating new supplicant interface", ifname);
 		iface = nm_supplicant_interface_new (self, ifname, is_wireless);
 		if (iface)
 			priv->ifaces = g_slist_append (priv->ifaces, iface);
+	} else {
+		nm_log_dbg (LOGD_SUPPLICANT, "(%s): returning existing supplicant interface", ifname);
 	}
 
 	return iface;
diff --git a/src/system-settings/Makefile.am b/src/system-settings/Makefile.am
index baec814..3b616b9 100644
--- a/src/system-settings/Makefile.am
+++ b/src/system-settings/Makefile.am
@@ -2,6 +2,7 @@ INCLUDES = -I${top_srcdir} \
            -I${top_srcdir}/include \
            -I${top_srcdir}/libnm-util \
            -I${top_srcdir}/libnm-glib \
+           -I${top_srcdir}/src/logging \
            -I${top_srcdir}/src \
            -I${top_builddir}/marshallers
 
@@ -44,6 +45,7 @@ libsystem_settings_la_LIBADD = \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(top_builddir)/libnm-glib/libnm-glib.la \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS) \
 	$(GMODULE_LIBS) \
diff --git a/src/system-settings/nm-inotify-helper.c b/src/system-settings/nm-inotify-helper.c
index 589dbd6..0ee168e 100644
--- a/src/system-settings/nm-inotify-helper.c
+++ b/src/system-settings/nm-inotify-helper.c
@@ -25,6 +25,7 @@
 
 #include "nm-marshal.h"
 #include "nm-inotify-helper.h"
+#include "nm-logging.h"
 
 G_DEFINE_TYPE (NMInotifyHelper, nm_inotify_helper, G_TYPE_OBJECT)
 
@@ -122,14 +123,14 @@ init_inotify (NMInotifyHelper *self)
 
 	priv->ifd = inotify_init ();
 	if (priv->ifd == -1) {
-		g_warning ("%s: couldn't initialize inotify", __func__);
+		nm_log_warn (LOGD_SYS_SET, "couldn't initialize inotify");
 		return FALSE;
 	}
 
 	/* Watch the inotify descriptor for file/directory change events */
 	channel = g_io_channel_unix_new (priv->ifd);
 	if (!channel) {
-		g_warning ("%s: couldn't create new GIOChannel", __func__);
+		nm_log_warn (LOGD_SYS_SET, "couldn't create new GIOChannel");
 		close (priv->ifd);
 		priv->ifd = -1;
 		return FALSE;
diff --git a/src/system-settings/nm-sysconfig-connection.c b/src/system-settings/nm-sysconfig-connection.c
index 7d6074c..09cec40 100644
--- a/src/system-settings/nm-sysconfig-connection.c
+++ b/src/system-settings/nm-sysconfig-connection.c
@@ -28,6 +28,7 @@
 #include "nm-settings-connection-interface.h"
 #include "nm-settings-interface.h"
 #include "nm-polkit-helpers.h"
+#include "nm-logging.h"
 
 
 static void settings_connection_interface_init (NMSettingsConnectionInterface *klass);
@@ -613,8 +614,9 @@ nm_sysconfig_connection_init (NMSysconfigConnection *self)
 	NMSysconfigConnectionPrivate *priv = NM_SYSCONFIG_CONNECTION_GET_PRIVATE (self);
 
 	priv->authority = polkit_authority_get ();
-	if (!priv->authority)
-		g_warning ("%s: error creating PolicyKit authority", __func__);
+	if (!priv->authority) {
+		nm_log_err (LOGD_SYS_SET, "%s: error creating PolicyKit authority");
+	}
 }
 
 static void
diff --git a/src/system-settings/nm-sysconfig-settings.c b/src/system-settings/nm-sysconfig-settings.c
index 5336906..4bcfb04 100644
--- a/src/system-settings/nm-sysconfig-settings.c
+++ b/src/system-settings/nm-sysconfig-settings.c
@@ -19,7 +19,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2009 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  * (C) Copyright 2008 Novell, Inc.
  */
 
@@ -57,8 +57,8 @@
 #include "nm-sysconfig-connection.h"
 #include "nm-polkit-helpers.h"
 #include "nm-system-config-error.h"
-#include "nm-utils.h"
 #include "nm-default-wired-connection.h"
+#include "nm-logging.h"
 
 #define CONFIG_KEY_NO_AUTO_DEFAULT "no-auto-default"
 
@@ -357,8 +357,6 @@ add_plugin (NMSysconfigSettings *self, NMSystemConfigInterface *plugin)
 
 	g_signal_connect (plugin, NM_SYSTEM_CONFIG_INTERFACE_CONNECTION_ADDED,
 	                  G_CALLBACK (plugin_connection_added), self);
-	g_signal_connect (plugin, NM_SYSTEM_CONFIG_INTERFACE_UNMANAGED_SPECS_CHANGED,
-	                  G_CALLBACK (unmanaged_specs_changed), self);
 	g_signal_connect (plugin, "notify::hostname", G_CALLBACK (hostname_changed), self);
 
 	nm_system_config_interface_init (plugin, NULL);
@@ -368,7 +366,10 @@ add_plugin (NMSysconfigSettings *self, NMSystemConfigInterface *plugin)
 	              NM_SYSTEM_CONFIG_INTERFACE_INFO, &pinfo,
 	              NULL);
 
-	g_message ("Loaded plugin %s: %s", pname, pinfo);
+	g_signal_connect (plugin, NM_SYSTEM_CONFIG_INTERFACE_UNMANAGED_SPECS_CHANGED,
+	                  G_CALLBACK (unmanaged_specs_changed), self);
+
+	nm_log_info (LOGD_SYS_SET, "Loaded plugin %s: %s", pname, pinfo);
 	g_free (pname);
 	g_free (pinfo);
 }
@@ -859,11 +860,11 @@ permission_call_done (GObject *object, GAsyncResult *result, gpointer user_data)
 	                                                         &error);
 	/* Some random error happened */
 	if (error) {
-		g_warning ("%s.%d (%s): error checking '%s' permission: (%d) %s",
-		           __FILE__, __LINE__, __func__,
-		           call->pk_action,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
+		nm_log_err (LOGD_SYS_SET, "error checking '%s' permission: (%d) %s",
+		            __FILE__, __LINE__, __func__,
+		            call->pk_action,
+		            error ? error->code : -1,
+		            error && error->message ? error->message : "(unknown)");
 		if (error)
 			g_error_free (error);
 	} else {
@@ -1064,7 +1065,7 @@ is_mac_auto_wired_blacklisted (NMSysconfigSettings *self, const GByteArray *mac)
 
 	config = g_key_file_new ();
 	if (!config) {
-		g_warning ("%s: not enough memory to load config file.", __func__);
+		nm_log_warn (LOGD_SYS_SET, "not enough memory to load config file.");
 		return FALSE;
 	}
 
@@ -1216,14 +1217,14 @@ default_wired_try_update (NMDefaultWiredConnection *wired,
 		g_object_set_data (G_OBJECT (nm_default_wired_connection_get_device (wired)),
 		                   DEFAULT_WIRED_TAG,
 		                   NULL);
-		g_message ("Saved default wired connection '%s' to persistent storage", id);
+		nm_log_info (LOGD_SYS_SET, "Saved default wired connection '%s' to persistent storage", id);
 		return FALSE;
 	}
 
-	g_warning ("%s: couldn't save default wired connection '%s': %d / %s",
-	           __func__, id,
-	           error ? error->code : -1,
-	           (error && error->message) ? error->message : "(unknown)");
+	nm_log_warn (LOGD_SYS_SET, "couldn't save default wired connection '%s': %d / %s",
+	             id,
+	             error ? error->code : -1,
+	             (error && error->message) ? error->message : "(unknown)");
 
 	/* If there was an error, don't destroy the default wired connection,
 	 * but add it back to the system settings service. Connection is already
@@ -1275,7 +1276,8 @@ nm_sysconfig_settings_device_added (NMSysconfigSettings *self, NMDevice *device)
 	id = nm_setting_connection_get_id (s_con);
 	g_assert (id);
 
-	g_message ("Added default wired connection '%s' for %s", id, nm_device_get_udi (device));
+	nm_log_info (LOGD_SYS_SET, "Added default wired connection '%s' for %s",
+	             id, nm_device_get_udi (device));
 
 	g_signal_connect (wired, "try-update", (GCallback) default_wired_try_update, self);
 	g_signal_connect (wired, "deleted", (GCallback) default_wired_deleted, self);
@@ -1327,6 +1329,7 @@ nm_sysconfig_settings_new (const char *config_file,
 			g_object_unref (self);
 			return NULL;
 		}
+		unmanaged_specs_changed (NULL, self);
 	}
 
 	return self;
@@ -1474,7 +1477,12 @@ nm_sysconfig_settings_class_init (NMSysconfigSettingsClass *class)
 	                              NM_DBUS_IFACE_SETTINGS_SYSTEM,
 	                              NM_TYPE_SYSCONFIG_SETTINGS_ERROR);
 
+	dbus_g_error_domain_register (NM_SETTINGS_INTERFACE_ERROR,
+	                              NM_DBUS_IFACE_SETTINGS,
+	                              NM_TYPE_SETTINGS_INTERFACE_ERROR);
+
 	/* And register all the settings errors with D-Bus */
+	dbus_g_error_domain_register (NM_CONNECTION_ERROR, NULL, NM_TYPE_CONNECTION_ERROR);
 	dbus_g_error_domain_register (NM_SETTING_802_1X_ERROR, NULL, NM_TYPE_SETTING_802_1X_ERROR);
 	dbus_g_error_domain_register (NM_SETTING_BLUETOOTH_ERROR, NULL, NM_TYPE_SETTING_BLUETOOTH_ERROR);
 	dbus_g_error_domain_register (NM_SETTING_CDMA_ERROR, NULL, NM_TYPE_SETTING_CDMA_ERROR);
@@ -1507,6 +1515,6 @@ nm_sysconfig_settings_init (NMSysconfigSettings *self)
 		                                          G_CALLBACK (pk_authority_changed_cb),
 		                                          self);
 	} else
-		g_warning ("%s: failed to create PolicyKit authority.", __func__);
+		nm_log_warn (LOGD_SYS_SET, "failed to create PolicyKit authority.");
 }
 
diff --git a/src/tests/Makefile.am b/src/tests/Makefile.am
index 398042c..39a994c 100644
--- a/src/tests/Makefile.am
+++ b/src/tests/Makefile.am
@@ -6,14 +6,18 @@ INCLUDES = \
 	-I$(top_srcdir)/src \
 	-I$(top_builddir)/src
 
-noinst_PROGRAMS = test-dhcp-options
+noinst_PROGRAMS = test-dhcp-options test-policy-hosts
+
+####### DHCP options test #######
 
 test_dhcp_options_SOURCES = \
 	test-dhcp-options.c
 
 test_dhcp_options_CPPFLAGS = \
 	$(GLIB_CFLAGS) \
-	$(DBUS_CFLAGS)
+	$(DBUS_CFLAGS) \
+	-DDHCLIENT_PATH=\"$(DHCLIENT_PATH)\" \
+	-DDHCPCD_PATH=\"$(DHCPCD_PATH)\"
 
 test_dhcp_options_LDADD = \
 	$(top_builddir)/libnm-util/libnm-util.la \
@@ -22,10 +26,23 @@ test_dhcp_options_LDADD = \
 	$(GLIB_LIBS) \
 	$(DBUS_LIBS)
 
+####### policy /etc/hosts test #######
+
+test_policy_hosts_SOURCES = \
+	test-policy-hosts.c
+
+test_policy_hosts_CPPFLAGS = \
+	$(GLIB_CFLAGS)
+
+test_policy_hosts_LDADD = \
+	$(top_builddir)/src/libtest-policy-hosts.la \
+	$(GLIB_LIBS)
+
 if WITH_TESTS
 
 check-local: test-dhcp-options
 	$(abs_builddir)/test-dhcp-options
+	$(abs_builddir)/test-policy-hosts
 
 endif
 
diff --git a/src/tests/test-dhcp-options.c b/src/tests/test-dhcp-options.c
index 90828d9..dd1f914 100644
--- a/src/tests/test-dhcp-options.c
+++ b/src/tests/test-dhcp-options.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  *
  */
 
@@ -35,15 +35,43 @@ typedef struct {
 	const char *value;
 } Option;
 
+static void
+destroy_gvalue (gpointer data)
+{
+	GValue *value = (GValue *) data;
+
+	g_value_unset (value);
+	g_slice_free (GValue, value);
+}
+
+static GValue *
+string_to_byte_array_gvalue (const char *str)
+{
+	GByteArray *array;
+	GValue *val;
+
+	array = g_byte_array_sized_new (strlen (str));
+	g_byte_array_append (array, (const guint8 *) str, strlen (str));
+
+	val = g_slice_new0 (GValue);
+	g_value_init (val, DBUS_TYPE_G_UCHAR_ARRAY);
+	g_value_take_boxed (val, array);
+
+	return val;
+}
+
 static GHashTable *
 fill_table (Option *test_options, GHashTable *table)
 {
 	Option *opt;
 
 	if (!table)
-		table = g_hash_table_new (g_str_hash, g_str_equal);
-	for (opt = test_options; opt->name; opt++)
-		g_hash_table_insert (table, (gpointer) opt->name, (gpointer) opt->value);
+		table = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, destroy_gvalue);
+	for (opt = test_options; opt->name; opt++) {
+		g_hash_table_insert (table,
+		                     (gpointer) opt->name,
+		                     string_to_byte_array_gvalue (opt->value));
+	}
 	return table;
 }
 
@@ -69,7 +97,7 @@ static Option generic_options[] = {
 };
 
 static void
-test_generic_options (void)
+test_generic_options (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -88,7 +116,7 @@ test_generic_options (void)
 	const char *expected_route2_gw = "10.1.1.1";
 
 	options = fill_table (generic_options, NULL);
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-generic", "failed to parse DHCP4 options");
 
@@ -187,7 +215,7 @@ static Option wins_options[] = {
 };
 
 static void
-test_wins_options (void)
+test_wins_options (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -199,7 +227,7 @@ test_wins_options (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (wins_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-wins", "failed to parse DHCP4 options");
 
@@ -231,7 +259,7 @@ static Option classless_routes_options[] = {
 };
 
 static void
-test_classless_static_routes (void)
+test_classless_static_routes (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -245,7 +273,7 @@ test_classless_static_routes (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (classless_routes_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442", "failed to parse DHCP4 options");
 
@@ -299,7 +327,7 @@ static Option invalid_classless_routes1[] = {
 };
 
 static void
-test_invalid_classless_routes1 (void)
+test_invalid_classless_routes1 (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -311,7 +339,7 @@ test_invalid_classless_routes1 (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_classless_routes1, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-invalid-1", "failed to parse DHCP4 options");
 
@@ -348,7 +376,7 @@ static Option invalid_classless_routes2[] = {
 };
 
 static void
-test_invalid_classless_routes2 (void)
+test_invalid_classless_routes2 (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -362,7 +390,7 @@ test_invalid_classless_routes2 (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_classless_routes2, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-invalid-2", "failed to parse DHCP4 options");
 
@@ -420,7 +448,7 @@ static Option invalid_classless_routes3[] = {
 };
 
 static void
-test_invalid_classless_routes3 (void)
+test_invalid_classless_routes3 (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -432,7 +460,7 @@ test_invalid_classless_routes3 (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_classless_routes3, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-invalid-3", "failed to parse DHCP4 options");
 
@@ -469,7 +497,7 @@ static Option gw_in_classless_routes[] = {
 };
 
 static void
-test_gateway_in_classless_routes (void)
+test_gateway_in_classless_routes (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -483,7 +511,7 @@ test_gateway_in_classless_routes (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (gw_in_classless_routes, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-gateway", "failed to parse DHCP4 options");
 
@@ -526,7 +554,7 @@ static Option escaped_searches_options[] = {
 };
 
 static void
-test_escaped_domain_searches (void)
+test_escaped_domain_searches (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -537,7 +565,7 @@ test_escaped_domain_searches (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (escaped_searches_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-escaped-domain-searches", "failed to parse DHCP4 options");
 
@@ -560,7 +588,7 @@ static Option invalid_escaped_searches_options[] = {
 };
 
 static void
-test_invalid_escaped_domain_searches (void)
+test_invalid_escaped_domain_searches (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -568,7 +596,7 @@ test_invalid_escaped_domain_searches (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_escaped_searches_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-invalid-escaped-domain-searches", "failed to parse DHCP4 options");
 
@@ -579,11 +607,76 @@ test_invalid_escaped_domain_searches (void)
 	g_hash_table_destroy (options);
 }
 
+static void
+test_ip4_missing_prefix (const char *client, const char *ip, guint32 expected_prefix)
+{
+	GHashTable *options;
+	NMIP4Config *ip4_config;
+	NMIP4Address *addr;
+
+	options = fill_table (generic_options, NULL);
+	g_hash_table_insert (options, "new_ip_address", string_to_byte_array_gvalue (ip));
+	g_hash_table_remove (options, "new_subnet_mask");
+
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
+	ASSERT (ip4_config != NULL,
+	        "dhcp-ip4-missing-prefix", "failed to parse DHCP4 options");
+
+	ASSERT (nm_ip4_config_get_num_addresses (ip4_config) == 1,
+	        "dhcp-ip4-missing-prefix", "unexpected number of IP4 addresses (not 1)");
+
+	addr = nm_ip4_config_get_address (ip4_config, 0);
+	ASSERT (addr != NULL,
+	        "dhcp-ip4-missing-prefix", "missing IP4 address #1");
+
+	ASSERT (nm_ip4_address_get_prefix (addr) == expected_prefix,
+	        "dhcp-ip4-missing-prefix", "unexpected IP4 address prefix %d (expected %d)",
+	        nm_ip4_address_get_prefix (addr), expected_prefix);
+
+	g_hash_table_destroy (options);
+}
+
+static void
+test_ip4_prefix_classless (const char *client)
+{
+	GHashTable *options;
+	NMIP4Config *ip4_config;
+	NMIP4Address *addr;
+
+	/* Ensure that the missing-subnet-mask handler doesn't mangle classless
+	 * subnet masks at all.  The handler should trigger only if the server
+	 * doesn't send the subnet mask.
+	 */
+
+	options = fill_table (generic_options, NULL);
+	g_hash_table_insert (options, "new_ip_address", string_to_byte_array_gvalue ("172.16.54.22"));
+	g_hash_table_insert (options, "new_subnet_mask", string_to_byte_array_gvalue ("255.255.252.0"));
+
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
+	ASSERT (ip4_config != NULL,
+	        "dhcp-ip4-prefix-classless", "failed to parse DHCP4 options");
+
+	ASSERT (nm_ip4_config_get_num_addresses (ip4_config) == 1,
+	        "dhcp-ip4-prefix-classless", "unexpected number of IP4 addresses (not 1)");
+
+	addr = nm_ip4_config_get_address (ip4_config, 0);
+	ASSERT (addr != NULL,
+	        "dhcp-ip4-prefix-classless", "missing IP4 address #1");
+
+	ASSERT (nm_ip4_address_get_prefix (addr) == 22,
+	        "dhcp-ip4-prefix-classless", "unexpected IP4 address prefix %d (expected 22)",
+	        nm_ip4_address_get_prefix (addr));
+
+	g_hash_table_destroy (options);
+}
+
 int main (int argc, char **argv)
 {
 	GError *error = NULL;
 	DBusGConnection *bus;
 	char *base;
+	const char *clients[2][2] = { {DHCLIENT_PATH, "dhclient"}, {DHCPCD_PATH, "dhcpcd"} };
+	guint32 i;
 
 	g_type_init ();
 	bus = dbus_g_bus_get (DBUS_BUS_SESSION, NULL);
@@ -592,15 +685,27 @@ int main (int argc, char **argv)
 		FAIL ("nm-utils-init", "failed to initialize libnm-util: %s", error->message);
 
 	/* The tests */
-	test_generic_options ();
-	test_wins_options ();
-	test_classless_static_routes ();
-	test_invalid_classless_routes1 ();
-	test_invalid_classless_routes2 ();
-	test_invalid_classless_routes3 ();
-	test_gateway_in_classless_routes ();
-	test_escaped_domain_searches ();
-	test_invalid_escaped_domain_searches ();
+	for (i = 0; i < 2; i++) {
+		const char *client_path = clients[i][0];
+		const char *client = clients[i][1];
+
+		if (!client_path || !strlen (client_path))
+			continue;
+
+		test_generic_options (client);
+		test_wins_options (client);
+		test_classless_static_routes (client);
+		test_invalid_classless_routes1 (client);
+		test_invalid_classless_routes2 (client);
+		test_invalid_classless_routes3 (client);
+		test_gateway_in_classless_routes (client);
+		test_escaped_domain_searches (client);
+		test_invalid_escaped_domain_searches (client);
+		test_ip4_missing_prefix (client, "192.168.1.10", 24);
+		test_ip4_missing_prefix (client, "172.16.54.50", 16);
+		test_ip4_missing_prefix (client, "10.1.2.3", 8);
+		test_ip4_prefix_classless (client);
+	}
 
 	base = g_path_get_basename (argv[0]);
 	fprintf (stdout, "%s: SUCCESS\n", base);
diff --git a/src/tests/test-policy-hosts.c b/src/tests/test-policy-hosts.c
new file mode 100644
index 0000000..e14f15e
--- /dev/null
+++ b/src/tests/test-policy-hosts.c
@@ -0,0 +1,394 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ */
+
+#include <glib.h>
+#include <string.h>
+
+#include "nm-policy-hosts.h"
+
+#define FALLBACK_HOSTNAME "localhost.localdomain"
+
+static void
+test_generic (const char *before,
+              const char *after,
+              const char *hostname,
+              gboolean expect_error)
+{
+	char **lines;
+	GString *newc;
+	GError *error = NULL;
+
+	/* Get the new /etc/hosts contents */
+	lines = g_strsplit_set (before, "\n\r", 0);
+	newc = nm_policy_get_etc_hosts ((const char **) lines,
+	                                strlen (before),
+	                                hostname,
+	                                FALLBACK_HOSTNAME,
+	                                &error);
+	g_strfreev (lines);
+
+	if (expect_error) {
+		g_assert (newc == NULL);
+		g_assert (error != NULL);
+		g_clear_error (&error);
+	} else if (after == NULL) {
+		/* No change to /etc/hosts required */
+		g_assert (newc == NULL);
+		g_assert (error == NULL);
+	} else {
+		g_assert (newc != NULL);
+		g_assert (error == NULL);
+
+#if 0
+		g_message ("\n--------------------------------------\n"
+		           "%s"
+		           "--------------------------------------",
+		           newc->str);
+#endif
+		g_assert (strlen (newc->str) == strlen (after));
+		g_assert (strcmp (newc->str, after) == 0);
+		g_string_free (newc, TRUE);
+	}
+}
+
+/*******************************************/
+
+static const char *generic_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic (void)
+{
+	test_generic (generic_before, NULL, "localhost.localdomain", FALSE);
+}
+
+/*******************************************/
+
+static const char *generic_no_boilerplate_before = \
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic_no_boilerplate (void)
+{
+	test_generic (generic_no_boilerplate_before, NULL, "localhost.localdomain", FALSE);
+}
+
+/*******************************************/
+
+static const char *generic_no_boilerplate_no_lh_before = \
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static const char *generic_no_boilerplate_no_lh_after = \
+	"127.0.0.1	localhost\n"
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic_no_boilerplate_no_lh (void)
+{
+	test_generic (generic_no_boilerplate_no_lh_before,
+	              generic_no_boilerplate_no_lh_after,
+	              "localhost.localdomain",
+	              FALSE);
+}
+
+/*******************************************/
+
+
+static const char *generic_no_boilerplate_no_lh_no_host_before = \
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static const char *generic_no_boilerplate_no_lh_no_host_after = \
+	"127.0.0.1	comet	localhost.localdomain	localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic_no_boilerplate_no_lh_no_host (void)
+{
+	test_generic (generic_no_boilerplate_no_lh_no_host_before,
+	              generic_no_boilerplate_no_lh_no_host_after,
+	              "comet",
+	              FALSE);
+}
+
+/*******************************************/
+static const char *named_generic_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	playboy localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_named_generic (void)
+{
+	test_generic (named_generic_before, NULL, "playboy", FALSE);
+}
+
+/*******************************************/
+
+static const char *named_non127_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n";
+
+static void
+test_hosts_named_non127 (void)
+{
+	test_generic (named_non127_before, NULL, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *named2_non127_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n";
+
+static void
+test_hosts_named2_non127 (void)
+{
+	test_generic (named2_non127_before, NULL, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *named_no_lh_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n";
+
+static const char *named_no_lh_after = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain	localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n";
+
+static void
+test_hosts_named_no_localhost (void)
+{
+	test_generic (named_no_lh_before, named_no_lh_after, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *no_lh_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	tomcat\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static const char *no_lh_after = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain	localhost\n"
+	"127.0.0.1	tomcat\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_no_localhost (void)
+{
+	test_generic (no_lh_before, no_lh_after, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *named_last_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 sparcbook.ausil.us\n"
+	"::1         localhost localhost.localdomain localhost6 localhost6.localdomain6 sparcbook.ausil.us\n";
+
+static void
+test_hosts_named_last (void)
+{
+	test_generic (named_last_before, NULL, "sparcbook.ausil.us", FALSE);
+}
+
+/*******************************************/
+
+static const char *no_host_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n"
+	"127.0.0.1	a.tribalfusion.com\n";
+
+static const char *no_host_after = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	comet	localhost.localdomain	localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n"
+	"127.0.0.1	a.tribalfusion.com\n";
+
+static void
+test_hosts_no_host (void)
+{
+	test_generic (no_host_before, no_host_after, "comet", FALSE);
+}
+
+/*******************************************/
+
+static const char *long_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain	localhost	comet\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	adserver.adtech.de\n"
+	"127.0.0.1	a.as-us.falkag.net\n"
+	"127.0.0.1	a.as-eu.falkag.net\n"
+	"127.0.0.1	ads.doubleclick.com\n"
+	"\n"
+	"# random comment\n"
+	"127.0.0.1	m1.2mdn.net\n"
+	"127.0.0.1	ds.serving-sys.com\n"
+	"127.0.0.1	pagead2.googlesyndication.com\n"
+	"127.0.0.1	ad.doubleclick.com\n"
+	"127.0.0.1	ad.doubleclick.net\n"
+	"127.0.0.1	oascentral.movietickets.com\n"
+	"127.0.0.1	view.atdmt.com\n"
+	"127.0.0.1	ads.chumcity.com\n"
+	"127.0.0.1	ads.as4x.tmcs.net\n"
+	"127.0.0.1	n4403ad.doubleclick.net\n"
+	"127.0.0.1	www.assoc-amazon.com\n"
+	"127.0.0.1	s25.sitemeter.com\n"
+	"127.0.0.1	adlog.com.com\n"
+	"127.0.0.1	ahs.laptopmag.com\n"
+	"127.0.0.1	altfarm.mediaplex.com\n"
+	"127.0.0.1	ads.addynamix.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n"
+	"127.0.0.1	a.tribalfusion.com\n";
+
+
+static void
+test_hosts_long (void)
+{
+	test_generic (long_before, NULL, "comet", FALSE);
+}
+
+/*******************************************/
+
+typedef struct {
+	const char *line;
+	const char *token;
+	gboolean expected;
+} Foo;
+
+static Foo foo[] = {
+	/* Using \t here to easily differentiate tabs vs. spaces for testing */
+	{ "127.0.0.1\tfoobar\tblah", "blah", TRUE },
+	{ "", "blah", FALSE },
+	{ "1.1.1.1\tbork\tfoo", "blah", FALSE },
+	{ "127.0.0.1 foobar\tblah", "blah", TRUE },
+	{ "127.0.0.1 foobar blah", "blah", TRUE },
+	{ "127.0.0.1 localhost", "localhost.localdomain", FALSE },
+	{ "192.168.1.1 blah borkbork", "blah", TRUE },
+	{ "192.168.1.1 foobar\tblah borkbork", "blah", TRUE },
+	{ "192.168.1.1\tfoobar\tblah\tborkbork", "blah", TRUE },
+	{ "192.168.1.1 \tfoobar \tblah \tborkbork\t ", "blah", TRUE },
+	{ "\t\t\t\t   \t\t\tasdfadf  a\t\t\t\t\t   \t\t\t\t\t ", "blah", FALSE },
+	{ NULL, NULL, FALSE }
+};
+
+static void
+test_find_token (void)
+{
+	Foo *iter = &foo[0];
+
+	while (iter->line) {
+		gboolean found;
+
+		found = nm_policy_hosts_find_token (iter->line, iter->token);
+		if (found != iter->expected) {
+			g_warning ("find-token: unexpected token result %d for '%s' <= '%s' (expected %d)",
+			           found, iter->line, iter->token, iter->expected);
+		}
+		g_assert (found == iter->expected);
+		iter++;
+	}
+}
+
+typedef void (*TCFunc)(void);
+
+#define TESTCASE(t, d) g_test_create_case (#t, 0, d, NULL, (TCFunc) t, NULL)
+
+int main (int argc, char **argv)
+{
+	GTestSuite *suite;
+
+	g_test_init (&argc, &argv, NULL);
+
+	suite = g_test_get_root ();
+
+	g_test_suite_add (suite, TESTCASE (test_find_token, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic_no_boilerplate, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic_no_boilerplate_no_lh, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic_no_boilerplate_no_lh_no_host, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_generic, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_non127, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named2_non127, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_no_localhost, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_no_localhost, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_last, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_no_host, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_long, NULL));
+
+	return g_test_run ();
+}
+
diff --git a/src/vpn-manager/Makefile.am b/src/vpn-manager/Makefile.am
index 1078603..56e4a4c 100644
--- a/src/vpn-manager/Makefile.am
+++ b/src/vpn-manager/Makefile.am
@@ -2,6 +2,7 @@ INCLUDES = \
 	-I${top_srcdir} \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/src \
 	-I${top_builddir}/marshallers \
 	-I${top_srcdir}/src/named-manager \
@@ -25,6 +26,7 @@ libvpn_manager_la_CPPFLAGS =	\
 
 libvpn_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
diff --git a/src/vpn-manager/nm-vpn-connection.c b/src/vpn-manager/nm-vpn-connection.c
index f8360dc..01f639a 100644
--- a/src/vpn-manager/nm-vpn-connection.c
+++ b/src/vpn-manager/nm-vpn-connection.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2009 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -35,7 +35,8 @@
 #include "nm-setting-ip4-config.h"
 #include "nm-dbus-manager.h"
 #include "nm-manager.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
+#include "nm-logging.h"
 #include "nm-utils.h"
 #include "nm-vpn-plugin-bindings.h"
 #include "nm-marshal.h"
@@ -269,7 +270,7 @@ plugin_failed (DBusGProxy *proxy,
 {
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (user_data);
 
-	nm_info ("VPN plugin failed: %d", plugin_failure);
+	nm_log_warn (LOGD_VPN, "VPN plugin failed: %d", plugin_failure);
 
 	switch (plugin_failure) {
 	case NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED:
@@ -291,7 +292,7 @@ plugin_state_changed (DBusGProxy *proxy,
 	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
 
-	nm_info ("VPN plugin state changed: %d", state);
+	nm_log_info (LOGD_VPN, "VPN plugin state changed: %d", state);
 
 	if (state == NM_VPN_SERVICE_STATE_STOPPED) {
 		/* Clear connection secrets to ensure secrets get requested each time the
@@ -305,7 +306,7 @@ plugin_state_changed (DBusGProxy *proxy,
 		case NM_VPN_CONNECTION_STATE_CONNECT:
 		case NM_VPN_CONNECTION_STATE_IP_CONFIG_GET:
 		case NM_VPN_CONNECTION_STATE_ACTIVATED:
-			nm_info ("VPN plugin state change reason: %d", priv->failure_reason);
+			nm_log_info (LOGD_VPN, "VPN plugin state change reason: %d", priv->failure_reason);
 			nm_vpn_connection_set_vpn_state (connection,
 			                                 NM_VPN_CONNECTION_STATE_FAILED,
 											 priv->failure_reason);
@@ -331,8 +332,8 @@ ip_address_to_string (guint32 numeric)
 	if (inet_ntop (AF_INET, &temp_addr, buf, INET_ADDRSTRLEN)) {
 		return buf;
 	} else {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (temp_addr.s_addr));
+		nm_log_warn (LOGD_VPN, "error converting IP4 address 0x%X",
+		             ntohl (temp_addr.s_addr));
 		return NULL;
 	}
 }
@@ -351,38 +352,44 @@ print_vpn_config (NMIP4Config *config,
 
 	addr = nm_ip4_config_get_address (config, 0);
 
-	nm_info ("VPN Gateway: %s", ip_address_to_string (nm_ip4_address_get_gateway (addr)));
+	nm_log_info (LOGD_VPN, "VPN Gateway: %s", ip_address_to_string (nm_ip4_address_get_gateway (addr)));
 	if (internal_gw)
-		nm_info ("Internal Gateway: %s", ip_address_to_string (internal_gw));
-	nm_info ("Tunnel Device: %s", tundev);
-	nm_info ("Internal IP4 Address: %s", ip_address_to_string (nm_ip4_address_get_address (addr)));
-	nm_info ("Internal IP4 Prefix: %d", nm_ip4_address_get_prefix (addr));
-	nm_info ("Internal IP4 Point-to-Point Address: %s",
-		    ip_address_to_string (nm_ip4_config_get_ptp_address (config)));
-	nm_info ("Maximum Segment Size (MSS): %d", nm_ip4_config_get_mss (config));
+		nm_log_info (LOGD_VPN, "Internal Gateway: %s", ip_address_to_string (internal_gw));
+	nm_log_info (LOGD_VPN, "Tunnel Device: %s", tundev);
+	nm_log_info (LOGD_VPN, "Internal IP4 Address: %s", ip_address_to_string (nm_ip4_address_get_address (addr)));
+	nm_log_info (LOGD_VPN, "Internal IP4 Prefix: %d", nm_ip4_address_get_prefix (addr));
+	nm_log_info (LOGD_VPN, "Internal IP4 Point-to-Point Address: %s",
+	             ip_address_to_string (nm_ip4_config_get_ptp_address (config)));
+	nm_log_info (LOGD_VPN, "Maximum Segment Size (MSS): %d", nm_ip4_config_get_mss (config));
 
 	num = nm_ip4_config_get_num_routes (config);
 	for (i = 0; i < num; i++) {
 		NMIP4Route *route;
 
 		route = nm_ip4_config_get_route (config, i);
-		nm_info ("Static Route: %s/%d   Next Hop: %s",
-			    ip_address_to_string (nm_ip4_route_get_dest (route)),
-			    nm_ip4_route_get_prefix (route),
-			    ip_address_to_string (nm_ip4_route_get_next_hop (route)));
+		nm_log_info (LOGD_VPN, "Static Route: %s/%d   Next Hop: %s",
+		             ip_address_to_string (nm_ip4_route_get_dest (route)),
+		             nm_ip4_route_get_prefix (route),
+		             ip_address_to_string (nm_ip4_route_get_next_hop (route)));
 	}
 
 	num = nm_ip4_config_get_num_nameservers (config);
-	for (i = 0; i < num; i++)
-		nm_info ("Internal IP4 DNS: %s", ip_address_to_string (nm_ip4_config_get_nameserver (config, i)));
+	for (i = 0; i < num; i++) {
+		nm_log_info (LOGD_VPN, "Internal IP4 DNS: %s",
+		             ip_address_to_string (nm_ip4_config_get_nameserver (config, i)));
+	}
 
 	if (nm_ip4_config_get_num_domains (config) > 0)
 		dns_domain = (char *) nm_ip4_config_get_domain (config, 0);
-	nm_info ("DNS Domain: '%s'", dns_domain ? dns_domain : "(none)");
-	nm_info ("Login Banner:");
-	nm_info ("-----------------------------------------");
-	nm_info ("%s", banner);
-	nm_info ("-----------------------------------------");
+
+	nm_log_info (LOGD_VPN, "DNS Domain: '%s'", dns_domain ? dns_domain : "(none)");
+
+	if (banner && strlen (banner)) {
+		nm_log_info (LOGD_VPN, "Login Banner:");
+		nm_log_info (LOGD_VPN, "-----------------------------------------");
+		nm_log_info (LOGD_VPN, "%s", banner);
+		nm_log_info (LOGD_VPN, "-----------------------------------------");
+	}
 }
 
 static void
@@ -399,8 +406,8 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	int i;
 	guint32 vpn_ext_gw = 0;
 
-	nm_info ("VPN connection '%s' (IP Config Get) reply received.",
-		    nm_vpn_connection_get_name (connection));
+	nm_log_info (LOGD_VPN, "VPN connection '%s' (IP Config Get) reply received.",
+	             nm_vpn_connection_get_name (connection));
 
 	g_source_remove (priv->ipconfig_timeout);
 	priv->ipconfig_timeout = 0;
@@ -411,7 +418,7 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	if (val)
 		priv->tundev = g_strdup (g_value_get_string (val));
 	else {
-		nm_warning ("%s: invalid or missing tunnel device received!", __func__);
+		nm_log_err (LOGD_VPN, "invalid or missing tunnel device received!");
 		goto error;
 	}
 
@@ -445,7 +452,7 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	if (nm_ip4_address_get_address (addr) && nm_ip4_address_get_prefix (addr)) {
 		nm_ip4_config_take_address (config, addr);
 	} else {
-		nm_warning ("%s: invalid IP4 config received!", __func__);
+		nm_log_err (LOGD_VPN, "invalid IP4 config received!");
 		nm_ip4_address_unref (addr);
 		goto error;
 	}
@@ -532,8 +539,8 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 
 		priv->ip4_config = config;
 
-		nm_info ("VPN connection '%s' (IP Config Get) complete.",
-			    nm_vpn_connection_get_name (connection));
+		nm_log_info (LOGD_VPN, "VPN connection '%s' (IP Config Get) complete.",
+		             nm_vpn_connection_get_name (connection));
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_ACTIVATED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_NONE);
@@ -541,8 +548,8 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	}
 
 error:
-	nm_warning ("VPN connection '%s' did not receive valid IP config information.",
-	            nm_vpn_connection_get_name (connection));
+	nm_log_warn (LOGD_VPN, "VPN connection '%s' did not receive valid IP config information.",
+	             nm_vpn_connection_get_name (connection));
 	nm_vpn_connection_set_vpn_state (connection,
 	                                 NM_VPN_CONNECTION_STATE_FAILED,
 	                                 NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID);
@@ -561,8 +568,8 @@ nm_vpn_connection_ip_config_timeout (gpointer user_data)
 	 * in this timeout, cancel activation because it's taken too long.
 	 */
 	if (nm_vpn_connection_get_vpn_state (connection) == NM_VPN_CONNECTION_STATE_IP_CONFIG_GET) {
-		nm_info ("VPN connection '%s' (IP Config Get) timeout exceeded.",
-		         nm_vpn_connection_get_name (connection));
+		nm_log_warn (LOGD_VPN, "VPN connection '%s' (IP Config Get) timeout exceeded.",
+		             nm_vpn_connection_get_name (connection));
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_FAILED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT);
@@ -577,12 +584,12 @@ nm_vpn_connection_connect_cb (DBusGProxy *proxy, GError *err, gpointer user_data
 	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
 
-	nm_info ("VPN connection '%s' (Connect) reply received.",
-		    nm_vpn_connection_get_name (connection));
+	nm_log_info (LOGD_VPN, "VPN connection '%s' (Connect) reply received.",
+	             nm_vpn_connection_get_name (connection));
 
 	if (err) {
-		nm_warning ("VPN connection '%s' failed to connect: '%s'.", 
-				  nm_vpn_connection_get_name (connection), err->message);
+		nm_log_warn (LOGD_VPN, "VPN connection '%s' failed to connect: '%s'.", 
+		             nm_vpn_connection_get_name (connection), err->message);
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_FAILED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED);
@@ -777,9 +784,9 @@ secrets_update_setting (NMSecretsProviderInterface *interface,
 		return FALSE;
 
 	if (!nm_connection_update_secrets (priv->connection, NM_SETTING_VPN_SETTING_NAME, new, &error)) {
-		nm_warning ("Failed to update VPN secrets: %d %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(none)");
+		nm_log_warn (LOGD_VPN, "Failed to update VPN secrets: %d %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(none)");
 		g_clear_error (&error);
 		return FALSE;
 	}
@@ -823,9 +830,9 @@ connection_need_secrets_cb  (DBusGProxy *proxy,
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (self);
 
 	if (error) {
-		g_warning ("%s.%d: NeedSecrets failed: %s %s",
-		           __FILE__, __LINE__,
-		           g_quark_to_string (error->domain), error->message);
+		nm_log_err (LOGD_VPN, "NeedSecrets failed: %s %s",
+		            g_quark_to_string (error->domain),
+		            error->message);
 		nm_vpn_connection_fail (self, NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS);
 		return;
 	}
@@ -893,7 +900,7 @@ vpn_cleanup (NMVPNConnection *connection)
 			                                 nm_device_get_ip4_config (priv->parent_dev),
 			                                 nm_device_get_priority (priv->parent_dev),
 			                                 NM_IP4_COMPARE_FLAG_ADDRESSES | NM_IP4_COMPARE_FLAG_ROUTES)) {
-				nm_warning ("%s: failed to re-apply VPN parent device addresses and routes.", __func__);
+				nm_log_err (LOGD_VPN, "failed to re-apply VPN parent device addresses and routes.");
 			}
 		}
 	}
@@ -940,7 +947,7 @@ connection_state_changed (NMVPNConnection *connection,
 
 			org_freedesktop_NetworkManager_VPN_Plugin_disconnect (priv->proxy, &err);
 			if (err) {
-				nm_warning ("%s", err->message);
+				nm_log_warn (LOGD_VPN, "error disconnecting VPN: %s", err->message);
 				g_error_free (err);
 			}
 
diff --git a/src/vpn-manager/nm-vpn-manager.c b/src/vpn-manager/nm-vpn-manager.c
index e8fa24c..221a8b5 100644
--- a/src/vpn-manager/nm-vpn-manager.c
+++ b/src/vpn-manager/nm-vpn-manager.c
@@ -27,7 +27,6 @@
 #include "nm-setting-vpn.h"
 #include "nm-dbus-manager.h"
 #include "NetworkManagerVPN.h"
-#include "nm-utils.h"
 #include "nm-marshal.h"
 
 G_DEFINE_TYPE (NMVPNManager, nm_vpn_manager, G_TYPE_OBJECT)
diff --git a/src/vpn-manager/nm-vpn-service.c b/src/vpn-manager/nm-vpn-service.c
index 15aa56d..bdbb377 100644
--- a/src/vpn-manager/nm-vpn-service.c
+++ b/src/vpn-manager/nm-vpn-service.c
@@ -29,7 +29,7 @@
 
 #include "nm-vpn-service.h"
 #include "nm-dbus-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-vpn-manager.h"
 #include "nm-glib-compat.h"
 
@@ -198,18 +198,20 @@ vpn_service_watch_cb (GPid pid, gint status, gpointer user_data)
 	if (WIFEXITED (status)) {
 		guint err = WEXITSTATUS (status);
 
-		if (err != 0)
-			nm_warning ("VPN service '%s' exited with error: %d",
-					  nm_vpn_service_get_name (service), WSTOPSIG (status));
-	} else if (WIFSTOPPED (status))
-		nm_warning ("VPN service '%s' stopped unexpectedly with signal %d",
-				  nm_vpn_service_get_name (service), WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		nm_warning ("VPN service '%s' died with signal %d",
-				  nm_vpn_service_get_name (service), WTERMSIG (status));
-	else
-		nm_warning ("VPN service '%s' died from an unknown cause", 
-				  nm_vpn_service_get_name (service));
+		if (err != 0) {
+			nm_log_warn (LOGD_VPN, "VPN service '%s' exited with error: %d",
+			             nm_vpn_service_get_name (service), WSTOPSIG (status));
+		}
+	} else if (WIFSTOPPED (status)) {
+		nm_log_warn (LOGD_VPN, "VPN service '%s' stopped unexpectedly with signal %d",
+		             nm_vpn_service_get_name (service), WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_warn (LOGD_VPN, "VPN service '%s' died with signal %d",
+		             nm_vpn_service_get_name (service), WTERMSIG (status));
+	} else {
+		nm_log_warn (LOGD_VPN, "VPN service '%s' died from an unknown cause", 
+		             nm_vpn_service_get_name (service));
+	}
 
 	priv->pid = 0;
 	priv->service_child_watch = 0;
@@ -222,8 +224,8 @@ nm_vpn_service_timeout (gpointer data)
 {
 	NMVPNService *service = NM_VPN_SERVICE (data);
 
-	nm_info ("VPN service '%s' did not start in time, cancelling connections",
-		    nm_vpn_service_get_name (service));
+	nm_log_warn (LOGD_VPN, "VPN service '%s' did not start in time, cancelling connections",
+	             nm_vpn_service_get_name (service));
 
 	NM_VPN_SERVICE_GET_PRIVATE (service)->service_start_timeout = 0;
 	nm_vpn_service_connections_stop (service, TRUE, NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT);
@@ -250,14 +252,14 @@ nm_vpn_service_daemon_exec (NMVPNService *service, GError **error)
 	                         nm_vpn_service_child_setup, NULL, &priv->pid,
 	                         &spawn_error);
 	if (success) {
-		nm_info ("VPN service '%s' started (%s), PID %d", 
-		         nm_vpn_service_get_name (service), priv->dbus_service, priv->pid);
+		nm_log_info (LOGD_VPN, "VPN service '%s' started (%s), PID %d", 
+		             nm_vpn_service_get_name (service), priv->dbus_service, priv->pid);
 
 		priv->service_child_watch = g_child_watch_add (priv->pid, vpn_service_watch_cb, service);
 		priv->service_start_timeout = g_timeout_add_seconds (5, nm_vpn_service_timeout, service);
 	} else {
-		nm_warning ("VPN service '%s': could not launch the VPN service. error: (%d) %s.",
-		            nm_vpn_service_get_name (service), spawn_error->code, spawn_error->message);
+		nm_log_warn (LOGD_VPN, "VPN service '%s': could not launch the VPN service. error: (%d) %s.",
+		             nm_vpn_service_get_name (service), spawn_error->code, spawn_error->message);
 
 		g_set_error (error,
 		             NM_VPN_MANAGER_ERROR, NM_VPN_MANAGER_ERROR_SERVICE_START_FAILED,
@@ -334,7 +336,8 @@ nm_vpn_service_activate (NMVPNService *service,
 		// FIXME: fill in error when errors happen
 		nm_vpn_connection_activate (vpn);
 	} else if (priv->service_start_timeout == 0) {
-		nm_info ("Starting VPN service '%s'...", nm_vpn_service_get_name (service));
+		nm_log_info (LOGD_VPN, "Starting VPN service '%s'...",
+		             nm_vpn_service_get_name (service));
 		if (!nm_vpn_service_daemon_exec (service, error))
 			vpn = NULL;
 	}
@@ -378,16 +381,16 @@ nm_vpn_service_name_owner_changed (NMDBusManager *mgr,
 		/* service just appeared */
 		GSList *iter;
 
-		nm_info ("VPN service '%s' just appeared, activating connections",
-			    nm_vpn_service_get_name (service));
+		nm_log_info (LOGD_VPN, "VPN service '%s' appeared, activating connections",
+		             nm_vpn_service_get_name (service));
 
 		for (iter = priv->connections; iter; iter = iter->next)
 			nm_vpn_connection_activate (NM_VPN_CONNECTION (iter->data));
 
 	} else if (old_owner_good && !new_owner_good) {
 		/* service went away */
-		nm_info ("VPN service '%s' disappeared, cancelling connections",
-			    nm_vpn_service_get_name (service));
+		nm_log_info (LOGD_VPN, "VPN service '%s' disappeared, cancelling connections",
+		             nm_vpn_service_get_name (service));
 		nm_vpn_service_connections_stop (service, TRUE, NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED);
 	}
 }
@@ -415,9 +418,9 @@ ensure_killed (gpointer data)
 		kill (pid, SIGKILL);
 
 	/* ensure the child is reaped */
-	nm_debug ("waiting for vpn service pid %d to exit", pid);
+	nm_log_dbg (LOGD_VPN, "waiting for VPN service pid %d to exit", pid);
 	waitpid (pid, NULL, 0);
-	nm_debug ("vpn service pid %d cleaned up", pid);
+	nm_log_dbg (LOGD_VPN, "VPN service pid %d cleaned up", pid);
 
 	return FALSE;
 }
@@ -446,9 +449,9 @@ finalize (GObject *object)
 			kill (priv->pid, SIGKILL);
 
 			/* ensure the child is reaped */
-			nm_debug ("waiting for vpn service pid %d to exit", priv->pid);
+			nm_log_dbg (LOGD_VPN, "waiting for VPN service pid %d to exit", priv->pid);
 			waitpid (priv->pid, NULL, 0);
-			nm_debug ("vpn service pid %d cleaned up", priv->pid);
+			nm_log_dbg (LOGD_VPN, "VPN service pid %d cleaned up", priv->pid);
 		}
 
 		priv->pid = 0;
diff --git a/src/wpa.c b/src/wpa.c
index 8f50047..5f4fd02 100644
--- a/src/wpa.c
+++ b/src/wpa.c
@@ -1,3 +1,4 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /*
  * WPA Supplicant - WPA state machine and EAPOL-Key processing
  * Copyright (c) 2003-2005, Jouni Malinen <jkmaline@cc.hut.fi>
@@ -19,7 +20,7 @@
 #include <glib.h>
 
 #include "wpa.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 typedef guint16 u16;
 typedef guint8 u8;
@@ -207,8 +208,8 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 	}
 
 	if (wpa_ie_len < sizeof(struct wpa_ie_hdr)) {
-		nm_debug ("%s: ie len too short %lu",
-			   __func__, (unsigned long) wpa_ie_len);
+		nm_log_dbg (LOGD_WIFI, "IE len too short %lu",
+			    (unsigned long) wpa_ie_len);
 		return -1;
 	}
 
@@ -218,8 +219,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 	    hdr->len != wpa_ie_len - 2 ||
 	    memcmp(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN) != 0 ||
 	    WPA_GET_LE16(hdr->version) != WPA_VERSION) {
-		nm_debug ("%s: malformed ie or unknown version",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "malformed IE or unknown version");
 		return -1;
 	}
 
@@ -231,8 +231,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 		pos += WPA_SELECTOR_LEN;
 		left -= WPA_SELECTOR_LEN;
 	} else if (left > 0) {
-		nm_debug ("%s: ie length mismatch, %u too much",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE length mismatch, %u too much", left);
 		return -1;
 	}
 
@@ -242,8 +241,8 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (pairwise), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (pairwise), "
+			            "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -252,8 +251,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 			left -= WPA_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for key mgmt)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for key mgmt)");
 		return -1;
 	}
 
@@ -263,8 +261,8 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (key mgmt), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (key mgmt), "
+				   "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -273,8 +271,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 			left -= WPA_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for capabilities)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for capabilities)");
 		return -1;
 	}
 
@@ -286,8 +283,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 	}
 
 	if (left > 0) {
-		nm_debug ("%s: ie has %u trailing bytes",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE has %u trailing bytes", left);
 		return -1;
 	}
 
@@ -317,8 +313,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 	}
 
 	if (rsn_ie_len < sizeof(struct rsn_ie_hdr)) {
-		nm_debug ("%s: ie len too short %lu",
-			   __func__, (unsigned long) rsn_ie_len);
+		nm_log_dbg (LOGD_WIFI, "IE len too short %lu",
+			    (unsigned long) rsn_ie_len);
 		return -1;
 	}
 
@@ -327,8 +323,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 	if (hdr->elem_id != WPA_RSN_INFO_ELEM ||
 	    hdr->len != rsn_ie_len - 2 ||
 	    WPA_GET_LE16(hdr->version) != RSN_VERSION) {
-		nm_debug ("%s: malformed ie or unknown version",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "malformed IE or unknown version");
 		return -1;
 	}
 
@@ -340,8 +335,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += RSN_SELECTOR_LEN;
 		left -= RSN_SELECTOR_LEN;
 	} else if (left > 0) {
-		nm_debug ("%s: ie length mismatch, %u too much",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE length mismatch, %u too much", left);
 		return -1;
 	}
 
@@ -351,8 +345,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (pairwise), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (pairwise), "
+				    "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -361,8 +355,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 			left -= RSN_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for key mgmt)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for key mgmt)");
 		return -1;
 	}
 
@@ -372,8 +365,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (key mgmt), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (key mgmt), "
+				   "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -382,8 +375,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 			left -= RSN_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for capabilities)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for capabilities)");
 		return -1;
 	}
 
@@ -399,9 +391,9 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += 2;
 		left -= 2;
 		if (left < data->num_pmkid * PMKID_LEN) {
-			nm_debug ("%s: PMKID underflow "
-				   "(num_pmkid=%d left=%d)",
-				   __func__, data->num_pmkid, left);
+			nm_log_dbg (LOGD_WIFI, "PMKID underflow "
+				    "(num_pmkid=%d left=%d)",
+				    data->num_pmkid, left);
 			data->num_pmkid = 0;
 		} else {
 			data->pmkid = pos;
@@ -411,8 +403,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 	}
 
 	if (left > 0) {
-		nm_debug ("%s: ie has %u trailing bytes - ignored",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE has %u trailing bytes - ignored", left);
 	}
 
 	return 0;
@@ -430,8 +421,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
  */
 wpa_ie_data * wpa_parse_wpa_ie(const u8 *wpa_ie, size_t wpa_ie_len)
 {
-	wpa_ie_data *	data = NULL;
-	int			err = -1;
+	wpa_ie_data *data = NULL;
+	int err = -1;
 
 	if (!wpa_ie || wpa_ie_len <= 0)
 		return NULL;
@@ -443,25 +434,21 @@ wpa_ie_data * wpa_parse_wpa_ie(const u8 *wpa_ie, size_t wpa_ie_len)
 	else
 		err = wpa_parse_wpa_ie_wpa(wpa_ie, wpa_ie_len, data);
 
-	if (err != 0)
-	{
+	if (err != 0) {
 		g_slice_free (wpa_ie_data, data);
 		data = NULL;
 	}
 
-#if 0
-	if (data)
-	{
-		nm_debug ("WPA IE: -------------------");
-		nm_debug ("   proto        0x%X", data->proto);
-		nm_debug ("   pw cipher    0x%X", data->pairwise_cipher);
-		nm_debug ("   gr cipher    0x%X", data->group_cipher);
-		nm_debug ("   key mgmt     0x%X", data->key_mgmt);
-		nm_debug ("   capabilities 0x%X", data->capabilities);
-		nm_debug ("   # pmkid      0x%X", data->num_pmkid);
-		nm_debug ("");
+	if (data) {
+		nm_log_dbg (LOGD_WIFI, "WPA IE: -------------------");
+		nm_log_dbg (LOGD_WIFI, "   proto        0x%X", data->proto);
+		nm_log_dbg (LOGD_WIFI, "   pw cipher    0x%X", data->pairwise_cipher);
+		nm_log_dbg (LOGD_WIFI, "   gr cipher    0x%X", data->group_cipher);
+		nm_log_dbg (LOGD_WIFI, "   key mgmt     0x%X", data->key_mgmt);
+		nm_log_dbg (LOGD_WIFI, "   capabilities 0x%X", data->capabilities);
+		nm_log_dbg (LOGD_WIFI, "   # pmkid      0x%X", data->num_pmkid);
+		nm_log_dbg (LOGD_WIFI, "");
 	}
-#endif
 
 	return data;
 }
diff --git a/system-settings/plugins/ifcfg-rh/plugin.c b/system-settings/plugins/ifcfg-rh/plugin.c
index a272728..47ce007 100644
--- a/system-settings/plugins/ifcfg-rh/plugin.c
+++ b/system-settings/plugins/ifcfg-rh/plugin.c
@@ -38,6 +38,7 @@
 #include <dbus/dbus-glib-lowlevel.h>
 
 #include <nm-setting-connection.h>
+#include <nm-settings-interface.h>
 
 #include "common.h"
 #include "nm-dbus-glib-types.h"
@@ -535,31 +536,46 @@ impl_ifcfgrh_get_ifcfg_details (SCPluginIfcfg *plugin,
 	const char *path;
 
 	if (!g_path_is_absolute (in_ifcfg)) {
-		g_set_error (error, 0, 0, "ifcfg path '%s' is not absolute", in_ifcfg);
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INVALID_CONNECTION,
+		             "ifcfg path '%s' is not absolute", in_ifcfg);
 		return FALSE;
 	}
 
 	connection = g_hash_table_lookup (priv->connections, in_ifcfg);
 	if (!connection) {
-		g_set_error (error, 0, 0, "ifcfg file '%s' unknown", in_ifcfg);
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INVALID_CONNECTION,
+		             "ifcfg file '%s' unknown", in_ifcfg);
 		return FALSE;
 	}
 
 	s_con = (NMSettingConnection *) nm_connection_get_setting (NM_CONNECTION (connection), NM_TYPE_SETTING_CONNECTION);
 	if (!s_con) {
-		g_set_error_literal (error, 0, 0, "unable to retrieve the connection setting");
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		             "unable to retrieve the connection setting");
 		return FALSE;
 	}
 
 	uuid = nm_setting_connection_get_uuid (s_con);
 	if (!uuid) {
-		g_set_error_literal (error, 0, 0, "unable to get the UUID");
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		             "unable to get the UUID");
 		return FALSE;
 	}
 	
 	path = nm_connection_get_path (NM_CONNECTION (connection));
 	if (!path) {
-		g_set_error_literal (error, 0, 0, "unable to get the connection D-Bus path");
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		             "unable to get the connection D-Bus path");
 		return FALSE;
 	}
 
diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index afe35bd..4149e6c 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 - 2009 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <stdlib.h>
@@ -606,16 +606,9 @@ read_full_ip4_address (shvarFile *ifcfg,
 
 	/* Try to autodetermine the prefix for the address' class */
 	if (!nm_ip4_address_get_prefix (addr)) {
-		guint32 tmp_addr, prefix = 0;
-
-		tmp_addr = nm_ip4_address_get_address (addr);
-		if (((ntohl(tmp_addr) & 0xFF000000) >> 24) <= 127)
-			prefix = 8;
-		else if (((ntohl(tmp_addr) & 0xFF000000) >> 24) <= 191)
-			prefix = 16;
-		else
-			prefix = 24;
+		guint32 prefix = 0;
 
+		prefix = nm_utils_ip4_get_default_prefix (nm_ip4_address_get_address (addr));
 		nm_ip4_address_set_prefix (addr, prefix);
 
 		value = svGetValue (ifcfg, ip_tag, FALSE);
@@ -1122,6 +1115,7 @@ static NMSetting *
 make_ip4_setting (shvarFile *ifcfg,
                   const char *network_file,
                   const char *iscsiadm_path,
+                  gboolean valid_ip6_config,
                   GError **error)
 {
 	NMSettingIP4Config *s_ip4 = NULL;
@@ -1199,14 +1193,17 @@ make_ip4_setting (shvarFile *ifcfg,
 			g_set_error (error, ifcfg_plugin_error_quark (), 0,
 			             "Unknown BOOTPROTO '%s'", value);
 			g_free (value);
-			goto error;
+			goto done;
 		}
 		g_free (value);
 	} else {
 		char *tmp_ip4, *tmp_prefix, *tmp_netmask;
 
-		/* If there is no BOOTPROTO, no IPADDR, no PREFIX, and no NETMASK,
-		 * assume DHCP is to be used.  Happens with minimal ifcfg files like:
+		/* If there is no BOOTPROTO, no IPADDR, no PREFIX, no NETMASK, but
+		 * valid IPv6 configuration, assume that IPv4 is disabled.  Otherwise,
+		 * if there is no IPv6 configuration, assume DHCP is to be used.
+		 * Happens with minimal ifcfg files like the following that anaconda
+		 * sometimes used to write out:
 		 *
 		 * DEVICE=eth0
 		 * HWADDR=11:22:33:44:55:66
@@ -1215,8 +1212,14 @@ make_ip4_setting (shvarFile *ifcfg,
 		tmp_ip4 = svGetValue (ifcfg, "IPADDR", FALSE);
 		tmp_prefix = svGetValue (ifcfg, "PREFIX", FALSE);
 		tmp_netmask = svGetValue (ifcfg, "NETMASK", FALSE);
-		if (!tmp_ip4 && !tmp_prefix && !tmp_netmask)
+		if (!tmp_ip4 && !tmp_prefix && !tmp_netmask) {
+			if (valid_ip6_config) {
+				/* Nope, no IPv4 */
+				goto done;
+			}
+
 			method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+		}
 		g_free (tmp_ip4);
 		g_free (tmp_prefix);
 		g_free (tmp_netmask);
@@ -1236,7 +1239,7 @@ make_ip4_setting (shvarFile *ifcfg,
 		for (i = 1; i < 256; i++) {
 			addr = read_full_ip4_address (ifcfg, network_file, i, error);
 			if (error && *error)
-				goto error;
+				goto done;
 			if (!addr)
 				break;
 
@@ -1278,7 +1281,7 @@ make_ip4_setting (shvarFile *ifcfg,
 			}
 			if (!tmp_success) {
 				g_free (tag);
-				goto error;
+				goto done;
 			}
 			g_clear_error (error);
 		}
@@ -1312,7 +1315,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	if (!route_path) {
 		g_set_error (error, ifcfg_plugin_error_quark (), 0,
 		             "Could not get route file path for '%s'", ifcfg->fileName);
-		goto error;
+		goto done;
 	}
 
 	/* First test new/legacy syntax */
@@ -1326,7 +1329,7 @@ make_ip4_setting (shvarFile *ifcfg,
 				route = read_one_ip4_route (route_ifcfg, network_file, i, error);
 				if (error && *error) {
 					svCloseFile (route_ifcfg);
-					goto error;
+					goto done;
 				}
 				if (!route)
 					break;
@@ -1341,7 +1344,7 @@ make_ip4_setting (shvarFile *ifcfg,
 		read_route_file_legacy (route_path, s_ip4, error);
 		g_free (route_path);
 		if (error && *error)
-			goto error;
+			goto done;
 	}
 
 	/* Legacy value NM used for a while but is incorrect (rh #459370) */
@@ -1367,7 +1370,7 @@ make_ip4_setting (shvarFile *ifcfg,
 
 	return NM_SETTING (s_ip4);
 
-error:
+done:
 	g_object_unref (s_ip4);
 	return NULL;
 }
@@ -1382,7 +1385,7 @@ make_ip6_setting (shvarFile *ifcfg,
 	char *value = NULL;
 	char *str_value;
 	char *route6_path = NULL;
-	gboolean bool_value, ipv6forwarding, ipv6_autoconf;
+	gboolean bool_value, ipv6forwarding, ipv6_autoconf, dhcp6 = FALSE;
 	char *method = NM_SETTING_IP6_CONFIG_METHOD_MANUAL;
 	guint32 i;
 	shvarFile *network_ifcfg;
@@ -1459,9 +1462,12 @@ make_ip6_setting (shvarFile *ifcfg,
 	/* Find out method property */
 	ipv6forwarding = svTrueValue (ifcfg, "IPV6FORWARDING", FALSE);
 	ipv6_autoconf = svTrueValue (ifcfg, "IPV6_AUTOCONF", !ipv6forwarding);
+	dhcp6 = svTrueValue (ifcfg, "DHCPV6C", FALSE);
 
 	if (ipv6_autoconf)
 		method = NM_SETTING_IP6_CONFIG_METHOD_AUTO;
+	else if (dhcp6)
+		method = NM_SETTING_IP6_CONFIG_METHOD_DHCP;
 	else {
 		/* IPV6_AUTOCONF=no and no IPv6 address -> method 'link-local' */
 		str_value = svGetValue (ifcfg, "IPV6ADDR", FALSE);
@@ -1572,6 +1578,7 @@ static gboolean
 add_one_wep_key (shvarFile *ifcfg,
                  const char *shvar_key,
                  guint8 key_idx,
+                 gboolean passphrase,
                  NMSettingWirelessSecurity *s_wsec,
                  GError **error)
 {
@@ -1591,42 +1598,51 @@ add_one_wep_key (shvarFile *ifcfg,
 	}
 
 	/* Validate keys */
-	if (strlen (value) == 10 || strlen (value) == 26) {
-		/* Hexadecimal WEP key */
-		char *p = value;
+	if (passphrase) {
+		if (strlen (value) && strlen (value) < 64) {
+			key = g_strdup (value);
+			g_object_set (G_OBJECT (s_wsec),
+			              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE,
+			              NM_WEP_KEY_TYPE_PASSPHRASE,
+			              NULL);
+		}
+	} else {
+		if (strlen (value) == 10 || strlen (value) == 26) {
+			/* Hexadecimal WEP key */
+			char *p = value;
 
-		while (*p) {
-			if (!g_ascii_isxdigit (*p)) {
-				g_set_error (error, ifcfg_plugin_error_quark (), 0,
-				             "Invalid hexadecimal WEP key.");
-				goto out;
+			while (*p) {
+				if (!g_ascii_isxdigit (*p)) {
+					g_set_error (error, ifcfg_plugin_error_quark (), 0,
+					             "Invalid hexadecimal WEP key.");
+					goto out;
+				}
+				p++;
 			}
-			p++;
-		}
-		key = g_strdup (value);
-	} else if (   strncmp (value, "s:", 2)
-	           && (strlen (value) == 7 || strlen (value) == 15)) {
-		/* ASCII passphrase */
-		char *p = value + 2;
+			key = g_strdup (value);
+		} else if (   strncmp (value, "s:", 2)
+		           && (strlen (value) == 7 || strlen (value) == 15)) {
+			/* ASCII passphrase */
+			char *p = value + 2;
 
-		while (*p) {
-			if (!isascii ((int) (*p))) {
-				g_set_error (error, ifcfg_plugin_error_quark (), 0,
-				             "Invalid ASCII WEP passphrase.");
-				goto out;
+			while (*p) {
+				if (!isascii ((int) (*p))) {
+					g_set_error (error, ifcfg_plugin_error_quark (), 0,
+					             "Invalid ASCII WEP passphrase.");
+					goto out;
+				}
+				p++;
 			}
-			p++;
-		}
 
-		key = utils_bin2hexstr (value, strlen (value), strlen (value) * 2);
-	} else {
-		g_set_error (error, ifcfg_plugin_error_quark (), 0, "Invalid WEP key length.");
+			key = utils_bin2hexstr (value, strlen (value), strlen (value) * 2);
+		}
 	}
 
 	if (key) {
 		nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
 		success = TRUE;
-	}
+	} else
+		g_set_error (error, ifcfg_plugin_error_quark (), 0, "Invalid WEP key length.");
 
 out:
 	g_free (value);
@@ -1639,15 +1655,26 @@ read_wep_keys (shvarFile *ifcfg,
                NMSettingWirelessSecurity *s_wsec,
                GError **error)
 {
-	if (!add_one_wep_key (ifcfg, "KEY1", 0, s_wsec, error))
+	/* Try hex/ascii keys first */
+	if (!add_one_wep_key (ifcfg, "KEY1", 0, FALSE, s_wsec, error))
+		return FALSE;
+	if (!add_one_wep_key (ifcfg, "KEY2", 1, FALSE, s_wsec, error))
+		return FALSE;
+	if (!add_one_wep_key (ifcfg, "KEY3", 2, FALSE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY2", 1, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY4", 3, FALSE, s_wsec, error))
+		return FALSE;
+	if (!add_one_wep_key (ifcfg, "KEY", def_idx, FALSE, s_wsec, error))
+		return FALSE;
+
+	/* And then passphrases */
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY3", 2, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY4", 3, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY", def_idx, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
 		return FALSE;
 
 	return TRUE;
@@ -1695,6 +1722,7 @@ make_wep_setting (shvarFile *ifcfg,
 			goto error;
 		}
 		svCloseFile (keys_ifcfg);
+		g_assert (error == NULL || *error == NULL);
 	}
 
 	/* If there's a default key, ensure that key exists */
@@ -3062,6 +3090,7 @@ connection_from_file (const char *filename,
 	NMSetting *s_ip4, *s_ip6;
 	const char *ifcfg_name = NULL;
 	gboolean nm_controlled = TRUE;
+	gboolean ip6_used = FALSE;
 
 	g_return_val_if_fail (filename != NULL, NULL);
 	g_return_val_if_fail (unmanaged != NULL, NULL);
@@ -3165,22 +3194,27 @@ connection_from_file (const char *filename,
 	if (!connection || *unmanaged)
 		goto done;
 
-	s_ip4 = make_ip4_setting (parsed, network_file, iscsiadm_path, error);
+	s_ip6 = make_ip6_setting (parsed, network_file, iscsiadm_path, error);
 	if (*error) {
 		g_object_unref (connection);
 		connection = NULL;
 		goto done;
-	} else if (s_ip4) {
-		nm_connection_add_setting (connection, s_ip4);
+	} else if (s_ip6) {
+		const char *method;
+
+		nm_connection_add_setting (connection, s_ip6);
+		method = nm_setting_ip6_config_get_method (NM_SETTING_IP6_CONFIG (s_ip6));
+		if (method && strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE))
+			ip6_used = TRUE;
 	}
 
-	s_ip6 = make_ip6_setting (parsed, network_file, iscsiadm_path, error);
+	s_ip4 = make_ip4_setting (parsed, network_file, iscsiadm_path, ip6_used, error);
 	if (*error) {
 		g_object_unref (connection);
 		connection = NULL;
 		goto done;
-	} else if (s_ip6)
-		nm_connection_add_setting (connection, s_ip6);
+	} else if (s_ip4)
+		nm_connection_add_setting (connection, s_ip4);
 
 	/* iSCSI / ibft connections are read-only since their settings are
 	 * stored in NVRAM and can only be changed in BIOS.
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am b/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am
index b5c94dd..66435ac 100644
--- a/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am
@@ -57,7 +57,10 @@ EXTRA_DIST = \
 	route6-test-wired-ipv6-manual \
 	ifcfg-test-wired-static-no-prefix-8 \
 	ifcfg-test-wired-static-no-prefix-16 \
-	ifcfg-test-wired-static-no-prefix-24
+	ifcfg-test-wired-static-no-prefix-24 \
+	ifcfg-test-wired-ipv6-only \
+	ifcfg-test-wifi-wep-passphrase \
+	keys-test-wifi-wep-passphrase
 
 check-local:
 	@for f in $(EXTRA_DIST); do \
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wifi-wep-passphrase b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wifi-wep-passphrase
new file mode 100644
index 0000000..250efa1
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wifi-wep-passphrase
@@ -0,0 +1,14 @@
+TYPE=Wireless
+DEVICE=eth2
+HWADDR=00:16:41:11:22:33
+NM_CONTROLLED=yes
+BOOTPROTO=dhcp
+ESSID=blahblah
+CHANNEL=1
+MODE=Managed
+RATE=auto
+ONBOOT=yes
+USERCTL=yes
+PEERDNS=yes
+IPV6INIT=no
+SECURITYMODE=open
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wired-ipv6-only b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wired-ipv6-only
new file mode 100644
index 0000000..59ec32e
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wired-ipv6-only
@@ -0,0 +1,14 @@
+# Intel Corporation 82567LM Gigabit Network Connection
+TYPE=Ethernet
+DEVICE=eth2
+HWADDR=00:11:22:33:44:ee
+ONBOOT=yes
+USERCTL=yes
+NM_CONTROLLED=yes
+PEERDNS=yes
+DNS1=1:2:3:4::a
+DOMAIN="lorem.com ipsum.org dolor.edu"
+IPV6INIT=yes
+IPV6_AUTOCONF=no
+IPV6ADDR="1001:abba::1234/56"
+
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/keys-test-wifi-wep-passphrase b/system-settings/plugins/ifcfg-rh/tests/network-scripts/keys-test-wifi-wep-passphrase
new file mode 100644
index 0000000..d45c0ea
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/keys-test-wifi-wep-passphrase
@@ -0,0 +1 @@
+KEY_PASSPHRASE1="foobar222blahblah"
diff --git a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
index 8855a32..c96d13a 100644
--- a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
+++ b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 - 2009 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <stdio.h>
@@ -2142,6 +2142,155 @@ test_read_wired_ipv6_manual (void)
 	g_object_unref (connection);
 }
 
+#define TEST_IFCFG_WIRED_IPV6_ONLY TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wired-ipv6-only"
+
+static void
+test_read_wired_ipv6_only (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GError *error = NULL;
+	const char *tmp;
+	const char *expected_id = "System test-wired-ipv6-only";
+	const char *expected_address1 = "1001:abba::1234";
+	guint32 expected_prefix1 = 56;
+	const char *expected_dns1 = "1:2:3:4::a";
+	NMIP6Address *ip6_addr;
+	struct in6_addr addr;
+
+	connection = connection_from_file (TEST_IFCFG_WIRED_IPV6_ONLY,
+	                                   NULL,
+	                                   TYPE_ETHERNET,
+	                                   NULL,
+	                                   &unmanaged,
+	                                   &keyfile,
+	                                   &routefile,
+	                                   &route6file,
+	                                   &error,
+	                                   &ignore_error);
+	ASSERT (connection != NULL,
+	        "wired-ipv6-only-read", "failed to read %s: %s", TEST_IFCFG_WIRED_IPV6_ONLY, error->message);
+
+	ASSERT (nm_connection_verify (connection, &error),
+	        "wired-ipv6-only-verify", "failed to verify %s: %s", TEST_IFCFG_WIRED_IPV6_ONLY, error->message);
+
+	ASSERT (unmanaged == FALSE,
+	        "wired-ipv6-only-verify", "failed to verify %s: unexpected unmanaged value", TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	ASSERT (s_con != NULL,
+	        "wired-ipv6-only-verify-connection", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+
+	/* ID */
+	tmp = nm_setting_connection_get_id (s_con);
+	ASSERT (tmp != NULL,
+	        "wired-ipv6-only-verify-connection", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_CONNECTION_SETTING_NAME,
+	        NM_SETTING_CONNECTION_ID);
+	ASSERT (strcmp (tmp, expected_id) == 0,
+	        "wired-ipv6-only-verify-connection", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_CONNECTION_SETTING_NAME,
+	        NM_SETTING_CONNECTION_ID);
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = NM_SETTING_WIRED (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED));
+	ASSERT (s_wired != NULL,
+	        "wired-ipv6-only-verify-wired", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_WIRED_SETTING_NAME);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
+	ASSERT (s_ip4 == NULL,
+	        "wired-ipv6-only-verify-ip4", "failed to verify %s: unexpected %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP4_CONFIG_SETTING_NAME);
+
+	/* ===== IPv6 SETTING ===== */
+
+	s_ip6 = NM_SETTING_IP6_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG));
+	ASSERT (s_ip6 != NULL,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+
+	/* Method */
+	tmp = nm_setting_ip6_config_get_method (s_ip6);
+	ASSERT (strcmp (tmp, NM_SETTING_IP6_CONFIG_METHOD_MANUAL) == 0,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME,
+	        NM_SETTING_IP6_CONFIG_METHOD);
+
+	/* IP addresses */
+	ASSERT (nm_setting_ip6_config_get_num_addresses (s_ip6) == 1,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+		TEST_IFCFG_WIRED_IPV6_MANUAL,
+		NM_SETTING_IP6_CONFIG_SETTING_NAME,
+		NM_SETTING_IP6_CONFIG_ADDRESSES);
+
+	/* Address #1 */
+	ip6_addr = nm_setting_ip6_config_get_address (s_ip6, 0);
+	ASSERT (ip6_addr,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: missing IP6 address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	ASSERT (nm_ip6_address_get_prefix (ip6_addr) == expected_prefix1,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected IP6 address #1 prefix",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	ASSERT (inet_pton (AF_INET6, expected_address1, &addr) > 0,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: couldn't convert IP address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+	ASSERT (IN6_ARE_ADDR_EQUAL (nm_ip6_address_get_address (ip6_addr), &addr),
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected IP6 address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	/* DNS Addresses */
+	ASSERT (nm_setting_ip6_config_get_num_dns (s_ip6) == 1,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME,
+	        NM_SETTING_IP6_CONFIG_DNS);
+
+	ASSERT (inet_pton (AF_INET6, expected_dns1, &addr) > 0,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: couldn't convert DNS IP address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+	ASSERT (IN6_ARE_ADDR_EQUAL (nm_setting_ip6_config_get_dns (s_ip6, 0), &addr),
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL,
+		NM_SETTING_IP6_CONFIG_SETTING_NAME,
+		NM_SETTING_IP6_CONFIG_DNS);
+
+	/* DNS domains - none as domains are stuffed to 'ipv4' setting */
+	ASSERT (nm_setting_ip6_config_get_num_dns_searches (s_ip6) == 0,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME,
+	        NM_SETTING_IP6_CONFIG_DNS);
+
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+}
+
 #define TEST_IFCFG_ONBOOT_NO TEST_IFCFG_DIR"/network-scripts/ifcfg-test-onboot-no"
 
 static void
@@ -2855,6 +3004,7 @@ test_read_wifi_wep (void)
 	const char *expected_mode = "infrastructure";
 	const guint32 expected_channel = 1;
 	const char *expected_wep_key0 = "0123456789abcdef0123456789";
+	NMWepKeyType key_type;
 
 	connection = connection_from_file (TEST_IFCFG_WIFI_WEP,
 	                                   NULL,
@@ -3026,6 +3176,13 @@ test_read_wifi_wep (void)
 	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
 	        NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX);
 
+	/* WEP key type */
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	ASSERT (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY,
+	        "wifi-wep-verify-wireless", "failed to verify %s: unexpected WEP key type %d",
+	        TEST_IFCFG_WIFI_WEP,
+	        key_type);
+
 	/* WEP key index 0 */
 	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 0);
 	ASSERT (tmp != NULL,
@@ -3359,6 +3516,142 @@ test_read_wifi_wep_adhoc (void)
 	g_object_unref (connection);
 }
 
+#define TEST_IFCFG_WIFI_WEP_PASSPHRASE TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-wep-passphrase"
+
+static void
+test_read_wifi_wep_passphrase (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GError *error = NULL;
+	const char *tmp;
+	const char *expected_wep_key0 = "foobar222blahblah";
+	NMWepKeyType key_type;
+
+	connection = connection_from_file (TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	                                   NULL,
+	                                   TYPE_WIRELESS,
+	                                   NULL,
+	                                   &unmanaged,
+	                                   &keyfile,
+	                                   &routefile,
+	                                   &route6file,
+	                                   &error,
+	                                   &ignore_error);
+	ASSERT (connection != NULL,
+	        "wifi-wep-passphrase-read", "failed to read %s: %s",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE, error->message);
+
+	ASSERT (nm_connection_verify (connection, &error),
+	        "wifi-wep-passphrase-verify", "failed to verify %s: %s",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE, error->message);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	ASSERT (s_con != NULL,
+	        "wifi-wep-passphrase-verify-connection", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	ASSERT (s_wireless != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SETTING_NAME);
+
+	/* Security */
+	tmp = nm_setting_wireless_get_security (s_wireless);
+	ASSERT (tmp != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SEC);
+	ASSERT (strcmp (tmp, NM_SETTING_WIRELESS_SECURITY_SETTING_NAME) == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SEC);
+
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY));
+	ASSERT (s_wsec != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+
+	/* Key management */
+	ASSERT (strcmp (nm_setting_wireless_security_get_key_mgmt (s_wsec), "none") == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_KEY_MGMT);
+
+	/* WEP key index */
+	ASSERT (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec) == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX);
+
+	/* WEP key type */
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	ASSERT (key_type == NM_WEP_KEY_TYPE_PASSPHRASE,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected WEP key type %d",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        key_type);
+
+	/* WEP key index 0 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 0);
+	ASSERT (tmp != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY0);
+	ASSERT (strcmp (tmp, expected_wep_key0) == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY0);
+
+	/* WEP key index 1 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 1);
+	ASSERT (tmp == NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY1);
+
+	/* WEP key index 2 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 2);
+	ASSERT (tmp == NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY2);
+
+	/* WEP key index 3 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 3);
+	ASSERT (tmp == NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY3);
+
+	g_object_unref (connection);
+}
+
 #define TEST_IFCFG_WIFI_LEAP TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-leap"
 
 static void
@@ -5108,6 +5401,140 @@ test_write_wired_dhcp (void)
 	g_object_unref (reread);
 }
 
+static void
+test_write_wired_static_ip6_only (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP6Config *s_ip6;
+	static unsigned char tmpmac[] = { 0x31, 0x33, 0x33, 0x37, 0xbe, 0xcd };
+	GByteArray *mac;
+	char *uuid;
+	guint64 timestamp = 0x12344433L;
+	struct in6_addr ip6;
+	struct in6_addr dns6;
+	NMIP6Address *addr6;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+
+	inet_pton (AF_INET6, "1003:1234:abcd::1", &ip6);
+	inet_pton (AF_INET6, "fade:0102:0103::face", &dns6);
+
+	connection = nm_connection_new ();
+	ASSERT (connection != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new connection");
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	ASSERT (s_con != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new %s setting",
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static IP6 Only",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_TIMESTAMP, timestamp,
+	              NULL);
+	g_free (uuid);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	ASSERT (s_wired != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new %s setting",
+	        NM_SETTING_WIRED_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	mac = g_byte_array_sized_new (sizeof (tmpmac));
+	g_byte_array_append (mac, &tmpmac[0], sizeof (tmpmac));
+	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, mac, NULL);
+	g_byte_array_free (mac, TRUE);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	ASSERT (s_ip6 != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new %s setting",
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip6_address_new ();
+	nm_ip6_address_set_address (addr6, &ip6);
+	nm_ip6_address_set_prefix (addr6, 11);
+	nm_setting_ip6_config_add_address (s_ip6, addr6);
+	nm_ip6_address_unref (addr6);
+
+	/* DNS server */
+	nm_setting_ip6_config_add_dns (s_ip6, &dns6);
+
+	ASSERT (nm_connection_verify (connection, &error) == TRUE,
+	        "wired-static-ip6-only-write", "failed to verify connection: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	ASSERT (success == TRUE,
+	        "wired-static-ip6-only-write", "failed to write connection to disk: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	ASSERT (testfile != NULL,
+	        "wired-static-ip6-only-write", "didn't get ifcfg file path back after writing connection");
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_ETHERNET,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	ASSERT (reread != NULL,
+	        "wired-static-ip6-only-write-reread", "failed to read %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_verify (reread, &error),
+	        "wired-static-ip6-only-write-reread-verify", "failed to verify %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_get_setting (reread, NM_TYPE_SETTING_IP4_CONFIG) == NULL,
+	        "wired-static-ip6-only-write-reread-verify", "unexpected IPv4 setting");
+
+	ASSERT (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT) == TRUE,
+	        "wired-static-ip6-only-write", "written and re-read connection weren't the same.");
+
+	if (route6file)
+		unlink (route6file);
+
+	g_free (testfile);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
+
 #define TEST_IFCFG_READ_WRITE_STATIC_ROUTES_LEGACY TEST_IFCFG_DIR"/network-scripts/ifcfg-test-static-routes-legacy"
 
 static void
@@ -6137,6 +6564,155 @@ test_write_wifi_wep_adhoc (void)
 }
 
 static void
+test_write_wifi_wep_passphrase (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	char *uuid;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GByteArray *ssid;
+	const unsigned char ssid_data[] = "blahblah";
+	struct stat statbuf;
+
+	connection = nm_connection_new ();
+	ASSERT (connection != NULL,
+	        "wifi-wep-passphrase-write", "failed to allocate new connection");
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	ASSERT (s_con != NULL,
+	        "wifi-wep-passphrase-write", "failed to allocate new %s setting",
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP Passphrase",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	ASSERT (s_wifi != NULL,
+	        "wifi-wep-passphrase-write", "failed to allocate new %s setting",
+	        NM_SETTING_WIRELESS_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_byte_array_sized_new (sizeof (ssid_data));
+	g_byte_array_append (ssid, ssid_data, sizeof (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_SEC, NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	              NULL);
+
+	g_byte_array_free (ssid, TRUE);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	ASSERT (s_wsec != NULL,
+			"wifi-wep-passphrase-write", "failed to allocate new %s setting",
+			NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0,
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "asdfdjaslfjasd;flasjdfl;aksdf");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+	ASSERT (s_ip4 != NULL,
+			"wifi-wep-passphrase-write", "failed to allocate new %s setting",
+			NM_SETTING_IP4_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	ASSERT (s_ip6 != NULL,
+	        "wifi-wep-adhoc-write", "failed to allocate new %s setting",
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE, NULL);
+
+	ASSERT (nm_connection_verify (connection, &error) == TRUE,
+	        "wifi-wep-passphrase-write", "failed to verify connection: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	ASSERT (success == TRUE,
+	        "wifi-wep-passphrase-write", "failed to write connection to disk: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	ASSERT (testfile != NULL,
+	        "wifi-wep-passphrase-write", "didn't get ifcfg file path back after writing connection");
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_WIRELESS,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	ASSERT (keyfile != NULL,
+	        "wifi-wep-passphrase-write-reread", "expected keyfile for '%s'", testfile);
+
+	ASSERT (stat (keyfile, &statbuf) == 0,
+	        "wifi-wep-passphrase-write-reread", "couldn't stat() '%s'", keyfile);
+	ASSERT (S_ISREG (statbuf.st_mode),
+	        "wifi-wep-passphrase-write-reread", "keyfile '%s' wasn't a normal file", keyfile);
+	ASSERT ((statbuf.st_mode & 0077) == 0,
+	        "wifi-wep-passphrase-write-reread", "keyfile '%s' wasn't readable only by its owner", keyfile);
+
+	unlink (keyfile);
+
+	ASSERT (reread != NULL,
+	        "wifi-wep-passphrase-write-reread", "failed to read %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_verify (reread, &error),
+	        "wifi-wep-passphrase-write-reread-verify", "failed to verify %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT) == TRUE,
+	        "wifi-wep-passphrase-write", "written and re-read connection weren't the same.");
+
+	g_free (testfile);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
+static void
 test_write_wifi_leap (void)
 {
 	NMConnection *connection;
@@ -7813,6 +8389,7 @@ int main (int argc, char **argv)
 	test_read_wired_static_routes ();
 	test_read_wired_static_routes_legacy ();
 	test_read_wired_ipv6_manual ();
+	test_read_wired_ipv6_only ();
 	test_read_onboot_no ();
 	test_read_wired_8021x_peap_mschapv2 ();
 	test_read_wifi_open ();
@@ -7824,6 +8401,7 @@ int main (int argc, char **argv)
 	test_read_wifi_open_ssid_quoted ();
 	test_read_wifi_wep ();
 	test_read_wifi_wep_adhoc ();
+	test_read_wifi_wep_passphrase ();
 	test_read_wifi_leap ();
 	test_read_wifi_wpa_psk ();
 	test_read_wifi_wpa_psk_unquoted ();
@@ -7835,6 +8413,7 @@ int main (int argc, char **argv)
 	test_read_wifi_wep_eap_ttls_chap ();
 
 	test_write_wired_static ();
+	test_write_wired_static_ip6_only ();
 	test_write_wired_static_routes ();
 	test_read_write_static_routes_legacy ();
 	test_write_wired_dhcp ();
@@ -7843,6 +8422,7 @@ int main (int argc, char **argv)
 	test_write_wifi_open_hex_ssid ();
 	test_write_wifi_wep ();
 	test_write_wifi_wep_adhoc ();
+	test_write_wifi_wep_passphrase ();
 	test_write_wifi_leap ();
 	test_write_wifi_wpa_psk ("Test Write Wifi WPA PSK",
 	                         "wifi-wpa-psk-write",
diff --git a/system-settings/plugins/ifcfg-rh/writer.c b/system-settings/plugins/ifcfg-rh/writer.c
index 4ded5c6..d8df2d3 100644
--- a/system-settings/plugins/ifcfg-rh/writer.c
+++ b/system-settings/plugins/ifcfg-rh/writer.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <ctype.h>
@@ -579,20 +579,46 @@ write_wireless_security_setting (NMConnection *connection,
 		}
 	}
 
+	/* WEP keys */
+
+	/* Clear existing keys */
+	set_secret (ifcfg, "KEY", NULL, FALSE); /* Clear any default key */
+	for (i = 0; i < 4; i++) {
+		tmp = g_strdup_printf ("KEY_PASSPHRASE%d", i + 1);
+		set_secret (ifcfg, tmp, NULL, FALSE);
+		g_free (tmp);
+
+		tmp = g_strdup_printf ("KEY%d", i + 1);
+		set_secret (ifcfg, tmp, NULL, FALSE);
+		g_free (tmp);
+	}
+
+	/* And write the new ones out */
 	if (wep) {
 		/* Default WEP TX key index */
 		tmp = g_strdup_printf ("%d", nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec) + 1);
 		svSetValue (ifcfg, "DEFAULTKEY", tmp, FALSE);
 		g_free (tmp);
-	}
 
-	/* WEP keys */
-	set_secret (ifcfg, "KEY", NULL, FALSE); /* Clear any default key */
-	for (i = 0; i < 4; i++) {
-		key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
-		tmp = g_strdup_printf ("KEY%d", i + 1);
-		set_secret (ifcfg, tmp, (wep && key) ? key : NULL, FALSE);
-		g_free (tmp);
+		for (i = 0; i < 4; i++) {
+			NMWepKeyType key_type;
+
+			key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
+			if (key) {
+				/* Passphrase needs a different ifcfg key since with WEP, there
+				 * are some passphrases that are indistinguishable from WEP hex
+				 * keys.
+				 */
+				key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+				if (key_type == NM_WEP_KEY_TYPE_PASSPHRASE)
+					tmp = g_strdup_printf ("KEY_PASSPHRASE%d", i + 1);
+				else
+					tmp = g_strdup_printf ("KEY%d", i + 1);
+
+				set_secret (ifcfg, tmp, key, FALSE);
+				g_free (tmp);
+			}
+		}
 	}
 
 	/* WPA protos */
@@ -807,6 +833,7 @@ write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		g_free (tmp);
 	}
 
+	svSetValue (ifcfg, "MTU", NULL, FALSE);
 	mtu = nm_setting_wired_get_mtu (s_wired);
 	if (mtu) {
 		tmp = g_strdup_printf ("%u", mtu);
@@ -910,9 +937,30 @@ write_ip4_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 
 	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
 	if (!s_ip4) {
-		g_set_error (error, ifcfg_plugin_error_quark (), 0,
-		             "Missing '%s' setting", NM_SETTING_IP4_CONFIG_SETTING_NAME);
-		return FALSE;
+		int result;
+
+		/* IPv4 disabled, clear IPv4 related parameters */
+		svSetValue (ifcfg, "BOOTPROTO", NULL, FALSE);
+		for (i = 0; i < 254; i++) {
+			if (i == 0) {
+				addr_key = g_strdup ("IPADDR");
+				prefix_key = g_strdup ("PREFIX");
+				gw_key = g_strdup ("GATEWAY");
+			} else {
+				addr_key = g_strdup_printf ("IPADDR%d", i + 1);
+				prefix_key = g_strdup_printf ("PREFIX%d", i + 1);
+				gw_key = g_strdup_printf ("GATEWAY%d", i + 1);
+			}
+
+			svSetValue (ifcfg, addr_key, NULL, FALSE);
+			svSetValue (ifcfg, prefix_key, NULL, FALSE);
+			svSetValue (ifcfg, gw_key, NULL, FALSE);
+		}
+
+		route_path = utils_get_route_path (ifcfg->fileName);
+		result = unlink (route_path);
+		g_free (route_path);
+		return TRUE;
 	}
 
 	value = nm_setting_ip4_config_get_method (s_ip4);
@@ -1205,18 +1253,27 @@ write_ip6_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 	g_assert (value);
 	if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
 		svSetValue (ifcfg, "IPV6INIT", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 		return TRUE;
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
 		svSetValue (ifcfg, "IPV6_AUTOCONF", "yes", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
+		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
+		svSetValue (ifcfg, "IPV6_AUTOCONF", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", "yes", FALSE);
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_MANUAL)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
 		svSetValue (ifcfg, "IPV6_AUTOCONF", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
 		svSetValue (ifcfg, "IPV6_AUTOCONF", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 		/* TODO */
 	}
 
diff --git a/system-settings/plugins/ifupdown/plugin.c b/system-settings/plugins/ifupdown/plugin.c
index d725bd9..e2358b9 100644
--- a/system-settings/plugins/ifupdown/plugin.c
+++ b/system-settings/plugins/ifupdown/plugin.c
@@ -59,7 +59,9 @@
 #define IFUPDOWN_PLUGIN_INFO "(C) 2008 Canonical Ltd.  To report bugs please use the NetworkManager mailing list."
 #define IFUPDOWN_SYSTEM_HOSTNAME_FILE "/etc/hostname"
 
-#define IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
+#define IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE SYSCONFDIR "/NetworkManager/NetworkManager.conf"
+#define IFUPDOWN_OLD_SYSTEM_SETTINGS_KEY_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
+
 #define IFUPDOWN_KEY_FILE_GROUP "ifupdown"
 #define IFUPDOWN_KEY_FILE_KEY_MANAGED "managed"
 #define IFUPDOWN_UNMANAGE_WELL_KNOWN_DEFAULT TRUE
@@ -78,6 +80,7 @@ typedef struct {
 	GHashTable *well_known_interfaces;
 	GHashTable *well_known_ifaces;
 	gboolean unmanage_well_known;
+	const char *conf_file;
 
 	gulong inotify_event_id;
 	int inotify_system_hostname_wd;
@@ -403,13 +406,19 @@ SCPluginIfupdown_init (NMSystemConfigInterface *config)
 	g_list_free (keys);
 	g_hash_table_destroy (auto_ifaces);
 
+	/* Find the config file */
+	if (g_file_test (IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE, G_FILE_TEST_EXISTS))
+		priv->conf_file = IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE;
+	else
+		priv->conf_file = IFUPDOWN_OLD_SYSTEM_SETTINGS_KEY_FILE;
+
 	keyfile = g_key_file_new ();
 	if (!g_key_file_load_from_file (keyfile,
-	                                IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE,
+	                                priv->conf_file,
 	                                G_KEY_FILE_NONE,
 	                                &error)) {
 		nm_info ("loading system config file (%s) caused error: (%d) %s",
-		         IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE,
+		         priv->conf_file,
 		         error ? error->code : -1,
 		         error && error->message ? error->message : "(unknown)");
 	} else {
diff --git a/system-settings/plugins/keyfile/nm-keyfile-connection.c b/system-settings/plugins/keyfile/nm-keyfile-connection.c
index b64c2f9..ed56d69 100644
--- a/system-settings/plugins/keyfile/nm-keyfile-connection.c
+++ b/system-settings/plugins/keyfile/nm-keyfile-connection.c
@@ -88,7 +88,8 @@ update (NMSettingsConnectionInterface *connection,
 		success = parent_settings_connection_iface->update (connection, callback, user_data);
 	} else {
 		callback (connection, error, user_data);
-		g_error_free (error);
+		if (error)
+			g_error_free (error);
 		g_free (filename);
 	}
 
diff --git a/system-settings/plugins/keyfile/plugin.c b/system-settings/plugins/keyfile/plugin.c
index 40f0960..36f47cc 100644
--- a/system-settings/plugins/keyfile/plugin.c
+++ b/system-settings/plugins/keyfile/plugin.c
@@ -42,7 +42,8 @@
 #define KEYFILE_PLUGIN_NAME "keyfile"
 #define KEYFILE_PLUGIN_INFO "(c) 2007 - 2008 Red Hat, Inc.  To report bugs please use the NetworkManager mailing list."
 
-#define CONF_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
+#define CONF_FILE SYSCONFDIR "/NetworkManager/NetworkManager.conf"
+#define OLD_CONF_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
 
 static char *plugin_get_hostname (SCPluginKeyfile *plugin);
 static void system_config_interface_init (NMSystemConfigInterface *system_config_interface_class);
@@ -59,6 +60,7 @@ typedef struct {
 	GFileMonitor *monitor;
 	guint monitor_id;
 
+	const char *conf_file;
 	GFileMonitor *conf_file_monitor;
 	guint conf_file_monitor_id;
 
@@ -297,7 +299,7 @@ setup_monitoring (NMSystemConfigInterface *config)
 		priv->monitor = monitor;
 	}
 
-	file = g_file_new_for_path (CONF_FILE);
+	file = g_file_new_for_path (priv->conf_file);
 	monitor = g_file_monitor_file (file, G_FILE_MONITOR_NONE, NULL, NULL);
 	g_object_unref (file);
 
@@ -344,12 +346,13 @@ add_connection (NMSystemConfigInterface *config,
 static GSList *
 get_unmanaged_specs (NMSystemConfigInterface *config)
 {
+	SCPluginKeyfilePrivate *priv = SC_PLUGIN_KEYFILE_GET_PRIVATE (config);
 	GKeyFile *key_file;
 	GSList *specs = NULL;
 	GError *error = NULL;
 
 	key_file = g_key_file_new ();
-	if (g_key_file_load_from_file (key_file, CONF_FILE, G_KEY_FILE_NONE, &error)) {
+	if (g_key_file_load_from_file (key_file, priv->conf_file, G_KEY_FILE_NONE, &error)) {
 		char *str;
 
 		str = g_key_file_get_value (key_file, "keyfile", "unmanaged-devices", NULL);
@@ -366,7 +369,7 @@ get_unmanaged_specs (NMSystemConfigInterface *config)
 			g_free (udis); /* Yes, g_free, not g_strfreev because we need the strings in the list */
 		}
 	} else {
-		g_warning ("Error parsing file '%s': %s", CONF_FILE, error->message);
+		g_warning ("Error parsing file '%s': %s", priv->conf_file, error->message);
 		g_error_free (error);
 	}
 
@@ -378,15 +381,16 @@ get_unmanaged_specs (NMSystemConfigInterface *config)
 static char *
 plugin_get_hostname (SCPluginKeyfile *plugin)
 {
+	SCPluginKeyfilePrivate *priv = SC_PLUGIN_KEYFILE_GET_PRIVATE (plugin);
 	GKeyFile *key_file;
 	char *hostname = NULL;
 	GError *error = NULL;
 
 	key_file = g_key_file_new ();
-	if (g_key_file_load_from_file (key_file, CONF_FILE, G_KEY_FILE_NONE, &error))
+	if (g_key_file_load_from_file (key_file, priv->conf_file, G_KEY_FILE_NONE, &error))
 		hostname = g_key_file_get_value (key_file, "keyfile", "hostname", NULL);
 	else {
-		g_warning ("Error parsing file '%s': %s", CONF_FILE, error->message);
+		g_warning ("Error parsing file '%s': %s", priv->conf_file, error->message);
 		g_error_free (error);
 	}
 
@@ -404,7 +408,7 @@ plugin_set_hostname (SCPluginKeyfile *plugin, const char *hostname)
 	gboolean result = FALSE;
 
 	key_file = g_key_file_new ();
-	if (g_key_file_load_from_file (key_file, CONF_FILE, G_KEY_FILE_NONE, &error)) {
+	if (g_key_file_load_from_file (key_file, priv->conf_file, G_KEY_FILE_NONE, &error)) {
 		char *data;
 		gsize len;
 
@@ -412,7 +416,7 @@ plugin_set_hostname (SCPluginKeyfile *plugin, const char *hostname)
 
 		data = g_key_file_to_data (key_file, &len, &error);
 		if (data) {
-			g_file_set_contents (CONF_FILE, data, len, &error);
+			g_file_set_contents (priv->conf_file, data, len, &error);
 			g_free (data);
 
 			g_free (priv->hostname);
@@ -425,7 +429,7 @@ plugin_set_hostname (SCPluginKeyfile *plugin, const char *hostname)
 			g_error_free (error);
 		}
 	} else {
-		g_warning ("Error parsing file '%s': %s", CONF_FILE, error->message);
+		g_warning ("Error parsing file '%s': %s", priv->conf_file, error->message);
 		g_error_free (error);
 	}
 
@@ -441,6 +445,11 @@ sc_plugin_keyfile_init (SCPluginKeyfile *plugin)
 {
 	SCPluginKeyfilePrivate *priv = SC_PLUGIN_KEYFILE_GET_PRIVATE (plugin);
 
+	if (g_file_test (CONF_FILE, G_FILE_TEST_EXISTS))
+		priv->conf_file = CONF_FILE;
+	else
+		priv->conf_file = OLD_CONF_FILE;
+
 	priv->hostname = plugin_get_hostname (plugin);
 }
 
diff --git a/test/Makefile.am b/test/Makefile.am
index 9a07f91..8e235e4 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -28,6 +28,9 @@ nm_online_LDADD = \
 	$(GLIB_LIBS)
 
 libnm_glib_test_SOURCES = libnm-glib-test.c
+libnm_glib_test_CFLAGS = \
+	-Wno-deprecated-declarations \
+	-Wno-deprecated
 libnm_glib_test_LDADD = \
 	$(top_builddir)/libnm-glib/libnm-glib.la \
 	$(top_builddir)/libnm-util/libnm-util.la \
