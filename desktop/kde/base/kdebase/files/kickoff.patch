Index: kicker/applets/media/mediumbutton.cpp
===================================================================
--- kicker/applets/media/mediumbutton.cpp.orig
+++ kicker/applets/media/mediumbutton.cpp
@@ -74,7 +74,7 @@ MediumButton::MediumButton(QWidget *pare
 
 MediumButton::~MediumButton()
 {
-    QPopupMenu *menu = popup();
+    QPopupMenu *menu = static_cast<QPopupMenu*>( popup());
     setPopup(0);
     delete menu;
 }
@@ -94,7 +94,7 @@ void MediumButton::setFileItem(const KFi
 
 void MediumButton::initPopup()
 {
-    QPopupMenu *old_popup = popup();
+    QPopupMenu *old_popup = static_cast<QPopupMenu*>( popup());
     
     KFileItemList items;
     items.append(&mFileItem);
Index: kicker/applets/trash/trashbutton.cpp
===================================================================
--- kicker/applets/trash/trashbutton.cpp.orig
+++ kicker/applets/trash/trashbutton.cpp
@@ -78,7 +78,7 @@ void TrashButton::setItemCount(int count
 
 void TrashButton::initPopup()
 {
-	QPopupMenu *old_popup = popup();
+	QPopupMenu *old_popup = static_cast<QPopupMenu*>( popup());
 
 	KFileItemList items;
 	items.append(&mFileItem);
Index: kicker/configure.in.in
===================================================================
--- /dev/null
+++ kicker/configure.in.in
@@ -0,0 +1,78 @@
+dnl Check for pkg-config
+AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+
+if test "$PKG_CONFIG" = "no"; then
+  AC_MSG_ERROR([
+This package requires pkg-config.
+])
+fi
+
+dnl Check for Glib-2.0
+# GLIB_CFLAGS:  cflags for compiling glib dependant sources
+# GLIB_LIBADD:  glib libraries (-l options)
+# GLIB_LDFLAGS: flags containing path to glib libraries (-L options)
+
+GLIB_PACKAGES="gmodule-2.0 gthread-2.0"
+GLIB_VERSION="1.3.3"
+AC_MSG_CHECKING(for GLib-2.0 (at least $GLIB_VERSION))
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.15 ; then
+   if $PKG_CONFIG --atleast-version $GLIB_VERSION $GLIB_PACKAGES >/dev/null 2>&1 ; then
+       GLIB_CFLAGS="`$PKG_CONFIG --cflags $GLIB_PACKAGES`"
+       GLIB_LIBADD="`$PKG_CONFIG --libs-only-l --libs-only-other $GLIB_PACKAGES`"
+       GLIB_LDFLAGS="`$PKG_CONFIG --libs-only-L $GLIB_PACKAGES`"
+       AC_MSG_RESULT(yes)
+   fi
+else
+   if $PKG_CONFIG --atleast-version $GLIB_VERSION $GLIB_PACKAGES >/dev/null 2>&1 ; then
+       GLIB_CFLAGS="`$PKG_CONFIG --cflags $GLIB_PACKAGES`"
+       GLIB_LIBADD="`$PKG_CONFIG --libs-only-l $GLIB_PACKAGES`"
+       GLIB_LDFLAGS="`$PKG_CONFIG --libs-only-L $GLIB_PACKAGES`"
+       AC_MSG_RESULT(yes)
+       AC_MSG_WARN([you may need to run make LDFLAGS=-pthread to compile arts])
+   fi
+fi
+
+if test -z "$GLIB_LIBADD"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kerry gmcop"
+fi
+
+AC_SUBST(GLIB_CFLAGS)
+AC_SUBST(GLIB_LIBADD)
+AC_SUBST(GLIB_LDFLAGS)
+
+dnl Check for libbeagle 0.2.0
+# LIBBEAGLE_CFLAGS:  cflags for compiling libbeagle dependant sources
+# LIBBEAGLE_LIBADD:  libbeagle libraries (-l options)
+# LIBBEAGLE_LDFLAGS: flags containing path to libbeagle libraries (-L options)
+
+LIBBEAGLE_PACKAGES="libbeagle-0.0"
+LIBBEAGLE_VERSION="0.2.4"
+AC_MSG_CHECKING(for libbeagle-0.2.4 (at least $LIBBEAGLE_VERSION))
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.15 ; then
+   if $PKG_CONFIG --atleast-version $LIBBEAGLE_VERSION $LIBBEAGLE_PACKAGES >/dev/null 2>&1 ; then
+       LIBBEAGLE_CFLAGS="`$PKG_CONFIG --cflags $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LIBADD="`$PKG_CONFIG --libs-only-l --libs-only-other $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LDFLAGS="`$PKG_CONFIG --libs-only-L $LIBBEAGLE_PACKAGES`"
+       AC_MSG_RESULT(yes)
+   fi
+else
+   if $PKG_CONFIG --atleast-version $LIBBEAGLE_VERSION $LIBBEAGLE_PACKAGES >/dev/null 2>&1 ; then
+       LIBBEAGLE_CFLAGS="`$PKG_CONFIG --cflags $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LIBADD="`$PKG_CONFIG --libs-only-l $LIBBEAGLE_PACKAGES`"
+       LIBBEAGLE_LDFLAGS="`$PKG_CONFIG --libs-only-L $LIBBEAGLE_PACKAGES`"
+       AC_MSG_RESULT(yes)
+       AC_MSG_WARN([you may need to run make LDFLAGS=-pthread to compile arts])
+   fi
+fi
+
+if test -z "$LIBBEAGLE_LIBADD"; then
+        AC_MSG_RESULT(not installed)
+    DO_NOT_COMPILE="$DO_NOT_COMPILE kerry gmcop"
+fi
+
+AC_SUBST(LIBBEAGLE_CFLAGS)
+AC_SUBST(LIBBEAGLE_LIBADD)
+AC_SUBST(LIBBEAGLE_LDFLAGS)
Index: kicker/kicker/buttons/kbutton.cpp
===================================================================
--- kicker/kicker/buttons/kbutton.cpp.orig
+++ kicker/kicker/buttons/kbutton.cpp
@@ -33,6 +33,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 
 #include "menumanager.h"
 #include "k_mnu.h"
+#include "k_mnu_stub.h"
 
 #include "kbutton.h"
 #include "kbutton.moc"
@@ -43,7 +44,7 @@ KButton::KButton( QWidget* parent )
     QToolTip::add(this, i18n("Applications, tasks and desktop sessions"));
     setTitle(i18n("K Menu"));
 
-    setPopup(MenuManager::the()->kmenu());
+    setPopup(MenuManager::the()->kmenu()->widget());
     MenuManager::the()->registerKButton(this);
     setIcon("kmenu");
 
Index: kicker/kicker/buttons/knewbutton.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/buttons/knewbutton.cpp
@@ -0,0 +1,199 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Binner <binner@kde.org>
+                   Stephan Kulow <coolo@kde.org>
+                   Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <cassert>
+#include <cmath>
+
+#include <qtooltip.h>
+#include <qpainter.h>
+#include <qcursor.h>
+#include <private/qeffects_p.h>
+
+#include <klocale.h>
+#include <kapplication.h>
+#include <kstandarddirs.h>
+#include <kiconloader.h>
+#include <kdebug.h>
+
+#include "kickerSettings.h"
+
+#include "config.h"
+#include "global.h"
+
+#include "menumanager.h"
+#include "k_mnu_stub.h"
+#include "k_new_mnu.h"
+
+#include "knewbutton.h"
+#include "knewbutton.moc"
+
+KNewButton *KNewButton::m_self = 0;
+
+KNewButton::KNewButton( QWidget* parent )
+    : KButton( parent ), m_oldPos(0,0)
+{
+    Q_ASSERT( !m_self );
+    m_self = this;
+    m_hoverTimer = -1;
+    m_openTimer = -1;
+    m_active = false;
+    m_mouseInside = false;
+    m_drag = false;
+
+    setAcceptDrops(true);
+    setIcon("kmenu");
+    setDrawArrow(false);
+    QApplication::desktop()->screen()->installEventFilter(this);
+    setMouseTracking(true);
+}
+
+KNewButton::~KNewButton()
+{
+    if ( m_self == this )
+        m_self = 0;
+    setMouseTracking(false);
+}
+
+void KNewButton::show()
+{
+     KButton::show();
+
+     if (KickerSettings::firstRun()) {
+         QTimer::singleShot(500,this,SLOT(slotExecMenu()));
+         KickerSettings::setFirstRun(false);
+         KickerSettings::writeConfig();
+     }
+}
+
+bool KNewButton::eventFilter(QObject *o, QEvent *e)
+{
+    if (e->type() == QEvent::MouseButtonRelease ||
+        e->type() == QEvent::MouseButtonPress   ||
+        e->type() == QEvent::MouseButtonDblClick )
+    {
+        QMouseEvent *me = static_cast<QMouseEvent *>(e);
+        if (rect().contains(mapFromGlobal(me->globalPos())))
+        {
+            if (m_pressedDuringPopup && m_popup && m_openTimer != -1
+                    && (me->button() & Qt::LeftButton) )
+                return true;
+        }
+    }
+
+    return KButton::eventFilter(o, e);
+}
+
+void KNewButton::enterEvent(QEvent* e)
+{
+     KButton::enterEvent(e);
+
+     m_mouseInside = true;
+     if (KickerSettings::openOnHover())
+        m_hoverTimer = startTimer(200);
+}
+
+void KNewButton::dragEnterEvent(QDragEnterEvent* /*e*/)
+{
+    if (m_hoverTimer != -1)
+        killTimer(m_hoverTimer);
+
+    m_hoverTimer = startTimer(500);
+    m_mouseInside = true;
+    m_drag = true;
+}
+
+void KNewButton::dragLeaveEvent(QDragLeaveEvent* /*e*/)
+{
+    m_mouseInside = false;
+    m_drag = false;
+}
+
+void KNewButton::leaveEvent(QEvent* e)
+{
+    m_mouseInside = false;
+    if (m_hoverTimer != -1)
+        killTimer(m_hoverTimer);
+    m_hoverTimer = -1;
+
+    KButton::leaveEvent(e);
+}
+
+void KNewButton::slotExecMenu()
+{
+    if (m_openTimer != -1)
+        killTimer(m_openTimer);
+
+    m_openTimer = startTimer(QApplication::doubleClickInterval() * 3);
+
+    KButton::slotExecMenu();
+
+    assert(dynamic_cast<KMenu*>(m_popup));
+
+    m_popup->move(KickerLib::popupPosition(popupDirection(), m_popup, this));
+    // I wish KMenu would properly done itself when it closes. But it doesn't.
+
+    bool useEffect = true; // could be QApplication::isEffectEnabled()
+    useEffect = false; // too many Qt bugs to be useful
+    if (m_drag)
+	useEffect = false;
+
+    m_drag = false; // once is enough
+
+    if (useEffect) {
+        switch (popupDirection()) {
+        case KPanelApplet::Left:
+            qScrollEffect(m_popup, QEffects::LeftScroll);
+            break;
+        case KPanelApplet::Up:
+            qScrollEffect(m_popup, QEffects::UpScroll);
+            break;
+        case KPanelApplet::Right:
+            qScrollEffect(m_popup, QEffects::RightScroll);
+            break;
+        case KPanelApplet::Down:
+            qScrollEffect(m_popup, QEffects::DownScroll);
+            break;
+        }
+    }
+    else
+        static_cast<KMenu*>(m_popup)->show();
+}
+
+void KNewButton::timerEvent(QTimerEvent* e)
+{
+    if (e->timerId() == m_hoverTimer) {
+
+        if (m_mouseInside && !isDown())
+            showMenu();
+
+        killTimer(m_hoverTimer);
+        m_hoverTimer = -1;
+    }
+    if (e->timerId() == m_openTimer)
+    {
+        killTimer(m_openTimer);
+        m_openTimer = -1;
+    }
+}
Index: kicker/kicker/buttons/knewbutton.h
===================================================================
--- /dev/null
+++ kicker/kicker/buttons/knewbutton.h
@@ -0,0 +1,75 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Binner <binner@kde.org>
+                   Stephan Kulow <coolo@kde.org>
+                   Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef __knewbutton_h__
+#define __knewbutton_h__
+
+#include "kbutton.h"
+
+#include <qpoint.h>
+
+/**
+ * Button that contains the PanelKMenu and client menu manager.
+ */
+class KNewButton : public KButton
+{
+    Q_OBJECT
+
+public:
+    KNewButton( QWidget *parent );
+    ~KNewButton();
+
+    static KNewButton *self() { return m_self; }
+
+    void loadConfig( const KConfigGroup& config );
+
+    bool active() const { return m_active; }
+    void setActive(bool a) { m_active = a; }
+
+protected:
+    virtual void show();
+    virtual void slotExecMenu();
+    virtual QString tileName() { return "KMenu"; }
+    virtual QString defaultIcon() const { return "go"; }
+
+    virtual void enterEvent(QEvent* e);
+    virtual void leaveEvent(QEvent* e);
+    virtual void dragEnterEvent(QDragEnterEvent*);
+    virtual void dragLeaveEvent(QDragLeaveEvent*);
+    virtual bool eventFilter(QObject *, QEvent *);
+    void timerEvent(QTimerEvent*);
+
+private:
+    QPoint m_oldPos;
+    int m_hoverTimer;
+    int m_openTimer;
+    bool m_active;
+    bool m_mouseInside;
+    bool m_drag;
+
+    static KNewButton *m_self;
+};
+
+#endif
Index: kicker/kicker/buttons/Makefile.am
===================================================================
--- kicker/kicker/buttons/Makefile.am.orig
+++ kicker/kicker/buttons/Makefile.am
@@ -1,10 +1,10 @@
 INCLUDES = -I$(srcdir)/../core -I$(srcdir)/../../libkicker -I../../libkicker \
-	-I$(srcdir)/../ui -I$(top_srcdir)/libkonq $(all_includes)
+	-I../ui -I$(srcdir)/../ui -I$(top_srcdir)/libkonq $(all_includes) $(LIBBEAGLE_CFLAGS) $(GLIB_CFLAGS)
 
 noinst_LTLIBRARIES = libkicker_buttons.la
 
 libkicker_buttons_la_SOURCES = servicebutton.cpp bookmarksbutton.cpp \
-	browserbutton.cpp \
+	browserbutton.cpp knewbutton.cpp \
 	desktopbutton.cpp extensionbutton.cpp kbutton.cpp \
 	nonkdeappbutton.cpp servicemenubutton.cpp urlbutton.cpp \
 	windowlistbutton.cpp
Index: kicker/kicker/core/container_button.cpp
===================================================================
--- kicker/kicker/core/container_button.cpp.orig
+++ kicker/kicker/core/container_button.cpp
@@ -43,6 +43,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include "desktopbutton.h"
 #include "extensionbutton.h"
 #include "kbutton.h"
+#include "knewbutton.h"
 #include "kicker.h"
 #include "kickerSettings.h"
 #include "kickertip.h"
@@ -326,14 +327,20 @@ KMenuButtonContainer::KMenuButtonContain
   : ButtonContainer(opMenu, parent)
 {
     checkImmutability(config);
-    embedButton( new KButton(this) );
+    if(KickerSettings::legacyKMenu())
+	embedButton( new KButton(this) );
+    else
+	embedButton( new KNewButton(this) );
     _actions = PanelAppletOpMenu::KMenuEditor;
 }
 
 KMenuButtonContainer::KMenuButtonContainer(QPopupMenu *opMenu, QWidget* parent)
   : ButtonContainer(opMenu, parent)
 {
-    embedButton( new KButton(this) );
+    if(KickerSettings::legacyKMenu())
+	embedButton( new KButton(this) );
+    else
+	embedButton( new KNewButton(this) );
     _actions = PanelAppletOpMenu::KMenuEditor;
 }
 
Index: kicker/kicker/core/kicker.cpp
===================================================================
--- kicker/kicker/core/kicker.cpp.orig
+++ kicker/kicker/core/kicker.cpp
@@ -48,6 +48,8 @@
 #include "extensionmanager.h"
 #include "pluginmanager.h"
 #include "menumanager.h"
+#include "k_new_mnu.h"
+#include "k_mnu_stub.h"
 #include "k_mnu.h"
 #include "showdesktop.h"
 #include "panelbutton.h"
@@ -212,7 +214,7 @@ bool Kicker::highlightMenuItem(const QSt
 
 void Kicker::showKMenu()
 {
-    MenuManager::the()->showKMenu();
+    MenuManager::the()->kmenuAccelActivated();
 }
 
 void Kicker::popupKMenu(const QPoint &p)
Index: kicker/kicker/core/Makefile.am
===================================================================
--- kicker/kicker/core/Makefile.am.orig
+++ kicker/kicker/core/Makefile.am
@@ -1,6 +1,6 @@
 INCLUDES = -I$(srcdir)/../../libkicker -I../../libkicker \
-	 -I$(srcdir)/../ui -I$(srcdir)/../buttons -I$(top_srcdir)/libkonq \
-	 $(all_includes)
+	 -I../ui -I$(srcdir)/../ui -I$(srcdir)/../buttons -I$(top_srcdir)/libkonq \
+	 $(all_includes) $(LIBBEAGLE_CFLAGS) $(GLIB_CFLAGS)
 
 noinst_LTLIBRARIES = libkicker_core.la
 
Index: kicker/kicker/core/menumanager.cpp
===================================================================
--- kicker/kicker/core/menumanager.cpp.orig
+++ kicker/kicker/core/menumanager.cpp
@@ -31,9 +31,12 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include "client_mnu.h"
 #include "container_extension.h"
 #include "global.h"
+#include "k_new_mnu.h"
 #include "k_mnu.h"
+#include "k_mnu_stub.h"
 #include "kicker.h"
 #include "panelbutton.h"
+#include "kickerSettings.h"
 
 #include "menumanager.h"
 #include "menumanager.moc"
@@ -62,7 +65,11 @@ MenuManager* MenuManager::the()
 MenuManager::MenuManager(QObject *parent)
     : QObject(parent, "MenuManager"), DCOPObject("MenuManager")
 {
-    m_kmenu = new PanelKMenu;
+    if (KickerSettings::legacyKMenu()) 
+	m_kmenu = new KMenuStub(new PanelKMenu);
+    else
+	m_kmenu = new KMenuStub(new KMenu);
+
     kapp->dcopClient()->setNotifications(true);
     connect(kapp->dcopClient(), SIGNAL(applicationRemoved(const QCString&)),
             this, SLOT(applicationRemoved(const QCString&)));
@@ -83,14 +90,8 @@ void MenuManager::slotSetKMenuItemActive
     m_kmenu->selectFirstItem();
 }
 
-void MenuManager::showKMenu()
-{
-    m_kmenu->showMenu();
-}
-
 void MenuManager::popupKMenu(const QPoint &p)
 {
-//    kdDebug(1210) << "popupKMenu()" << endl;
     if (m_kmenu->isVisible())
     {
         m_kmenu->hide();
@@ -120,7 +121,7 @@ void MenuManager::unregisterKButton(Pane
     m_kbuttons.remove(button);
 }
 
-PanelPopupButton* MenuManager::findKButtonFor(QPopupMenu* menu)
+PanelPopupButton* MenuManager::findKButtonFor(QWidget* menu)
 {
     KButtonList::const_iterator itEnd = m_kbuttons.constEnd();
     for (KButtonList::const_iterator it = m_kbuttons.constBegin(); it != itEnd; ++it)
@@ -169,7 +170,7 @@ void MenuManager::kmenuAccelActivated()
         const QSize size = m_kmenu->sizeHint();
         m_kmenu->resize(size.width(),size.height());
 
-        PanelPopupButton* button = findKButtonFor(m_kmenu);
+        PanelPopupButton* button = findKButtonFor(m_kmenu->widget());
 
         // let's unhide the panel while we're at it. traverse the widget
         // hierarchy until we find the panel, if any
@@ -189,7 +190,6 @@ void MenuManager::kmenuAccelActivated()
 
             menuParent = menuParent->parent();
         }
-
         button->showMenu();
     }
 }
@@ -213,7 +213,7 @@ QCString MenuManager::createMenu(QPixmap
 
 void MenuManager::removeMenu(QCString menu)
 {
-    bool iterate = true;
+    bool iterate = true, need_adjustSize = false;
     ClientMenuList::iterator it = clientmenus.begin();
     for (; it != clientmenus.end(); iterate ? ++it : it)
     {
@@ -224,15 +224,17 @@ void MenuManager::removeMenu(QCString me
             m_kmenu->removeClientMenu(m->idInParentMenu);
             it = clientmenus.erase(it);
             iterate = false;
+            need_adjustSize = true;
         }
     }
-    m_kmenu->adjustSize();
+    if (need_adjustSize)
+        m_kmenu->adjustSize();
 }
 
 
 void MenuManager::applicationRemoved(const QCString& appRemoved)
 {
-    bool iterate = true;
+    bool iterate = true, need_adjustSize = false;
     ClientMenuList::iterator it = clientmenus.begin();
     for (; it != clientmenus.end(); iterate ? ++it : it)
     {
@@ -243,9 +245,11 @@ void MenuManager::applicationRemoved(con
             m_kmenu->removeClientMenu(m->idInParentMenu);
             it = clientmenus.erase(it);
             iterate = false;
+            need_adjustSize = true;
         }
     }
-    m_kmenu->adjustSize();
+    if (need_adjustSize)
+        m_kmenu->adjustSize();
 }
 
 bool MenuManager::process(const QCString &fun, const QByteArray &data,
Index: kicker/kicker/core/menumanager.h
===================================================================
--- kicker/kicker/core/menumanager.h.orig
+++ kicker/kicker/core/menumanager.h
@@ -28,7 +28,9 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include <qvaluelist.h>
 
 class PanelKMenu;
+class KMenu;
 class KickerClientMenu;
+class KMenuStub;
 class PanelPopupButton;
 
 typedef QValueList<PanelPopupButton*> KButtonList;
@@ -50,13 +52,12 @@ public:
     bool process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &reply);
 
     // KMenu controls
-    PanelKMenu* kmenu() { return m_kmenu; }
-    void showKMenu();
+    KMenuStub* kmenu() { return m_kmenu; }
     void popupKMenu(const QPoint &p);
 
     void registerKButton(PanelPopupButton *button);
     void unregisterKButton(PanelPopupButton *button);
-    PanelPopupButton* findKButtonFor(QPopupMenu* menu);
+    PanelPopupButton* findKButtonFor(QWidget* menu);
     ~MenuManager();
 
 public slots:
@@ -67,7 +68,7 @@ protected slots:
     void applicationRemoved(const QCString&);
 
 protected:
-    PanelKMenu* m_kmenu;
+    KMenuStub* m_kmenu;
     typedef QValueList<KickerClientMenu*> ClientMenuList;
     ClientMenuList clientmenus;
 
Index: kicker/kicker/interfaces/kickoffsearchinterface.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/interfaces/kickoffsearchinterface.cpp
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "kickoffsearchinterface.h"
+
+KickoffSearch::KickoffSearchInterface::KickoffSearchInterface( QObject* parent, const char* name )
+    :QObject( parent, name )
+{
+}
+
+#include "kickoffsearchinterface.moc"
Index: kicker/kicker/interfaces/kickoffsearchinterface.h
===================================================================
--- /dev/null
+++ kicker/kicker/interfaces/kickoffsearchinterface.h
@@ -0,0 +1,46 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef KICKOFFSEARCHINTERFACE_H
+#define KICKOFFSEARCHINTERFACE_H
+
+#include <qobject.h>
+
+class HitMenuItem;
+
+namespace KickoffSearch
+{
+    class KickoffSearchInterface :public QObject
+    {
+        Q_OBJECT
+
+    public:
+        KickoffSearchInterface( QObject* parent, const char* name = 0);
+
+    public:
+        virtual bool anotherHitMenuItemAllowed(int cat) = 0;
+        virtual void addHitMenuItem(HitMenuItem* item) = 0;
+        virtual void searchOver() = 0;
+        virtual void initCategoryTitlesUpdate() = 0;
+        virtual void updateCategoryTitles() = 0;
+    };
+}
+
+#endif /* SELECTIONINTERFACE_H */
+
Index: kicker/kicker/interfaces/kickoff-search-plugin.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/interfaces/kickoff-search-plugin.cpp
@@ -0,0 +1,37 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "kickoff-search-plugin.h"
+#include <qobjectlist.h>
+
+KickoffSearch::Plugin::Plugin(QObject *parent, const char* name )
+    :QObject( parent, name )
+{
+}
+
+KickoffSearch::Plugin::~Plugin()
+{
+}
+
+KickoffSearch::KickoffSearchInterface* KickoffSearch::Plugin::kickoffSearchInterface()
+{
+    return static_cast<KickoffSearchInterface*>( parent()->child( 0, "KickoffSearch::KickoffSearchInterface" ) );
+}
+
+#include "kickoff-search-plugin.moc"
Index: kicker/kicker/interfaces/kickoffsearchplugin.desktop
===================================================================
--- /dev/null
+++ kicker/kicker/interfaces/kickoffsearchplugin.desktop
@@ -0,0 +1,4 @@
+[Desktop Entry]
+Type=ServiceType
+X-KDE-ServiceType=KickoffSearch/Plugin
+Comment=A search plugin for Kickoff
Index: kicker/kicker/interfaces/kickoff-search-plugin.h
===================================================================
--- /dev/null
+++ kicker/kicker/interfaces/kickoff-search-plugin.h
@@ -0,0 +1,106 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef KICKOFF_SEARCH_PLUGIN_H
+#define KICKOFF_SEARCH_PLUGIN_H
+
+#include "kickoffsearchinterface.h"
+
+#include <qobject.h>
+#include <kurl.h>
+#include <kservice.h>
+
+typedef enum {
+    ACTIONS = 0,
+    APPS,
+    BOOKMARKS,
+    NOTES,
+    MAILS,
+    FILES,
+    MUSIC,
+    WEBHIST,
+    CHATS,
+    FEEDS,
+    PICS,
+    VIDEOS,
+    DOCS,
+    OTHER,
+    num_categories
+} CATEGORY;
+
+class HitMenuItem
+{
+public:
+    HitMenuItem (int id, int category)
+	: id (id), category (category),score(0) { } /* dummy */
+    HitMenuItem (QString name, QString info, KURL uri, QString mimetype, int id, int category, QString icon=QString::null, int score = 0)
+	: display_name (name)
+	, display_info (info)
+	, uri (uri)
+	, mimetype (mimetype)
+	, id (id)
+	, category (category)
+	, icon (icon)
+	, score (score)
+        , service (NULL) { }
+
+    ~HitMenuItem () { }
+
+    bool operator< (HitMenuItem item)
+    {
+	return ((category == item.category && score > item.score) || (category == item.category && id < item.id) ||
+		(category < item.category));
+    }
+
+    // FIXME: We dont really need to store display_name and display_info
+    QString display_name; // name to display
+    QString display_info; // other information to display
+    KURL uri; // uri to open when clicked
+    QString mimetype;
+    int id; // id of the item in the menu
+    int category;
+    QString icon;
+    int score;
+    KService::Ptr service;
+
+    QString quotedPath () const
+    {
+	return uri.path ().replace ('"', "\\\"");
+    }
+};
+
+namespace KickoffSearch {
+
+    class Plugin : public QObject
+    {
+        Q_OBJECT
+
+    public:
+        Plugin(QObject *parent, const char* name=0);
+        virtual ~Plugin();
+
+        virtual bool daemonRunning()=0;
+        virtual void query(QString,bool)=0;
+
+        KickoffSearchInterface * kickoffSearchInterface();
+    };
+};
+
+#endif /* KICKOFF_SEARCH_PLUGIN_H */
Index: kicker/kicker/interfaces/Makefile.am
===================================================================
--- /dev/null
+++ kicker/kicker/interfaces/Makefile.am
@@ -0,0 +1,12 @@
+METASOURCES = AUTO
+INCLUDES= -I$(top_srcdir)/src $(all_includes) 
+
+# The library containing the plugin base class
+lib_LTLIBRARIES =  libkickoffsearch_interfaces.la
+libkickoffsearch_interfaces_la_SOURCES = kickoff-search-plugin.cpp kickoffsearchinterface.cpp
+libkickoffsearch_interfaces_la_LDFLAGS = $(all_libraries) -version-info 0:0:0
+
+kickoffsearchincludedir = $(includedir)
+kickoffsearchinclude_HEADERS = kickoff-search-plugin.h kickoffsearchinterface.h
+
+kde_servicetypes_DATA = kickoffsearchplugin.desktop
Index: kicker/kicker/Makefile.am
===================================================================
--- kicker/kicker/Makefile.am.orig
+++ kicker/kicker/Makefile.am
@@ -1,6 +1,6 @@
 INCLUDES = $(all_includes)
 
-SUBDIRS = core ui buttons .
+SUBDIRS = core interfaces ui buttons plugins .
 
 bin_PROGRAMS =
 lib_LTLIBRARIES =
@@ -9,7 +9,7 @@ kdeinit_LTLIBRARIES = kicker.la
 CLEANFILES = dummy.cpp
 
 kicker_la_LIBADD = core/libkicker_core.la  buttons/libkicker_buttons.la \
-	ui/libkicker_ui.la ../libkicker/libkickermain.la $(LIB_KIO) $(LIB_KUTILS)
+	ui/libkicker_ui.la ../libkicker/libkickermain.la $(LIB_KIO) $(LIB_KUTILS) $(LIB_KABC)
 
 kicker_la_SOURCES = dummy.cpp
 kicker_la_LDFLAGS = -module $(KDE_PLUGIN) $(all_libraries)
Index: kicker/kicker/plugins/beaglesearch.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/plugins/beaglesearch.cpp
@@ -0,0 +1,362 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include "beaglesearch.h"
+
+#include <qdatetime.h>
+#include <qmutex.h>
+#include <qstringlist.h>
+#include <qapplication.h>
+#include <time.h>
+
+void beagle_init ()
+{
+    g_type_init ();
+}
+
+// ---------------- Hit ---------------------------
+
+Hit::Hit (BeagleHit *_hit) : processed (false)
+{
+    hit = beagle_hit_ref (_hit);
+}
+
+Hit::~Hit ()
+{
+    beagle_hit_unref (hit);
+    if (! processed)
+	return;
+    QDictIterator<QStringList> it (property_map);
+    for( ; it.current(); ++it )
+        ((QStringList *)it.current())->clear ();
+
+}
+
+void Hit::processProperties ()
+{
+    processed = true;
+    GSList *prop_list = beagle_hit_get_all_properties (hit);
+    GSList *it;
+    property_map.setAutoDelete (true);
+    for (it = prop_list; it; it = it->next) {
+        BeagleProperty *property = (BeagleProperty *) it->data;
+        QString key = QString::fromUtf8 (beagle_property_get_key (property));
+        if (! property_map [key])
+            property_map.insert (key, new QStringList ());
+        property_map [key]->append (QString::fromUtf8 (beagle_property_get_value (property)));
+    }
+    g_slist_free (prop_list);
+}
+
+const QString Hit::operator[] (QString prop_name)
+{
+    if (! processed)
+	processProperties ();
+
+    QStringList *prop_list = property_map [prop_name];
+    if (! prop_list)
+        return QString::null;
+    if (prop_list->count () != 1)
+        return QString::null;
+    return (QString)prop_list->first ();
+}
+
+// ---------------- BeagleSearch ------------------
+
+BeagleSearchResult::BeagleSearchResult(int client_id)
+  : client_id (client_id), total (0)
+{
+    hitlist = new QPtrList<Hit>;
+    hitlist->setAutoDelete (true);
+}
+
+
+BeagleSearchResult::~BeagleSearchResult()
+{
+    // everything is set to autodelete
+}
+
+void BeagleSearchResult::addHit(BeagleHit *_hit)
+{
+    Hit *hit = new Hit (_hit);
+    hitlist->prepend (hit);
+}
+
+const QPtrList<Hit> *BeagleSearchResult::getHits () const
+{
+    return hitlist;
+}
+
+
+static int total_hits;
+
+static void print_feed_item_hit (BeagleHit *hit)
+{
+    const char *text;
+
+    if (beagle_hit_get_one_property (hit, "dc:title", &text))
+        g_print ("Blog: %s\n", text);
+}
+
+static void print_file_hit (BeagleHit *hit)
+{
+    g_print ("File: %s, (%s)\n", beagle_hit_get_uri (hit), beagle_hit_get_mime_type (hit));
+}
+
+static void print_other_hit (BeagleHit *hit)
+{
+    const char *text;
+
+    g_print ("%s (%s)", beagle_hit_get_uri (hit),
+             beagle_hit_get_source (hit));
+    if (beagle_hit_get_one_property (hit, "dc:title", &text))
+        g_print ("title = %s\n", text);
+}
+
+static void print_hit (BeagleHit *hit) 
+{
+    if (strcmp (beagle_hit_get_type (hit), "FeedItem") == 0) {
+        print_feed_item_hit (hit);
+    } 
+    else if (strcmp (beagle_hit_get_type (hit), "File") == 0) {
+        print_file_hit (hit);
+    } else {
+        print_other_hit (hit);
+    }
+}
+
+// ---------------- BeagleSearchClient ------------------
+
+void BeagleSearchClient::run ()
+{
+    kdDebug () << "Starting query ..." << endl;
+
+    QTime query_timer;
+    query_timer.start ();
+    
+    g_signal_connect (query, "hits-added",
+                      G_CALLBACK (hitsAddedSlot),
+                      this);
+    g_signal_connect (query, "finished",
+                      G_CALLBACK (finishedSlot),
+                      this);
+    beagle_client_send_request_async (client,
+                                      BEAGLE_REQUEST (query),
+                                      NULL);
+    g_main_loop_run (main_loop);
+    kdDebug () << "Finished query ..." << endl;
+    
+    QCustomEvent *ev;
+    if (collate_results) {
+	result->query_msec = query_timer.elapsed ();
+    
+	ev =  new QCustomEvent (RESULTFOUND, result);
+        QApplication::postEvent (object, ev);
+    }
+
+    ev =  new QCustomEvent (KILLME, this);
+    QApplication::postEvent (object, ev);
+
+}
+
+void BeagleSearchClient::stopClient ()
+{
+   if (finished ())
+       return; // duh!
+   kdDebug () << "Query thread " << id << " not yet finished ..." << endl;
+   // get ready for suicide
+   client_mutex->lock ();
+   kill_me = true;
+   g_signal_handlers_disconnect_by_func (
+           query, 
+           (void *)hitsAddedSlot,
+           this);
+   g_signal_handlers_disconnect_by_func (
+           query,
+           (void *)finishedSlot,
+           this);
+   g_main_loop_quit (main_loop);
+   client_mutex->unlock ();
+}
+
+void BeagleSearchClient::hitsAddedSlot (BeagleQuery *query,
+                                        BeagleHitsAddedResponse *response,
+                                        BeagleSearchClient *bsclient)
+{
+    GSList *hits, *l;
+    gint    i;
+    gint    nr_hits;
+
+    // check if we are supposed to be killed
+    bsclient->client_mutex->lock ();
+    if (bsclient->kill_me) {
+        kdDebug () << "Suicide time before processing" << endl;
+	bsclient->client_mutex->unlock ();
+	return;
+    }
+    bsclient->client_mutex->unlock ();
+
+    hits = beagle_hits_added_response_get_hits (response);
+
+    nr_hits = g_slist_length (hits);
+    total_hits += nr_hits;
+    g_print ("Found hits (%d) at %ld:\n", nr_hits, time (NULL));
+
+    BeagleSearchResult *search_result;
+    if (! bsclient->collate_results)
+        search_result = new BeagleSearchResult (bsclient->id);
+    else
+        search_result = bsclient->result;
+    search_result->total += nr_hits;
+
+    for (l = hits, i = 1; l; l = l->next, ++i) {
+        //g_print ("[%d] ", i);
+        //print_hit (BEAGLE_HIT (l->data));
+        //g_print ("\n");
+
+        search_result->addHit(BEAGLE_HIT (l->data));//hit);
+    }
+    g_print ("[%ld] hits adding finished \n", time (NULL));
+
+    // check if we are supposed to be killed
+    bsclient->client_mutex->lock ();
+    if (bsclient->kill_me) {
+        kdDebug () << "Suicide time before sending ..." << endl;
+	bsclient->client_mutex->unlock ();
+	if (! bsclient->collate_results)
+	    delete search_result;
+	return;
+    }
+    bsclient->client_mutex->unlock ();
+
+    // time to send back results, if user asked so
+    if (bsclient->collate_results)
+        return;
+    QCustomEvent *ev =  new QCustomEvent (RESULTFOUND, search_result);
+    g_print ("[%ld] event notified \n", time (NULL));
+    QApplication::postEvent (bsclient->object, ev);
+}
+
+void BeagleSearchClient::finishedSlot (BeagleQuery *query,
+                                       BeagleFinishedResponse *response,
+                                       BeagleSearchClient *bsclient)
+{
+    // check if we are supposed to be killed
+    bsclient->client_mutex->lock ();
+    bool should_kill = bsclient->kill_me;
+    QObject* receiver = bsclient->object;
+    bsclient->client_mutex->unlock ();
+
+    if (should_kill)
+	return;
+
+    g_main_loop_quit (bsclient->main_loop);
+
+    if (bsclient->collate_results)
+        return; // if we are collating, everything will be send from a central place
+    if (receiver) {
+        QCustomEvent *ev =  new QCustomEvent (SEARCHOVER, bsclient);
+        g_print ("[%ld] query finish notified \n", time (NULL));
+        QApplication::postEvent (receiver, ev);
+    }
+}
+
+// ----------------- BeagleUtil -------------------
+
+BeagleQuery *
+BeagleUtil::createQueryFromString (QString query_str,
+                                    QStringList &sources_menu,
+                                    QStringList &types_menu,
+				    int max_hits_per_source)
+{
+    BeagleQuery *beagle_query = beagle_query_new ();
+    beagle_query_set_max_hits (beagle_query, max_hits_per_source); // this is per source!
+
+    kdDebug () << "Creating query from \"" << query_str << "\"" << endl;
+    for ( QStringList::Iterator it = sources_menu.begin(); it != sources_menu.end(); ++it )
+        beagle_query_add_source (beagle_query, g_strdup ((*it).utf8 ()));
+
+    for ( QStringList::Iterator it = types_menu.begin(); it != types_menu.end(); ++it )
+        beagle_query_add_hit_type (beagle_query, g_strdup ((*it).utf8 ()));
+
+    QStringList query_terms;
+    QString start_date, end_date;
+    QStringList words = QStringList::split (' ', query_str, false);
+    for ( QStringList::Iterator it = words.begin(); it != words.end(); ++it ) {
+        QStringList key_value_pair = QStringList::split ('=', *it, false);
+        if (key_value_pair.count () == 1)
+            query_terms += *it;
+        else if (key_value_pair.count () == 2) {
+            QString key = key_value_pair [0].lower ();
+            QString value = key_value_pair [1];
+            if (key == "mime")
+                beagle_query_add_mime_type (beagle_query, g_strdup (value.utf8 ()));
+            else if (key == "type")
+                beagle_query_add_hit_type (beagle_query, g_strdup (value.utf8 ()));
+            else if (key == "source")
+                beagle_query_add_source (beagle_query, g_strdup (value.utf8 ()));
+            else if (key == "start")
+                start_date = value;
+            else if (key == "end")
+                end_date = value;
+            else
+                query_terms += *it;
+        } else
+            query_terms += *it;
+    }
+
+    beagle_query_add_text (beagle_query, g_strdup (query_terms.join (" ").utf8 ()));
+    kdDebug () << "Adding query text:" << query_terms.join (" ").utf8 () << endl;
+
+    if (start_date.isNull () && end_date.isNull ())
+        return beagle_query;
+
+    //kdDebug () << "Handling dates ..." << endl;
+    BeagleQueryPartDate * date_part = beagle_query_part_date_new ();
+    if (! start_date.isNull ())
+        beagle_query_part_date_set_start_date (date_part, timestringToBeagleTimestamp (start_date));
+    if (! end_date.isNull ())
+        beagle_query_part_date_set_end_date (date_part, timestringToBeagleTimestamp (end_date));
+    beagle_query_add_part (beagle_query, BEAGLE_QUERY_PART (date_part));
+
+    return beagle_query;
+}
+
+// timestring format allowed YYYYmmDD
+BeagleTimestamp *
+BeagleUtil::timestringToBeagleTimestamp(QString timestring)
+{
+    //kdDebug () << "datetime string:" << timestring << endl;
+    // FIXME: error check timestring format
+    if (timestring.isNull () || timestring.stripWhiteSpace () == "" || timestring.length() != 8 )
+        return beagle_timestamp_new_from_unix_time (QDateTime::currentDateTime ().toTime_t ());
+    //QDateTime dt = QDateTime::fromString (timestring, Qt::ISODate);
+    struct tm tm_time;
+    time_t timet_time;
+    time (&timet_time);
+    localtime_r (&timet_time, &tm_time);
+    strptime (timestring.ascii(), "%Y%m%d", &tm_time);
+    tm_time.tm_sec = tm_time.tm_min = tm_time.tm_hour = 0;
+    //kdDebug() << asctime (&tm_time) << endl;
+    timet_time = mktime (&tm_time);
+    return beagle_timestamp_new_from_unix_time (timet_time);
+}
+
Index: kicker/kicker/plugins/beaglesearch.h
===================================================================
--- /dev/null
+++ kicker/kicker/plugins/beaglesearch.h
@@ -0,0 +1,234 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef BEAGLESEARCH_H
+#define BEAGLESEARCH_H
+
+#include <qdict.h>
+#include <qptrlist.h>
+#include <qthread.h>
+#include <qevent.h>
+#include <qmutex.h>
+
+#include <kdebug.h>
+#include <kurl.h>
+
+extern "C" {
+#include <glib.h>
+#include <beagle/beagle.h>
+}
+
+// BeagleSearchClient sends 3 types of events
+// when results are to be sent as they arrive,
+//  - RESULTFOUND : when result is found
+//  - SEARCHOVER :  when search is over
+//  - KILLME : just before thread finishes - used to cleanup the thread object
+// when results are to be sent after receiving all of them
+//  - RESULTFOUND : when all results are obtained
+//  - KILLME : just before thread finishes - used to cleanup the thread object
+#define RESULTFOUND (QEvent::Type)1001 /* QEvent::User + 1 */
+#define SEARCHOVER  (QEvent::Type)1002 /* QEvent::User + 2 */
+#define KILLME      (QEvent::Type)1003 /* QEvent::User + 3 */
+
+class QStringList;
+
+// IMPORTANT: Call this before any beagle calls
+void beagle_init ();
+
+class Hit {
+public:
+    Hit (BeagleHit *_hit);
+    ~Hit ();
+    
+    // convenience wrappers
+    // remember that the hit values are utf8 strings
+    const KURL getUri () const { return KURL (QString::fromUtf8 (beagle_hit_get_uri (hit)));}
+    const QString getType () const { return QString::fromUtf8 (beagle_hit_get_type (hit));}
+    const QString getMimeType () const { return QString::fromUtf8 (beagle_hit_get_mime_type (hit));}
+    const QString getSource () const { return QString::fromUtf8 (beagle_hit_get_source (hit));}
+    const KURL getParentUri () const { return KURL (QString::fromUtf8 (beagle_hit_get_parent_uri (hit)));}
+    const QDict<QStringList>& getAllProperties ()
+    {
+	if (! processed)
+	    processProperties ();
+	return property_map;
+    }
+    const QStringList* getProperties (QString prop_name)
+    {
+	if (! processed)
+	    processProperties ();
+	return property_map [prop_name];
+    }
+    const QString operator[] (QString prop_name);
+
+private:
+    BeagleHit *hit;
+    QDict<QStringList> property_map;
+    // not every hit may be used. so, do a lazy processing of property_map
+    bool processed;
+    void processProperties ();
+};
+
+class BeagleSearchResult{
+public:
+    BeagleSearchResult(int client_id);
+    ~BeagleSearchResult();
+    void addHit (BeagleHit *hit);
+    QString getHitCategory (Hit *hit);
+
+    // id of the bsclient
+    int client_id;
+    // time taken to finish query
+    int query_msec;
+    // total number of results in this query
+    int total;
+
+    const QPtrList<Hit> *getHits () const;
+
+private:
+    // lists of hits
+    QPtrList<Hit> *hitlist;
+};
+
+// caller should delete bsclient->result and bsclient
+class BeagleSearchClient : public QThread {
+public:
+    // passing NULL for client makes bsclient create client itself and
+    // delete it later
+    BeagleSearchClient (int id,
+                        QObject *y,
+                        BeagleClient *client,
+                        BeagleQuery *query,
+                        bool collate_results)
+    : id (id), kill_me (false), object (y), client (client),
+      query (query), destroy_client (false), collate_results (collate_results)
+    {
+        if (client == NULL) {
+	    client = beagle_client_new (NULL);
+            destroy_client = true;
+        }
+	
+//        if (client == NULL)
+//            throw -1;
+
+        main_loop = g_main_loop_new (NULL, FALSE);
+        if (collate_results)
+            result = new BeagleSearchResult (id);
+
+	client_mutex = new QMutex ();
+    }
+
+    // It is never safe to delete BeagleSearchClient directly, the thread might still be running
+    ~BeagleSearchClient ()
+    {
+	if (! finished ()) {
+	    kdDebug () << "Thread " << id << " still running. Waiting.........." << endl;
+	    wait ();
+	}
+
+        if (destroy_client)
+            g_object_unref (client);
+        g_main_loop_unref (main_loop);
+        g_object_unref (query);
+        kdDebug() << "Deleting client ..." << id << endl;
+	delete client_mutex;
+    }
+
+private:
+    static void hitsAddedSlot (BeagleQuery *query,
+                               BeagleHitsAddedResponse *response,
+                               BeagleSearchClient *bsclient);
+
+    static void finishedSlot (BeagleQuery  *query,
+                              BeagleFinishedResponse *response,
+                              BeagleSearchClient *bsclient);
+
+public:
+    // run() starts the query and sends the result as follows:
+    // - either wait till get back all results and send it as RESULTFOUND
+    // - or, send results as it gets them as RESULTFOUND and 
+    //       send SEARCHOVER when finished
+    // collate_results controls the behaviour
+    virtual void run ( );
+    
+    // after stopClient() is called, application can safely go and remove previous menu entries
+    // - i.e. after stopClient is called, app doesnt except the eventhandler to receive any results
+    // - use client_id to determine which is the current client, set it right after stopclient
+    // - Eventhandler checks client id, if it is current, it adds stuff to the menu
+    //   else, it discards everything
+    // Once eventhandler is being processed, doQuery() wont be called and vice versa
+    //   so no need to serialize eventhandler and doquery
+    //
+    // stopClient needs to make sure that once it is called, the thread is finished asap. Use a mutex
+    // to serialize actions. callbacks need to use mutex too.
+    // stopclient has to remove signal handlers to prevent further signal calls, set kill_me flag
+    //   and quite main loop
+    // stopClient can be called at the following times:
+    // - Waiting for the first result:
+    //   nothing extra
+    // - in hitsAddedSlot, processing results
+    //   in callback, before processing, if killme is set, just return.
+    // - in hitsAddedSlot, after sending results
+    //   before sending, if killme is set, dont send results
+    //   (doing it twice in hitsAdded because forming BeagleSearchResult can take time)
+    // - Waiting for more results
+    //   nothing extra
+    // - in finishedSlot, before sending finishedMsg
+    //   if killme is set, just return
+    // - in finishedSlot, after sending finishedMsg
+    //   if killme is set, just return
+    //  in Run(), when return from mainloop, if killme is set, dont do anything more but call delete this
+    void stopClient ();
+
+    // id of the client
+    // this is required in case applications fires many clients in rapid succession
+    int id;
+    
+    GMainLoop * main_loop;
+    BeagleSearchResult *result;
+    
+    // this is set if the client is obsolete now i.e.
+    // the application doesnt need the results from the client anymore
+    bool kill_me;
+private:
+    // the application; need this to send events to the application
+    QObject *object;
+    // mutex to control setting the kill_me shared variable
+    QMutex *client_mutex;
+    BeagleClient *client;
+    BeagleQuery *query;
+    // should the client be destroyed by the client
+    // if the client created it, then most probably it should
+    bool destroy_client;
+    bool collate_results;
+};
+
+class BeagleUtil {
+public:
+
+    static BeagleQuery *createQueryFromString (QString query_str,
+					       QStringList &sources,
+                                               QStringList &types,
+					       int max_hits_per_source = 100);
+    static BeagleTimestamp *timestringToBeagleTimestamp (QString timestring);
+};
+
+#endif
Index: kicker/kicker/plugins/kickoff-beagle-plugin.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/plugins/kickoff-beagle-plugin.cpp
@@ -0,0 +1,475 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "kickoff-beagle-plugin.h"
+
+#include <qregexp.h>
+#include <qtimer.h>
+
+#include <kapplication.h>
+#include <kdesktopfile.h>
+#include <kgenericfactory.h>
+#include <kservice.h>
+
+QString dc_identifier = "dc:identifier";
+QString dc_title = "dc:title";
+QString parent_dc_title = "parent:dc:title";
+QString exactfilename = "beagle:ExactFilename";
+QString fixme_name = "fixme:Name";
+QString beagle_filename = "beagle:Filename";
+QString fixme_attachment_title = "fixme:attachment_title";
+QString fixme_hasattachments = "fixme:hasAttachments";
+QString parent_prefix = "parent:";
+QString fixme_folder = "fixme:folder";
+QString fixme_categories = "fixme:Categories";
+QString fixme_comment = "fixme:Comment";
+QString fixme_width = "fixme:width";
+QString fixme_height = "fixme:height";
+QString fixme_from_address = "fixme:from_address";
+QString fixme_artist = "fixme:artist";
+QString fixme_album = "fixme:album";
+QString dc_source = "dc:source";
+QString dc_publisher = "dc:publisher";
+QString digikam_tag = "digikam:Tag";
+QString fixme_speakingto = "fixme:speakingto";
+QString fixme_starttime = "fixme:starttime";
+QString comma_string = ",";
+
+static CATEGORY getHitCategory (Hit *hit)
+{
+    QString hittype = hit->getType();
+    QString hitsource = hit->getSource();
+
+    // if hit source is None, dont handle it. Might be anthrax-envelope :)
+    if (hitsource.isNull())
+        return OTHER;
+
+    if (hitsource == "documentation")
+        return DOCS;
+
+    if (hittype == "IMLog")
+        return CHATS;
+
+    // sure shots
+    if (hittype == "FeedItem")
+        return FEEDS;
+    if (hittype == "WebHistory")
+        return WEBHIST;
+    if (hittype == "MailMessage")
+        return MAILS;
+    if (hittype == "Note")
+        return NOTES;
+
+    // check for applications
+    if (hittype == "File" && (*hit) ["beagle:FilenameExtension"] == ".desktop")
+        return APPS;
+
+    // check for music
+    QString hitmimetype = hit->getMimeType();
+    if (hitsource == "Amarok"
+        || hitmimetype.startsWith ("audio")
+        || hitmimetype == "application/ogg")
+        return MUSIC; // not an exhaustive search
+
+    // check for images from files
+    if (hitsource == "Files" && hitmimetype.startsWith ("image"))
+        return PICS;
+
+    if (hitsource == "Files" && hitmimetype.startsWith ("video"))
+        return VIDEOS;
+
+    if (hitsource == "Files")
+        return FILES;
+
+    return OTHER;
+}
+
+K_EXPORT_COMPONENT_FACTORY( kickoffsearch_beagle,
+                            KGenericFactory<KickoffBeaglePlugin>( "kickoffsearch_beagle" ) )
+
+KickoffBeaglePlugin::KickoffBeaglePlugin(QObject *parent, const char* name, const QStringList&)
+            : KickoffSearch::Plugin(parent, name ), genericTitle( true )
+{
+    g_type_init ();
+    current_beagle_client = NULL;
+}
+
+bool KickoffBeaglePlugin::daemonRunning()
+{
+    return beagle_util_daemon_is_running();
+}
+
+void KickoffBeaglePlugin::query(QString term, bool _genericTitle)
+{
+    genericTitle = _genericTitle;
+    current_query_str = term;
+
+    // Beagle search
+    if (current_beagle_client != NULL) {
+	kdDebug () << "Previous client w/id " << current_beagle_client->id << " still running ... ignoring it." << endl;
+	current_beagle_client->stopClient ();
+    }
+    current_beagle_client_id = KApplication::random ();
+    kdDebug () << "Creating client with id:" << current_beagle_client_id << endl;
+
+    BeagleClient *beagle_client = beagle_client_new (NULL);
+    if (beagle_client == NULL) {
+        kdDebug() << "beagle service not running ..." << endl;
+        return;
+    }
+
+    QStringList sources, types;
+    BeagleQuery *beagle_query = BeagleUtil::createQueryFromString (term, sources, types, 99); // maximum 99 results, if this doesnt work, blame the stars
+
+    current_beagle_client = new BeagleSearchClient (
+                                current_beagle_client_id,
+                                this,
+                                beagle_client,
+                                beagle_query,
+                                false);
+    current_beagle_client->start();
+//    kdDebug () << "Query dispatched at " << time (NULL) << endl;
+}
+
+void KickoffBeaglePlugin::cleanClientList ()
+{
+    toclean_list_mutex.lock ();
+    BeagleSearchClient *old_client = toclean_client_list.take (0);
+    if (old_client != NULL) { // failsafe
+	kdDebug () << "Cleanup old client " << old_client->id << endl;
+	delete old_client;
+    }
+    toclean_list_mutex.unlock ();
+}
+
+void KickoffBeaglePlugin::customEvent (QCustomEvent *e)
+{
+    if (e->type () == RESULTFOUND) {
+//        kdDebug () << "Quick query thread at " << time (NULL) << " with current_id=" << current_beagle_client_id <<  " finished ..." << endl;
+        BeagleSearchResult *result = (BeagleSearchResult *) e->data ();
+        if (current_beagle_client_id != result->client_id) {
+            kdDebug () << "Stale result from " << result->client_id << endl;
+	    delete result;
+	    // FIXME: Should I also free e ?
+        } else {
+            kdDebug () << "Good results ...total=" << result->total << endl;
+            showResults (result);
+        }
+        //KPassivePopup::message( "This is the message", this );
+    } else if (e->type () == SEARCHOVER) {
+        BeagleSearchClient *client = (BeagleSearchClient *) e->data ();
+	if (client == NULL) {
+//	    kdDebug () << "Query finished event at " << time (NULL) << " but client is already deleted" << endl;
+	    return;
+	}
+//        kdDebug () << "Query finished event at " << time (NULL) << " for id=" << client->id << endl;
+	if (current_beagle_client_id == client->id) {
+	    kickoffSearchInterface()->searchOver();
+ 	    current_beagle_client = NULL; // important !
+	}
+    } else if (e->type () == KILLME) {
+        BeagleSearchClient *client = (BeagleSearchClient *) e->data ();
+	if (client->finished ())
+	    delete client;
+	else {
+	    // add client to cleanup list
+	    toclean_list_mutex.lock ();
+	    toclean_client_list.append (client);
+	    kdDebug () << "Scheduling client to be deleted in 500ms" << endl;
+	    toclean_list_mutex.unlock ();
+	    QTimer::singleShot (500, this, SLOT (cleanClientList ()));
+	}
+    }
+}
+
+// this method decides what to display in the result list
+HitMenuItem *KickoffBeaglePlugin::hitToHitMenuItem (int category, Hit *hit)
+{
+    QString title, info, mimetype, icon;
+    int score = 0;
+    KURL uri;
+
+#if 0
+    kdDebug() << "*** " << hit->getUri() << endl;
+    QDict<QStringList> all = hit->getAllProperties();
+    QDictIterator<QStringList> it( all );
+    for( ; it.current(); ++it )
+        kdDebug() << it.currentKey() << ": " << *(it.current()) << endl;
+#endif
+
+    switch (category) {
+	case FILES:
+	    {
+		uri = hit->getUri ();
+		QString uristr = uri.path ();
+	    	title = (*hit) [exactfilename];
+	    	int last_slash = uristr.findRev ('/', -1);
+                info = i18n("Folder: %1").arg(last_slash == 0 ? "/" 
+                        : uristr.section ('/', -2, -2));
+	    }
+	    break;
+	case MAILS:
+	    {
+		QString prefix = QString::null;
+		bool is_attachment = ((*hit) [parent_prefix + fixme_hasattachments] == "true");
+		bool has_parent = (! hit->getParentUri ().isEmpty ());
+		bool parent_mbox_file = false;
+		if (has_parent)
+		    parent_mbox_file = ((*hit) [parent_prefix + fixme_folder] == QString::null);
+
+		// Logic:
+		// If has_parent == false, everything is normal
+		// If has_parent == true, parent_mbox_file == false, everything is normal, use uri
+		// FIXME: If has_parent == true, parent_mbox_file == true, ???
+		// If has_parent == true, is_attachment == true, hit is attach and access with prefix "parent:", use parenturi
+		// Else, not attachment (multipart), access with prefix "parent:", use parenturi
+
+		if (has_parent && !parent_mbox_file) {
+		    uri = hit->getParentUri ();
+		    prefix = parent_prefix;
+		    if (is_attachment)
+			title = (*hit) [fixme_attachment_title];
+		    if (title.isEmpty ())
+			title = (*hit) [prefix + dc_title];
+		    if (title.isEmpty ())
+			title = i18n("No subject");
+		    if (is_attachment)
+			title = title.prepend (i18n("(Attachment) "));
+		    info = (i18n("From %1").arg((*hit) [prefix + fixme_from_address]));
+		} else {
+		    uri = hit->getUri ();
+		    title = (*hit) [dc_title];
+		    info = (i18n("From %1").arg((*hit) [fixme_from_address]));
+		}
+	    }
+	    mimetype = "message/rfc822"; // to handle attachment results
+	    break;
+ 	case MUSIC:
+	    uri = hit->getUri ();
+	    title = (*hit) [exactfilename];
+	    {
+		QString artist = (*hit) [fixme_artist];
+		QString album = (*hit) [fixme_album];
+		if (! artist.isEmpty ())
+		    info = (i18n("By %1").arg(artist));
+		else if (! album.isEmpty ())
+		    info = (i18n("From Album %1").arg(album));
+		else {
+		    QString uristr = uri.path ();
+		    int last_slash = uristr.findRev ('/', -1);
+                    info = i18n("Folder: %1")
+                        .arg(last_slash == 0 ? "/" : uristr.section ('/', -2, -2));
+		}
+	    }
+	    break;
+ 	case VIDEOS:
+	    uri = hit->getUri ();
+	    title = (*hit) [exactfilename];
+	    {
+		QString uristr = uri.path ();
+		int last_slash = uristr.findRev ('/', -1);
+                info = i18n("Folder: %1").arg(last_slash == 0 ? "/" : uristr.section ('/', -2, -2));
+	    }
+	    break;
+	case WEBHIST:
+	    uri = hit->getUri ();
+	    title = (*hit) [dc_title];
+	    title = title.replace(QRegExp("\n")," ");
+	    mimetype = "text/html";
+	    if (title.isEmpty () || title.stripWhiteSpace ().isEmpty ()) {
+		title = uri.prettyURL ();
+	    } else {
+		info = uri.host () + uri.path ();
+	    }
+	    break;
+	case FEEDS:
+	    {
+		uri = KURL ((*hit) [dc_identifier]);
+	    	title = (*hit) [dc_title];
+	    	mimetype = "text/html";
+	    	QString publisher = (*hit) [dc_publisher];
+	    	QString source = (*hit) [dc_source];
+	    	if (! publisher.isEmpty ())
+	    	    info = publisher;
+	    	else if (! source.isEmpty ())
+	    	    info = source;
+	    }
+	    break;
+	case PICS:
+	    {
+		uri = hit->getUri ();
+		title = (*hit) [exactfilename];
+		QString width = (*hit) [fixme_width];
+		QString height = (*hit) [fixme_height];
+		if (width.isEmpty () || height.isEmpty ()) {
+		    QString uristr = uri.path ();
+		    int last_slash = uristr.findRev ('/', -1);
+                    info = i18n("Folder: %1")
+                        .arg(last_slash == 0 ? "/" : uristr.section ('/', -2, -2));
+		    break;
+		}
+		info = (QString (" (%1x%2)").arg (width).arg (height));
+		const QStringList *tags = hit->getProperties (digikam_tag);
+		if (tags == NULL)
+		    break;
+		QString tags_string = tags->join (comma_string);
+		info += (" " + tags_string);
+	    }
+	    break;
+	case APPS:
+	    {
+		uri = hit->getUri ();
+	    	title = (*hit) [dc_title];
+		KDesktopFile desktopfile(uri.path(),true);
+		if (genericTitle && !desktopfile.readGenericName().isEmpty()) {
+		  title = desktopfile.readGenericName();
+		  info = desktopfile.readName();
+		}
+		else {
+		  title = desktopfile.readName();
+		  info = desktopfile.readGenericName();
+		}
+		icon = desktopfile.readIcon();
+                QString input = current_query_str.lower();
+		QString command = desktopfile.readEntry("Exec");
+		if (command==input)
+                  score = 100;
+                else if (command.find(input)==0)
+                  score = 50;
+                else if (command.find(input)!=-1)
+                  score = 10;
+		else if (title==input)
+                  score = 100;
+                else if (title.find(input)==0)
+                  score = 50;
+                else if (title.find(input)!=-1)
+                  score = 10;
+	    	break;
+	    }
+	    break;
+	case NOTES:
+            {
+	        uri = hit->getUri ();
+	        title = (*hit) [dc_title];
+	        title = i18n("Title: %1").arg(title.isEmpty() ? i18n("Untitled") : title);
+
+	        if (hit->getSource()=="KNotes")
+                   icon="knotes";
+                else
+                   icon="contents2";
+            }
+	    break;
+	case CHATS:
+            {
+	        uri = hit->getUri ();
+	        title = (*hit) [fixme_speakingto];
+	        title = i18n("Conversation With %1").arg(title.isEmpty() ? i18n("Unknown Person") : title);
+	        QDateTime datetime;
+	        datetime = datetimeFromString((*hit) [fixme_starttime]);
+                info=i18n("Date: %1").arg(KGlobal::locale()->formatDateTime(datetime,false));
+	        if (hit->getMimeType()=="beagle/x-kopete-log")
+                   icon="kopete";
+                else
+                   icon="gaim";
+            }
+	    break;
+	case DOCS:
+	    {
+		uri = hit->getUri ();
+		title = (*hit) [dc_title];
+		if (title.isEmpty () || title.stripWhiteSpace ().isEmpty ())
+		    title = uri.prettyURL ();
+		else {
+			QString uristr = uri.path ();
+			int last_slash = uristr.findRev ('/', -1);
+                        info = i18n("Folder: %1").arg(last_slash == 0 ? "/" : uristr.section ('/',
+                                    -2, -2));
+		}
+	    }
+	    break;
+	default:
+	    return NULL;
+    }
+    if (mimetype.isEmpty ())
+	mimetype = hit->getMimeType ();
+    return new HitMenuItem (title, info, uri, mimetype, 0, category, icon, score);
+}
+
+void KickoffBeaglePlugin::showResults(BeagleSearchResult *result)
+{
+    if (result->total == 0 ) {
+	// Dont report error from here ...
+        kdDebug() << "No matches found" << endl;
+	delete result;
+	return;
+    }
+
+    const QPtrList<Hit> *hits = result->getHits();
+    if (hits == NULL) {
+        kdDebug () << "Hmm... null" << endl;
+	delete result;
+        return;
+    }
+    kickoffSearchInterface()->initCategoryTitlesUpdate();
+
+    QPtrListIterator<Hit> it (*hits);
+    Hit *hit;
+    for (; (hit = it.current ()) != NULL; ++it) {
+	CATEGORY category = getHitCategory (hit);
+
+	// if category is not handled, continue
+	if (category == OTHER)
+          continue;
+
+        if ( category == APPS ) {
+            // we need to check if this is useful
+            KService cs( hit->getUri().path() );
+            if ( cs.noDisplay() )
+                continue;
+        }
+
+        if (!kickoffSearchInterface()->anotherHitMenuItemAllowed(category))
+          continue;
+
+        HitMenuItem *hit_item = hitToHitMenuItem (category, hit);
+
+        if (!hit_item)
+	   continue;
+
+        kickoffSearchInterface()->addHitMenuItem(hit_item);
+    }
+
+    kickoffSearchInterface()->updateCategoryTitles();
+
+    delete result;
+}
+
+QDateTime KickoffBeaglePlugin::datetimeFromString( const QString& s)
+{
+      int year( s.mid( 0, 4 ).toInt() );
+      int month( s.mid( 4, 2 ).toInt() );
+      int day( s.mid( 6, 2 ).toInt() );
+      int hour( s.mid( 8, 2 ).toInt() );
+      int min( s.mid( 10, 2 ).toInt() );
+      int sec( s.mid( 12, 2 ).toInt() );
+      return QDateTime(QDate(year,month,day),QTime(hour,min,sec));
+}
+
+#include "kickoff-beagle-plugin.moc"
Index: kicker/kicker/plugins/kickoff-beagle-plugin.h
===================================================================
--- /dev/null
+++ kicker/kicker/plugins/kickoff-beagle-plugin.h
@@ -0,0 +1,64 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef CAPITALIZEPLUGIN_H
+#define CAPITALIZEPLUGIN_H
+
+#include "../interfaces/kickoff-search-plugin.h"
+#include "beaglesearch.h"
+
+class KickoffBeaglePlugin :public KickoffSearch::Plugin
+{
+    Q_OBJECT
+
+public:
+    KickoffBeaglePlugin(QObject *parent, const char* name, const QStringList&);
+
+    void query(QString, bool);
+    bool daemonRunning();
+
+protected slots:
+    // to clean beaglesearchclients
+    void cleanClientList ();
+
+private:
+    QString current_query_str;
+
+    // all beagle activity is done through the BSC object
+    BeagleSearchClient *current_beagle_client;
+
+    // used to send notification from the beagle thread to the main event loop
+    virtual void customEvent (QCustomEvent *e);
+
+    QPtrList<BeagleSearchClient> toclean_client_list;
+    QMutex toclean_list_mutex;
+
+    // show the results
+    void showResults (BeagleSearchResult *);
+    HitMenuItem *hitToHitMenuItem (int category, Hit *hit);
+
+    // use a different id for each bsc client, and use that to separate stale responses from current ones
+    int current_beagle_client_id;
+
+    bool genericTitle;
+    QDateTime datetimeFromString( const QString& );
+};
+
+#endif /* CAPITALIZEPLUGIN_H */
Index: kicker/kicker/plugins/kickoffsearch_beagle.desktop
===================================================================
--- /dev/null
+++ kicker/kicker/plugins/kickoffsearch_beagle.desktop
@@ -0,0 +1,6 @@
+[Desktop Entry]
+Name=Beagle Search
+Comment=Beagle search plugin for Kickoff search
+ServiceTypes=KickoffSearch/Plugin
+Type=Service
+X-KDE-Library=kickoffsearch_beagle
Index: kicker/kicker/plugins/Makefile.am
===================================================================
--- /dev/null
+++ kicker/kicker/plugins/Makefile.am
@@ -0,0 +1,24 @@
+INCLUDES    = -I$(top_srcdir)/interfaces $(all_includes) $(LIBBEAGLE_CFLAGS) $(GLIB_CFLAGS)
+METASOURCES = AUTO
+
+# Install this plugin in the KDE modules directory
+kde_module_LTLIBRARIES = kickoffsearch_beagle.la
+
+# Srcs for the plugin
+kickoffsearch_beagle_la_SOURCES = kickoff-beagle-plugin.cpp beaglesearch.cpp
+
+# Libs needed by the plugin
+kickoffsearch_beagle_la_LIBADD = $(LIB_KPARTS) ../interfaces/libkickoffsearch_interfaces.la \
+	$(LIBBEAGLE_LIBADD) $(GLIB_LIBADD)
+
+# LD flags for the plugin
+# -module says: this is a module, i.e. something you're going to dlopen
+# so e.g. it has no version number like a normal shared lib would have.
+kickoffsearch_beagle_la_LDFLAGS = -module $(KDE_PLUGIN) $(all_libraries)
+
+# Install the desktop file needed to detect the plugin
+kde_services_DATA = kickoffsearch_beagle.desktop
+
+# i18n translation messages
+messages: rc.cpp
+	$(XGETTEXT) *.cpp *.h -o $(podir)/kickoffsearch_beagle.pot
Index: kicker/kicker/ui/appletop_mnu.cpp
===================================================================
--- kicker/kicker/ui/appletop_mnu.cpp.orig
+++ kicker/kicker/ui/appletop_mnu.cpp
@@ -30,6 +30,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE 
 #include "appletop_mnu.h"
 #include "container_button.h"
 #include "containerarea.h"
+#include "kickerSettings.h"
 
 PanelAppletOpMenu::PanelAppletOpMenu(int actions, QPopupMenu *opMenu, const QPopupMenu* appletsMenu,
                                      const QString & title, const QString &icon,
@@ -159,6 +160,20 @@ PanelAppletOpMenu::PanelAppletOpMenu(int
         }
     }
 
+    if ((actions & PanelAppletOpMenu::KMenuEditor))
+    {
+        if (needSeparator)
+        {
+            insertSeparator();
+            needSeparator = false;
+        }
+
+        if (KickerSettings::legacyKMenu()) 
+          insertItem(SmallIcon("kmenu"), i18n("Switch to Kickoff Menu Style"), this, SLOT(toggleLegacy()));
+        else
+          insertItem(SmallIcon("about_kde"), i18n("Switch to KDE Menu Style"), this, SLOT(toggleLegacy()));
+    }
+
     if ((actions & PanelAppletOpMenu::KMenuEditor) && kapp->authorizeKAction("menuedit"))
     {
         if (needSeparator)
@@ -205,4 +220,11 @@ void PanelAppletOpMenu::keyPressEvent(QK
     QPopupMenu::keyPressEvent(e);
 }
 
+void PanelAppletOpMenu::toggleLegacy()
+{
+    KickerSettings::setLegacyKMenu(!KickerSettings::legacyKMenu());
+    KickerSettings::writeConfig();
+    Kicker::the()->restart();
+}
+
 #include "appletop_mnu.moc"
Index: kicker/kicker/ui/appletop_mnu.h
===================================================================
--- kicker/kicker/ui/appletop_mnu.h.orig
+++ kicker/kicker/ui/appletop_mnu.h
@@ -47,6 +47,9 @@ public:
 signals:
     void escapePressed();
 
+protected slots:
+    void toggleLegacy();
+
 protected:
     void keyPressEvent(QKeyEvent* e);
 };
Index: kicker/kicker/ui/default-favs
===================================================================
--- /dev/null
+++ kicker/kicker/ui/default-favs
@@ -0,0 +1,9 @@
+writer.desktop
+kde-konsole.desktop
+kde-Home.desktop
+mozillafirefox.desktop
+kde-Kontact.desktop
+kde-amarok.desktop
+gimp.desktop
+kde-Help.desktop
+
Index: kicker/kicker/ui/flipscrollview.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/flipscrollview.cpp
@@ -0,0 +1,300 @@
+/*****************************************************************
+
+Copyright (c) 2006 Will Stephenson <wstephenson@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <qhbox.h>
+#include <qheader.h>
+#include <assert.h>
+
+#include "itemview.h"
+#include "flipscrollview.h"
+
+
+/* Flip scroll steps, as percentage of itemview width to scroll per
+ * step.  Assumes the itemview is scrolled in ten steps */
+
+/* slow start, then fast */
+//static const double scrollSteps[] = { 0.05, 0.05, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125, 0.1125 };
+
+/* slow fast slow */
+//static const double scrollSteps[] = { 0.05, 0.05, 0.13, 0.13, 0.15, 0.13, 0.13, 0.13, 0.05, 0.05 };
+
+/* slow veryfast slow */
+static const double scrollSteps[] = { 0.03, 0.03, 0.147, 0.147, 0.147, 0.147, 0.147, 0.147, 0.03, 0.028 };
+;
+
+BackFrame::BackFrame( QWidget *parent )
+    : QFrame( parent ), mouse_inside( false )
+{
+    setFrameStyle( QFrame::NoFrame );
+    left_triangle.load( locate( "appdata", "pics/left_triangle.png" ) );
+}
+
+void BackFrame::drawContents( QPainter *p )
+{
+    QColor gray( 230, 230, 230 );
+    if ( mouse_inside )
+        p->fillRect( 3, 3, width() - 6, height() - 6, colorGroup().color( QColorGroup::Highlight ) );
+    else
+        p->fillRect( 3, 3, width() - 6, height() - 6, gray );
+    p->setPen( gray.dark(110) );
+    p->drawRect( 3, 3, width() - 6, height() - 6 );
+
+    int pixsize = ( width() - 6 ) * 3 / 5;
+    QImage i = left_triangle.convertToImage().smoothScale( pixsize, pixsize );
+    QPixmap tri;
+    tri.convertFromImage( i );
+
+    p->drawPixmap( ( width() - tri.width() ) / 2, ( height() - tri.height() ) / 2, tri );
+}
+
+void BackFrame::enterEvent( QEvent *e )
+{
+    mouse_inside = true;
+    update();
+}
+
+void BackFrame::leaveEvent( QEvent *e )
+{
+    mouse_inside = false;
+    update();
+}
+
+void BackFrame::mousePressEvent ( QMouseEvent * e )
+{
+    emit clicked();
+}
+
+FlipScrollView::FlipScrollView( QWidget * parent, const char * name )
+    : QScrollView( parent, name ), mState( StoppedLeft ), mScrollDirection( 1 ), mShowBack( false )
+{
+    setVScrollBarMode( QScrollView::AlwaysOff );
+    setHScrollBarMode( QScrollView::AlwaysOff );
+    setFrameStyle( QFrame::NoFrame );
+    mLeftView = new ItemView( this, "left_view" );
+    addChild( mLeftView );
+
+    mRightView = new ItemView( this, "right_view" );
+    addChild( mRightView );
+
+    mTimer = new QTimer( this, "mTimer" );
+    connect( mTimer, SIGNAL( timeout() ), SLOT( slotScrollTimer() ) );
+
+    connect( mLeftView, SIGNAL( startService(KService::Ptr) ),
+             SIGNAL( startService(KService::Ptr) ) );
+    connect( mLeftView, SIGNAL( startURL(const QString& ) ),
+             SIGNAL( startURL(const QString& ) ) );
+    connect( mLeftView, SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ),
+             SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ) );
+    connect( mRightView, SIGNAL( startService(KService::Ptr) ),
+             SIGNAL( startService(KService::Ptr) ) );
+    connect( mRightView, SIGNAL( startURL(const QString& ) ),
+             SIGNAL( startURL(const QString& ) ) );
+    connect( mRightView, SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ),
+             SIGNAL( rightButtonPressed(QListViewItem*,const QPoint&,int) ) );
+
+    // wild hack to make sure it has correct width
+    mLeftView->setVScrollBarMode( QScrollView::AlwaysOn );
+    mRightView->setVScrollBarMode( QScrollView::AlwaysOn );
+    mLeftView->setVScrollBarMode( QScrollView::Auto );
+    mRightView->setVScrollBarMode( QScrollView::Auto );
+
+    mBackrow = new BackFrame( this );
+    mBackrow->resize( 24, 100 );
+    connect( mBackrow, SIGNAL( clicked() ), SIGNAL( backButtonClicked() ) );
+}
+
+ItemView* FlipScrollView::prepareRightMove()
+{
+    if ( mState != StoppedLeft )
+    {
+        mTimer->stop();
+        ItemView *swap = mLeftView;
+        mLeftView = mRightView;
+        mRightView = swap;
+        moveChild( mLeftView, 0, 0 );
+        moveChild( mRightView, width(), 0 );
+        mBackrow->hide();
+        mRightView->resize( width(), height() );
+        mLeftView->resize( width(), height() );
+        setContentsPos( 0, 0 );
+    }
+
+    mState = StoppedLeft;
+    mRightView->clear();
+    return mRightView;
+}
+
+void FlipScrollView::showBackButton( bool enable )
+{
+    kdDebug() << "FlipScrollView::showBackButton " << enable << endl;
+    mShowBack = enable;
+}
+
+ItemView* FlipScrollView::prepareLeftMove(bool clear)
+{
+    if ( mState != StoppedRight )
+    {
+        mTimer->stop();
+        ItemView *swap = mLeftView;
+        mLeftView = mRightView;
+        mRightView = swap;
+        moveChild( mLeftView, 0, 0 );
+        moveChild( mRightView, width(), 0 );
+        mRightView->resize( width(), height() );
+        mLeftView->resize( width(), height() );
+        mBackrow->hide();
+        setContentsPos( width(), 0 );
+    }
+
+    mState = StoppedRight;
+    if (clear)
+        mLeftView->clear();
+    return mLeftView;
+}
+
+void FlipScrollView::viewportResizeEvent ( QResizeEvent * )
+{
+    mLeftView->resize( size() );
+    mRightView->resize( width() - mBackrow->width(), height() );
+    mBackrow->resize( mBackrow->width(), height() );
+    resizeContents( width() * 2, height() );
+    moveChild( mBackrow, width(), 0 );
+    moveChild( mRightView, width() + mBackrow->width(), 0 );
+    setContentsPos( 0, 0 );
+}
+
+ItemView *FlipScrollView::currentView() const
+{
+    if ( mState == StoppedRight )
+        return mRightView;
+    else
+        return mLeftView;
+}
+
+ItemView *FlipScrollView::leftView() const
+{
+    return mLeftView;
+}
+
+ItemView *FlipScrollView::rightView() const
+{
+    return mRightView;
+}
+
+FlipScrollView::~FlipScrollView() {}
+
+static const int max_steps = 10;
+
+void FlipScrollView::slotScrollTimer()
+{
+    mStepsRemaining--;
+    assert( mStepsRemaining >= 0 && mStepsRemaining < int(sizeof(  scrollSteps ) / sizeof( double )) );
+    scrollBy( ( int )( mScrollDirection * mLeftView->width() * scrollSteps[ mStepsRemaining ] ), 0 );
+    //scrollBy( mScrollDirection * mLeftView->width() / max_steps, 0 );
+
+    if ( mStepsRemaining == 0 )
+    {
+        if ( mState == ScrollingRight )
+        {
+            mState = StoppedRight;
+            setContentsPos( width(), 0 );
+        } else {
+            mState = StoppedLeft;
+            setContentsPos( 0, 0 );
+        }
+
+        kdDebug() << "slotScrollTimer " << mShowBack << endl;
+
+        if ( mShowBack )
+        {
+            mBackrow->show();
+            if ( mState == StoppedRight )
+            {
+                moveChild( mRightView, width() + mBackrow->width(), 0 );
+                mRightView->resize( width() - mBackrow->width(), height() );
+                mLeftView->resize( width(), height() );
+                moveChild( mBackrow, width(), 0 );
+                moveChild( mLeftView, 0, 0 );
+            } else
+            {
+                moveChild( mRightView, width(), 0 );
+                mRightView->resize( width(), height() );
+                mLeftView->resize( width() - mBackrow->width(), height() );
+                moveChild( mBackrow, 0, 0 );
+                moveChild( mLeftView, mBackrow->width(), 0 );
+            }
+        } else
+            mBackrow->hide();
+
+        if (!mSelectMenuPath.isEmpty()) {
+            if (mSelectMenuPath=="kicker:/goup/") {
+                currentView()->setSelected(currentView()->firstChild(),true);
+                currentView()->firstChild()->repaint();
+            }
+            else {
+                QListViewItem * child = currentView()->firstChild();
+                while( child ) {
+                    KMenuItem* kitem = dynamic_cast<KMenuItem*>(child);
+                    if (kitem && kitem->menuPath()==mSelectMenuPath) {
+                        currentView()->setSelected(child,true);
+                        kdDebug() << "child repaint\n";
+                        child->repaint();
+                        break;
+                    }
+                    child = child->nextSibling();
+                }
+            }
+        }
+        mLeftView->setVScrollBarMode( QScrollView::Auto );
+        mRightView->setVScrollBarMode( QScrollView::Auto );
+        mTimer->stop();
+	mLeftView->setMouseMoveSelects( true );
+	mRightView->setMouseMoveSelects( true );
+    }
+}
+
+void FlipScrollView::flipScroll(const QString& selectMenuPath)
+{
+    if ( mState == StoppedLeft )
+    {
+        mState = ScrollingRight;
+        mScrollDirection = 1;
+    }
+    else
+    {
+        mState = ScrollingLeft;
+        mScrollDirection = -1;
+    }
+
+    mLeftView->setVScrollBarMode( QScrollView::AlwaysOff );
+    mRightView->setVScrollBarMode( QScrollView::AlwaysOff );
+    mStepsRemaining = max_steps;
+    mTimer->start( 30 );
+    mSelectMenuPath = selectMenuPath;
+    if (!mSelectMenuPath.isEmpty()) {
+	mLeftView->setMouseMoveSelects( false );
+	mRightView->setMouseMoveSelects( false );
+    }
+}
+
+#include "flipscrollview.moc"
Index: kicker/kicker/ui/flipscrollview.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/flipscrollview.h
@@ -0,0 +1,117 @@
+/*****************************************************************
+
+Copyright (c) 2006 Will Stephenson <wstephenson@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+/*
+ * Flip scroll menu
+ * Each level of the menu is a separate QListView
+ * Child items are added to their own QListView.
+ * When a parent is clicked, we look up its child menu and insert
+ * that in a QScrollView, then scroll to it.
+ *
+ * Need to intercept QListViewItems' parent param and instead of
+ * inserting directly into parent, insert into parent item's listview
+ *
+ * So need
+ * - adapted QLVI
+ * - wrap QLV and offer same interface
+ */
+
+#ifndef FLIPSCROLLVIEW_H
+#define FLIPSCROLLVIEW_H
+
+#include <qscrollview.h>
+#include <qlistview.h>
+#include <qframe.h>
+#include <qtimer.h>
+#include <qpainter.h>
+#include <kstandarddirs.h>
+#include "service_mnu.h"
+
+class ItemView;
+
+class BackFrame : public QFrame
+{
+    Q_OBJECT
+
+public:
+    BackFrame( QWidget *parent );
+    virtual void drawContents( QPainter *p );
+
+    void enterEvent ( QEvent * );
+    void leaveEvent( QEvent * );
+    void mousePressEvent ( QMouseEvent * e );
+
+signals:
+    void clicked();
+
+private:
+    QPixmap left_triangle;
+    bool mouse_inside;
+};
+
+class FlipScrollView : public QScrollView
+{
+    Q_OBJECT
+public:
+    enum State{ StoppedLeft, StoppedRight, ScrollingLeft, ScrollingRight };
+    FlipScrollView( QWidget * parent = 0, const char * name = 0 );
+    ~FlipScrollView();
+
+    ItemView *currentView() const;
+    ItemView *leftView() const;
+    ItemView *rightView() const;
+    ItemView *prepareLeftMove(bool clear=true);
+    ItemView *prepareRightMove();
+
+    void flipScroll(const QString& selectMenuPath = QString::null);
+    void showBackButton(bool enable);
+
+protected slots:
+    void slotScrollTimer();
+
+signals:
+    void startService(KService::Ptr kservice);
+    void startURL(const QString& u);
+    void rightButtonPressed(QListViewItem*,const QPoint&,int);
+    void backButtonClicked();
+
+protected:
+    void viewportResizeEvent ( QResizeEvent * );
+
+private:
+    ItemView * mLeftView;
+    ItemView * mRightView;
+//  ItemView * mCurrentView;
+    int mStepsRemaining;
+    State mState;
+    QTimer * mTimer;
+    BackFrame *mBackrow;
+    QString mSelectMenuPath;
+    int mScrollDirection;
+    bool mShowBack;
+};
+
+
+
+
+#endif
Index: kicker/kicker/ui/itemview.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/itemview.cpp
@@ -0,0 +1,1242 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <dmctl.h>
+
+#include <qimage.h>
+#include <qpainter.h>
+#include <qstyle.h>
+#include <qwidgetstack.h>
+#include <qlayout.h>
+#include <qlabel.h>
+#include <qvbox.h>
+#include <qheader.h>
+#include <qdrawutil.h>
+#include <qdragobject.h>
+#include <qcursor.h>
+#include <qpaintdevicemetrics.h>
+#include <qbuffer.h>
+#include <qtooltip.h>
+#include <qstylesheet.h>
+#include <qiconview.h>
+
+#include <dcopclient.h>
+#include <kapplication.h>
+#include <kaboutkde.h>
+#include <kpixmapeffect.h>
+#include <kaction.h>
+#include <kbookmarkmenu.h>
+#include <kconfig.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kglobalsettings.h>
+#include <kiconloader.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kstandarddirs.h>
+#include <kcombobox.h>
+#include <kwin.h>
+#include <kdebug.h>
+#include <kmimetype.h>
+#include <kmultipledrag.h>
+
+#include "client_mnu.h"
+#include "container_base.h"
+#include "global.h"
+#include "kbutton.h"
+#include "kicker.h"
+#include "kickerSettings.h"
+#include "konqbookmarkmanager.h"
+#include "menuinfo.h"
+#include "menumanager.h"
+#include "popupmenutitle.h"
+#include "quickbrowser_mnu.h"
+#include "recentapps.h"
+
+#include "k_mnu.h"
+#include "k_new_mnu.h"
+#include "itemview.h"
+
+// --------------------------------------------------------------------------
+
+KMenuItem::~KMenuItem()
+{
+    ItemView *listview = dynamic_cast<ItemView*>( listView() );
+    if ( listview && listview->m_lastOne == this) {
+      listview->m_lastOne = 0;
+      listview->m_old_contentY = -1;
+    }
+}
+
+static double pointSize( double pixelSize, QPaintDevice *w )
+{
+    return pixelSize * 72. / QPaintDevice::x11AppDpiY( w->x11Screen () );
+}
+
+static int pixelSize( double pixelSize, QPaintDevice *w )
+{
+    return qRound( pixelSize * QPaintDevice::x11AppDpiY( w->x11Screen () ) / 72. );
+}
+
+void KMenuItem::init()
+{
+    setMultiLinesEnabled(true);
+    m_s = 0;
+    m_path = QString::null;
+    m_icon = QString::null;
+    m_menuPath = QString::null;
+    setDragEnabled(true);
+    m_has_children = false;
+    m_old_width = -1;
+    right_triangle.load( locate( "appdata", "pics/right_triangle.png" ) );
+}
+
+void KMenuItem::setTitle(const QString& txt)
+{
+    m_title = txt;
+    setText( 0, txt );
+    setup();
+}
+
+void KMenuItem::setToolTip(const QString& txt)
+{
+    m_tooltip = txt;
+}
+
+void KMenuItem::setDescription(const QString& txt)
+{
+    m_description = txt;
+    setup();
+}
+
+void KMenuItem::setIcon(const QString& icon, int size)
+{
+    m_icon = icon;
+    QListViewItem::setPixmap(0, KGlobal::iconLoader()->loadIcon(icon, KIcon::Panel, size ));
+}
+
+void KMenuItem::setHasChildren( bool flag )
+{
+    m_has_children = flag;
+    repaint();
+}
+
+void KMenuItem::setup()
+{
+    // if someone configured a larger generalFont than 10pt, he might have a _real_ problem with 7pt
+    // the 7pt could be read out of konquerorrc I guess
+    float min_font_size = 7. * QMAX(1., KGlobalSettings::generalFont().pointSizeFloat() / 10.);
+
+    const int expected_height = 38;
+    description_font_size = QMAX( pointSize( expected_height * .3, listView() ), min_font_size );
+    title_font_size = QMAX( pointSize( expected_height * .25, listView() ), min_font_size + 1 );
+
+    //kdDebug() << description_font_size << " " << title_font_size << " " << pointSize( expected_height * .25, listView() ) << endl;
+    QListViewItem::setup();
+    setHeight( (int)QMAX( expected_height, pixelSize( title_font_size + description_font_size * 2.3, listView())));
+}
+
+int KMenuItem::width ( const QFontMetrics & , const QListView * lv, int  )
+{
+    return lv->viewport()->width();
+}
+
+void KMenuItem::paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align)
+{
+    ItemView *listview = static_cast<ItemView*>( listView() );
+    int bottom = listView()->itemRect( this ).bottom();
+    int diff = bottom - listView()->viewport()->height();
+
+    KPixmap pm;
+    pm.resize( width, height() );
+    QPainter pp( &pm );
+    paintCellInter( &pp, cg, column, width, align );
+    pp.end();
+
+    if ( diff > 0 && diff <= height() ) // cut off
+    {
+        pm.resize( width, height() - diff );
+        KPixmapEffect::blend( pm, float( diff ) / height(),
+                              cg.color( QColorGroup::Background ),
+                              KPixmapEffect::VerticalGradient );
+        p->drawPixmap( 0, 0, pm );
+        if ( listview->m_lastOne != this )
+        {
+            listview->m_lastOne = this;
+            listview->m_old_contentY = -1;
+        }
+    }
+    else
+    {
+        p->drawPixmap( 0, 0, pm );
+        if ( this == listview->m_lastOne ) {
+            if ( bottom < 0 )
+                listview->m_lastOne = static_cast<KMenuItem*>( itemAbove() );
+            else
+                listview->m_lastOne = static_cast<KMenuItem*>( itemBelow() );
+            listview->m_old_contentY = -1;
+            repaint();
+        }
+    }
+}
+
+void KMenuItem::makeGradient( KPixmap &off, const QColor &c )
+{
+    KPixmap blend;
+    blend.resize( off.width() / 3, off.height() );
+    bitBlt( &blend, 0, 0, &off, off.width() - blend.width(), 0, blend.width(), blend.height() );
+    KPixmapEffect::blend( blend, 0.2, c, KPixmapEffect::HorizontalGradient );
+    QPainter p( &off );
+    p.drawPixmap( off.width() - blend.width(), 0, blend );
+    p.end();
+}
+
+void KMenuItem::paintCellInter(QPainter* p, const QColorGroup & cg, int column, int width, int align)
+{
+    const BackgroundMode bgmode = listView()->viewport()->backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+    QColor backg = cg.color( crole );
+
+    if ( isSelected() )
+        backg = cg.color( QColorGroup::Highlight );
+    p->fillRect( 0, 0, width, height(), backg );
+
+    QFontMetrics fm( p->fontMetrics() );
+
+    int pixsize = 32;
+    if ( height() < 36 )
+        pixsize = 16;
+    const int left_margin = 30;
+    const int margin = 3;
+
+//    p->drawText( 2, 2, left_margin - 2, height(), align, QString::number( childCount () ) );
+
+    const QPixmap * pix = pixmap( column );
+
+    if ( pix )
+    {
+        QPixmap pix32 = *pix;
+
+        if ( pix->width() > pixsize )
+        {
+            QImage i = pix->convertToImage().smoothScale( pixsize, pixsize );
+            pix32.convertFromImage( i );
+        }
+        p->drawPixmap( (pixsize - pix32.width()) / 2 + left_margin,
+                       ( height() - pix32.height() ) / 2, pix32 );
+    }
+
+    if ( m_title.isEmpty() )
+        return;
+
+    int r = left_margin + pixsize + margin * 2;
+
+    QFont f1 = p->font();
+    f1.setPointSizeFloat( title_font_size );
+    f1.setWeight( QFont::Normal ); // QFont::DemiBold == 63
+
+    QFont f2 = p->font();
+    f2.setPointSizeFloat( description_font_size );
+    f2.setWeight( QFont::Light );
+
+    int f1h = QFontMetrics( f1 ).height();
+    int f2h = QFontMetrics( f2 ).height();
+
+    const int text_margin = 2;
+    int spacing = ( height() - f1h - f2h - text_margin ) / 2;
+    if ( m_description.isEmpty() )
+        spacing = ( height() - f1h ) / 2;
+
+    int right_triangle_size = pixelSize( 7, listView() );
+
+    int right_margin = listView()->verticalScrollBar()->width();
+    if ( m_has_children )
+        right_margin += right_triangle_size * 2;
+
+    KPixmap off;
+    QPainter pp;
+
+    off.resize( width-text_margin-r-right_margin, height() );
+    pp.begin( &off );
+    pp.fillRect( 0, 0, off.width(), off.height(), backg );
+
+    if (isSelected())
+       pp.setPen( cg.color( QColorGroup::HighlightedText ) );
+    else
+       pp.setPen( cg.color( QColorGroup::Text ) );
+
+    pp.setFont( f1 );
+    pp.drawText( 0, 0, off.width(), off.height(), align, m_title );
+    pp.end();
+    if ( QFontMetrics( f1 ).width( m_title ) > off.width() )
+    {
+        makeGradient( off, backg );
+        if ( !m_description.isEmpty() )
+            setToolTip( m_title + "<br><br>" + m_description );
+        else
+            setToolTip( m_title );
+    }
+    p->drawPixmap( r, spacing, off );
+
+    if ( !m_description.isEmpty() )
+    {
+        pp.begin( &off );
+        pp.fillRect( 0, 0, off.width(), off.height(), backg );
+
+        QColor myColor = cg.color( QColorGroup::Text ).light( 200 );
+        if ( qGray( myColor.rgb() ) == 0 )
+            myColor = QColor( 100, 100, 110 );
+        pp.setPen( myColor );
+        pp.setPen( isSelected() ? cg.color( QColorGroup::Mid ) : myColor );
+        pp.setFont( f2 );
+        pp.drawText( 0, 0, off.width(), off.height(), align, m_description );
+        pp.end();
+        if ( QFontMetrics( f2 ).width( m_description ) > off.width() )
+        {
+            makeGradient( off, backg );
+            setToolTip( m_title + "<br><br>" + m_description );
+        }
+        p->drawPixmap( r, spacing + text_margin + f1h, off );
+    }
+
+    if ( m_has_children )
+    {
+        QImage i = right_triangle.convertToImage().smoothScale( right_triangle_size,
+                                                                right_triangle_size );
+        QPixmap tri;
+        tri.convertFromImage( i );
+
+        p->drawPixmap( listView()->width() -  right_margin, ( height() - f1h ) / 2, tri );
+    }
+
+    if ( m_old_width != width )
+    {
+        // the listview caches paint events
+        m_old_width = width;
+        repaint();
+    }
+}
+
+// --------------------------------------------------------------------------
+
+KMenuItemSeparator::KMenuItemSeparator(int nId, QListView* parent)
+    : KMenuItem(nId, parent), lv(parent), cached_width( 0 )
+{
+    setEnabled(false);
+    left_margin = 15;
+}
+
+void KMenuItemSeparator::setup()
+{
+    KMenuItem::setup();
+
+    QFont f = QFont();
+    QFontMetrics fm(f);
+    f.setPointSize( 8 );
+    if ( itemAbove() && !text( 0 ).isEmpty() )
+        setHeight( (int)QMAX( 34., fm.height() * 1.4) );
+    else
+        setHeight( (int)QMAX( 26., fm.height() * 1.4 ) );
+}
+
+void KMenuItemSeparator::setLink( const QString &text, const QString &url )
+{
+    m_link_text = text;
+    m_link_url = url;
+    m_link_rect = QRect();
+}
+
+bool KMenuItemSeparator::hitsLink( const QPoint &pos )
+{
+    return m_link_rect.contains( pos );
+}
+
+void KMenuItemSeparator::preparePixmap( int width )
+{
+    if ( cached_width != width )
+    {
+        pixmap.load( locate("data", "kicker/pics/menu_separator.png" ) );
+        QImage i = pixmap.convertToImage().smoothScale( width - 15 - left_margin, pixmap.height() );
+        pixmap.convertFromImage( i );
+        cached_width = width;
+    }
+}
+
+void KMenuItemSeparator::paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align)
+{
+    preparePixmap(width);
+
+    const int h = height();
+
+    if (text(0).isEmpty()) {
+      KMenuItem::paintCell(p, cg, column, width, align);
+      p->drawPixmap( 15 , h/2, pixmap );
+    }
+    else {
+      const BackgroundMode bgmode = lv->viewport()->backgroundMode();
+      const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+      p->fillRect( 0, 0, width, h, cg.brush( crole ) );
+
+      int margin = 0;
+      if ( itemAbove() ) {
+          p->drawPixmap( 15 , h/4, pixmap );
+          margin = h / 4;
+      }
+      QFont f = listView()->font();
+      f.setWeight( QFont::Normal );
+      f.setPointSize( 8 );
+      p->setFont( f );
+      QColor myColor = cg.color( QColorGroup::Text ).light( 200 );
+      if ( qGray( myColor.rgb() ) == 0 )
+          myColor = QColor( 100, 100, 110 );
+      p->setPen( myColor );
+      int twidth = p->fontMetrics().width(text(0));
+      int lwidth = 0;
+      int swidth = 0;
+      int fwidth = 0;
+
+      if ( !m_link_text.isEmpty() )
+      {
+          swidth = p->fontMetrics().width( " (" );
+          lwidth = p->fontMetrics().width(m_link_text );
+          fwidth = p->fontMetrics().width( ")" );
+      }
+      int pos = int(lv->width() * 0.9 - twidth - swidth - lwidth - fwidth);
+      p->drawText( pos, margin + 5,
+                   width, h - ( margin +5 ), AlignTop, text(0) );
+      if ( !m_link_text.isEmpty() )
+      {
+          pos += twidth;
+          p->drawText( pos, margin + 5,
+                       width, h - ( margin +5 ), AlignTop, " (" );
+          pos += swidth;
+          p->setPen( cg.color( QColorGroup::Link ) );
+          f.setUnderline( true );
+          p->setFont( f );
+          p->drawText( pos, margin + 5,
+                       width, h - ( margin +5 ), AlignTop, m_link_text );
+          m_link_rect = QRect( pos, margin + 5, lwidth, p->fontMetrics().height() );
+          pos += lwidth;
+          f.setUnderline( false );
+          p->setFont( f );
+          p->drawText( pos, margin + 5,
+                       width, h - ( margin +5 ), AlignTop, ")" );
+      }
+    }
+}
+
+KMenuItemHeader::KMenuItemHeader(int nId, const QString& relPath, QListView* parent)
+    : KMenuItemSeparator(nId, parent)
+{
+    setEnabled( false );
+    QString path;
+    if (relPath.startsWith( "new/" /*"kicker:/new/"*/ )) {
+       paths.append( "kicker:/goup/" );
+       texts.append( i18n("New Applications") );
+       icons.append( "clock" );
+    }
+    else if (relPath == "kicker:/restart/") {
+       texts.append( i18n("Restart Computer") );
+    }
+    else if (relPath == "kicker:/switchuser/") {
+       texts.append( i18n("Switch User") );
+    }
+    else {
+      KServiceGroup::Ptr subMenuRoot = KServiceGroup::group(relPath);
+      QStringList items = QStringList::split( '/', relPath );
+      for ( QStringList::ConstIterator it = items.begin(); it != items.end(); ++it )
+      {
+        path += *it + "/";
+        paths.append( "kicker:/goup/" + path );
+        KServiceGroup::Ptr subMenuRoot = KServiceGroup::group(path);
+        QString groupCaption = subMenuRoot->caption();
+        texts.append( groupCaption );
+        icons.append( subMenuRoot->icon() );
+      }
+    }
+
+    setPath( "kicker:/goup/" + path ); // the last wins for now
+    left_margin = 10;
+}
+
+void KMenuItemHeader::setup()
+{
+    KMenuItem::setup();
+
+    QFontMetrics fm( listView()->font() );
+    setHeight( QMAX( int( texts.count() * fm.height() + ( texts.count() + 1 ) * 2 + 10 ), height()) );
+    // nada
+}
+
+void KMenuItemHeader::paintCell(QPainter* p, const QColorGroup & cg, int , int width, int align )
+{
+    preparePixmap(width);
+
+    const BackgroundMode bgmode = listView()->viewport()->backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+
+    QBrush br = cg.brush( crole );
+    if ( isSelected() ) {
+        br = cg.brush( QColorGroup::Highlight );
+        p->fillRect( 0, 0, width, height() - 3, br );
+    } else {
+        p->fillRect( 0, 0, width, height(), br );
+    }
+
+    QFontMetrics fm( p->fontMetrics() );
+    const int left_margin = 10;
+
+    const int margin = 3;
+
+    int r = left_margin + margin * 2;
+
+    const int min_font_size = 7;
+    int title_font_size = qRound( pixelSize( QMAX( pointSize( 12, listView() ), min_font_size + 1 ), listView() ) );
+
+    QFont f1 = p->font();
+    f1.setPixelSize( title_font_size );
+    p->setFont( f1 );
+    int f1h = QFontMetrics( f1 ).height();
+
+    p->setPen( cg.color( QColorGroup::Text ) );
+
+    const int text_margin = 2;
+    int spacing = ( height() - texts.count() * f1h - QMAX( texts.count() - 1, 0 ) * text_margin ) / 2;
+
+    for ( uint i = 0; i < texts.count(); ++i )
+    {
+        if (i==texts.count()-1) {
+            f1.setWeight( QFont::DemiBold );
+            p->setFont( f1 );
+            f1h = QFontMetrics( f1 ).height();
+        }
+
+        p->drawText( r, spacing, width-text_margin-r, height(), align, texts[i] );
+        spacing += text_margin + f1h;
+        r += title_font_size;
+    }
+
+    p->drawPixmap( left_margin , height() - 2, pixmap );
+}
+
+KMenuSpacer::KMenuSpacer(int nId, QListView* parent)
+    : KMenuItem(nId, parent)
+{
+    setEnabled(false);
+}
+
+void KMenuSpacer::setup()
+{
+    // nada
+}
+
+void KMenuSpacer::paintCell(QPainter* p, const QColorGroup & cg, int , int width, int )
+{
+    const BackgroundMode bgmode = listView()->viewport()->backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+    QBrush br = cg.brush( crole );
+
+    p->fillRect( 0, 0, width, height(), br );
+}
+
+void KMenuSpacer::setHeight( int i )
+{
+    KMenuItem::setHeight( i );
+}
+
+class ItemViewTip : public QToolTip
+{
+public:
+    ItemViewTip( QWidget *parent, QListView *lv );
+
+    void maybeTip( const QPoint &pos );
+
+private:
+    QListView *view;
+
+};
+
+ItemViewTip::ItemViewTip( QWidget *parent, QListView *lv )
+    : QToolTip( parent ), view( lv )
+{
+}
+
+void ItemViewTip::maybeTip( const QPoint &pos )
+{
+    KMenuItem *item = dynamic_cast<KMenuItem*>( view->itemAt( pos ) );
+    QPoint contentsPos = view->viewportToContents( pos );
+    if ( !item )
+        return;
+
+    if ( item->toolTip().isNull() )
+        return;
+
+    QRect r = view->itemRect( item );
+    int headerPos = view->header()->sectionPos( 0 );
+    r.setLeft( headerPos );
+    r.setRight( headerPos + view->header()->sectionSize( 0 ) );
+    tip( r, item->toolTip() );
+}
+
+// --------------------------------------------------------------------------
+
+ItemView::ItemView(QWidget* parent, const char* name)
+    : KListView(parent, name), m_spacer( 0 ),
+      m_mouseMoveSelects(true), m_iconSize(32)
+{
+    setHScrollBarMode( QScrollView::AlwaysOff );
+    setFrameStyle( QFrame::NoFrame );
+    setSelectionMode(QListView::Single);
+    addColumn("");
+    header()->setStretchEnabled(1, 0);
+    //setColumnWidthMode(0, QListView::Maximum);
+    header()->hide();
+    setMouseTracking(true);
+    setItemMargin(0);
+    setSorting(-1);
+    setTreeStepSize(38);
+    setFocusPolicy(QWidget::NoFocus);
+
+    m_lastOne = 0;
+    m_old_contentY = -1;
+
+    connect(this, SIGNAL(mouseButtonClicked( int, QListViewItem*, const QPoint &, int )),
+                  SLOT(slotItemClicked(int, QListViewItem*, const QPoint &, int)));
+
+    connect(this, SIGNAL(returnPressed(QListViewItem*)), SLOT(slotItemClicked(QListViewItem*)));
+    connect(this, SIGNAL(spacePressed(QListViewItem*)), SLOT(slotItemClicked(QListViewItem*)));
+
+    new ItemViewTip( viewport(), this );
+}
+
+KMenuItemHeader *ItemView::insertHeader(int id, const QString &relpath)
+{
+    KMenuItemHeader *newItem = new KMenuItemHeader(id, relpath, this );
+    moveItemToIndex(newItem, 1);
+    setBackPath( "kicker:/goup/" + relpath ); // the last wins for now
+
+    return newItem;
+}
+
+KMenuItem* ItemView::findItem(int nId)
+{
+    for (QListViewItemIterator it(this); it.current(); ++it)
+    {
+	if(static_cast<KMenuItem*>(it.current())->id() == nId)
+	    return static_cast<KMenuItem*>(it.current());
+    }
+
+    return 0L;
+}
+
+bool ItemView::focusNextPrevChild(bool /*next*/)
+{
+    return false;
+}
+
+KMenuItem* ItemView::itemAtIndex(int nIndex)
+{
+    if(nIndex <= 0)
+	return 0L;
+
+    if(nIndex >= childCount())
+      return static_cast<KMenuItem*>(lastItem());
+
+    int i = 1;
+    QListViewItemIterator it(this);
+    for (;it.current(); ++i, ++it) {
+	if(i == nIndex)
+	    return static_cast<KMenuItem*>(it.current());
+    }
+
+    return static_cast<KMenuItem*>(lastItem());
+}
+
+KMenuItem* ItemView::insertItem( const QString& icon, const QString& text, const QString& description, const
+                                 QString& path, int nId, int nIndex, KMenuItem *parent)
+{
+    KMenuItem* newItem = findItem(nId);
+
+    if(!newItem && parent)
+        newItem = new KMenuItem(nId, parent );
+    else if ( !newItem )
+	newItem = new KMenuItem(nId, this );
+
+    newItem->setIcon(icon, m_iconSize);
+    newItem->setTitle(text);
+    newItem->setDescription(description);
+    newItem->setPath(path);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+KMenuItem* ItemView::insertItem( const QString& icon, const QString& text, const QString& description,
+                                 int nId, int nIndex, KMenuItem *parent)
+{
+   return insertItem( icon, text, description, QString::null, nId, nIndex, parent);
+}
+
+int ItemView::setItemEnabled(int id, bool enabled)
+{
+    KMenuItem* item = findItem(id);
+
+    if(item)
+	item->setEnabled(enabled);
+
+    return 0;
+}
+
+KMenuItemSeparator *ItemView::insertSeparator(int nId, const QString& text, int nIndex)
+{
+    KMenuItemSeparator *newItem = new KMenuItemSeparator(nId, this);
+
+    newItem->setText(0, text);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+    return newItem;
+}
+
+void ItemView::moveItemToIndex(KMenuItem* item, int nIndex)
+{
+
+    if (nIndex <= 0) {
+          takeItem(item);
+          KListView::insertItem(item);
+    }
+    else {
+        item->moveItem(itemAtIndex(nIndex));
+    }
+}
+
+void ItemView::slotMoveContent()
+{
+    if ( !m_spacer )
+        return;
+
+    int item_height = 0;
+    QListViewItemIterator it( this );
+    while ( it.current() ) {
+        if ( !dynamic_cast<KMenuSpacer*>( it.current() ) && !it.current()->parent() && it.current()->isVisible() )  {
+            it.current()->invalidateHeight();
+            item_height += it.current()->totalHeight();
+        }
+        ++it;
+    }
+
+    if ( height() > item_height )
+        m_spacer->setHeight( height() - item_height );
+    else
+        m_spacer->setHeight( 0 );
+}
+
+KMenuItem *ItemView::insertMenuItem(KService::Ptr& s, int nId, int nIndex, KMenuItem* parentItem,
+                                    const QString& aliasname, const QString & label, const QString & categoryIcon )
+{
+    if (!s)
+	return 0;
+
+    QString serviceName = aliasname.isEmpty() ? s->name() : aliasname;
+
+    kdDebug() << "insertMenuItem " << nId << " " << nIndex << " " << s->name() << endl;
+    KMenuItem* newItem = 0; //findItem(nId);
+    if(!newItem)
+	newItem = parentItem ? new KMenuItem(nId, parentItem) : new KMenuItem(nId, this);
+
+    newItem->setIcon(s->icon()=="unknown" ? categoryIcon : s->icon(), m_iconSize);
+    if ((KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat()
+            == KickerSettings::DescriptionOnly) && !s->genericName().isEmpty()) {
+      newItem->setTitle(s->genericName());
+      newItem->setDescription(label.isEmpty() ? serviceName : label);
+    }
+    else {
+      newItem->setTitle(label.isEmpty() ? serviceName : label);
+      newItem->setDescription(s->genericName());
+    }
+    newItem->setService(s);
+
+    if (nIndex==-2)
+      return newItem;
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+KMenuItem* ItemView::insertDocumentItem(const QString& s, int nId, int nIndex, const QStringList* /*suppressGenericNames*/,
+                                        const QString& /*aliasname*/)
+{
+    KMenuItem* newItem = findItem(nId);
+
+    if(!newItem)
+	newItem = new KMenuItem(nId, this);
+
+    KMimeType::Ptr mt = KMimeType::findByURL( s );
+    newItem->setIcon(KMimeType::iconForURL( s ), m_iconSize);
+    newItem->setTitle(s);
+    newItem->setDescription(mt->comment());
+    newItem->setPath(s);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+KMenuItem* ItemView::insertRecentlyItem(const QString& s, int nId, int nIndex)
+{
+    KDesktopFile f(s, true /* read only */);
+
+    KMenuItem* newItem = findItem(nId);
+
+    if(!newItem)
+	newItem = new KMenuItem(nId, this);
+
+    newItem->setIcon(f.readIcon(), m_iconSize);
+
+    // work around upstream fixed bug
+    QString name=f.readName();
+    if (name.isEmpty())
+      name=f.readURL();
+
+    newItem->setTitle(name);
+
+    QString comment = f.readComment();
+    if (comment.isEmpty()) {
+      KURL url(f.readURL());
+      if (!url.host().isEmpty())
+        comment = i18n("Host: %1").arg(url.host());
+    }
+
+    newItem->setDescription(comment);
+    newItem->setPath(s);
+
+    if (nIndex==-1)
+      nIndex=childCount();
+
+    moveItemToIndex(newItem, nIndex);
+
+    return newItem;
+}
+
+int ItemView::insertItem(PopupMenuTitle*, int, int)
+{
+    return 0;
+}
+
+KMenuItem* ItemView::insertSubItem(const QString& icon, const QString& caption, const QString& description, const QString& path, KMenuItem* parentItem)
+{
+#warning FIXME
+    KMenuItem* newItem = parentItem ? new KMenuItem(-1, parentItem) : new KMenuItem(-1, this);
+    newItem->setTitle(caption);
+    newItem->setDescription(description);
+    newItem->setIcon(icon, m_iconSize);
+    newItem->setPath(path);
+
+    return newItem;
+}
+
+
+
+void ItemView::slotItemClicked(int button, QListViewItem * item, const QPoint & /*pos*/, int /*c*/ )
+{
+    if (button==1)
+      slotItemClicked(item);
+}
+
+void ItemView::slotItemClicked(QListViewItem* item)
+{
+    KMenuItem* kitem = dynamic_cast<KMenuItem*>(item);
+    if ( !kitem )
+        return;
+
+    if(kitem->service()) {
+        emit startService(kitem->service());
+    }
+    else if(!kitem->path().isEmpty()) {
+        emit startURL(kitem->path());
+    }
+}
+
+void ItemView::contentsMousePressEvent ( QMouseEvent * e )
+{
+    KListView::contentsMousePressEvent( e );
+
+    QPoint vp = contentsToViewport(e->pos());
+    KMenuItemSeparator *si = dynamic_cast<KMenuItemSeparator*>( itemAt( vp ) );
+    if ( si )
+    {
+        if ( si->hitsLink( vp - itemRect(si).topLeft() ) )
+            emit startURL( si->linkUrl() );
+    }
+}
+
+void ItemView::contentsMouseMoveEvent(QMouseEvent *e)
+{
+    QPoint vp = contentsToViewport(e->pos());
+    QListViewItem * i = itemAt( vp );
+
+    bool link_cursor = false;
+    KMenuItemSeparator *si = dynamic_cast<KMenuItemSeparator*>( i );
+    if ( si )
+        link_cursor = si->hitsLink( vp - itemRect(si).topLeft() );
+
+    if (i && !i->isSelectable() && !link_cursor) {
+      unsetCursor();
+      viewport()->unsetCursor();
+      return;
+    }
+
+    KListView::contentsMouseMoveEvent(e);
+
+    if (m_mouseMoveSelects) {
+      if(i && i->isEnabled() && !i->isSelected() &&
+         // FIXME: This is wrong if you drag over the items.
+         (e->state() & (LeftButton|MidButton|RightButton)) == 0)
+          KListView::setSelected(i, true);
+      else if (!i && selectedItem())
+          KListView::setSelected(selectedItem(), false);
+    }
+
+    if ( link_cursor )
+        setCursor( Qt::PointingHandCursor );
+    else
+        unsetCursor();
+
+}
+
+void ItemView::leaveEvent(QEvent* e)
+{
+    KListView::leaveEvent(e);
+
+    clearSelection();
+}
+
+void ItemView::resizeEvent ( QResizeEvent * e )
+{
+    KListView::resizeEvent( e );
+//    if ( m_lastOne )
+//        int diff = itemRect( m_lastOne ).bottom() - viewport()->height();
+}
+
+void ItemView::viewportPaintEvent ( QPaintEvent * pe )
+{
+    //kdDebug() << "viewportPaintEvent " << pe->rect() << " " << contentsY () << " " << m_old_contentY << endl;
+    KListView::viewportPaintEvent( pe );
+
+    if ( m_lastOne && m_old_contentY != contentsY() ) {
+        m_old_contentY = contentsY();
+        m_lastOne->repaint();
+    }
+}
+
+void ItemView::clear()
+{
+    KListView::clear();
+    m_lastOne = 0;
+    m_old_contentY = -1;
+    m_back_url = QString::null;
+}
+
+void ItemView::contentsWheelEvent(QWheelEvent *e)
+{
+    KListView::contentsWheelEvent(e);
+
+    QPoint vp = contentsToViewport(e->pos());
+    QListViewItem * i = itemAt( vp );
+
+    if(i && i->isEnabled() && !i->isSelected() &&
+       // FIXME: This is wrong if you drag over the items.
+       (e->state() & (LeftButton|MidButton|RightButton)) == 0)
+        KListView::setSelected(i, true);
+    else if (!i && selectedItem())
+        KListView::setSelected(selectedItem(), false);
+}
+
+QDragObject * ItemView::dragObject()
+{
+    KMultipleDrag* o = 0;
+    QListViewItem *item = itemAt( viewport()->mapFromGlobal(QCursor::pos()) );
+    if ( item ) {
+      KMenuItem* kitem = static_cast<KMenuItem*>(item);
+
+      if (dynamic_cast<KMenuItemHeader*>(item))
+        return 0;
+
+      o = new KMultipleDrag(viewport());
+      QPixmap pix = KGlobal::iconLoader()->loadIcon( kitem->icon(), KIcon::Panel, m_iconSize);
+      QPixmap add = KGlobal::iconLoader()->loadIcon( "add", KIcon::Small );
+
+      QPainter p( &pix );
+      p.drawPixmap(pix.height()-add.height(), pix.width()-add.width(), add);
+      p.end();
+
+      QBitmap mask;
+
+      if (pix.mask())
+          mask = *pix.mask();
+      else {
+	  mask.resize(pix.size());
+	  mask.fill(Qt::color1);
+      }
+
+      bitBlt( &mask, pix.width()-add.width(), pix.height()-add.height(), add.mask(), 0, 0, add.width(), add.height(), OrROP );
+      pix.setMask( mask );
+      o->setPixmap(pix);
+
+      if(kitem->service()) {
+        // If the path to the desktop file is relative, try to get the full
+        // path from KStdDirs.
+        QString path = kitem->service()->desktopEntryPath();
+        path = locate("apps", path);
+        o->addDragObject(new KURLDrag(KURL::List(KURL(path)), 0));
+      }
+      else if (kitem->path().startsWith("kicker:/new") || kitem->path().startsWith("system:/")) {
+        delete o;
+        return 0;
+      }
+      else if (kitem->hasChildren()) {
+         o->addDragObject(new KURLDrag(KURL::List(KURL("programs:/"+kitem->menuPath())), 0));
+         return o;
+      }
+      else if(!kitem->path().isEmpty() && !kitem->path().startsWith("kicker:/") && !kitem->path().startsWith("kaddressbook --uid")) {
+         QString uri = kitem->path();
+
+         if (uri.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+             KDesktopFile df(uri,true);
+             uri=df.readURL();
+         }
+
+         o->addDragObject(new KURLDrag(KURL::List(KURL(uri)), 0));
+      }
+
+      o->addDragObject(new KMenuItemDrag(*kitem,this));
+    }
+    return o;
+}
+
+int ItemView::goodHeight()
+{
+    int item_height = 0;
+    QListViewItemIterator it( this );
+    while ( it.current() ) {
+        if ( !dynamic_cast<KMenuSpacer*>( it.current() ) && !it.current()->parent() && it.current()->isVisible() )  {
+            item_height += it.current()->height();
+        }
+        ++it;
+    }
+
+    return item_height;
+}
+
+
+KMenuItemDrag::KMenuItemDrag(KMenuItem& item, QWidget *dragSource)
+    : QDragObject(dragSource, 0)
+{
+    QBuffer buff(a);
+    buff.open(IO_WriteOnly);
+    QDataStream s(&buff);
+
+    s << item.id() << (item.service() ? item.service()->storageId() : QString::null)
+      << item.title() << item.description() << item.icon() << item.path();
+}
+
+KMenuItemDrag::~KMenuItemDrag()
+{
+}
+
+const char * KMenuItemDrag::format(int i) const
+{
+    if (i == 0)
+        return "application/kmenuitem";
+
+    return 0;
+}
+
+QByteArray KMenuItemDrag::encodedData(const char* mimeType) const
+{
+    if (QString("application/kmenuitem") == mimeType)
+        return a;
+
+    return QByteArray();
+}
+
+bool KMenuItemDrag::canDecode(const QMimeSource * e)
+{
+    if (e->provides( "application/kmenuitem" ) )
+        return true;
+
+    return false;
+}
+
+bool ItemView::acceptDrag (QDropEvent* event) const
+{
+    if ( !acceptDrops() )
+        return false;
+
+    if (KMenuItemDrag::canDecode(event))
+        return true;
+
+    if (QTextDrag::canDecode(event)) {
+        QString text;
+        QTextDrag::decode(event,text);
+        return !text.startsWith("programs:/");
+    }
+
+    return itemsMovable();
+}
+
+bool KMenuItemDrag::decode(const QMimeSource* e, KMenuItemInfo& item)
+{
+    QByteArray a = e->encodedData("application/kmenuitem");
+
+    if (a.isEmpty()) {
+        QStringList l;
+        bool ret = QUriDrag::decodeToUnicodeUris( e, l );
+        if ( ret )
+        {
+            for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it )
+            {
+                QString url = *it;
+                kdDebug () << "Url " << url << endl;
+                item.m_path = KURL( url ).path();
+                if ( KDesktopFile::isDesktopFile( item.m_path ) )
+                {
+                    KDesktopFile df( item.m_path, true );
+                    item.m_description = df.readGenericName();
+                    item.m_icon = df.readIcon();
+                    item.m_title = df.readName();
+                }
+                else
+                {
+                    item.m_title = item.m_path;
+                    item.m_icon = KMimeType::iconForURL( url );
+                    item.m_title = item.m_path.section( '/', -1, -1 );
+                    int last_slash = url.findRev ('/', -1);
+                    if (last_slash == 0)
+                        item.m_description = i18n("Directory: /)");
+                    else
+                        item.m_description = i18n("Directory: ") + url.section ('/', -2, -2);
+                }
+
+                return true;
+            }
+        }
+        return false;
+    }
+
+    QBuffer buff(a);
+    buff.open(IO_ReadOnly);
+    QDataStream s(&buff);
+
+    KMenuItemInfo i;
+    QString storageId;
+    s >> i.m_id >> storageId >> i.m_title >> i.m_description >> i.m_icon >> i.m_path;
+
+    i.m_s = storageId.isEmpty() ? 0 : KService::serviceByStorageId(storageId);
+    item = i;
+
+    return true;
+}
+
+FavoritesItemView::FavoritesItemView(QWidget* parent, const char* name)
+    : ItemView(parent, name)
+{
+}
+
+bool FavoritesItemView::acceptDrag (QDropEvent* event) const
+{
+    if (event->source()==this->viewport())
+        return true;
+
+    if (KMenuItemDrag::canDecode(event)) {
+        KMenuItemInfo item;
+        KMenuItemDrag::decode(event,item);
+        QStringList favs = KickerSettings::favorites();
+
+        if (item.m_s)
+            return favs.find(item.m_s->storageId())==favs.end();
+        else {
+            QStringList::Iterator it;
+
+            QString uri = item.m_path;
+
+            if (uri.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+               KDesktopFile df(uri,true);
+               uri=df.readURL();
+            }
+
+            for (it = favs.begin(); it != favs.end(); ++it) {
+                if ((*it)[0]=='/') {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==uri)
+                        break;
+                }
+            }
+            return it==favs.end();
+        }
+    }
+
+    if (QTextDrag::canDecode(event)) {
+        QString text;
+        QTextDrag::decode(event,text);
+        QStringList favs = KickerSettings::favorites();
+
+        if (text.endsWith(".desktop")) {
+            KService::Ptr p = KService::serviceByDesktopPath(text.replace("file://",QString::null));
+            return (p && favs.find(p->storageId())==favs.end());
+        }
+        else {
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it) {
+                if ((*it)[0]=='/') {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==text)
+                        break;
+                }
+            }
+            return it==favs.end();
+        }
+    }
+
+    return itemsMovable();
+}
+
+#include "itemview.moc"
+
+// vim:cindent:sw=4:
Index: kicker/kicker/ui/itemview.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/itemview.h
@@ -0,0 +1,261 @@
+/*****************************************************************
+
+Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef __itemview_h__
+#define __itemview_h__
+
+#include <dcopobject.h>
+#include <qintdict.h>
+#include <qpixmap.h>
+#include <qframe.h>
+#include <qtoolbutton.h>
+#include <klistview.h>
+#include <qdragobject.h>
+
+#include "kmenubase.h"
+#include "kmenuitembase.h"
+#include "service_mnu.h"
+
+class KickerClientMenu;
+class KBookmarkMenu;
+class KActionCollection;
+class KBookmarkOwner;
+class Panel;
+class QWidgetStack;
+class KHistoryCombo;
+class QScrollView;
+class PopupMenuTitle;
+class QWidget;
+class QVBoxLayout;
+class QTimer;
+class KPixmap;
+
+class KMenuItem : public QListViewItem
+{
+public:
+    KMenuItem(int nId, QListView* parent) : QListViewItem(parent), m_id(nId) { init(); }
+    KMenuItem(int nId, QListViewItem* parent) : QListViewItem(parent), m_id(nId) { init(); }
+    ~KMenuItem();
+
+    void setIcon(const QString& icon, int size);
+    QString icon() const { return m_icon; }
+    void setTitle( const QString& text );
+    QString title() const { return m_title; }
+    void setToolTip( const QString& text );
+    QString toolTip() const { return m_tooltip; }
+    void setDescription(const QString& text);
+    QString description() const { return m_description; }
+    void setService(KService::Ptr& s) { m_s = s; }
+    KService::Ptr service() { return m_s; }
+    void setPath(const QString& u) { m_path = u; }
+    QString path() const { return m_path; }
+    void setMenuPath(const QString& u) { m_menuPath = u; }
+    QString menuPath() const { return m_menuPath; }
+    int id() const { return m_id; }
+    void setHasChildren(bool flag);
+    bool hasChildren() const { return m_has_children; }
+    void makeGradient(KPixmap &off, const QColor& c);
+
+protected:
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    int width ( const QFontMetrics & fm, const QListView * lv, int c );
+    virtual void paintCellInter(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    virtual void setup();
+
+private:
+    void init();
+
+    int m_id;
+    KService::Ptr m_s;
+    QString m_title;
+    QString m_description;
+    QString m_path;
+    QString m_icon;
+    QString m_tooltip;
+    QString m_menuPath;
+    float title_font_size;
+    float description_font_size;
+    bool m_has_children;
+    int m_old_width;
+    QPixmap right_triangle;
+};
+
+class KMenuItemSeparator : public KMenuItem
+{
+public:
+    KMenuItemSeparator(int nId, QListView* parent);
+    virtual void setup();
+
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    void setLink(const QString &text, const QString &link = QString::null );
+
+    QString linkUrl() const { return m_link_url; }
+
+    /// returns true if the cursor has to change
+    bool hitsLink(const QPoint &pos);
+
+protected:
+    void preparePixmap(int width);
+    QPixmap pixmap;
+    int left_margin;
+
+private:
+    QListView* lv;
+    int cached_width;
+    QString m_link_text, m_link_url;
+    QRect m_link_rect;
+
+};
+
+class KMenuItemHeader : public KMenuItemSeparator
+{
+public:
+    KMenuItemHeader( int nId, const QString &relpath, QListView* parent);
+    virtual void setup();
+
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+
+private:
+    QListView* lv;
+    QStringList paths;
+    QStringList texts;
+    QStringList icons;
+    QPixmap left_triangle;
+};
+
+class KMenuSpacer : public KMenuItem
+{
+public:
+    KMenuSpacer(int nId, QListView* parent);
+    virtual void paintCell(QPainter* p, const QColorGroup & cg, int column, int width, int align);
+    virtual void setup();
+
+    void setHeight(int);
+};
+
+class ItemView : public KListView
+{
+    friend class KMenuItem;
+
+    Q_OBJECT
+public:
+    ItemView(QWidget* parent, const char* name = 0);
+
+    KMenuItem* insertItem( const QString& icon, const QString& text, const QString& description, int nId, int nIndex, KMenuItem* parentItem = 0 );
+    KMenuItem* insertItem( const QString& icon, const QString& text, const QString& description, const QString& path, int nId, int nIndex, KMenuItem* parentItem = 0 );
+    int insertItem( PopupMenuTitle*, int, int);
+    int setItemEnabled(int id, bool enabled);
+    KMenuItemSeparator *insertSeparator(int id, const QString& text, int nIndex);
+    KMenuItemHeader *insertHeader(int id, const QString &relpath);
+    KMenuItem* insertMenuItem(KService::Ptr & s, int nId, int nIndex = -1, KMenuItem* parentItem = 0,
+                        const QString &aliasname = QString::null, const QString &label = QString::null,
+                        const QString &categoryIcon = QString::null);
+    KMenuItem* insertRecentlyItem(const QString& s, int nId, int nIndex = -1);
+    KMenuItem* insertDocumentItem(const QString& s, int nId, int nIndex = -1 , const QStringList* suppressGenericNames = 0,
+                        const QString& aliasname = QString::null);
+    KMenuItem* insertSubItem(const QString& icon, const QString& caption, const QString& description, const QString& path, KMenuItem* parentItem);
+    KMenuItem* findItem(int nId);
+
+    void setIconSize(int size) { m_iconSize = size; }
+    void setMouseMoveSelects(bool select) { m_mouseMoveSelects = select; }
+    void clear();
+    int goodHeight();
+    QString path;
+    void setBackPath( const QString &str ) { m_back_url = str; }
+    QString backPath() const { return m_back_url; }
+
+public slots:
+    void slotItemClicked(QListViewItem*);
+    void slotMoveContent();
+
+signals:
+    void startService(KService::Ptr kservice);
+    void startURL(const QString& u);
+
+protected:
+    void contentsMouseMoveEvent(QMouseEvent *e);
+    void contentsMousePressEvent ( QMouseEvent * e );
+    void contentsWheelEvent(QWheelEvent *e);
+    void leaveEvent(QEvent *e);
+    virtual void resizeEvent ( QResizeEvent * e );
+    virtual void viewportPaintEvent ( QPaintEvent * pe );
+    virtual QDragObject* dragObject ();
+    virtual bool acceptDrag (QDropEvent* event) const;
+    virtual bool focusNextPrevChild(bool next);
+
+private slots:
+    void slotItemClicked(int button, QListViewItem * item, const QPoint & pos, int c );
+
+private:
+    KMenuItem* itemAtIndex(int nIndex);
+    void moveItemToIndex(KMenuItem*, int);
+
+    QWidget* m_itemBox;
+    QVBoxLayout* m_itemLayout;
+    KMenuItem *m_lastOne;
+    KMenuSpacer *m_spacer;
+
+    QString m_back_url;
+
+    bool m_mouseMoveSelects;
+    int m_iconSize;
+    int m_old_contentY;
+};
+
+class FavoritesItemView : public ItemView
+{
+public:
+    FavoritesItemView(QWidget* parent, const char* name = 0);
+
+protected:
+    virtual bool acceptDrag (QDropEvent* event) const;
+};
+
+class KMenuItemInfo
+{
+public:
+    int m_id;
+    KService::Ptr m_s;
+    QString m_title;
+    QString m_description;
+    QString m_path;
+    QString m_icon;
+};
+
+class KMenuItemDrag : public QDragObject
+{
+    public:
+        KMenuItemDrag(KMenuItem& item, QWidget *dragSource);
+        ~KMenuItemDrag();
+
+        virtual const char * format(int i = 0) const;
+        virtual QByteArray encodedData(const char *) const;
+
+        static bool canDecode(const QMimeSource * e);
+        static bool decode(const QMimeSource* e, KMenuItemInfo& item);
+
+    private:
+        QByteArray a;
+};
+
+#endif
Index: kicker/kicker/ui/kmenubase.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/kmenubase.h
@@ -0,0 +1,107 @@
+/****************************************************************************
+** Form interface generated from reading ui file 'kicker/ui/kmenubase.ui'
+**
+** Created: Pzt Kas 6 14:38:52 2006
+**      by: The User Interface Compiler ($Id: qt/main.cpp   3.3.7   edited Aug 31 2005 $)
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+
+#ifndef KMENU_H
+#define KMENU_H
+
+#include <qvariant.h>
+#include <qpixmap.h>
+#include <qdialog.h>
+
+class QVBoxLayout;
+class QHBoxLayout;
+class QGridLayout;
+class QSpacerItem;
+class QFrame;
+class QLabel;
+class KHistoryCombo;
+class QToolButton;
+
+class KMenuBase : public QDialog
+{
+    Q_OBJECT
+
+public:
+    KMenuBase( QWidget* parent = 0, const char* name = 0, bool modal = FALSE, WFlags fl = 0 );
+    ~KMenuBase();
+
+    QFrame* m_searchFrame;
+    QLabel* m_searchLabel;
+    KHistoryCombo* m_kcommand;
+    QLabel* m_searchPixmap;
+    QFrame* m_btnFavorites;
+    QLabel* pixmapLabel_fav;
+    QLabel* m_btnFavorites_text;
+    QFrame* m_btnRecently;
+    QLabel* pixmapLabel_recent;
+    QLabel* m_btnRecently_text;
+    QFrame* m_system;
+    QLabel* pixmapLabel_system;
+    QLabel* m_system_text;
+    QFrame* m_browser;
+    QLabel* pixmapLabel_browser;
+    QLabel* m_browser_text;
+    QFrame* m_exit;
+    QLabel* pixmapLabel_exit;
+    QLabel* m_exit_text;
+    QFrame* m_expandSpace;
+    QLabel* m_userInfo;
+    QToolButton* m_lock;
+
+protected:
+    QHBoxLayout* m_search;
+    QSpacerItem* spacer5_2;
+    QHBoxLayout* m_searchFrameLayout;
+    QHBoxLayout* layout18;
+    QHBoxLayout* buttonBox;
+    QVBoxLayout* m_btnFavoritesLayout;
+    QVBoxLayout* layout33;
+    QSpacerItem* m_btnFavorites_spacer;
+    QHBoxLayout* layout12_3;
+    QSpacerItem* spacer7_2_3;
+    QSpacerItem* spacer7_4;
+    QVBoxLayout* m_btnRecentlyLayout;
+    QVBoxLayout* layout13_2_5;
+    QSpacerItem* m_btnRecently_spacer;
+    QHBoxLayout* layout12_2_5;
+    QSpacerItem* spacer7_2_2_5;
+    QSpacerItem* spacer7_3_5;
+    QVBoxLayout* m_systemLayout;
+    QVBoxLayout* layout13_2_2_2;
+    QSpacerItem* m_system_spacer;
+    QHBoxLayout* layout12_2_2_2;
+    QSpacerItem* spacer7_2_2_2_2;
+    QSpacerItem* spacer7_3_2_2;
+    QVBoxLayout* m_browserLayout;
+    QVBoxLayout* layout13_2_3_2;
+    QSpacerItem* m_browser_spacer;
+    QHBoxLayout* layout12_2_3_2;
+    QSpacerItem* spacer7_2_2_3_2;
+    QSpacerItem* spacer7_3_3_2;
+    QVBoxLayout* m_exitLayout;
+    QVBoxLayout* layout13_2_4_2;
+    QSpacerItem* m_exit_spacer;
+    QHBoxLayout* layout12_2_4_2;
+    QSpacerItem* spacer7_2_2_4_2;
+    QSpacerItem* spacer7_3_4_2;
+    QHBoxLayout* m_footer;
+    QSpacerItem* spacer13_2;
+    QSpacerItem* spacer13;
+
+protected slots:
+    virtual void languageChange();
+
+private:
+    QPixmap image0;
+
+    void init();
+
+};
+
+#endif // KMENU_H
Index: kicker/kicker/ui/kmenubase.ui
===================================================================
--- /dev/null
+++ kicker/kicker/ui/kmenubase.ui
@@ -0,0 +1,1177 @@
+<!DOCTYPE UI><UI version="3.3" stdsetdef="1">
+<class>KMenuBase</class>
+<widget class="QDialog">
+    <property name="name">
+        <cstring>KMenu</cstring>
+    </property>
+    <property name="geometry">
+        <rect>
+            <x>0</x>
+            <y>0</y>
+            <width>723</width>
+            <height>580</height>
+        </rect>
+    </property>
+    <property name="caption">
+        <string>KMenu</string>
+    </property>
+    <property name="frameShadow" stdset="0">
+        <string>MShadow</string>
+    </property>
+    <property name="frameShape" stdset="0">
+        <string>MShape</string>
+    </property>
+    <widget class="QLayoutWidget">
+        <property name="name">
+            <cstring>m_search</cstring>
+        </property>
+        <property name="geometry">
+            <rect>
+                <x>20</x>
+                <y>40</y>
+                <width>190</width>
+                <height>54</height>
+            </rect>
+        </property>
+        <hbox>
+            <property name="name">
+                <cstring>unnamed</cstring>
+            </property>
+            <property name="margin">
+                <number>0</number>
+            </property>
+            <property name="spacing">
+                <number>0</number>
+            </property>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_searchFrame</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>5</hsizetype>
+                        <vsizetype>0</vsizetype>
+                        <horstretch>0</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>52</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>52</height>
+                    </size>
+                </property>
+                <property name="frameShape">
+                    <enum>StyledPanel</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Raised</enum>
+                </property>
+                <property name="lineWidth">
+                    <number>0</number>
+                </property>
+                <hbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout18</cstring>
+                        </property>
+                        <hbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_searchLabel</cstring>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="font">
+                                    <font>
+                                        <pointsize>14</pointsize>
+                                    </font>
+                                </property>
+                                <property name="text">
+                                    <string>Search:</string>
+                                </property>
+                            </widget>
+                            <widget class="KHistoryCombo">
+                                <property name="name">
+                                    <cstring>m_kcommand</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>7</hsizetype>
+                                        <vsizetype>0</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_searchPixmap</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>1</hsizetype>
+                                        <vsizetype>1</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                                <property name="minimumSize">
+                                    <size>
+                                        <width>32</width>
+                                        <height>32</height>
+                                    </size>
+                                </property>
+                                <property name="maximumSize">
+                                    <size>
+                                        <width>32</width>
+                                        <height>32</height>
+                                    </size>
+                                </property>
+                                <property name="backgroundMode">
+                                    <enum>PaletteBackground</enum>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="scaledContents">
+                                    <bool>true</bool>
+                                </property>
+                            </widget>
+                        </hbox>
+                    </widget>
+                </hbox>
+            </widget>
+            <spacer>
+                <property name="name">
+                    <cstring>spacer5_2</cstring>
+                </property>
+                <property name="orientation">
+                    <enum>Horizontal</enum>
+                </property>
+                <property name="sizeType">
+                    <enum>Preferred</enum>
+                </property>
+                <property name="sizeHint">
+                    <size>
+                        <width>16</width>
+                        <height>20</height>
+                    </size>
+                </property>
+            </spacer>
+        </hbox>
+    </widget>
+    <widget class="QLayoutWidget">
+        <property name="name">
+            <cstring>buttonBox</cstring>
+        </property>
+        <property name="geometry">
+            <rect>
+                <x>90</x>
+                <y>150</y>
+                <width>440</width>
+                <height>190</height>
+            </rect>
+        </property>
+        <hbox>
+            <property name="name">
+                <cstring>unnamed</cstring>
+            </property>
+            <property name="margin">
+                <number>0</number>
+            </property>
+            <property name="spacing">
+                <number>0</number>
+            </property>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_btnFavorites</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>0</hsizetype>
+                        <vsizetype>1</vsizetype>
+                        <horstretch>1</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>0</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>32767</height>
+                    </size>
+                </property>
+                <property name="backgroundOrigin">
+                    <enum>WidgetOrigin</enum>
+                </property>
+                <property name="mouseTracking">
+                    <bool>true</bool>
+                </property>
+                <property name="focusPolicy">
+                    <enum>StrongFocus</enum>
+                </property>
+                <property name="frameShape">
+                    <enum>NoFrame</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Raised</enum>
+                </property>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>0</number>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout33</cstring>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>6</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>layout12_3</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_2_3</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>pixmapLabel_fav</cstring>
+                                        </property>
+                                        <property name="sizePolicy">
+                                            <sizepolicy>
+                                                <hsizetype>0</hsizetype>
+                                                <vsizetype>0</vsizetype>
+                                                <horstretch>0</horstretch>
+                                                <verstretch>0</verstretch>
+                                            </sizepolicy>
+                                        </property>
+                                        <property name="backgroundOrigin">
+                                            <enum>ParentOrigin</enum>
+                                        </property>
+                                        <property name="mouseTracking">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="scaledContents">
+                                            <bool>true</bool>
+                                        </property>
+                                    </widget>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_4</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                </hbox>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_btnFavorites_text</cstring>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="mouseTracking">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="text">
+                                    <string>&lt;p align="center"&gt; &lt;u&gt;F&lt;/u&gt;avorites&lt;/p&gt;</string>
+                                </property>
+                                <property name="alignment">
+                                    <set>WordBreak|AlignCenter</set>
+                                </property>
+                            </widget>
+                            <spacer>
+                                <property name="name">
+                                    <cstring>m_btnFavorites_spacer</cstring>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Vertical</enum>
+                                </property>
+                                <property name="sizeType">
+                                    <enum>Fixed</enum>
+                                </property>
+                                <property name="sizeHint">
+                                    <size>
+                                        <width>5</width>
+                                        <height>20</height>
+                                    </size>
+                                </property>
+                            </spacer>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_btnRecently</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>1</hsizetype>
+                        <vsizetype>5</vsizetype>
+                        <horstretch>1</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>0</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>32767</height>
+                    </size>
+                </property>
+                <property name="backgroundOrigin">
+                    <enum>WidgetOrigin</enum>
+                </property>
+                <property name="mouseTracking">
+                    <bool>true</bool>
+                </property>
+                <property name="focusPolicy">
+                    <enum>StrongFocus</enum>
+                </property>
+                <property name="frameShape">
+                    <enum>NoFrame</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Plain</enum>
+                </property>
+                <property name="lineWidth">
+                    <number>0</number>
+                </property>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>0</number>
+                    </property>
+                    <property name="spacing">
+                        <number>0</number>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout13_2_5</cstring>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>6</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>layout12_2_5</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_2_2_5</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>pixmapLabel_recent</cstring>
+                                        </property>
+                                        <property name="sizePolicy">
+                                            <sizepolicy>
+                                                <hsizetype>0</hsizetype>
+                                                <vsizetype>0</vsizetype>
+                                                <horstretch>0</horstretch>
+                                                <verstretch>0</verstretch>
+                                            </sizepolicy>
+                                        </property>
+                                        <property name="backgroundOrigin">
+                                            <enum>ParentOrigin</enum>
+                                        </property>
+                                        <property name="mouseTracking">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="scaledContents">
+                                            <bool>true</bool>
+                                        </property>
+                                    </widget>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_3_5</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                </hbox>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_btnRecently_text</cstring>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="mouseTracking">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="text">
+                                    <string>&lt;p align="center"&gt;&lt;u&gt;H&lt;/u&gt;istory&lt;/p&gt;</string>
+                                </property>
+                                <property name="alignment">
+                                    <set>WordBreak|AlignCenter</set>
+                                </property>
+                            </widget>
+                            <spacer>
+                                <property name="name">
+                                    <cstring>m_btnRecently_spacer</cstring>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Vertical</enum>
+                                </property>
+                                <property name="sizeType">
+                                    <enum>Fixed</enum>
+                                </property>
+                                <property name="sizeHint">
+                                    <size>
+                                        <width>5</width>
+                                        <height>20</height>
+                                    </size>
+                                </property>
+                            </spacer>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_system</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>1</hsizetype>
+                        <vsizetype>5</vsizetype>
+                        <horstretch>1</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>0</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>32767</height>
+                    </size>
+                </property>
+                <property name="backgroundOrigin">
+                    <enum>WidgetOrigin</enum>
+                </property>
+                <property name="mouseTracking">
+                    <bool>true</bool>
+                </property>
+                <property name="focusPolicy">
+                    <enum>StrongFocus</enum>
+                </property>
+                <property name="frameShape">
+                    <enum>NoFrame</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Raised</enum>
+                </property>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>0</number>
+                    </property>
+                    <property name="spacing">
+                        <number>0</number>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout13_2_2_2</cstring>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>6</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>layout12_2_2_2</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_2_2_2_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>pixmapLabel_system</cstring>
+                                        </property>
+                                        <property name="sizePolicy">
+                                            <sizepolicy>
+                                                <hsizetype>0</hsizetype>
+                                                <vsizetype>0</vsizetype>
+                                                <horstretch>0</horstretch>
+                                                <verstretch>0</verstretch>
+                                            </sizepolicy>
+                                        </property>
+                                        <property name="backgroundOrigin">
+                                            <enum>ParentOrigin</enum>
+                                        </property>
+                                        <property name="mouseTracking">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="scaledContents">
+                                            <bool>true</bool>
+                                        </property>
+                                    </widget>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_3_2_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                </hbox>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_system_text</cstring>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="mouseTracking">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="text">
+                                    <string>&lt;p align="center"&gt; &lt;u&gt;C&lt;/u&gt;omputer&lt;/p&gt;</string>
+                                </property>
+                                <property name="alignment">
+                                    <set>WordBreak|AlignCenter</set>
+                                </property>
+                            </widget>
+                            <spacer>
+                                <property name="name">
+                                    <cstring>m_system_spacer</cstring>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Vertical</enum>
+                                </property>
+                                <property name="sizeType">
+                                    <enum>Fixed</enum>
+                                </property>
+                                <property name="sizeHint">
+                                    <size>
+                                        <width>5</width>
+                                        <height>20</height>
+                                    </size>
+                                </property>
+                            </spacer>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_browser</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>1</hsizetype>
+                        <vsizetype>5</vsizetype>
+                        <horstretch>1</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>0</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>32767</height>
+                    </size>
+                </property>
+                <property name="backgroundOrigin">
+                    <enum>WidgetOrigin</enum>
+                </property>
+                <property name="mouseTracking">
+                    <bool>true</bool>
+                </property>
+                <property name="focusPolicy">
+                    <enum>StrongFocus</enum>
+                </property>
+                <property name="frameShape">
+                    <enum>NoFrame</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Raised</enum>
+                </property>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>0</number>
+                    </property>
+                    <property name="spacing">
+                        <number>0</number>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout13_2_3_2</cstring>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>6</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>layout12_2_3_2</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_2_2_3_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>pixmapLabel_browser</cstring>
+                                        </property>
+                                        <property name="sizePolicy">
+                                            <sizepolicy>
+                                                <hsizetype>0</hsizetype>
+                                                <vsizetype>0</vsizetype>
+                                                <horstretch>0</horstretch>
+                                                <verstretch>0</verstretch>
+                                            </sizepolicy>
+                                        </property>
+                                        <property name="backgroundOrigin">
+                                            <enum>ParentOrigin</enum>
+                                        </property>
+                                        <property name="mouseTracking">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="scaledContents">
+                                            <bool>true</bool>
+                                        </property>
+                                    </widget>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_3_3_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                </hbox>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_browser_text</cstring>
+                                </property>
+                                <property name="sizePolicy">
+                                    <sizepolicy>
+                                        <hsizetype>1</hsizetype>
+                                        <vsizetype>1</vsizetype>
+                                        <horstretch>0</horstretch>
+                                        <verstretch>0</verstretch>
+                                    </sizepolicy>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="mouseTracking">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="text">
+                                    <string>&lt;p align="center"&gt;&lt;u&gt;A&lt;/u&gt;pplications&lt;/p&gt;</string>
+                                </property>
+                                <property name="alignment">
+                                    <set>WordBreak|AlignCenter</set>
+                                </property>
+                            </widget>
+                            <spacer>
+                                <property name="name">
+                                    <cstring>m_browser_spacer</cstring>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Vertical</enum>
+                                </property>
+                                <property name="sizeType">
+                                    <enum>Fixed</enum>
+                                </property>
+                                <property name="sizeHint">
+                                    <size>
+                                        <width>5</width>
+                                        <height>20</height>
+                                    </size>
+                                </property>
+                            </spacer>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_exit</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>1</hsizetype>
+                        <vsizetype>5</vsizetype>
+                        <horstretch>1</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>0</width>
+                        <height>0</height>
+                    </size>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>32767</width>
+                        <height>32767</height>
+                    </size>
+                </property>
+                <property name="backgroundOrigin">
+                    <enum>WidgetOrigin</enum>
+                </property>
+                <property name="mouseTracking">
+                    <bool>true</bool>
+                </property>
+                <property name="focusPolicy">
+                    <enum>StrongFocus</enum>
+                </property>
+                <property name="frameShape">
+                    <enum>NoFrame</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Raised</enum>
+                </property>
+                <vbox>
+                    <property name="name">
+                        <cstring>unnamed</cstring>
+                    </property>
+                    <property name="margin">
+                        <number>0</number>
+                    </property>
+                    <property name="spacing">
+                        <number>0</number>
+                    </property>
+                    <widget class="QLayoutWidget">
+                        <property name="name">
+                            <cstring>layout13_2_4_2</cstring>
+                        </property>
+                        <vbox>
+                            <property name="name">
+                                <cstring>unnamed</cstring>
+                            </property>
+                            <property name="margin">
+                                <number>6</number>
+                            </property>
+                            <widget class="QLayoutWidget">
+                                <property name="name">
+                                    <cstring>layout12_2_4_2</cstring>
+                                </property>
+                                <hbox>
+                                    <property name="name">
+                                        <cstring>unnamed</cstring>
+                                    </property>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_2_2_4_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                    <widget class="QLabel">
+                                        <property name="name">
+                                            <cstring>pixmapLabel_exit</cstring>
+                                        </property>
+                                        <property name="sizePolicy">
+                                            <sizepolicy>
+                                                <hsizetype>0</hsizetype>
+                                                <vsizetype>0</vsizetype>
+                                                <horstretch>0</horstretch>
+                                                <verstretch>0</verstretch>
+                                            </sizepolicy>
+                                        </property>
+                                        <property name="backgroundOrigin">
+                                            <enum>ParentOrigin</enum>
+                                        </property>
+                                        <property name="mouseTracking">
+                                            <bool>true</bool>
+                                        </property>
+                                        <property name="scaledContents">
+                                            <bool>true</bool>
+                                        </property>
+                                    </widget>
+                                    <spacer>
+                                        <property name="name">
+                                            <cstring>spacer7_3_4_2</cstring>
+                                        </property>
+                                        <property name="orientation">
+                                            <enum>Horizontal</enum>
+                                        </property>
+                                        <property name="sizeType">
+                                            <enum>Expanding</enum>
+                                        </property>
+                                        <property name="sizeHint">
+                                            <size>
+                                                <width>40</width>
+                                                <height>20</height>
+                                            </size>
+                                        </property>
+                                    </spacer>
+                                </hbox>
+                            </widget>
+                            <widget class="QLabel">
+                                <property name="name">
+                                    <cstring>m_exit_text</cstring>
+                                </property>
+                                <property name="backgroundOrigin">
+                                    <enum>ParentOrigin</enum>
+                                </property>
+                                <property name="mouseTracking">
+                                    <bool>true</bool>
+                                </property>
+                                <property name="text">
+                                    <string>&lt;p align="center"&gt;&lt;u&gt;L&lt;/u&gt;eave&lt;/p&gt;</string>
+                                </property>
+                            </widget>
+                            <spacer>
+                                <property name="name">
+                                    <cstring>m_exit_spacer</cstring>
+                                </property>
+                                <property name="orientation">
+                                    <enum>Vertical</enum>
+                                </property>
+                                <property name="sizeType">
+                                    <enum>Fixed</enum>
+                                </property>
+                                <property name="sizeHint">
+                                    <size>
+                                        <width>5</width>
+                                        <height>20</height>
+                                    </size>
+                                </property>
+                            </spacer>
+                        </vbox>
+                    </widget>
+                </vbox>
+            </widget>
+            <widget class="QFrame">
+                <property name="name">
+                    <cstring>m_expandSpace</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>7</hsizetype>
+                        <vsizetype>5</vsizetype>
+                        <horstretch>87</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="minimumSize">
+                    <size>
+                        <width>10</width>
+                        <height>0</height>
+                    </size>
+                </property>
+                <property name="backgroundOrigin">
+                    <enum>WidgetOrigin</enum>
+                </property>
+                <property name="frameShape">
+                    <enum>NoFrame</enum>
+                </property>
+                <property name="frameShadow">
+                    <enum>Plain</enum>
+                </property>
+            </widget>
+        </hbox>
+    </widget>
+    <widget class="QLayoutWidget">
+        <property name="name">
+            <cstring>m_footer</cstring>
+        </property>
+        <property name="geometry">
+            <rect>
+                <x>95</x>
+                <y>395</y>
+                <width>407</width>
+                <height>34</height>
+            </rect>
+        </property>
+        <hbox>
+            <property name="name">
+                <cstring>unnamed</cstring>
+            </property>
+            <property name="margin">
+                <number>4</number>
+            </property>
+            <property name="spacing">
+                <number>4</number>
+            </property>
+            <widget class="QLabel">
+                <property name="name">
+                    <cstring>m_userInfo</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>3</hsizetype>
+                        <vsizetype>0</vsizetype>
+                        <horstretch>0</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="text">
+                    <string>User&amp;nbsp;&lt;b&gt;user&lt;/b&gt;&amp;nbsp;on&amp;nbsp;&lt;b&gt;host&lt;/b&gt;</string>
+                </property>
+            </widget>
+            <spacer>
+                <property name="name">
+                    <cstring>spacer13_2</cstring>
+                </property>
+                <property name="orientation">
+                    <enum>Horizontal</enum>
+                </property>
+                <property name="sizeType">
+                    <enum>MinimumExpanding</enum>
+                </property>
+                <property name="sizeHint">
+                    <size>
+                        <width>104</width>
+                        <height>20</height>
+                    </size>
+                </property>
+            </spacer>
+            <widget class="QToolButton">
+                <property name="name">
+                    <cstring>m_lock</cstring>
+                </property>
+                <property name="sizePolicy">
+                    <sizepolicy>
+                        <hsizetype>4</hsizetype>
+                        <vsizetype>4</vsizetype>
+                        <horstretch>0</horstretch>
+                        <verstretch>0</verstretch>
+                    </sizepolicy>
+                </property>
+                <property name="maximumSize">
+                    <size>
+                        <width>90</width>
+                        <height>24</height>
+                    </size>
+                </property>
+                <property name="text">
+                    <string></string>
+                </property>
+                <property name="iconSet">
+                    <iconset>image0</iconset>
+                </property>
+                <property name="usesBigPixmap">
+                    <bool>true</bool>
+                </property>
+                <property name="autoRaise">
+                    <bool>true</bool>
+                </property>
+            </widget>
+            <spacer>
+                <property name="name">
+                    <cstring>spacer13</cstring>
+                </property>
+                <property name="orientation">
+                    <enum>Horizontal</enum>
+                </property>
+                <property name="sizeType">
+                    <enum>Fixed</enum>
+                </property>
+                <property name="sizeHint">
+                    <size>
+                        <width>14</width>
+                        <height>20</height>
+                    </size>
+                </property>
+            </spacer>
+        </hbox>
+    </widget>
+</widget>
+<customwidgets>
+</customwidgets>
+<images>
+    <image name="image0">
+        <data format="PNG" length="975">89504e470d0a1a0a0000000d4948445200000020000000200806000000737a7af400000396494441545885ed97cb6b5b471487bf33731fba56ae2dcb759ce0906070fa80dab418170285f46f6817dd94ae4ae9ae7f4b775974d36d43165d77d3d207c58560ecb690b4250b91b8d48fd8b16459baf7cee9e25ec5b27c6d246fdc8507c48199d1996f7e73ced191a82a1739cc859e7e09f07f00f0ca2677bf98065854b87765f6da823a75e7712e464cf3e93feb029f016bb5cf37870300168107c0fc790e1e18770a5f1f006bc3027c09cc4fbefb1e9a8c01d9c0b220a2404f1883aa0083296d999c3b60f7c7efe60b9fef0c05509d9d5900d0344293f689751147dae9927605057c5fb195b08018dc1c519d9d0158283bab14401d5da042efe9c500022218510e9b8e4e7897e0d65b28d07ab64ad8fa89b06a4f42a8ebb9e90e0df072180f2ce052c8dae012b2a44dc7de255efe181305e01ceefa02cd95367eb282f8118c505dcb01a4b8456717ddfa1b6d6d42a78590d2d94dc96e2f616c97bdefbfc254c689973fc44ece91fdfb0bbeef504a9e621400dd7902807bf118d7eed2f3271634014ddbb82ca1fdf06b4c18515d7a1fb11e587fe883cf04a0dbca4104e8f769c89fa48809f143344da1b347baf918dbda46aa7390a6a0690e8d39538f5200131ed9fe12640c98e0e885c4f4262de9f30dfca73f40d086f84df026c075f32f78c1880095f1dc06720c400c48d8cc0954c12b2ab92a783ee219d8f9039a3b505f44e25b10d690b0361a00956bb90d2db8be8836063adb88b18023ebf67e4a348f81b157a03a05490776d6e06003ea6f80a98c0a305d00f8483f803548db47d560b4c395e58f102b184f480f3388ae4354470207489ebe7b7f22c9e969590e105e2d4022707d65d85aa8f8793aa45de2853b640a2f7e5fc16d3f227cf5b55ca597d00246e0f0e09c0a446390f50581b5503188f3c10b78fef337749efd8647c2d4eb3791c1fd856a302a405428305685ac4f01cf83b6c0614096a6245b4f989abf8a1fd741bc7cef60ce590bb4460598296c3c00e0a391e0f65ba86660234ced360495d3cbafb5a0fb230254eab90d27204b8fe68d219889696e3c64ebdb0784f124b67603d233fa15eb813bbd42960288e7e79543f4b8a4ea30c632f5f612496b9f209ec803eeac52278a783e4069352aed099b8dc67ab3d180781c8ccd6fd1fb18417c9fa03e9daf19737cfdd85e0bf138cd468366a3b13eb402c0a7c0fdbdd55fe7e31b37d12c39b94339fbe680589ffdd54708f217f0c92800abe43ddc3df24ee65c4d29b9c2eb144d6929e4e55fb34b808b06f80fb1903c3480b564e80000000049454e44ae426082</data>
+    </image>
+</images>
+<includes>
+    <include location="local" impldecl="in implementation">kmenubase.ui.h</include>
+</includes>
+<functions>
+    <function access="private" specifier="non virtual">init()</function>
+</functions>
+<layoutdefaults spacing="6" margin="11"/>
+<includehints>
+    <includehint>kcombobox.h</includehint>
+</includehints>
+</UI>
Index: kicker/kicker/ui/kmenubase.ui.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/kmenubase.ui.h
@@ -0,0 +1,9 @@
+#include <X11/Xlib.h>
+
+void KMenuBase::init()
+{
+    XSetWindowAttributes attrs;
+    attrs.override_redirect = True;
+    XChangeWindowAttributes( qt_xdisplay(), winId(), CWOverrideRedirect, &attrs );
+    setWFlags( Qt::WType_Popup );
+}
Index: kicker/kicker/ui/kmenuitembase.ui
===================================================================
--- /dev/null
+++ kicker/kicker/ui/kmenuitembase.ui
@@ -0,0 +1,141 @@
+<!DOCTYPE UI><UI version="3.3" stdsetdef="1">
+<class>KMenuItemBase</class>
+<widget class="QWidget">
+    <property name="name">
+        <cstring>KMenuItemBase</cstring>
+    </property>
+    <property name="geometry">
+        <rect>
+            <x>0</x>
+            <y>0</y>
+            <width>514</width>
+            <height>80</height>
+        </rect>
+    </property>
+    <property name="sizePolicy">
+        <sizepolicy>
+            <hsizetype>7</hsizetype>
+            <vsizetype>5</vsizetype>
+            <horstretch>0</horstretch>
+            <verstretch>0</verstretch>
+        </sizepolicy>
+    </property>
+    <property name="minimumSize">
+        <size>
+            <width>0</width>
+            <height>0</height>
+        </size>
+    </property>
+    <property name="maximumSize">
+        <size>
+            <width>32767</width>
+            <height>80</height>
+        </size>
+    </property>
+    <property name="caption">
+        <string>KMenuItemBase</string>
+    </property>
+    <grid>
+        <property name="name">
+            <cstring>unnamed</cstring>
+        </property>
+        <property name="margin">
+            <number>2</number>
+        </property>
+        <widget class="QLayoutWidget" row="0" column="1">
+            <property name="name">
+                <cstring>layout11</cstring>
+            </property>
+            <vbox>
+                <property name="name">
+                    <cstring>unnamed</cstring>
+                </property>
+                <widget class="QLabel">
+                    <property name="name">
+                        <cstring>itemTitle</cstring>
+                    </property>
+                    <property name="sizePolicy">
+                        <sizepolicy>
+                            <hsizetype>7</hsizetype>
+                            <vsizetype>1</vsizetype>
+                            <horstretch>1</horstretch>
+                            <verstretch>0</verstretch>
+                        </sizepolicy>
+                    </property>
+                    <property name="font">
+                        <font>
+                            <pointsize>14</pointsize>
+                        </font>
+                    </property>
+                    <property name="text">
+                        <string></string>
+                    </property>
+                    <property name="textFormat">
+                        <enum>RichText</enum>
+                    </property>
+                    <property name="alignment">
+                        <set>WordBreak|AlignTop</set>
+                    </property>
+                </widget>
+                <widget class="QLabel">
+                    <property name="name">
+                        <cstring>itemDescription</cstring>
+                    </property>
+                    <property name="sizePolicy">
+                        <sizepolicy>
+                            <hsizetype>7</hsizetype>
+                            <vsizetype>7</vsizetype>
+                            <horstretch>0</horstretch>
+                            <verstretch>1</verstretch>
+                        </sizepolicy>
+                    </property>
+                    <property name="paletteForegroundColor">
+                        <color>
+                            <red>188</red>
+                            <green>188</green>
+                            <blue>188</blue>
+                        </color>
+                    </property>
+                    <property name="text">
+                        <string></string>
+                    </property>
+                    <property name="textFormat">
+                        <enum>RichText</enum>
+                    </property>
+                    <property name="alignment">
+                        <set>WordBreak|AlignTop</set>
+                    </property>
+                </widget>
+            </vbox>
+        </widget>
+        <widget class="QLayoutWidget" row="0" column="0">
+            <property name="name">
+                <cstring>layout4</cstring>
+            </property>
+            <vbox>
+                <property name="name">
+                    <cstring>unnamed</cstring>
+                </property>
+                <widget class="QLabel">
+                    <property name="name">
+                        <cstring>itemPixmap</cstring>
+                    </property>
+                    <property name="minimumSize">
+                        <size>
+                            <width>64</width>
+                            <height>64</height>
+                        </size>
+                    </property>
+                    <property name="text">
+                        <string></string>
+                    </property>
+                    <property name="alignment">
+                        <set>AlignTop|AlignHCenter</set>
+                    </property>
+                </widget>
+            </vbox>
+        </widget>
+    </grid>
+</widget>
+<layoutdefaults spacing="6" margin="11"/>
+</UI>
Index: kicker/kicker/ui/k_mnu_stub.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/k_mnu_stub.cpp
@@ -0,0 +1,141 @@
+/*****************************************************************
+
+Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include "k_mnu_stub.h"
+#include "k_new_mnu.h"
+#include "k_mnu.h"
+
+void KMenuStub::removeClientMenu(int id)
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->removeClientMenu(id);
+    return m_w.panelkmenu->removeClientMenu(id);
+}
+
+int KMenuStub::insertClientMenu(KickerClientMenu *p)
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->insertClientMenu(p);
+    return m_w.panelkmenu->insertClientMenu(p);
+}
+
+void KMenuStub::adjustSize()
+{ 
+    if(m_type == t_KMenu)
+	return m_w.kmenu->adjustSize();
+    return m_w.panelkmenu->adjustSize();
+}
+
+void KMenuStub::hide()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->hide();
+    return m_w.panelkmenu->hide();
+}
+
+void KMenuStub::show()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->show();
+    return m_w.panelkmenu->show();
+}
+
+void KMenuStub::showMenu()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->showMenu();
+    return m_w.panelkmenu->showMenu();
+}
+
+#if 0
+void KMenuStub::resize()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->resize();
+    return m_w.panelkmenu->resize();
+}
+#endif
+
+void KMenuStub::popup(const QPoint &pos, int indexAtPoint)
+{   
+    return m_type == t_KMenu ?
+	m_w.kmenu->popup(pos, indexAtPoint)
+       : m_w.panelkmenu->popup(pos, indexAtPoint);
+}
+
+void KMenuStub::selectFirstItem()
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->selectFirstItem();
+    return m_w.panelkmenu->selectFirstItem();
+}
+
+void KMenuStub::resize(int w, int h)
+{   
+    if(m_type == t_KMenu)
+	return m_w.kmenu->resize(w, h);
+    return m_w.panelkmenu->resize(w, h);
+}
+
+QSize KMenuStub::sizeHint() const
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->sizeHint();
+    return m_w.panelkmenu->sizeHint();
+}
+
+bool KMenuStub::highlightMenuItem( const QString &menuId )
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->highlightMenuItem(menuId);
+    return m_w.panelkmenu->highlightMenuItem(menuId);
+}
+
+void KMenuStub::clearRecentMenuItems()
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->clearRecentAppsItems();
+    return m_w.panelkmenu->clearRecentMenuItems();
+}
+
+void KMenuStub::initialize()
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->initialize();
+    return m_w.panelkmenu->initialize();
+}
+
+bool KMenuStub::isVisible() const
+{
+    if(m_type == t_KMenu)
+	return m_w.kmenu->isVisible();
+    return m_w.panelkmenu->isVisible();
+}
+
+QWidget* KMenuStub::widget()
+{ 
+    if(m_type == t_KMenu)
+	return m_w.kmenu;
+    return m_w.panelkmenu;
+}
+
Index: kicker/kicker/ui/k_mnu_stub.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/k_mnu_stub.h
@@ -0,0 +1,72 @@
+/*****************************************************************
+
+Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef __k_mnu_stub_h__
+#define __k_mnu_stub_h__
+
+#include <qstring.h>
+#include <qpoint.h>
+
+class KickerClientMenu;
+class KMenu;
+class PanelKMenu;
+
+
+
+
+class KMenuStub
+{
+public:
+    KMenuStub(KMenu* _kmenu) 
+      : m_type(t_KMenu)  { m_w.kmenu = _kmenu; }
+    KMenuStub(PanelKMenu* _panelkmenu) 
+      : m_type(t_PanelKMenu) { m_w.panelkmenu = _panelkmenu; }
+    ~KMenuStub() {} 
+
+    void removeClientMenu(int id);
+    int insertClientMenu(KickerClientMenu *p);
+    void adjustSize();
+    void hide();
+    void show();
+    void showMenu();
+    void resize();
+    void popup(const QPoint &pos, int indexAtPoint = -1);
+    void selectFirstItem();
+    void resize(int, int);
+    QSize sizeHint() const;
+    bool highlightMenuItem( const QString &menuId );
+    void clearRecentMenuItems();
+    void initialize();
+
+    QWidget* widget();
+
+    bool isVisible() const;
+private:
+     enum {t_PanelKMenu, t_KMenu} m_type;
+     union {
+        KMenu* kmenu;
+        PanelKMenu* panelkmenu;
+     } m_w;
+};
+
+#endif
Index: kicker/kicker/ui/k_new_mnu.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/k_new_mnu.cpp
@@ -0,0 +1,3876 @@
+/*****************************************************************
+
+   Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+   Copyright (c) 2006 Dirk Mueller <mueller@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <dmctl.h>
+#include <inttypes.h>
+
+#include <qimage.h>
+#include <qpainter.h>
+#include <qstyle.h>
+#include <qwidgetstack.h>
+#include <qlayout.h>
+#include <qlabel.h>
+#include <qregexp.h>
+#include <qfile.h>
+#include <qstylesheet.h>
+#include <qaccel.h>
+#include <qcursor.h>
+#include <qdir.h>
+#include <qsimplerichtext.h>
+#include <qtooltip.h>
+
+#include <dcopclient.h>
+#include <kapplication.h>
+#include <kaboutkde.h>
+#include <kaction.h>
+#include <kbookmarkmenu.h>
+#include <kconfig.h>
+#include <kdebug.h>
+#include <kglobal.h>
+#include <kglobalsettings.h>
+#include <kiconloader.h>
+#include <klineedit.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kstandarddirs.h>
+#include <kcombobox.h>
+#include <kwin.h>
+#include <kdebug.h>
+#include <kuser.h>
+#include <kurllabel.h>
+#include <krun.h>
+#include <kmimetype.h>
+#include <krecentdocument.h>
+#include <kcompletionbox.h>
+#include <kurifilter.h>
+#include <kbookmarkmanager.h>
+#include <kbookmark.h>
+#include <kprocess.h>
+#include <kio/jobclasses.h>
+#include <kio/job.h>
+#include <dcopref.h>
+#include <konq_popupmenu.h>
+#include <konqbookmarkmanager.h>
+#include <kparts/componentfactory.h>
+
+#include "client_mnu.h"
+#include "container_base.h"
+#include "global.h"
+#include "knewbutton.h"
+#include "kicker.h"
+#include "kickerSettings.h"
+#include "konqbookmarkmanager.h"
+#include "menuinfo.h"
+#include "menumanager.h"
+#include "popupmenutitle.h"
+#include "quickbrowser_mnu.h"
+#include "recentapps.h"
+#include "flipscrollview.h"
+#include "itemview.h"
+#include <dmctl.h>
+#include <sys/vfs.h>
+#include <mykickoffsearchinterface.h>
+
+#include "media_watcher.h"
+#include "k_mnu.h"
+#include "k_new_mnu.h"
+#include "k_new_mnu.moc"
+
+#define WAIT_BEFORE_QUERYING 700
+
+#define IDS_PER_CATEGORY 20
+#define ACTIONS_ID_BASE 10
+#define APP_ID_BASE 10 + IDS_PER_CATEGORY
+#define BOOKMARKS_ID_BASE 10 + (IDS_PER_CATEGORY * 2)
+#define NOTES_ID_BASE 10 + (IDS_PER_CATEGORY * 3)
+#define MAIL_ID_BASE 10 + (IDS_PER_CATEGORY * 4)
+#define FILE_ID_BASE 10 + (IDS_PER_CATEGORY * 5)
+#define MUSIC_ID_BASE 10 + (IDS_PER_CATEGORY * 6)
+#define WEBHIST_ID_BASE 10 + (IDS_PER_CATEGORY * 7)
+#define CHAT_ID_BASE 10 + (IDS_PER_CATEGORY * 8)
+#define FEED_ID_BASE 10 + (IDS_PER_CATEGORY * 9)
+#define PIC_ID_BASE 10 + (IDS_PER_CATEGORY * 10)
+#define VIDEO_ID_BASE 10 + (IDS_PER_CATEGORY * 11)
+#define DOC_ID_BASE 10 + (IDS_PER_CATEGORY * 12)
+#define OTHER_ID_BASE 10 + (IDS_PER_CATEGORY * 13)
+
+static QString calculate(const QString &exp)
+{
+   QString result, cmd;
+   const QString bc = KStandardDirs::findExe("bc");
+   if ( !bc.isEmpty() )
+      cmd = QString("echo %1 | %2").arg(KProcess::quote(exp), KProcess::quote(bc));
+   else
+      cmd = QString("echo $((%1))").arg(exp);
+   FILE *fs = popen(QFile::encodeName(cmd).data(), "r");
+   if (fs)
+   {
+      QTextStream ts(fs, IO_ReadOnly);
+      result = ts.read().stripWhiteSpace();
+      pclose(fs);
+   }
+   return result;
+}
+
+int base_category_id[] = {ACTIONS_ID_BASE, APP_ID_BASE, BOOKMARKS_ID_BASE, NOTES_ID_BASE, MAIL_ID_BASE,
+                          FILE_ID_BASE, MUSIC_ID_BASE, WEBHIST_ID_BASE, CHAT_ID_BASE, FEED_ID_BASE,
+                          PIC_ID_BASE, VIDEO_ID_BASE, DOC_ID_BASE, OTHER_ID_BASE};
+
+#include <assert.h>
+
+static int used_size( QLabel *label, int oldsize )
+{
+    QSimpleRichText st( label->text(), KGlobalSettings::toolBarFont() );
+    st.setWidth( oldsize );
+    return QMAX( st.widthUsed(), oldsize );
+}
+
+KMenu::KMenu()
+  : KMenuBase(0)
+  , m_sloppyTimer(0, "KNewMenu::sloppyTimer"), m_mediaFreeTimer(0, "KNewMenu::mediaFreeTimer"),
+    m_iconName(QString::null), m_activeTab( 0 ), m_orientation( Uninitialized ), m_search_plugin( 0 )
+{
+    setMouseTracking(true);
+    connect(&m_sloppyTimer, SIGNAL(timeout()), SLOT(slotSloppyTimeout()));
+
+    // set the first client id to some arbitrarily large value.
+    client_id = 10000;
+    // Don't automatically clear the main menu.
+    actionCollection = new KActionCollection(this);
+
+    connect(Kicker::the(), SIGNAL(configurationChanged()),
+            this, SLOT(configChanged()));
+
+    KUser * user = new KUser();
+
+    char hostname[256];
+    hostname[0] = '\0';
+    if (!gethostname( hostname, sizeof(hostname) ))
+      hostname[sizeof(hostname)-1] = '\0';
+
+    m_userInfo->setText( i18n( "User&nbsp;<b>%1</b>&nbsp;on&nbsp;<b>%2</b>" )
+                         .arg( user->loginName() ).arg( hostname ) );
+    setupUi();
+
+    m_userInfo->setBackgroundMode( PaletteBase );
+    QColor userInfoColor = QApplication::palette().color( QPalette::Normal, QColorGroup::Mid );
+    if ( qGray( userInfoColor.rgb() ) > 120 )
+        userInfoColor = userInfoColor.dark( 200 );
+    else
+        userInfoColor = userInfoColor.light( 200 );
+    m_userInfo->setPaletteForegroundColor( userInfoColor );
+
+    m_favoriteView = new FavoritesItemView (m_stacker, "m_favoriteView");
+    m_favoriteView->setAcceptDrops(true);
+    m_favoriteView->setItemsMovable(true);
+    m_stacker->addWidget(m_favoriteView, 1);
+
+    m_recentlyView = new ItemView (m_stacker, "m_recentlyView");
+    m_stacker->addWidget(m_recentlyView, 2);
+
+    m_systemView = new ItemView(m_stacker, "m_systemView");
+    m_stacker->addWidget(m_systemView, 3);
+
+    m_browserView = new FlipScrollView(m_stacker, "m_browserView");
+    m_stacker->addWidget(m_browserView, 4);
+    connect( m_browserView, SIGNAL( backButtonClicked() ), SLOT( slotGoBack() ) );
+
+    m_exitView = new FlipScrollView(m_stacker, "m_exitView");
+    m_stacker->addWidget(m_exitView, 5);
+    connect( m_exitView, SIGNAL( backButtonClicked() ), SLOT( slotGoExitMainMenu() ) );
+
+    m_searchWidget = new QVBox (m_stacker, "m_searchWidget");
+    m_searchWidget->setSpacing(0);
+    m_stacker->addWidget(m_searchWidget, 6);
+
+    // search provider icon
+    QPixmap icon;
+    KURIFilterData data;
+    QStringList list;
+    data.setData( QString("some keyword") );
+    list << "kurisearchfilter" << "kuriikwsfilter";
+
+    if ( KURIFilter::self()->filterURI(data, list) ) {
+      QString iconPath = locate("cache", KMimeType::favIconForURL(data.uri()) + ".png");
+      if ( iconPath.isEmpty() )
+        icon = SmallIcon("enhanced_browsing");
+      else
+        icon = QPixmap( iconPath );
+    }
+    else
+      icon = SmallIcon("enhanced_browsing");
+
+    m_searchResultsWidget = new ItemView (m_searchWidget, "m_searchResultsWidget");
+    m_searchResultsWidget->setItemMargin(4);
+    m_searchResultsWidget->setIconSize(16);
+    m_searchActions = new ItemView (m_searchWidget, "m_searchActions");
+    m_searchActions->setFocusPolicy(QWidget::NoFocus);
+    m_searchActions->setItemMargin(4);
+    m_searchInternet = new QListViewItem(m_searchActions, i18n("Search Internet"));
+    m_searchInternet->setPixmap(0,icon);
+    setTabOrder(m_kcommand, m_searchResultsWidget);
+
+    m_kerryInstalled = !KStandardDirs::findExe(QString::fromLatin1("kerry")).isEmpty();
+    m_isShowing = false;
+
+    if (!m_kerryInstalled) {
+       m_searchIndex = 0;
+       m_searchActions->setMaximumHeight(5+m_searchInternet->height());
+    }
+    else {
+       m_searchIndex = new QListViewItem(m_searchActions, i18n("Search Index"));
+       m_searchIndex->setPixmap(0,SmallIcon("kerry"));
+       m_searchActions->setMaximumHeight(5+m_searchIndex->height()*2);
+    }
+    connect(m_searchActions, SIGNAL(clicked(QListViewItem*)), SLOT(searchActionClicked(QListViewItem*)));
+    connect(m_searchActions, SIGNAL(returnPressed(QListViewItem*)), SLOT(searchActionClicked(QListViewItem*)));
+    connect(m_searchActions, SIGNAL(spacePressed(QListViewItem*)), SLOT(searchActionClicked(QListViewItem*)));
+
+    connect(m_searchResultsWidget, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_searchResultsWidget, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_searchResultsWidget, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_recentlyView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_recentlyView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_recentlyView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int  )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_favoriteView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_favoriteView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_favoriteView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int  )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+    connect(m_favoriteView, SIGNAL(moved(QListViewItem*, QListViewItem*, QListViewItem*)), SLOT(slotFavoritesMoved( QListViewItem*, QListViewItem*, QListViewItem* )));
+
+    connect(m_systemView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_systemView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_systemView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_browserView, SIGNAL(startURL(const QString&)), SLOT(slotGoSubMenu(const QString&)));
+    connect(m_browserView, SIGNAL(startService(KService::Ptr)), SLOT(slotStartService(KService::Ptr)));
+    connect(m_browserView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    connect(m_exitView, SIGNAL(startURL(const QString&)), SLOT(slotStartURL(const QString&)));
+    connect(m_exitView, SIGNAL(rightButtonPressed( QListViewItem*, const QPoint &, int )), SLOT(slotContextMenuRequested( QListViewItem*, const QPoint &, int )));
+
+    m_kcommand->setDuplicatesEnabled( false );
+    m_kcommand->setLineEdit(new KLineEdit(m_kcommand, "m_kcommand-lineedit"));
+    m_kcommand->setCompletionMode( KGlobalSettings::CompletionAuto );
+    connect(m_kcommand, SIGNAL(cleared()), SLOT(clearedHistory()));
+    connect(m_kcommand->lineEdit(), SIGNAL(returnPressed()), SLOT(searchAccept()));
+    connect(m_kcommand->lineEdit(), SIGNAL(textChanged(const QString &)), SLOT(searchChanged(const QString &)));
+
+    // URI Filter meta object...
+    m_filterData = new KURIFilterData();
+
+    max_category_id = new int [num_categories];
+    categorised_hit_total = new int [num_categories];
+
+    input_timer = new QTimer (this, "input_timer");
+    connect( input_timer, SIGNAL(timeout()), this, SLOT(doQuery()) );
+
+    init_search_timer = new QTimer (this, "init_search_timer");
+    connect( input_timer, SIGNAL(timeout()), this, SLOT(initSearch()) );
+    init_search_timer->start(2000, true);
+
+    connect( m_favoriteView, SIGNAL( dropped (QDropEvent *, QListViewItem * ) ),
+             SLOT( slotFavDropped( QDropEvent *, QListViewItem * ) ) );
+
+    this->installEventFilter(this);
+    m_btnFavorites->installEventFilter(this);
+    m_btnFavorites->setAcceptDrops(true);
+    m_favoriteView->installEventFilter(this);
+    m_btnRecently->installEventFilter(this);
+    m_recentlyView->installEventFilter(this);
+    m_browser->installEventFilter(this);
+    m_browserView->leftView()->installEventFilter(this);
+    m_browserView->rightView()->installEventFilter(this);
+    m_system->installEventFilter(this);
+    m_systemView->installEventFilter(this);
+    m_exit->installEventFilter(this);
+    m_exitView->leftView()->installEventFilter(this);
+    m_exitView->rightView()->installEventFilter(this);
+    m_kcommand->lineEdit()->installEventFilter(this);
+    m_searchLabel->installEventFilter(this);
+    m_searchPixmap->installEventFilter(this);
+    m_stacker->installEventFilter(this);
+
+    connect(this, SIGNAL(clickedFavoritesButton()), SLOT(slotFavoritesButton()));
+    connect(this, SIGNAL(clickedRecentlyButton()), SLOT(slotRecentlyButton()));
+    connect(this, SIGNAL(clickedBrowserButton()), SLOT(slotBrowserButton()));
+    connect(this, SIGNAL(clickedSystemButton()), SLOT(slotSystemButton()));
+    connect(this, SIGNAL(clickedExitButton()), SLOT(slotExitButton()));
+
+    QAccel *a = new QAccel( this );
+    a->connectItem( a->insertItem( QAccel::shortcutKey("&"+m_btnFavorites_text->text().mid(m_btnFavorites_text->text().find("<u>")+3,1))) , this, SLOT(slotFavoritesButton()) );
+    a->connectItem( a->insertItem( QAccel::shortcutKey("&"+m_btnRecently_text->text().mid( m_btnRecently_text->text().find("<u>")+3,1))), this, SLOT(slotRecentlyButton()) );
+    a->connectItem( a->insertItem( QAccel::shortcutKey("&"+m_system_text->text().mid( m_system_text->text().find("<u>")+3,1))), this, SLOT(slotSystemButton()) );
+    a->connectItem( a->insertItem( QAccel::shortcutKey("&"+m_browser_text->text().mid( m_browser_text->text().find("<u>")+3,1))), this, SLOT(slotBrowserButton()) );
+    a->connectItem( a->insertItem( QAccel::shortcutKey("&"+m_exit_text->text().mid( m_exit_text->text().find("<u>")+3,1))), this, SLOT(slotExitButton()) );
+//    a->connectItem( a->insertItem( QAccel::shortcutKey(m_lock->textLabel())), this, SLOT(slotLock())) ;
+
+    m_btnFavorites->setPaletteForegroundColor(Qt::black);
+    m_btnRecently->setPaletteForegroundColor(Qt::black);
+    m_browser->setPaletteForegroundColor(Qt::black);
+    m_system->setPaletteForegroundColor(Qt::black);
+    m_exit->setPaletteForegroundColor(Qt::black);
+    m_searchFrame->setPaletteForegroundColor(Qt::black);
+
+    emailRegExp = QRegExp("^([\\w\\-]+\\.)*[\\w\\-]+@([\\w\\-]+\\.)*[\\w\\-]+$");
+    authRegExp = QRegExp("^[a-zA-Z]+://\\w+(:\\w+)?@([\\w\\-]+\\.)*[\\w\\-]+(:\\d+)?(/.*)?$");
+    uriRegExp = QRegExp("^[a-zA-Z]+://([\\w\\-]+\\.)*[\\w\\-]+(:\\d+)?(/.*)?$");
+    uri2RegExp = QRegExp("^([\\w\\-]+\\.)+[\\w\\-]+(:\\d+)?(/.*)?$");
+
+    m_resizeHandle = new QLabel(this);
+    m_resizeHandle->setBackgroundOrigin( QLabel::ParentOrigin );
+    m_resizeHandle->setScaledContents(true);
+    m_resizeHandle->setFixedSize( 16, 16 );
+    m_searchFrame->stackUnder( m_resizeHandle );
+    m_isresizing = false;
+
+    m_searchPixmap->setPixmap( BarIcon( "find", 32 ) );
+
+//    m_lock->setPixmap( BarIcon( "lock", 32 ) );
+    const int tab_icon_size = 32;
+    pixmapLabel_fav->setPixmap( BarIcon( "bookmark", tab_icon_size ) );
+    pixmapLabel_fav->setFixedSize( tab_icon_size, tab_icon_size );
+    pixmapLabel_recent->setPixmap( BarIcon( "recently_used", tab_icon_size ) );
+    pixmapLabel_recent->setFixedSize( tab_icon_size, tab_icon_size );
+    pixmapLabel_system->setPixmap( BarIcon( "system", tab_icon_size ) );
+    pixmapLabel_system->setFixedSize( tab_icon_size, tab_icon_size );
+    pixmapLabel_browser->setPixmap( BarIcon( "player_playlist", tab_icon_size ) );
+    pixmapLabel_browser->setFixedSize( tab_icon_size, tab_icon_size );
+    pixmapLabel_exit->setPixmap( BarIcon( "leave", tab_icon_size ) );
+    pixmapLabel_exit->setFixedSize( tab_icon_size, tab_icon_size );
+
+    QFont f = font();
+    f.setPointSize( QMAX( 7, qRound( f.pointSize() * 0.80 ) ) );
+    m_exit_text->setFont( f );
+    m_btnFavorites_text->setFont( f );
+    m_btnRecently_text->setFont( f );
+    m_btnRecently_text->setFont( f );
+    m_browser_text->setFont( f );
+    m_system_text->setFont( f );
+    m_exit_text->setFont( f );
+
+    f.setPointSize( QMAX( 7, qRound( f.pointSize() * 1.50 ) ) );
+    m_searchLabel->setFont( f );
+
+    int minwidth = 32;
+    minwidth = used_size( m_btnFavorites_text, minwidth );
+    minwidth = used_size( m_btnRecently_text, minwidth );
+    minwidth = used_size( m_btnRecently_text, minwidth );
+    minwidth = used_size( m_browser_text, minwidth );
+    minwidth = used_size( m_system_text, minwidth );
+    minwidth = used_size( m_exit_text, minwidth );
+
+    m_btnFavorites_text->setMinimumWidth( minwidth );
+    m_btnRecently_text->setMinimumWidth( minwidth );
+    m_browser_text->setMinimumWidth( minwidth );
+    m_system_text->setMinimumWidth( minwidth );
+    m_exit_text->setMinimumWidth( minwidth );
+
+    const int bottom_margin = qRound(3. * QPaintDevice::x11AppDpiY( x11Screen () ) / 72.);
+
+    m_btnFavorites_spacer->changeSize( 1, bottom_margin, QSizePolicy::Fixed,  QSizePolicy::Fixed);
+    m_btnRecently_spacer->changeSize( 1, bottom_margin, QSizePolicy::Fixed,  QSizePolicy::Fixed );
+    m_browser_spacer->changeSize( 1, bottom_margin, QSizePolicy::Fixed,  QSizePolicy::Fixed );
+    m_system_spacer->changeSize( 1, bottom_margin, QSizePolicy::Fixed,  QSizePolicy::Fixed );
+    m_exit_spacer->changeSize( 1, bottom_margin, QSizePolicy::Fixed,  QSizePolicy::Fixed );
+
+#if KDE_IS_VERSION( 3, 5, 4 )
+    static_cast<KLineEdit*>(m_kcommand->lineEdit())->setClickMessage(i18n( "Applications, Contacts and Documents" ) );
+#endif
+
+    bookmarkManager = 0;
+    m_addressBook = 0;
+    m_popupMenu = 0;
+
+    main_border_lc.load( locate("appdata", "pics/main_border_lc.png" ) );
+    main_border_rc.load( locate("appdata", "pics/main_border_rc.png" ) );
+
+    main_border_tl.load( locate("appdata", "pics/main_corner_tl.png" ) );
+    main_border_tr.load( locate("appdata", "pics/main_corner_tr.png" ) );
+
+    search_tab_left.load( locate("appdata", "pics/search-tab-left.png" ) );
+    search_tab_right.load( locate("appdata", "pics/search-tab-right.png" ) );
+    search_tab_center.load( locate("appdata", "pics/search-tab-center.png" ) );
+
+    QToolTip::add( m_btnRecently, "<qt>" + i18n( "Recently used applications and documents" ) + "</qt>" );
+    QToolTip::add( m_btnFavorites, "<qt>" + i18n( "Most commonly used applications and documents" )  + "</qt>" );
+    QToolTip::add( m_browser, "<qt>" + i18n( "List of installed applications" ) + "</qt>" );
+    QToolTip::add( m_system, "<qt>" + i18n( "Information and configuration of your system, access to "
+                                            "personal files, network resources and connected disk drives" ) + "</qt>" );
+#warning FIXME after test
+//    QToolTip::add( m_exit, "<qt>" + i18n( "Logout, switch user, switch off or reset, suspend of the system" ) + "</qt>" );
+    QToolTip::add( m_exit, i18n( "<qt>Logout, switch user, switch off or reset, suspend of the system" ) + "</qt>" );
+    QToolTip::add( m_searchFrame, "<qt>" + i18n( "Search for personal files and applications" ) + "</qt>" );
+//    QToolTip::add( m_lock, "<qt>" + i18n( "Locks screen for the current session" ) + "</qt>" );
+//    QToolTip::add( m_helpLabel, "<qt>" + i18n( "Shows Help" ) + "</qt>" );
+
+    setOrientation(BottomUp);
+}
+
+void KMenu::setupUi()
+{
+    m_stacker = new QWidgetStack( this, "m_stacker" );
+    m_stacker->setGeometry( QRect( 90, 260, 320, 220 ) );
+    m_stacker->setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)3, (QSizePolicy::SizeType)3, 1, 1, m_stacker->sizePolicy().hasHeightForWidth() ) );
+    m_stacker->setPaletteBackgroundColor( QColor( 255, 255, 255 ) );
+   // m_stacker->setFocusPolicy( QWidget::StrongFocus );
+    m_stacker->setLineWidth( 0 );
+    m_stacker->setFocusPolicy(QWidget::NoFocus);
+    connect(m_stacker, SIGNAL(aboutToShow(QWidget*)), SLOT(stackWidgetRaised(QWidget*)));
+
+    m_kcommand->setName("m_kcommand");
+
+}
+
+KMenu::~KMenu()
+{
+    saveConfig();
+
+    clearSubmenus();
+    delete m_filterData;
+}
+
+bool KMenu::loadSidePixmap()
+{
+    if (!KickerSettings::useSidePixmap())
+    {
+        return false;
+    }
+
+    QString sideName = KickerSettings::sidePixmapName();
+    QString sideTileName = KickerSettings::sideTileName();
+
+    QImage image;
+    image.load(locate("data", "kicker/pics/" + sideName));
+
+    if (image.isNull())
+    {
+        kdDebug(1210) << "Can't find a side pixmap" << endl;
+        return false;
+    }
+
+    KickerLib::colorize(image);
+    sidePixmap.convertFromImage(image);
+
+    image.load(locate("data", "kicker/pics/" + sideTileName));
+
+    if (image.isNull())
+    {
+        kdDebug(1210) << "Can't find a side tile pixmap" << endl;
+        return false;
+    }
+
+    KickerLib::colorize(image);
+    sideTilePixmap.convertFromImage(image);
+
+    if (sidePixmap.width() != sideTilePixmap.width())
+    {
+        kdDebug(1210) << "Pixmaps have to be the same size" << endl;
+        return false;
+    }
+
+    // pretile the pixmap to a height of at least 100 pixels
+    if (sideTilePixmap.height() < 100)
+    {
+        int tiles = (int)(100 / sideTilePixmap.height()) + 1;
+        QPixmap preTiledPixmap(sideTilePixmap.width(), sideTilePixmap.height() * tiles);
+        QPainter p(&preTiledPixmap);
+        p.drawTiledPixmap(preTiledPixmap.rect(), sideTilePixmap);
+        sideTilePixmap = preTiledPixmap;
+    }
+
+    return true;
+}
+
+bool KMenu::eventFilter ( QObject * receiver, QEvent* e)
+{
+//kdDebug() << "eventFilter receiver=" << receiver->name() << "  type=" << e->type() << endl;
+    QWidget* raiseWidget = 0;
+    QFrame *raiseFrame = 0;
+
+    if (e->type() ==  QEvent::KeyPress ||
+        e->type() == QEvent::MouseButtonPress ||
+        e->type() == QEvent::MouseMove
+        || e->type() == QEvent::FocusIn
+        || e->type() == QEvent::Wheel) {
+        QPoint p;
+
+        if (e->type() == QEvent::MouseMove) {
+            QMouseEvent* me = static_cast<QMouseEvent*>(e);
+            p = me->globalPos();
+        }
+        else if (e->type() == QEvent::Wheel) {
+            QWheelEvent* we = static_cast<QWheelEvent*>(e);
+            p = we->globalPos();
+        }
+
+	while (receiver) {
+	    if (receiver == m_browser)
+		raiseWidget = m_browserView;
+	    if (receiver == m_btnFavorites)
+		raiseWidget = m_favoriteView;
+	    if (receiver == m_btnRecently)
+		raiseWidget = m_recentlyView;
+	    if (receiver == m_system)
+		raiseWidget = m_systemView;
+	    if (receiver == m_exit)
+		raiseWidget = m_exitView;
+	    if ( raiseWidget )
+		raiseFrame = dynamic_cast<QFrame*>(receiver);
+            /* we do not want hover activation for the search line edit as this can be
+             * pretty disturbing */
+	    if ( (receiver == m_searchPixmap ||
+                  ( ( receiver == m_searchLabel || receiver==m_kcommand->lineEdit() ) &&
+                    ( e->type() == QEvent::KeyPress || e->type() == QEvent::Wheel ||
+                      e->type() == QEvent::MouseButtonPress  ) ) )
+                 && !m_isShowing) {
+		 raiseWidget = m_searchWidget;
+		 raiseFrame = m_searchFrame;
+	    }
+
+	    if(raiseWidget)
+		break;
+	    if(receiver->isWidgetType())
+		receiver = static_cast<QWidget*>(receiver)->parentWidget(true);
+	    else
+		break;
+	}
+
+        if (e->type() == QEvent::FocusIn && receiver && raiseWidget) {
+            m_searchResultsWidget->setFocusPolicy(QWidget::StrongFocus);
+            m_searchActions->setFocusPolicy(raiseWidget == m_searchWidget ?
+                    QWidget::StrongFocus : QWidget::NoFocus);
+            setTabOrder(raiseWidget, m_searchResultsWidget);
+            if (raiseWidget != m_stacker->visibleWidget()
+                && static_cast<QWidget*>(receiver)->focusPolicy() == QWidget::NoFocus
+                && m_stacker->id(raiseWidget) >= 0) {
+
+                raiseStackWidget(raiseWidget);
+                return true;
+            }
+
+            if (raiseWidget->focusPolicy() != QWidget::NoFocus)
+                return false;
+        }
+
+	if (m_sloppyRegion.contains(p)) {
+            if (!m_sloppyTimer.isActive() || m_sloppyFrame != raiseFrame)
+                m_sloppyTimer.start(style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay)/2);
+	    m_sloppyWidget = raiseWidget;
+	    m_sloppyFrame = raiseFrame;
+	    return false;
+	}
+    }
+
+    if(e->type() == QEvent::Enter && receiver->isWidgetType()) {
+	static_cast<QWidget*>(receiver)->setMouseTracking(true);
+        QToolTip::hide();
+    }
+
+    if ( ( e->type() == QEvent::DragEnter || e->type() == QEvent::DragMove ) &&
+         receiver == m_btnFavorites )
+    {
+        if ( m_activeTab != m_btnFavorites )
+            QTimer::singleShot( 0, this, SLOT( slotFavoritesButton() ) );
+
+	return false;
+    }
+
+    // This is a nightmare of a hack, look away. Logic needs
+    // to be moved to the stacker and all widgets in the stacker
+    // must have focusNextPrevChild() overwritten to do nothing
+    if (e->type() == QEvent::KeyPress && raiseFrame) {
+        ItemView* view;
+        if (m_browserView==m_stacker->visibleWidget())
+            view = m_browserView->currentView();
+        else if (m_exitView==m_stacker->visibleWidget())
+            view = m_exitView->currentView();
+        else
+            view = dynamic_cast<ItemView*>(m_stacker->visibleWidget());
+
+        if (view)
+        {
+            bool handled = true;
+            switch (static_cast<QKeyEvent*>(e)->key()) {
+                case Key_Up:
+                    if (view->selectedItem()) {
+                        view->setSelected(view->selectedItem()->itemAbove(),true);
+                    }
+                    else {
+                        view->setSelected(view->lastItem(),true);
+                    }
+                    break;
+                case Key_Down:
+                    if (view->selectedItem()) {
+                        view->setSelected(view->selectedItem()->itemBelow(),true);
+                    }
+                    else {
+                        view->setSelected(view->firstChild(),true);
+                    }
+                    break;
+                case Key_Right:
+                    if (view->selectedItem() && !static_cast<KMenuItem*>(view->selectedItem())->hasChildren())
+                        break;
+                    // nobreak
+                case Key_Enter:
+                case Key_Return:
+                    if (view->selectedItem())
+                        view->slotItemClicked(view->selectedItem());
+
+                    break;
+                case Key_Left:
+                    if (view->selectedItem() && !static_cast<KMenuItem*>(view->selectedItem())->hasChildren())
+                        break;
+                    // nobreak
+                case Key_Backspace:
+                    if ((m_browserView == m_stacker->visibleWidget() || m_exitView == m_stacker->visibleWidget())
+                            && view->firstChild())
+                        view->slotItemClicked(view->firstChild());
+
+                    break;
+                default:
+                    handled = false;
+            }
+
+            if (handled)
+                view->ensureItemVisible(view->selectedItem());
+
+            return handled;
+        }
+    }
+
+    bool r = KMenuBase::eventFilter(receiver, e);
+
+    if (!r && raiseWidget)
+	raiseStackWidget(raiseWidget);
+
+    if (e->type() == QEvent::Wheel && raiseWidget )
+    {
+        // due to an ugly Qt bug we have to kill wheel events
+        // that cause focus switches
+        r = true;
+    }
+
+    if (e->type() == QEvent::Enter && receiver == m_stacker)
+    {
+        QRect r(m_stacker->mapToGlobal(QPoint(-8,-64)), m_stacker->size());
+        r.setSize(r.size()+QSize(16,128));
+
+        m_sloppyRegion = QRegion(r);
+    }
+
+    // redo the sloppy region
+    if (e->type() == QEvent::MouseMove && !r && raiseWidget)
+    {
+        QPointArray points(4);
+
+        points.setPoint(0, m_stacker->mapToGlobal(m_stacker->rect().bottomLeft()));
+        points.setPoint(1, m_stacker->mapToGlobal(m_stacker->rect().bottomRight()));
+
+        // hmm, eventually this should be mouse position + 10px, not
+        // just worst case. but worst case seems to work fine enough.
+        QPoint edge(raiseFrame->mapToGlobal(QPoint(0,0)));
+        edge.setY(edge.y()+raiseFrame->rect().height());
+        edge.setX(edge.x()+raiseFrame->rect().center().x());
+
+        points.setPoint(2, edge+QPoint(-16,0));
+        points.setPoint(3, edge+QPoint(16,0));
+
+        m_sloppyRegion = QRegion(points);
+    }
+
+    return r;
+}
+
+void KMenu::slotBrowserButton()
+{
+    if ( m_activeTab == m_browser)
+       slotGoSubMenu(QString::null);
+    else
+       raiseStackWidget( m_browserView );
+}
+
+void KMenu::slotSystemButton()
+{
+    raiseStackWidget( m_systemView );
+}
+
+void KMenu::slotExitButton()
+{
+    if ( m_activeTab == m_exit)
+       slotGoExitMainMenu();
+    else
+       raiseStackWidget( m_exitView );
+}
+
+void KMenu::slotRecentlyButton()
+{
+    raiseStackWidget( m_recentlyView );
+}
+
+void KMenu::slotFavoritesButton()
+{
+    raiseStackWidget( m_favoriteView );
+}
+
+void KMenu::slotSloppyTimeout()
+{
+    if (m_sloppyRegion.contains(QCursor::pos())
+        && m_sloppyFrame)
+    {
+        QRect sloppyFrameRect(m_sloppyFrame->mapToGlobal(QPoint(0,0)),
+                m_sloppyFrame->size());
+
+        if ( sloppyFrameRect.contains(QCursor::pos()))
+        {
+            raiseStackWidget(m_sloppyWidget);
+
+            m_sloppyWidget = 0;
+            m_sloppyFrame = 0;
+            m_sloppyRegion = QRegion();
+        }
+    }
+    m_sloppyTimer.stop();
+}
+
+void KMenu::paintSearchTab( bool active )
+{
+    QPixmap canvas( m_searchFrame->size() );
+    QPainter p( &canvas );
+
+    QPixmap pix;
+
+    if ( m_orientation == BottomUp )
+        pix.load( locate("appdata", "pics/search-gradient.png" ) );
+    else
+        pix.load( locate("appdata", "pics/search-gradient-topdown.png" ) );
+
+    pix.convertFromImage( pix.convertToImage().scale(pix.width(), m_searchFrame->height()));
+    p.drawTiledPixmap( 0, 0, m_searchFrame->width(), m_searchFrame->height(), pix );
+
+    if ( active ) {
+
+        p.setBrush( Qt::white );
+        p.setPen( Qt::NoPen );
+
+        search_tab_center.convertFromImage( search_tab_center.convertToImage().scale(search_tab_center.width(), m_searchFrame->height()));
+        p.drawTiledPixmap( search_tab_left.width(), 0, m_searchFrame->width()-search_tab_left.width()-search_tab_right.width(), m_searchFrame->height(), search_tab_center );
+
+        search_tab_left.convertFromImage( search_tab_left.convertToImage().scale(search_tab_left.width(), m_searchFrame->height()));
+        p.drawPixmap( 0, 0, search_tab_left );
+
+        search_tab_right.convertFromImage( search_tab_right.convertToImage().scale(search_tab_right.width(), m_searchFrame->height()));
+        p.drawPixmap( m_searchFrame->width()-search_tab_right.width(), 0, search_tab_right );
+    }
+
+    p.end();
+    m_searchFrame->setPaletteBackgroundPixmap( canvas );
+}
+
+void KMenu::paintTab( QFrame *tab, bool active )
+{
+    if ( !tab )
+        return;
+
+    if ( tab==m_searchFrame ) {
+        paintSearchTab( active );
+        return;
+    }
+
+    QPixmap canvas( tab->size() );
+    QPainter p( &canvas );
+
+    QPixmap pix;
+
+    if ( m_orientation == BottomUp )
+        pix.load( locate( "appdata", "pics/button-box-gradient.png" ) );
+    else
+        pix.load( locate( "appdata", "pics/button-box-gradient-topdown.png" ) );
+
+    pix.convertFromImage( pix.convertToImage().scale(1, tab->height()));
+    p.drawTiledPixmap( 0, 0, tab->width(), tab->height(), pix );
+
+    pix.load( locate( "appdata", "pics/button-box-top.png" ) );
+    p.drawTiledPixmap( 0, 0, tab->width(), pix.height(), pix );
+    int xpos = pix.width();
+
+    pix.load( locate( "appdata", "pics/button-box-left-corner.png" ) );
+    if ( tab->x() < pix.width() )
+        p.drawPixmap( xpos, 0, pix );
+
+    pix.load( locate( "appdata", "pics/button-box-right-corner.png" ) );
+    if ( tab->geometry().right() + pix.width() >= buttonBox->mainWidget()->width() )
+    {
+        p.drawPixmap( tab->width() - pix.width(), 0, pix );
+    }
+
+    const int bottom_margin = m_btnFavorites_spacer->sizeHint().height();
+
+    if ( active ) {
+
+        p.setBrush( Qt::white );
+        p.setPen( Qt::NoPen );
+        const int left = tab_bottom_left.width();
+        const int right = tab_bottom_right.width();
+        if ( m_orientation == BottomUp )
+        {
+            p.drawRect( tab_left_center.width(), 0,
+                    tab->width() - tab_left_center.width() - tab_right_center.width(),
+                    tab->height() - tab_center.height() - bottom_margin );
+
+            p.drawTiledPixmap( left, tab->height() - tab_center.height() - bottom_margin,
+                    tab->width() - left - right,
+                    tab_center.height(), tab_center );
+        }
+        else {
+            p.drawRect( tab_left_center.width(), tab_center.height() + bottom_margin,
+                    tab->width() - tab_left_center.width() - tab_right_center.width(),
+                    tab->height() - tab_center.height() );
+
+            p.drawTiledPixmap( left, bottom_margin,
+                    tab->width() - left - right,
+                    tab_center.height(), tab_center );
+        }
+
+
+        /* spills out tons of warnings ;(
+         * QPixmap tab_center_rest = tab_center;
+         * tab_center_rest.resize( tab_center.width(), tab_center.height() - tab_bottom_left.height() );
+         */
+
+
+        if ( m_orientation == BottomUp )
+        {
+            QPixmap tab_center_rest( tab_center.width(), tab_center.height() - tab_bottom_left.height() );
+            QPainter pixp( &tab_center_rest );
+            pixp.drawPixmap( 0, 0, tab_center );
+            pixp.end();
+
+            p.drawTiledPixmap( tab_left_center.width(),
+                    tab->height() - tab_center.height() - bottom_margin,
+                    left - tab_left_center.width(),
+                    tab_center.height() - tab_bottom_left.height(),
+                    tab_center_rest );
+            p.drawTiledPixmap( tab->width() - right,
+                    tab->height() - tab_center.height() - bottom_margin,
+                    right - tab_left_center.width(),
+                    tab_center.height() - tab_bottom_left.height(),
+                    tab_center_rest );
+
+            // top left corner
+            p.drawPixmap( 0, 0, tab_top_left );
+            // top right corner
+            p.drawPixmap( tab->width() - tab_bottom_right.width(), 0,
+                    tab_top_right );
+            // bottom left corner
+            p.drawPixmap( 0,
+                    tab->height() - tab_bottom_left.height() - bottom_margin,
+                    tab_bottom_left );
+            // left edge, between corners
+            p.drawTiledPixmap( 0, tab_top_left.height(),
+                    tab_left_center.width(),
+                    tab->height() - tab_bottom_left.height() - tab_top_left.height() - bottom_margin,
+                    tab_left_center );
+            // right edge, between corners
+            p.drawTiledPixmap( tab->width() - tab_right_center.width(),
+                    0,
+                    tab_left_center.width(),
+                    tab->height() - tab_bottom_right.height() - bottom_margin,
+                    tab_right_center );
+            // bottom right corner
+            p.drawPixmap( tab->width() - tab_bottom_right.width(),
+                    tab->height() - tab_bottom_right.height() - bottom_margin,
+                    tab_bottom_right );
+        }
+        else
+        {
+            QPixmap tab_center_rest( tab_center.width(), tab_center.height() - tab_bottom_left.height() );
+            QPainter pixp( &tab_center_rest );
+            pixp.drawPixmap( 0, -( tab_bottom_left.height() ), tab_center );
+            pixp.end();
+
+            p.drawTiledPixmap( tab_left_center.width(),
+                    bottom_margin + tab_top_left.height(),
+                    left - tab_left_center.width(),
+                    tab_center_rest.height()/* - tab_bottom_left.height()*/,
+                    tab_center_rest );
+
+            p.drawTiledPixmap( tab->width() - right,
+                    bottom_margin + tab_top_left.height(),
+                    /*tab->height() - tab_center.height() - bottom_margin,*/
+                    right - tab_right_center.width(),
+
+                    tab_center_rest.height(),
+                    tab_center_rest );
+
+            // top left corner
+            p.drawPixmap( 0, bottom_margin, tab_top_left );
+            // bottom left corner
+            p.drawPixmap( 0, tab->height() - tab_bottom_left.height(),
+                    tab_bottom_left );
+            // left edge, between corners
+              p.drawTiledPixmap( 0, tab_top_left.height() + bottom_margin,
+              tab_left_center.width(),
+              tab->height() - tab_bottom_left.height() - tab_top_left.height() - bottom_margin,
+              tab_left_center );
+            // right edge, between corners
+            p.drawTiledPixmap( tab->width() - tab_right_center.width(), tab_top_right.height() + bottom_margin,
+            tab_bottom_right.width(),
+            tab->height() - tab_top_right.height() - tab_bottom_right.height() - bottom_margin,
+            tab_right_center );
+
+            // top right corner
+            p.drawPixmap( tab->width() - tab_bottom_right.width(),
+                    bottom_margin, tab_top_right );
+            // bottom right corner
+            p.drawPixmap( tab->width() - tab_bottom_right.width(),
+                    tab->height() - tab_bottom_right.height(), tab_bottom_right );
+        }
+
+    }
+
+    p.end();
+    tab->setPaletteBackgroundPixmap( canvas );
+}
+
+void KMenu::stackWidgetRaised(QWidget* raiseWidget)
+{
+    QFrame * frame = 0;
+
+    if (raiseWidget == m_searchWidget)
+	frame = m_searchFrame;
+    else if (raiseWidget == m_browserView) {
+        if ( m_activeTab == m_browser)
+          return;
+
+	frame = m_browser;
+        if (m_browserDirty ) {
+          createNewProgramList();
+          m_browserView->prepareRightMove();
+          m_browserView->currentView()->clear();
+          fillSubMenu(QString::null, m_browserView->currentView());
+          m_browserDirty = false;
+        }
+    }
+    else if (raiseWidget == m_systemView)
+	frame = m_system;
+    else if (raiseWidget==m_recentlyView) {
+	frame = m_btnRecently;
+        if (m_recentDirty)
+            updateRecent();
+    }
+    else if (raiseWidget == m_favoriteView)
+	frame = m_btnFavorites;
+    else if (raiseWidget == m_exitView) {
+        if ( m_activeTab == m_exit )
+          return;
+
+	frame = m_exit;
+        slotGoExitMainMenu();
+    }
+
+    if (!frame)
+      return;
+
+    if ( m_activeTab == frame )
+        return;
+
+    paintTab( m_activeTab, false );
+    paintTab( frame, true );
+
+   // if (dynamic_cast<QScrollView*>(raiseWidget))
+   //     m_activeTab->setFocusProxy(static_cast<QScrollView*>(raiseWidget)->viewport());
+
+    if (0 && /*raiseWidget == m_stacker->visibleWidget() &&*/ !raiseWidget->hasFocus()) {
+
+        if (dynamic_cast<QScrollView*>(raiseWidget))
+            static_cast<QScrollView*>(raiseWidget)->viewport()->setFocus();
+        else
+            raiseWidget->setFocus();
+    }
+
+    m_activeTab = frame;
+
+    m_sloppyRegion = QRegion();
+    m_sloppyTimer.stop();
+
+    ItemView* view;
+    if (raiseWidget == m_browserView)
+        view = m_browserView->currentView();
+    else if (raiseWidget == m_exitView)
+        view = m_exitView->currentView();
+    else
+        view = dynamic_cast<ItemView*>(m_stacker->visibleWidget());
+    if (view && !view->selectedItem()) {
+	if (view->firstChild() && view->firstChild()->isSelectable()) {
+     	    view->setSelected(view->firstChild(),true);
+        }
+        else if (view->childCount()>1) {
+       	    view->setSelected(view->firstChild()->itemBelow(),true);
+        }
+    }
+}
+
+void KMenu::raiseStackWidget( QWidget *raiseWidget )
+{
+    if (!raiseWidget)
+      return;
+
+
+    m_stacker->raiseWidget(raiseWidget);
+}
+
+void KMenu::paletteChanged()
+{
+    if (!loadSidePixmap())
+    {
+        sidePixmap = sideTilePixmap = QPixmap();
+        setMinimumSize( sizeHint() );
+    }
+}
+
+void KMenu::slotGoBack()
+{
+    goSubMenu( m_browserView->currentView()->backPath() );
+}
+
+void KMenu::slotGoExitMainMenu()
+{
+    if (m_exitView->currentView()==m_exitView->rightView()) {
+      m_exitView->prepareLeftMove(false);
+      m_exitView->showBackButton(false);
+      m_exitView->flipScroll(QString::null);
+    }
+}
+
+void KMenu::slotGoExitSubMenu(const QString& url)
+{
+    m_exitView->prepareRightMove();
+    m_exitView->showBackButton(true);
+
+    int nId = serviceMenuEndId() + 1;
+    int index = 1;
+
+    if (url=="kicker:/restart/") {
+      QStringList rebootOptions;
+      int def, cur;
+      if ( DM().bootOptions( rebootOptions, def, cur ) )
+      {
+        if ( cur == -1 )
+            cur = def;
+
+        int boot_index = rebootOptions.count() - 1;
+        QStringList::ConstIterator it = rebootOptions.end();
+        --it;
+        for (; it != rebootOptions.end(); --it, --boot_index)
+        {
+
+            QString option = i18n( "Start '%1'" ).arg( *it );
+            if (boot_index == cur)
+                option = i18n("Start '%1' (current)").arg( *it );
+            m_exitView->rightView()->insertItem( "reload", option,
+                    i18n( "Restart and boot directly into '%1'").arg( *it ),
+                    QString( "kicker:/restart_%1" ).arg( boot_index ), nId++, index++ );
+        }
+        m_exitView->rightView()->insertHeader( nId++, "kicker:/restart/" );
+      }
+    }
+    else /*if (url=="kicker:/switchuser/") */{
+        m_exitView->rightView()->insertItem( "switchuser", i18n( "Start New Session" ),
+                     i18n( "Start a parallel session" ), "kicker:/switchuser", nId++, index++ );
+
+        m_exitView->rightView()->insertItem( "lock", i18n( "Lock Current && Start New Session").replace("&&","&"),
+                     i18n( "Lock screen and start a parallel session" ), "kicker:/switchuserafterlock", nId++, index++ );
+
+       SessList sess;
+       if (DM().localSessions( sess )) {
+          if (sess.count()>1)
+              m_exitView->rightView()->insertSeparator( nId++, QString::null, index++ );
+          for (SessList::ConstIterator it = sess.begin(); it != sess.end(); ++it) {
+              if ((*it).vt && !(*it).self) {
+                  QString user, loc;
+                  DM().sess2Str2( *it, user, loc );
+                  QStringList list = QStringList::split(":", user);
+                  m_exitView->rightView()->insertItem( "switchuser", i18n( "Switch to Session of User '%1'").arg(list[0]),
+                     i18n("Session: %1").arg(list[1].mid(1)+", "+loc) , QString("kicker:/switchuser_%1").arg((*it).vt), nId++, index++ );
+              }
+          }
+        }
+
+        m_exitView->rightView()->insertHeader( nId++, "kicker:/switchuser/" );
+    }
+    m_exitView->flipScroll(QString::null);
+}
+
+void KMenu::slotGoSubMenu(const QString& relPath)
+{
+     goSubMenu(relPath);
+}
+
+void KMenu::goSubMenu(const QString& relPath, bool keyboard)
+{
+    kdDebug() << "KMenu::goSubMenu(" << relPath << ", " << keyboard <<")" << endl;
+    if ( relPath.startsWith( "kicker:/goup/" ) )
+    {
+        QString rel = relPath.mid( strlen( "kicker:/goup/" ) );
+        int index = rel.length() - 1;
+        if ( rel.endsWith( "/" ) )
+            index--;
+        index = rel.findRev( '/', index );
+        kdDebug() << "goup, rel '" << rel << "' " << index << endl;
+        QString currel = rel;
+        rel = rel.left( index + 1 );
+        if ( rel == "/" )
+            rel = QString::null;
+
+        kdDebug() << "goup, rel '" << rel << "' " << rel.isEmpty() << endl;
+        fillSubMenu( rel, m_browserView->prepareLeftMove() );
+        m_browserView->flipScroll(keyboard ? currel : QString::null);
+        return;
+    } else if (relPath.isEmpty())
+    {
+	if (m_browserView->currentView()->path.isEmpty())
+	    return;
+	fillSubMenu( relPath, m_browserView->prepareLeftMove() );
+    } else if ( relPath.startsWith( "kicker:/new/" ) )
+    {
+        ItemView* view = m_browserView->prepareRightMove();
+        m_browserView->showBackButton( true );
+
+        int nId = serviceMenuEndId() + 1;
+        view->insertHeader( nId++, "new/" );
+        int index = 2;
+        for (QStringList::ConstIterator it = m_newInstalledPrograms.begin();
+            it != m_newInstalledPrograms.end(); ++it) {
+            KService::Ptr p = KService::serviceByStorageId((*it));
+            view->insertMenuItem(p, nId++, index++);
+         }
+    } else
+    {
+        //m_browserView->clear();
+        fillSubMenu(relPath, m_browserView->prepareRightMove());
+    }
+    m_browserView->flipScroll(keyboard ? "kicker:/goup/": QString::null);
+}
+
+void KMenu::fillSubMenu(const QString& relPath, ItemView *view)
+{
+    kdDebug() << "fillSubMenu() " << relPath << endl;
+    KServiceGroup::Ptr root = KServiceGroup::group(relPath);
+    Q_ASSERT( root );
+
+    KServiceGroup::List list = root->entries(true, true, true, KickerSettings::
+            menuEntryFormat() == KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat()
+            == KickerSettings::DescriptionOnly);
+
+    int nId = serviceMenuStartId();
+    m_browserView->showBackButton( !relPath.isEmpty() );
+    if ( !relPath.isEmpty() )
+    {
+        view->insertHeader( nId++, relPath );
+    }
+    else if ( m_newInstalledPrograms.count() ) {
+        KMenuItem *item = view->insertItem( "clock", i18n( "New Applications" ),
+                              QString::null, "kicker:/new/", nId++, -1 );
+        item->setHasChildren( true );
+        view->insertSeparator( nId++, QString::null, -1 );
+    }
+
+    view->path = relPath;
+
+    fillMenu (root, list, relPath, view, nId);
+}
+
+void KMenu::fillMenu(KServiceGroup::Ptr&
+                     , KServiceGroup::List& _list,
+                     const QString& _relPath,
+                     ItemView* view,
+                     int& id)
+{
+    bool separatorNeeded = false;
+    KServiceGroup::List::ConstIterator it = _list.begin();
+
+    for (; it != _list.end(); ++it)
+    {
+        KSycocaEntry * e = *it;
+
+        if (e->isType(KST_KServiceGroup))
+        {
+           KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+            QString groupCaption = g->caption();
+
+           // Avoid adding empty groups.
+            KServiceGroup::Ptr subMenuRoot = KServiceGroup::group(g->relPath());
+
+            int nbChildCount = subMenuRoot->childCount();
+            if (nbChildCount == 0 && !g->showEmptyMenu())
+            {
+                continue;
+            }
+
+            bool is_description = KickerSettings::menuEntryFormat() == KickerSettings::DescriptionAndName ||
+                                  KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly;
+
+            QString inlineHeaderName = g->showInlineHeader() ? groupCaption : "";
+
+            if ( nbChildCount == 1 && g->allowInline() && g->inlineAlias())
+            {
+                KServiceGroup::Ptr element = KServiceGroup::group(g->relPath());
+                if ( element )
+                {
+                    //just one element
+
+                    KServiceGroup::List listElement = element->entries(true, true, true, is_description );
+                    KSycocaEntry * e1 = *( listElement.begin() );
+                    if ( e1->isType( KST_KService ) )
+                    {
+                        KService::Ptr s(static_cast<KService *>(e1));
+                        view->insertMenuItem(s, id++, -1, 0);
+                        continue;
+                    }
+                }
+            }
+
+            if (g->allowInline() && ((nbChildCount <= g->inlineValue() ) ||   (g->inlineValue() == 0)))
+            {
+                //inline all entries
+                KServiceGroup::Ptr rootElement = KServiceGroup::group(g->relPath());
+
+                if (!rootElement || !rootElement->isValid())
+                {
+                    break;
+                }
+
+
+                KServiceGroup::List listElement = rootElement->entries(true, true, true, is_description );
+
+#if 0
+                if ( !g->inlineAlias() && !inlineHeaderName.isEmpty() )
+                {
+                    int mid = view->insertItem(new PopupMenuTitle(inlineHeaderName, font()), id++, id, 0);
+                    m_browserView->setItemEnabled( mid, false );
+                }
+#endif
+
+                fillMenu( rootElement, listElement, g->relPath(), 0, id );
+                continue;
+            }
+
+            // Ignore dotfiles.
+            if ((g->name().at(0) == '.'))
+            {
+                continue;
+            }
+
+            KMenuItem *item = view->insertItem(g->icon(), groupCaption, QString::null, g->relPath(), id++, -1);
+	    item->setMenuPath(g->relPath());
+            item->setHasChildren( true );
+
+#warning FIXME
+#if 0
+            PanelServiceMenu * m =
+                newSubMenu(g->name(), g->relPath(), this, g->name().utf8(), inlineHeaderName);
+            m->setCaption(groupCaption);
+
+            QIconSet iconset = KickerLib::menuIconSet(g->icon());
+
+            if (separatorNeeded)
+            {
+                insertSeparator();
+                separatorNeeded = false;
+            }
+
+            int newId = insertItem(iconset, groupCaption, m, id++);
+            entryMap_.insert(newId, static_cast<KSycocaEntry*>(g));
+            // We have to delete the sub menu our selves! (See Qt docs.)
+            subMenus.append(m);
+#endif
+        }
+        if (e->isType(KST_KService))
+        {
+            KService::Ptr s(static_cast<KService *>(e));
+            if (_relPath.isEmpty()) {
+                QStringList favs = KickerSettings::favorites();
+                if (favs.find(s->storageId())!=favs.end())
+                  continue;
+            }
+            KMenuItem *item = view->insertMenuItem(s, id++, -1);
+	    item->setMenuPath(_relPath+s->menuId());
+        }
+        else if (e->isType(KST_KServiceSeparator))
+        {
+            separatorNeeded = true;
+        }
+    }
+
+    view->slotMoveContent();
+}
+
+void KMenu::initialize()
+{
+    static bool m_initialized=false;
+    if (m_initialized)
+        return;
+    m_initialized = true;
+
+    kdDebug(1210) << "KMenu::initialize()" << endl;
+
+    if (loadSidePixmap())
+    {
+        // in case we've been through here before, let's disconnect
+        disconnect(kapp, SIGNAL(kdisplayPaletteChanged()),
+                this, SLOT(paletteChanged()));
+        connect(kapp, SIGNAL(kdisplayPaletteChanged()),
+                this, SLOT(paletteChanged()));
+    }
+    else
+    {
+        sidePixmap = sideTilePixmap = QPixmap();
+    }
+
+   /*
+       If  the user configured ksmserver to
+     */
+    KConfig ksmserver("ksmserverrc", false, false);
+    ksmserver.setGroup("General");
+/*
+    if (kapp->authorize("lock_screen"))
+        connect( m_lock, SIGNAL(clicked()), SLOT(slotLock()));
+    else
+        m_lock->hide();
+*/
+    connect( m_lock, SIGNAL(clicked()), SLOT(slotPardus()));
+    if (!kapp->authorize("logout"))
+        m_exit->hide();
+
+    // load search field history
+    QStringList histList = KickerSettings::history();
+    int maxHistory = KickerSettings::historyLength();
+
+    bool block = m_kcommand->signalsBlocked();
+    m_kcommand->blockSignals( true );
+    m_kcommand->setMaxCount( maxHistory );
+    m_kcommand->setHistoryItems( histList );
+    m_kcommand->blockSignals( block );
+
+    QStringList compList = KickerSettings::completionItems();
+    if( compList.isEmpty() )
+        m_kcommand->completionObject()->setItems( histList );
+    else
+        m_kcommand->completionObject()->setItems( compList );
+
+    KCompletionBox* box = m_kcommand->completionBox();
+    if (box)
+        box->setActivateOnSelect( false );
+
+    m_finalFilters = KURIFilter::self()->pluginNames();
+    m_finalFilters.remove("kuriikwsfilter");
+
+    m_middleFilters = m_finalFilters;
+    m_middleFilters.remove("localdomainurifilter");
+
+    QStringList favs = KickerSettings::favorites();
+    if (favs.isEmpty()) {
+      QFile f(locate("data", "kicker/default-favs"));
+      if (f.open(IO_ReadOnly)) {
+        QTextStream is(&f);
+
+        while (!is.eof())
+            favs << is.readLine();
+
+        f.close();
+      }
+      KickerSettings::setFavorites(favs);
+      KickerSettings::writeConfig();
+    }
+
+    int nId = serviceMenuEndId() + 1;
+    int index = 1;
+    for (QStringList::ConstIterator it = favs.begin(); it != favs.end(); ++it)
+    {
+       if ((*it)[0]=='/') {
+          KDesktopFile df((*it),true);
+          QString url = df.readURL();
+          if (!KURL(url).isLocalFile() || QFile::exists(url.replace("file://",QString::null)))
+            m_favoriteView->insertItem(df.readIcon(),df.readName(),df.readGenericName(), url, nId++, index++);
+       }
+       else {
+          KService::Ptr p = KService::serviceByStorageId((*it));
+          m_favoriteView->insertMenuItem(p, nId++, index++);
+       }
+    }
+
+    //nId = m_favoriteView->insertSeparator( nId, QString::null, index++ );
+//    m_favoriteView->insertDocument(KURL("help:/khelpcenter/userguide/index.html"), nId++);
+
+    insertStaticItems();
+
+    raiseStackWidget( m_favoriteView );
+}
+
+void KMenu::insertStaticItems()
+{
+    int nId = serviceMenuEndId() + 1;
+    int index = 1;
+
+    m_exitView->leftView()->insertSeparator( nId++, i18n("Session"), index++ );
+    if (kapp->authorize("logout"))
+       m_exitView->leftView()->insertItem( "undo", i18n( "Logout" ),
+                                   i18n( "End session" ), "kicker:/logout", nId++, index++ );
+    if (kapp->authorize("lock_screen"))
+       m_exitView->leftView()->insertItem( "lock", i18n( "Lock" ),
+                                   i18n( "Lock screen" ), "kicker:/lock", nId++, index++ );
+
+    KConfig ksmserver("ksmserverrc", false, false);
+    ksmserver.setGroup("General");
+    if (ksmserver.readEntry( "loginMode" ) == "restoreSavedSession")
+    {
+        m_exitView->leftView()->insertItem("filesave", i18n("Save Session"),
+                               i18n("Save current Session for next login"),
+                               "kicker:/savesession", nId++, index++ );
+    }
+    if (DM().isSwitchable() && kapp->authorize("switch_user"))
+    {
+        KMenuItem *switchuser = m_exitView->leftView()->insertItem( "switchuser", i18n( "Switch User" ),
+                                                                    i18n( "Manage parallel sessions" ), "kicker:/switchuser/", nId++, index++ );
+        switchuser->setHasChildren(true);
+    }
+
+    bool maysd = false;
+    if (ksmserver.readBoolEntry( "offerShutdown", true ) && DM().canShutdown())
+        maysd = true;
+
+    if ( maysd )
+    {
+        m_exitView->leftView()->insertSeparator( nId++, i18n("System"), index++ );
+        m_exitView->leftView()->insertItem( "exit", i18n( "Shutdown Computer" ),
+                                   i18n( "Turn off computer" ), "kicker:/shutdown", nId++, index++ );
+
+        m_exitView->leftView()->insertItem( "reload", i18n( "Restart Computer" ),
+                                            i18n( "Restart and boot this system" ),
+                                            "kicker:/restart", nId++, index++ );
+
+        insertSuspendOption(nId, index);
+
+        int def, cur;
+        QStringList dummy_opts;
+        if ( DM().bootOptions( dummy_opts, def, cur ) )
+        {
+
+            KMenuItem *restart = m_exitView->leftView()->insertItem( "reload", i18n( "Start Operating System" ),
+                                                                     i18n( "Restart and boot another operating system" ),
+                                                                     "kicker:/restart/", nId++, index++ );
+            restart->setHasChildren(true);
+        }
+    }
+
+    index = 1;
+
+    m_systemView->insertSeparator( nId++, i18n("Applications"), index++);
+
+    m_systemView->insertItem( "tasma", i18n( "System Settings" ),
+                                     i18n( "Tasma" ), "/usr/kde/3.5/share/applications/kde/tasma.desktop", nId++, index++ );
+
+    m_systemView->insertItem( "network", i18n( "Network Settings" ),
+                                     i18n( "Network Manager" ), "/usr/kde/3.5/share/applications/kde/network-manager.desktop", nId++, index++ );
+
+    m_systemView->insertItem( "package-manager", i18n( "Package Manager" ),
+                                     i18n( "Package Manager" ), "/usr/kde/3.5/share/applications/kde/packagemanager.desktop", nId++, index++ );
+
+    m_systemView->insertItem( "info", i18n( "System Information" ),
+                              "sysinfo:/",  "sysinfo:/", nId++, index++ );
+
+    m_systemView->insertSeparator( nId++, i18n("System Folders"), index++ );
+
+    m_systemView->insertItem( "folder_red", i18n( "Home Folder" ),
+                              QDir::homeDirPath(), "file://"+QDir::homeDirPath(), nId++, index++ );
+
+    if ( KStandardDirs::exists( KGlobalSettings::documentPath() + "/" ) )
+    {
+        QString documentPath = KGlobalSettings::documentPath();
+        if ( documentPath.endsWith( "/" ) )
+            documentPath = documentPath.left( documentPath.length() - 1 );
+        if (documentPath!=QDir::homeDirPath())
+           m_systemView->insertItem( "folder_green", i18n( "My Documents" ), documentPath, documentPath, nId++, index++ );
+    }
+
+    m_systemView->insertItem( "remote", i18n( "Network Folders" ),
+                              "remote:/", "remote:/", nId++, index++ );
+
+    m_mediaWatcher = new MediaWatcher( this );
+    connect( m_mediaWatcher, SIGNAL( mediumChanged() ), SLOT( updateMedia() ) );
+    m_media_id = 0;
+
+    connect(&m_mediaFreeTimer, SIGNAL(timeout()), SLOT( updateMedia()));
+}
+
+int KMenu::insertClientMenu(KickerClientMenu *)
+{
+#if 0
+    int id = client_id;
+    clients.insert(id, p);
+    return id;
+#endif
+    return 0;
+}
+
+void KMenu::removeClientMenu(int)
+{
+#if 0
+    clients.remove(id);
+    slotClear();
+#endif
+}
+
+extern int kicker_screen_number;
+
+void KMenu::slotLock()
+{
+    kdDebug() << "slotLock " << endl;
+    accept();
+    QCString appname( "kdesktop" );
+    if ( kicker_screen_number )
+        appname.sprintf("kdesktop-screen-%d", kicker_screen_number);
+    kapp->dcopClient()->send(appname, "KScreensaverIface", "lock()", "");
+}
+
+void KMenu::slotPardus()
+{
+    accept();
+    kapp->invokeBrowser("http://www.pardus.org.tr");
+}
+
+void KMenu::slotLogout()
+{
+    kapp->requestShutDown();
+}
+
+void KMenu::slotPopulateSessions()
+{
+    int p = 0;
+    DM dm;
+
+    sessionsMenu->clear();
+    if (kapp->authorize("start_new_session") && (p = dm.numReserve()) >= 0)
+    {
+        if (kapp->authorize("lock_screen"))
+	  sessionsMenu->insertItem(/*SmallIconSet("lockfork"),*/ i18n("Lock Current && Start New Session"), 100 );
+        sessionsMenu->insertItem(SmallIconSet("fork"), i18n("Start New Session"), 101 );
+        if (!p) {
+            sessionsMenu->setItemEnabled( 100, false );
+            sessionsMenu->setItemEnabled( 101, false );
+        }
+        sessionsMenu->insertSeparator();
+    }
+    SessList sess;
+    if (dm.localSessions( sess ))
+        for (SessList::ConstIterator it = sess.begin(); it != sess.end(); ++it) {
+            int id = sessionsMenu->insertItem( DM::sess2Str( *it ), (*it).vt );
+            if (!(*it).vt)
+                sessionsMenu->setItemEnabled( id, false );
+            if ((*it).self)
+                sessionsMenu->setItemChecked( id, true );
+        }
+}
+
+void KMenu::slotSessionActivated( int ent )
+{
+    if (ent == 100)
+        doNewSession( true );
+    else if (ent == 101)
+        doNewSession( false );
+    else if (!sessionsMenu->isItemChecked( ent ))
+        DM().lockSwitchVT( ent );
+}
+
+void KMenu::doNewSession( bool lock )
+{
+    int result = KMessageBox::warningContinueCancel(
+        kapp->desktop()->screen(kapp->desktop()->screenNumber(this)),
+        i18n("<p>You have chosen to open another desktop session.<br>"
+               "The current session will be hidden "
+               "and a new login screen will be displayed.<br>"
+               "An F-key is assigned to each session; "
+               "F%1 is usually assigned to the first session, "
+               "F%2 to the second session and so on. "
+               "You can switch between sessions by pressing "
+               "Ctrl, Alt and the appropriate F-key at the same time. "
+               "Additionally, the KDE Panel and Desktop menus have "
+               "actions for switching between sessions.</p>")
+                           .arg(7).arg(8),
+        i18n("Warning - New Session"),
+        KGuiItem(i18n("&Start New Session"), "fork"),
+        ":confirmNewSession",
+        KMessageBox::PlainCaption | KMessageBox::Notify);
+
+    if (result==KMessageBox::Cancel)
+        return;
+
+    if (lock)
+        slotLock();
+
+    DM().startReserve();
+}
+
+void KMenu::searchAccept()
+{
+    QString cmd = m_kcommand->currentText().stripWhiteSpace();
+
+    bool logout = (cmd == "logout");
+    bool lock = (cmd == "lock");
+
+    addToHistory();
+
+    if ( !logout && !lock )
+    {
+        // first try if we have any search action
+        if (m_searchResultsWidget->currentItem())
+            m_searchResultsWidget->slotItemClicked(m_searchResultsWidget->currentItem());
+        // otherwise, try to run it like minicli does
+        else if ( runCommand() )
+            return;
+    }
+
+    saveConfig();
+    hide();
+
+    if ( logout )
+    {
+        kapp->propagateSessionManager();
+        kapp->requestShutDown();
+    }
+    if ( lock )
+    {
+        QCString appname( "kdesktop" );
+        int kicker_screen_number = qt_xscreen();
+        if ( kicker_screen_number )
+            appname.sprintf("kdesktop-screen-%d", kicker_screen_number);
+        kapp->dcopClient()->send(appname, "KScreensaverIface", "lock()", "");
+    }
+}
+
+bool KMenu::runCommand()
+{
+kdDebug() << "runCommand() " << m_kcommand->lineEdit()->text() << endl;
+    // Ignore empty commands...
+    if ( m_kcommand->lineEdit()->text().isEmpty() )
+      return true;
+
+    accept();
+
+    if (input_timer->isActive ())
+        input_timer->stop ();
+
+    // Make sure we have an updated data
+    parseLine( true );
+
+    bool block = m_kcommand->signalsBlocked();
+    m_kcommand->blockSignals( true );
+    m_kcommand->clearEdit();
+    m_kcommand->setFocus();
+    m_kcommand->reset();
+    m_kcommand->blockSignals( block );
+
+
+    QString cmd;
+    KURL uri = m_filterData->uri();
+    if ( uri.isLocalFile() && !uri.hasRef() && uri.query().isEmpty() )
+      cmd = uri.path();
+    else
+      cmd = uri.url();
+
+    QString exec;
+
+    switch( m_filterData->uriType() )
+    {
+      case KURIFilterData::LOCAL_FILE:
+      case KURIFilterData::LOCAL_DIR:
+      case KURIFilterData::NET_PROTOCOL:
+      case KURIFilterData::HELP:
+      {
+        // No need for kfmclient, KRun does it all (David)
+        (void) new KRun( m_filterData->uri(), parentWidget());
+        return false;
+      }
+      case KURIFilterData::EXECUTABLE:
+      {
+        if( !m_filterData->hasArgsAndOptions() )
+        {
+          // Look for desktop file
+          KService::Ptr service = KService::serviceByDesktopName(cmd);
+          if (service && service->isValid() && service->type() == "Application")
+          {
+            notifyServiceStarted(service);
+            KRun::run(*service, KURL::List());
+            return false;
+          }
+        }
+      }
+      // fall-through to shell case
+      case KURIFilterData::SHELL:
+      {
+        if (kapp->authorize("shell_access"))
+        {
+          exec = cmd;
+
+          if( m_filterData->hasArgsAndOptions() )
+            cmd += m_filterData->argsAndOptions();
+
+          break;
+        }
+        else
+        {
+          KMessageBox::sorry( this, i18n("<center><b>%1</b></center>\n"
+                                    "You do not have permission to execute "
+                                    "this command.")
+                                    .arg( QStyleSheet::convertFromPlainText(cmd) ));
+          return true;
+        }
+      }
+      case KURIFilterData::UNKNOWN:
+      case KURIFilterData::ERROR:
+      default:
+      {
+        // Look for desktop file
+        KService::Ptr service = KService::serviceByDesktopName(cmd);
+        if (service && service->isValid() && service->type() == "Application")
+        {
+          notifyServiceStarted(service);
+          KRun::run(*service, KURL::List(), this);
+          return false;
+        }
+
+        service = KService::serviceByName(cmd);
+        if (service && service->isValid() && service->type() == "Application")
+        {
+          notifyServiceStarted(service);
+          KRun::run(*service, KURL::List(), this);
+          return false;
+      }
+
+        KMessageBox::sorry( this, i18n("<center><b>%1</b></center>\n"
+                                  "Could not run the specified command.")
+                                  .arg( QStyleSheet::convertFromPlainText(cmd) ));
+        return true;
+      }
+    }
+
+    if ( KRun::runCommand( cmd, exec, m_iconName ) )
+      return false;
+
+    KMessageBox::sorry( this, i18n("<center><b>%1</b></center>\n"
+                                "The specified command does not exist.").arg(cmd) );
+    return true; // Let the user try again...
+}
+
+void KMenu::show()
+{
+    m_isShowing = true;
+    emit aboutToShow();
+
+    initialize();
+
+    PanelPopupButton *kButton = MenuManager::the()->findKButtonFor( this );
+    if (kButton)
+    {
+        if (kButton->center().y()<QApplication::desktop()->height()/2)
+            setOrientation(TopDown);
+        else
+            setOrientation(BottomUp);
+    }
+
+    m_browserDirty=true;
+    m_recentDirty=true;
+
+    m_activeTab = m_btnFavorites;
+    paintTab( m_btnFavorites, true );
+    paintTab( m_btnRecently, false );
+    paintTab( m_browser, false );
+    paintTab( m_system, false );
+    paintTab( m_exit, false );
+    paintTab( m_expandSpace, false );
+    paintTab( m_searchFrame, false );
+
+    updateMedia();
+    m_mediaFreeTimer.start(10 * 1000); // refresh all 10s
+
+    slotFavoritesButton();
+    m_kcommand->clear();
+    current_query.clear();
+    m_kcommand->setFocus();
+
+    // we need to reenable it
+    m_toolTipsEnabled = QToolTip::isGloballyEnabled();
+    QToolTip::setGloballyEnabled(KickerSettings::showToolTips());
+
+    if ( KNewButton::self() )
+        KNewButton::self()->setActive( true );
+
+    KMenuBase::show();
+    m_isShowing = false;
+}
+
+void KMenu::setOrientation(MenuOrientation orientation)
+{
+    if (m_orientation==orientation)
+        return;
+
+    m_orientation=orientation;
+
+    m_resizeHandle->setCursor(m_orientation == BottomUp ? Qt::sizeBDiagCursor : Qt::sizeFDiagCursor);
+
+    QPixmap pix;
+    if ( m_orientation == BottomUp )
+        pix.load( locate("appdata", "pics/search-gradient.png" ) );
+    else
+        pix.load( locate("appdata", "pics/search-gradient-topdown.png" ) );
+
+    pix.convertFromImage( pix.convertToImage().scale(pix.width(), m_searchFrame->height()));
+    m_search->mainWidget()->setPaletteBackgroundPixmap( pix );
+    m_resizeHandle->setPaletteBackgroundPixmap( pix );
+
+    if ( m_orientation == BottomUp )
+    {
+        tab_bottom_left.load( locate("appdata", "pics/tab-bottom-left.png" ) );
+        tab_bottom_right.load( locate("appdata", "pics/tab-bottom-right.png" ) );
+        tab_center.load( locate("appdata", "pics/tab-center.png" ) );
+        tab_left_center.load( locate("appdata", "pics/tab-left_center.png" ) );
+        tab_right_center.load( locate("appdata", "pics/tab-right_center.png" ) );
+        tab_top_left.load( locate("appdata", "pics/tab-top-left.png" ) );
+        tab_top_right.load( locate("appdata", "pics/tab-top-right.png" ) );
+    }
+    else
+    {
+        tab_bottom_left.load( locate("appdata", "pics/tab-bottom-left-topdown.png" ) );
+        tab_bottom_right.load( locate("appdata", "pics/tab-bottom-right-topdown.png" ) );
+        tab_center.load( locate("appdata", "pics/tab-center-topdown.png" ) );
+        tab_left_center.load( locate("appdata", "pics/tab-left_center.png" ) );
+        tab_right_center.load( locate("appdata", "pics/tab-right_center.png" ) );
+        tab_top_left.load( locate("appdata", "pics/tab-top-left-topdown.png" ) );
+        tab_top_right.load( locate("appdata", "pics/tab-top-right-topdown.png" ) );
+    }
+
+    QPixmap respix = QPixmap( locate("data", "kicker/pics/resize_handle.png" ) );
+    if ( m_orientation == TopDown ) {
+      QWMatrix m;
+      m.rotate( 90.0 );
+      respix=respix.xForm(m);
+    }
+    m_resizeHandle->setPixmap(respix);
+
+    resizeEvent(new QResizeEvent(sizeHint(), sizeHint()));
+}
+
+void KMenu::showMenu()
+{
+    kdDebug() << "KMenu::showMenu()" << endl;
+    PanelPopupButton *kButton = MenuManager::the()->findKButtonFor(this);
+    if (kButton)
+    {
+	adjustSize();
+        kButton->showMenu();
+    }
+    else
+    {
+        show();
+    }
+    kdDebug() << "end KMenu::showMenu()" << endl;
+}
+
+void KMenu::hide()
+{
+    //kdDebug() << "KMenu::hide() from " << kdBacktrace() << endl;
+
+    // TODO: hide popups
+    emit aboutToHide();
+
+    if (m_popupMenu) {
+        m_popupMenu->deleteLater();
+        m_popupMenu=0;
+    }
+    m_mediaFreeTimer.stop();
+
+    m_isresizing = false;
+
+    if ( KNewButton::self() )
+        KNewButton::self()->setActive( false );
+
+    KickerSettings::setKMenuWidth(width());
+    KickerSettings::setKMenuHeight(height());
+    KickerSettings::writeConfig();
+
+    QToolTip::setGloballyEnabled(m_toolTipsEnabled);
+
+    // remove focus from lineedit again, otherwise it doesn't kill its timers
+    slotFavoritesButton();
+
+    QWidget::hide();
+}
+
+void KMenu::paintEvent(QPaintEvent * e)
+{
+    KMenuBase::paintEvent(e);
+
+    QPainter p(this);
+    p.setClipRegion(e->region());
+
+    const BackgroundMode bgmode = backgroundMode();
+    const QColorGroup::ColorRole crole = QPalette::backgroundRoleFromMode( bgmode );
+    p.setBrush( colorGroup().brush( crole ) );
+
+    p.drawRect( 0, 0, width(), height() );
+    int ypos = m_search->mainWidget()->geometry().bottom();
+
+    p.drawTiledPixmap( 0, ypos, main_border_lc.width(),
+                       m_stacker->geometry().bottom() - ypos + 1,
+                       main_border_lc );
+    p.drawTiledPixmap( width() - main_border_rc.width(), ypos, main_border_rc.width(),
+                       m_stacker->geometry().bottom() - ypos + 1,
+                       main_border_rc );
+
+    p.drawPixmap( 0, ypos, main_border_tl );
+    p.drawPixmap( width() - main_border_tr.width(), ypos, main_border_tr );
+    p.drawPixmap( 0, buttonBox->mainWidget()->y(), button_box_left );
+}
+
+
+void KMenu::configChanged()
+{
+    RecentlyLaunchedApps::the().m_bNeedToUpdate = false;
+    RecentlyLaunchedApps::the().configChanged();
+}
+
+// create and fill "recent" section at first
+void KMenu::createRecentMenuItems()
+{
+    RecentlyLaunchedApps::the().init();
+
+    if (!KickerSettings::numVisibleEntries())
+      KickerSettings::setNumVisibleEntries(5);
+
+    int nId = serviceMenuEndId() + 1;
+    m_recentlyView->insertSeparator( nId++, i18n( "Applications" ), -1 );
+
+    QStringList RecentApps;
+    RecentlyLaunchedApps::the().getRecentApps(RecentApps);
+
+    if (RecentApps.count() > 0)
+    {
+//        bool bSeparator = KickerSettings::showMenuTitles();
+        int nIndex = 0;
+
+        for (QValueList<QString>::ConstIterator it =
+             RecentApps.fromLast(); /*nop*/; --it)
+        {
+            KService::Ptr s = KService::serviceByDesktopPath(*it);
+            if (!s)
+            {
+                RecentlyLaunchedApps::the().removeItem(*it);
+            }
+            else
+                m_recentlyView->insertMenuItem(s, nIndex++);
+
+            if (it == RecentApps.begin())
+            {
+                break;
+            }
+        }
+
+    }
+
+    m_recentlyView->insertSeparator( nId++, i18n( "Documents" ), -1 );
+
+    QStringList fileList = KRecentDocument::recentDocuments();
+    kdDebug() << "createRecentMenuItems=" << fileList << endl;
+    for (QStringList::ConstIterator it = fileList.begin();
+         it != fileList.end();
+         ++it)
+        m_recentlyView->insertRecentlyItem(*it, nId++);
+
+}
+
+void KMenu::clearSubmenus()
+{
+    // we don't need to delete these on the way out since the libloader
+    // handles them for us
+    if (QApplication::closingDown())
+    {
+        return;
+    }
+
+    for (PopupMenuList::const_iterator it = dynamicSubMenus.constBegin();
+            it != dynamicSubMenus.constEnd();
+            ++it)
+    {
+        delete *it;
+    }
+    dynamicSubMenus.clear();
+
+#warning FIXME
+    //QFrame::clearSubmenus();
+}
+
+void KMenu::updateRecent()
+{
+    m_recentlyView->clear();
+
+    createRecentMenuItems();
+
+    m_recentDirty = false;
+}
+
+void KMenu::popup(const QPoint&, int)
+{
+   qDebug("KMenu::popup called!");
+}
+
+void KMenu::clearRecentAppsItems()
+{
+    RecentlyLaunchedApps::the().clearRecentApps();
+    RecentlyLaunchedApps::the().save();
+    RecentlyLaunchedApps::the().m_bNeedToUpdate = true;
+    updateRecent();
+}
+
+void KMenu::clearRecentDocsItems()
+{
+    KRecentDocument::clear();
+    updateRecent();
+}
+
+void KMenu::searchChanged(const QString & text)
+{
+  if (!text.isEmpty()) {
+    const QColor on = QColor( 244, 244, 244 );
+    const QColor off = QColor( 181, 181, 181 );
+    raiseStackWidget(m_searchWidget);
+  }
+
+  m_searchActions->clearSelection();
+  m_searchResultsWidget->clearSelection();
+
+  if (input_timer->isActive ())
+    input_timer->stop ();
+  input_timer->start (WAIT_BEFORE_QUERYING, TRUE);
+}
+
+bool KMenu::dontQueryNow (const QString& str)
+{
+    if (str.isEmpty ())
+        return true;
+    if (str == current_query.get())
+	return true;
+    int length = str.length ();
+    int last_whitespace = str.findRev (' ', -1);
+    if (last_whitespace == length-1)
+        return false; // if the user typed a space, search
+    if (last_whitespace >= length-2)
+        return true; // dont search if the user only typed one character
+    QChar lastchar = str[length-1];
+    if (lastchar == ":" || lastchar == "=")
+        return true;
+    return false;
+}
+
+void KMenu::createNewProgramList()
+{
+    m_seenProgramsChanged = false;
+    m_seenPrograms = KickerSettings::firstSeenApps();
+    m_newInstalledPrograms.clear();
+
+    m_currentDate = QDate::currentDate().toString(Qt::ISODate);
+
+    bool initialize = (m_seenPrograms.count() == 0);
+
+    createNewProgramList(QString::null);
+
+    if (initialize) {
+       for (QStringList::Iterator it = m_seenPrograms.begin(); it != m_seenPrograms.end(); ++it)
+           *(++it)="-";
+
+        m_newInstalledPrograms.clear();
+    }
+
+    if (m_seenProgramsChanged) {
+      KickerSettings::setFirstSeenApps(m_seenPrograms);
+      KickerSettings::writeConfig();
+    }
+}
+
+void KMenu::createNewProgramList(QString relPath)
+{
+    KServiceGroup::Ptr group = KServiceGroup::group(relPath);
+    if (!group || !group->isValid())
+      return;
+
+    KServiceGroup::List list = group->entries();
+    if (list.isEmpty())
+      return;
+
+    KServiceGroup::List::ConstIterator it = list.begin();
+    for(; it != list.end(); ++it) {
+	KSycocaEntry *e = *it;
+
+	if(e != 0) {
+		if(e->isType(KST_KServiceGroup)) {
+			KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+			if(!g->noDisplay())
+				createNewProgramList(g->relPath());
+		} else if(e->isType(KST_KService)) {
+			KService::Ptr s(static_cast<KService *>(e));
+			if(s->type() == "Application" && !s->noDisplay() ) {
+                            QString shortStorageId = s->storageId().replace(".desktop",QString::null);
+                            QStringList::Iterator it_find = m_seenPrograms.begin();
+                            QStringList::Iterator it_end = m_seenPrograms.end();
+ 			    bool found = false;
+			    for (; it_find != it_end; ++it_find) {
+				if (*(it_find)==shortStorageId) {
+				   found = true;
+				   break;
+                                }
+                                ++it_find;
+                            }
+                            if (!found) {
+                                m_seenProgramsChanged=true;
+                                m_seenPrograms+=shortStorageId;
+                                m_seenPrograms+=m_currentDate;
+                                if (m_newInstalledPrograms.find(s->storageId())==m_newInstalledPrograms.end())
+                                  m_newInstalledPrograms+=s->storageId();
+                            }
+                            else {
+                                ++it_find;
+                                if (*(it_find)!="-") {
+                                   QDate date = QDate::fromString(*(it_find),Qt::ISODate);
+                                   if (date.daysTo(QDate::currentDate())<3) {
+                                      if (m_newInstalledPrograms.find(s->storageId())==m_newInstalledPrograms.end())
+                                         m_newInstalledPrograms+=s->storageId();
+                                   }
+                                   else {
+                                      m_seenProgramsChanged=true;
+                                      (*it_find)="-";
+                                   }
+                                }
+                            }
+                        }
+		}
+	}
+    }
+}
+
+void KMenu::searchProgramList(QString relPath)
+{
+    KServiceGroup::Ptr group = KServiceGroup::group(relPath);
+    if (!group || !group->isValid())
+      return;
+
+    KServiceGroup::List list = group->entries();
+    if (list.isEmpty())
+      return;
+
+    KServiceGroup::List::ConstIterator it = list.begin();
+    for(; it != list.end(); ++it) {
+	KSycocaEntry *e = *it;
+
+	if(e != 0) {
+		if(e->isType(KST_KServiceGroup)) {
+			KServiceGroup::Ptr g(static_cast<KServiceGroup *>(e));
+			if(!g->noDisplay())
+				searchProgramList(g->relPath());
+		} else if(e->isType(KST_KService)) {
+			KService::Ptr s(static_cast<KService *>(e));
+			if(s->type() == "Application" && !s->noDisplay() && !checkUriInMenu(s->desktopEntryPath())) {
+				if (!current_query.matches(s->name()+' '+s->genericName()+' '+s->exec()+' '+
+				    s->keywords().join(",")+' '+s->comment()+' '+group->caption()+' '+
+				    s->categories().join(",")) || !anotherHitMenuItemAllowed(APPS))
+					continue;
+
+				QString input = current_query.get();
+				int score = 0;
+				if (s->exec()==input)
+					score = 100;
+				else if (s->exec().find(input)==0)
+					score = 50;
+				else if (s->exec().find(input)!=-1)
+					score = 10;
+				else if (s->name().lower()==input)
+					score = 100;
+				else if (s->name().lower().find(input)==0)
+					score = 50;
+				else if (s->name().lower().find(input)!=-1)
+					score = 10;
+
+				if (s->exec().find(' ')==-1)
+					score+=1;
+
+				if (s->substituteUid())
+					score-=1;
+
+				QString firstLine, secondLine;
+				if ((KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly) && !s->genericName().isEmpty()) {
+					firstLine = s->genericName();
+					secondLine = s->name();
+				}
+				else {
+					firstLine = s->name();;
+					secondLine = s->genericName();
+				}
+
+        			HitMenuItem *hit_item = new HitMenuItem (firstLine, secondLine,
+                                s->desktopEntryPath(), QString::null, 0, APPS, s->icon(), score);
+        			if (hit_item == NULL)
+					continue;
+
+				hit_item->service = s;
+        			insertSearchResult(hit_item);
+
+                                QString exe = s->exec();
+                                int pos = exe.find(' ');
+                                if (pos>0)
+                                  exe=exe.left(pos);
+				m_programsInMenu+=KGlobal::dirs()->findExe(exe);
+			}
+		}
+	}
+    }
+}
+
+void KMenu::searchBookmarks(KBookmarkGroup group)
+{
+	KBookmark bookmark = group.first();
+	while(!bookmark.isNull()) {
+		if (bookmark.isGroup()) {
+			searchBookmarks(bookmark.toGroup());
+		} else if (!bookmark.isSeparator() && !bookmark.isNull()) {
+				if (!current_query.matches(bookmark.fullText()+' '+bookmark.url().url()) || !anotherHitMenuItemAllowed(BOOKMARKS)) {
+                                        bookmark = group.next(bookmark);
+	    				continue;
+                                }
+
+        			HitMenuItem *hit_item = new HitMenuItem (bookmark.fullText(), bookmark.fullText(),
+                                bookmark.url(), QString::null, 0, BOOKMARKS, bookmark.icon());
+
+        			insertSearchResult(hit_item);
+		}
+		bookmark = group.next(bookmark);
+	}
+}
+
+void KMenu::initSearch()
+{
+    if (!m_addressBook)
+       m_addressBook = KABC::StdAddressBook::self( false );
+
+    if (!bookmarkManager)
+      bookmarkManager = KBookmarkManager::userBookmarksManager();
+
+    if (!m_search_plugin) {
+      m_search_plugin_interface = new QObject( this, "m_search_plugin_interface" );
+      new MyKickoffSearchInterface( this, m_search_plugin_interface, "kickoffsearch interface" );
+      KTrader::OfferList offers = KTrader::self()->query("KickoffSearch/Plugin");
+
+      KService::Ptr service = *offers.begin();
+      if (service) {
+        int errCode = 0;
+        m_search_plugin = KParts::ComponentFactory::createInstanceFromService<KickoffSearch::Plugin>
+            ( service, m_search_plugin_interface, 0, QStringList(), &errCode);
+      }
+    }
+}
+
+void KMenu::searchAddressbook()
+{
+    if (!m_addressBook)
+      m_addressBook = KABC::StdAddressBook::self( false );
+
+    KABC::AddressBook::ConstIterator it = m_addressBook->begin();
+    while (it!=m_addressBook->end()) {
+        if (!current_query.matches((*it).assembledName()+' '+(*it).fullEmail())) {
+            it++;
+            continue;
+        }
+
+        HitMenuItem *hit_item;
+        QString realName = (*it).realName();
+        if (realName.isEmpty())
+            realName=(*it).preferredEmail();
+
+        if (!(*it).preferredEmail().isEmpty()) {
+	    if (!anotherHitMenuItemAllowed(ACTIONS)) {
+               it++;
+               continue;
+            }
+
+            hit_item = new HitMenuItem (i18n("Send Email to %1").arg(realName), (*it).preferredEmail(),
+                                "mailto:"+(*it).preferredEmail(), QString::null, 0, ACTIONS, "mail_new");
+
+        			insertSearchResult(hit_item);
+        }
+
+	if (!anotherHitMenuItemAllowed(ACTIONS)) {
+               it++;
+               continue;
+        }
+
+        hit_item = new HitMenuItem (i18n("Open Addressbook at %1").arg(realName), (*it).preferredEmail(),
+                                "kaddressbook --uid "+(*it).uid(), QString::null, 0, ACTIONS, "kaddressbook");
+
+        			insertSearchResult(hit_item);
+
+       it++;
+    }
+}
+
+void KMenu::clearSearchResults(bool showHelp)
+{
+    m_searchResultsWidget->clear();
+    m_searchResultsWidget->setFocusPolicy(showHelp ? QWidget::NoFocus : QWidget::StrongFocus);
+    setTabOrder(m_kcommand, m_searchResultsWidget);
+
+    if (showHelp) {
+        QListViewItem* item;
+        item = new QListViewItem( m_searchResultsWidget, "   " + i18n("- Add ext:type to specify a file extension.") );
+        item->setSelectable(false);
+        item = new QListViewItem( m_searchResultsWidget, "   " + i18n("- When searching for a phrase, add quotes.") );
+        item->setSelectable(false);
+        item = new QListViewItem( m_searchResultsWidget, "   " + i18n("- To exclude search terms, use the minus symbol in front.") );
+        item->setSelectable(false);
+        item = new QListViewItem( m_searchResultsWidget, "   " + i18n("- To search for optional terms, use OR.") );
+        item->setSelectable(false);
+        item = new QListViewItem( m_searchResultsWidget, "   " + i18n("- You can use upper and lower case.") );
+        item->setSelectable(false);
+        item = new QListViewItem( m_searchResultsWidget, i18n("Search Quick Tips"));
+        item->setSelectable(false);
+    }
+
+    for (int i=0; i<num_categories; ++i) {
+	categorised_hit_total [i] = 0;
+	max_category_id [i] = base_category_id [i];
+    }
+}
+
+void KMenu::doQuery (bool return_pressed)
+{
+    QString query_str = m_kcommand->lineEdit()->text ().simplifyWhiteSpace ();
+    if (! return_pressed && dontQueryNow (query_str)) {
+        if (query_str.length()<3)
+            clearSearchResults();
+        else {
+            if (m_searchResultsWidget->firstChild() && m_searchResultsWidget->firstChild()->isSelectable()) {
+                m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild(),true);
+            }
+            else if (m_searchResultsWidget->childCount()>1) {
+                m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild()->itemBelow(),true);
+            }
+        }
+        return;
+    }
+    kdDebug() << "Querying for [" << query_str << "]" << endl;
+    current_query.set(query_str);
+
+    // reset search results
+    HitMenuItem *hit_item;
+    while ((hit_item = m_current_menu_items.take ()) != NULL) {
+        //kndDebug () << " (" << hit_item->id << "," << hit_item->category << ")" << endl;
+        delete hit_item;
+    }
+
+    clearSearchResults(false);
+    m_searchPixmap->setMovie(QMovie(locate( "appdata", "pics/search-running.mng" )));
+
+    resetOverflowCategory();
+
+    initCategoryTitlesUpdate();
+
+    // calculate ?
+    QString cmd = query_str.stripWhiteSpace();
+    if (!cmd.isEmpty() && (cmd[0].isNumber() || (cmd[0] == '(')) &&
+            (QRegExp("[a-zA-Z\\]\\[]").search(cmd) == -1))
+    {
+        QString result = calculate(cmd);
+        if (!result.isEmpty())
+        {
+            categorised_hit_total[ACTIONS] ++;
+            HitMenuItem *hit_item = new HitMenuItem (i18n("%1 = %2").arg(query_str, result), QString::null,
+                    "kcalc", QString::null, (++max_category_id [ACTIONS]), ACTIONS, "kcalc");
+            int index = getHitMenuItemPosition (hit_item);
+            m_searchResultsWidget->insertItem(iconForHitMenuItem(hit_item), hit_item->display_name,
+                    hit_item->display_info, KGlobal::dirs()->findExe("kcalc"), max_category_id [ACTIONS], index);
+        }
+    }
+
+    // detect email address
+    if (emailRegExp.exactMatch(query_str)) {
+      categorised_hit_total[ACTIONS] ++;
+      HitMenuItem *hit_item = new HitMenuItem (i18n("Send Email to %1").arg(query_str), QString::null,
+                                "mailto:"+query_str, QString::null, (++max_category_id [ACTIONS]), ACTIONS, "mail_new");
+      int index = getHitMenuItemPosition (hit_item);
+      m_searchResultsWidget->insertItem(iconForHitMenuItem(hit_item), hit_item->display_name, hit_item->display_info, "mailto:"+query_str, max_category_id [ACTIONS], index);
+    }
+
+    // quick own application search
+    m_programsInMenu.clear();
+    searchProgramList(QString::null);
+
+    KURIFilterData filterData;
+    filterData.setData(query_str);
+    filterData.setCheckForExecutables(true);
+
+    if (KURIFilter::self()->filterURI(filterData)) {
+
+        QString description;
+        QString exe;
+
+        switch (filterData.uriType()) {
+        case KURIFilterData::LOCAL_FILE:
+            description = i18n("Open Local File: %1").arg(filterData.uri().url());
+            break;
+        case KURIFilterData::LOCAL_DIR:
+            description = i18n("Open Local Dir: %1").arg(filterData.uri().url());
+            break;
+        case KURIFilterData::NET_PROTOCOL:
+            description = i18n("Open Remote Location: %1").arg(filterData.uri().url());
+            break;
+        case KURIFilterData::SHELL:
+        case KURIFilterData::EXECUTABLE:
+                exe = KGlobal::dirs()->findExe(filterData.uri().url());
+
+            if (m_programsInMenu.find(exe)!=m_programsInMenu.end())
+                exe = QString::null;
+            else {
+                description = i18n("Run '%1'").arg(exe);
+            }
+        default:
+            break;
+        }
+
+        if (!description.isEmpty()) {
+            categorised_hit_total[ACTIONS] ++;
+            HitMenuItem *hit_item = new HitMenuItem (description, QString::null,
+                    exe.isEmpty() ? filterData.uri() : exe, QString::null,
+                    (++max_category_id [ACTIONS]), ACTIONS, exe.isEmpty() ? "fileopen": "run");
+            int index = getHitMenuItemPosition (hit_item);
+            m_searchResultsWidget->insertItem(iconForHitMenuItem(hit_item), hit_item->display_name,
+                    hit_item->display_info,
+                    exe.isEmpty() ? filterData.uri().url() : exe, max_category_id [ACTIONS], index);
+        }
+    }
+
+    // search Konqueror bookmarks;
+    if (!bookmarkManager)
+      bookmarkManager = KBookmarkManager::userBookmarksManager();
+
+    if (query_str.length()>=3)
+      searchBookmarks(bookmarkManager->root());
+
+    // search KDE addressbook
+    if (query_str.length()>=3)
+      searchAddressbook();
+
+    updateCategoryTitles();
+
+    if (m_searchResultsWidget->childCount()>1)
+      m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild()->itemBelow(),true);
+    m_searchActions->clearSelection();
+
+    if (!m_search_plugin)
+      initSearch();
+
+    // start search plugin only with at least 3 characters
+    if (query_str.length()<3 || !m_search_plugin || (m_search_plugin && !m_search_plugin->daemonRunning()) ) {
+      m_searchPixmap->setPixmap( BarIcon( "find", 32 ) );
+      fillOverflowCategory();
+      if (query_str.length()>2 && m_current_menu_items.isEmpty())
+	  reportError (i18n("No matches found"));
+      return;
+    }
+
+    if (m_search_plugin) {
+      m_search_plugin->query(current_query.get(), KickerSettings::DescriptionAndName || KickerSettings::menuEntryFormat() == KickerSettings::DescriptionOnly);
+    }
+}
+
+bool KMenu::anotherHitMenuItemAllowed(int cat, bool count)
+{
+	// update number of hits in this category
+        if (count)
+	    categorised_hit_total [cat] ++;
+
+	// if number of hits in this category is more than allowed, dont process this
+	if (max_category_id [cat] - base_category_id [cat] < max_items(cat))
+            return true;
+
+        if (m_overflowCategoryState==None || (m_overflowCategoryState==Filling && m_overflowCategory==cat &&
+            max_category_id [cat] + m_overflowList.count() - base_category_id [cat] < max_items(cat) * 2.0))
+            return true;
+
+        return false;
+}
+
+void KMenu::addHitMenuItem(HitMenuItem* item)
+{
+        if (checkUriInMenu(item->uri.path()))
+            return;
+
+	// if number of hits in this category is more than allowed, dont process this
+	if (!anotherHitMenuItemAllowed(item->category, false))
+	    return;
+
+        insertSearchResult(item);
+}
+
+void KMenu::insertSearchResult(HitMenuItem* item)
+{
+        if (m_overflowCategoryState==None) {
+            m_overflowCategoryState = Filling;
+            m_overflowCategory = item->category;
+        }
+        else if (m_overflowCategoryState==Filling && m_overflowCategory!=item->category)
+            m_overflowCategoryState = NotNeeded;
+
+        if (max_category_id [item->category] - base_category_id [item->category] < max_items(item->category)) {
+	    max_category_id [item->category]++;
+            item->id=max_category_id [item->category];
+
+            int index = getHitMenuItemPosition (item);
+
+            kdDebug () << "Adding " << item->uri
+    		    << "(" << item->mimetype << ") with id="
+    		    << max_category_id [item->category] << " at " << index << endl;
+
+            KMenuItem *hit_item = m_searchResultsWidget->insertItem(iconForHitMenuItem(item), item->display_name, item->display_info, item->uri.url(), max_category_id [item->category], index);
+            hit_item->setService(item->service);
+
+            kdDebug () << "Done inserting ... " << endl;
+        }
+        else if (m_overflowCategoryState==Filling && m_overflowCategory==item->category &&
+            max_category_id [item->category] - base_category_id [item->category] < max_items(item->category) * 2)
+               m_overflowList.append(item);
+}
+
+void KMenu::searchOver()
+{
+    m_searchPixmap->setPixmap( BarIcon( "find", 32 ) );
+    fillOverflowCategory();
+    if (m_current_menu_items.isEmpty()) {
+        kdDebug() << "No matches found" << endl;
+	reportError (i18n("No matches found"));
+    }
+    if (!m_searchResultsWidget->selectedItem() && !m_searchActions->selectedItem() && m_searchResultsWidget->childCount()>1) {
+            m_searchResultsWidget->setSelected(m_searchResultsWidget->firstChild()->itemBelow(),true);
+        }
+}
+
+void KMenu::initCategoryTitlesUpdate()
+{
+    // Need to know if each category was updated with hits or had the first hit
+    // That way we know if we need to changetitle or inserttitle
+    already_added = new bool [num_categories];
+    for (int i=0; i<num_categories; ++i)
+	already_added [i] = (max_category_id [i] != base_category_id [i]);
+}
+
+void KMenu::updateCategoryTitles()
+{
+    // update category title
+    for (int i=0; i<num_categories; ++i) {
+	if (i == OTHER)
+	    continue;
+	// nothing is in this category
+	if (max_category_id [i] == base_category_id [i])
+	    continue;
+
+        KMenuItemSeparator *sep = 0;
+
+	// if nothing was in this category before but now there is
+	if (! already_added [i]) {
+	    // insert a new title for this category
+	    int index = getHitMenuItemPosition (new HitMenuItem (
+						    base_category_id[i],
+						    i));
+            QString title = QString ("%1").arg (i18n(categories [i].utf8()));
+            sep = m_searchResultsWidget->insertSeparator(base_category_id [i], title, index);
+	    kdDebug () << "Inserting heading with id=" << base_category_id[i] << " for " << categories[i] << " at " << index << endl;
+	} else {
+	    // something was already displayed in this category
+	    // update the title to reflect the total
+            sep = dynamic_cast<KMenuItemSeparator*>( m_searchResultsWidget->findItem(base_category_id [i]) );
+            if ( !sep )
+                continue;
+            kdDebug () << "Changing heading of id=" << base_category_id[i] << " for " << categories[i] << endl;
+	}
+
+        int max = max_items(i);
+        if (m_overflowCategoryState == Filling && m_overflowCategory == i)
+            max *= 2;
+
+        if ( categorised_hit_total [i] > max ) {
+            if (m_kerryInstalled)
+                sep->setLink( i18n( "top %1 of %2" ).arg( max ).arg( categorised_hit_total [i] ), QString( "kerry:/%1" ).arg( i ) );
+            else
+                sep->setText( 0, i18n( "%1 (top %2 of %3)" ).arg( i18n(categories [i].utf8()) ).arg( max ).arg( categorised_hit_total [i] ) );
+        }
+        else {
+            sep->setLink( QString::null );
+        }
+    }
+    delete[] already_added;
+    already_added = 0;
+}
+
+QString KMenu::iconForHitMenuItem(HitMenuItem *hit_item)
+{
+    // get the icon
+    if (!hit_item->icon.isEmpty())
+        return hit_item->icon;
+
+    if (hit_item->category == WEBHIST) {
+        QString favicon = KMimeType::favIconForURL (hit_item->uri);
+        if (! favicon.isEmpty ())
+	    return favicon;
+    }
+
+    if (mimetype_iconstore.contains (hit_item->mimetype))
+        return (mimetype_iconstore [hit_item->mimetype]);
+    else {
+        KMimeType::Ptr mimetype_ptr = KMimeType::mimeType (hit_item->mimetype);
+        QString mimetype_icon = mimetype_ptr->icon(QString::null, FALSE);
+        mimetype_iconstore [hit_item->mimetype] = mimetype_icon;
+        return mimetype_icon;
+    }
+    return QString::null;
+}
+
+void KMenu::slotStartService(KService::Ptr ptr)
+{
+    accept();
+
+    addToHistory();
+    KApplication::startServiceByDesktopPath(ptr->desktopEntryPath(),
+                                            QStringList(), 0, 0, 0, "", true);
+    updateRecentlyUsedApps(ptr);
+}
+
+
+void KMenu::slotStartURL(const QString& u)
+{
+    if ( u == "kicker:/goup/" ) {
+        // only m_exitView is connected to this slot, not m_browserView
+        slotGoExitMainMenu();
+        return;
+    }
+
+    if ( u == "kicker:/restart/" || u=="kicker:/switchuser/") {
+        slotGoExitSubMenu(u);
+        return;
+    }
+
+    accept();
+
+    if ( u == "kicker:/lock" ) {
+        slotLock();
+    }
+    else if ( u == "kicker:/logout" ) {
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 0 << -1 << "";
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+    }
+    else if ( u == "kicker:/shutdown" ) {
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 2 << -1 << "";
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+    }
+    else if ( u == "kicker:/restart" ) {
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 1 << -1 << QString::null;
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+    }
+    else if ( u == "kicker:/suspend_disk" ) {
+        slotSuspend( 1 );
+    }
+    else if ( u == "kicker:/suspend_ram" ) {
+        slotSuspend( 2 );
+    }
+    else if ( u == "kicker:/standby" ) {
+        slotSuspend( 3 );
+    }
+    else if ( u == "kicker:/savesession" ) {
+        QByteArray data;
+        kapp->dcopClient()->send( "ksmserver", "default",
+                "saveCurrentSession()", data );
+    }
+    else if ( u == "kicker:/switchuser" ) {
+        DM().startReserve();
+    }
+    else if ( u == "kicker:/switchuserafterlock" ) {
+        slotLock();
+        DM().startReserve();
+    }
+    else if ( u.startsWith("kicker:/switchuser_") )
+        DM().lockSwitchVT( u.mid(19).toInt() );
+    else if ( u.startsWith("kicker:/restart_") ) {
+        QStringList rebootOptions;
+        int def, cur;
+        DM().bootOptions( rebootOptions, def, cur );
+
+        QByteArray params;
+        QDataStream stream(params, IO_WriteOnly);
+        stream << 1 << -1 << rebootOptions[u.mid(16).toInt()];
+
+        kapp->dcopClient()->send("ksmserver", "default", "logoutTimed(int,int,QString)", params);
+    }
+#warning restart entry not supported
+#if 0
+    else if ( u == "kicker:/restart_windows" ) {
+        if (KMessageBox::Continue==KMessageBox::warningContinueCancel(this, i18n("Do you really want to reset the computer and boot Microsoft Windows"), i18n("Start Windows Confirmation"), KGuiItem(i18n("Start Windows"),"reload")))
+            KMessageBox::error( this, QString( "kicker:/restart_windows is not yet implemented " ) );
+    }
+#endif
+    else if ( u.startsWith("kerry:/"))
+    {
+       QByteArray data;
+       QDataStream arg(data, IO_WriteOnly);
+       arg << m_kcommand->currentText() << kerry_categories[u.mid(7).toInt()];
+       if (ensureServiceRunning("kerry"))
+           kapp->dcopClient()->send("kerry","search","search(QString,QString)", data);
+    }
+    else {
+        addToHistory();
+        if (u.startsWith("kaddressbook --uid")) {
+            KProcess *proc = new KProcess;
+            *proc << "kaddressbook" << "--uid" << u.mid(19);
+            proc->start();
+            accept();
+            return;
+        } else if (u.startsWith("note:/")) {
+            KProcess *proc = new KProcess;
+            *proc << "tomboy";
+            *proc << "--open-note" << u;
+            if (!proc->start())
+               KMessageBox::error(0,i18n("Could not start Tomboy."));
+            return;
+        }
+        else if (u.startsWith("knotes:/") ) {
+            if (ensureServiceRunning("knotes")) {
+                QByteArray data;
+                QDataStream arg(data, IO_WriteOnly);
+                arg << u.mid(9,22);
+
+                kapp->dcopClient()->send("knotes","KNotesIface","showNote(QString)", data);
+            }
+            return;
+        }
+
+        kapp->propagateSessionManager();
+        (void) new KRun( u, parentWidget());
+    }
+}
+
+void KMenu::slotContextMenuRequested( QListViewItem * item, const QPoint & pos, int /*col*/ )
+{
+    const QObject* source = sender();
+
+    if (!item)
+        return;
+
+    KMenuItem* kitem = dynamic_cast<KMenuItem*>(item);
+    if (!kitem)
+        return;
+
+    KFileItemList _items;
+    _items.setAutoDelete(true);
+
+    if (dynamic_cast<KMenuItemSeparator*>(item))
+        return;
+
+    m_popupService = kitem->service();
+    m_popupPath.menuPath = kitem->menuPath();
+    if (!m_popupService) {
+        m_popupPath.title = kitem->title();
+        m_popupPath.description = kitem->description();
+        m_popupPath.path = kitem->path();
+        m_popupPath.icon = kitem->icon();
+
+        if (m_popupPath.path.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+               KDesktopFile df(m_popupPath.path,true);
+               m_popupPath.path=df.readURL();
+        }
+    }
+
+    m_popupMenu = new KPopupMenu(this);
+    connect(m_popupMenu, SIGNAL(activated(int)), SLOT(slotContextMenu(int)));
+    bool hasEntries = false;
+
+    m_popupMenu->insertTitle(SmallIcon(kitem->icon()),kitem->title());
+
+     if (source==m_favoriteView)
+     {
+         hasEntries = true;
+         m_popupMenu->insertItem(SmallIconSet("remove"),
+             i18n("Remove From Favorites"), RemoveFromFavorites);
+     }
+     else if (!kitem->hasChildren() && !m_popupPath.path.startsWith("system:/"))
+     {
+         hasEntries = true;
+         int num = m_popupMenu->insertItem(SmallIconSet("bookmark_add"),
+             i18n("Add to Favorites"), AddToFavorites);
+
+         QStringList favs = KickerSettings::favorites();
+         if (m_popupService && favs.find(m_popupService->storageId())!=favs.end())
+            m_popupMenu->setItemEnabled(num, false);
+         else {
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it)
+            {
+                if ((*it)[0]=='/')
+                {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==m_popupPath.path)
+                        break;
+                }
+            }
+            if (it!=favs.end())
+                m_popupMenu->setItemEnabled(num, false);
+         }
+     }
+
+     if (source!=m_exitView) {
+        if (m_popupService || (!m_popupPath.path.startsWith("kicker:/") && !m_popupPath.path.startsWith("system:/") && !m_popupPath.path.startsWith("kaddressbook --uid"))) {
+            if (hasEntries)
+                m_popupMenu->insertSeparator();
+
+            if (kapp->authorize("editable_desktop_icons") )
+            {
+                hasEntries = true;
+                if (m_popupPath.menuPath.endsWith("/"))
+                  m_popupMenu->insertItem(SmallIconSet("desktop"),
+                    i18n("Add Menu to Desktop"), AddMenuToDesktop);
+                else
+                  m_popupMenu->insertItem(SmallIconSet("desktop"),
+                      i18n("Add Item to Desktop"), AddItemToDesktop);
+            }
+            if (kapp->authorizeKAction("kicker_rmb") && !Kicker::the()->isImmutable())
+            {
+                hasEntries = true;
+                if (m_popupPath.menuPath.endsWith("/"))
+                   m_popupMenu->insertItem(SmallIconSet("kicker"),
+                      i18n("Add Menu to Main Panel"), AddMenuToPanel);
+                else
+                   m_popupMenu->insertItem(SmallIconSet("kicker"),
+                      i18n("Add Item to Main Panel"), AddItemToPanel);
+            }
+            if (kapp->authorizeKAction("menuedit") && !kitem->menuPath().isEmpty())
+            {
+                hasEntries = true;
+                if (kitem->menuPath().endsWith("/"))
+                  m_popupMenu->insertItem(SmallIconSet("kmenuedit"), i18n("Edit Menu"), EditMenu);
+                else
+                  m_popupMenu->insertItem(SmallIconSet("kmenuedit"), i18n("Edit Item"), EditItem);
+            }
+            if (kapp->authorize("run_command") && (m_popupService || (!m_popupPath.menuPath.isEmpty() && !m_popupPath.menuPath.endsWith("/"))))
+            {
+               hasEntries = true;
+               m_popupMenu->insertItem(SmallIconSet("run"),
+               i18n("Put Into Run Dialog"), PutIntoRunDialog);
+            }
+        }
+        if (source==m_searchResultsWidget || ((source==m_favoriteView || source==m_recentlyView || source == m_systemView) && !m_popupService && !m_popupPath.path.startsWith("kicker:/")) ) {
+            QString uri;
+            if (m_popupService)
+                uri = locate("apps", m_popupService->desktopEntryPath());
+            else
+                uri = m_popupPath.path;
+
+            QString mimetype = QString::null;
+            if ( m_popupPath.path.startsWith( "system:/media/" ) )
+                mimetype = media_mimetypes[m_popupPath.path];
+
+            KFileItem* item = new KFileItem(uri, mimetype, KFileItem::Unknown);
+            _items.append( item );
+
+            const KURL kurl(uri);
+            KActionCollection act(this);
+
+            KonqPopupMenu * konqPopupMenu = new KonqPopupMenu( KonqBookmarkManager::self(), _items,
+                                                   kurl, act, (KNewMenu*)NULL, this,
+                                                   item->isLocalFile() ? KonqPopupMenu::ShowProperties : KonqPopupMenu::NoFlags,
+                                                   KParts::BrowserExtension::DefaultPopupItems );
+
+            if (konqPopupMenu->count()) {
+                if (hasEntries) {
+                    m_popupMenu->insertSeparator();
+                    m_popupMenu->insertItem(SmallIconSet("add"),i18n("Advanced"), konqPopupMenu);
+                }
+                else {
+                    delete m_popupMenu;
+                    m_popupMenu = (KPopupMenu*)konqPopupMenu;
+                    m_popupMenu->insertTitle(SmallIcon(kitem->icon()),kitem->title(),-1,0);
+                }
+                hasEntries = true;
+            }
+        }
+    }
+
+    if (source==m_recentlyView) {
+       m_popupMenu->insertSeparator();
+       if (m_popupService)
+         m_popupMenu->insertItem(SmallIconSet("history_clear"),
+                 i18n("Clear Recently Used Applications"), ClearRecentlyUsedApps);
+       else
+         m_popupMenu->insertItem(SmallIconSet("history_clear"),
+                 i18n("Clear Recently Used Documents"), ClearRecentlyUsedDocs);
+    }
+
+    if (hasEntries) {
+       m_isShowing = true;
+       m_popupMenu->exec(pos);
+       m_isShowing = false;
+    }
+
+    delete m_popupMenu;
+    m_popupMenu = 0;
+}
+
+void KMenu::slotContextMenu(int selected)
+{
+    KServiceGroup::Ptr g;
+    QByteArray ba;
+    QDataStream ds(ba, IO_WriteOnly);
+
+    KURL src,dest;
+    KIO::CopyJob *job;
+
+    KProcess *proc;
+
+    QStringList favs = KickerSettings::favorites();
+
+    switch (selected) {
+        case AddItemToDesktop:
+            accept();
+	    if (m_popupService) {
+	        src.setPath( KGlobal::dirs()->findResource( "apps", m_popupService->desktopEntryPath() ) );
+	        dest.setPath( KGlobalSettings::desktopPath() );
+	        dest.setFileName( src.fileName() );
+
+                job = KIO::copyAs( src, dest );
+                job->setDefaultPermissions( true );
+ 	    }
+            else {
+		KDesktopFile* df = new KDesktopFile( newDesktopFile(KURL(m_popupPath.path), KGlobalSettings::desktopPath() ) );
+		df->writeEntry("GenericName", m_popupPath.description);
+		df->writeEntry( "Icon", m_popupPath.icon );
+		df->writePathEntry( "URL", m_popupPath.path );
+		df->writeEntry( "Name", m_popupPath.title );
+		df->writeEntry( "Type", "Link" );
+		df->sync();
+		delete df;
+            }
+            accept();
+	    break;
+
+	case AddItemToPanel:
+            accept();
+	    if (m_popupService)
+	    	kapp->dcopClient()->send("kicker", "Panel", "addServiceButton(QString)", m_popupService->desktopEntryPath());
+            else
+#warning FIXME special RecentDocuments/foo.desktop handling
+	    	kapp->dcopClient()->send("kicker", "Panel", "addURLButton(QString)", m_popupPath.path);
+	    accept();
+	    break;
+
+	case EditItem:
+        case EditMenu:
+	    accept();
+            proc = new KProcess(this);
+            *proc << KStandardDirs::findExe(QString::fromLatin1("kmenuedit"));
+            *proc << "/"+m_popupPath.menuPath.section('/',-200,-2) << m_popupPath.menuPath.section('/', -1);
+            proc->start();
+	    break;
+
+	case PutIntoRunDialog:
+	    accept();
+	    if (m_popupService)
+	      kapp->dcopClient()->send("kdesktop", "default", "popupExecuteCommand(QString)", m_popupService->exec());
+	    else
+#warning FIXME special RecentDocuments/foo.desktop handling
+              kapp->dcopClient()->send("kdesktop", "default", "popupExecuteCommand(QString)", m_popupPath.path);
+            accept();
+	    break;
+
+	case AddMenuToDesktop: {
+	    accept();
+	    KDesktopFile *df = new KDesktopFile( newDesktopFile(KURL("programs:/"+m_popupPath.menuPath),KGlobalSettings::desktopPath()));
+            df->writeEntry( "Icon", m_popupPath.icon );
+            df->writePathEntry( "URL", "programs:/"+m_popupPath.menuPath );
+	    df->writeEntry( "Name", m_popupPath.title );
+	    df->writeEntry( "Type", "Link" );
+            df->sync();
+	    delete df;
+
+	    break;
+            }
+	case AddMenuToPanel:
+	    accept();
+            ds << "foo" << m_popupPath.menuPath;
+	    kapp->dcopClient()->send("kicker", "Panel", "addServiceMenuButton(QString,QString)", ba);
+	    break;
+
+        case AddToFavorites:
+	    if (m_popupService) {
+              if (favs.find(m_popupService->storageId())==favs.end()) {
+                KService::Ptr p = KService::serviceByStorageId(m_popupService->storageId());
+                m_favoriteView->insertMenuItem(p, serviceMenuEndId()+favs.count()+1);
+                favs+=m_popupService->storageId();
+              }
+            }
+            else {
+               QStringList::Iterator it;
+               for (it = favs.begin(); it != favs.end(); ++it) {
+                  if ((*it)[0]=='/') {
+                     KDesktopFile df((*it),true);
+                     if (df.readURL().replace("file://",QString::null)==m_popupPath.path)
+                        break;
+                  }
+               }
+               if (it==favs.end()) {
+                 QString file = KickerLib::newDesktopFile(m_popupPath.path);
+                 KDesktopFile df(file);
+                 df.writeEntry("Encoding", "UTF-8");
+                 df.writeEntry("Type","Link");
+                 df.writeEntry("Name", m_popupPath.title);
+                 df.writeEntry("GenericName", m_popupPath.description);
+                 df.writeEntry("Icon", m_popupPath.icon);
+                 df.writeEntry("URL", m_popupPath.path);
+
+                 m_favoriteView->insertItem(m_popupPath.icon, m_popupPath.title, m_popupPath.description,
+                    m_popupPath.path, serviceMenuEndId()+favs.count()+1, -1);
+
+                 favs+=file;
+               }
+            }
+            KickerSettings::setFavorites(favs);
+            KickerSettings::writeConfig();
+            m_browserDirty=true;
+            slotFavoritesButton();
+	    break;
+
+        case RemoveFromFavorites:
+	    if (m_popupService) {
+              favs.erase(favs.find(m_popupService->storageId()));
+
+              for (QListViewItemIterator it(m_favoriteView); it.current(); ++it) {
+                 KMenuItem* kitem = static_cast<KMenuItem*>(it.current());
+	         if (kitem->service() && kitem->service()->storageId() == m_popupService->storageId()) {
+                   delete it.current();
+                   break;
+                 }
+              }
+            }
+            else {
+               for (QStringList::Iterator it = favs.begin(); it != favs.end(); ++it) {
+                  if ((*it)[0]=='/') {
+                     KDesktopFile df((*it),true);
+                     if (df.readURL().replace("file://",QString::null)==m_popupPath.path) {
+			QFile::remove((*it));
+                        favs.erase(it);
+                        break;
+                     }
+                  }
+               }
+               for (QListViewItemIterator it(m_favoriteView); it.current(); ++it) {
+                  KMenuItem* kitem = static_cast<KMenuItem*>(it.current());
+	          if (!kitem->service() && kitem->path() == m_popupPath.path) {
+                     delete it.current();
+                     break;
+                  }
+               }
+            }
+	    m_favoriteView->slotMoveContent();
+            KickerSettings::setFavorites(favs);
+            KickerSettings::writeConfig();
+            m_browserDirty=true;
+            slotFavoritesButton();
+	    break;
+
+        case ClearRecentlyUsedApps:
+            clearRecentAppsItems();
+	    break;
+
+        case ClearRecentlyUsedDocs:
+            clearRecentDocsItems();
+	    break;
+
+	default:
+	    break;
+	}
+}
+
+void KMenu::resizeEvent ( QResizeEvent * e )
+{
+    //kdDebug() << "resizeEvent " << size() << endl;
+    KMenuBase::resizeEvent(e);
+    int ypos = 0;
+    // this is the height remaining to fill
+    int left_height = height();
+
+    if ( m_orientation == BottomUp )
+    {
+        m_resizeHandle->move( e->size().width() - 19, 3);
+
+        // put the search widget at the top of the menu and give it its desired
+        // height
+        m_search->mainWidget()->setGeometry( 0, ypos, width(),
+                m_search->minimumSize().height() );
+        left_height -= m_search->minimumSize().height();
+        ypos += m_search->minimumSize().height();
+
+        // place the footer widget at the bottom of the menu and give it its desired
+        // height
+        m_footer->mainWidget()->setGeometry( 0, height() - m_footer->minimumSize().height(),
+                width(), m_footer->minimumSize().height() );
+        left_height -= m_footer->minimumSize().height();
+
+        // place the button box above the footer widget, horizontal placement
+        // has the width of the edge graphics subtracted
+        buttonBox->mainWidget()->setGeometry( button_box_left.width(),
+                height() - m_footer->minimumSize().height() -
+                buttonBox->minimumSize().height(),
+                width() - button_box_left.width(),
+                buttonBox->minimumSize().height() );
+        left_height -= buttonBox->minimumSize().height();
+
+        // place the main (stacker) widget below the search widget,
+        // in the remaining vertical space
+        m_stacker->setGeometry(main_border_lc.width(), ypos,
+                width() - main_border_lc.width() - main_border_rc.width(),
+                left_height );
+
+        button_box_left.load( locate( "appdata", "pics/button-box-left.png" ) );
+        button_box_left.convertFromImage( button_box_left.convertToImage().
+                scale(button_box_left.width(),
+                    buttonBox->mainWidget()->height() ) );
+    }
+    else // TopDown orientation
+    {
+        // place the 'footer' widget at the top of the menu and give it
+        // its desired height
+        m_footer->mainWidget()->setGeometry( 0,
+                ypos /*height() - m_footer->minimumSize().height()*/,
+                width(),
+                m_footer->minimumSize().height() );
+        ypos += m_footer->minimumSize().height();
+        left_height -= m_footer->minimumSize().height();
+
+        // place the button box next at the top of the menu.
+        // has the width of the edge graphics subtracted
+        buttonBox->mainWidget()->setGeometry( button_box_left.width(),
+                ypos,
+                width() - button_box_left.width(),
+                buttonBox->minimumSize().height() );
+        ypos += buttonBox->minimumSize().height();
+        left_height -= buttonBox->minimumSize().height();
+
+        // put the search widget above the footer widget
+        // height
+        m_search->mainWidget()->setGeometry( 0,
+                height() - m_search->minimumSize().height(),
+                width(),
+                m_search->minimumSize().height()
+                );
+        left_height -= m_search->minimumSize().height();
+
+        // place the main (stacker) widget below the button box,
+        // in the remaining vertical space
+        m_stacker->setGeometry(main_border_lc.width(), ypos,
+                width() - main_border_lc.width() - main_border_rc.width(),
+                left_height );
+        m_resizeHandle->move( e->size().width() - 19, e->size().height() - 19);
+    }
+    paintTab( m_btnRecently, false );
+    paintTab( m_btnFavorites, false );
+    paintTab( m_browser, false );
+    paintTab( m_system, false );
+    paintTab( m_exit, false );
+    paintTab( m_expandSpace, false );
+    paintTab( m_searchFrame, false );
+    paintTab( m_activeTab, true );
+}
+
+void KMenu::mousePressEvent ( QMouseEvent * e )
+{
+    kdDebug() << "KMenu::mousePressEvent " << e->pos() << " " << m_resizeHandle->pos() << endl;
+    if ( m_orientation == BottomUp ) {
+       if (e->x() > width() - m_resizeHandle->width() &&
+          e->y() < m_resizeHandle->height() )
+       {
+           kdDebug() << "hit!" << endl; // TODO: it's triangle
+            m_isresizing = true;
+       }
+    }
+    else {
+       if (e->x() > width() - m_resizeHandle->width() &&
+          e->y() > height() - m_resizeHandle->height() )
+       {
+           kdDebug() << "hit!" << endl; // TODO: it's triangle
+            m_isresizing = true;
+       }
+    }
+
+    QPoint pos = buttonBox->mainWidget()->mapFromGlobal(e->globalPos());
+    if ( m_exit->geometry().contains( pos ) )
+        emit clickedExitButton();
+    else if ( m_system->geometry().contains( pos ) )
+        emit clickedSystemButton();
+    else if ( m_btnFavorites->geometry().contains( pos ) )
+        emit clickedFavoritesButton();
+    else if ( m_browser->geometry().contains( pos ) )
+        emit clickedBrowserButton();
+    else if ( m_btnRecently->geometry().contains( pos ) )
+        emit clickedRecentlyButton();
+
+    KMenuBase::mousePressEvent(e);
+}
+
+void KMenu::mouseReleaseEvent ( QMouseEvent * /*e*/ )
+{
+    m_isresizing = false;
+}
+
+void KMenu::mouseMoveEvent ( QMouseEvent * e )
+{
+    if ( hasMouseTracking() && m_isresizing ) {
+        m_stacker->setMinimumSize( QSize(0, 0) );
+        m_stacker->setMaximumSize( QSize(32000, 32000) );
+        int newWidth = QMAX( e->x() - x(), minimumSizeHint().width() );
+        if ( m_orientation == BottomUp ) {
+          int newHeight = QMAX( height() - e->y(), minimumSizeHint().height() + 10 );
+          int newY = y() + height() - newHeight;
+          setGeometry( x(), newY, newWidth, newHeight);
+        }
+        else {
+          setGeometry( x(), y(), newWidth, QMAX( e->y(), minimumSizeHint().height() + 10 ));
+        }
+    }
+}
+
+void KMenu::clearedHistory()
+{
+    saveConfig();
+}
+
+void KMenu::saveConfig()
+{
+    KickerSettings::setHistory( m_kcommand->historyItems() );
+    KickerSettings::setCompletionItems( m_kcommand->completionObject()->items() );
+    KickerSettings::writeConfig();
+}
+
+void KMenu::notifyServiceStarted(KService::Ptr service)
+{
+    // Inform other applications (like the quickstarter applet)
+    // that an application was started
+    QByteArray params;
+    QDataStream stream(params, IO_WriteOnly);
+    stream << "minicli" << service->storageId();
+    kdDebug() << "minicli appLauncher dcop signal: " << service->storageId() << endl;
+    KApplication::kApplication()->dcopClient()->emitDCOPSignal("appLauncher",
+        "serviceStartedByStorageId(QString,QString)", params);
+}
+
+void KMenu::parseLine( bool final )
+{
+  QString cmd = m_kcommand->currentText().stripWhiteSpace();
+  m_filterData->setData( cmd );
+
+  if( final )
+    KURIFilter::self()->filterURI( *(m_filterData), m_finalFilters );
+  else
+    KURIFilter::self()->filterURI( *(m_filterData), m_middleFilters );
+
+  m_iconName = m_filterData->iconName();
+
+  kdDebug (1207) << "Command: " << m_filterData->uri().url() << endl;
+  kdDebug (1207) << "Arguments: " << m_filterData->argsAndOptions() << endl;
+}
+
+// report error as a title in the menu
+void KMenu::reportError (QString error)
+{
+    int index = 1000; //getHitMenuItemPosition (new HitMenuItem (base_category_id[0], 0));
+    kndDebug () << "Inserting error:" << error << " at position " << index << endl;
+    m_searchResultsWidget->insertSeparator(OTHER_ID_BASE + 120, error, index);
+}
+
+int KMenu::getHitMenuItemPosition ( HitMenuItem *hit_item)
+{
+    QPtrListIterator<HitMenuItem> it (m_current_menu_items);
+    const HitMenuItem *cur_item;
+    int pos = 0;
+    while ((cur_item = it.current ()) != NULL) {
+	++it;
+	if ((cur_item->category!=hit_item->category || !cur_item->display_name.isEmpty()) && (*hit_item) < (*cur_item))
+	    break;
+	pos++;
+    }
+    m_current_menu_items.insert (pos, hit_item);
+
+    return pos + 1;
+}
+
+bool KMenu::checkUriInMenu( const QString &uri)
+{
+    QPtrListIterator<HitMenuItem> it (m_current_menu_items);
+    const HitMenuItem *cur_item;
+    while ((cur_item = it.current ()) != NULL) {
+	++it;
+	if (cur_item->uri == uri )
+	    return true;
+    }
+
+    return false;
+}
+
+void KMenu::searchActionClicked(QListViewItem* item)
+{
+   accept();
+
+   addToHistory();
+   if (item==m_searchIndex) {
+     QByteArray data;
+     QDataStream arg(data, IO_WriteOnly);
+     arg << m_kcommand->currentText();
+
+     if (ensureServiceRunning("kerry"))
+       kapp->dcopClient()->send("kerry","search","search(QString)", data);
+   }
+   else {
+     KURIFilterData data;
+     QStringList list;
+     data.setData( m_kcommand->currentText() );
+     list << "kurisearchfilter" << "kuriikwsfilter";
+
+     if( !KURIFilter::self()->filterURI(data, list) ) {
+         KDesktopFile file("searchproviders/google.desktop", true, "services");
+         data.setData(file.readEntry("Query").replace("\\{@}", m_kcommand->currentText()));
+     }
+
+     (void) new KRun( data.uri(), parentWidget());
+   }
+}
+
+void KMenu::addToHistory()
+{
+  QString search = m_kcommand->currentText().stripWhiteSpace();
+
+  if (search.length()<4)
+    return;
+
+  m_kcommand->addToHistory( search );
+}
+
+QString KMenu::newDesktopFile(const KURL& url, const QString &directory)
+{
+   QString base = url.fileName();
+   if (base.endsWith(".desktop"))
+      base.truncate(base.length()-8);
+   QRegExp r("(.*)(?=-\\d+)");
+   if (r.search(base) > -1)
+      base = r.cap(1);
+
+   QString file = base + ".desktop";
+
+   for(int n = 1; ++n; )
+   {
+      if (!QFile::exists(directory+file))
+         break;
+
+      file = QString("%2-%1.desktop").arg(n).arg(base);
+   }
+   return directory+file;
+}
+
+void KMenu::updateRecentlyUsedApps(KService::Ptr &service)
+{
+    QString strItem(service->desktopEntryPath());
+
+    // don't add an item from root kmenu level
+    if (!strItem.contains('/'))
+    {
+        return;
+    }
+
+    // add it into recent apps list
+    RecentlyLaunchedApps::the().appLaunched(strItem);
+    RecentlyLaunchedApps::the().save();
+    RecentlyLaunchedApps::the().m_bNeedToUpdate = true;
+}
+
+QSize KMenu::sizeHint() const
+{
+#warning FIXME
+    // this should be only for the inner area so layout changes do not break it
+    const int width = QMIN(KickerSettings::kMenuWidth(), QApplication::desktop()->width()-50);
+    const int height = QMIN(KickerSettings::kMenuHeight(), QApplication::desktop()->height()-50);
+    QSize wanted(width, height);
+    kdDebug() << "show " << minimumSizeHint() << " " << m_stacker->minimumSizeHint() << " "
+              << m_searchFrame->minimumSizeHint() << " " << wanted << endl;
+    bool isDefault = wanted.isNull();
+    wanted = wanted.expandedTo(minimumSizeHint());
+    if ( isDefault )
+        wanted.setHeight( wanted.height() + ( m_favoriteView->goodHeight() - m_stacker->minimumSizeHint().height() ) );
+
+    return wanted;
+}
+
+QSize KMenu::minimumSizeHint() const
+{
+    QSize minsize = buttonBox->minimumSize();
+    minsize.setWidth( minsize.width() + button_box_left.width() );
+    minsize.setWidth( QMAX( minsize.width(),
+                            m_search->minimumSize().width() ) );
+    minsize.setWidth( QMAX( minsize.width(),
+                            m_search->minimumSize().width() ) );
+
+    minsize.setHeight( minsize.height() +
+                       m_search->minimumSize().height() +
+                       m_footer->minimumSize().height() +
+                       180 ); // 180 is a very rough guess for 32 icon size
+    return minsize;
+}
+
+void KMenu::slotFavoritesMoved( QListViewItem* item, QListViewItem* /*afterFirst*/, QListViewItem* afterNow)
+{
+    KMenuItem* kitem = dynamic_cast<KMenuItem*>(item);
+    KMenuItem* kafterNow = dynamic_cast<KMenuItem*>(afterNow);
+
+    QStringList favs = KickerSettings::favorites();
+    QStringList::Iterator it;
+    QString addFav = QString::null;
+
+    // remove at old position
+    if (kitem->service())
+    {
+        favs.erase(favs.find(kitem->service()->storageId()));
+        addFav = kitem->service()->storageId();
+    }
+    else
+    {
+        for (it = favs.begin(); it != favs.end(); ++it)
+        {
+            if ((*it)[0]=='/')
+            {
+                KDesktopFile df((*it),true);
+                if (df.readURL().replace("file://",QString::null)==kitem->path())
+                {
+                    addFav = *it;
+                    favs.erase(it);
+                    break;
+                }
+            }
+        }
+    }
+
+    if (addFav.isEmpty())
+      return;
+
+    if (!kafterNow || dynamic_cast<KMenuSpacer*>(afterNow))
+    {
+        favs.prepend(addFav);
+    }
+    else
+    {
+        // add at new position
+        for (it = favs.begin(); it != favs.end(); ++it)
+        {
+            if ((*it)[0]=='/' && !kafterNow->service())
+            {
+                KDesktopFile df((*it),true);
+                if (df.readURL().replace("file://",QString::null)==kafterNow->path())
+                {
+                    kdDebug() << "insert after " << kafterNow->path() << endl;
+                    favs.insert(++it,addFav);
+                    break;
+                }
+            }
+            else if (kafterNow->service() && *it==kafterNow->service()->storageId())
+            {
+                kdDebug() << "insert after service " << kafterNow->service() << endl;
+                favs.insert(++it,addFav);
+                break;
+            }
+        }
+    }
+    kdDebug() << "favs " << favs << endl;
+
+    KickerSettings::setFavorites(favs);
+    KickerSettings::writeConfig();
+
+    m_favoriteView->slotMoveContent();
+}
+
+void KMenu::updateMedia()
+{
+    QStringList devices = m_mediaWatcher->devices();
+    if ( devices.isEmpty() )
+        return;
+
+    int nId = serviceMenuStartId();
+    if ( m_media_id ) {
+        for ( int i = m_media_id + 1 ;; ++i )
+        {
+            KMenuItem *item = m_systemView->findItem( i );
+            if ( !item )
+                break;
+            if ( !item->path().startsWith( "system:/" ) )
+                break;
+            media_mimetypes.remove(item->path());
+            delete item;
+        }
+        nId = m_media_id + 1;
+    } else {
+        m_media_id = nId;
+        m_systemView->insertSeparator( nId++, i18n("Media"), -1);
+    }
+
+    for ( QStringList::ConstIterator it = devices.constBegin(); it != devices.constEnd(); ++it )
+    {
+        QString id = ( *it );
+        QString name = *++it;
+        QString label = *++it;
+        QString userLabel = ( *++it );
+        bool mountable = ( *++it == "true" ); // bool
+        ( void )mountable;
+        QString deviceNode = ( *++it );
+        QString mountPoint = ( *++it );
+        QString fsType = ( *++it );
+        bool mounted = ( *++it == "true" ); // bool
+        QString baseURL = ( *++it );
+        QString mimeType = ( *++it );
+        QString iconName = ( *++it );
+
+        media_mimetypes["system:/media/"+name] = mimeType;
+
+        if ( iconName.isEmpty() ) // no user icon, query the MIME type
+        {
+            KMimeType::Ptr mime = KMimeType::mimeType( mimeType );
+            iconName = mime->icon( QString::null, false );
+        }
+
+        QString descr = deviceNode;
+        if ( mounted )
+        {
+            descr = mountPoint;
+            // calc the free/total space
+            struct statfs sfs;
+            if ( statfs( QFile::encodeName( mountPoint ), &sfs ) == 0 )
+            {
+                uint64_t total = ( uint64_t )sfs.f_blocks * sfs.f_bsize;
+                uint64_t avail = ( uint64_t )( getuid() ? sfs.f_bavail : sfs.f_bfree ) * sfs.f_bsize;
+                if ( avail < total && avail > 1024 ) {
+                    label += " " + i18n( "(%1 available)" ).arg( KIO::convertSize(avail) );
+                }
+            }
+        }
+        m_systemView->insertItem( iconName, userLabel.isEmpty() ? label : userLabel,
+                                  descr, "system:/media/" + name, nId++, -1 );
+
+        ++it; // skip separator
+    }
+}
+
+bool KMenu::ensureServiceRunning(const QString & service)
+{
+    QStringList URLs;
+    QByteArray data, replyData;
+    QCString replyType;
+    QDataStream arg(data, IO_WriteOnly);
+    arg << service << URLs;
+
+    if ( !kapp->dcopClient()->call( "klauncher", "klauncher", "start_service_by_desktop_name(QString,QStringList)",
+                      data, replyType, replyData) ) {
+        qWarning( "call to klauncher failed.");
+        return false;
+    }
+    QDataStream reply(replyData, IO_ReadOnly);
+
+    if ( replyType != "serviceResult" )
+    {
+        qWarning( "unexpected result '%s' from klauncher.", replyType.data());
+        return false;
+    }
+    int result;
+    QCString dcopName;
+    QString error;
+    reply >> result >> dcopName >> error;
+    if (result != 0)
+    {
+        qWarning("Error starting: %s", error.local8Bit().data());
+        return false;
+    }
+    return true;
+}
+
+void KMenu::slotFavDropped(QDropEvent * ev, QListViewItem *after )
+{
+    QStringList favs = KickerSettings::favorites();
+    KMenuItem *newItem = 0;
+
+    if (KMenuItemDrag::canDecode(ev))
+    {
+        KMenuItemInfo item;
+        KMenuItemDrag::decode(ev,item);
+
+        if (item.m_s)
+        {
+            if (favs.find(item.m_s->storageId())==favs.end())
+            {
+                newItem = m_favoriteView->insertMenuItem(item.m_s, serviceMenuEndId()+favs.count()+1);
+                favs += item.m_s->storageId();
+            }
+        }
+        else
+        {
+            QString uri = item.m_path;
+            if (uri.startsWith(locateLocal("data", QString::fromLatin1("RecentDocuments/")))) {
+               KDesktopFile df(uri,true);
+               uri=df.readURL();
+            }
+
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it)
+            {
+                if ((*it)[0]=='/')
+                {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==uri)
+                        break;
+                }
+            }
+            if (it==favs.end())
+            {
+                QString file = KickerLib::newDesktopFile(uri);
+                KDesktopFile df(file);
+                df.writeEntry("Encoding", "UTF-8");
+                df.writeEntry("Type","Link");
+                df.writeEntry("Name", item.m_title);
+                df.writeEntry("GenericName", item.m_description);
+                df.writeEntry("Icon", item.m_icon);
+                df.writeEntry("URL", uri);
+
+                newItem = m_favoriteView->insertItem(item.m_icon, item.m_title, item.m_description,
+                                                     uri, serviceMenuEndId()+favs.count()+1, -1);
+                favs += file;
+            }
+        }
+    }
+    else if (QTextDrag::canDecode(ev))
+    {
+        QString text;
+        QTextDrag::decode(ev,text);
+
+        if (text.endsWith(".desktop"))
+        {
+            KService::Ptr p = KService::serviceByDesktopPath(text.replace("file://",QString::null));
+            if (p && favs.find(p->storageId())==favs.end()) {
+                newItem = m_favoriteView->insertMenuItem(p, serviceMenuEndId()+favs.count()+1);
+                favs+=p->storageId();
+            }
+        }
+        else
+        {
+            QStringList::Iterator it;
+            for (it = favs.begin(); it != favs.end(); ++it)
+            {
+                if ((*it)[0]=='/')
+                {
+                    KDesktopFile df((*it),true);
+                    if (df.readURL().replace("file://",QString::null)==text)
+                        break;
+                }
+            }
+            if (it==favs.end())
+            {
+                KFileItem* item = new KFileItem(text, QString::null, KFileItem::Unknown);
+                KURL kurl(text);
+
+                QString file = KickerLib::newDesktopFile(text);
+                KDesktopFile df(file);
+                df.writeEntry("Encoding", "UTF-8");
+                df.writeEntry("Type","Link");
+                df.writeEntry("Name", item->name());
+                df.writeEntry("GenericName", i18n("Directory: %1").arg(kurl.upURL().path()));
+                df.writeEntry("Icon", item->iconName());
+                df.writeEntry("URL", text);
+
+                newItem = m_favoriteView->insertItem(item->iconName(), item->name(), i18n("Directory: %1").arg(kurl.upURL().path()), text, serviceMenuEndId()+favs.count()+1, -1);
+                favs += file;
+            }
+        }
+    }
+
+    if ( newItem ) {
+        if (!after && m_favoriteView->childCount()>0) {
+            newItem->moveItem( m_favoriteView->firstChild() );
+            m_favoriteView->firstChild()->moveItem( newItem );
+        }
+        else
+            newItem->moveItem( after );
+        KickerSettings::setFavorites(favs);
+        slotFavoritesMoved( newItem, 0, after );
+    }
+    raiseStackWidget( m_favoriteView );
+
+}
+
+void KMenu::resetOverflowCategory()
+{
+   if (m_overflowCategoryState==NotNeeded)
+      m_overflowList.setAutoDelete( true );
+
+   m_overflowList.clear();
+   m_overflowList.setAutoDelete( false );
+   m_overflowCategoryState = None;
+   m_overflowCategory = num_categories;
+}
+
+void KMenu::fillOverflowCategory()
+{
+   if (m_overflowCategoryState==Filling) {
+      initCategoryTitlesUpdate();
+      for (HitMenuItem * item = m_overflowList.first(); item; item = m_overflowList.next() ) {
+	  max_category_id [item->category]++;
+          item->id=max_category_id [item->category];
+
+          KMenuItem *hit_item = m_searchResultsWidget->insertItem(iconForHitMenuItem(item), item->display_name, item->display_info, item->uri.url(), max_category_id [item->category], getHitMenuItemPosition (item));
+          hit_item->setService(item->service);
+      }
+      updateCategoryTitles();
+  }
+}
+
+int KMenu::max_items(int category) const
+{
+    if (category==ACTIONS)
+      return 10;
+
+    return 5;
+}
+
+#define DBUS_HAL_INTERFACE             "org.freedesktop.Hal"
+#define DBUS_HAL_SYSTEM_POWER_INTERFACE        "org.freedesktop.Hal.Device.SystemPowerManagement"
+#define HAL_UDI_COMPUTER               "/org/freedesktop/Hal/devices/computer"
+
+#include <liblazy.h>
+
+void KMenu::insertSuspendOption( int &nId, int &index )
+{
+    int supported = -1;
+    bool suspend_ram, suspend_disk, standby;
+
+    liblazy_hal_get_property_bool(HAL_UDI_COMPUTER, "power_management.can_suspend", &supported);
+    if (supported == 1)
+        suspend_ram = true;
+    else
+        suspend_ram = false;
+	liblazy_hal_get_property_bool(HAL_UDI_COMPUTER, "power_management.can_standby", &supported);
+	if (supported == 1)
+	     standby = true;
+	else
+	     standby = false;
+	liblazy_hal_get_property_bool(HAL_UDI_COMPUTER, "power_management.can_hibernate", &supported);
+	if (supported == 1)
+	     suspend_disk = true;
+	else
+	     suspend_disk = false;
+
+	if (liblazy_hal_is_caller_privileged("org.freedesktop.hal.power-management.hibernate") != 1)
+	     suspend_disk = false;
+	if (liblazy_hal_is_caller_privileged("org.freedesktop.hal.power-management.suspend") != 1)
+	     suspend_ram = false;
+	if (liblazy_hal_is_caller_privileged("org.freedesktop.hal.power-management.standby") != 1)
+	    standby = false;
+
+	if ( ! ( standby + suspend_ram + suspend_disk ) )
+            return;
+
+        i18n("Suspend Computer");
+
+        if ( suspend_disk )
+            m_exitView->leftView()->insertItem( "player_pause", i18n( "Suspend to Disk" ),
+                                                i18n( "Pause without logging out" ), "kicker:/suspend_disk", nId++, index++ );
+
+        if ( suspend_ram )
+            m_exitView->leftView()->insertItem( "player_pause", i18n( "Suspend to RAM" ),
+                                                i18n( "Pause without logging out" ), "kicker:/suspend_ram", nId++, index++ );
+
+        if ( standby )
+            m_exitView->leftView()->insertItem( "player_pause", i18n( "Standby" ),
+                                                i18n( "Pause without logging out" ), "kicker:/standby", nId++, index++ );
+}
+
+void KMenu::slotSuspend(int id)
+{
+    int error = 0;
+    int wake = 0;
+    DBusMessage *reply = 0;
+
+    if (id == 1) {
+        error = liblazy_dbus_system_send_method_call(DBUS_HAL_INTERFACE,
+                                                     HAL_UDI_COMPUTER,
+                                                     DBUS_HAL_SYSTEM_POWER_INTERFACE,
+                                                     "Hibernate",
+                                                     &reply,
+                                                     DBUS_TYPE_INVALID);
+    } else if (id == 2)
+        error = liblazy_dbus_system_send_method_call(DBUS_HAL_INTERFACE,
+                                                     HAL_UDI_COMPUTER,
+                                                     DBUS_HAL_SYSTEM_POWER_INTERFACE,
+                                                     "Suspend",
+                                                     &reply,
+                                                     DBUS_TYPE_INT32,
+                                                     &wake,
+                                                     DBUS_TYPE_INVALID);
+    else if (id == 3)
+        error = liblazy_dbus_system_send_method_call(DBUS_HAL_INTERFACE,
+                                                     HAL_UDI_COMPUTER,
+                                                     DBUS_HAL_SYSTEM_POWER_INTERFACE,
+                                                     "Standby",
+                                                     &reply,
+                                                     DBUS_TYPE_INVALID);
+    else
+        return;
+    if (error)
+        KMessageBox::error(this, i18n("Suspend failed"));
+
+}
+
+// vim:cindent:sw=4:
Index: kicker/kicker/ui/k_new_mnu.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/k_new_mnu.h
@@ -0,0 +1,343 @@
+/*****************************************************************
+
+   Copyright (c) 1996-2000 the kicker authors. See file AUTHORS.
+   Copyright (c) 2006 Debajyoti Bera <dbera.web@gmail.com>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef __k_new_mnu_h__
+#define __k_new_mnu_h__
+
+#include <dcopobject.h>
+#include <qintdict.h>
+#include <qpixmap.h>
+#include <qframe.h>
+#include <qtoolbutton.h>
+#include <qscrollview.h>
+#include <qtimer.h>
+#include <qbitmap.h>
+#include <qvbox.h>
+#include <qregexp.h>
+
+#include <kabc/addressbook.h>
+#include <kabc/stdaddressbook.h>
+#include "../interfaces/kickoff-search-plugin.h"
+
+#include "kmenubase.h"
+#include "service_mnu.h"
+#include "query.h"
+
+class KickerClientMenu;
+class KBookmarkMenu;
+class KActionCollection;
+class KBookmarkOwner;
+class Panel;
+class QWidgetStack;
+class KHistoryCombo;
+class QScrollView;
+class PopupMenuTitle;
+class MediaWatcher;
+class KURIFilterData;
+class KBookmarkGroup;
+class KBookmarkManager;
+class ItemView;
+class FlipScrollView;
+class QListViewItem;
+class KMenuItem;
+class QListView;
+
+static QString categories[14] = {I18N_NOOP("Actions"), I18N_NOOP("Applications"), I18N_NOOP("Bookmarks"),
+                                 I18N_NOOP("Notes"), I18N_NOOP("Emails"),  I18N_NOOP("Files"), I18N_NOOP("Music"),
+                                 I18N_NOOP("Browsing History"), I18N_NOOP("Chat Logs"), I18N_NOOP("Feeds"),
+                                 I18N_NOOP("Pictures"), I18N_NOOP("Videos"), I18N_NOOP("Documentation"),
+                                 I18N_NOOP("Others")};
+
+static QString kerry_categories[14] = {"contacts", "applications", "webpages", "everything", "conversations",
+                                       "everything", "media", "webpages", "conversations", "webpages", "images",
+                                       "media", "everything", "everything"};
+
+enum MenuOrientation { Uninitialized, TopDown, BottomUp };
+enum OverflowCategoryState { None, Filling, NotNeeded };
+
+class KMenu : public KMenuBase
+{
+    Q_OBJECT
+
+public:
+    KMenu();
+    ~KMenu();
+
+    int insertClientMenu(KickerClientMenu *p);
+    void removeClientMenu(int id);
+
+    virtual void showMenu();
+    virtual bool eventFilter(QObject*, QEvent*);
+
+    void clearRecentAppsItems();
+    void clearRecentDocsItems();
+    bool highlightMenuItem(const QString& /*id*/) { return false;}
+
+    void selectFirstItem() {}
+    void popup(const QPoint&, int indexAtPoint);
+
+    enum MaskEffect { Plain, Dissolve };
+
+    virtual QSize sizeHint() const;
+    virtual QSize minimumSizeHint() const;
+
+    void searchOver();
+    void initCategoryTitlesUpdate();
+    bool anotherHitMenuItemAllowed(int cat, bool count=true);
+    void addHitMenuItem(HitMenuItem*);
+    void insertSearchResult(HitMenuItem* item);
+
+    void updateCategoryTitles();
+
+signals:
+    void aboutToHide();
+    void aboutToShow();
+
+public slots:
+    virtual void initialize();
+
+    virtual void hide();
+    virtual void show();
+
+    void stackWidgetRaised(QWidget*);
+
+protected slots:
+    void slotLock();
+    void slotPardus();
+    void slotLogout();
+    void slotPopulateSessions();
+    void slotSessionActivated( int );
+    void slotGoSubMenu(const QString& relPath);
+    void slotGoBack();
+    void slotGoExitMainMenu();
+    void slotGoExitSubMenu(const QString& url);
+
+    void paletteChanged();
+    virtual void configChanged();
+    void updateRecent();
+
+    void initSearch();
+    void searchAccept();
+    void searchChanged(const QString &);
+    // when timeout happens or doQueryNow calls
+    void doQuery (bool return_pressed = false);
+    void searchActionClicked(QListViewItem*);
+
+    void slotStartService(KService::Ptr);
+    void slotStartURL(const QString&);
+    void slotContextMenuRequested( QListViewItem * item, const QPoint & pos, int col );
+
+    void clearedHistory();
+
+    void slotBrowserButton();
+    void slotSystemButton();
+    void slotExitButton();
+    void slotRecentlyButton();
+    void slotFavoritesButton();
+    void slotSloppyTimeout();
+
+    void slotContextMenu(int);
+    void slotFavoritesMoved( QListViewItem*, QListViewItem*, QListViewItem* );
+
+    void updateMedia();
+    void slotFavDropped(QDropEvent * e, QListViewItem *after );
+    void slotSuspend(int id);
+
+signals:
+    void clickedBrowserButton();
+    void clickedSystemButton();
+    void clickedExitButton();
+    void clickedRecentlyButton();
+    void clickedFavoritesButton();
+
+protected:
+    virtual void paintEvent(QPaintEvent *);
+    virtual void resizeEvent ( QResizeEvent * );
+    virtual void mousePressEvent ( QMouseEvent * e );
+    virtual void mouseReleaseEvent ( QMouseEvent * e );
+    virtual void mouseMoveEvent ( QMouseEvent * e );
+
+    bool loadSidePixmap();
+    void doNewSession(bool lock);
+    void createRecentMenuItems();
+    void insertStaticItems();
+    void insertSuspendOption( int &id, int &index );
+    virtual void clearSubmenus();
+    void raiseStackWidget( QWidget *view );
+
+    bool runCommand();
+
+    void setupUi();
+
+    void saveConfig();
+    void searchProgramList(QString relPath);
+    void searchBookmarks(KBookmarkGroup);
+    void searchAddressbook();
+
+    void createNewProgramList();
+    void createNewProgramList(QString relPath);
+
+    void paintTab( QFrame *tab, bool active );
+    void paintSearchTab( bool active );
+
+    void goSubMenu(const QString& relPath, bool keyboard = false);
+    void setOrientation(MenuOrientation orientation);
+
+private:
+    int serviceMenuStartId() { return 5242; }
+    int serviceMenuEndId() { return 5242; }
+
+    void fillMenu( KServiceGroup::Ptr &_root, KServiceGroup::List &_list,
+		   const QString &_relPath, ItemView* view, int & id );
+
+    void fillSubMenu(const QString& relPath, ItemView *view);
+
+    QPopupMenu                 *sessionsMenu;
+    QPixmap                     sidePixmap;
+    QPixmap                     sideTilePixmap;
+    int                         client_id;
+    bool                        delay_init;
+    QIntDict<KickerClientMenu>  clients;
+    KActionCollection          *actionCollection;
+    PopupMenuList               dynamicSubMenus;
+
+    QTimer                       m_sloppyTimer;
+    QTimer                       m_mediaFreeTimer;
+    MediaWatcher               * m_mediaWatcher;
+    QRegion                      m_sloppyRegion;
+    QFrame                     * m_sloppyFrame;
+    QWidget                    * m_sloppyWidget;
+    ItemView                   * m_recentlyView;
+    ItemView                   * m_favoriteView;
+    ItemView                   * m_searchResultsWidget;
+    QListView                  * m_searchActions;
+    FlipScrollView             * m_browserView;
+    ItemView                   * m_systemView;
+    FlipScrollView             * m_exitView;
+    QVBox                      * m_searchWidget;
+    QLabel                     * m_resizeHandle;
+
+    bool                       m_isresizing;
+    // timer for search without pressing enter feature
+    QTimer *input_timer, *init_search_timer;
+
+    Query current_query;
+
+    bool dontQueryNow(const QString &);
+
+    // start timeout timer to call doQuery is enough time has passed since last keypress
+    void checkToDoQuery (const QString &);
+    // when return is pressed
+    void doQueryNow ();
+    void clearSearchResults(bool showHelp = true);
+
+    int *max_category_id; // maximum id in this category: max_category_id - base_category_id gives the current number of hits displayed in this category
+    int *categorised_hit_total; // current number of hits returned in each category
+
+    bool ensureServiceRunning(const QString & service);
+
+    QString iconForHitMenuItem(HitMenuItem *hit_item);
+
+    int getHitMenuItemPosition (HitMenuItem *hit_item);
+    QMap<QString, QString> mimetype_iconstore;
+    QMap<QString, QString> media_mimetypes;
+    // report error as a menu item
+    void reportError (QString err);
+    void addToHistory();
+
+    int max_items(int category) const;
+    QString TOP_CATEGORY_STRING;
+    bool *already_added;
+
+    void notifyServiceStarted(KService::Ptr service);
+    void parseLine( bool final );
+    QString m_iconName;
+    QStringList m_middleFilters;
+    QStringList m_finalFilters;
+    KURIFilterData* m_filterData;
+    QPtrList<HitMenuItem> m_current_menu_items;
+    QListViewItem *m_searchIndex, *m_searchInternet;
+
+    bool checkUriInMenu(const QString &uri);
+
+    QRegExp emailRegExp,uriRegExp,uri2RegExp,authRegExp;
+
+    KBookmarkManager *bookmarkManager;
+    KABC::AddressBook* m_addressBook;
+
+    QFrame *m_activeTab;
+
+    enum ContextMenuEntry { AddItemToPanel, EditItem, AddMenuToPanel, EditMenu,
+                            AddItemToDesktop, AddMenuToDesktop, PutIntoRunDialog,
+                            AddToFavorites, RemoveFromFavorites, ClearRecentlyUsedApps, ClearRecentlyUsedDocs };
+    struct PopupPath { QString title, description, icon, path, menuPath; };
+
+    KPopupMenu* m_popupMenu;
+    KService* m_popupService;
+    PopupPath m_popupPath;
+
+    QString newDesktopFile(const KURL& url, const QString &directory);
+    void updateRecentlyUsedApps(KService::Ptr &service);
+
+    QPixmap main_border_lc;
+    QPixmap main_border_rc;
+    QPixmap main_border_tl;
+    QPixmap main_border_tr;
+    QPixmap button_box_left;
+
+    QPixmap tab_bottom_left;
+    QPixmap tab_bottom_right;
+    QPixmap tab_center;
+    QPixmap tab_left_center;
+    QPixmap tab_right_center;
+    QPixmap tab_top_left;
+    QPixmap tab_top_right;
+
+    QPixmap search_tab_left;
+    QPixmap search_tab_right;
+    QPixmap search_tab_center;
+
+    QWidgetStack *m_stacker;
+
+    QStringList m_programsInMenu;
+    QStringList m_newInstalledPrograms, m_seenPrograms;
+    bool m_seenProgramsChanged;
+    QString m_currentDate;
+
+    MenuOrientation m_orientation;
+    bool m_toolTipsEnabled;
+    int m_media_id;
+
+    bool m_recentDirty, m_browserDirty, m_kerryInstalled, m_isShowing;
+
+    KickoffSearch::Plugin* m_search_plugin;
+    QObject* m_search_plugin_interface;
+
+    OverflowCategoryState m_overflowCategoryState;
+    QPtrList<HitMenuItem> m_overflowList;
+    int m_overflowCategory;
+
+    void resetOverflowCategory();
+    void fillOverflowCategory();
+};
+
+#endif
Index: kicker/kicker/ui/Makefile.am
===================================================================
--- kicker/kicker/ui/Makefile.am.orig
+++ kicker/kicker/ui/Makefile.am
@@ -1,38 +1,44 @@
 INCLUDES = -I$(srcdir)/../core -I../core -I$(srcdir)/../buttons \
 	-I../../libkicker -I$(srcdir)/../../libkicker \
-	-I$(top_srcdir)/libkonq -I$(top_srcdir)/kdmlib $(all_includes)
+	-I$(top_srcdir)/libkonq -I$(top_srcdir)/kdmlib $(DBUS_INCS) $(all_includes)
 
 noinst_LTLIBRARIES = libkicker_ui.la
 
 libkicker_ui_la_SOURCES = addbutton_mnu.cpp appletitem.ui appletview.ui addapplet.cpp \
         addapplet_mnu.cpp appletop_mnu.cpp \
         browser_mnu.cpp client_mnu.cpp dirdrop_mnu.cpp \
-        nonKDEButtonSettings.ui exe_dlg.cpp k_mnu.cpp k_mnu.skel\
-        quickbrowser_mnu.cpp service_mnu.cpp \
-        addextension_mnu.cpp extensionop_mnu.cpp \
-        recentapps.cpp browser_dlg.cpp \
+        nonKDEButtonSettings.ui exe_dlg.cpp k_new_mnu.cpp k_mnu.cpp k_mnu.skel\
+        quickbrowser_mnu.cpp service_mnu.cpp kmenubase.ui kmenuitembase.ui \
+        addextension_mnu.cpp extensionop_mnu.cpp k_mnu_stub.cpp \
+        recentapps.cpp browser_dlg.cpp itemview.cpp \
         removeapplet_mnu.cpp removeextension_mnu.cpp removecontainer_mnu.cpp \
         removebutton_mnu.cpp popupmenutitle.cpp hidebutton.cpp \
-        addappletvisualfeedback.cpp
+        addappletvisualfeedback.cpp flipscrollview.cpp \
+	media_watcher.cpp media_watcher.skel mykickoffsearchinterface.cpp query.cpp
 
-libkicker_ui_la_LIBADD = $(top_builddir)/libkonq/libkonq.la $(top_builddir)/kdmlib/libdmctl.la
+libkicker_ui_la_LIBADD = $(top_builddir)/libkonq/libkonq.la $(top_builddir)/kdmlib/libdmctl.la \
+		$(LIB_KABC) ../interfaces/libkickoffsearch_interfaces.la -llazy
 
 libkicker_ui_la_METASOURCES = AUTO
 
 noinst_HEADERS = addapplet.h appletwidget.h addbutton_mnu.h addapplet_mnu.h appletop_mnu.h \
-		browser_mnu.h client_mnu.h dirdrop_mnu.h exe_dlg.h k_mnu.h \
+		browser_mnu.h client_mnu.h dirdrop_mnu.h exe_dlg.h k_new_mnu.h  k_mnu.h \
 		quickbrowser_mnu.h service_mnu.h \
 		addextension_mnu.h extensionop_mnu.h \
-		recentapps.h browser_dlg.h \
+		recentapps.h browser_dlg.h itemview.h query.h \
 		removeapplet_mnu.h removeextension_mnu.h removecontainer_mnu.h \
 		removebutton_mnu.h popupmenutitle.h hidebutton.h addappletvisualfeedback.h
 
+kicker_ui_data_DATA = default-favs
+kicker_ui_datadir = $(kde_datadir)/kicker
+
 removecontainer_mnu.lo: ../../libkicker/kickerSettings.h
 removeextension_mnu.lo: ../../libkicker/kickerSettings.h
 addextension_mnu.lo: ../core/extensionSettings.h
 appletop_mnu.lo: ../../libkicker/kickerSettings.h
 extensionop_mnu.lo: ../../libkicker/kickerSettings.h
 k_mnu.lo: ../../libkicker/kickerSettings.h
+k_new_mnu.lo: ../../libkicker/kickerSettings.h
 removecontainer_mnu.lo: ../core/extensionSettings.h
 removeextension_mnu.lo: ../core/extensionSettings.h
 service_mnu.lo: ../../libkicker/kickerSettings.h
Index: kicker/kicker/ui/media_watcher.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/media_watcher.cpp
@@ -0,0 +1,57 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Kulow <coolo@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#include "media_watcher.h"
+#include <kapplication.h>
+#include <kdebug.h>
+#include <dcopclient.h>
+#include <dcopref.h>
+
+MediaWatcher::MediaWatcher( QObject *parent ) :
+    QObject( parent ), DCOPObject("mediawatcher")
+{
+    connectDCOPSignal( "kded", "mediamanager", "mediumAdded(QString,bool)",
+                       "slotMediumAdded(QString,bool)", true );
+    connectDCOPSignal( "kded", "mediamanager", "mediumRemoved(QString,bool)",
+                       "slotMediumAdded(QString,bool)", true );
+    connectDCOPSignal( "kded", "mediamanager", "mediumChanged(QString,bool)",
+                       "slotMediumAdded(QString,bool)", true );
+
+    updateDevices();
+}
+
+void MediaWatcher::updateDevices()
+{
+    DCOPRef nsd( "kded", "mediamanager" );
+    nsd.setDCOPClient( kapp->dcopClient() );
+    m_devices = nsd.call( "fullList" );
+}
+
+void MediaWatcher::slotMediumAdded( QString item, bool a )
+{
+    updateDevices();
+
+    emit mediumChanged();
+}
+
+#include "media_watcher.moc"
Index: kicker/kicker/ui/media_watcher.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/media_watcher.h
@@ -0,0 +1,51 @@
+/*****************************************************************
+
+Copyright (c) 2006 Stephan Kulow <coolo@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef _media_watcher_
+#define _media_watcher_
+
+#include <dcopobject.h>
+#include <qobject.h>
+#include <qstringlist.h>
+
+class MediaWatcher : public QObject, public DCOPObject
+{
+    Q_OBJECT
+    K_DCOP
+
+    QStringList m_devices;
+    void updateDevices();
+
+k_dcop:
+    void slotMediumAdded(QString medium, bool a);
+
+signals:
+    void mediumChanged();
+
+public:
+    MediaWatcher(QObject *parent);
+
+    QStringList devices() const { return m_devices; }
+};
+
+#endif
Index: kicker/kicker/ui/mykickoffsearchinterface.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/mykickoffsearchinterface.cpp
@@ -0,0 +1,54 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#include "mykickoffsearchinterface.h"
+#include "../ui/k_new_mnu.h"
+
+MyKickoffSearchInterface::MyKickoffSearchInterface( KMenu* menu, QObject* parent, const char* name  )
+    : KickoffSearchInterface( parent, name ), _menu( menu )
+{
+}
+
+bool MyKickoffSearchInterface::anotherHitMenuItemAllowed(int cat)
+{
+   return _menu->anotherHitMenuItemAllowed(cat);
+}
+
+void MyKickoffSearchInterface::addHitMenuItem(HitMenuItem* item)
+{
+   _menu->addHitMenuItem(item);
+}
+
+
+void MyKickoffSearchInterface::searchOver()
+{
+   _menu->searchOver();
+}
+
+void MyKickoffSearchInterface::initCategoryTitlesUpdate()
+{
+   _menu->initCategoryTitlesUpdate();
+}
+
+void MyKickoffSearchInterface::updateCategoryTitles()
+{
+   _menu->updateCategoryTitles();
+}
+
+#include "mykickoffsearchinterface.moc"
Index: kicker/kicker/ui/mykickoffsearchinterface.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/mykickoffsearchinterface.h
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Stephan Binner <binner@kde.org>                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ ***************************************************************************/
+
+#ifndef MYKICKOFFSEARCHINTERFACE_H
+#define MYKICKOFFSEARCHINTERFACE_H
+
+#include "../interfaces/kickoffsearchinterface.h"
+
+class KMenu;
+
+using namespace KickoffSearch;
+
+class MyKickoffSearchInterface :public KickoffSearchInterface
+{
+    Q_OBJECT
+
+public:
+    MyKickoffSearchInterface( KMenu*, QObject* parent, const char* name = 0 );
+
+    bool anotherHitMenuItemAllowed(int cat);
+    void addHitMenuItem(HitMenuItem* item);
+    void searchOver();
+    void initCategoryTitlesUpdate();
+    void updateCategoryTitles();
+
+private:
+    KMenu* _menu;
+
+};
+
+#endif /* MYKICKOFFSEARCHINTERFACE_H */
Index: kicker/kicker/ui/query.cpp
===================================================================
--- /dev/null
+++ kicker/kicker/ui/query.cpp
@@ -0,0 +1,136 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Stephan Binner <binner@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#include "query.h"
+#include <kdebug.h>
+
+Query::Query()
+{
+   alternatives.setAutoDelete(true);
+}
+
+void Query::clear()
+{
+   query_term = QString::null;
+   alternatives.clear();
+}
+
+void Query::set(const QString &term)
+{
+   query_term = term;
+   alternatives.clear();
+
+   current_alternative = new Alternative;
+   current_part = QString::null;
+   within_quotes = false;
+   exclude_part = false;
+
+   for (uint index=0;index<term.length();index++) {
+      if (current_part.isEmpty() && query_term[index]=='-')
+         exclude_part = true;
+      else if (term[index]=='\'' || term[index]=='"') {
+         if (within_quotes)
+            add_term();
+         else
+            within_quotes = true;
+      }
+      else if (!within_quotes && query_term[index]==' ')
+         add_term();
+      else if (!exclude_part && !within_quotes && query_term[index]=='O' && index+1<term.length() && query_term[index+1]=='R') {
+         index++;
+         alternatives.append(current_alternative);
+         current_alternative = new Alternative;
+         within_quotes = false;
+         exclude_part = false;
+         current_part = QString::null;
+     }
+     else
+        current_part+=term[index];
+   }
+   add_term();
+   alternatives.append(current_alternative);
+
+#if 0
+   for (Alternative* alt=alternatives.first(); alt; alt=alternatives.next()) {
+      kdDebug() << "---" << endl;
+      kdDebug() << "*** includes = " << alt->includes << endl;
+      kdDebug() << "*** excludes = " << alt->excludes << endl;
+   }
+#endif
+}
+
+void Query::add_term() {
+   if (!current_part.isEmpty()) {
+      if (current_part.startsWith("*"))
+         current_part=current_part.mid(1);
+
+      if (current_part.endsWith("*"))
+         current_part=current_part.mid(0,current_part.length()-1);
+
+      if (exclude_part)
+         current_alternative->excludes+=current_part.lower();
+      else
+         current_alternative->includes+=current_part.lower();
+   }
+   within_quotes = false;
+   exclude_part = false;
+   current_part = QString::null;
+}
+
+QString Query::get() const
+{
+   return query_term;
+}
+
+bool Query::matches(const QString &term)
+{
+   QString lower_term = term.lower();
+
+   for (Alternative* alt=alternatives.first(); alt; alt=alternatives.next()) {
+      if (!alt->includes.count())
+         continue;
+
+      bool next_alternative = false;
+
+      for ( QStringList::ConstIterator it = alt->excludes.begin(); it != alt->excludes.end(); ++it ) {
+         if ( lower_term.find(*it)!=-1 ) {
+            next_alternative = true;
+            continue;
+         }
+      }
+      if (next_alternative)
+         continue;
+
+      for ( QStringList::ConstIterator it = alt->includes.begin(); it != alt->includes.end(); ++it ) {
+         if ( lower_term.find(*it)==-1 ) {
+            next_alternative = true;
+            continue;
+         }
+      }
+      if (next_alternative)
+         continue;
+
+//kdDebug() << "Found hit in '" << term << "'" << endl;
+      return true;
+   }
+
+   return false;
+}
Index: kicker/kicker/ui/query.h
===================================================================
--- /dev/null
+++ kicker/kicker/ui/query.h
@@ -0,0 +1,55 @@
+/*****************************************************************
+
+   Copyright (c) 2006 Stephan Binner <binner@kde.org>
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; see the file COPYING.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+******************************************************************/
+
+#ifndef QUERY_H
+#define QUERY_H
+
+#include <qstringlist.h>
+#include <qptrlist.h>
+
+class Alternative
+{
+public:
+    QStringList includes;
+    QStringList excludes;
+};
+
+class Query
+{
+  public:
+    Query();
+    void clear();
+    void set(const QString &);
+    QString get() const;
+    bool matches(const QString &);
+
+  private:
+    QString query_term;
+    QPtrList<Alternative> alternatives;
+
+    void add_term();
+    QString current_part;
+    Alternative *current_alternative;
+    bool within_quotes;
+    bool exclude_part;
+};
+
+#endif
Index: kicker/libkicker/kickerSettings.kcfg
===================================================================
--- kicker/libkicker/kickerSettings.kcfg.orig
+++ kicker/libkicker/kickerSettings.kcfg
@@ -98,6 +98,27 @@
       <label>A list of extensions that have been loaded at runtime. In the case of a crash these extensions will not be loaded at the next Kicker start, in case they caused the crash</label>
    </entry>
 
+<entry name="LegacyKMenu" type="Bool" >
+      <label>When this option is enabled, the classic K Menu is used.</label>
+      <default>true</default>
+   </entry>
+
+<entry name="OpenOnHover" type="Bool" >
+      <label>When this option is enabled, the Kickoff Menu does open on mouse hover.</label>
+      <default>false</default>
+   </entry>
+
+<entry name="KMenuWidth" type="Int">
+      <label>Preferred width of the KMenu</label>
+      <default>0</default>
+    </entry>
+
+<entry name="KMenuHeight" type="Int">
+      <label>Preferred width of the KMenu</label>
+      <default>0</default>
+    </entry>
+
+
 </group>
 
 <group name="menus">
@@ -172,6 +193,19 @@
       <default>false</default>
    </entry>
 
+<entry name="Favorites" type="StringList">
+      <label>The menu entries shown in the Favorites tab</label>
+   </entry>
+
+<entry name="FirstRun" type="Bool" >
+      <label>Whether the panel has been started before or not</label>
+      <default>true</default>
+   </entry>
+
+<entry name="FirstSeenApps" type="StringList">
+      <label>When the applications were first seen by Kickoff</label>
+   </entry>
+
 </group>
 
 <group name="button_tiles">
@@ -337,6 +371,29 @@
 
 </group>
 
+  <group name="SearchField"> 
+    <entry key="History" type="PathList">
+      <default></default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+    <entry key="HistoryLength" type="Int">
+      <default>50</default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+    <entry key="CompletionItems" type="PathList">
+      <default></default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+    <entry key="CompletionMode" type="Int">
+      <default>2</default>
+      <label></label>
+      <whatsthis></whatsthis>
+    </entry>
+  </group>
+
 </kcfg>
 
 
Index: kicker/libkicker/panelbutton.cpp
===================================================================
--- kicker/libkicker/panelbutton.cpp.orig
+++ kicker/libkicker/panelbutton.cpp
@@ -65,6 +65,7 @@ PanelButton::PanelButton( QWidget* paren
       m_hasAcceptedDrag(false),
       m_arrowDirection(KPanelExtension::Bottom),
       m_popupDirection(KPanelApplet::Up),
+      m_iconAlignment(AlignCenter),
       m_orientation(Horizontal),
       m_size((KIcon::StdSizes)-1),
       m_fontPercent(0.40)
@@ -186,6 +187,12 @@ void PanelButton::setPopupDirection(KPan
     setArrowDirection(KickerLib::directionToPopupPosition(d));
 }
 
+void PanelButton::setIconAlignment(AlignmentFlags align)
+{
+    m_iconAlignment = align;
+    update();
+}
+
 void PanelButton::setOrientation(Orientation o)
 {
     m_orientation = o;
@@ -556,11 +563,13 @@ void PanelButton::drawButtonLabel(QPaint
                                                  icon.height() - 2);
     }
 
+    // coolo only wants center and top. Bottom/Right isn't there.
+    int y = (m_iconAlignment & AlignVCenter) ? (height() - icon.height()) / 2 : 0;
+
     if (!m_buttonText.isEmpty() && orientation() == Horizontal)
     {
         int h = height();
         int w = width();
-        int y = (h - icon.height())/2;
         p->save();
         QFont f = font();
 
@@ -629,8 +638,7 @@ void PanelButton::drawButtonLabel(QPaint
     }
     else if (!icon.isNull())
     {
-        int y = (height() - icon.height()) / 2;
-        int x = (width()  - icon.width()) / 2;
+        int x = (m_iconAlignment & AlignHCenter) ? (width()  - icon.width()) / 2 : 0;
         p->drawPixmap(x, y, icon);
     }
 
@@ -792,7 +800,19 @@ void PanelButton::loadIcons()
     QString nm = m_iconName;
     KIcon::States defaultState = isEnabled() ? KIcon::DefaultState :
                                                KIcon::DisabledState;
-    m_icon = ldr->loadIcon(nm, KIcon::Panel, m_size, defaultState, 0L, true);
+    if (nm=="kmenu-suse")
+    {
+        QString pth = locate( "appdata", "pics/kmenu_basic.mng" );
+        if (!pth.isEmpty())
+        {
+            m_icon = QImage(pth);
+            m_iconh = QPixmap(m_icon);
+            m_iconz = QPixmap(m_icon);
+            return;
+        }
+    }
+    else
+        m_icon = ldr->loadIcon(nm, KIcon::Panel, m_size, defaultState, 0L, true);
 
     if (m_icon.isNull())
     {
@@ -857,7 +877,7 @@ PanelPopupButton::PanelPopupButton(QWidg
     connect(this, SIGNAL(pressed()), SLOT(slotExecMenu()));
 }
 
-void PanelPopupButton::setPopup(QPopupMenu *popup)
+void PanelPopupButton::setPopup(QWidget *popup)
 {
     if (m_popup)
     {
@@ -875,7 +895,7 @@ void PanelPopupButton::setPopup(QPopupMe
     }
 }
 
-QPopupMenu *PanelPopupButton::popup() const
+QWidget *PanelPopupButton::popup() const
 {
     return m_popup;
 }
@@ -954,7 +974,9 @@ void PanelPopupButton::slotExecMenu()
     }
 
     m_popup->adjustSize();
-    m_popup->exec(KickerLib::popupPosition(popupDirection(), m_popup, this));
+    if(dynamic_cast<QPopupMenu*>(m_popup))
+        static_cast<QPopupMenu*>(m_popup)->exec(KickerLib::popupPosition(popupDirection(), m_popup, this));
+    // else.. hmm. some derived class has to fix it.
 }
 
 void PanelPopupButton::menuAboutToHide()
@@ -983,3 +1005,5 @@ void PanelPopupButton::setInitialized(bo
     m_initialized = initialized;
 }
 
+
+
Index: kicker/libkicker/panelbutton.h
===================================================================
--- kicker/libkicker/panelbutton.h.orig
+++ kicker/libkicker/panelbutton.h
@@ -257,6 +257,8 @@ public slots:
     void setPopupDirection(KPanelApplet::Direction d);
 
 protected:
+
+    void setIconAlignment(AlignmentFlags align);
     /**
      * Subclasses must implement this to define the name of the button which is
      * used to identify this button for saving and loading. It must be unique
@@ -391,6 +393,7 @@ private:
     QPixmap m_iconz; // mouse over
     KPanelExtension::Position m_arrowDirection;
     KPanelApplet::Direction m_popupDirection;
+    AlignmentFlags m_iconAlignment;
     Orientation m_orientation;
     int m_size;
     double m_fontPercent;
@@ -419,12 +422,12 @@ public:
      * Sets the button's popup menu.
      * @param popup the menu to pop up
      */
-    void setPopup(QPopupMenu *popup);
+    void setPopup(QWidget *popup);
 
     /**
      * @return the button's popup menu
      */
-    QPopupMenu *popup() const;
+    QWidget *popup() const;
 
     bool eventFilter(QObject *, QEvent *);
     virtual void showMenu();
@@ -459,8 +462,8 @@ protected slots:
 private slots:
     void menuAboutToHide();
 
-private:
-    QPopupMenu *m_popup;
+protected:
+    QWidget *m_popup;
     bool m_pressedDuringPopup;
     bool m_initialized;
 
Index: kicker/taskbar/taskcontainer.cpp
===================================================================
--- kicker/taskbar/taskcontainer.cpp.orig
+++ kicker/taskbar/taskcontainer.cpp
@@ -67,7 +67,11 @@ TaskContainer::TaskContainer(Task::Ptr t
       discardNextMouseEvent(false),
       aboutToActivate(false),
       m_mouseOver(false),
-      m_paintEventCompression(false)
+      animationTimer(0, "TaskContainer::animationTimer"),
+      dragSwitchTimer(0, "TaskContainer::dragSwitchTimer"),
+      attentionTimer(0, "TaskContainer::attentionTimer"),
+      m_paintEventCompression(false),
+      m_paintEventCompressionTimer(0, "TaskContainer::paintEventCompressionTimer")
 {
     init();
     setAcceptDrops(true); // Always enabled to activate task during drag&drop.
@@ -95,7 +99,11 @@ TaskContainer::TaskContainer(Startup::Pt
       discardNextMouseEvent(false),
       aboutToActivate(false),
       m_mouseOver(false),
-      m_paintEventCompression(false)
+      animationTimer(0, "TaskContainer::animationTimer"),
+      dragSwitchTimer(0, "TaskContainer::dragSwitchTimer"),
+      attentionTimer(0, "TaskContainer::attentionTimer"),
+      m_paintEventCompression(false),
+      m_paintEventCompressionTimer(0, "TaskContainer::paintEventCompressionTimer")
 {
     init();
     setEnabled(false);
