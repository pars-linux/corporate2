From 2d34651fbd5887cd254ca9dfcef740c258859104 Mon Sep 17 00:00:00 2001
From: Eric W. Biederman <ebiederm@xmission.com>
Date: Tue, 9 Mar 2010 13:06:51 +0100
Subject: [PATCH] nsfd v5

git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/linux-2.6.33-nsfd-v5.git

0001-pid-Remove-the-child_reaper-special-case-in-init-mai.patch
0002-pidns-Call-pid_ns_prepare_proc-from-create_pid_names.patch
0003-pidns-Don-t-allow-new-pids-after-the-namespace-is-de.patch
0004-pidns-Use-task_active_pid_ns-where-appropriate.patch
0005-pidns-Support-unsharing-the-pid-namespace.patch
0006-ns-proc-files-for-namespace-naming-policy.patch
0007-ns-Introduce-the-setns-syscall.patch
0008-ns-proc-Add-support-for-the-network-namespace.patch
0009-ns-proc-Add-support-for-the-pid-namespace.patch
0010-ns-proc-Add-support-for-the-uts-namespace.patch
0011-ns-proc-Add-support-for-the-ipc-namespace.patch
0012-ns-proc-Add-support-for-the-mount-namespace.patch

Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
---
 arch/alpha/kernel/systbls.S               |    1 
 arch/arm/kernel/calls.S                   |    1 
 arch/avr32/kernel/syscall_table.S         |    1 
 arch/blackfin/mach-common/entry.S         |    1 
 arch/ia64/kernel/entry.S                  |    1 
 arch/microblaze/kernel/syscall_table.S    |    1 
 arch/mips/kernel/scall32-o32.S            |    1 
 arch/mips/kernel/scall64-64.S             |    1 
 arch/mips/kernel/scall64-n32.S            |    1 
 arch/mips/kernel/scall64-o32.S            |    1 
 arch/powerpc/platforms/cell/spufs/sched.c |    2 
 arch/sh/kernel/syscalls_64.S              |    1 
 arch/sparc/kernel/systbls_32.S            |    2 
 arch/sparc/kernel/systbls_64.S            |    4 
 arch/um/drivers/mconsole_kern.c           |    2 
 arch/x86/ia32/ia32entry.S                 |    1 
 arch/x86/include/asm/unistd_32.h          |    3 
 arch/x86/include/asm/unistd_64.h          |    2 
 arch/x86/kernel/syscall_table_32.S        |    1 
 arch/xtensa/include/asm/unistd.h          |    4 
 fs/namespace.c                            |   57 ++++++++
 fs/proc/Makefile                          |    1 
 fs/proc/base.c                            |   22 +--
 fs/proc/inode.c                           |    7 +
 fs/proc/internal.h                        |   18 ++
 fs/proc/namespaces.c                      |  196 ++++++++++++++++++++++++++++++
 fs/proc/root.c                            |   28 +---
 include/linux/pid_namespace.h             |   12 +
 include/linux/proc_fs.h                   |   21 +++
 init/main.c                               |    9 -
 ipc/namespace.c                           |   31 ++++
 kernel/cgroup.c                           |    2 
 kernel/fork.c                             |   11 -
 kernel/nsproxy.c                          |   44 ++++++
 kernel/perf_event.c                       |    2 
 kernel/pid.c                              |   12 +
 kernel/pid_namespace.c                    |   41 +++++-
 kernel/signal.c                           |    9 -
 kernel/sysctl_binary.c                    |    2 
 kernel/utsname.c                          |   32 ++++
 net/core/net_namespace.c                  |   30 ++++
 41 files changed, 543 insertions(+), 76 deletions(-)
 create mode 100644 fs/proc/namespaces.c

Index: linux-2.6.35/arch/alpha/kernel/systbls.S
===================================================================
--- linux-2.6.35.orig/arch/alpha/kernel/systbls.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/alpha/kernel/systbls.S	2010-08-03 16:40:55.534551725 -0700
@@ -512,6 +512,7 @@
 	.quad sys_pwritev
 	.quad sys_rt_tgsigqueueinfo
 	.quad sys_perf_event_open
+	.quad sys_setns
 
 	.size sys_call_table, . - sys_call_table
 	.type sys_call_table, @object
Index: linux-2.6.35/arch/arm/kernel/calls.S
===================================================================
--- linux-2.6.35.orig/arch/arm/kernel/calls.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/arm/kernel/calls.S	2010-08-03 16:40:55.534551725 -0700
@@ -375,6 +375,7 @@
 		CALL(sys_rt_tgsigqueueinfo)
 		CALL(sys_perf_event_open)
 /* 365 */	CALL(sys_recvmmsg)
+		CALL(sys_setns)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
Index: linux-2.6.35/arch/avr32/kernel/syscall_table.S
===================================================================
--- linux-2.6.35.orig/arch/avr32/kernel/syscall_table.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/avr32/kernel/syscall_table.S	2010-08-03 16:40:55.534551725 -0700
@@ -296,4 +296,5 @@
 	.long	sys_ni_syscall		/* 280, was sys_timerfd */
 	.long	sys_eventfd
 	.long	sys_recvmmsg
+	.long	sys_setns
 	.long	sys_ni_syscall		/* r8 is saturated at nr_syscalls */
Index: linux-2.6.35/arch/blackfin/mach-common/entry.S
===================================================================
--- linux-2.6.35.orig/arch/blackfin/mach-common/entry.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/blackfin/mach-common/entry.S	2010-08-03 16:40:55.534551725 -0700
@@ -1628,6 +1628,7 @@
 	.long _sys_rt_tgsigqueueinfo
 	.long _sys_perf_event_open
 	.long _sys_recvmmsg		/* 370 */
+	.long _sys_setns
 
 	.rept NR_syscalls-(.-_sys_call_table)/4
 	.long _sys_ni_syscall
Index: linux-2.6.35/arch/ia64/kernel/entry.S
===================================================================
--- linux-2.6.35.orig/arch/ia64/kernel/entry.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/ia64/kernel/entry.S	2010-08-03 16:40:55.624923258 -0700
@@ -1768,6 +1768,7 @@
 	data8 sys_pwritev			// 1320
 	data8 sys_rt_tgsigqueueinfo
 	data8 sys_recvmmsg
+	data8 sys_setns
 
 	.org sys_call_table + 8*NR_syscalls	// guard against failures to increase NR_syscalls
 #endif /* __IA64_ASM_PARAVIRTUALIZED_NATIVE */
Index: linux-2.6.35/arch/microblaze/kernel/syscall_table.S
===================================================================
--- linux-2.6.35.orig/arch/microblaze/kernel/syscall_table.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/microblaze/kernel/syscall_table.S	2010-08-03 16:40:55.624923258 -0700
@@ -372,3 +372,4 @@
 	.long sys_rt_tgsigqueueinfo	/* 365 */
 	.long sys_perf_event_open
 	.long sys_recvmmsg
+	.long sys_setns
Index: linux-2.6.35/arch/mips/kernel/scall32-o32.S
===================================================================
--- linux-2.6.35.orig/arch/mips/kernel/scall32-o32.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/mips/kernel/scall32-o32.S	2010-08-03 16:40:55.624923258 -0700
@@ -584,6 +584,7 @@
 	sys	sys_perf_event_open	5
 	sys	sys_accept4		4
 	sys     sys_recvmmsg            5
+	sys	sys_setns		2
 	.endm
 
 	/* We pre-compute the number of _instruction_ bytes needed to
Index: linux-2.6.35/arch/mips/kernel/scall64-64.S
===================================================================
--- linux-2.6.35.orig/arch/mips/kernel/scall64-64.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/mips/kernel/scall64-64.S	2010-08-03 16:40:55.624923258 -0700
@@ -421,4 +421,5 @@
 	PTR	sys_perf_event_open
 	PTR	sys_accept4
 	PTR     sys_recvmmsg
+	PTR	sys_setns
 	.size	sys_call_table,.-sys_call_table
Index: linux-2.6.35/arch/mips/kernel/scall64-n32.S
===================================================================
--- linux-2.6.35.orig/arch/mips/kernel/scall64-n32.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/mips/kernel/scall64-n32.S	2010-08-03 16:41:51.827169090 -0700
@@ -420,4 +420,5 @@
 	PTR	sys_accept4
 	PTR     compat_sys_recvmmsg
 	PTR     sys_getdents
+	PTR	sys_setns
 	.size	sysn32_call_table,.-sysn32_call_table
Index: linux-2.6.35/arch/mips/kernel/scall64-o32.S
===================================================================
--- linux-2.6.35.orig/arch/mips/kernel/scall64-o32.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/mips/kernel/scall64-o32.S	2010-08-03 16:40:55.624923258 -0700
@@ -539,4 +539,5 @@
 	PTR	sys_perf_event_open
 	PTR	sys_accept4
 	PTR     compat_sys_recvmmsg
+	PTR	sys_setns
 	.size	sys_call_table,.-sys_call_table
Index: linux-2.6.35/arch/powerpc/platforms/cell/spufs/sched.c
===================================================================
--- linux-2.6.35.orig/arch/powerpc/platforms/cell/spufs/sched.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/powerpc/platforms/cell/spufs/sched.c	2010-08-03 16:40:55.624923258 -0700
@@ -1095,7 +1095,7 @@
 		LOAD_INT(c), LOAD_FRAC(c),
 		count_active_contexts(),
 		atomic_read(&nr_spu_contexts),
-		current->nsproxy->pid_ns->last_pid);
+		task_active_pid_ns(current)->last_pid);
 	return 0;
 }
 
Index: linux-2.6.35/arch/sh/kernel/syscalls_64.S
===================================================================
--- linux-2.6.35.orig/arch/sh/kernel/syscalls_64.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/sh/kernel/syscalls_64.S	2010-08-03 16:40:55.624923258 -0700
@@ -393,3 +393,4 @@
 	.long sys_perf_event_open
 	.long sys_recvmmsg		/* 365 */
 	.long sys_accept4
+	.long sys_setns
Index: linux-2.6.35/arch/sparc/kernel/systbls_32.S
===================================================================
--- linux-2.6.35.orig/arch/sparc/kernel/systbls_32.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/sparc/kernel/systbls_32.S	2010-08-03 16:40:55.624923258 -0700
@@ -82,5 +82,5 @@
 /*310*/	.long sys_utimensat, sys_signalfd, sys_timerfd_create, sys_eventfd, sys_fallocate
 /*315*/	.long sys_timerfd_settime, sys_timerfd_gettime, sys_signalfd4, sys_eventfd2, sys_epoll_create1
 /*320*/	.long sys_dup3, sys_pipe2, sys_inotify_init1, sys_accept4, sys_preadv
-/*325*/	.long sys_pwritev, sys_rt_tgsigqueueinfo, sys_perf_event_open, sys_recvmmsg
+/*325*/	.long sys_pwritev, sys_rt_tgsigqueueinfo, sys_perf_event_open, sys_recvmmsg, sys_setns
 
Index: linux-2.6.35/arch/sparc/kernel/systbls_64.S
===================================================================
--- linux-2.6.35.orig/arch/sparc/kernel/systbls_64.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/sparc/kernel/systbls_64.S	2010-08-03 16:40:55.624923258 -0700
@@ -83,7 +83,7 @@
 /*310*/	.word compat_sys_utimensat, compat_sys_signalfd, sys_timerfd_create, sys_eventfd, compat_sys_fallocate
 	.word compat_sys_timerfd_settime, compat_sys_timerfd_gettime, compat_sys_signalfd4, sys_eventfd2, sys_epoll_create1
 /*320*/	.word sys_dup3, sys_pipe2, sys_inotify_init1, sys_accept4, compat_sys_preadv
-	.word compat_sys_pwritev, compat_sys_rt_tgsigqueueinfo, sys_perf_event_open, compat_sys_recvmmsg
+	.word compat_sys_pwritev, compat_sys_rt_tgsigqueueinfo, sys_perf_event_open, compat_sys_recvmmsg, sys_setns
 
 #endif /* CONFIG_COMPAT */
 
@@ -158,4 +158,4 @@
 /*310*/	.word sys_utimensat, sys_signalfd, sys_timerfd_create, sys_eventfd, sys_fallocate
 	.word sys_timerfd_settime, sys_timerfd_gettime, sys_signalfd4, sys_eventfd2, sys_epoll_create1
 /*320*/	.word sys_dup3, sys_pipe2, sys_inotify_init1, sys_accept4, sys_preadv
-	.word sys_pwritev, sys_rt_tgsigqueueinfo, sys_perf_event_open, sys_recvmmsg
+	.word sys_pwritev, sys_rt_tgsigqueueinfo, sys_perf_event_open, sys_recvmmsg, sys_setns
Index: linux-2.6.35/arch/um/drivers/mconsole_kern.c
===================================================================
--- linux-2.6.35.orig/arch/um/drivers/mconsole_kern.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/um/drivers/mconsole_kern.c	2010-08-03 16:40:55.624923258 -0700
@@ -125,7 +125,7 @@
 void mconsole_proc(struct mc_request *req)
 {
 	struct nameidata nd;
-	struct vfsmount *mnt = current->nsproxy->pid_ns->proc_mnt;
+	struct vfsmount *mnt = task_active_pid_ns(current)->proc_mnt;
 	struct file *file;
 	int n, err;
 	char *ptr = req->request.data, *buf;
Index: linux-2.6.35/arch/x86/ia32/ia32entry.S
===================================================================
--- linux-2.6.35.orig/arch/x86/ia32/ia32entry.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/x86/ia32/ia32entry.S	2010-08-03 16:40:55.624923258 -0700
@@ -842,4 +842,5 @@
 	.quad compat_sys_rt_tgsigqueueinfo	/* 335 */
 	.quad sys_perf_event_open
 	.quad compat_sys_recvmmsg
+	.quad sys_setns
 ia32_syscall_end:
Index: linux-2.6.35/arch/x86/include/asm/unistd_32.h
===================================================================
--- linux-2.6.35.orig/arch/x86/include/asm/unistd_32.h	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/x86/include/asm/unistd_32.h	2010-08-03 16:40:55.624923258 -0700
@@ -343,10 +343,11 @@
 #define __NR_rt_tgsigqueueinfo	335
 #define __NR_perf_event_open	336
 #define __NR_recvmmsg		337
+#define __NR_setns		338
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 338
+#define NR_syscalls 339
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
Index: linux-2.6.35/arch/x86/include/asm/unistd_64.h
===================================================================
--- linux-2.6.35.orig/arch/x86/include/asm/unistd_64.h	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/x86/include/asm/unistd_64.h	2010-08-03 16:40:55.624923258 -0700
@@ -663,6 +663,8 @@
 __SYSCALL(__NR_perf_event_open, sys_perf_event_open)
 #define __NR_recvmmsg				299
 __SYSCALL(__NR_recvmmsg, sys_recvmmsg)
+#define __NR_setns				300
+__SYSCALL(__NR_setns, sys_setns)
 
 #ifndef __NO_STUBS
 #define __ARCH_WANT_OLD_READDIR
Index: linux-2.6.35/arch/x86/kernel/syscall_table_32.S
===================================================================
--- linux-2.6.35.orig/arch/x86/kernel/syscall_table_32.S	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/x86/kernel/syscall_table_32.S	2010-08-03 16:40:55.624923258 -0700
@@ -337,3 +337,4 @@
 	.long sys_rt_tgsigqueueinfo	/* 335 */
 	.long sys_perf_event_open
 	.long sys_recvmmsg
+	.long sys_setns
Index: linux-2.6.35/arch/xtensa/include/asm/unistd.h
===================================================================
--- linux-2.6.35.orig/arch/xtensa/include/asm/unistd.h	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/arch/xtensa/include/asm/unistd.h	2010-08-03 16:40:55.624923258 -0700
@@ -683,8 +683,10 @@
 __SYSCALL(306, sys_eventfd, 1)
 #define __NR_recvmmsg				307
 __SYSCALL(307, sys_recvmmsg, 5)
+#define __NR_setns				308
+__SYSCALL(307, sys_setns, 2)
 
-#define __NR_syscall_count			308
+#define __NR_syscall_count			309
 
 /*
  * sysxtensa syscall handler
Index: linux-2.6.35/fs/namespace.c
===================================================================
--- linux-2.6.35.orig/fs/namespace.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/fs/namespace.c	2010-08-03 16:40:55.637625497 -0700
@@ -29,6 +29,7 @@
 #include <linux/log2.h>
 #include <linux/idr.h>
 #include <linux/fs_struct.h>
+#include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include "pnode.h"
@@ -2351,3 +2352,59 @@
 	kfree(ns);
 }
 EXPORT_SYMBOL(put_mnt_ns);
+
+
+static void *mntns_get(struct task_struct *task)
+{
+	struct mnt_namespace *ns;
+	rcu_read_lock();
+	ns = task->nsproxy->mnt_ns;
+	get_mnt_ns(ns);
+	rcu_read_unlock();
+	return ns;
+}
+
+static void mntns_put(void *ns)
+{
+	put_mnt_ns(ns);
+}
+
+static int mntns_install(struct nsproxy *nsproxy, void *ns)
+{
+	struct fs_struct *fs = current->fs;
+	struct mnt_namespace *mnt_ns = ns;
+	struct path root;
+
+	if (fs->users != 1)
+		return -EINVAL;
+
+	get_mnt_ns(mnt_ns);
+	put_mnt_ns(nsproxy->mnt_ns);
+	nsproxy->mnt_ns = mnt_ns;
+
+	/* Find the root */
+	root.mnt    = mnt_ns->root;
+	root.dentry = mnt_ns->root->mnt_root;
+	path_get(&root);
+	while(d_mountpoint(root.dentry) && follow_down(&root))
+		;
+
+	/* Update the pwd and root */
+	path_get(&root);
+	path_get(&root);
+	path_put(&fs->root);
+	path_put(&fs->pwd);
+	fs->root = root;
+	fs->pwd  = root;
+	path_put(&root);
+
+	return 0;
+}
+
+const struct proc_ns_operations mntns_operations = {
+	.name		= PROC_NSNAME("mnt"),
+	.get		= mntns_get,
+	.put		= mntns_put,
+	.install	= mntns_install,
+};
+
Index: linux-2.6.35/fs/proc/Makefile
===================================================================
--- linux-2.6.35.orig/fs/proc/Makefile	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/fs/proc/Makefile	2010-08-03 16:40:55.637625497 -0700
@@ -19,6 +19,7 @@
 proc-y	+= uptime.o
 proc-y	+= version.o
 proc-y	+= softirqs.o
+proc-y  += namespaces.o
 proc-$(CONFIG_PROC_SYSCTL)	+= proc_sysctl.o
 proc-$(CONFIG_NET)		+= proc_net.o
 proc-$(CONFIG_PROC_KCORE)	+= kcore.o
Index: linux-2.6.35/fs/proc/base.c
===================================================================
--- linux-2.6.35.orig/fs/proc/base.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/fs/proc/base.c	2010-08-03 16:40:55.637625497 -0700
@@ -552,7 +552,7 @@
 	return allowed;
 }
 
-static int proc_setattr(struct dentry *dentry, struct iattr *attr)
+int proc_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int error;
 	struct inode *inode = dentry->d_inode;
@@ -1485,8 +1485,7 @@
 	return 0;
 }
 
-
-static struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)
+struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)
 {
 	struct inode * inode;
 	struct proc_inode *ei;
@@ -1527,7 +1526,7 @@
 	return NULL;
 }
 
-static int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task;
@@ -1568,7 +1567,7 @@
  * made this apply to all per process world readable and executable
  * directories.
  */
-static int pid_revalidate(struct dentry *dentry, struct nameidata *nd)
+int pid_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task = get_proc_task(inode);
@@ -1604,7 +1603,7 @@
 	return !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;
 }
 
-static const struct dentry_operations pid_dentry_operations =
+const struct dentry_operations pid_dentry_operations =
 {
 	.d_revalidate	= pid_revalidate,
 	.d_delete	= pid_delete_dentry,
@@ -1612,9 +1611,6 @@
 
 /* Lookups */
 
-typedef struct dentry *instantiate_t(struct inode *, struct dentry *,
-				struct task_struct *, const void *);
-
 /*
  * Fill a directory entry.
  *
@@ -1627,8 +1623,8 @@
  * reported by readdir in sync with the inode numbers reported
  * by stat.
  */
-static int proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
-	char *name, int len,
+int proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+	const char *name, int len,
 	instantiate_t instantiate, struct task_struct *task, const void *ptr)
 {
 	struct dentry *child, *dir = filp->f_path.dentry;
@@ -2260,6 +2256,8 @@
 
 #endif
 
+
+
 #ifdef CONFIG_ELF_CORE
 static ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,
 					 size_t count, loff_t *ppos)
@@ -2568,6 +2566,7 @@
 	DIR("task",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),
 	DIR("fd",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),
 	DIR("fdinfo",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),
+	DIR("ns",	  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),
 #ifdef CONFIG_NET
 	DIR("net",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),
 #endif
@@ -2906,6 +2905,7 @@
 static const struct pid_entry tid_base_stuff[] = {
 	DIR("fd",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),
 	DIR("fdinfo",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),
+	DIR("ns",	 S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),
 	REG("environ",   S_IRUSR, proc_environ_operations),
 	INF("auxv",      S_IRUSR, proc_pid_auxv),
 	ONE("status",    S_IRUGO, proc_pid_status),
Index: linux-2.6.35/fs/proc/inode.c
===================================================================
--- linux-2.6.35.orig/fs/proc/inode.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/fs/proc/inode.c	2010-08-03 16:40:55.637625497 -0700
@@ -28,6 +28,7 @@
 static void proc_delete_inode(struct inode *inode)
 {
 	struct proc_dir_entry *de;
+	const struct proc_ns_operations *ns_ops;
 
 	truncate_inode_pages(&inode->i_data, 0);
 
@@ -40,6 +41,10 @@
 		pde_put(de);
 	if (PROC_I(inode)->sysctl)
 		sysctl_head_put(PROC_I(inode)->sysctl);
+	/* Release any associated namespace */
+	ns_ops = PROC_I(inode)->ns_ops;
+	if (ns_ops && ns_ops->put)
+		ns_ops->put(PROC_I(inode)->ns);
 	clear_inode(inode);
 }
 
@@ -61,6 +66,8 @@
 	ei->pde = NULL;
 	ei->sysctl = NULL;
 	ei->sysctl_entry = NULL;
+	ei->ns = NULL;
+	ei->ns_ops = NULL;
 	inode = &ei->vfs_inode;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	return inode;
Index: linux-2.6.35/fs/proc/internal.h
===================================================================
--- linux-2.6.35.orig/fs/proc/internal.h	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/fs/proc/internal.h	2010-08-03 16:40:55.637625497 -0700
@@ -119,3 +119,21 @@
  */
 int proc_readdir(struct file *, void *, filldir_t);
 struct dentry *proc_lookup(struct inode *, struct dentry *, struct nameidata *);
+
+
+
+/* Lookups */
+typedef struct dentry *instantiate_t(struct inode *, struct dentry *,
+				struct task_struct *, const void *);
+int proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+	const char *name, int len,
+	instantiate_t instantiate, struct task_struct *task, const void *ptr);
+int pid_revalidate(struct dentry *dentry, struct nameidata *nd);
+struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task);
+extern const struct dentry_operations pid_dentry_operations;
+int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat);
+int proc_setattr(struct dentry *dentry, struct iattr *attr);
+
+extern const struct inode_operations proc_ns_dir_inode_operations;
+extern const struct file_operations proc_ns_dir_operations;
+
Index: linux-2.6.35/fs/proc/namespaces.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.35/fs/proc/namespaces.c	2010-08-03 16:40:55.637625497 -0700
@@ -0,0 +1,196 @@
+#include <linux/proc_fs.h>
+#include <linux/nsproxy.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/fs_struct.h>
+#include <linux/mount.h>
+#include <linux/path.h>
+#include <linux/namei.h>
+#include <linux/file.h>
+#include <linux/utsname.h>
+#include <net/net_namespace.h>
+#include <linux/mnt_namespace.h>
+#include <linux/ipc_namespace.h>
+#include <linux/pid_namespace.h>
+#include "internal.h"
+
+
+static const struct proc_ns_operations *ns_entries[] = {
+#ifdef CONFIG_NET_NS
+	&netns_operations,
+#endif
+#ifdef CONFIG_PID_NS
+	&pidns_operations,
+#endif
+#ifdef CONFIG_UTS_NS
+	&utsns_operations,
+#endif
+#ifdef CONFIG_IPC_NS
+	&ipcns_operations,
+#endif
+	&mntns_operations,
+};
+
+static const struct file_operations ns_file_operations = {
+	.llseek		= no_llseek,
+};
+
+static struct dentry *proc_ns_instantiate(struct inode *dir,
+	struct dentry *dentry, struct task_struct *task, const void *ptr)
+{
+	const struct proc_ns_operations *ns_ops = ptr;
+	struct inode *inode;
+	struct proc_inode *ei;
+	struct dentry *error = ERR_PTR(-ENOENT);
+
+	inode = proc_pid_make_inode(dir->i_sb, task);
+	if (!inode)
+		goto out;
+
+	ei = PROC_I(inode);
+	inode->i_mode = S_IFREG|S_IRUSR;
+	inode->i_fop  = &ns_file_operations;
+	ei->ns_ops    = ns_ops;
+	ei->ns	      = ns_ops->get(task);
+
+	dentry->d_op = &pid_dentry_operations;
+	d_add(dentry, inode);
+	/* Close the race of the process dying before we return the dentry */
+	if (pid_revalidate(dentry, NULL))
+		error = NULL;
+out:
+	return error;
+}
+
+static int proc_ns_fill_cache(struct file *filp, void *dirent,
+	filldir_t filldir, struct task_struct *task,
+	const struct proc_ns_operations *ops)
+{
+	return proc_fill_cache(filp, dirent, filldir,
+				ops->name.name, ops->name.len,
+				proc_ns_instantiate, task, ops);
+}
+
+static int proc_ns_dir_readdir(struct file *filp, void *dirent,
+				filldir_t filldir)
+{
+	int i;
+	struct dentry *dentry = filp->f_path.dentry;
+	struct inode *inode = dentry->d_inode;
+	struct task_struct *task = get_proc_task(inode);
+	const struct proc_ns_operations **entry, **last;
+	ino_t ino;
+	int ret;
+
+	ret = -ENOENT;
+	if (!task)
+		goto out_no_task;
+
+	ret = -EPERM;
+	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+		goto out;
+
+	ret = 0;
+	i = filp->f_pos;
+	switch (i) {
+	case 0:
+		ino = inode->i_ino;
+		if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
+			goto out;
+		i++;
+		filp->f_pos++;
+		/* fall through */
+	case 1:
+		ino = parent_ino(dentry);
+		if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
+			goto out;
+		i++;
+		filp->f_pos++;
+		/* fall through */
+	default:
+		i -= 2;
+		if (i >= ARRAY_SIZE(ns_entries)) {
+			ret = 1;
+			goto out;
+		}
+		entry = ns_entries + i;
+		last = &ns_entries[ARRAY_SIZE(ns_entries) - 1];
+		while (entry <= last) {
+			if (proc_ns_fill_cache(filp, dirent, filldir,
+						task, *entry) < 0)
+				goto out;
+			filp->f_pos++;
+			entry++;
+		}
+	}
+
+	ret = 1;
+out:
+	put_task_struct(task);
+out_no_task:
+	return ret;
+}
+
+const struct file_operations proc_ns_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= proc_ns_dir_readdir,
+};
+
+static struct dentry *proc_ns_dir_lookup(struct inode *dir,
+				struct dentry *dentry, struct nameidata *nd)
+{
+	struct dentry *error;
+	struct task_struct *task = get_proc_task(dir);
+	const struct proc_ns_operations **entry, **last;
+	unsigned int len = dentry->d_name.len;
+
+	error = ERR_PTR(-ENOENT);
+
+	if (!task)
+		goto out_no_task;
+
+	error = ERR_PTR(-EPERM);
+	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+		goto out;
+
+	last = &ns_entries[ARRAY_SIZE(ns_entries) - 1];
+	for (entry = ns_entries; entry <= last; entry++) {
+		if ((*entry)->name.len != len)
+			continue;
+		if (!memcmp(dentry->d_name.name, (*entry)->name.name, len))
+			break;
+	}
+	if (entry > last)
+		goto out;
+
+	error = proc_ns_instantiate(dir, dentry, task, *entry);
+out:
+	put_task_struct(task);
+out_no_task:
+	return error;
+}
+
+const struct inode_operations proc_ns_dir_inode_operations = {
+	.lookup		= proc_ns_dir_lookup,
+	.getattr	= pid_getattr,
+	.setattr	= proc_setattr,
+};
+
+struct file *proc_ns_fget(int fd)
+{
+	struct file *file;
+
+	file = fget(fd);
+	if (!file)
+		return ERR_PTR(-EBADF);
+
+	if (file->f_op != &ns_file_operations)
+		goto out_invalid;
+
+	return file;
+
+out_invalid:
+	fput(file);
+	return ERR_PTR(-EINVAL);
+}
+
Index: linux-2.6.35/fs/proc/root.c
===================================================================
--- linux-2.6.35.orig/fs/proc/root.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/fs/proc/root.c	2010-08-03 16:40:55.637625497 -0700
@@ -43,21 +43,10 @@
 	struct pid_namespace *ns;
 	struct proc_inode *ei;
 
-	if (proc_mnt) {
-		/* Seed the root directory with a pid so it doesn't need
-		 * to be special in base.c.  I would do this earlier but
-		 * the only task alive when /proc is mounted the first time
-		 * is the init_task and it doesn't have any pids.
-		 */
-		ei = PROC_I(proc_mnt->mnt_sb->s_root->d_inode);
-		if (!ei->pid)
-			ei->pid = find_get_pid(1);
-	}
-
 	if (flags & MS_KERNMOUNT)
 		ns = (struct pid_namespace *)data;
 	else
-		ns = current->nsproxy->pid_ns;
+		ns = task_active_pid_ns(current);
 
 	sb = sget(fs_type, proc_test_super, proc_set_super, ns);
 	if (IS_ERR(sb))
@@ -71,17 +60,18 @@
 			return err;
 		}
 
-		ei = PROC_I(sb->s_root->d_inode);
-		if (!ei->pid) {
-			rcu_read_lock();
-			ei->pid = get_pid(find_pid_ns(1, ns));
-			rcu_read_unlock();
-		}
-
 		sb->s_flags |= MS_ACTIVE;
 		ns->proc_mnt = mnt;
 	}
 
+	/* Ensure the root directory has it's associated pid. */
+	ei = PROC_I(sb->s_root->d_inode);
+	if (!ei->pid) {
+		rcu_read_lock();
+		ei->pid = get_pid(find_pid_ns(1, ns));
+		rcu_read_unlock();
+	}
+
 	simple_set_mnt(mnt, sb);
 	return 0;
 }
Index: linux-2.6.35/include/linux/pid_namespace.h
===================================================================
--- linux-2.6.35.orig/include/linux/pid_namespace.h	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/include/linux/pid_namespace.h	2010-08-03 16:40:55.637625497 -0700
@@ -20,6 +20,7 @@
 	struct kref kref;
 	struct pidmap pidmap[PIDMAP_ENTRIES];
 	int last_pid;
+	atomic_t dead;
 	struct task_struct *child_reaper;
 	struct kmem_cache *pid_cachep;
 	unsigned int level;
@@ -42,7 +43,8 @@
 	return ns;
 }
 
-extern struct pid_namespace *copy_pid_ns(unsigned long flags, struct pid_namespace *ns);
+extern struct pid_namespace *copy_pid_ns(unsigned long flags,
+	struct pid_namespace *default_ns, struct pid_namespace *active_ns);
 extern void free_pid_ns(struct kref *kref);
 extern void zap_pid_ns_processes(struct pid_namespace *pid_ns);
 
@@ -60,12 +62,12 @@
 	return ns;
 }
 
-static inline struct pid_namespace *
-copy_pid_ns(unsigned long flags, struct pid_namespace *ns)
+static inline struct pid_namespace *copy_pid_ns(unsigned long flags,
+	struct pid_namespace *default_ns, struct pid_namespace *active_ns)
 {
 	if (flags & CLONE_NEWPID)
-		ns = ERR_PTR(-EINVAL);
-	return ns;
+		return ERR_PTR(-EINVAL);
+	return default_ns;
 }
 
 static inline void put_pid_ns(struct pid_namespace *ns)
Index: linux-2.6.35/include/linux/proc_fs.h
===================================================================
--- linux-2.6.35.orig/include/linux/proc_fs.h	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/include/linux/proc_fs.h	2010-08-03 16:40:55.637625497 -0700
@@ -250,6 +250,25 @@
 extern void kclist_add(struct kcore_list *, void *, size_t, int type);
 #endif
 
+struct nsproxy;
+struct proc_ns_operations {
+	struct {
+		unsigned int len;
+		const char *name;
+	} name;
+	unsigned int name_len;
+	void *(*get)(struct task_struct *task);
+	void (*put)(void *ns);
+	int (*install)(struct nsproxy *nsproxy, void *ns);
+};
+#define PROC_NSNAME(NAME) { .name = (NAME), .len = (sizeof(NAME) - 1), }
+extern const struct proc_ns_operations netns_operations;
+extern const struct proc_ns_operations pidns_operations;
+extern const struct proc_ns_operations utsns_operations;
+extern const struct proc_ns_operations ipcns_operations;
+extern const struct proc_ns_operations mntns_operations;
+extern struct file *proc_ns_fget(int fd);
+
 union proc_op {
 	int (*proc_get_link)(struct inode *, struct path *);
 	int (*proc_read)(struct task_struct *task, char *page);
@@ -268,6 +287,8 @@
 	struct proc_dir_entry *pde;
 	struct ctl_table_header *sysctl;
 	struct ctl_table *sysctl_entry;
+	void *ns;
+	const struct proc_ns_operations *ns_ops;
 	struct inode vfs_inode;
 };
 
Index: linux-2.6.35/init/main.c
===================================================================
--- linux-2.6.35.orig/init/main.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/init/main.c	2010-08-03 16:40:55.637625497 -0700
@@ -879,15 +879,6 @@
 	 * init can run on any cpu.
 	 */
 	set_cpus_allowed_ptr(current, cpu_all_mask);
-	/*
-	 * Tell the world that we're going to be the grim
-	 * reaper of innocent orphaned children.
-	 *
-	 * We don't want people to have to make incorrect
-	 * assumptions about where in the task array this
-	 * can be found.
-	 */
-	init_pid_ns.child_reaper = current;
 
 	cad_pid = task_pid(current);
 
Index: linux-2.6.35/ipc/namespace.c
===================================================================
--- linux-2.6.35.orig/ipc/namespace.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/ipc/namespace.c	2010-08-03 16:40:55.637625497 -0700
@@ -11,6 +11,7 @@
 #include <linux/slab.h>
 #include <linux/fs.h>
 #include <linux/mount.h>
+#include <linux/proc_fs.h>
 
 #include "util.h"
 
@@ -132,3 +133,33 @@
 		free_ipc_ns(ns);
 	}
 }
+
+static void *ipcns_get(struct task_struct *task)
+{
+	struct ipc_namespace *ns;
+	rcu_read_lock();
+	ns = get_ipc_ns(task->nsproxy->ipc_ns);
+	rcu_read_unlock();
+	return ns;
+}
+
+static void ipcns_put(void *ns)
+{
+	return put_ipc_ns(ns);
+}
+
+static int ipcns_install(struct nsproxy *nsproxy, void *ns)
+{
+	/* Ditch state from the old ipc namespace */
+	exit_sem(current);
+	put_ipc_ns(nsproxy->ipc_ns);
+	nsproxy->ipc_ns = get_ipc_ns(ns);
+	return 0;
+}
+
+const struct proc_ns_operations ipcns_operations = {
+	.name		= PROC_NSNAME("ipc"),
+	.get		= ipcns_get,
+	.put		= ipcns_put,
+	.install	= ipcns_install,
+};
Index: linux-2.6.35/kernel/cgroup.c
===================================================================
--- linux-2.6.35.orig/kernel/cgroup.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/cgroup.c	2010-08-03 16:40:55.637625497 -0700
@@ -2650,7 +2650,7 @@
 {
 	struct cgroup_pidlist *l;
 	/* don't need task_nsproxy() if we're looking at ourself */
-	struct pid_namespace *ns = current->nsproxy->pid_ns;
+	struct pid_namespace *ns = task_active_pid_ns(current);
 
 	/*
 	 * We can't drop the pidlist_mutex before taking the l->mutex in case
Index: linux-2.6.35/kernel/fork.c
===================================================================
--- linux-2.6.35.orig/kernel/fork.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/fork.c	2010-08-03 16:40:55.644559010 -0700
@@ -1154,12 +1154,6 @@
 		pid = alloc_pid(p->nsproxy->pid_ns);
 		if (!pid)
 			goto bad_fork_cleanup_io;
-
-		if (clone_flags & CLONE_NEWPID) {
-			retval = pid_ns_prepare_proc(p->nsproxy->pid_ns);
-			if (retval < 0)
-				goto bad_fork_free_pid;
-		}
 	}
 
 	p->pid = pid_nr(pid);
@@ -1263,7 +1257,7 @@
 		tracehook_finish_clone(p, clone_flags, trace);
 
 		if (thread_group_leader(p)) {
-			if (clone_flags & CLONE_NEWPID)
+			if (pid->numbers[pid->level].nr == 1)
 				p->nsproxy->pid_ns->child_reaper = p;
 
 			p->signal->leader_pid = pid;
@@ -1634,7 +1628,8 @@
 	err = -EINVAL;
 	if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|
 				CLONE_VM|CLONE_FILES|CLONE_SYSVSEM|
-				CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET))
+				CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|
+				CLONE_NEWPID))
 		goto bad_unshare_out;
 
 	/*
Index: linux-2.6.35/kernel/nsproxy.c
===================================================================
--- linux-2.6.35.orig/kernel/nsproxy.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/nsproxy.c	2010-08-03 16:40:55.644559010 -0700
@@ -22,6 +22,9 @@
 #include <linux/pid_namespace.h>
 #include <net/net_namespace.h>
 #include <linux/ipc_namespace.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+#include <linux/syscalls.h>
 
 static struct kmem_cache *nsproxy_cachep;
 
@@ -81,7 +84,8 @@
 		goto out_ipc;
 	}
 
-	new_nsp->pid_ns = copy_pid_ns(flags, task_active_pid_ns(tsk));
+	new_nsp->pid_ns = copy_pid_ns(flags, tsk->nsproxy->pid_ns,
+						task_active_pid_ns(tsk));
 	if (IS_ERR(new_nsp->pid_ns)) {
 		err = PTR_ERR(new_nsp->pid_ns);
 		goto out_pid;
@@ -185,7 +189,7 @@
 	int err = 0;
 
 	if (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
-			       CLONE_NEWNET)))
+			       CLONE_NEWNET | CLONE_NEWPID)))
 		return 0;
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -233,6 +237,42 @@
 	switch_task_namespaces(p, NULL);
 }
 
+SYSCALL_DEFINE2(setns, unsigned int, nstype, int, fd)
+{
+	const struct proc_ns_operations *ops;
+	struct task_struct *tsk = current;
+	struct nsproxy *new_nsproxy;
+	struct proc_inode *ei;
+	struct file *file;
+	int err;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	file = proc_ns_fget(fd);
+	if (IS_ERR(file))
+		return PTR_ERR(file);
+
+	err = -EINVAL;
+	ei = PROC_I(file->f_dentry->d_inode);
+	ops = ei->ns_ops;
+	if (nstype &&
+	    ((ops->name.len >= sizeof(nstype)) ||
+	    memcmp(&nstype, ops->name.name, ops->name.len)))
+		goto out;
+
+	new_nsproxy = create_new_namespaces(0, tsk, tsk->fs);
+	err = ops->install(new_nsproxy, ei->ns);
+	if (err) {
+		free_nsproxy(new_nsproxy);
+		goto out;
+	}
+	switch_task_namespaces(tsk, new_nsproxy);
+out:
+	fput(file);
+	return err;
+}
+
 static int __init nsproxy_cache_init(void)
 {
 	nsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC);
Index: linux-2.6.35/kernel/perf_event.c
===================================================================
--- linux-2.6.35.orig/kernel/perf_event.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/perf_event.c	2010-08-03 16:40:55.669610546 -0700
@@ -4843,7 +4843,7 @@
 
 	event->parent		= parent_event;
 
-	event->ns		= get_pid_ns(current->nsproxy->pid_ns);
+	event->ns		= get_pid_ns(task_active_pid_ns(current));
 	event->id		= atomic64_inc_return(&perf_event_id);
 
 	event->state		= PERF_EVENT_STATE_INACTIVE;
Index: linux-2.6.35/kernel/pid.c
===================================================================
--- linux-2.6.35.orig/kernel/pid.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/pid.c	2010-08-03 16:40:55.669610546 -0700
@@ -248,6 +248,10 @@
 	struct pid_namespace *tmp;
 	struct upid *upid;
 
+	pid = NULL;
+	if (atomic_read(&ns->dead))
+		goto out;
+
 	pid = kmem_cache_alloc(ns->pid_cachep, GFP_KERNEL);
 	if (!pid)
 		goto out;
@@ -305,7 +309,7 @@
 
 struct pid *find_vpid(int nr)
 {
-	return find_pid_ns(nr, current->nsproxy->pid_ns);
+	return find_pid_ns(nr, task_active_pid_ns(current));
 }
 EXPORT_SYMBOL_GPL(find_vpid);
 
@@ -387,7 +391,7 @@
 
 struct task_struct *find_task_by_vpid(pid_t vnr)
 {
-	return find_task_by_pid_ns(vnr, current->nsproxy->pid_ns);
+	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
 }
 
 struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
@@ -439,7 +443,7 @@
 
 pid_t pid_vnr(struct pid *pid)
 {
-	return pid_nr_ns(pid, current->nsproxy->pid_ns);
+	return pid_nr_ns(pid, task_active_pid_ns(current));
 }
 EXPORT_SYMBOL_GPL(pid_vnr);
 
@@ -450,7 +454,7 @@
 
 	rcu_read_lock();
 	if (!ns)
-		ns = current->nsproxy->pid_ns;
+		ns = task_active_pid_ns(current);
 	if (likely(pid_alive(task))) {
 		if (type != PIDTYPE_PID)
 			task = task->group_leader;
Index: linux-2.6.35/kernel/pid_namespace.c
===================================================================
--- linux-2.6.35.orig/kernel/pid_namespace.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/pid_namespace.c	2010-08-03 16:40:55.669610546 -0700
@@ -14,6 +14,7 @@
 #include <linux/err.h>
 #include <linux/acct.h>
 #include <linux/slab.h>
+#include <linux/proc_fs.h>
 
 #define BITS_PER_PAGE		(PAGE_SIZE*8)
 
@@ -89,6 +90,7 @@
 	kref_init(&ns->kref);
 	ns->level = level;
 	ns->parent = get_pid_ns(parent_pid_ns);
+	atomic_set(&ns->dead, 0);
 
 	set_bit(0, ns->pidmap[0].page);
 	atomic_set(&ns->pidmap[0].nr_free, BITS_PER_PAGE - 1);
@@ -96,6 +98,9 @@
 	for (i = 1; i < PIDMAP_ENTRIES; i++)
 		atomic_set(&ns->pidmap[i].nr_free, BITS_PER_PAGE);
 
+	if (pid_ns_prepare_proc(ns))
+		goto out_free_map;
+
 	return ns;
 
 out_free_map:
@@ -115,13 +120,14 @@
 	kmem_cache_free(pid_ns_cachep, ns);
 }
 
-struct pid_namespace *copy_pid_ns(unsigned long flags, struct pid_namespace *old_ns)
+struct pid_namespace *copy_pid_ns(unsigned long flags,
+	struct pid_namespace *default_ns, struct pid_namespace *active_ns)
 {
 	if (!(flags & CLONE_NEWPID))
-		return get_pid_ns(old_ns);
+		return get_pid_ns(default_ns);
 	if (flags & (CLONE_THREAD|CLONE_PARENT))
 		return ERR_PTR(-EINVAL);
-	return create_pid_namespace(old_ns);
+	return create_pid_namespace(active_ns);
 }
 
 void free_pid_ns(struct kref *kref)
@@ -157,6 +163,7 @@
 	 *
 	 */
 	read_lock(&tasklist_lock);
+	atomic_set(&pid_ns->dead, 1);
 	nr = next_pidmap(pid_ns, 1);
 	while (nr > 0) {
 		rcu_read_lock();
@@ -184,6 +191,34 @@
 	return;
 }
 
+static void *pidns_get(struct task_struct *task)
+{
+	struct pid_namespace *ns;
+	rcu_read_lock();
+	ns = get_pid_ns(task->nsproxy->pid_ns);
+	rcu_read_unlock();
+	return ns;
+}
+
+static void pidns_put(void *ns)
+{
+	put_pid_ns(ns);
+}
+
+static int pidns_install(struct nsproxy *nsproxy, void *ns)
+{
+	put_pid_ns(nsproxy->pid_ns);
+	nsproxy->pid_ns = get_pid_ns(ns);
+	return 0;
+}
+
+const struct proc_ns_operations pidns_operations = {
+	.name		= PROC_NSNAME("pid"),
+	.get		= pidns_get,
+	.put		= pidns_put,
+	.install	= pidns_install,
+};
+
 static __init int pid_namespaces_init(void)
 {
 	pid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC);
Index: linux-2.6.35/kernel/signal.c
===================================================================
--- linux-2.6.35.orig/kernel/signal.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/signal.c	2010-08-03 16:40:55.669610546 -0700
@@ -1458,16 +1458,15 @@
 	 * we are under tasklist_lock here so our parent is tied to
 	 * us and cannot exit and release its namespace.
 	 *
-	 * the only it can is to switch its nsproxy with sys_unshare,
-	 * bu uncharing pid namespaces is not allowed, so we'll always
-	 * see relevant namespace
+	 * The only it can is to switch its nsproxy with sys_unshare,
+	 * but we use the pid_namespace for task_pid which never changes.
 	 *
 	 * write_lock() currently calls preempt_disable() which is the
 	 * same as rcu_read_lock(), but according to Oleg, this is not
 	 * correct to rely on this
 	 */
 	rcu_read_lock();
-	info.si_pid = task_pid_nr_ns(tsk, tsk->parent->nsproxy->pid_ns);
+	info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));
 	info.si_uid = __task_cred(tsk)->uid;
 	rcu_read_unlock();
 
@@ -1538,7 +1537,7 @@
 	 * see comment in do_notify_parent() abot the following 3 lines
 	 */
 	rcu_read_lock();
-	info.si_pid = task_pid_nr_ns(tsk, parent->nsproxy->pid_ns);
+	info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));
 	info.si_uid = __task_cred(tsk)->uid;
 	rcu_read_unlock();
 
Index: linux-2.6.35/kernel/sysctl_binary.c
===================================================================
--- linux-2.6.35.orig/kernel/sysctl_binary.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/sysctl_binary.c	2010-08-03 16:40:55.669610546 -0700
@@ -1350,7 +1350,7 @@
 		goto out_putname;
 	}
 
-	mnt = current->nsproxy->pid_ns->proc_mnt;
+	mnt = task_active_pid_ns(current)->proc_mnt;
 	result = vfs_path_lookup(mnt->mnt_root, mnt, pathname, 0, &nd);
 	if (result)
 		goto out_putname;
Index: linux-2.6.35/kernel/utsname.c
===================================================================
--- linux-2.6.35.orig/kernel/utsname.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/kernel/utsname.c	2010-08-03 16:40:55.669610546 -0700
@@ -14,6 +14,7 @@
 #include <linux/utsname.h>
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/proc_fs.h>
 
 static struct uts_namespace *create_uts_ns(void)
 {
@@ -73,3 +74,34 @@
 	ns = container_of(kref, struct uts_namespace, kref);
 	kfree(ns);
 }
+
+static void *utsns_get(struct task_struct *task)
+{
+	struct uts_namespace *ns;
+	rcu_read_lock();
+	ns = task->nsproxy->uts_ns;
+	get_uts_ns(ns);
+	rcu_read_unlock();
+	return ns;
+}
+
+static void utsns_put(void *ns)
+{
+	put_uts_ns(ns);
+}
+
+static int utsns_install(struct nsproxy *nsproxy, void *ns)
+{
+	get_uts_ns(ns);
+	put_uts_ns(nsproxy->uts_ns);
+	nsproxy->uts_ns = ns;
+	return 0;
+}
+
+const struct proc_ns_operations utsns_operations = {
+	.name		= PROC_NSNAME("uts"),
+	.get		= utsns_get,
+	.put		= utsns_put,
+	.install	= utsns_install,
+};
+
Index: linux-2.6.35/net/core/net_namespace.c
===================================================================
--- linux-2.6.35.orig/net/core/net_namespace.c	2010-08-01 15:11:14.000000000 -0700
+++ linux-2.6.35/net/core/net_namespace.c	2010-08-03 16:40:55.669610546 -0700
@@ -571,3 +571,33 @@
 	mutex_unlock(&net_mutex);
 }
 EXPORT_SYMBOL_GPL(unregister_pernet_device);
+
+#ifdef CONFIG_NET_NS
+static void *netns_get(struct task_struct *task)
+{
+	struct net *net;
+	rcu_read_lock();
+	net = get_net(task->nsproxy->net_ns);
+	rcu_read_unlock();
+	return net;
+}
+
+static void netns_put(void *ns)
+{
+	put_net(ns);
+}
+
+static int netns_install(struct nsproxy *nsproxy, void *ns)
+{
+	put_net(nsproxy->net_ns);
+	nsproxy->net_ns = get_net(ns);
+	return 0;
+}
+
+const struct proc_ns_operations netns_operations = {
+	.name		= PROC_NSNAME("net"),
+	.get		= netns_get,
+	.put		= netns_put,
+	.install	= netns_install,
+};
+#endif
