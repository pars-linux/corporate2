diff -Nuar libarchive.orig/archive_read_support_compression_compress.c libarchive/archive_read_support_compression_compress.c
--- libarchive.orig/archive_read_support_compression_compress.c	2009-04-10 13:47:04.000000000 +0300
+++ libarchive/archive_read_support_compression_compress.c	2009-04-10 13:49:37.000000000 +0300
@@ -356,16 +356,20 @@
 	struct private_data *state = (struct private_data *)self->data;
 	int code, newcode;
 
+#ifdef DEBUG
 	static int debug_buff[1024];
 	static unsigned debug_index;
+#endif
 
 	code = newcode = getbits(self, state->bits);
 	if (code < 0)
 		return (code);
 
+#ifdef DEBUG
 	debug_buff[debug_index++] = code;
 	if (debug_index >= sizeof(debug_buff)/sizeof(debug_buff[0]))
 		debug_index = 0;
+#endif
 
 	/* If it's a reset code, reset the dictionary. */
 	if ((code == 256) && state->use_reset_code) {
diff -Nuar libarchive.orig/archive_read_support_format_tar.c libarchive/archive_read_support_format_tar.c
--- libarchive.orig/archive_read_support_format_tar.c	2009-04-10 13:47:04.000000000 +0300
+++ libarchive/archive_read_support_format_tar.c	2009-04-10 13:48:37.000000000 +0300
@@ -2268,23 +2268,39 @@
 static char *
 base64_decode(const char *s, size_t len, size_t *out_len)
 {
-	static const unsigned char digits[64] = {
-		'A','B','C','D','E','F','G','H','I','J','K','L','M','N',
-		'O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b',
-		'c','d','e','f','g','h','i','j','k','l','m','n','o','p',
-		'q','r','s','t','u','v','w','x','y','z','0','1','2','3',
-		'4','5','6','7','8','9','+','/' };
-	static unsigned char decode_table[128];
+   /* The decode_table is generated by the folloing code:
+    * ···
+    *    static const unsigned char digits[64] = {
+    *      'A','B','C','D','E','F','G','H','I','J','K','L','M','N',
+    *      'O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b',
+    *      'c','d','e','f','g','h','i','j','k','l','m','n','o','p',
+    *      'q','r','s','t','u','v','w','x','y','z','0','1','2','3',
+    *      '4','5','6','7','8','9','+','/' };
+    *    size_t i;
+    *    memset(decode_table, 0xff, sizeof(decode_table));
+    *    for (i = 0; i < sizeof(digits); i++)
+    *      decode_table[digits[i]] = i;
+    * */
+   static unsigned char decode_table[128] = {
+              0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+              0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+              0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+              0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+              0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
+              0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
+              0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+              0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
+              0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
+              0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
+              0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
+              0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
+              0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
+              0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
+              0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff};
+
 	char *out, *d;
 	const unsigned char *src = (const unsigned char *)s;
 
-	/* If the decode table is not yet initialized, prepare it. */
-	if (decode_table[digits[1]] != 1) {
-		size_t i;
-		memset(decode_table, 0xff, sizeof(decode_table));
-		for (i = 0; i < sizeof(digits); i++)
-			decode_table[digits[i]] = i;
-	}
 
 	/* Allocate enough space to hold the entire output. */
 	/* Note that we may not use all of this... */
