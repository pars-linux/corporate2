Index: phonon/gstreamer/audiooutput.cpp
===================================================================
--- phonon.orig/gstreamer/audiooutput.cpp
+++ phonon/gstreamer/audiooutput.cpp
@@ -140,7 +140,9 @@ bool AudioOutput::setOutputDevice(int ne
         // Save previous state
         GstState oldState = GST_STATE(m_audioSink);
         const QByteArray oldDeviceValue = GstHelper::property(m_audioSink, "device");
-        const QByteArray deviceId = ad->gstId;
+        const QByteArray deviceId = (ad->gstId == "PulseAudio Sound Server"
+                                     ? "default"
+                                     : ad->gstId);
         m_device = newDevice;
 
         // We test if the device can be opened by checking if it can go from NULL to READY state
Index: phonon/gstreamer/backend.cpp
===================================================================
--- phonon.orig/gstreamer/backend.cpp
+++ phonon/gstreamer/backend.cpp
@@ -300,7 +300,7 @@ QHash<QByteArray, QVariant> Backend::obj
             if ((ad = deviceManager()->audioDevice(index))) {
                 ret.insert("name", ad->gstId);
                 ret.insert("description", ad->description);
-                ret.insert("icon", QLatin1String("audio-card"));
+                ret.insert("icon", ad->icon);
             }
         }
         break;
Index: phonon/gstreamer/devicemanager.cpp
===================================================================
--- phonon.orig/gstreamer/devicemanager.cpp
+++ phonon/gstreamer/devicemanager.cpp
@@ -16,6 +16,8 @@
 */
 
 #include <gst/interfaces/propertyprobe.h>
+#include <QSettings>
+#include <QCoreApplication>
 #include "devicemanager.h"
 #include "backend.h"
 #include "gsthelper.h"
@@ -45,10 +47,16 @@ AudioDevice::AudioDevice(DeviceManager *
         : gstId(gstId)
 {
     id = manager->allocateDeviceId();
+    icon = "audio-card";
     //get name from device
     if (gstId == "default") {
         description = "Default audio device";
-    } else {
+    } else if (gstId == "PulseAudio Sound Server") {
+        // Cosmetic hack 
+        description = QObject::tr("Pass all audio through the PulseAudio Sound Server.\n\nYou can use pavucontrol to adjust which audio device(s) streams use.").toUtf8();
+        icon = "audio-backend-pulseaudio";
+    }
+    else {
         GstElement *aSink= manager->createAudioSink();
 
         if (aSink) {
@@ -77,6 +85,13 @@ DeviceManager::DeviceManager(Backend *ba
     m_audioSink = qgetenv("PHONON_GST_AUDIOSINK");
     if (m_audioSink.isEmpty()) {
         m_audioSink = settings.value(QLatin1String("audiosink"), "Auto").toByteArray().toLower();
+        // Detect Pulse according to Mandriva config system so we can apply some cosmetic hacks
+        if (m_audioSink == "auto") {
+            QSettings pulseconf("/etc/conf.d/pulseaudio", QSettings::NativeFormat);
+            if (pulseconf.value( "PULSE_SERVER_TYPE", "None" ) == "personal") {
+                m_audioSink = "pulsesink";
+            }
+        }
     }
 
     m_videoSinkWidget = qgetenv("PHONON_GST_VIDEOMODE");
@@ -313,8 +328,13 @@ void DeviceManager::updateDeviceList()
     QList<QByteArray> list;
 
     if (audioSink) {
-        list = GstHelper::extractProperties(audioSink, "device");
-        list.prepend("default");
+        if (m_audioSink == "pulsesink") {
+            // If we're using pulse, just hide all other devices.
+            list.append("PulseAudio Sound Server");
+        } else {
+            list = GstHelper::extractProperties(audioSink, "device");
+            list.prepend("default");
+        }
 
         for (int i = 0 ; i < list.size() ; ++i) {
             QByteArray gstId = list.at(i);
Index: phonon/gstreamer/devicemanager.h
===================================================================
--- phonon.orig/gstreamer/devicemanager.h
+++ phonon/gstreamer/devicemanager.h
@@ -42,6 +42,7 @@ public :
     int id;
     QByteArray gstId;
     QByteArray description;
+    QString icon;
 };
 
 class DeviceManager : public QObject {
Index: phonon/xine/backend.cpp
===================================================================
--- phonon.orig/xine/backend.cpp
+++ phonon/xine/backend.cpp
@@ -547,9 +547,11 @@ QHash<QByteArray, QVariant> Backend::aud
             ret.insert("description", that->m_audioOutputInfos[i].description);
 
             const QString iconName = that->m_audioOutputInfos[i].icon;
-            if (!iconName.isEmpty()) {
+            if (!iconName.isEmpty())
+                ret.insert("icon", iconName);
+            else
                 ret.insert("icon", QLatin1String("audio-card"));
-            }
+
             ret.insert("available", that->m_audioOutputInfos[i].available);
 
             ret.insert("initialPreference", that->m_audioOutputInfos[i].initialPreference);
@@ -609,6 +611,29 @@ void Backend::checkAudioOutputs()
 
         // This will list the audio drivers, not the actual devices.
         const char *const *outputPlugins = xine_list_audio_output_plugins(m_xine);
+
+        // Detect Pulse according to Mandriva config system so we can apply some cosmetic hacks
+        bool using_pulse = false;
+        QSettings pulseconf("/etc/conf.d/pulseaudio", QSettings::NativeFormat);
+        if (pulseconf.value( "PULSE_SERVER_TYPE", "None" ) == "personal")
+            using_pulse = true;
+
+        if (using_pulse) {
+            // Assume failure
+            using_pulse = false;
+            for (int i = 0; outputPlugins[i]; ++i) {
+                if (0 == strcmp(outputPlugins[i], "pulseaudio")) {
+                    // Yay!
+                    using_pulse = true;
+                    addAudioOutput(nextIndex++, 100, tr("PulseAudio"),
+                            xine_get_audio_driver_plugin_description(m_xine, outputPlugins[i]),
+                            /*icon name */"audio-backend-pulseaudio", outputPlugins[i]);
+                    // No need to check any more, so quit our loop.
+                    break;
+                }
+            }
+        }
+        if (!using_pulse)
         for (int i = 0; outputPlugins[i]; ++i) {
             debug() << Q_FUNC_INFO << "outputPlugin: " << outputPlugins[i];
             if (0 == strcmp(outputPlugins[i], "alsa")) {
@@ -643,14 +668,9 @@ void Backend::checkAudioOutputs()
                             "work, and its design focuses on two key areas: synchronous "
                             "execution of all clients, and low latency operation.</p></html>"),
                             /*icon name */"audio-backend-jack", outputPlugins[i]);
-            } else if (0 == strcmp(outputPlugins[i], "arts")) {
-                addAudioOutput(nextIndex++, -100, tr("aRts"),
-                        tr("<html><p>aRts is the old sound server and media framework that was used "
-                            "in KDE2 and KDE3. Its use is discouraged.</p></html>"),
-                        /*icon name */"audio-backend-arts", outputPlugins[i]);
             } else if (0 == strcmp(outputPlugins[i], "pulseaudio")) {
                 addAudioOutput(nextIndex++, 10, tr("PulseAudio"),
-                        xine_get_audio_driver_plugin_description(m_xine, outputPlugins[i]),
+                        tr("Pass all audio through the PulseAudio Sound Server.\n\nYou can use pavucontrol to adjust which audio device(s) streams use."),
                         /*icon name */"audio-backend-pulseaudio", outputPlugins[i]);
             } else if (0 == strcmp(outputPlugins[i], "esd")) {
                 addAudioOutput(nextIndex++, 8, tr("Esound (ESD)"),
