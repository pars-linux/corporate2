From 7e664dc56a1f2ce385f6f7739209ef2413974d8f Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Thu, 14 May 2009 03:52:13 +0200
Subject: [PATCH 122/127] rescue: make we don't end up in an endless loop when we can't move a sink input

---
 src/modules/module-rescue-streams.c |   38 +++++++++++++++++++---------------
 1 files changed, 21 insertions(+), 17 deletions(-)

diff --git a/src/modules/module-rescue-streams.c b/src/modules/module-rescue-streams.c
index 7c99a9b..c22711a 100644
--- a/src/modules/module-rescue-streams.c
+++ b/src/modules/module-rescue-streams.c
@@ -31,6 +31,7 @@
 #include <pulsecore/modargs.h>
 #include <pulsecore/log.h>
 #include <pulsecore/namereg.h>
+#include <pulsecore/core-util.h>
 
 #include "module-rescue-streams-symdef.h"
 
@@ -49,6 +50,7 @@ struct userdata {
 
 static pa_hook_result_t sink_hook_callback(pa_core *c, pa_sink *sink, void* userdata) {
     pa_sink_input *i;
+    uint32_t idx;
     pa_sink *target;
 
     pa_assert(c);
@@ -58,15 +60,14 @@ static pa_hook_result_t sink_hook_callback(pa_core *c, pa_sink *sink, void* user
     if (c->state == PA_CORE_SHUTDOWN)
         return PA_HOOK_OK;
 
-    if (!pa_idxset_size(sink->inputs)) {
+    if (pa_idxset_size(sink->inputs) <= 0) {
         pa_log_debug("No sink inputs to move away.");
         return PA_HOOK_OK;
     }
 
     if (!(target = pa_namereg_get(c, NULL, PA_NAMEREG_SINK)) || target == sink) {
-        uint32_t idx;
 
-        for (target = pa_idxset_first(c->sinks, &idx); target; target = pa_idxset_next(c->sinks, &idx))
+        PA_IDXSET_FOREACH(target, c->sinks, idx)
             if (target != sink)
                 break;
 
@@ -76,20 +77,24 @@ static pa_hook_result_t sink_hook_callback(pa_core *c, pa_sink *sink, void* user
         }
     }
 
-    while ((i = pa_idxset_first(sink->inputs, NULL))) {
+    pa_assert(target != sink);
+
+    PA_IDXSET_FOREACH(i, sink->inputs, idx) {
         if (pa_sink_input_move_to(i, target, FALSE) < 0)
-            pa_log_warn("Failed to move sink input %u \"%s\" to %s.", i->index, pa_proplist_gets(i->proplist, PA_PROP_APPLICATION_NAME), target->name);
+            pa_log_info("Failed to move sink input %u \"%s\" to %s.", i->index,
+                        pa_strnull(pa_proplist_gets(i->proplist, PA_PROP_APPLICATION_NAME)), target->name);
         else
-            pa_log_info("Sucessfully moved sink input %u \"%s\" to %s.", i->index, pa_proplist_gets(i->proplist, PA_PROP_APPLICATION_NAME), target->name);
+            pa_log_info("Sucessfully moved sink input %u \"%s\" to %s.", i->index,
+                        pa_strnull(pa_proplist_gets(i->proplist, PA_PROP_APPLICATION_NAME)), target->name);
     }
 
-
     return PA_HOOK_OK;
 }
 
 static pa_hook_result_t source_hook_callback(pa_core *c, pa_source *source, void* userdata) {
     pa_source_output *o;
     pa_source *target;
+    uint32_t idx;
 
     pa_assert(c);
     pa_assert(source);
@@ -98,15 +103,14 @@ static pa_hook_result_t source_hook_callback(pa_core *c, pa_source *source, void
     if (c->state == PA_CORE_SHUTDOWN)
         return PA_HOOK_OK;
 
-    if (!pa_idxset_size(source->outputs)) {
+    if (pa_idxset_size(source->outputs) <= 0) {
         pa_log_debug("No source outputs to move away.");
         return PA_HOOK_OK;
     }
 
     if (!(target = pa_namereg_get(c, NULL, PA_NAMEREG_SOURCE)) || target == source) {
-        uint32_t idx;
 
-        for (target = pa_idxset_first(c->sources, &idx); target; target = pa_idxset_next(c->sources, &idx))
+        PA_IDXSET_FOREACH(target, c->sources, idx)
             if (target != source && !target->monitor_of == !source->monitor_of)
                 break;
 
@@ -118,19 +122,20 @@ static pa_hook_result_t source_hook_callback(pa_core *c, pa_source *source, void
 
     pa_assert(target != source);
 
-    while ((o = pa_idxset_first(source->outputs, NULL))) {
+    PA_IDXSET_FOREACH(o, source->outputs, idx) {
         if (pa_source_output_move_to(o, target, FALSE) < 0)
-            pa_log_warn("Failed to move source output %u \"%s\" to %s.", o->index, pa_proplist_gets(o->proplist, PA_PROP_APPLICATION_NAME), target->name);
+            pa_log_info("Failed to move source output %u \"%s\" to %s.", o->index,
+                        pa_strnull(pa_proplist_gets(o->proplist, PA_PROP_APPLICATION_NAME)), target->name);
         else
-            pa_log_info("Sucessfully moved source output %u \"%s\" to %s.", o->index, pa_proplist_gets(o->proplist, PA_PROP_APPLICATION_NAME), target->name);
+            pa_log_info("Sucessfully moved source output %u \"%s\" to %s.", o->index,
+                        pa_strnull(pa_proplist_gets(o->proplist, PA_PROP_APPLICATION_NAME)), target->name);
     }
 
-
     return PA_HOOK_OK;
 }
 
 int pa__init(pa_module*m) {
-    pa_modargs *ma = NULL;
+    pa_modargs *ma;
     struct userdata *u;
 
     pa_assert(m);
@@ -153,10 +158,9 @@ void pa__done(pa_module*m) {
 
     pa_assert(m);
 
-    if (!m->userdata)
+    if (!(u = m->userdata))
         return;
 
-    u = m->userdata;
     if (u->sink_slot)
         pa_hook_slot_free(u->sink_slot);
     if (u->source_slot)
-- 
1.6.3

