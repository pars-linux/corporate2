From 39ddf44509cbcfea4d0a693d706514f5deaa6c75 Mon Sep 17 00:00:00 2001
From: ander <ander@localhost.(none)>
Date: Mon, 22 Jun 2009 14:10:17 -0300
Subject: [PATCH 1/2] Driver changes sent by clevo

---
 src/300vtbl.h       |   20 +-
 src/310vtbl.h       |  124 +-
 src/Makefile.am     |    6 +
 src/init.c          |  230 +-
 src/init.h          |   69 +-
 src/init301.c       | 1001 +++-
 src/init301.h       |    9 +-
 src/initdef.h       |   36 +-
 src/initextx.c      |  150 +-
 src/initextx.h      |    3 +
 src/sis.h           |  796 ++--
 src/sis300_accel.c  |  125 +-
 src/sis300_accel.h  |  401 +-
 src/sis310_accel.c  | 1108 ++---
 src/sis310_accel.h  |  248 +-
 src/sis6326_video.c |   21 +-
 src/sis_3daccel.c   |  681 +++
 src/sis_3daccel.h   |  576 ++
 src/sis_accel.c     |   83 +-
 src/sis_config.h    |   85 +
 src/sis_cursor.c    | 1520 +++---
 src/sis_cursor.h    |    2 +-
 src/sis_dac.c       |  358 +-
 src/sis_dac.h       |    5 +-
 src/sis_dga.c       |  167 +-
 src/sis_dri.c       |  148 +-
 src/sis_dri.h       |   17 +-
 src/sis_driver.c    |14451 +++++++++++++++++++++------------------------------
 src/sis_driver.h    |  957 +---
 src/sis_hwmc.c      |  580 +++
 src/sis_memcpy.c    |   16 +-
 src/sis_mergedfb.c  | 3005 +++++++++++
 src/sis_opt.c       |  467 ++-
 src/sis_regs.h      |   24 +-
 src/sis_setup.c     |  388 ++-
 src/sis_shadow.c    |  193 +-
 src/sis_utility.c   |  839 +--
 src/sis_vb.c        | 2725 +++++++++-
 src/sis_vb.h        |  980 ++++
 src/sis_vga.c       |  327 +-
 src/sis_video.c     | 2294 ++++++---
 src/sis_video.h     |  261 +-
 src/sis_videostr.h  |    9 +-
 src/sispcirename.h  |  122 +
 src/vgatypes.h      |    9 +-
 src/vstruct.h       |   11 +
 46 files changed, 21160 insertions(+), 14487 deletions(-)
 create mode 100644 src/sis_3daccel.c
 create mode 100644 src/sis_3daccel.h
 create mode 100644 src/sis_config.h
 create mode 100644 src/sis_hwmc.c
 create mode 100644 src/sis_mergedfb.c
 create mode 100644 src/sis_vb.h
 create mode 100644 src/sispcirename.h

diff --git a/src/300vtbl.h b/src/300vtbl.h
index 356d04c..ea1cd68 100644
--- a/src/300vtbl.h
+++ b/src/300vtbl.h
@@ -189,10 +189,10 @@ static const struct SiS_Ext2 SiS300_RefIndex[] =
 	{0x0027,0x45,0x3c,0x08,0x0a,0x6e,1280, 960, 0, 0x00, 0x00}, /* 2a - 1280x960-85 */
 	{0xc077,0x33,0x09,0x06,0x00,0x20,1024, 600, 0, 0x00, 0x00}, /* 2b */
 	{0xc077,0x34,0x0b,0x06,0x00,0x23,1152, 768, 0, 0x00, 0x00}, /* 2c */	/* VCLK 0x09 */
-	{0x0077,0x35,0x27,0x08,0x18,0x70, 800, 480, 0, 0x00, 0x00}, /* 2d */
+	{0x007f,0x35,0x27,0x08,0x18,0x70, 800, 480, 0, 0x00, 0x00}, /* 2d */
 	{0x0047,0x36,0x37,0x08,0x18,0x70, 800, 480, 0, 0x00, 0x00}, /* 2e */
 	{0x0047,0x37,0x08,0x08,0x18,0x70, 800, 480, 0, 0x00, 0x00}, /* 2f */
-	{0x0077,0x38,0x09,0x09,0x19,0x71,1024, 576, 0, 0x00, 0x00}, /* 30 */
+	{0x0877,0x38,0x09,0x09,0x19,0x71,1024, 576, 0, 0x00, 0x00}, /* 30 */
 	{0x0047,0x39,0x38,0x09,0x19,0x71,1024, 576, 0, 0x00, 0x00}, /* 31 */
 	{0x0047,0x3a,0x11,0x09,0x19,0x71,1024, 576, 0, 0x00, 0x00}, /* 32 */
 	{0x0077,0x3b,0x39,0x0a,0x0c,0x75,1280, 720, 0, 0x00, 0x00}, /* 33 */
@@ -201,11 +201,11 @@ static const struct SiS_Ext2 SiS300_RefIndex[] =
 	{0x0067,0x49,0x35,0x06,0x1a,0x29,1152, 864, 0, 0x00, 0x00}, /* 36 1152x864-60Hz  */
 	{0x0067,0x3e,0x34,0x06,0x1a,0x29,1152, 864, 0, 0x00, 0x00}, /* 37 1152x864-75Hz */
 	{0x0047,0x44,0x3a,0x06,0x1a,0x29,1152, 864, 0, 0x00, 0x00}, /* 38 1152x864-85Hz */
-	{0x00c7,0x3f,0x28,0x00,0x16,0x39, 848, 480, 0, 0x00, 0x00}, /* 39 848x480-38Hzi */
-	{0xc067,0x40,0x3d,0x0b,0x16,0x39, 848, 480, 0, 0x00, 0x00}, /* 3a 848x480-60Hz  */
-	{0x00c7,0x41,0x28,0x00,0x17,0x3f, 856, 480, 0, 0x00, 0x00}, /* 3b 856x480-38Hzi */
-	{0xc067,0x42,0x28,0x0c,0x17,0x3f, 856, 480, 0, 0x00, 0x00}, /* 3c 856x480-60Hz  */
-	{0x0067,0x43,0x3e,0x0d,0x1b,0x48,1360, 768, 0, 0x00, 0x00}, /* 3d 1360x768-60Hz */
+	{0x0087,0x3f,0x28,0x00,0x16,0x39, 848, 480, 0, 0x00, 0x00}, /* 39 848x480-38Hzi */
+	{0xc877,0x40,0x3d,0x0e,0x16,0x39, 848, 480, 0, 0x00, 0x00}, /* 3a 848x480-60Hz  */
+	{0x0087,0x41,0x28,0x00,0x17,0x3f, 856, 480, 0, 0x00, 0x00}, /* 3b 856x480-38Hzi */
+	{0xc877,0x42,0x28,0x0f,0x17,0x3f, 856, 480, 0, 0x00, 0x00}, /* 3c 856x480-60Hz  */
+	{0x0067,0x43,0x3e,0x10,0x1b,0x48,1360, 768, 0, 0x00, 0x00}, /* 3d 1360x768-60Hz */
 	{0x0077,0x46,0x3f,0x08,0x08,0x55,1280, 768, 0, 0x00, 0x00}, /* 3e 1280x768-60Hz */
 	{0x006f,0x47,0x4c,0x06,0x15,0x5f, 768, 576, 0, 0x00, 0x00}, /* 3f 768x576 */
 	{0x0027,0x48,0x13,0x08,0x00,0x67,1360,1024, 0, 0x00, 0x00}, /* 40 1360x1024-59Hz (BARCO1366 only) */
@@ -789,6 +789,9 @@ static const struct SiS_LVDSData SiS300_LVDS848x480Data_1[]=
 	{   0,   0,   0,   0},
 	{   0,   0,   0,   0},
 	{   0,   0,   0,   0},
+	{   0,   0,   0,   0},
+	{   0,   0,   0,   0},
+	{   0,   0,   0,   0},
 	{1088, 525,1088, 525},  /* 848x480 */
 	{1088, 525,1088, 525},  /* 856x480 */
 	{1088, 525,1088, 525}   /* 1360x768 TODO */
@@ -808,6 +811,9 @@ static const struct SiS_LVDSData SiS300_LVDS848x480Data_2[]=
 	{   0,   0,   0,   0},
 	{   0,   0,   0,   0},
 	{   0,   0,   0,   0},
+	{   0,   0,   0,   0},
+	{   0,   0,   0,   0},
+	{   0,   0,   0,   0},
 	{1088, 525,1088, 525},  /* 848x480 */
 	{1088, 525,1088, 525},  /* 856x480 */
 	{1088, 525,1088, 525}	/* 1360x768 TODO */
diff --git a/src/310vtbl.h b/src/310vtbl.h
index d2220ed..6b84079 100644
--- a/src/310vtbl.h
+++ b/src/310vtbl.h
@@ -52,7 +52,7 @@
 
 static const struct SiS_Ext SiS310_EModeIDTable[] =
 {
-	{0x6a,0x2212,0x0102,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3}, /* 800x600x? */
+	{0x6a,0x2212,0x0102,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3}, /* 800x600x4    */     /*0x00*/
 	{0x2e,0x0a1b,0x0101,SIS_RI_640x480,  0x00,0x00,0x05,0x05,0x08, 2}, /* 640x480x8 */
 	{0x2f,0x0a1b,0x0100,SIS_RI_640x400,  0x00,0x00,0x05,0x05,0x10, 0}, /* 640x400x8 */
 	{0x30,0x2a1b,0x0103,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3}, /* 800x600x8 */
@@ -62,21 +62,21 @@ static const struct SiS_Ext SiS310_EModeIDTable[] =
 	{0x34,0x6a1d,0x0000,SIS_RI_720x576,  0x00,0x00,0x06,0x06,0x12,-1}, /* 720x576x16 */
 	{0x35,0x4a1f,0x0000,SIS_RI_720x480,  0x00,0x00,0x06,0x06,0x11,-1}, /* 720x480x32 */
 	{0x36,0x6a1f,0x0000,SIS_RI_720x576,  0x00,0x00,0x06,0x06,0x12,-1}, /* 720x576x32 */
-	{0x37,0x0212,0x0104,SIS_RI_1024x768, 0x00,0x00,0x08,0x07,0x13, 4}, /* 1024x768x? */
+	{0x37,0x0212,0x0104,SIS_RI_1024x768, 0x00,0x00,0x08,0x07,0x13, 4}, /* 1024x768x4 */
 	{0x38,0x0a1b,0x0105,SIS_RI_1024x768, 0x00,0x00,0x08,0x07,0x13, 4}, /* 1024x768x8 */
-	{0x3a,0x0e3b,0x0107,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 8}, /* 1280x1024x8 */
-	{0x3c,0x0e3b,0x0130,SIS_RI_1600x1200,0x00,0x00,0x00,0x00,0x1e,10}, /* 1600x1200x8 */
-	{0x3d,0x0e7d,0x0131,SIS_RI_1600x1200,0x00,0x00,0x00,0x00,0x1e,10}, /* 1600x1200x16 */
+	{0x3a,0x0e3b,0x0107,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 9}, /* 1280x1024x8 */
+	{0x3c,0x0e3b,0x0130,SIS_RI_1600x1200,0x00,0x00,0x00,0x00,0x1e,12}, /* 1600x1200x8 */
+	{0x3d,0x0e7d,0x0131,SIS_RI_1600x1200,0x00,0x00,0x00,0x00,0x1e,12}, /* 1600x1200x16 */
 	{0x40,0x9a1c,0x010d,SIS_RI_320x200,  0x00,0x00,0x04,0x04,0x25, 0}, /* 320x200x15 */
-	{0x41,0x9a1d,0x010e,SIS_RI_320x200,  0x00,0x00,0x04,0x04,0x25, 0}, /* 320x200x16 */
-	{0x43,0x0a1c,0x0110,SIS_RI_640x480,  0x00,0x00,0x05,0x05,0x08, 2},
+	{0x41,0x9a1d,0x010e,SIS_RI_320x200,  0x00,0x00,0x04,0x04,0x25, 0}, /* 320x200x16 */       /*0x10*/
+	{0x43,0x0a1c,0x0110,SIS_RI_640x480,  0x00,0x00,0x05,0x05,0x08, 2}, /* 640x480x15 */
 	{0x44,0x0a1d,0x0111,SIS_RI_640x480,  0x00,0x00,0x05,0x05,0x08, 2}, /* 640x480x16 */
-	{0x46,0x2a1c,0x0113,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3},
+	{0x46,0x2a1c,0x0113,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3}, /* 800x600x15 */
 	{0x47,0x2a1d,0x0114,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3}, /* 800x600x16 */
-	{0x49,0x0a3c,0x0116,SIS_RI_1024x768, 0x00,0x00,0x00,0x07,0x13, 4},
+	{0x49,0x0a3c,0x0116,SIS_RI_1024x768, 0x00,0x00,0x00,0x07,0x13, 4}, /* 1024x768x15 */
 	{0x4a,0x0a3d,0x0117,SIS_RI_1024x768, 0x00,0x00,0x08,0x07,0x13, 4}, /* 1024x768x16 */
-	{0x4c,0x0e7c,0x0119,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 8},
-	{0x4d,0x0e7d,0x011a,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 8}, /* 1280x1024x16 */
+	{0x4c,0x0e7c,0x0119,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 9}, /* 1280x1024x15 */
+	{0x4d,0x0e7d,0x011a,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 9}, /* 1280x1024x16 */
 	{0x50,0x9a1b,0x0132,SIS_RI_320x240,  0x00,0x00,0x04,0x04,0x26, 2}, /* 320x240x8  */
 	{0x51,0xba1b,0x0133,SIS_RI_400x300,  0x00,0x00,0x07,0x07,0x27, 3}, /* 400x300x8  */
 	{0x52,0xba1b,0x0134,SIS_RI_512x384,  0x00,0x00,0x00,0x00,0x28, 4}, /* 512x384x8  */
@@ -84,23 +84,23 @@ static const struct SiS_Ext SiS310_EModeIDTable[] =
 	{0x57,0xba1d,0x0136,SIS_RI_400x300,  0x00,0x00,0x07,0x07,0x27, 3}, /* 400x300x16 */
 	{0x58,0xba1d,0x0137,SIS_RI_512x384,  0x00,0x00,0x00,0x00,0x28, 4}, /* 512x384x16 */
 	{0x59,0x9a1b,0x0138,SIS_RI_320x200,  0x00,0x00,0x04,0x04,0x25, 0}, /* 320x200x8  */
-	{0x5a,0x021b,0x0138,SIS_RI_320x240,  0x00,0x00,0x00,0x00,0x3f, 2}, /* 320x240x8  fstn */
-	{0x5b,0x0a1d,0x0135,SIS_RI_320x240,  0x00,0x00,0x00,0x00,0x3f, 2}, /* 320x240x16 fstn */
+	{0x5a,0x021b,0x0138,SIS_RI_320x240,  0x00,0x00,0x00,0x00,0x3f, 2}, /* 320x240x8  fstn*/   /*0x20*/
+	{0x5b,0x0a1d,0x0135,SIS_RI_320x240,  0x00,0x00,0x00,0x00,0x3f, 2}, /* 320x240x16 fstn*/
 	{0x5c,0xba1f,0x0000,SIS_RI_512x384,  0x00,0x00,0x00,0x00,0x28, 4}, /* 512x384x32 */
-	{0x5d,0x0a1d,0x0139,SIS_RI_640x400,  0x00,0x00,0x05,0x07,0x10, 0},
+	{0x5d,0x0a1d,0x0139,SIS_RI_640x400,  0x00,0x00,0x05,0x07,0x10, 0}, /* 640x400x16 */
 	{0x5e,0x0a1f,0x0000,SIS_RI_640x400,  0x00,0x00,0x05,0x07,0x10, 0}, /* 640x400x32 */
 	{0x62,0x0a3f,0x013a,SIS_RI_640x480,  0x00,0x00,0x05,0x05,0x08, 2}, /* 640x480x32 */
 	{0x63,0x2a3f,0x013b,SIS_RI_800x600,  0x00,0x00,0x07,0x06,0x00, 3}, /* 800x600x32 */
 	{0x64,0x0a7f,0x013c,SIS_RI_1024x768, 0x00,0x00,0x08,0x07,0x13, 4}, /* 1024x768x32 */
-	{0x65,0x0eff,0x013d,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 8}, /* 1280x1024x32 */
-	{0x66,0x0eff,0x013e,SIS_RI_1600x1200,0x00,0x00,0x00,0x00,0x1e,10}, /* 1600x1200x32 */
+	{0x65,0x0eff,0x013d,SIS_RI_1280x1024,0x00,0x00,0x00,0x00,0x1a, 9}, /* 1280x1024x32 */
+	{0x66,0x0eff,0x013e,SIS_RI_1600x1200,0x00,0x00,0x00,0x00,0x1e,12}, /* 1600x1200x32 */
 	{0x68,0x067b,0x013f,SIS_RI_1920x1440,0x00,0x00,0x00,0x00,0x29,-1}, /* 1920x1440x8 */
 	{0x69,0x06fd,0x0140,SIS_RI_1920x1440,0x00,0x00,0x00,0x00,0x29,-1}, /* 1920x1440x16 */
 	{0x6b,0x07ff,0x0141,SIS_RI_1920x1440,0x00,0x00,0x00,0x00,0x29,-1}, /* 1920x1440x32 */
 	{0x6c,0x067b,0x0000,SIS_RI_2048x1536,0x00,0x00,0x00,0x00,0x2f,-1}, /* 2048x1536x8 */
 	{0x6d,0x06fd,0x0000,SIS_RI_2048x1536,0x00,0x00,0x00,0x00,0x2f,-1}, /* 2048x1536x16 */
 	{0x6e,0x07ff,0x0000,SIS_RI_2048x1536,0x00,0x00,0x00,0x00,0x2f,-1}, /* 2048x1536x32 */
-	{0x70,0x6a1b,0x0000,SIS_RI_800x480,  0x00,0x00,0x07,0x07,0x34,-1}, /* 800x480x8 */
+	{0x70,0x6a1b,0x0000,SIS_RI_800x480,  0x00,0x00,0x07,0x07,0x34,-1}, /* 800x480x8   */        /*0x30*/
 	{0x71,0x4a1b,0x0000,SIS_RI_1024x576, 0x00,0x00,0x00,0x00,0x37,-1}, /* 1024x576x8 */
 	{0x74,0x4a1d,0x0000,SIS_RI_1024x576, 0x00,0x00,0x00,0x00,0x37,-1}, /* 1024x576x16 */
 	{0x75,0x0a3d,0x0000,SIS_RI_1280x720, 0x00,0x00,0x00,0x00,0x3a, 5}, /* 1280x720x16 */
@@ -115,9 +115,9 @@ static const struct SiS_Ext SiS310_EModeIDTable[] =
 	{0x23,0x0e3b,0x0000,SIS_RI_1280x768, 0x00,0x00,0x00,0x00,0x40, 6}, /* 1280x768x8 */
 	{0x24,0x0e7d,0x0000,SIS_RI_1280x768, 0x00,0x00,0x00,0x00,0x40, 6}, /* 1280x768x16 */
 	{0x25,0x0eff,0x0000,SIS_RI_1280x768, 0x00,0x00,0x00,0x00,0x40, 6}, /* 1280x768x32 */
-	{0x26,0x0e3b,0x0000,SIS_RI_1400x1050,0x00,0x00,0x00,0x00,0x43, 9}, /* 1400x1050x8 */
-	{0x27,0x0e7d,0x0000,SIS_RI_1400x1050,0x00,0x00,0x00,0x00,0x43, 9}, /* 1400x1050x16 */
-	{0x28,0x0eff,0x0000,SIS_RI_1400x1050,0x00,0x00,0x00,0x00,0x43, 9}, /* 1400x1050x32*/
+	{0x26,0x0e3b,0x0000,SIS_RI_1400x1050,0x00,0x00,0x00,0x00,0x43, 10}, /* 1400x1050x8 */
+	{0x27,0x0e7d,0x0000,SIS_RI_1400x1050,0x00,0x00,0x00,0x00,0x43, 10}, /* 1400x1050x16 */      /*0x40*/
+	{0x28,0x0eff,0x0000,SIS_RI_1400x1050,0x00,0x00,0x00,0x00,0x43, 10}, /* 1400x1050x32*/
 	{0x29,0x4e1b,0x0000,SIS_RI_1152x864, 0x00,0x00,0x00,0x00,0x45,-1}, /* 1152x864 */
 	{0x2a,0x4e3d,0x0000,SIS_RI_1152x864, 0x00,0x00,0x00,0x00,0x45,-1},
 	{0x2b,0x4e7f,0x0000,SIS_RI_1152x864, 0x00,0x00,0x00,0x00,0x45,-1},
@@ -132,29 +132,38 @@ static const struct SiS_Ext SiS310_EModeIDTable[] =
 	{0x4e,0x6aff,0x0000,SIS_RI_1360x768, 0x00,0x00,0x00,0x00,0x4c,-1},
 	{0x4f,0x9a1f,0x0000,SIS_RI_320x200,  0x00,0x00,0x04,0x04,0x25, 0}, /* 320x200x32 */
 	{0x53,0x9a1f,0x0000,SIS_RI_320x240,  0x00,0x00,0x04,0x04,0x26, 2}, /* 320x240x32 */
-	{0x54,0xba1f,0x0000,SIS_RI_400x300,  0x00,0x00,0x07,0x07,0x27, 3}, /* 400x300x32 */
+	{0x54,0xba1f,0x0000,SIS_RI_400x300,  0x00,0x00,0x07,0x07,0x27, 3}, /* 400x300x32 */             /*0x50*/
 	{0x5f,0x6a1b,0x0000,SIS_RI_768x576,  0x00,0x00,0x06,0x06,0x4d,-1}, /* 768x576 */
 	{0x60,0x6a1d,0x0000,SIS_RI_768x576,  0x00,0x00,0x06,0x06,0x4d,-1},
 	{0x61,0x6a3f,0x0000,SIS_RI_768x576,  0x00,0x00,0x06,0x06,0x4d,-1},
 	{0x14,0x0e3b,0x0000,SIS_RI_1280x800, 0x00,0x00,0x00,0x00,0x4e, 7}, /* 1280x800 */
 	{0x15,0x0e7d,0x0000,SIS_RI_1280x800, 0x00,0x00,0x00,0x00,0x4e, 7},
 	{0x16,0x0eff,0x0000,SIS_RI_1280x800, 0x00,0x00,0x00,0x00,0x4e, 7},
-	{0x17,0x0e3b,0x0000,SIS_RI_1680x1050,0x00,0x00,0x00,0x00,0x51, 9}, /* 1680x1050 */
-	{0x18,0x0e7d,0x0000,SIS_RI_1680x1050,0x00,0x00,0x00,0x00,0x51, 9},
-	{0x19,0x0eff,0x0000,SIS_RI_1680x1050,0x00,0x00,0x00,0x00,0x51, 9},
+	{0x17,0x0e3b,0x0000,SIS_RI_1680x1050,0x00,0x00,0x00,0x00,0x51, 13}, /* 1680x1050 */
+	{0x18,0x0e7d,0x0000,SIS_RI_1680x1050,0x00,0x00,0x00,0x00,0x51, 13},
+	{0x19,0x0eff,0x0000,SIS_RI_1680x1050,0x00,0x00,0x00,0x00,0x51, 13},
 	{0x2c,0x267b,0x0000,SIS_RI_1920x1080,0x00,0x00,0x00,0x00,0x52,-1}, /* 1920x1080(i) */
 	{0x2d,0x26fd,0x0000,SIS_RI_1920x1080,0x00,0x00,0x00,0x00,0x52,-1},
 	{0x73,0x27ff,0x0000,SIS_RI_1920x1080,0x00,0x00,0x00,0x00,0x52,-1},
 	{0x1d,0x6a1b,0x0000,SIS_RI_960x540,  0x00,0x00,0x00,0x00,0x53,-1}, /* 960x540 */
 	{0x1e,0x6a3d,0x0000,SIS_RI_960x540,  0x00,0x00,0x00,0x00,0x53,-1},
 	{0x1f,0x6a7f,0x0000,SIS_RI_960x540,  0x00,0x00,0x00,0x00,0x53,-1},
-	{0x20,0x6a1b,0x0000,SIS_RI_960x600,  0x00,0x00,0x00,0x00,0x54,-1}, /* 960x600 */
+	{0x20,0x6a1b,0x0000,SIS_RI_960x600,  0x00,0x00,0x00,0x00,0x54,-1}, /* 960x600 */                  /*0x60*/
 	{0x21,0x6a3d,0x0000,SIS_RI_960x600,  0x00,0x00,0x00,0x00,0x54,-1},
 	{0x22,0x6a7f,0x0000,SIS_RI_960x600,  0x00,0x00,0x00,0x00,0x54,-1},
 	{0x1a,0x0e3b,0x0000,SIS_RI_1280x854, 0x00,0x00,0x00,0x00,0x55, 8}, /* 1280x854 */
 	{0x1b,0x0e7d,0x0000,SIS_RI_1280x854, 0x00,0x00,0x00,0x00,0x55, 8},
 	{0x1c,0x0eff,0x0000,SIS_RI_1280x854, 0x00,0x00,0x00,0x00,0x55, 8},
+	{0x55,0x0e3b,0x0000,SIS_RI_1440x900, 0x00,0x00,0x00,0x00,0x58,11}, /* 1440x900 */ /*8bpp*/
+	{0x67,0x0e7d,0x0000,SIS_RI_1440x900, 0x00,0x00,0x00,0x00,0x58,11}, /* 1440x900 */ /* (ROMIndex661 11 guessed) */ /*16bpp*/
+	{0x6f,0x0eff,0x0000,SIS_RI_1440x900, 0x00,0x00,0x00,0x00,0x58,11},/*  1440x900 */ /*32 bpp*/
+	{0x72,0x0e3b,0x0000,SIS_RI_1366x768, 0x00,0x00,0x00,0x00,0x5b,-1}, /* 1366x768 */  /*8 bpp*/ /*Ivans@090109*/
+	{0x7b,0x0e7d,0x0000,SIS_RI_1366x768, 0x00,0x00,0x00,0x00,0x5b,-1}, /* 1366x768 */ /*16 bpp*/ /*Ivans@090109*/
+	{0x7f,0x0eff,0x0000,SIS_RI_1366x768, 0x00,0x00,0x00,0x00,0x5b,-1}, /* 1366x768 */ /*32 bpp*/ /*Ivans@090109*/
 	{0xff,0x0000,0x0000,0,               0x00,0x00,0x00,0x00,0x00,-1}
+	/* Available: 0x72, 0x7b, (0x7f)
+	 * (0x6a, 0x37, 0x40, 0x43, 0x46, 0x49, 0x4c)
+	 */
 };
 
 static const struct SiS_Ext2 SiS310_RefIndex[] =
@@ -211,10 +220,10 @@ static const struct SiS_Ext2 SiS310_RefIndex[] =
 	{0x4007,0x2f,0x33,0x00,0x00,0x6c,2048,1536, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x31 */
 	{0x4007,0x30,0x37,0x00,0x00,0x6c,2048,1536, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x32 */
 	{0x4005,0x31,0x38,0x00,0x00,0x6c,2048,1536, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x33 */
-	{0x2077,0x32,0x40,0x08,0x18,0x70, 800, 480, 0x30, 0x00, 0x00, 0x32, 0x40, 0x5e, 0x73}, /* 0x34 */
+	{0x307f,0x32,0x40,0x08,0x18,0x70, 800, 480, 0x30, 0x00, 0x00, 0x32, 0x40, 0x5e, 0x73}, /* 0x34 */
 	{0x2047,0x33,0x07,0x08,0x18,0x70, 800, 480, 0x30, 0x00, 0x00, 0x33, 0x07, 0xff, 0xff}, /* 0x35 */
 	{0x2047,0x34,0x0a,0x08,0x18,0x70, 800, 480, 0x30, 0x00, 0x00, 0x34, 0x0a, 0xff, 0xff}, /* 0x36 */
-	{0x2077,0x35,0x0b,0x09,0x19,0x71,1024, 576, 0x30, 0x00, 0x00, 0x35, 0x0b, 0x5f, 0x74}, /* 0x37 */
+	{0x3877,0x35,0x0b,0x09,0x19,0x71,1024, 576, 0x30, 0x00, 0x00, 0x35, 0x0b, 0x5f, 0x74}, /* 0x37 */
 	{0x2047,0x36,0x11,0x09,0x19,0x71,1024, 576, 0x30, 0x00, 0x00, 0x36, 0x11, 0xff, 0xff}, /* 0x38 */
 	{0x2047,0x37,0x16,0x09,0x19,0x71,1024, 576, 0x30, 0x00, 0x00, 0x37, 0x16, 0xff, 0xff}, /* 0x39 */
 	{0x3137,0x38,0x19,0x0a,0x0c,0x75,1280, 720, 0x30, 0x00, 0x00, 0x38, 0x19, 0x60, 0x75}, /* 0x3a */
@@ -232,10 +241,10 @@ static const struct SiS_Ext2 SiS310_RefIndex[] =
 	{0x0127,0x44,0x19,0x00,0x1a,0x29,1152, 864, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x46 1152x864-75Hz  */
 	{0x0127,0x4a,0x1e,0x00,0x1a,0x29,1152, 864, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x47 1152x864-85Hz  */
 	{0x0087,0x45,0x57,0x00,0x16,0x39, 848, 480, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x48 848x480-38Hzi  */
-	{0xc067,0x46,0x55,0x0b,0x16,0x39, 848, 480, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x49 848x480-60Hz   */
+	{0xd877,0x46,0x55,0x0e,0x16,0x39, 848, 480, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x49 848x480-60Hz   */
 	{0x0087,0x47,0x57,0x00,0x17,0x3f, 856, 480, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x4a 856x480-38Hzi  */
-	{0xc067,0x48,0x57,0x00,0x17,0x3f, 856, 480, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x4b 856x480-60Hz   */
-	{0x0067,0x49,0x58,0x0c,0x1b,0x48,1360, 768, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x4c 1360x768-60Hz  */
+	{0xd877,0x48,0x57,0x0f,0x17,0x3f, 856, 480, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x4b 856x480-60Hz   */
+	{0x0067,0x49,0x58,0x10,0x1b,0x48,1360, 768, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x4c 1360x768-60Hz  */
 	{0x006f,0x4d,0x71,0x06,0x15,0x5f, 768, 576, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* 0x4d 768x576-56Hz   */
 	{0x2067,0x4f,0x5c,0x08,0x0d,0x14,1280, 800, 0x30, 0x00, 0x00, 0x5b, 0x19, 0x4f, 0x5c}, /* 0x4e 1280x800-60Hz  */
 	{0x2067,0x4f,0x5c,0x08,0x0d,0x14,1280, 800, 0x30, 0x00, 0x00, 0x5c, 0x1e, 0xff, 0xff}, /* 0x4f 1280x800-75Hz  */
@@ -247,6 +256,10 @@ static const struct SiS_Ext2 SiS310_RefIndex[] =
 	{0x2067,0x61,0x76,0x0d,0x22,0x1a,1280, 854, 0x30, 0x00, 0x00, 0x62, 0x19, 0x61, 0x76}, /* 0x55 1280x854-60Hz  */
 	{0x2067,0x61,0x76,0x0d,0x22,0x1a,1280, 854, 0x30, 0x00, 0x00, 0x63, 0x1e, 0xff, 0xff}, /* 0x56 1280x854-75Hz  */
 	{0x2067,0x61,0x76,0x0d,0x22,0x1a,1280, 854, 0x30, 0x00, 0x00, 0x64, 0x20, 0xff, 0xff}, /* 0x57 1280x854-85Hz  */
+	{0x2067,0x65,0x77,0x0e,0x23,0x67,1440, 900, 0x30, 0x00, 0x00, 0x66, 0x78, 0x65, 0x77}, /* 0x58 1440x900-60Hz  */
+	{0x2067,0x65,0x77,0x0e,0x23,0x67,1440, 900, 0x30, 0x00, 0x00, 0x67, 0x79, 0xff, 0xff}, /* 0x59 1440x900-75Hz  */
+	{0x2067,0x65,0x77,0x0e,0x23,0x67,1440, 900, 0x30, 0x00, 0x00, 0x68, 0x7a, 0xff, 0xff}, /* 0x5a 1440x900-85Hz  */
+	{0x2067,0x69,0x7b,0x00,0x00,0x7f,1366, 768, 0x30, 0x00, 0x00, 0x69, 0x7b, 0x69, 0x7b}, /*0x5b 1366x768-60Hz*/ /*Ivans@090109*/
 	{0xffff,0x00,0x00,0x00,0x00,0x00,   0,   0,    0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 };
 
@@ -267,10 +280,10 @@ static const struct SiS_CRT1Table SiS310_CRT1Table[] =
  {{0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
    0x9c,0x8e,0x8f,0x96,0xb9,0x30,0x00,0x05,
    0x00}},  /* 0x4 */
- {{0x5f,0x4f,0x4f,0x83,0x55,0x81,0x0b,0x3e,    /* corrected 640x480-60 */
+ {{0x5f,0x4f,0x4f,0x83,0x55,0x81,0x0b,0x3e,
    0xe9,0x8b,0xdf,0xe8,0x0c,0x00,0x00,0x05,
    0x00}},  /* 0x5 */
- {{0x63,0x4f,0x4f,0x87,0x56,0x9b,0x06,0x3e,    /* corrected 640x480-72 */
+ {{0x63,0x4f,0x4f,0x87,0x56,0x9b,0x06,0x3e,
    0xe8,0x8a,0xdf,0xe7,0x07,0x00,0x00,0x01,
    0x00}},  /* 0x6 */
  {{0x64,0x4f,0x4f,0x88,0x55,0x9d,0xf2,0x1f,
@@ -280,16 +293,16 @@ static const struct SiS_CRT1Table SiS310_CRT1Table[] =
    0xe0,0x83,0xdf,0xdf,0xfc,0x10,0x00,0x05,
    0x00}},  /* 0x8 */
  {{0x65,0x4f,0x4f,0x89,0x58,0x80,0xfb,0x1f,
-   0xe0,0x83,0xdf,0xdf,0xfc,0x10,0x00,0x05,  /* Corrected VBE */
+   0xe0,0x83,0xdf,0xdf,0xfc,0x10,0x00,0x05,
    0x61}},  /* 0x9 */
  {{0x65,0x4f,0x4f,0x89,0x58,0x80,0x01,0x3e,
    0xe0,0x83,0xdf,0xdf,0x02,0x00,0x00,0x05,
    0x61}},  /* 0xa */
  {{0x67,0x4f,0x4f,0x8b,0x58,0x81,0x0d,0x3e,
-   0xe0,0x83,0xdf,0xdf,0x0e,0x00,0x00,0x05,  /* Corrected VBE */
+   0xe0,0x83,0xdf,0xdf,0x0e,0x00,0x00,0x05,
    0x61}},  /* 0xb */
  {{0x65,0x4f,0x4f,0x89,0x57,0x9f,0xfb,0x1f,
-   0xe6,0x8a,0xdf,0xdf,0xfc,0x10,0x00,0x01,  /* Corrected VDE, VBE */
+   0xe6,0x8a,0xdf,0xdf,0xfc,0x10,0x00,0x01,
    0x00}},  /* 0xc */
  {{0x7b,0x63,0x63,0x9f,0x6a,0x93,0x6f,0xf0,
    0x58,0x8a,0x57,0x57,0x70,0x20,0x00,0x05,
@@ -417,7 +430,7 @@ static const struct SiS_CRT1Table SiS310_CRT1Table[] =
  {{0x9f,0x7f,0x7f,0x83,0x85,0x91,0x1e,0xf1,
    0xad,0x81,0x3f,0x3f,0x1f,0x30,0x00,0x02,
    0x01}},  /* 0x36 */
- {{0xa7,0x7f,0x7f,0x88,0x89,0x95,0x26,0xf1,   /* 95 was 15 - illegal HBE! */
+ {{0xa7,0x7f,0x7f,0x88,0x89,0x95,0x26,0xf1,
    0xb1,0x85,0x3f,0x3f,0x27,0x30,0x00,0x02,
    0x01}},  /* 0x37 */
  {{0xce,0x9f,0x9f,0x92,0xa9,0x17,0x28,0xc4,
@@ -429,13 +442,13 @@ static const struct SiS_CRT1Table SiS310_CRT1Table[] =
  {{0xd3,0x9f,0x9f,0x97,0xab,0x1f,0x2e,0xd4,
    0x7d,0x81,0xcf,0xcf,0x2f,0x21,0x00,0x07,
    0x01}},  /* 0x3a */
- {{0xdc,0x9f,0x9f,0x80,0xaf,0x9d,0xe6,0xff,	/* 1280x960-60 - corrected */
+ {{0xdc,0x9f,0x9f,0x80,0xaf,0x9d,0xe6,0xff,
    0xc0,0x83,0xbf,0xbf,0xe7,0x10,0x00,0x07,
    0x01}},  /* 0x3b */
  {{0x6b,0x59,0x59,0x8f,0x5e,0x8c,0x0b,0x3e,
    0xe9,0x8b,0xdf,0xe7,0x04,0x00,0x00,0x05,
    0x00}},  /* 0x3c */
- {{0x6d,0x59,0x59,0x91,0x60,0x89,0x53,0xf0,	/* 720x576, corrected to 60Hz */
+ {{0x6d,0x59,0x59,0x91,0x60,0x89,0x53,0xf0,
    0x41,0x84,0x3f,0x3f,0x54,0x00,0x00,0x05,
    0x41}},  /* 0x3d */
  {{0x86,0x6a,0x6a,0x8a,0x74,0x06,0x8c,0x15,
@@ -554,7 +567,23 @@ static const struct SiS_CRT1Table SiS310_CRT1Table[] =
    0x41}},  /* 0x63 */
  {{0xd3,0x9f,0x9f,0x97,0xab,0x1f,0x2e,0xde, /* 1280x854 (1280x1024) 85 Hz */
    0xc0,0x84,0x55,0xbf,0x2f,0x01,0x00,0x07,
-   0x41}}   /* 0x64 */
+   0x41}},  /* 0x64 */
+ {{                                          /* 1400x900-60 wide */
+   0xe9,0xb3,0xb3,0x8d,0xc1,0x94,0xa4,0xff,
+   0x86,0x8c,0x83,0x83,0xa5,0x10,0x00,0x03,
+   0x00}},  /* 0x65 */
+ {{0xef,0xb3,0xb3,0x93,0xbf,0x87,0x5e,0xde, /* 1440x900 (1440x1080) 60Hz */
+   0xef,0x83,0x83,0xee,0x5f,0x21,0x00,0x07,
+   0x41}},  /* 0x66 */
+ {{0xef,0xb3,0xb3,0x93,0xbf,0x87,0x5e,0xde, /* 1440x900 (1440x1080) 75Hz */
+   0xef,0x83,0x83,0xee,0x5f,0x21,0x00,0x07,
+   0x41}},  /* 0x67 */
+ {{0xef,0xb3,0xb3,0x93,0xbf,0x87,0x5e,0xde, /* 1440x900 (1440x1080) 85Hz */
+   0xef,0x83,0x83,0xee,0x5f,0x21,0x00,0x07,
+   0x41}},   /* 0x68 */
+ {{0xda,0xaa,0xaa,0x9e,0xb7,0x08,0x1c,0xf5,/*1368x768 60Hz for LVDS 1366x768. Ivans@090109*/
+   0x02,0x8c,0xff,0xff,0x1d,0x10,0x00,0x03,
+   0x41}}    /* 0x69 */
 };
 
 static const struct SiS_MCLKData SiS310_MCLKData_0_315[] =
@@ -785,7 +814,12 @@ static struct SiS_VCLKData SiS310_VCLKData[] =
 	{ 0x1b,0xc1, 34}, /* 0x73 800x480 60Hz (wide) */
 	{ 0x41,0x64, 48}, /* 0x74 1024x576 60Hz (wide) */
 	{ 0x52,0x27, 75}, /* 0x75 1280x720 60Hz (wide) */
-	{ 0x75,0x13, 84}  /* 0x76 1280x854 60Hz (wide) */
+	{ 0x75,0x13, 84}, /* 0x76 1280x854 60Hz (wide) */
+	{ 0x78,0x28, 96}, /* 0x77 1440x900 60Hz (wide) */
+	{ 0xb6,0x43,132}, /* 0x78 1440x900 60Hz (1440x1080) */
+	{ 0x7d,0x0a,164}, /* 0x79 1440x900 75Hz (1440x1080) */
+	{ 0x19,0x01,186}, /* 0x7a 1440x900 85Hz (1440x1080) */
+	{ 0x76,0x29, 86}  /* 0x7b 1366x768 60Hz, used 1360x768 VCLK. Ivans@090109*/
 };
 
 static struct SiS_VBVCLKData SiS310_VBVCLKData[] =
@@ -883,7 +917,7 @@ static struct SiS_VBVCLKData SiS310_VBVCLKData[] =
 	{ 0x56,0x07,156}, /* 0x5a 1400x1050-75 */
 	{ 0x70,0x29, 81}, /* 0x5b 1280x768 LCD (TMDS) */
 	{ 0xce,0x1e, 73}, /* 0x5c 1280x800_2 LCD (SiS LVDS) - (CRT1: 45 25 83) */
-	{ 0xbe,0x44,121}, /* 0x5d 1680x1050 LCD */
+	{ 0x70,0x0a,147}, /*{ 0xbe,0x44,121},*/ /* 0x5d 1680x1050 LCD */
 	{ 0x70,0x24,162}, /* 0x5e 1600x1200 LCD */
 	{ 0x52,0x27, 75}, /* 0x5f 1280x720 (TMDS + HDTV) (correct) */
 	{ 0xc8,0x48, 77}, /* 0x60 1280x768_2 (SiS LVDS) */
@@ -908,7 +942,12 @@ static struct SiS_VBVCLKData SiS310_VBVCLKData[] =
 	{ 0x1b,0xc1, 34}, /* 0x73 800x480 60Hz (wide) */
 	{ 0x41,0x64, 48}, /* 0x74 1024x576 60Hz (wide) */
 	{ 0x52,0x27, 75}, /* 0x75 1280x720 60Hz (wide) */
-	{ 0x75,0x13, 84}  /* 0x76 1280x854 60Hz (SiS LVDS) LCD */
+	{ 0x75,0x13, 84}, /* 0x76 1280x854 60Hz (SiS LVDS) LCD */
+	{ 0x78,0x28, 96}, /* 0x77 1440x900 60Hz  LCD (wide) */
+	{ 0xb6,0x43,132}, /* 0x78 1440x900 60Hz (1440x1080) */
+	{ 0x7d,0x0a,164}, /* 0x79 1440x900 75Hz (1440x1080) */
+	{ 0x19,0x01,186}, /* 0x7a 1440x900 85Hz (1440x1080) */
+	{ 0xa5,0x44, 72}  /* 0x7b 1366x768 60Hz. Ivans@090109*/
 };
 
 static const unsigned char SiS310_SR15[4 * 8] =
@@ -1336,4 +1375,3 @@ static const unsigned char SiS310_CHTVVCLKOPALM[] = { 0x48,0x48,0x48,0x48,0x45,0
 static const unsigned char SiS310_CHTVVCLKUPALN[] = { 0x47,0x47,0x47,0x47,0x48,0x4a,0x54 };
 static const unsigned char SiS310_CHTVVCLKOPALN[] = { 0x47,0x47,0x47,0x47,0x48,0x4f,0x52 };
 
-
diff --git a/src/Makefile.am b/src/Makefile.am
index 281db15..91a1b4c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -46,9 +46,12 @@ sis_drv_la_SOURCES = \
          sis310_accel.c \
          sis310_accel.h \
          sis6326_video.c \
+         sis_3daccel.c \
+         sis_3daccel.h \
          sis_accel.c \
          sis_accel.h \
          sis_common.h \
+         sis_config.h \
          sis_cursor.c \
          sis_cursor.h \
          sis_dac.c \
@@ -57,13 +60,16 @@ sis_drv_la_SOURCES = \
          sis_driver.c \
          sis_driver.h \
          sis.h \
+         sis_hwmc.c \
          sis_memcpy.c \
+         sis_mergedfb.c \
          sis_opt.c \
          sis_regs.h \
          sis_setup.c \
          sis_shadow.c \
          sis_utility.c \
          sis_vb.c \
+         sis_vb.h \
          sis_vga.c \
          sis_video.c \
          sis_video.h \
diff --git a/src/init.c b/src/init.c
index 2e35d5f..32a4c58 100644
--- a/src/init.c
+++ b/src/init.c
@@ -38,7 +38,7 @@
  * *    documentation and/or other materials provided with the distribution.
  * * 3) The name of the author may not be used to endorse or promote products
  * *    derived from this software without specific prior written permission.
- * *
+ * * 
  * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  * * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
@@ -134,6 +134,8 @@ InitCommonPointer(struct SiS_Private *SiS_Pr)
    SiS_Pr->SiS_StLCD1600x1200Data   = SiS_StLCD1600x1200Data;
    SiS_Pr->SiS_ExtLCD1600x1200Data  = SiS_ExtLCD1600x1200Data;
    SiS_Pr->SiS_NoScaleData          = SiS_NoScaleData;
+   SiS_Pr->SiS_LCD1440x900Data      = SiS_LCD1440x900Data;/*Ivans add 1440x900*/
+   SiS_Pr->SiS_LCD1366x768Data      = SiS_LCD1366x768Data;/*1366x768 LVDS. Ivans@090109*/
 
    SiS_Pr->SiS_LVDS320x240Data_1   = SiS_LVDS320x240Data_1;
    SiS_Pr->SiS_LVDS320x240Data_2   = SiS_LVDS320x240Data_2;
@@ -159,8 +161,9 @@ InitCommonPointer(struct SiS_Private *SiS_Pr)
    SiS_Pr->SiS_CHTVUNTSCData = SiS_CHTVUNTSCData;
    SiS_Pr->SiS_CHTVONTSCData = SiS_CHTVONTSCData;
 
-   SiS_Pr->SiS_PanelMinLVDS   = Panel_800x600;    /* lowest value LVDS/LCDA */
-   SiS_Pr->SiS_PanelMin301    = Panel_1024x768;   /* lowest value 301 */
+   SiS_Pr->SiS_PanelMinLVDS   = Panel_800x600;    /* 0x01:lowest value LVDS/LCDA */
+   SiS_Pr->SiS_PanelMin301    = Panel_1024x768;   /* 0x02: lowest value 301:
+                                                                                 NOT support 800x600 panel!? */
 }
 #endif
 
@@ -250,10 +253,12 @@ InitTo310Pointer(struct SiS_Private *SiS_Pr)
    SiS_Pr->SiS_EModeIDTable  = SiS310_EModeIDTable;
    SiS_Pr->SiS_RefIndex      = SiS310_RefIndex;
    SiS_Pr->SiS_CRT1Table     = SiS310_CRT1Table;
-   if(SiS_Pr->ChipType >= SIS_340) {
-      SiS_Pr->SiS_MCLKData_0 = SiS310_MCLKData_0_340;  /* 340 + XGI */
+   if(SiS_Pr->ChipType >= XGI_20) {
+      SiS_Pr->SiS_MCLKData_0 = SiS310_MCLKData_0_340;  /* XGI 20, 40 */
    } else if(SiS_Pr->ChipType >= SIS_761) {
       SiS_Pr->SiS_MCLKData_0 = SiS310_MCLKData_0_761;  /* 761 - preliminary */
+   } else if(SiS_Pr->ChipType >= SIS_340) {
+      SiS_Pr->SiS_MCLKData_0 = SiS310_MCLKData_0_340;  /* 340 */
    } else if(SiS_Pr->ChipType >= SIS_760) {
       SiS_Pr->SiS_MCLKData_0 = SiS310_MCLKData_0_760;  /* 760 */
    } else if(SiS_Pr->ChipType >= SIS_661) {
@@ -450,6 +455,9 @@ SiS_GetModeID(int VGAEngine, unsigned int VBFlags, int HDisplay, int VDisplay,
 			if(VDisplay == 1024) ModeIndex = ModeIndex_300_1360x1024[Depth];
 		}
 		break;
+	case 1368:/*using 1368 data to passing 1366 mode. Ivans@090109*/
+		if(LCDwidth == 1366) ModeIndex = ModeIndex_LVDS_1366x768[Depth];
+		break;
 	case 1400:
 		if(VGAEngine == SIS_315_VGA) {
 			if(VDisplay == 1050) {
@@ -457,6 +465,13 @@ SiS_GetModeID(int VGAEngine, unsigned int VBFlags, int HDisplay, int VDisplay,
 			}
 		}
 		break;
+	case 1440:
+		if(VGAEngine == SIS_315_VGA) {
+			if(VDisplay == 900) {
+				ModeIndex = ModeIndex_1440x900[Depth];
+			}
+		}
+		break;
 	case 1600:
 		if(VDisplay == 1200) ModeIndex = ModeIndex_1600x1200[Depth];
 		break;
@@ -691,6 +706,11 @@ SiS_GetModeID_LCD(int VGAEngine, unsigned int VBFlags, int HDisplay, int VDispla
 		if(VDisplay == 768) ModeIndex = ModeIndex_1360x768[Depth];
 	     }
 	     break;
+	case 1368:/*using 1368 data to passing 1366 mode. Ivans@090109*/
+	     if(VGAEngine == SIS_315_VGA){
+	        if(LCDwidth ==1366) ModeIndex = ModeIndex_LVDS_1366x768[Depth];
+	     }
+	     break;
 	case 1400:
 	     if(VGAEngine == SIS_315_VGA) {
 		if(VBFlags2 & VB2_LCDOVER1280BRIDGE) {
@@ -698,6 +718,13 @@ SiS_GetModeID_LCD(int VGAEngine, unsigned int VBFlags, int HDisplay, int VDispla
 		}
 	     }
 	     break;
+	case 1440:
+	     if(VGAEngine == SIS_315_VGA) {
+		if(VBFlags2 & VB2_LCDOVER1280BRIDGE) {
+		   if(VDisplay == 900) ModeIndex = ModeIndex_1440x900[Depth];
+		}
+	     }
+	     break;
 	case 1600:
 	     if(VGAEngine == SIS_315_VGA) {
 		if(VBFlags2 & VB2_LCDOVER1280BRIDGE) {
@@ -805,6 +832,20 @@ SiS_GetModeID_TV(int VGAEngine, unsigned int VBFlags, int HDisplay, int VDisplay
 	     if(VDisplay == 600)      ModeIndex = ModeIndex_800x600[Depth];
 	     else if(VDisplay == 480) ModeIndex = ModeIndex_800x480[Depth];
 	     break;
+	case 848:
+	     if((VBFlags2 & VB2_30xBLV) ||
+	        (VBFlags & TV_HIVISION) ||
+	        ((VBFlags & TV_YPBPR) && (VBFlags & (TV_YPBPR1080I | TV_YPBPR750P)))) {
+		if(VDisplay == 480) ModeIndex = ModeIndex_848x480[Depth];
+	     }
+	     break;
+	case 856:
+	     if((VBFlags2 & VB2_30xBLV) ||
+	        (VBFlags & TV_HIVISION) ||
+	        ((VBFlags & TV_YPBPR) && (VBFlags & (TV_YPBPR1080I | TV_YPBPR750P)))) {
+		if(VDisplay == 480) ModeIndex = ModeIndex_856x480[Depth];
+	     }
+	     break;
 	case 960:
 	     if(VGAEngine == SIS_315_VGA) {
 	        if((VBFlags & TV_HIVISION) || ((VBFlags & TV_YPBPR) && (VBFlags & TV_YPBPR1080I))) {
@@ -1067,7 +1108,7 @@ SiS_GetSysFlags(struct SiS_Private *SiS_Pr)
       }
    }
 
-   if(SiS_Pr->ChipType >= SIS_760 && SiS_Pr->ChipType <= SIS_761) {
+   if(SiS_Pr->ChipType == SIS_760 || SiS_Pr->ChipType == SIS_761) {
       if(SiS_GetReg(SiS_Pr->SiS_P3d4,0x78) & 0x30) {
          SiS_Pr->SiS_SysFlags |= SF_760LFB;
       }
@@ -1118,6 +1159,9 @@ SiSInitPCIetc(struct SiS_Private *SiS_Pr)
    case SIS_761:
    case SIS_340:
    case XGI_40:
+   case SIS_662:
+   case SIS_770:
+   case SIS_671:
       /* See above */
       SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x20,0xa1);
       /*  - Enable 3D G/L transformation engine (0x80)
@@ -1126,7 +1170,7 @@ SiSInitPCIetc(struct SiS_Private *SiS_Pr)
        *  - Enable 3D command parser (0x08)
        *  - Enable 3D (0x02)
        */
-      SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x1E,0xDA);
+      SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x1E,0x5A);
       break;
    case XGI_20:
    case SIS_550:
@@ -1197,8 +1241,9 @@ SiSSetLVDSetc(struct SiS_Private *SiS_Pr)
    case SIS_741:
    case SIS_660:
    case SIS_760:
-   case SIS_761:
    case SIS_340:
+   case SIS_341:
+   case SIS_342:
    case XGI_20:
    case XGI_40:
 	temp = (SiS_GetReg(SiS_Pr->SiS_P3d4,0x38) & 0xe0) >> 5;
@@ -1206,6 +1251,16 @@ SiSSetLVDSetc(struct SiS_Private *SiS_Pr)
 	if(temp == 3)			SiS_Pr->SiS_IF_DEF_CH70xx = 2;
 	if(temp == 4)			SiS_Pr->SiS_IF_DEF_CONEX = 1;  /* Not yet supported */
 	break;
+   case SIS_761:
+   case SIS_770:
+   case SIS_662:
+	temp = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x03); 
+      if((temp==0x10)&&(SiS_Pr->SiS_VBType==VB2_307LV))   /*chaoyu:(TODO) bug*/
+	{
+	    SiS_Pr->SiS_IF_DEF_LVDS = 1;
+       }
+	break;
+
 #endif
    default:
 	break;
@@ -1258,8 +1313,8 @@ SiSDetermineROMLayout661(struct SiS_Private *SiS_Pr)
    if(SiS_Pr->ChipType >= XGI_20) {
       /* XGI ROMs don't qualify */
       return FALSE;
-   } else if(SiS_Pr->ChipType >= SIS_761) {
-      /* I very much assume 761, 340 and newer will use new layout */
+   } else if(SiS_Pr->ChipType >= SIS_340) {
+      /* I very much assume 340 and newer will use new layout */
       return TRUE;
    } else if(SiS_Pr->ChipType >= SIS_661) {
       if((ROMAddr[0x1a] == 'N') &&
@@ -1278,7 +1333,7 @@ SiSDetermineROMLayout661(struct SiS_Private *SiS_Pr)
       if((romvmaj != 0) || (romvmin >= 92)) {
 	 return TRUE;
       }
-   } else if(IS_SIS650740) {
+   } else if((SiS_Pr->ChipType >= SIS_650) && (SiS_Pr->ChipType <= SIS_740)) {
       if((ROMAddr[0x1a] == 'N') &&
 	 (ROMAddr[0x1b] == 'e') &&
 	 (ROMAddr[0x1c] == 'w') &&
@@ -1320,21 +1375,47 @@ SiSDetermineROMUsage(struct SiS_Private *SiS_Pr)
 	 if((SiS_Pr->SiS_ROMNew = SiSDetermineROMLayout661(SiS_Pr))) {
 	    SiS_Pr->SiS_EMIOffset = 14;
 	    SiS_Pr->SiS_PWDOffset = 17;
-	    SiS_Pr->SiS661LCD2TableSize = 36;
 	    /* Find out about LCD data table entry size */
-	    if((romptr = SISGETROMW(0x0102))) {
-	       if(ROMAddr[romptr + (32 * 16)] == 0xff)
-		  SiS_Pr->SiS661LCD2TableSize = 32;
-	       else if(ROMAddr[romptr + (34 * 16)] == 0xff)
-		  SiS_Pr->SiS661LCD2TableSize = 34;
-	       else if(ROMAddr[romptr + (36 * 16)] == 0xff)	   /* 0.94, 2.05.00+ */
-		  SiS_Pr->SiS661LCD2TableSize = 36;
-	       else if( (ROMAddr[romptr + (38 * 16)] == 0xff) ||   /* 2.00.00 - 2.02.00 */
-		 	(ROMAddr[0x6F] & 0x01) ) {		   /* 2.03.00 - <2.05.00 */
-		  SiS_Pr->SiS661LCD2TableSize = 38;		   /* UMC data layout abandoned at 2.05.00 */
-		  SiS_Pr->SiS_EMIOffset = 16;
-		  SiS_Pr->SiS_PWDOffset = 19;
-	       }
+           if(SiS_Pr->ChipType < SIS_761)	{	
+	       SiS_Pr->SiS661LCD2TableSize = 36;
+	       if((romptr = SISGETROMW(0x0102))) {
+	           if(ROMAddr[romptr + (32 * 16)] == 0xff)
+		       SiS_Pr->SiS661LCD2TableSize = 32;
+	           else if(ROMAddr[romptr + (34 * 16)] == 0xff)
+		       SiS_Pr->SiS661LCD2TableSize = 34;
+	           else if(ROMAddr[romptr + (36 * 16)] == 0xff)	   /* 0.94, 2.05.00+ */
+		       SiS_Pr->SiS661LCD2TableSize = 36;
+	           else if( (ROMAddr[romptr + (38 * 16)] == 0xff) ||   /* 2.00.00 - 2.02.00 */
+		       (ROMAddr[0x6F] & 0x01) ) {		   /* 2.03.00 - <2.05.00 */
+		   SiS_Pr->SiS661LCD2TableSize = 38;		   /* UMC data layout abandoned at 2.05.00 */
+		   SiS_Pr->SiS_EMIOffset = 16;
+		   SiS_Pr->SiS_PWDOffset = 19;
+	           }
+	        }
+            }
+	    else
+	    {
+                if(SiS_Pr->BIOSVersion>=36){
+                    SiS_Pr->SiS661LCD2TableSize = 39;
+	            SiS_Pr->SiS_EMIOffset = 13;
+	            SiS_Pr->SiS_PWDOffset = 15;
+                }else{
+                    SiS_Pr->SiS661LCD2TableSize = 30;           
+	            SiS_Pr->SiS_EMIOffset = 13;
+	            SiS_Pr->SiS_PWDOffset = 15;
+                }
+	        if((romptr = SISGETROMW(0x9C))) {
+	           if(ROMAddr[romptr + (32 * 16)] == 0xff)
+		       SiS_Pr->SiS661LCD2TableSize = 32;
+	           else if(ROMAddr[romptr + (34 * 16)] == 0xff)
+		       SiS_Pr->SiS661LCD2TableSize = 34;
+	           else if(ROMAddr[romptr + (36 * 16)] == 0xff)	  
+		       SiS_Pr->SiS661LCD2TableSize = 36;
+	           else if( (ROMAddr[romptr + (38 * 16)] == 0xff) ||
+		       (ROMAddr[0x6F] & 0x01) ) {		   
+		   SiS_Pr->SiS661LCD2TableSize = 38;	
+	           }
+	        }
 	    }
 	 }
       }
@@ -1406,7 +1487,7 @@ SiS_ResetSegmentRegOver(struct SiS_Private *SiS_Pr)
 static void
 SiS_ResetSegmentRegisters(struct SiS_Private *SiS_Pr)
 {
-   if((IS_SIS65x) || (SiS_Pr->ChipType >= SIS_661)) {
+   if((SiS_Pr->SiS_SysFlags & SF_Is65x) || (SiS_Pr->ChipType >= SIS_661)) {
       SiS_ResetSegmentReg(SiS_Pr);
       SiS_ResetSegmentRegOver(SiS_Pr);
    }
@@ -1422,7 +1503,7 @@ static
 void
 SiS_GetVBType(struct SiS_Private *SiS_Pr)
 {
-   unsigned short flag = 0, rev = 0, nolcd = 0;
+   unsigned short flag = 0, rev = 0, nolcd = 0, stPart4_39 = 0;
    unsigned short p4_0f, p4_25, p4_27;
 
    SiS_Pr->SiS_VBType = 0;
@@ -1435,12 +1516,27 @@ SiS_GetVBType(struct SiS_Private *SiS_Pr)
 
    flag = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x00);
 
-   if(flag > 3)
+   if((flag > 2) && (flag != 7))
       return;
 
    rev = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x01);
+   stPart4_39 = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x39);
 
-   if(flag >= 2) {
+   if(flag == 7) 
+   {
+        if(rev==0xE0||rev==0xE1)
+        {
+            switch(stPart4_39)
+            {
+                case 0xE0:
+      	                SiS_Pr->SiS_VBType = VB_SIS307T;
+  		        break;
+	    	    case 0xFF:
+      	                SiS_Pr->SiS_VBType = VB_SIS307LV;
+		        break;
+            }
+        }
+   } else if(flag >= 2) {
       SiS_Pr->SiS_VBType = VB_SIS302B;
    } else if(flag == 1) {
       if(rev >= 0xC0) {
@@ -1454,6 +1550,7 @@ SiS_GetVBType(struct SiS_Private *SiS_Pr)
 	 SiS_Pr->SiS_VBType = VB_SIS301;
       }
    }
+
    if(SiS_Pr->SiS_VBType & (VB_SIS301B | VB_SIS301C | VB_SIS302B)) {
       if(rev >= 0xE0) {
 	 flag = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x39);
@@ -1463,6 +1560,7 @@ SiS_GetVBType(struct SiS_Private *SiS_Pr)
 	 SiS_Pr->SiS_VBType = VB_SIS301LV;
       }
    }
+
    if(SiS_Pr->SiS_VBType & (VB_SIS301C | VB_SIS301LV | VB_SIS302LV | VB_SIS302ELV)) {
       p4_0f = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x0f);
       p4_25 = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x25);
@@ -1509,6 +1607,8 @@ SiS_Get310DRAMType(struct SiS_Private *SiS_Pr)
 {
    unsigned char data;
 
+   /* Only called for 315PRO, 330, 760+LFB currently */
+
    if((*SiS_Pr->pSiS_SoftSetting) & SoftDRAMType) {
       data = (*SiS_Pr->pSiS_SoftSetting) & 0x03;
    } else {
@@ -1524,7 +1624,9 @@ SiS_Get310DRAMType(struct SiS_Private *SiS_Pr)
 	 } else {
 	    data = SiS_GetReg(SiS_Pr->SiS_P3d4,0x78) & 0x07;
 	 }
-      } else if(IS_SIS550650740) {
+      } else if((SiS_Pr->ChipType == SIS_550) ||
+		(SiS_Pr->ChipType == SIS_650) ||
+		(SiS_Pr->ChipType == SIS_740)) {
 	 data = SiS_GetReg(SiS_Pr->SiS_P3c4,0x13) & 0x07;
       } else {	/* 315, 330 */
 	 data = SiS_GetReg(SiS_Pr->SiS_P3c4,0x3a) & 0x03;
@@ -1552,6 +1654,8 @@ SiS_GetMCLK(struct SiS_Private *SiS_Pr)
    unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;
    unsigned short index;
 
+   /* Only called for SiS330 and 760/LFB currently */
+
    index = SiS_Get310DRAMType(SiS_Pr);
    if(SiS_Pr->ChipType >= SIS_661) {
       if(SiS_Pr->SiS_ROMNew) {
@@ -1663,6 +1767,9 @@ SiS_GetModePtr(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 unsigned short
 SiS_GetRefCRTVCLK(struct SiS_Private *SiS_Pr, unsigned short Index, int UseWide)
 {
+#ifdef TWDEBUG
+ xf86DrvMsg(0,X_INFO,"[SiS_GetRefCRTVCLK]:UseWide=%d,SiS_Ext2_Index=0x%x.\n",UseWide,Index);	
+#endif       	
    if(SiS_Pr->SiS_RefIndex[Index].Ext_InfoFlag & HaveWideTiming) {
       if(UseWide == 1) {
          return SiS_Pr->SiS_RefIndex[Index].Ext_CRTVCLK_WIDE;
@@ -1734,17 +1841,29 @@ SiS_SetLowModeTest(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 static void
 SiS_OpenCRTC(struct SiS_Private *SiS_Pr)
 {
-   if(IS_SIS650) {
+   switch(SiS_Pr->ChipType) {
+   case SIS_650:
       SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x51,0x1f);
-      if(IS_SIS651) SiS_SetRegOR(SiS_Pr->SiS_P3d4,0x51,0x20);
+      if(SiS_Pr->SiS_SysFlags & (SF_Is651 | SF_Is652)) {
+         SiS_SetRegOR(SiS_Pr->SiS_P3d4,0x51,0x20);
+      }
       SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x56,0xe7);
-   } else if(IS_SIS661741660760) {
+      break;
+   case SIS_661:
+   case SIS_741:
+   case SIS_660:
+   case SIS_760:
+   case SIS_662:
+   case SIS_761:
+   case SIS_770:
+   case SIS_671:
       SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x61,0xf7);
       SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x51,0x1f);
       SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x56,0xe7);
       if(!SiS_Pr->SiS_ROMNew) {
 	 SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x3a,0xef);
       }
+      break;
    }
 }
 
@@ -1754,7 +1873,11 @@ SiS_CloseCRTC(struct SiS_Private *SiS_Pr)
 #if 0 /* This locks some CRTC registers. We don't want that. */
    unsigned short temp1 = 0, temp2 = 0;
 
-   if(IS_SIS661741660760) {
+   switch(SiS_Pr->ChipType) {
+   case SIS_661:
+   case SIS_741:
+   case SIS_660:
+   case SIS_760:
       if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) {
          temp1 = 0xa0; temp2 = 0x08;
       }
@@ -1955,7 +2078,8 @@ SiS_SetATTRegs(struct SiS_Private *SiS_Pr, unsigned short StandTableIndex)
 	    }
 	 } else if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
 	    if(SiS_Pr->ChipType >= SIS_315H) {
-	       if(IS_SIS550650740660) {
+	       if((SiS_Pr->ChipType >= SIS_550) &&
+	          (SiS_Pr->ChipType != SIS_330)) {
 		  /* 315, 330 don't do this */
 		  if(SiS_Pr->SiS_VBType & VB_SIS30xB) {
 		     if(SiS_Pr->SiS_VBInfo & SetInSlaveMode) ARdata = 0;
@@ -2568,17 +2692,31 @@ SiS_SetCRT1FIFO_310(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
    modeflag = SiS_GetModeFlag(SiS_Pr, ModeNo, ModeIdIndex);
 
    SiS_SetReg(SiS_Pr->SiS_P3c4,0x08,0xAE);
-   SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x09,0xF0);
+
+   if(SiS_Pr->ChipType == SIS_662){
+       SiS_SetRegANDOR(SiS_Pr->SiS_P3c4,0x09,0xA0,0x0B);       
+   }else if(SiS_Pr->ChipType < SIS_662){
+   	SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x09,0xF0);
+   }else if((ModeNo == 0x6b) || (ModeNo == 0x6e) ){ /*2048x1536 (0x6c), 1920x1440(0x68) for newer chip than 662*/
+   	SiS_SetReg(SiS_Pr->SiS_P3c4,0x08,0x03);
+   	SiS_SetReg(SiS_Pr->SiS_P3c4,0x09,0x07);
+   }
+   
    if(ModeNo > 0x13) {
       if(SiS_Pr->ChipType >= XGI_20) {
 	 SiS_SetReg(SiS_Pr->SiS_P3c4,0x08,0x34);
 	 SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x3D,0x01);
-      } else if(SiS_Pr->ChipType >= SIS_661) {
+      } else if(SiS_Pr->ChipType >= SIS_661&&SiS_Pr->ChipType <= SIS_761) {
 	 if(!(modeflag & HalfDCLK)) {
 	    SiS_SetReg(SiS_Pr->SiS_P3c4,0x08,0x34);
 	    SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x3D,0x01);
 	 }
-      } else {
+      } else if(SiS_Pr->ChipType >= SIS_662){
+	 if(!(modeflag & HalfDCLK)) {
+	    SiS_SetReg(SiS_Pr->SiS_P3c4,0x08,0x10);
+	    SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x3D,0x01);
+	 }
+      }else{
 	 if((!(modeflag & DoubleScanMode)) || (!(modeflag & HalfDCLK))) {
 	    SiS_SetReg(SiS_Pr->SiS_P3c4,0x08,0x34);
 	    SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x3D,0x01);
@@ -3136,8 +3274,8 @@ SiS_StrangeStuff(struct SiS_Private *SiS_Pr)
     * this here.
     */
 #ifdef SIS315H
-   if((IS_SIS651) || (IS_SISM650) ||
-      SiS_Pr->ChipType == SIS_340 ||
+   if((SiS_Pr->SiS_SysFlags & SF_Is65x) ||
+      SiS_Pr->ChipType == SIS_340       ||
       SiS_Pr->ChipType == XGI_40) {
       SiS_SetReg(SiS_Pr->SiS_VidCapt, 0x3f, 0x00);   /* Fiddle with capture regs */
       SiS_SetReg(SiS_Pr->SiS_VidCapt, 0x00, 0x00);
@@ -3203,22 +3341,24 @@ SiS_Handle760(struct SiS_Private *SiS_Pr)
 /*********************************************/
 
 #ifdef SIS_XORG_XF86
-static void
+void
 SiS_SetPitchCRT1(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn)
 {
    SISPtr pSiS = SISPTR(pScrn);
    unsigned short HDisplay = pSiS->scrnPitch >> 3;
 
+   if(SiS_GetReg(SiS_Pr->SiS_P3c4,0x06) & 0x20) HDisplay <<= 1;
+
    SiS_SetReg(SiS_Pr->SiS_P3d4,0x13,(HDisplay & 0xFF));
    SiS_SetRegANDOR(SiS_Pr->SiS_P3c4,0x0E,0xF0,(HDisplay >> 8));
 }
 
-static void
+void
 SiS_SetPitchCRT2(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn)
 {
    SISPtr pSiS = SISPTR(pScrn);
-   unsigned short HDisplay = pSiS->scrnPitch2 >> 3;
-
+   unsigned short HDisplay = pSiS->scrnPitch >> 3;
+   
     /* Unlock CRT2 */
    if(pSiS->VGAEngine == SIS_315_VGA)
       SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x2F, 0x01);
@@ -3403,7 +3543,7 @@ SiSSetMode(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 
 	 SiS_SetReg(SiS_Pr->SiS_P3d4,0x38,backupreg);
 
-	 if((IS_SIS650) && (SiS_GetReg(SiS_Pr->SiS_P3d4,0x30) & 0xfc)) {
+	 if((SiS_Pr->ChipType == SIS_650) && (SiS_GetReg(SiS_Pr->SiS_P3d4,0x30) & 0xfc)) {
 	    if((ModeNo == 0x03) || (ModeNo == 0x10)) {
 	       SiS_SetRegOR(SiS_Pr->SiS_P3d4,0x51,0x80);
 	       SiS_SetRegOR(SiS_Pr->SiS_P3d4,0x56,0x08);
diff --git a/src/init.h b/src/init.h
index 4f5c06d..618ed58 100644
--- a/src/init.h
+++ b/src/init.h
@@ -70,9 +70,6 @@
 #ifdef SIS_LINUX_KERNEL
 #include "vgatypes.h"
 #include "vstruct.h"
-#ifdef SIS_CP
-#undef SIS_CP
-#endif
 #include <linux/config.h>
 #include <linux/version.h>
 #include <linux/types.h>
@@ -121,12 +118,14 @@ static const unsigned short ModeIndex_1280x854[]     = {0x1a, 0x1b, 0x00, 0x1c};
 static const unsigned short ModeIndex_1360x768[]     = {0x48, 0x4b, 0x00, 0x4e};
 static const unsigned short ModeIndex_300_1360x1024[]= {0x67, 0x6f, 0x00, 0x72};  /* 300 series, BARCO only */
 static const unsigned short ModeIndex_1400x1050[]    = {0x26, 0x27, 0x00, 0x28};  /* 315 series only */
+static const unsigned short ModeIndex_1440x900[]     = {0x55, 0x67, 0x00, 0x6f};  /* 315 series only */
 static const unsigned short ModeIndex_1680x1050[]    = {0x17, 0x18, 0x00, 0x19};  /* 315 series only */
 static const unsigned short ModeIndex_1600x1200[]    = {0x3c, 0x3d, 0x00, 0x66};
 static const unsigned short ModeIndex_1920x1080[]    = {0x2c, 0x2d, 0x00, 0x73};  /* 315 series only */
 static const unsigned short ModeIndex_1920x1440[]    = {0x68, 0x69, 0x00, 0x6b};
 static const unsigned short ModeIndex_300_2048x1536[]= {0x6c, 0x6d, 0x00, 0x00};
 static const unsigned short ModeIndex_310_2048x1536[]= {0x6c, 0x6d, 0x00, 0x6e};
+static const unsigned short ModeIndex_LVDS_1366x768[]= {0x72, 0x7b, 0x00, 0x7f};/*1366x768, 315+307LV ,Ivans@090109*/
 
 static const unsigned short SiS_DRAMType[17][5]={
 	{0x0C,0x0A,0x02,0x40,0x39},
@@ -292,7 +291,10 @@ static const struct SiS_ModeResInfo_S SiS_ModeResInfo[] =
 	{ 1920,1080, 8,16},   /* 0x1f */
 	{  960, 540, 8,16},   /* 0x20 */
 	{  960, 600, 8,16},   /* 0x21 */
-	{ 1280, 854, 8,16}    /* 0x22 */
+	{ 1280, 854, 8,16},   /* 0x22 */
+	{ 1440, 900, 8,16},   /* 0x23 */
+	{ 1920,1200, 8,16},   /* 0x24 */
+        { 1366, 768, 8,16}    /* 0x25 */ /*Ivans@090109*/
 };
 
 #if defined(SIS300) || defined(SIS315H)
@@ -767,7 +769,7 @@ static const unsigned char SiS_PALTiming[] = {
 };
 
 static const unsigned char SiS_HiTVExtTiming[] = {
-	0x32,0x65,0x2c,0x5f,0x08,0x31,0x3a,0x64,
+	0x2a,0x5d,0x2c,0x5f,0x08,0x31,0x3a,0x64,
 	0x28,0x02,0x01,0x3d,0x06,0x3e,0x35,0x6d,
 	0x06,0x14,0x3e,0x35,0x6d,0x00,0xc5,0x3f,
 	0x64,0x90,0x33,0x8c,0x18,0x36,0x3e,0x13,
@@ -868,7 +870,8 @@ static const struct SiS_TVData SiS_ExtPALData[] =
  {    3,   2,1080, 619,1270, 540, 438, 0, 438,    0,0xf3,0x00,0x1d,0x20},  /* 720x576 */
  {    1,   1,1170, 821,1270, 520, 686, 0, 686,    0,0xF3,0x00,0x1D,0x20},  /* 1024x768 625i */
  {    1,   1,1170, 821,1270, 520, 686, 0, 686,    0,0xF3,0x00,0x1D,0x20},  /* 1024x768 625p */
- {    9,   4, 848, 528,1270, 530,   0, 0,  50,    0,0xf5,0xfb,0x1b,0x2a}   /* 720x480 */
+ {    9,   4, 848, 528,1270, 530,   0, 0,  50,    0,0xf5,0xfb,0x1b,0x2a},  /* 720x480 */
+ {    3,   2,1272, 566,1270, 530,   0, 0,  50,    0,0xf5,0xfb,0x1b,0x2a}   /* 848x480, 856x480 */
 };
 
 static const struct SiS_TVData SiS_StNTSCData[] =
@@ -890,8 +893,10 @@ static const struct SiS_TVData SiS_ExtNTSCData[] =
  {  143, 120,1056, 643,1270, 440,   0, 1,   0,    0,0xf4,0x10,0x1c,0x00},  /* 800x600, 400x300 */
  {  143, 120,1100, 643,1270, 440,   0, 1,   0,    0,0xf4,0x10,0x1c,0x00},  /* 720x576 */
  {    1,   1,1100, 811,1412, 440,   0, 1,   0,    0,0xee,0x0c,0x22,0x08},  /* 1024x768 (525i) */
- {    1,   1,1100, 846,1270, 440, 455, 0,   0,    0,0x00,0x00,0x00,0x00},  /* 1024x768 (525p) */
+ {   55,  54,1125, 846,1270, 440, 455, 0,   0,    0,0x00,0x00,0x00,0x00},  /* 1024x768 (525p_karma) */
  {  143,  76, 836, 523,1270, 440,   0, 1,   0,    0,0xee,0x0c,0x22,0x08},  /* 720x480 */
+ {  143, 120,1320, 560,1270, 440,   0, 0,   0,    0,0xf1,0x05,0x1f,0x16},  /* 848x480, 856x480 */
+ {    1,   1,1093, 811,1412, 440,   0, 1,   0,    0,0xee,0x0c,0x22,0x08}   /*1024x768 (karma spec.)*/
 };
 
 static const struct SiS_TVData SiS_StHiTVData[] =  /* Slave + TVSimu */
@@ -929,6 +934,9 @@ static const struct SiS_TVData SiS_ExtHiTVData[] =
  {    8,   5, 0x6d6,0x323,0x670,0x3c0,0x128, 0, 0, 0, 0, 0, 0, 0},  /* 1280x720  */
  {    8,   3,  1260,  851, 1648,  960,   50, 0, 0, 0, 0, 0, 0, 0},  /* 960x600  */
  {    4,   1,  1050,  600, 1920, 1080,   50, 0, 0, 0, 0, 0, 0, 0},  /* 960x540  */
+ {    0,   0,     0,    0,    0,    0,    0, 0, 0, 0, 0, 0, 0, 0},
+ {    4,   1, 0x41a,0x233,0x60c,0x3c0,0x143, 1, 0, 0, 0, 0, 0, 0},  /* 848x480   */
+ {    4,   1, 0x41a,0x233,0x60c,0x3c0,0x143, 1, 0, 0, 0, 0, 0, 0},  /* 856x480   */
 };
 
 static const struct SiS_TVData SiS_St525pData[] =
@@ -960,7 +968,7 @@ static const struct SiS_TVData SiS_Ext750pData[] =
  {    2,  1, 1100, 562, 1130, 640,   0, 1, 0, 0, 0, 0, 0, 0},  /* 720x480 */
  {    1,  1, 1375, 878, 1130, 640, 638, 0, 0, 0, 0, 0, 0, 0},  /* 1024x768 */
  {    5,  3, 1100, 675, 1130, 640,   0, 1, 0, 0, 0, 0, 0, 0},  /* 720/768x576 */
- {    2,  1, 1100, 590, 1130, 640,  50, 0, 0, 0, 0, 0, 0, 0},  /* 800x480 */
+ {    2,  1, 1100, 590, 1130, 640,  50, 0, 0, 0, 0, 0, 0, 0},  /* 800/848/856x480 */
  {    5,  3, 1100, 675, 1130, 640,   0, 1, 0, 0, 0, 0, 0, 0},  /* 1024x576 */
 #ifdef OLD1280720P
  {   25, 24, 1496, 755, 1120, 680,  50, 0, 0, 0, 0, 0, 0, 0}   /* 1280x720 */
@@ -1068,6 +1076,38 @@ static const struct SiS_LCDData SiS_LCD1280x800_2Data[] = /* 2.03.00 (LVDS) */
 	{  97,   90, 1600,  730, 1552,  812 }  /* 1280x720 */
 };
 
+/*Ivans add 1440x900 */
+static const struct SiS_LCDData SiS_LCD1440x900Data[] =
+{
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{165,52,1040,488,1760,912},/*Index=0x04, 640x480*/
+	{ 55,21,1008,609,1760,912 },/*Index=0x05, 800x600*/
+	{ 165,112,1400,776,1760,912 }, /*Index=0x06,1024x768*/
+	{0,0,0,0,0,0},
+	{ 211,166,1552,808,1760,912 },/*Index=0x08,1280x800 no any match timing.*/
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{ 1,1,1760,912,1760,912 } /*VGA 1440x900, LCD 1440x900.Index=14=0x0E*/
+};
+/*1366x768. Ivans@090109*/
+static const struct SiS_LCDData SiS_LCD1366x768Data[] =
+{       
+	{1, 1, 1528, 790, 1528, 790 },/*1366x768. Index=0x00.*/
+        {0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{0,0,0,0,0,0},
+	{191,175,1792,608,1528,790},/*800x600. Index=0x05*/
+	{191, 144, 1152, 790, 1528, 790 }/*1024x768. Index=0x06*/
+};
+/*Ivans@090109*/
+
 #if 0
 static const struct SiS_LCDData SiS_LCD1280x800_3Data[] = /* 2.02.05a (LVDS); m250 */
 {
@@ -1136,6 +1176,7 @@ static const struct SiS_LCDData SiS_StLCD1400x1050Data[] =
 	{   0,    0,    0,    0,    0,    0 },
 	{   0,    0,    0,    0,    0,    0 },
 	{   0,    0,    0,    0,    0,    0 },
+	{   0,    0,    0,    0,    0,    0 },
 	{   0,    0,    0,    0,    0,    0 }
 };
 
@@ -1157,6 +1198,7 @@ static const struct SiS_LCDData SiS_ExtLCD1400x1050Data[] =
 	{ 211,  120, 1400,  730, 1688, 1066 }, /* 1280x720 */
 	{   0,    0,    0,    0,    0,    0 },
 	{   0,    0,    0,    0,    0,    0 },
+	{   0,    0,    0,    0,    0,    0 },
 	{   0,    0,    0,    0,    0,    0 }
 };
 
@@ -1175,7 +1217,8 @@ static const struct SiS_LCDData SiS_LCD1680x1050Data[] =
 	{  13,    9, 1900,  739, 1900, 1066 }, /* 10 1280x720 */
 	{  95,   94, 1880, 1066, 1900, 1066 }, /* 11 1400x1050 patch index */
 	{   1,    1, 1900, 1066, 1900, 1066 }, /* 12 1680x1050 */
-	{   0,    0,    0,    0,    0,    0 }
+	{   0,    0,    0,    0,    0,    0 }, /* 13 1280x854 */
+	{   0,    0,    0,    0,    0,    0 }, /* 14 1440x900 */
 };
 
 static const struct SiS_LCDData SiS_StLCD1600x1200Data[] =
@@ -1193,6 +1236,7 @@ static const struct SiS_LCDData SiS_StLCD1600x1200Data[] =
 	{ 0,  0,   0,   0,    0,    0 },
 	{ 0,  0,   0,   0,    0,    0 },
 	{ 0,  0,   0,   0,    0,    0 },
+	{ 0,  0,   0,   0,    0,    0 },
 	{ 0,  0,   0,   0,    0,    0 }
 };
 
@@ -1213,6 +1257,7 @@ static const struct SiS_LCDData SiS_ExtLCD1600x1200Data[] =
 	{ 0, 0,   0,   0,    0,    0 },
 	{ 0, 0,   0,   0,    0,    0 },
 	{ 0, 0,   0,   0,    0,    0 },
+	{ 0, 0,   0,   0,    0,    0 },
 	{ 0, 0,   0,   0,    0,    0 }
 };
 
@@ -1251,7 +1296,9 @@ static const struct SiS_LCDData SiS_NoScaleData[] =
 	{ 1, 1,1408, 816,1408, 816 },  /* 0x1f: 1280x800 (TMDS special) */
 	{ 1, 1,1760,1235,1760,1235 },  /* 0x20: 1600x1200 for LCDA */
 	{ 1, 1,2048,1320,2048,1320 },  /* 0x21: 1600x1200 for non-SiS LVDS */
-	{ 1, 1,1664, 861,1664, 861 }   /* 0x22: 1280x854 */
+	{ 1, 1,1664, 861,1664, 861 },  /* 0x22: 1280x854 */
+	{ 1, 1,1760, 912,1760, 912 },  /* 0x23: 1400x900 */
+	{ 1, 1,1528, 790,1528, 790}    /* 0x24: 1366x768. Ivans@090109*/
 };
 
 /**************************************************************/
@@ -1585,6 +1632,8 @@ BOOLEAN		SiSBIOSSetModeCRT2(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn,
 				DisplayModePtr mode, BOOLEAN IsCustom);
 BOOLEAN		SiSBIOSSetModeCRT1(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn,
 				DisplayModePtr mode, BOOLEAN IsCustom);
+void		SiS_SetPitchCRT1(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn);
+void		SiS_SetPitchCRT2(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn);
 #endif
 #ifdef SIS_LINUX_KERNEL
 BOOLEAN		SiSSetMode(struct SiS_Private *SiS_Pr, unsigned short ModeNo);
diff --git a/src/init301.c b/src/init301.c
index 6bb52d2..a225208 100644
--- a/src/init301.c
+++ b/src/init301.c
@@ -140,6 +140,7 @@ SiS_SetRegSR11ANDOR(struct SiS_Private *SiS_Pr, unsigned short DataAND,
 /*********************************************/
 
 #ifdef SIS315H
+/* This function is used to get vesa timeing table offset in VBIOS*/
 static unsigned char *
 GetLCDStructPtr661(struct SiS_Private *SiS_Pr)
 {
@@ -160,21 +161,33 @@ GetLCDStructPtr661(struct SiS_Private *SiS_Pr)
 
       if(SiS_Pr->ChipType < SIS_661) reg = 0x3c;
       else                           reg = 0x7d;
-
-      idx = (SiS_GetReg(SiS_Pr->SiS_P3d4,reg) & 0x1f) * 26;
-
-      if(idx < (8*26)) {
-         myptr = (unsigned char *)&SiS_LCDStruct661[idx];
+      if(SiS_Pr->ChipType >= SIS_761)
+      {
+          idx = (SiS_GetReg(SiS_Pr->SiS_P3d4,reg) & 0x1f) * 25;
+          romindex = SISGETROMW(0x9a);
+          if(romindex) {
+              romindex += idx;
+              myptr = &ROMAddr[romindex];
+          }	
       }
-      romindex = SISGETROMW(0x100);
-      if(romindex) {
-         romindex += idx;
-         myptr = &ROMAddr[romindex];
+      else
+      {
+          idx = (SiS_GetReg(SiS_Pr->SiS_P3d4,reg) & 0x1f) * 26;
+          if(idx < (8*26)) {
+              myptr = (unsigned char *)&SiS_LCDStruct661[idx];
+          }
+          romindex = SISGETROMW(0x100);
+          if(romindex) {
+              romindex += idx;
+              myptr = &ROMAddr[romindex];
+          }	
       }
    }
    return myptr;
 }
 
+
+/* This function is used to get LCDID table offset in VBIOS*/
 static unsigned short
 GetLCDStructPtr661_2(struct SiS_Private *SiS_Pr)
 {
@@ -187,15 +200,25 @@ GetLCDStructPtr661_2(struct SiS_Private *SiS_Pr)
     * of machines with a 301C and a panel that does not support DDC)
     * use the BIOS data as well.
     */
-
-   if((SiS_Pr->SiS_ROMNew) &&
-      ( (SiS_Pr->SiS_VBType & VB_SISLVDS) ||
-        (!SiS_Pr->PanelSelfDetected) )) {
-      romptr = SISGETROMW(0x102);
-      romptr += ((SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) >> 4) * SiS_Pr->SiS661LCD2TableSize);
-   }
-
-   return romptr;
+    if(SiS_Pr->ChipType < SIS_761)
+    {
+        if((SiS_Pr->SiS_ROMNew) &&
+         ( (SiS_Pr->SiS_VBType & VB_SISLVDS) ||
+         (!SiS_Pr->PanelSelfDetected) )) {
+            romptr = SISGETROMW(0x102);
+            romptr += ((SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) >> 4) * SiS_Pr->SiS661LCD2TableSize);
+        }
+    }
+    else
+    {
+        if((SiS_Pr->SiS_ROMNew) &&
+          ( (SiS_Pr->SiS_VBType & VB_SISLVDS) ||
+          (!SiS_Pr->PanelSelfDetected) )) {
+          romptr = SISGETROMW(0x9c);
+          romptr += ((SiS_GetReg(SiS_Pr->SiS_P3d4,0x39) & 0x7C)>>2)*SiS_Pr->SiS661LCD2TableSize;
+        }
+    }
+    return romptr;
 }
 #endif
 
@@ -755,7 +778,9 @@ SiS_IsDualLink(struct SiS_Private *SiS_Pr)
    if(SiS_Pr->ChipType >= SIS_315H) {
       if((SiS_CRT2IsLCD(SiS_Pr)) ||
          (SiS_IsVAMode(SiS_Pr))) {
+         if(SiS_CheckLVDS( SiS_Pr)){ /* karma@080401 check LVDS to enable DualLink */
 	 if(SiS_Pr->SiS_LCDInfo & LCDDualLink) return TRUE;
+         }
       }
    }
 #endif
@@ -876,14 +901,10 @@ SiS_IsLCDOrLCDA(struct SiS_Private *SiS_Pr)
 static BOOLEAN
 SiS_HaveBridge(struct SiS_Private *SiS_Pr)
 {
-   unsigned short flag;
-
-   if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {
+   if((SiS_Pr->SiS_IF_DEF_LVDS == 1) || (SiS_Pr->SiS_VBType & VB_SISVB)) {
       return TRUE;
-   } else if(SiS_Pr->SiS_VBType & VB_SISVB) {
-      flag = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x00);
-      if((flag == 1) || (flag == 2)) return TRUE;
    }
+
    return FALSE;
 }
 
@@ -986,7 +1007,7 @@ SiS_GetVBInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo,
 		 /* Reset LCDA setting if not driver mode */
 		 SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x38,0xfc);
 	      }
-	      if(IS_SIS650) {
+	      if(SiS_Pr->ChipType == SIS_650) {
 		 if(SiS_Pr->SiS_UseLCDA) {
 		    if(SiS_GetReg(SiS_Pr->SiS_P3d4,0x5f) & 0xF0) {
 		       if((ModeNo <= 0x13) || (!(SiS_GetReg(SiS_Pr->SiS_P3d4,0x31) & (DriverMode >> 8)))) {
@@ -1510,6 +1531,9 @@ SiS_GetLCDInfoBIOS(struct SiS_Private *SiS_Pr)
 #endif
 
    if((ROMAddr = GetLCDStructPtr661(SiS_Pr))) {
+      #ifdef TWDEBUG	   
+      xf86DrvMsg(0,X_INFO,"[GetLCDStructPtr661==ROMAddr]:Enter if loop.\n");
+      #endif
       if((temp = SISGETROMW(6)) != SiS_Pr->PanelHT) {
 	 SiS_Pr->SiS_NeedRomModeData = TRUE;
 	 SiS_Pr->PanelHT  = temp;
@@ -1523,13 +1547,27 @@ SiS_GetLCDInfoBIOS(struct SiS_Private *SiS_Pr)
       SiS_Pr->PanelVRS = SISGETROMW(14);
       SiS_Pr->PanelVRE = SISGETROMW(16);
       SiS_Pr->PanelVCLKIdx315 = VCLK_CUSTOM_315;
-      SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].CLOCK =
-	 SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].CLOCK = (unsigned short)((unsigned char)ROMAddr[18]);
-      SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].SR2B =
-	 SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].Part4_A = ROMAddr[19];
-      SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].SR2C =
-	 SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].Part4_B = ROMAddr[20];
-
+      if(SiS_Pr->ChipType < SIS_761)
+      {
+          SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].CLOCK =
+	  SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].CLOCK = (unsigned short)((unsigned char)ROMAddr[18]);
+          SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].SR2B =
+	  SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].Part4_A = ROMAddr[19];
+          SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].SR2C =
+	  SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].Part4_B = ROMAddr[20];	  
+      }
+      else
+      {
+        #ifdef TWDEBUG
+	      xf86DrvMsg(0,X_INFO,"[ VCLK_CUSTOM_315.CLOCK==ROMAddr[20] ]:Enter else loop.\n");
+        #endif      
+	  SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].CLOCK =
+	  SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].CLOCK = (unsigned short)((unsigned char)ROMAddr[20]);
+          SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].SR2B =
+	  SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].Part4_A = ROMAddr[18];
+          SiS_Pr->SiS_VCLKData[VCLK_CUSTOM_315].SR2C =
+	  SiS_Pr->SiS_VBVCLKData[VCLK_CUSTOM_315].Part4_B = ROMAddr[19];	  
+      }
 #ifdef SIS_XORG_XF86
 #ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "Paneldata BIOS:  [%d %d] [H %d %d] [V %d %d] [C %d 0x%02x 0x%02x]\n",
@@ -1623,6 +1661,10 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
   }
 #endif
 
+#ifdef TWDEBUG
+  xf86DrvMsg(0,X_INFO,"[SiS_GetLCDResInfo]:Panel661=0x%x,Panel_ID=0x%x,ModeNo=0x%x,ModeIdIndex=0x%x,modeflag=0x%x.\n",temp,SiS_Pr->SiS_LCDTypeInfo,ModeNo,ModeIdIndex,modeflag);
+#endif
+
   /* Translate to our internal types */
 #ifdef SIS315H
   if(SiS_Pr->ChipType == SIS_550) {
@@ -1638,15 +1680,28 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
      if(temp == Panel310_1280x768) {
         temp = Panel_1280x768_2;
      }
+     if((temp == Panel661_Custom) && (SiS_Pr->SiS_LCDTypeInfo == Panel661_Custom)){
+        temp = Panel_1366x768; /*1366x768 translated from 0x0f.(not used ROM) Ivans@090109*/
+     }
+     if(temp == Panel661_640x480){ /*for SiS_ROMNew failed. Ivans@161208*/
+        temp =Panel_1440x900;      /*new X (X7.4,Xserver1.5)on Ubuntu810*/
+     }                             /*it caused the ROM found failed.(TODO PCI_REWORK)*/
      if(SiS_Pr->SiS_ROMNew) {
 	if(temp == Panel661_1280x800) {
 	   temp = Panel_1280x800_2;
 	}
+	if(temp == Panel661_640x480){ /* Ivans add CR36 translate 1440x900. */
+	   temp = Panel_1440x900;
+	}
      }
   }
 
   SiS_Pr->SiS_LCDResInfo = temp;
 
+#ifdef TWDEBUG
+  xf86DrvMsg(0,X_INFO,"[SiS_GetLCDResInfo]:SiS_LCDResInfo=0x%x. \n",SiS_Pr->SiS_LCDResInfo);
+#endif
+
 #ifdef SIS300
   if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {
      if(SiS_Pr->SiS_CustomT == CUT_BARCO1366) {
@@ -1659,6 +1714,19 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
   }
 #endif
 
+  /* chaoyu add: we try to support 800x600 panel on 302LV */
+   if(SiS_Pr->SiS_VBType & (VB_SIS302LV | VB_SIS302ELV)){
+#ifdef SISMERGED
+   	if(!(SiS_Pr->MergedFB))	/* ToDo: Single LCD should be added */
+#endif
+		SiS_Pr->SiS_PanelMin301 = Panel_800x600;
+#ifdef SISMERGED
+	else
+		SiS_SetReg(SiS_Pr->SiS_P3d4, 0x7d, 0x00);
+#endif
+   }
+
+   
   if(SiS_Pr->SiS_VBType & VB_SISVB) {
      if(SiS_Pr->SiS_LCDResInfo < SiS_Pr->SiS_PanelMin301)
 	SiS_Pr->SiS_LCDResInfo = SiS_Pr->SiS_PanelMin301;
@@ -1671,6 +1739,10 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
   SiS_Pr->SiS_LCDInfo = temp & ~0x000e;
   /* Need temp below! */
 
+#ifdef TWDEBUG
+ xf86DrvMsg(0,X_INFO,"[SiS_GetLCDResInfo]:SiS_CR37_LCDInfo_RECORD=0x%x.\n",temp);
+#endif
+
   /* These must/can't scale no matter what */
   switch(SiS_Pr->SiS_LCDResInfo) {
   case Panel_320x240_1:
@@ -1696,10 +1768,16 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
      }
      if(SiS_Pr->SiS_VBType & VB_SISDUALLINK) {
 	if(SiS_Pr->SiS_ROMNew) {
-	   if(temp & 0x02) SiS_Pr->SiS_LCDInfo |= LCDDualLink;
+	    if(SiS_Pr->ChipType < SIS_761){
+	        if((temp & 0x02) && SiS_CheckLVDS(SiS_Pr)) SiS_Pr->SiS_LCDInfo |= LCDDualLink;/* karma@080401 check LVDS to enable DualLink */
+	    }else{
+      	    if((temp & 0x04) && SiS_CheckLVDS(SiS_Pr)) SiS_Pr->SiS_LCDInfo |= LCDDualLink;/* karma@080401 check LVDS to enable DualLink */
+	    }
 	} else if((myptr = GetLCDStructPtr661(SiS_Pr))) {
-	   if(myptr[2] & 0x01) SiS_Pr->SiS_LCDInfo |= LCDDualLink;
-	}
+	   if((myptr[2] & 0x01) && SiS_CheckLVDS(SiS_Pr)) SiS_Pr->SiS_LCDInfo |= LCDDualLink;/* karma@080401 check LVDS to enable DualLink */
+	} else if(SiS_Pr->SiS_LCDResInfo == Panel_1440x900){/*for ROMNew failed. Ivans@161208*/
+       if(SiS_CheckLVDS(SiS_Pr)) SiS_Pr->SiS_LCDInfo |= LCDDualLink;/*it caused panel blur.*/
+    }
      }
   } else if(SiS_Pr->ChipType >= SIS_315H) {
      if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) {
@@ -1710,18 +1788,20 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
 	temp = SiS_GetReg(SiS_Pr->SiS_P3d4,0x35);
 	if(temp & 0x01) SiS_Pr->SiS_LCDInfo |= LCDRGB18Bit;
 	if(SiS_Pr->SiS_VBType & VB_SISDUALLINK) {
-	   if(temp & 0x02) SiS_Pr->SiS_LCDInfo |= LCDDualLink;
+	   if((temp & 0x02) && SiS_CheckLVDS(SiS_Pr)) SiS_Pr->SiS_LCDInfo |= LCDDualLink;/* karma@080401 check LVDS to enable DualLink */
 	}
      } else if(!(SiS_Pr->SiS_ROMNew)) {
 	if(SiS_Pr->SiS_VBType & VB_SISDUALLINK) {
 	   if((SiS_Pr->SiS_CustomT == CUT_CLEVO1024) &&
-	      (SiS_Pr->SiS_LCDResInfo == Panel_1024x768)) {
+	      (SiS_Pr->SiS_LCDResInfo == Panel_1024x768) && 
+	       SiS_CheckLVDS(SiS_Pr)) {/* karma@080401 check LVDS to enable DualLink */
 	      SiS_Pr->SiS_LCDInfo |= LCDDualLink;
 	   }
-	   if((SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) ||
+	   if(((SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) ||
 	      (SiS_Pr->SiS_LCDResInfo == Panel_1400x1050) ||
 	      (SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) ||
-	      (SiS_Pr->SiS_LCDResInfo == Panel_1680x1050)) {
+	      (SiS_Pr->SiS_LCDResInfo == Panel_1680x1050)) && 
+	      SiS_CheckLVDS(SiS_Pr)) {/* karma@080401 check LVDS to enable DualLink */
 	      SiS_Pr->SiS_LCDInfo |= LCDDualLink;
 	   }
 	}
@@ -1872,6 +1952,20 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
 			    SiS_Pr->PanelVCLKIdx315 = VCLK108_2_315;
 			    SiS_GetLCDInfoBIOS(SiS_Pr);
 			    break;
+     case Panel_1440x900:   SiS_Pr->PanelXRes = 1440; SiS_Pr->PanelYRes =  900;
+			    SiS_Pr->PanelHT   = 1760; SiS_Pr->PanelVT   =  912;
+			    SiS_Pr->PanelHRS  =   64; SiS_Pr->PanelHRE  =   32;
+			    SiS_Pr->PanelVRS  =    3; SiS_Pr->PanelVRE  =    3;
+			    SiS_Pr->PanelVCLKIdx315 = VCLKLCD1440_900;
+			    SiS_GetLCDInfoBIOS(SiS_Pr);
+			    break;
+     case Panel_1366x768:   SiS_Pr->PanelXRes = 1366; SiS_Pr->PanelYRes =  768;/*1366X768. Ivans@0910109*/
+			    SiS_Pr->PanelHT   = 1528; SiS_Pr->PanelVT   =  790;
+			    SiS_Pr->PanelHRS  =   48; SiS_Pr->PanelHRE  =   32;
+			    SiS_Pr->PanelVRS  =    2; SiS_Pr->PanelVRE  =    5;     
+			    SiS_Pr->PanelVCLKIdx315 = VCLKLCD1366_768;
+			    SiS_GetLCDInfoBIOS(SiS_Pr);
+			    break;
      case Panel_1600x1200:  SiS_Pr->PanelXRes = 1600; SiS_Pr->PanelYRes = 1200;
 			    SiS_Pr->PanelHT   = 2160; SiS_Pr->PanelVT   = 1250;
 			    SiS_Pr->PanelHRS  =   64; SiS_Pr->PanelHRE  =  192;
@@ -2098,17 +2192,26 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
 				  SiS_Pr->SiS_LCDInfo |= DontExpandLCD;
 			       }
 			       break;
-	case SIS_RI_1280x1024: SiS_Pr->SiS_LCDInfo |= DontExpandLCD;
-			       break;
 	}
 	break;
      }
+     case Panel_1440x900: {
+	static const unsigned char nonscalingmodes[] = {
+	   SIS_RI_720x480, SIS_RI_720x576, SIS_RI_768x576, SIS_RI_800x480, SIS_RI_848x480,
+	   SIS_RI_856x480, SIS_RI_960x540, SIS_RI_960x600, SIS_RI_1024x576,SIS_RI_1024x600,
+	   SIS_RI_1152x768,SIS_RI_1152x864,SIS_RI_1280x720,SIS_RI_1280x768,SIS_RI_1280x800,
+	   SIS_RI_1280x854,SIS_RI_1360x768,0xff
+	};
+	SiS_CheckScaling(SiS_Pr, resinfo, nonscalingmodes);
+	break;
+     }
      case Panel_1600x1200: {
 	static const unsigned char nonscalingmodes[] = {
 	     SIS_RI_720x480, SIS_RI_720x576, SIS_RI_768x576, SIS_RI_800x480, SIS_RI_848x480,
 	     SIS_RI_856x480, SIS_RI_960x540, SIS_RI_960x600, SIS_RI_1024x576,SIS_RI_1024x600,
 	     SIS_RI_1152x768,SIS_RI_1152x864,SIS_RI_1280x720,SIS_RI_1280x768,SIS_RI_1280x800,
-	     SIS_RI_1280x854,SIS_RI_1280x960,SIS_RI_1360x768,SIS_RI_1360x1024,0xff
+	     SIS_RI_1280x854,SIS_RI_1280x960,SIS_RI_1360x768,SIS_RI_1360x1024,SIS_RI_1440x900,
+	     0xff
 	};
 	SiS_CheckScaling(SiS_Pr, resinfo, nonscalingmodes);
 	break;
@@ -2118,6 +2221,16 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
 	     SIS_RI_720x480, SIS_RI_720x576, SIS_RI_768x576, SIS_RI_800x480, SIS_RI_848x480,
 	     SIS_RI_856x480, SIS_RI_960x540, SIS_RI_960x600, SIS_RI_1024x576,SIS_RI_1024x600,
 	     SIS_RI_1152x768,SIS_RI_1152x864,SIS_RI_1280x854,SIS_RI_1280x960,SIS_RI_1360x768,
+	     SIS_RI_1360x1024,SIS_RI_1440x900,0xff
+	};
+	SiS_CheckScaling(SiS_Pr, resinfo, nonscalingmodes);
+	break;
+     }
+     case Panel_1920x1200: {
+	static const unsigned char nonscalingmodes[] = {
+	     SIS_RI_720x480, SIS_RI_720x576, SIS_RI_768x576, SIS_RI_800x480, SIS_RI_848x480,
+	     SIS_RI_856x480, SIS_RI_960x540, SIS_RI_960x600, SIS_RI_1024x576,SIS_RI_1024x600,
+	     SIS_RI_1152x768,SIS_RI_1152x864,SIS_RI_1280x854,SIS_RI_1280x960,SIS_RI_1360x768,
 	     SIS_RI_1360x1024,0xff
 	};
 	SiS_CheckScaling(SiS_Pr, resinfo, nonscalingmodes);
@@ -2235,6 +2348,9 @@ SiS_GetLCDResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
   } else {
      SiS_Pr->SiS_SetFlag |= LCDVESATiming;
   }
+#ifdef TWDEBUG
+  xf86DrvMsg(0,X_INFO,"[SiS_GetLCDResInfo]:LCDInfo=0x%x from CR37.\n",SiS_Pr->SiS_LCDInfo);
+#endif
 
 #ifdef SIS_LINUX_KERNEL
 #if 0
@@ -2559,7 +2675,7 @@ SiS_SetCRT2ModeRegs(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
 	if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {
 	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x00,0xa0,tempah);
 	} else if(SiS_Pr->SiS_VBType & VB_SISVB) {
-	   if(IS_SIS740) {
+	   if(SiS_Pr->ChipType == SIS_740) {
 	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x00,tempah);
 	   } else {
 	      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x00,0xa0,tempah);
@@ -2692,7 +2808,7 @@ SiS_SetCRT2ModeRegs(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
 
 	/* 740 variants match for 30xB, 301B-DH, 30xLV */
 
-	if(!(IS_SIS740)) {
+	if(SiS_Pr->ChipType != SIS_740) {
 	   tempah = 0x04;						   /* For all bridges */
 	   tempbl = 0xfb;
 	   if(!(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA)) {
@@ -2713,7 +2829,9 @@ SiS_SetCRT2ModeRegs(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
 	 * chipset than the bridge revision.
 	 */
 
-	if((IS_SIS740) || (SiS_Pr->ChipType >= SIS_661) || (SiS_Pr->SiS_ROMNew)) {
+	if((SiS_Pr->ChipType == SIS_740) ||
+	   (SiS_Pr->ChipType >= SIS_661) ||
+	   (SiS_Pr->SiS_ROMNew)) {
 	   tempah = 0x30;
 	   tempbl = 0xc0;
 	   if((SiS_Pr->SiS_VBInfo & DisableCRT2Display) ||
@@ -2737,7 +2855,7 @@ SiS_SetCRT2ModeRegs(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
 	         tempah = tempah2 = 0x00;
 	   } else if(SiS_Pr->SiS_TVBlue == -1) {
 	      /* Set on 651/M650, clear on 315/650 */
-	      if(!(IS_SIS65x)) /* (bridgerev != 0xb0) */ {
+	      if(!(SiS_Pr->SiS_SysFlags & SF_Is65x)) /* (bridgerev != 0xb0) */ {
 	         tempah = tempah2 = 0x00;
 	      }
 	   }
@@ -2756,7 +2874,7 @@ SiS_SetCRT2ModeRegs(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
 	   SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x21,tempbl2,tempah2);
 	}
 
-	if(IS_SIS740) {
+	if(SiS_Pr->ChipType == SIS_740) {
 	   tempah = 0x80;
 	   if(SiS_Pr->SiS_VBInfo & DisableCRT2Display) tempah = 0x00;
 	   SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x23,0x7f,tempah);
@@ -2974,13 +3092,20 @@ SiS_GetCRT2Ptr(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 	}
 
 	if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) {
+	   if(SiS_Pr->SiS_LCDResInfo == Panel_1366x768){/*1366x768. Ivans@090109*/
+	      if (resinfo == SIS_RI_1366x768)  tempal = 2; /*1366x768 (1:1) */
+	      if (resinfo == SIS_RI_1024x768)  tempal = 1; /*1024 on 1366 Panel*/
+	      if (resinfo == SIS_RI_800x600 )  tempal = 0; /* 800 on 1366 Panel*/
+	   }	
 	   /* Pass 1:1 only (center-screen handled outside) */
 	   /* This is never called for the panel's native resolution */
 	   /* since Pass1:1 will not be set in this case */
-	   tempbx = 100;
-	   if(ModeNo >= 0x13) {
-	      tempal = SiS_Pr->SiS_RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC_NS;
-	   }
+	   else{
+            tempbx = 100;
+	    if(ModeNo >= 0x13) {
+	    tempal = SiS_Pr->SiS_RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC_NS;
+	    } 
+	  }
 	}
 
 #ifdef SIS315H
@@ -3040,12 +3165,23 @@ SiS_GetCRT2Ptr(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 	      tempal = 4;
 	      if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p) tempal = 9;
 	      break;
+	   case SIS_RI_848x480:
+	   case SIS_RI_856x480:
+	      tempal = 10;
+	      if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p) tempal = 9;
+	      break;
 	   case SIS_RI_512x384:
 	   case SIS_RI_1024x768:
 	      tempal = 7;
 	      if(SiS_Pr->SiS_TVMode & (TVSetYPbPr525p | TVSetYPbPr625p)) {
 	         tempal = 8;
 	      }
+		/*(karma)spec. for TV composite mode 1024x768*/
+		/*(karma) pathing for PAL */
+	      if((SiS_Pr->SiS_VBInfo & SetCRT2ToAVIDEO) && (SiS_Pr->ChipType > SIS_761)){
+	         if((SiS_Pr->SiS_TVMode & TVSetNTSC1024) || (SiS_Pr->SiS_TVMode & TVSetPALM))
+		 	 tempal = 11;
+	      }
 	      break;
 	   case SIS_RI_1280x720:
 	      if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p) tempal = 11;
@@ -3344,10 +3480,19 @@ SiS_GetCRT2Data301(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
 	 (resinfo661 >= 0)                     &&
 	 (SiS_Pr->SiS_NeedRomModeData) ) {
 	if((ROMAddr = GetLCDStructPtr661(SiS_Pr))) {
-	   if((romptr = (SISGETROMW(21)))) {
-	      romptr += (resinfo661 * 10);
-	      ROMAddr = SiS_Pr->VirtualRomBase;
-	   }
+	    if(SiS_Pr->ChipType < SIS_761)	
+	    {    if((romptr = (SISGETROMW(21)))) {
+	              romptr += (resinfo661 * 10);
+	              ROMAddr = SiS_Pr->VirtualRomBase;
+	          }
+	    }
+	    else
+	    {
+	          if((romptr = (SISGETROMW(22)))) {
+	              romptr += (resinfo661 * 7);
+	              ROMAddr = SiS_Pr->VirtualRomBase;
+	          }
+	    }
 	}
      }
 #endif
@@ -3484,7 +3629,11 @@ SiS_GetCRT2Data301(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
 
 	if(!(SiS_Pr->SiS_TVMode & TVSetPAL)) {
 	   SiS_Pr->SiS_HT = NTSCHT;
-	   if(SiS_Pr->SiS_TVMode & TVSetNTSC1024) SiS_Pr->SiS_HT = NTSC2HT;
+	   if(SiS_Pr->SiS_TVMode & TVSetNTSC1024){
+/*(karma) spec. for TV composite mode 1024x768*/
+	      if(SiS_Pr->SiS_VBInfo & SetCRT2ToAVIDEO)SiS_Pr->SiS_HT = NTSC3HT;
+	      else SiS_Pr->SiS_HT = NTSC2HT;
+	   }
 	   SiS_Pr->SiS_VT = NTSCVT;
 	} else {
 	   SiS_Pr->SiS_HT = PALHT;
@@ -3527,15 +3676,31 @@ SiS_GetCRT2Data301(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
 	   SiS_Pr->SiS_RVBHCFACT = ROMAddr[romptr+1];
 	   SiS_Pr->SiS_VGAHT     = ROMAddr[romptr+2] | ((ROMAddr[romptr+3] & 0x0f) << 8);
 	   SiS_Pr->SiS_VGAVT     = (ROMAddr[romptr+4] << 4) | ((ROMAddr[romptr+3] & 0xf0) >> 4);
-	   SiS_Pr->SiS_HT        = ROMAddr[romptr+5] | ((ROMAddr[romptr+6] & 0x0f) << 8);
-	   SiS_Pr->SiS_VT        = (ROMAddr[romptr+7] << 4) | ((ROMAddr[romptr+6] & 0xf0) >> 4);
-	   SiS_Pr->SiS_RVBHRS2   = ROMAddr[romptr+8] | ((ROMAddr[romptr+9] & 0x0f) << 8);
-	   if((SiS_Pr->SiS_RVBHRS2) && (modeflag & HalfDCLK)) {
-	      SiS_Pr->SiS_RVBHRS2 = ((SiS_Pr->SiS_RVBHRS2 + 3) >> 1) - 3;
-	      tempax = (ROMAddr[romptr+9] >> 4) & 0x07;
-	      if(ROMAddr[romptr+9] & 0x80) SiS_Pr->SiS_RVBHRS2 -= tempax;
-	      else                         SiS_Pr->SiS_RVBHRS2 += tempax;
-	   }
+	   if(SiS_Pr->ChipType<SIS_761)
+           {
+	       SiS_Pr->SiS_HT        = ROMAddr[romptr+5] | ((ROMAddr[romptr+6] & 0x0f) << 8);
+	       SiS_Pr->SiS_VT        = (ROMAddr[romptr+7] << 4) | ((ROMAddr[romptr+6] & 0xf0) >> 4);
+               SiS_Pr->SiS_RVBHRS2   = ROMAddr[romptr+8] | ((ROMAddr[romptr+9] & 0x0f) << 8);
+	       if((SiS_Pr->SiS_RVBHRS2) && (modeflag & HalfDCLK)) {
+	           SiS_Pr->SiS_RVBHRS2 = ((SiS_Pr->SiS_RVBHRS2 + 3) >> 1) - 3;
+	           tempax = (ROMAddr[romptr+9] >> 4) & 0x07;
+	       if(ROMAddr[romptr+9] & 0x80) SiS_Pr->SiS_RVBHRS2 -= tempax;
+	       else                         SiS_Pr->SiS_RVBHRS2 += tempax;
+	       }		   
+           }
+	   else
+           {    
+               SiS_Pr->SiS_HT        = SiS_Pr->PanelHT;
+               SiS_Pr->SiS_VT        = SiS_Pr->PanelVT;
+               SiS_Pr->SiS_RVBHRS2   = ROMAddr[romptr+5] | ((ROMAddr[romptr+6] & 0x0f) << 8);
+	       if((SiS_Pr->SiS_RVBHRS2) && (modeflag & HalfDCLK)) {
+	           SiS_Pr->SiS_RVBHRS2 = ((SiS_Pr->SiS_RVBHRS2 + 3) >> 1) - 3;
+	           tempax = (ROMAddr[romptr+6] >> 4) & 0x07;
+	       if(ROMAddr[romptr+6] & 0x80) SiS_Pr->SiS_RVBHRS2 -= tempax;
+	       else                         SiS_Pr->SiS_RVBHRS2 += tempax;
+	       }
+           }
+	   /*step2 (if above steps still not work, you change below infor to force not scaling)*/
 	   if(SiS_Pr->SiS_VGAHT) gotit = TRUE;
 	   else {
 	      SiS_Pr->SiS_LCDInfo |= DontExpandLCD;
@@ -3569,6 +3734,12 @@ SiS_GetCRT2Data301(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
 	      case Panel_1280x800  + 32: LCDPtr = SiS_Pr->SiS_LCD1280x800Data;      break;
 	      case Panel_1280x800_2    :
 	      case Panel_1280x800_2+ 32: LCDPtr = SiS_Pr->SiS_LCD1280x800_2Data;    break;
+              /*1366x768. Ivans@090109*/
+	      case Panel_1366x768      :
+              case Panel_1366x768  + 32: LCDPtr = SiS_Pr->SiS_LCD1366x768Data;      break;					
+	      /*Ivans add 1440x900.*/	 			 
+	      case Panel_1440x900      :
+	      case Panel_1440x900  + 32: LCDPtr = SiS_Pr->SiS_LCD1440x900Data;      break;				 
 	      case Panel_1280x854      :
 	      case Panel_1280x854  + 32: LCDPtr = SiS_Pr->SiS_LCD1280x854Data;      break;
 	      case Panel_1280x960      :
@@ -4055,7 +4226,7 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 		 SiS_DDC2Delay(SiS_Pr,0xe000);
 		 SiS_SetRegByte(SiS_Pr->SiS_P3c6,0x00);
 		 pushax = SiS_GetReg(SiS_Pr->SiS_P3c4,0x06);
-		 if(IS_SIS740) {
+		 if(SiS_Pr->ChipType == SIS_740) {
 		    SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x06,0xE3);
 		 }
 	         SiS_PanelDelay(SiS_Pr, 3);
@@ -4110,7 +4281,10 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 	      SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x32,0xDF);
 	      temp = SiS_GetReg(SiS_Pr->SiS_Part1Port,0x00);
 	      SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x00,0x10);
-	      SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x1E,0xDF);
+		/* chaoyu: We should not diable CRT2 here, since there 
+		    are some errors probably happening if we disable and 
+		    then enable(in SiS_EnableBridge) the bridge. */
+		/*SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x1E,0xDF);*/
 	      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x00,temp);
 
 	   }
@@ -4144,7 +4318,44 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 	   }
 
 #endif /* SIS315H */
-
+        if((SiS_Pr->SiS_VBType==VB2_307LV)||(SiS_Pr->SiS_VBType==VB2_307T))   /*chaoyu:(TODO) bug*/
+        {
+                if(SiS_Pr->SiS_VBInfo==SetCRT2ToLCD)
+                {  /*channel B disable*/
+                    /*disable channel B   part4, 0x1F[6]=1*/
+                    SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x1F,0x40); 
+                }
+                else if(SiS_Pr->SiS_VBInfo==SetCRT2ToLCDA){
+                    /*disable channel A  part4_30 [1]=0*/
+                    SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x30,0xFD); 
+                }
+		/*disable VB globle fun part2,0x00[5]=0*/
+                SiS_SetRegAND(SiS_Pr->SiS_Part2Port,0x00,~0x20); 
+
+		/*reset IGU output FIFO  part1,0x4C[4:3]=00*/
+                SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x4C,~0x18); 
+
+                if(SiS_Pr->SiS_VBInfo==SetCRT2ToLCD)
+                {  
+		    /*disable crt2 engine   SR1E[5]=0*/
+		    SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x1E,~0x10); 
+                }
+                else if(SiS_Pr->SiS_VBInfo==SetCRT2ToLCDA){
+                    /*disable CRT1  CR17[7]=0*/
+                    SiS_SetRegAND(SiS_Pr->SiS_P3d4,0x17,~0x80); 
+                }
+
+		/*reset IGU Pcie Plls    part1, 0x38[6]=0*/
+		SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x38,~0x40);
+
+		/*reset VB PCIE pll part4,0x4C[5]=0*/
+		SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x4C,~0x20);
+
+		/*reset IGU Pcie Pll   part1,0x38[5]=0*/
+		SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x38,~0x20);
+	    
+        }
+	
 	}
 
      } else {     /* ============ For 301 ================ */
@@ -4239,6 +4450,8 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 
 #ifdef SIS315H	/* 315 series */
 
+	SiS_UnLockCRT2(SiS_Pr);
+
 	if(!(SiS_IsNotM650orLater(SiS_Pr))) {
 	   /*if(SiS_Pr->ChipType < SIS_340) { */ /* XGI needs this */
 	      SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x4c,~0x18);
@@ -4276,8 +4489,10 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 	}
 
 	if(SiS_Pr->SiS_IF_DEF_CH70xx == 0) {
-	   SiS_SetRegSR11ANDOR(SiS_Pr,0xF7,0x08);
-	   SiS_PanelDelay(SiS_Pr, 3);
+	   if((SiS_Pr->SiS_CustomT != CUT_ICOP550) && (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
+	      SiS_SetRegSR11ANDOR(SiS_Pr,0xF7,0x08);
+	      SiS_PanelDelay(SiS_Pr, 3);
+	   }
 	}
 
 	if( (SiS_Pr->SiS_IF_DEF_CH70xx == 0)   ||
@@ -4308,8 +4523,10 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 	   if(SiS_CRT2IsLCD(SiS_Pr)) {
 	      SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x1e,0xdf);
 	      if(SiS_Pr->ChipType == SIS_550) {
-		 SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x1e,0xbf);
-		 SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x1e,0xef);
+		 if((SiS_Pr->SiS_CustomT != CUT_ICOP550) && (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
+		    SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x1e,0xbf);
+		    SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x1e,0xef);
+		 }
 	      }
 	   }
 	} else {
@@ -4330,22 +4547,22 @@ SiS_DisableBridge(struct SiS_Private *SiS_Pr)
 	   }
 	}
 
-	SiS_UnLockCRT2(SiS_Pr);
-
 	if(SiS_Pr->ChipType == SIS_550) {
 	   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x01,0x80); /* DirectDVD PAL?*/
 	   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x02,0x40); /* VB clock / 4 ? */
-	} else if( (SiS_Pr->SiS_IF_DEF_CH70xx == 0)   ||
+	} else if( (SiS_Pr->SiS_IF_DEF_CH70xx == 0) ||
 		   (!(SiS_IsDualEdge(SiS_Pr))) ||
 		   (!(SiS_IsVAMode(SiS_Pr))) ) {
 	   SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x2e,0xf7);
 	}
 
         if(SiS_Pr->SiS_IF_DEF_CH70xx == 0) {
-	   if(SiS_CRT2IsLCD(SiS_Pr)) {
-	      if(!(SiS_WeHaveBacklightCtrl(SiS_Pr))) {
-		 SiS_PanelDelay(SiS_Pr, 2);
-		 SiS_SetRegSR11ANDOR(SiS_Pr,0xFB,0x04);
+           if((SiS_Pr->SiS_CustomT != CUT_ICOP550) && (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
+	      if(SiS_CRT2IsLCD(SiS_Pr)) {
+		 if(!(SiS_WeHaveBacklightCtrl(SiS_Pr))) {
+		    SiS_PanelDelay(SiS_Pr, 2);
+		    SiS_SetRegSR11ANDOR(SiS_Pr,0xFB,0x04);
+		 }
 	      }
 	   }
         }
@@ -4469,22 +4686,25 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 	 }
 
 	 if(!(SiS_IsNotM650orLater(SiS_Pr))) {
-	    /*if(SiS_Pr->ChipType < SIS_340) { */
 	       tempah = 0x10;
 	       if(SiS_LCDAEnabled(SiS_Pr)) {
 		  if(SiS_TVEnabled(SiS_Pr)) tempah = 0x18;
 		  else			    tempah = 0x08;
 	       }
 	       SiS_SetReg(SiS_Pr->SiS_Part1Port,0x4c,tempah);
-	    /*}*/
 	 }
 
+         if(SiS_Pr->ChipType >= SIS_761){
+             SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x39,0x02);	 
+   	         SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x51,0x02);
+         }
+         
 	 if(SiS_Pr->SiS_VBType & VB_SISLVDS) {
 
 	    SiS_SetRegByte(SiS_Pr->SiS_P3c6,0x00);
 	    SiS_DisplayOff(SiS_Pr);
 	    pushax = SiS_GetReg(SiS_Pr->SiS_P3c4,0x06);
-	    if(IS_SIS740) {
+	    if(SiS_Pr->ChipType == SIS_740) {
 	       SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x06,0xE3);
 	    }
 
@@ -4515,8 +4735,8 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 
 	 }
 
-	 if(!(SiS_IsVAMode(SiS_Pr))) {
 
+	 if(!(SiS_IsVAMode(SiS_Pr))) {
 	    temp = SiS_GetReg(SiS_Pr->SiS_P3c4,0x32) & 0xDF;
 	    if(SiS_BridgeInSlavemode(SiS_Pr)) {
 	       tempah = SiS_GetReg(SiS_Pr->SiS_P3d4,0x30);
@@ -4525,9 +4745,10 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 	       }
 	    }
 	    SiS_SetReg(SiS_Pr->SiS_P3c4,0x32,temp);
-
+        SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x27,0x40);
+        SiS_GenericDelay(SiS_Pr, 17664);
 	    SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x1E,0x20);                   /* enable CRT2 */
-
+        SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x27,~0x40);
 	    SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x2e,0x7f);
 	    SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x2e,0x80);
 
@@ -4585,6 +4806,7 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 		     unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;
 		     unsigned short romptr = GetLCDStructPtr661_2(SiS_Pr);
 		     if(romptr) {
+		        SiS_WaitVBRetrace(SiS_Pr);
 			SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x30,0x20); /* Reset */
 			SiS_Pr->EMI_30 = 0;
 			SiS_Pr->EMI_31 = ROMAddr[romptr + SiS_Pr->SiS_EMIOffset + 0];
@@ -4688,6 +4910,7 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 		  }
 
 		  if(!(SiS_Pr->OverruleEMI && (!r30) && (!r31) && (!r32) && (!r33))) {
+		     SiS_WaitVBRetrace(SiS_Pr);
 		     SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x30,0x20); /* Reset */
 		     SiS_GenericDelay(SiS_Pr, 2048);
 		  }
@@ -4703,13 +4926,17 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 		      (SiS_CRT2IsLCD(SiS_Pr)) ) {
 		     if(r30 & 0x40) {
 			/*SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x2a,0x80);*/
-			SiS_PanelDelayLoop(SiS_Pr, 3, 5);
+			SiS_PanelDelayLoop(SiS_Pr, 3, 10);
 			if(delaylong) {
 			   SiS_PanelDelayLoop(SiS_Pr, 3, 5);
 			   delaylong = FALSE;
 			}
 			SiS_WaitVBRetrace(SiS_Pr);
 			SiS_WaitVBRetrace(SiS_Pr);
+			SiS_WaitVBRetrace(SiS_Pr);
+			SiS_WaitVBRetrace(SiS_Pr);
+			SiS_WaitVBRetrace(SiS_Pr);
+			SiS_WaitVBRetrace(SiS_Pr);
 			if(SiS_Pr->SiS_CustomT == CUT_ASUSA2H_2) {
 			   SiS_GenericDelay(SiS_Pr, 1280);
 			}
@@ -4732,10 +4959,11 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 		     SiS_GenericDelay(SiS_Pr, 2048);
 		     SiS_WaitVBRetrace(SiS_Pr);
 		  }
-		  if(!didpwd) {
+		  if(SiS_Pr->SiS_EnableBackLight) {
 		     SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x26,0x01);
-		  } else {
-		     SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x26,0x03);
+		  }
+		  if(didpwd) {
+		     SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x26,0x02);
 		  }
 	       }
 	    }
@@ -4747,6 +4975,7 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 	 }
 
 	 if(!(SiS_WeHaveBacklightCtrl(SiS_Pr))) {
+	    SiS_WaitVBRetrace(SiS_Pr);
 	    SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x00,0x7f);
 	 }
 
@@ -4851,6 +5080,8 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 
 #ifdef SIS315H    /* 315 series */
 
+       SiS_UnLockCRT2(SiS_Pr);
+
        if(!(SiS_IsNotM650orLater(SiS_Pr))) {
 	  /*if(SiS_Pr->ChipType < SIS_340) {*/  /* XGI needs this */
 	     SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x4c,0x18);
@@ -4858,14 +5089,15 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
        }
 
        if(SiS_Pr->SiS_IF_DEF_CH70xx == 0) {
-	  if(SiS_CRT2IsLCD(SiS_Pr)) {
-	     SiS_SetRegSR11ANDOR(SiS_Pr,0xFB,0x00);
-	     SiS_PanelDelay(SiS_Pr, 0);
+          if((SiS_Pr->SiS_CustomT != CUT_ICOP550) && (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
+	     if(SiS_CRT2IsLCD(SiS_Pr)) {
+	        SiS_SetRegSR11ANDOR(SiS_Pr,0xFB,0x00);
+	        SiS_PanelDelay(SiS_Pr, 0);
+	     }
 	  }
        }
 
        SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x1E,0x20);
-       SiS_UnLockCRT2(SiS_Pr);
 
        SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x2e,0xf7);
 
@@ -4902,8 +5134,10 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 	  if(SiS_CRT2IsLCD(SiS_Pr)) {
 	     SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1E,0x20);
 	     if(SiS_Pr->ChipType == SIS_550) {
-		SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1E,0x40);
-		SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1E,0x10);
+		if((SiS_Pr->SiS_CustomT != CUT_ICOP550) && (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
+		   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1E,0x40);
+		   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1E,0x10);
+		}
 	     }
 	  }
        } else if(SiS_IsVAMode(SiS_Pr)) {
@@ -4935,10 +5169,12 @@ SiS_EnableBridge(struct SiS_Private *SiS_Pr)
 	     }
 	  }
        } else if(SiS_Pr->SiS_IF_DEF_CH70xx == 0) {
-	  if(!(SiS_WeHaveBacklightCtrl(SiS_Pr))) {
-	     if(SiS_CRT2IsLCD(SiS_Pr)) {
-		SiS_PanelDelay(SiS_Pr, 1);
-		SiS_SetRegSR11ANDOR(SiS_Pr,0xF7,0x00);
+          if((SiS_Pr->SiS_CustomT != CUT_ICOP550) && (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
+	     if(!(SiS_WeHaveBacklightCtrl(SiS_Pr))) {
+		if(SiS_CRT2IsLCD(SiS_Pr)) {
+		   SiS_PanelDelay(SiS_Pr, 1);
+		   SiS_SetRegSR11ANDOR(SiS_Pr,0xF7,0x00);
+		}
 	     }
 	  }
        }
@@ -5001,7 +5237,9 @@ SiS_SetCRT2Sync(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned shor
       if(!(SiS_Pr->SiS_LCDInfo & LCDRGB18Bit)) tempah |= 0x10;
       if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
 	 if((SiS_Pr->SiS_CustomT == CUT_BARCO1366) ||
-	    (SiS_Pr->SiS_CustomT == CUT_BARCO1024)) {
+	    (SiS_Pr->SiS_CustomT == CUT_BARCO1024) ||
+	    (SiS_Pr->SiS_CustomT == CUT_ICOP550)   ||
+	    (SiS_Pr->SiS_CustomT == CUT_ICOP550_2)) {
 	    tempah |= 0xf0;
 	 }
 	 if( (SiS_Pr->SiS_IF_DEF_FSTN) ||
@@ -5328,21 +5566,34 @@ SiS_SetCRT2FIFO_300(struct SiS_Private *SiS_Pr,unsigned short ModeNo)
 static void
 SiS_SetCRT2FIFO_310(struct SiS_Private *SiS_Pr)
 {
-  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x01,0x3B);
-  if( (SiS_Pr->ChipType == SIS_760)      &&
-      (SiS_Pr->SiS_SysFlags & SF_760LFB)  &&
-      (SiS_Pr->SiS_ModeType == Mode32Bpp) &&
-      (SiS_Pr->SiS_VGAHDE >= 1280)	  &&
-      (SiS_Pr->SiS_VGAVDE >= 1024) ) {
-     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2f,0x03);
-     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x01,0x3b);
-     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x4d,0xc0);
-     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2f,0x01);
-     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x4d,0xc0);
-     SiS_SetReg(SiS_Pr->SiS_Part1Port,0x02,0x6e);
-  } else {
-     SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x02,~0x3f,0x04);
-  }
+
+	if(SiS_Pr->ChipType >= SIS_670){
+		SiS_SetReg(SiS_Pr->SiS_Part1Port,0x3b,0x00);
+		if(SiS_Pr->SiS_ModeType >= Mode24Bpp){
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x01,~0x3f,0x39);  	/* (karma) to reduce 800x600&640x480 noise */
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x02,~0x3f,0x0e);			
+		}else{
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x01,~0x3f,0x18);
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x02,~0x3f,0x12);	
+		}
+	}
+	else{
+		SiS_SetReg(SiS_Pr->SiS_Part1Port,0x01,0x3B);
+		if( 	(SiS_Pr->ChipType == SIS_760)      &&
+ 			(SiS_Pr->SiS_SysFlags & SF_760LFB)  &&
+ 			(SiS_Pr->SiS_ModeType == Mode32Bpp) &&
+  			(SiS_Pr->SiS_VGAHDE >= 1280)	  &&
+  			(SiS_Pr->SiS_VGAVDE >= 1024) ) {
+				SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2f,0x03);
+				SiS_SetReg(SiS_Pr->SiS_Part1Port,0x01,0x3b);
+				SiS_SetReg(SiS_Pr->SiS_Part1Port,0x4d,0xc0);
+				SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2f,0x01);
+				SiS_SetReg(SiS_Pr->SiS_Part1Port,0x4d,0xc0);
+				SiS_SetReg(SiS_Pr->SiS_Part1Port,0x02,0x6e);
+		} else {
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x02,~0x3f,0x04);
+		}
+	}
 
 }
 #endif
@@ -5481,7 +5732,7 @@ SiS_SetGroup1_301(struct SiS_Private *SiS_Pr, unsigned short ModeNo,unsigned sho
   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1A,temp);                	/* SR0E, dither[7] */
 
   temp = SiS_GetRegByte((SiS_Pr->SiS_P3ca+0x02));
-  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,temp);			/* ? */
+  SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,temp);			/* 3c2 */
 
 #ifdef SIS_XORG_XF86
 #ifdef TWDEBUG
@@ -5518,7 +5769,7 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
   unsigned int   tempeax = 0, tempebx, tempecx, tempvcfact = 0;
   BOOLEAN islvds = FALSE, issis  = FALSE, chkdclkfirst = FALSE;
   BOOLEAN lvds550 = FALSE;
-#ifdef SIS300
+#if defined(SIS300) || (defined(SIS315H) && defined(SIS_INCL_CUSTOM_ICOP))
   unsigned short crt2crtc = 0;
 #endif
 #ifdef SIS315H
@@ -5528,7 +5779,7 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
   if(ModeNo <= 0x13) {
      modeflag = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ModeFlag;
      resinfo = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ResInfo;
-#ifdef SIS300
+#if defined(SIS300) || (defined(SIS315H) && defined(SIS_INCL_CUSTOM_ICOP))
      crt2crtc = SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_CRT2CRTC;
 #endif
   } else if(SiS_Pr->UseCustomMode) {
@@ -5536,7 +5787,7 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
   } else {
      modeflag = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_ModeFlag;
      resinfo = SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_RESINFO;
-#ifdef SIS300
+#if defined(SIS300) || (defined(SIS315H) && defined(SIS_INCL_CUSTOM_ICOP))
      crt2crtc = SiS_Pr->SiS_RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
 #endif
   }
@@ -5566,9 +5817,9 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
 
 #ifdef SIS315H
   if((SiS_Pr->ChipType >= SIS_315H) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA)) {
-     if(IS_SIS330) {
+     if(SiS_Pr->ChipType == SIS_330) {
         SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x2D,0x10);
-     } else if(IS_SIS740) {
+     } else if(SiS_Pr->ChipType == SIS_740) {
         if(islvds) {
            SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x13,0xfb,0x04);
 	   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x2D,0x03);
@@ -5937,7 +6188,7 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
   if(SiS_Pr->SiS_IF_DEF_TRUMPION) {
      unsigned char *ROMAddr = SiS_Pr->VirtualRomBase;
      unsigned char *trumpdata;
-     int   i, j = crt2crtc;
+     int i, j = crt2crtc;
      unsigned char TrumpMode13[4]   = { 0x01, 0x10, 0x2c, 0x00 };
      unsigned char TrumpMode10_1[4] = { 0x01, 0x10, 0x27, 0x00 };
      unsigned char TrumpMode10_2[4] = { 0x01, 0x16, 0x10, 0x00 };
@@ -5950,16 +6201,16 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
      }
 
      SiS_SetRegAND(SiS_Pr->SiS_Part1Port,0x02,0xbf);
-     for(i=0; i<5; i++) {
+     for(i = 0; i < 5; i++) {
 	SiS_SetTrumpionBlock(SiS_Pr, trumpdata);
      }
      if(SiS_Pr->SiS_LCDResInfo == Panel_1024x768) {
 	if(ModeNo == 0x13) {
-	   for(i=0; i<4; i++) {
+	   for(i = 0; i < 4; i++) {
 	      SiS_SetTrumpionBlock(SiS_Pr, &TrumpMode13[0]);
 	   }
 	} else if(ModeNo == 0x10) {
-	   for(i=0; i<4; i++) {
+	   for(i = 0; i < 4; i++) {
 	      SiS_SetTrumpionBlock(SiS_Pr, &TrumpMode10_1[0]);
 	      SiS_SetTrumpionBlock(SiS_Pr, &TrumpMode10_2[0]);
 	   }
@@ -6069,6 +6320,8 @@ SiS_SetGroup1_LVDS(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned s
         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x45,0x0a);
      }
   }
+
+
 #endif  /* SIS315H */
 }
 
@@ -6104,7 +6357,9 @@ SiS_SetGroup1(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
   if(SiS_Pr->ChipType == SIS_550 &&
      SiS_Pr->SiS_IF_DEF_LVDS     &&
      !SiS_Pr->SiS_IF_DEF_DSTN    &&
-     !SiS_Pr->SiS_IF_DEF_FSTN) {
+     !SiS_Pr->SiS_IF_DEF_FSTN    &&
+     (SiS_Pr->SiS_CustomT != CUT_ICOP550) &&
+     (SiS_Pr->SiS_CustomT != CUT_ICOP550_2)) {
      lvds550 = 1;
   }
 
@@ -6380,7 +6635,7 @@ SiS_SetGroup1(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 
 	temp &= 0x3c;
 
-	SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x13,~0x3C,temp);   /* Panel Link Delay Compensation; (Software Command Reset; Power Saving) */
+	SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x13,~0x3C,temp);   
 
 #endif  /* SIS300 */
 
@@ -6411,7 +6666,7 @@ SiS_SetGroup1(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 		 }
 	      }
 
-	      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,tempbl,temp);	    /* Panel Link Delay Compensation */
+	      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,tempbl,temp);	    
 	   }
 
 	} /* < 661 */
@@ -6419,6 +6674,8 @@ SiS_SetGroup1(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 	tempax = 0;
 	if(modeflag & DoubleScanMode) tempax |= 0x80;
 	if(modeflag & HalfDCLK)       tempax |= 0x40;
+	if(SiS_Pr->ChipType>=SIS_761)
+            tempax |= 0x20;
 	SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2C,0x3f,tempax);
 
 #endif  /* SIS315H */
@@ -6427,6 +6684,14 @@ SiS_SetGroup1(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 
   }  /* Slavemode */
 
+  if(SiS_Pr->ChipType>=SIS_761)
+  {
+      SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2F, ~0x04, 0x04);
+      SiS_SetReg(SiS_Pr->SiS_Part1Port,0x27,0x04);
+	if(SiS_Pr->ChipType>=SIS_670) /* Set channel-B normal */
+		SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x38,0x60);
+  }
+
   if(SiS_Pr->SiS_VBType & VB_SISVB) {
      if((SiS_Pr->SiS_VBType & VB_NoLCD) && (SiS_Pr->SiS_VBInfo & SetCRT2ToLCD)) {
 	/* For 301BDH with LCD, we set up the Panel Link */
@@ -6447,6 +6712,20 @@ SiS_SetGroup1(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 	}
      }
   }
+
+   /*chaoyu add: in order to support 800*600 panel on 302LV, 
+       we patch for the mode 800*600. 
+       TODO: other mode! */
+  if((SiS_Pr->SiS_VBType &
+(VB_SIS302LV | VB_SIS302ELV))  && 
+  	(SiS_Pr->SiS_LCDResInfo == Panel_800x600)){
+  	   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1e,0x20);
+	   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x13,0x04);
+	   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1a,0x10);
+	   SiS_SetReg(SiS_Pr->SiS_Part1Port,0x35,0xac);
+  }
+
+  
 }
 
 /*********************************************/
@@ -6624,21 +6903,24 @@ SiS_SetTVSpecial(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
      }
 #endif
   } else if(SiS_Pr->SiS_TVMode & TVSetYPbPr525p) {
-     if(SiS_Pr->SiS_TVMode & TVSet525p1024) {
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1f,0x77);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x20,0x13);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x2b,0x78);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x2c,0x04);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x42,0x14);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x43,0x73);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1c,0xaf);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1e,0x71);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x21,0xbb);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x23,0xb5);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x26,0xdc);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x46,0x3c);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x45,0x11);
-        SiS_SetReg(SiS_Pr->SiS_Part2Port,0x44,0x00);
+        if(SiS_Pr->SiS_TVMode & TVSet525p1024) {
+	   if(SiS_Pr->ChipType < SIS_671){        
+        	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x2c,0x04);
+        	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x42,0x14);        
+        	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x21,0xbb);
+        	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x23,0xb5);
+        	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x26,0xdc);
+	   }
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1b,0xd0);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1c,0xaf);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1e,0x71);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1f,0x77);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x20,0x13);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x2b,0x78);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x43,0x78);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x44,0x8d);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x45,0x51);
+           SiS_SetReg(SiS_Pr->SiS_Part2Port,0x46,0x3d); 
      }
   } else if(!(SiS_Pr->SiS_TVMode & TVSetPAL)) {
      if(SiS_Pr->SiS_TVMode & TVSetNTSC1024) {
@@ -6707,6 +6989,23 @@ SiS_SetGroup2_Tail(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 	temp = 1;
 	if(ModeNo <= 0x13) temp = 3;
 	SiS_SetReg(SiS_Pr->SiS_Part2Port,0x0b,temp);
+
+	 /* chaoyu add:
+	  * ToDo: Patch for mode 1280x1024 on 1400x1050 panel. 
+	  * There are bugs in this mode. 
+	  */
+	if((SiS_Pr->SiS_VBType & VB_SIS307LV) && 
+            (ModeNo == 0x65 || ModeNo == 0x4d || ModeNo == 0x3a) ){
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x04, 0x1b);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x05, 0x29);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x06, 0x19);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x46, 0x1f);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x20, 0x07);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x2c, 0xbb);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1f, 0x08);
+		SiS_SetReg(SiS_Pr->SiS_Part2Port,0x45, 0x4a);
+	}
+	
      }
   }
 }
@@ -6874,9 +7173,11 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
   tempcx += 7;
   if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) tempcx -= 4;
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x22,0x0F,((tempcx << 4) & 0xf0));
-
+  
   tempbx = TimingPoint[j] | (TimingPoint[j+1] << 8);
   tempbx += tempcx;
+
+/*horizontal half line equalizer pulse End*/
   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x24,tempbx);
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x25,0x0F,((tempbx >> 4) & 0xf0));
 
@@ -6889,6 +7190,7 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 
   j += 2;
   tempcx += (TimingPoint[j] | (TimingPoint[j+1] << 8));
+  /*horizontal sync half line pulse end*/
   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x27,tempcx);
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x28,0x0F,((tempcx >> 4) & 0xf0));
 
@@ -6900,12 +7202,14 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
   if(SiS_IsDualLink(SiS_Pr)) tempcx >>= 1;
   j += 2;
   tempcx -= (TimingPoint[j] | ((TimingPoint[j+1]) << 8));
+  /*horizontal (half line) blank expansion end*/
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x2D,0x0F,((tempcx << 4) & 0xf0));
 
   tempcx -= 11;
   if(!(SiS_Pr->SiS_VBInfo & SetCRT2ToTV)) {
      tempcx = SiS_GetVGAHT2(SiS_Pr) - 1;
   }
+  /*horizontal half line active End*/
   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x2E,tempcx);
 
   tempbx = SiS_Pr->SiS_VDE;
@@ -6964,40 +7268,67 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 	SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x10,0xbf,((tempbx & 0x0400) >> 4));
      }
   }
-
+/*from here to find out the tempbx and tempcx difference*/
   tempax = tempbx = tempcx = 0;
   if(!(modeflag & HalfDCLK)) {
      if(SiS_Pr->SiS_VGAHDE >= SiS_Pr->SiS_HDE) {
-        tempbx |= 0x20;
+        tempbx |= 0x20;   /*enable downscale function*/
      }
   }
 
   tempch = tempcl = 1;
+  longtemp = SiS_Pr->SiS_VGAHDE;
   if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
-     if(SiS_Pr->SiS_VGAHDE >= 960) {
-        if(!(modeflag & HalfDCLK)) {
+  	if(SiS_Pr->ChipType < SIS_761){
+            if(longtemp > 800) {
+                if(!(modeflag & HalfDCLK)) {
+                    longtemp = 800;
+                    if(SiS_Pr->SiS_VGAHDE >= 1280) {
+                        tempbx &= ~0x20;
+                    } else if(SiS_Pr->SiS_VGAHDE == 960) {
+                        longtemp = 750;
+                    } else if(SiS_Pr->SiS_VGAHDE == 856) {
+                        longtemp = 672;
+                    } else if(SiS_Pr->SiS_VGAHDE == 848) {
+                        longtemp = 664;
+                    }
+#if 0
 	   tempcl = 32;
 	   if(SiS_Pr->SiS_VGAHDE >= 1280) {
               tempch = 20;
               tempbx &= ~0x20;
            } else if(SiS_Pr->SiS_VGAHDE >= 1024) {
               tempch = 25;
-           } else {
+           } else if(SiS_Pr->SiS_VGAHDE >= 960) {
 	      tempch = 25; /* OK */
+	   } else {
+	      tempch = 30;
 	   }
-        }
-     }
+#endif
+                }
+            }
+  	}
   }
 
-  if(!(tempbx & 0x20)) {
+  if((tempbx & 0x20)) {
+     if(modeflag & HalfDCLK) longtemp >>= 1;
+	 if(SiS_Pr->ChipType > SIS_761){
+             if(longtemp > SiS_Pr->SiS_HDE){ 
+                 longtemp=longtemp-SiS_Pr->SiS_HDE;
+             }
+	 }
+  }
+  
+     longtemp <<= 13;
+#if 0
      if(modeflag & HalfDCLK) tempcl <<= 1;
      longtemp = ((SiS_Pr->SiS_VGAHDE * tempch) / tempcl) << 13;
+#endif
      if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) longtemp <<= 3;
      tempax = longtemp / SiS_Pr->SiS_HDE;
      if(longtemp % SiS_Pr->SiS_HDE) tempax++;
      tempbx |= ((tempax >> 8) & 0x1F);
      tempcx = tempax >> 13;
-  }
 
   SiS_SetReg(SiS_Pr->SiS_Part2Port,0x44,tempax);
   SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x45,0xC0,tempbx);
@@ -7031,7 +7362,7 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 
      if(SiS_Pr->SiS_VBType & VB_SIS30xCLV) {
         temp = 0;
-        if(SiS_Pr->SiS_TVMode & TVSetPALM) temp = 8;
+   /*     if(SiS_Pr->SiS_TVMode & TVSetPALM) temp = 8; (Karma)BUG?! */
         SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x4e,0xf7,temp);
      }
 
@@ -7054,7 +7385,6 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
   if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) return;
 
   /* From here: Part2 LCD setup */
-
   tempbx = SiS_Pr->SiS_HDE;
   if(SiS_IsDualLink(SiS_Pr)) tempbx >>= 1;
   tempbx--;			         	/* RHACTE = HDE - 1 */
@@ -7180,7 +7510,9 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
        }
     }
 
-    tempbx = ((SiS_Pr->SiS_VT + SiS_Pr->SiS_VDE) >> 1) - 1;
+    tempbx = ((SiS_Pr->SiS_VT + SiS_Pr->SiS_VDE) >> 1) - 7;
+
+
     if(SiS_Pr->SiS_LCDInfo & DontExpandLCD) {
        if(SiS_Pr->PanelYRes != SiS_Pr->SiS_VDE) {
           if(!(SiS_Pr->SiS_LCDInfo & LCDPass11)) { /* ? */
@@ -7217,9 +7549,8 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 #endif
 
     SiS_SetReg(SiS_Pr->SiS_Part2Port,0x04,tempbx);	    /* lcdvrs */
-
     temp = (tempbx >> 4) & 0xF0;
-    tempbx += (tempcx + 1);
+    tempbx += (tempcx + 2);
     temp |= (tempbx & 0x0F);
 
     if(SiS_Pr->UseCustomMode) {
@@ -7244,8 +7575,14 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
     if(SiS_Pr->SiS_VBType & VB_SIS30xCLV)	bridgeoffset += 2; /* OK for Averatec 1280x800 (301C) */
     if(SiS_IsDualLink(SiS_Pr))			bridgeoffset++;
     else if(SiS_Pr->SiS_VBType & VB_SIS302LV)	bridgeoffset++;    /* OK for Asus A4L 1280x800 */
+    if(SiS_Pr->SiS_VBType & VB_SIS307LV){
+        if(SiS_Pr->SiS_LCDResInfo==Panel_1280x1024){
+            bridgeoffset = 0x04;
+	}else{
+            bridgeoffset = 0x08;
+	}
+    }
     /* Higher bridgeoffset shifts to the LEFT */
-
     temp = 0;
     if((SiS_Pr->SiS_LCDInfo & DontExpandLCD) && (!(SiS_Pr->SiS_LCDInfo & LCDPass11))) {
        if(SiS_Pr->PanelXRes != SiS_Pr->SiS_HDE) {
@@ -7276,15 +7613,14 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
     xf86DrvMsg(0, X_INFO, "lcdhdee 0x%x\n", tempbx);
 #endif
 #endif
-
     tempbx += bridgeoffset;
 
     SiS_SetReg(SiS_Pr->SiS_Part2Port,0x23,tempbx);	    /* lcdhdee */
     SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x25,0xF0,((tempbx >> 8) & 0x0f));
 
     tempcx = (tempcx - tempax) >> 2;
-
     tempbx += tempcx;
+
     push2 = tempbx;
 
     if(SiS_Pr->SiS_LCDResInfo == Panel_1280x1024) {
@@ -7307,7 +7643,6 @@ SiS_SetGroup2(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
     xf86DrvMsg(0, X_INFO, "lcdhrs 0x%x\n", tempbx);
 #endif
 #endif
-
     SiS_SetReg(SiS_Pr->SiS_Part2Port,0x1C,tempbx);	    /* lcdhrs */
     SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x1D,0x0F,((tempbx >> 4) & 0xf0));
 
@@ -7356,11 +7691,7 @@ SiS_SetGroup3(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 
   if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA) return;
 
-#ifndef SIS_CP
   SiS_SetReg(SiS_Pr->SiS_Part3Port,0x00,0x00);
-#else
-  SIS_CP_INIT301_CP
-#endif
 
   if(SiS_Pr->SiS_TVMode & TVSetPALTiming) {
      SiS_SetReg(SiS_Pr->SiS_Part3Port,0x13,0xFA);
@@ -7401,9 +7732,6 @@ SiS_SetGroup3(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
      }
   }
 
-#ifdef SIS_CP
-  SIS_CP_INIT301_CP2
-#endif
 }
 
 /*********************************************/
@@ -7485,23 +7813,6 @@ SiS_SetGroup4_C_ELV(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
             SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x3b,0xfd);
          }
       }
-
-#if 0
-      if(SiS_Pr->ChipType >= SIS_661) { 		/* ? */
-         if(SiS_Pr->SiS_TVMode & TVAspect43) {
-            if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p) {
-	       if(resinfo == SIS_RI_1024x768) {
-	          SiS_ShiftXPos(SiS_Pr, 97);
-	       } else {
-	          SiS_ShiftXPos(SiS_Pr, 111);
-	       }
-	    } else if(SiS_Pr->SiS_TVMode & TVSetHiVision) {
-	       SiS_ShiftXPos(SiS_Pr, 136);
-	    }
-         }
-      }
-#endif
-
    }
 
 }
@@ -7523,15 +7834,29 @@ SiS_SetCRT2VCLK(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned shor
   }
 
   if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {
-     if(SiS_Pr->SiS_TVMode & (TVSetNTSC1024 | TVSet525p1024)) {
+     if(SiS_Pr->SiS_TVMode & TVSetNTSC1024) {
         SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0a,0x57);
  	SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0b,0x46);
 	SiS_SetReg(SiS_Pr->SiS_Part4Port,0x1f,0xf6);
-     } else {
+     } else if (SiS_Pr->SiS_TVMode & TVSet525p1024) {
+        SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0a,0x57);
+ 		SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0b,0x64);
+		SiS_SetReg(SiS_Pr->SiS_Part4Port,0x1f,0xf6);
+     }
+     else {
         SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0a,reg1);
         SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0b,reg2);
      }
-  } else {
+/*karma for Ypbpr750p 1280x720*/
+      if(SiS_Pr->ChipType >= SIS_315H){
+         if(SiS_Pr->SiS_TVMode & TVSetYPbPr750p){
+	    if(ModeNo == 0x79 || ModeNo == 0x75 || ModeNo == 0x78){   
+	    SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0a,0x46); 
+	    SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0b,0x43); 
+	    }
+	 }
+      }
+   } else {
      SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0a,0x01);
      SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0b,reg2);
      SiS_SetReg(SiS_Pr->SiS_Part4Port,0x0a,reg1);
@@ -7605,6 +7930,7 @@ SiS_SetGroup4(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
      }
   }
 
+
   SiS_SetReg(SiS_Pr->SiS_Part4Port,0x13,SiS_Pr->SiS_RVBHCFACT);
 
   tempbx = SiS_Pr->SiS_RVBHCMAX;
@@ -7627,25 +7953,50 @@ SiS_SetGroup4(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
   tempbx = SiS_Pr->SiS_VGAHDE;
   if(modeflag & HalfDCLK)    tempbx >>= 1;
   if(SiS_IsDualLink(SiS_Pr)) tempbx >>= 1;
-
-  if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
-     temp = 0;
-     if(tempbx > 800)        temp = 0x60;
-  } else if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) {
-     temp = 0;
-     if(tempbx > 1024)       temp = 0xC0;
-     else if(tempbx >= 960)  temp = 0xA0;
-  } else if(SiS_Pr->SiS_TVMode & TVSetYPbPrProg) {
-     temp = 0;
-     if(tempbx >= 1280)      temp = 0x40;
-     else if(tempbx >= 1024) temp = 0x20;
-  } else {
-     temp = 0x80;
-     if(tempbx >= 1024)      temp = 0xA0;
+  if(SiS_Pr->ChipType < SIS_761){
+      if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
+          temp = 0;
+          if(tempbx > 800)        temp = 0x60;
+      } else if(SiS_Pr->SiS_VBInfo & SetCRT2ToHiVision) {
+          temp = 0;
+          if(tempbx > 1024)       temp = 0xC0;
+          else if(tempbx > 800)   temp = 0xA0;
+      } else if(SiS_Pr->SiS_TVMode & TVSetYPbPrProg) {
+          temp = 0;
+          if(tempbx >= 1280)      temp = 0x40;
+          else if(tempbx > 800)   temp = 0x20;
+      } else {
+          temp = 0x80;
+          if(tempbx > 800)	     temp = 0xA0;
+      }
+  }else{
+      if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD){
+	  	  temp = 0;
+          if(tempbx > 960)        temp = 0x60;
+      }else if(SiS_Pr->SiS_TVMode & TVSetYPbPrProg){ 
+          temp = 0;
+          if(tempbx > 960)        temp = 0x60;
+		  if(SiS_Pr->ChipType >= SIS_662){  /*(karma) for YPbPr 1024x768&1280x720*/
+	 	     if(tempbx == 1024) 	  temp = 0x28;
+		     else if(tempbx == 1280) temp = 0x48;
+		  }
+      } /*(karma) for TV 800x600 & 640x480*/
+	  else if(SiS_Pr->SiS_VBInfo & (SetCRT2ToAVIDEO || SetCRT2ToSVIDEO)){
+	      temp = 0;
+	      if(tempbx > 1024)   temp = 0xc0;
+	      else if(tempbx > 960)   temp = 0xa0;
+	      else temp = 0x80;
+      } else if(SiS_Pr->SiS_TVMode & (TVSetInterlace)) {
+          temp = 0;
+          if(tempbx > 1024)       temp = 0xC0;
+          else if(tempbx > 960)   temp = 0xa0;
+          else temp = 0x80;
+      } 
+  }
+  if(SiS_Pr->ChipType < SIS_761){
+      temp |= SiS_Pr->Init_P4_0E;
   }
 
-  temp |= SiS_Pr->Init_P4_0E;
-
   if(SiS_Pr->SiS_VBType & VB_SIS301) {
      if(SiS_Pr->SiS_LCDResInfo != Panel_1280x1024) {
         temp &= 0xf0;
@@ -7685,40 +8036,47 @@ SiS_SetGroup4(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
   temp |= (tempcx & 0x4F);
   SiS_SetReg(SiS_Pr->SiS_Part4Port,0x19,temp);
 
+  /*karma for Ypbpr750p 1280x720*/
+  if((SiS_Pr->ChipType >= SIS_315H) && (SiS_Pr->SiS_TVMode & TVSetYPbPr750p))
+  {
+     if((ModeNo == 0x79) ||(ModeNo == 0x75)|| (ModeNo == 0x78))
+	  SiS_SetReg(SiS_Pr->SiS_Part4Port,0x1A,0x93);
+  }
+
   if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {
 
      SiS_SetReg(SiS_Pr->SiS_Part4Port,0x1C,0x28);
 
-     /* Calc Linebuffer max address and set/clear decimode */
      tempbx = 0;
-     if(SiS_Pr->SiS_TVMode & (TVSetHiVision | TVSetYPbPr750p)) tempbx = 0x08;
+     if(SiS_Pr->SiS_TVMode & (TVSetHiVision | TVSetYPbPr750p)) tempbx = 0x08; 
      tempax = SiS_Pr->SiS_VGAHDE;
      if(modeflag & HalfDCLK)    tempax >>= 1;
      if(SiS_IsDualLink(SiS_Pr)) tempax >>= 1;
-     if(tempax > 800) {
-        if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
-	   tempax -= 800;
-	} else {
-	   tempbx = 0x08;
-	   if(tempax == 960)	   tempax *= 25; /* Correct */
-           else if(tempax == 1024) tempax *= 25;
-           else			   tempax *= 20;
-	   temp = tempax % 32;
-	   tempax /= 32;
-	   if(temp) tempax++;
-	   tempax++;
-	   if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
-	      if(resinfo == SIS_RI_1024x768 ||
-	         resinfo == SIS_RI_1024x576 ||
-		 resinfo == SIS_RI_1280x1024 ||
-		 resinfo == SIS_RI_1280x720) {
-	         /* Otherwise white line or garbage at right edge */
-	         tempax = (tempax & 0xff00) | 0x20;
-	      } else if(resinfo == SIS_RI_960x540) {
-	         tempax = (tempax & 0xff00) | 0xed;
-	      }
-	   }
-	}
+     if(SiS_Pr->ChipType < SIS_761){
+         if(tempax > 800) {
+             if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
+	         tempax -= 800;
+	     } else {
+	         tempbx = 0x08;
+	         if(tempax == 960)      tempax = 749;
+	         else if(tempax == 856) tempax = 669;
+	         else if(tempax == 848) tempax = 662;
+	         else			  tempax = 800;
+	     }
+         }
+     }else{
+         tempbx &=~0x08; 
+
+             if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
+                 if(tempax>960)
+	             tempax -= 960;
+	     } else {
+	         if(tempax > 960){
+		     tempbx = 0x08;
+                     tempax = (tempax *3)/4;
+		 }
+	     }
+         
      }
      tempax--;
      temp = ((tempax >> 4) & 0x30) | tempbx;
@@ -7749,19 +8107,24 @@ SiS_SetGroup4(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
      SiS_SetReg(SiS_Pr->SiS_Part4Port,0x22,tempbx);
      temp = (tempbx >> 5) & 0x38;
      SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x21,0xC0,temp);
-
      if(SiS_Pr->SiS_VBType & VB_SISLVDS) {
 	if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
            SiS_SetReg(SiS_Pr->SiS_Part4Port,0x24,0x0e);
-	   /* LCD-too-dark-error-source, see FinalizeLCD() */
 	}
      }
-
      SiS_SetDualLinkEtc(SiS_Pr);
-
   }  /* 301B */
-
   SiS_SetCRT2VCLK(SiS_Pr, ModeNo, ModeIdIndex, RefreshRateTableIndex);
+
+
+  /*chaoyu add: in order to support 800*600 panel on 302LV, 
+       we patch for the mode 800*600. 
+       TODO: other mode! */
+  if((SiS_Pr->SiS_VBType &
+(VB_SIS302LV | VB_SIS302ELV))  && 
+  	(SiS_Pr->SiS_LCDResInfo == Panel_800x600)){
+  	   SiS_SetReg(SiS_Pr->SiS_Part4Port,0x23,0x10);
+  }
 }
 
 /*********************************************/
@@ -8083,9 +8446,7 @@ SiS_SetCHTVReg(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
       /* Register 0x3D does not exist in non-macrovision register map
             (Maybe this is a macrovision register?)
        */
-#ifndef SIS_CP
       SiS_SetCH70xx(SiS_Pr,0x3d,0x00);
-#endif
 
       /* Register 0x10 only contains 1 writable bit (S0) for sensing,
              all other bits a read-only. Macrovision?
@@ -8201,9 +8562,6 @@ SiS_SetCHTVReg(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short
 
    }
 
-#ifdef SIS_CP
-   SIS_CP_INIT301_CP3
-#endif
 
 }
 
@@ -8881,7 +9239,7 @@ void
 SiS_SiS30xBLOn(struct SiS_Private *SiS_Pr)
 {
   /* Switch on LCD backlight on SiS30xLV */
-  SiS_DDC2Delay(SiS_Pr,0xff00);
+  SiS_DDC2Delay(SiS_Pr, 0xff00);
   if(!(SiS_GetReg(SiS_Pr->SiS_Part4Port,0x26) & 0x02)) {
      SiS_SetRegOR(SiS_Pr->SiS_Part4Port,0x26,0x02);
      SiS_WaitVBRetrace(SiS_Pr);
@@ -8922,20 +9280,20 @@ SiS_SetTrumpBlockLoop(struct SiS_Private *SiS_Pr, unsigned char *dataptr)
   unsigned short tempah,temp;
   unsigned char *mydataptr;
 
-  for(i=0; i<20; i++) {				/* Do 20 attempts to write */
+  for(i = 0; i < 20; i++) {			/* Do 20 attempts to write */
      mydataptr = dataptr;
      num = *mydataptr++;
      if(!num) return mydataptr;
      if(i) {
         SiS_SetStop(SiS_Pr);
-	SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT * 2);
+	SiS_DDC2Delay(SiS_Pr, SiS_I2CDELAYSHORT * 2);
      }
      if(SiS_SetStart(SiS_Pr)) continue;		/* Set start condition */
      tempah = SiS_Pr->SiS_DDC_DeviceAddr;
-     temp = SiS_WriteDDC2Data(SiS_Pr,tempah);	/* Write DAB (S0=0=write) */
+     temp = SiS_WriteDDC2Data(SiS_Pr, tempah);	/* Write DAB (S0=0=write) */
      if(temp) continue;				/*    (ERROR: no ack) */
      tempah = *mydataptr++;
-     temp = SiS_WriteDDC2Data(SiS_Pr,tempah);	/* Write register number */
+     temp = SiS_WriteDDC2Data(SiS_Pr, tempah);	/* Write register number */
      if(temp) continue;				/*    (ERROR: no ack) */
      for(j=0; j<num; j++) {
         tempah = *mydataptr++;
@@ -9486,10 +9844,9 @@ SiS_HandleDDC(struct SiS_Private *SiS_Pr, unsigned int VBFlags, int VGAEngine,
       }
    }
    if((sr1f) || (!cr17)) {
-      SiS_WaitRetrace1(SiS_Pr);
-      SiS_WaitRetrace1(SiS_Pr);
-      SiS_WaitRetrace1(SiS_Pr);
-      SiS_WaitRetrace1(SiS_Pr);
+      for(result = 0; result < 10; result++) {
+         SiS_WaitRetrace1(SiS_Pr);
+      }
    }
 
    if(DDCdatatype == 0) {
@@ -9630,7 +9987,7 @@ SiS_SetSCLKLow(struct SiS_Private *SiS_Pr)
 		  SiS_Pr->SiS_DDC_Index,
 		  SiS_Pr->SiS_DDC_NClk,
 		  0x00);					/* SetSCLKLow()  */
-  SiS_DDC2Delay(SiS_Pr,SiS_I2CDELAYSHORT);
+  SiS_DDC2Delay(SiS_Pr, SiS_I2CDELAYSHORT);
   return 0;
 }
 
@@ -9743,7 +10100,7 @@ GetLCDPtrIndexBIOS(struct SiS_Private *SiS_Pr)
 {
   unsigned short index;
 
-  if((IS_SIS650) && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {
+  if((SiS_Pr->ChipType == SIS_650) && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {
      if(!(SiS_IsNotM650orLater(SiS_Pr))) {
         if((index = SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) & 0xf0)) {
 	   index >>= 4;
@@ -9890,9 +10247,9 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
      else {
         delay = 0x04;
         if(SiS_Pr->SiS_VBType & VB_SIS30xB) {
-	   if(IS_SIS650) {
+	   if(SiS_Pr->ChipType == SIS_650) {
 	      delay = 0x0a;
-	   } else if(IS_SIS740) {
+	   } else if(SiS_Pr->ChipType == SIS_740) {
 	      delay = 0x00;
 	   } else if(SiS_Pr->ChipType < SIS_330) {
 	      delay = 0x0c;
@@ -9941,8 +10298,8 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 	         delay = 0x00;
 	      }
 	   } else if(SiS_Pr->SiS_VBType & VB_SISLVDS) {
-	      if(IS_SIS740) delay = 0x01;
-	      else          delay = 0x03;
+	      if(SiS_Pr->ChipType == SIS_740)	delay = 0x01;
+	      else				delay = 0x03;
 	   }
 	   SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,delay);
 	}
@@ -9988,7 +10345,7 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
         index = GetLCDPtrIndexBIOS(SiS_Pr);
         myindex = GetLCDPtrIndex(SiS_Pr);
 
-        if(IS_SIS650 && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {
+        if((SiS_Pr->ChipType == SIS_650) && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {
 
            if(SiS_IsNotM650orLater(SiS_Pr)) {
 
@@ -10026,22 +10383,22 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 
         } else if(SiS_Pr->SiS_IF_DEF_LVDS == 1) {
 
-	   if(IS_SIS740) delay = 0x03;
-	   else          delay = 0x00;
+	   if(SiS_Pr->ChipType == SIS_740) delay = 0x03;
+	   else				   delay = 0x00;
 
 	} else {
 
            delay = SiS310_LCDDelayCompensation_301[myindex];
 	   if(SiS_Pr->SiS_VBType & VB_SISLVDS) {
-	      if(IS_SIS740) delay = 0x01;
+	      if(SiS_Pr->ChipType == SIS_740) delay = 0x01;
 	      else if(SiS_Pr->ChipType <= SIS_315PRO) delay = SiS310_LCDDelayCompensation_3xx301LV[myindex];
 	      else          delay = SiS310_LCDDelayCompensation_650301LV[myindex];
 	   } else if(SiS_Pr->SiS_VBType & VB_SIS301C) {
-	      if(IS_SIS740) delay = 0x01;  /* ? */
+	      if(SiS_Pr->ChipType == SIS_740) delay = 0x01;  /* ? */
 	      else          delay = 0x03;
 	      if(SiS_Pr->SiS_LCDResInfo == Panel_1600x1200) delay = 0x00; /* experience */
 	   } else if(SiS_Pr->SiS_VBType & VB_SIS30xB) {
-	      if(IS_SIS740) delay = 0x01;
+	      if(SiS_Pr->ChipType == SIS_740) delay = 0x01;
 	      else          delay = SiS310_LCDDelayCompensation_3xx301B[myindex];
 	   }
 
@@ -10058,7 +10415,7 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 
      index = GetTVPtrIndex(SiS_Pr);
 
-     if(IS_SIS650 && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {
+     if((SiS_Pr->ChipType == SIS_650) && (SiS_Pr->SiS_VBType & VB_SISLVDS)) {
 
         if(SiS_IsNotM650orLater(SiS_Pr)) {
 
@@ -10114,7 +10471,7 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 
 	delay = SiS310_TVDelayCompensation_301[index];
         if(SiS_Pr->SiS_VBType & VB_SIS30xBLV) {
-	   if(IS_SIS740) {
+	   if(SiS_Pr->ChipType == SIS_740) {
 	      delay = SiS310_TVDelayCompensation_740301B[index];
 	      /* LV: use 301 data? BIOS bug? */
 	   } else {
@@ -10136,7 +10493,7 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
 
   if(SiS_Pr->SiS_VBType & VB_SISVB) {
 
-     if(IS_SIS650 && (SiS_Pr->SiS_VBType & VB_SISLVDS) && dochiptest) {
+     if((SiS_Pr->ChipType == SIS_650) && (SiS_Pr->SiS_VBType & VB_SISLVDS) && dochiptest) {
 
         temp = (SiS_GetReg(SiS_Pr->SiS_P3d4,0x36) & 0xf0) >> 4;
         if(temp == 8) {		/* 1400x1050 BIOS (COMPAL) */
@@ -10161,7 +10518,7 @@ SetDelayComp(struct SiS_Private *SiS_Pr, unsigned short ModeNo)
      if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
         SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0xF0,delay);
      } else {
-        if(IS_SIS650 && (SiS_Pr->SiS_IF_DEF_CH70xx != 0)) {
+        if((SiS_Pr->ChipType == SIS_650) && (SiS_Pr->SiS_IF_DEF_CH70xx != 0)) {
            delay <<= 4;
            SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2D,0x0F,delay);
         } else {
@@ -10377,6 +10734,43 @@ SetPhaseIncr(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short M
      }
   }
 }
+static Bool
+DelayCompForFutroS400(struct SiS_Private *SiS_Pr)
+{
+	if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCDA)/*TMDS with 301c Via ChA*/
+        {
+	        if(SiS_Pr->SiS_HDE == 1280)
+	        {	if((SiS_Pr->SiS_VDE == 1024)||(SiS_Pr->SiS_VDE == 960))
+	                {
+		             SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2d,0x33); /*chanel A and B always be 0x33 in 1280x1024*/				          return 0;														    }
+	 	}
+		else if((SiS_Pr->SiS_HDE == 1440)&&(SiS_Pr->SiS_VDE == 900))
+		{ 
+			 SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0x0f,0x30); /*ChA always be oxd? in 1680x1050*/
+			                    return 0;
+		}
+		else if((SiS_Pr->SiS_HDE == 1680)&&(SiS_Pr->SiS_VDE == 1050))
+		{
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0x0f,0xd0); /*ChA always be oxd? in 1680x1050*/			             return 0;
+		}
+		else if((SiS_Pr->SiS_HDE == 1600)&&(SiS_Pr->SiS_VDE == 1200))					    {
+			SiS_SetReg(SiS_Pr->SiS_Part1Port,0x2d,0xb2);
+			return 0;
+	       	}
+	}
+    if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD){
+		
+		if(SiS_Pr->CHDisplay == 1280  &&  SiS_Pr->CVDisplay == 1024)	
+			{SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,0x03);
+             return 0;
+            }
+		else if  (SiS_Pr->CHDisplay ==  1600 &&  SiS_Pr->CVDisplay == 1200)
+			{SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,0x02);
+               return 0;
+            }
+     }
+        return 1;/*Use ROMNew*/
+}
 
 static void
 SetDelayComp661(struct SiS_Private *SiS_Pr, unsigned short ModeNo,
@@ -10384,10 +10778,21 @@ SetDelayComp661(struct SiS_Private *SiS_Pr, unsigned short ModeNo,
 {
    unsigned short delay = 0, romptr = 0, index, lcdpdcindex;
    unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;
+   unsigned char  useROMNew;
 
    if(!(SiS_Pr->SiS_VBInfo & (SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA | SetCRT2ToRAMDAC)))
       return;
 
+   /*New Futro Timing*/   
+   if(SiS_Pr->UseFutroTiming == TRUE)
+   {
+	if(!(useROMNew = DelayCompForFutroS400(SiS_Pr)))
+	{	
+	     xf86DrvMsg(0,X_INFO,"Futro Special Timing has been set\n");
+	     return;
+	}
+   }
+
    /* 1. New ROM: VGA2 and LCD/LCDA-Pass1:1 */
    /* (If a custom mode is used, Pass1:1 is always set; hence we do this:) */
 
@@ -10448,7 +10853,7 @@ SetDelayComp661(struct SiS_Private *SiS_Pr, unsigned short ModeNo,
 	 }
       }
 
-   } else if(SiS_Pr->ChipType >= SIS_340) {
+   }else if(SiS_Pr->ChipType >= SIS_340) {
 
       delay = 0x0606;
       if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
@@ -10536,6 +10941,26 @@ SetDelayComp661(struct SiS_Private *SiS_Pr, unsigned short ModeNo,
       SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,((delay >> 1) & 0x0f));
       SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x35,0x7f,((delay & 0x01) << 7));
    }
+
+	/*5. Other special cases*/
+
+
+   if(SiS_Pr->UseFutroTiming == TRUE){ /*Futro timing: 741 + 301C, channelB timing error*/
+
+	if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD){
+		
+		if(SiS_Pr->CHDisplay == 1280  &&  SiS_Pr->CVDisplay == 1024)	
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,0x03);
+		else if  (SiS_Pr->CHDisplay ==  1600 &&  SiS_Pr->CVDisplay == 1200)
+			SiS_SetRegANDOR(SiS_Pr->SiS_Part1Port,0x2d,0xf0,0x02);
+
+		xf86DrvMsg(0, X_INFO, "Special Timing has been set\n");
+	}	
+   }
+
+
+
+   
 }
 
 static void
@@ -10587,29 +11012,29 @@ SetPanelParms661(struct SiS_Private *SiS_Pr)
 {
    unsigned char  *ROMAddr = SiS_Pr->VirtualRomBase;
    unsigned short romptr, temp1, temp2;
-
-   if(SiS_Pr->SiS_VBType & (VB_SISLVDS | VB_SIS30xC)) {
-      SiS_SetRegAND(SiS_Pr->SiS_Part4Port,0x24,0x0f);
-   }
-
+   #ifdef TWDEBUG
+   unsigned char part4_0x24;
+   #endif
+   /*Ivans modify the PART4-0x24's value opration from ROM */
+   /*we don't rewrite part4-0x24's value if user do not using Option "LVDSHL" "0~3"*/
+  /*just using original setting value by VBIOS from booting util here.*/
    if(SiS_Pr->SiS_VBType & VB_SISLVDS) {
       if(SiS_Pr->LVDSHL != -1) {
-         SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,SiS_Pr->LVDSHL);
+      #ifdef TWDEBUG
+      xf86DrvMsg(0,X_INFO,"[SetPanelParms661->LVDSHL!=-1]:LVDSHL=%d.\n",SiS_Pr->LVDSHL);
+      #endif
+      
+      SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,0xfc,SiS_Pr->LVDSHL);
+      
+      #ifdef TWDEBUG
+      part4_0x24 = SiS_GetReg(SiS_Pr->SiS_Part4Port,0x24);
+      xf86DrvMsg(0,X_INFO,"[SetPanelParms661->after LVDSHL write in part4 0x24]:part4_0x24=%x.\n",part4_0x24); 
+      #endif
       }
    }
 
    if(SiS_Pr->SiS_ROMNew) {
-
       if((romptr = GetLCDStructPtr661_2(SiS_Pr))) {
-         if(SiS_Pr->SiS_VBType & VB_SISLVDS) {
-            temp1 = (ROMAddr[romptr] & 0x03) | 0x0c;
-	    temp2 = 0xfc;
-	    if(SiS_Pr->LVDSHL != -1) {
-	      temp1 &= 0xfc;
-	      temp2 = 0xf3;
-	    }
-	    SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x24,temp2,temp1);
-         }
 	 if(SiS_Pr->SiS_VBInfo & SetCRT2ToLCD) {
             temp1 = (ROMAddr[romptr + 1] & 0x80) >> 1;
             SiS_SetRegANDOR(SiS_Pr->SiS_Part4Port,0x0d,0xbf,temp1);
@@ -10707,7 +11132,7 @@ SiS_FinalizeLCD(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned shor
      modeflag =  SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_ModeFlag;
   }
 
-  if(IS_SIS650) {
+  if(SiS_Pr->ChipType == SIS_650) {
      if(!(SiS_GetReg(SiS_Pr->SiS_P3d4, 0x5f) & 0xf0)) {
         if(SiS_Pr->SiS_CustomT == CUT_CLEVO1024) {
 	   SiS_SetRegOR(SiS_Pr->SiS_Part1Port,0x1e,0x02);
@@ -10797,7 +11222,7 @@ SiS_FinalizeLCD(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned shor
 	      if((ModeNo > 0x13) && (resinfo == SIS_RI_1024x768)) {
 	         SiS_SetReg(SiS_Pr->SiS_Part1Port,0x18,0x02);  /* 1.10.7u */
 #if 0
-	         tempbx = 806;  /* 0x326 */			 /* other older BIOSes */
+	         tempbx = 806;  			 /* other older BIOSes */
 		 tempbx--;
 		 temp = tempbx & 0xff;
 		 SiS_SetReg(SiS_Pr->SiS_Part1Port,0x1b,temp);
@@ -11303,3 +11728,7 @@ SiS_OEM300Setting(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned sh
 }
 #endif
 
+unsigned int SiS_CheckLVDS(struct SiS_Private * SiS_Pr)   /* karma@080401 check LVDS to enable DualLink */
+{
+      return(SiS_GetReg(SiS_Pr->SiS_P3d4, 0x7E) & 0x01);
+}
diff --git a/src/init301.h b/src/init301.h
index a95276c..1b89238 100644
--- a/src/init301.h
+++ b/src/init301.h
@@ -64,9 +64,6 @@
 #ifdef SIS_LINUX_KERNEL
 #include "vgatypes.h"
 #include "vstruct.h"
-#ifdef SIS_CP
-#undef SIS_CP
-#endif
 #include <linux/config.h>
 #include <linux/version.h>
 #include <linux/types.h>
@@ -161,7 +158,8 @@ static const unsigned char SiS_TVPhase[] =
 	0x21,0xE6,0xEF,0xA4,	/* 0x0a SiS_PALMPhase2 */
 	0x21,0xF6,0x94,0x46,	/* 0x0b SiS_PALNPhase2 */
 	0x1E,0x8B,0xA2,0xA7,
-	0x1E,0x83,0x0A,0xE0,	/* 0x0d SiS_SpecialPhaseM */
+  /*0x1E,0x83,0x0A,0xE0,*/	/* 0x0d SiS_SpecialPhaseM OLD*/
+	0x1E,0x83,0x00,0xE0,	/* 0x0d SiS_SpecialPhaseM */
 	0x00,0x00,0x00,0x00,
 	0x00,0x00,0x00,0x00,
 	0x1e,0x8c,0x5c,0x7a,	/* 0x10 SiS_SpecialPhase */
@@ -449,5 +447,6 @@ extern unsigned int	sisfb_read_lpc_pci_dword(struct SiS_Private *SiS_Pr, int reg
 extern void		SiS_SetGroup2_C_ELV(struct SiS_Private *SiS_Pr, unsigned short ModeNo,
 				unsigned short ModeIdIndex, unsigned short RefreshRateTableIndex);
 #endif
-
 #endif
+
+unsigned int SiS_CheckLVDS(struct SiS_Private *SiS_Pr); /* karma@080401 check LVDS to enable DualLink */
\ No newline at end of file
diff --git a/src/initdef.h b/src/initdef.h
index e9d0467..bad15ff 100644
--- a/src/initdef.h
+++ b/src/initdef.h
@@ -53,24 +53,6 @@
 #ifndef _INITDEF_
 #define _INITDEF_
 
-#define IS_SIS330		(SiS_Pr->ChipType == SIS_330)
-#define IS_SIS550		(SiS_Pr->ChipType == SIS_550)
-#define IS_SIS650		(SiS_Pr->ChipType == SIS_650)  /* All versions, incl 651, M65x */
-#define IS_SIS740		(SiS_Pr->ChipType == SIS_740)
-#define IS_SIS651	        (SiS_Pr->SiS_SysFlags & (SF_Is651 | SF_Is652))
-#define IS_SISM650	        (SiS_Pr->SiS_SysFlags & (SF_IsM650 | SF_IsM652 | SF_IsM653))
-#define IS_SIS65x               (IS_SIS651 || IS_SISM650)       /* Only special versions of 65x */
-#define IS_SIS661		(SiS_Pr->ChipType == SIS_661)
-#define IS_SIS741		(SiS_Pr->ChipType == SIS_741)
-#define IS_SIS660		(SiS_Pr->ChipType == SIS_660)
-#define IS_SIS760		(SiS_Pr->ChipType == SIS_760)
-#define IS_SIS761		(SiS_Pr->ChipType == SIS_761)
-#define IS_SIS661741660760	(IS_SIS661 || IS_SIS741 || IS_SIS660 || IS_SIS760 || IS_SIS761)
-#define IS_SIS650740            ((SiS_Pr->ChipType >= SIS_650) && (SiS_Pr->ChipType < SIS_330))
-#define IS_SIS550650740         (IS_SIS550 || IS_SIS650740)
-#define IS_SIS650740660         (IS_SIS650 || IS_SIS740 || IS_SIS661741660760)
-#define IS_SIS550650740660      (IS_SIS550 || IS_SIS650740660)
-
 #define SISGETROMW(x)		(ROMAddr[(x)] | (ROMAddr[(x)+1] << 8))
 
 /* SiS_VBType */
@@ -91,7 +73,7 @@
 #define VB_SISLVDS		(VB_SIS301LV | VB_SIS302LV | VB_SIS302ELV | VB_SIS307LV)
 #define VB_SIS30xBLV		(VB_SIS30xB | VB_SISLVDS)
 #define VB_SIS30xCLV		(VB_SIS30xC | VB_SIS302ELV | VB_SIS307LV)
-#define VB_SISVB		(VB_SIS301 | VB_SIS30xBLV)
+#define VB_SISVB		(VB_SISTMDS | VB_SISLVDS)
 #define VB_SISLCDA		(VB_SIS302B | VB_SIS301C  | VB_SIS307T  | VB_SISLVDS)
 #define VB_SISTMDSLCDA		(VB_SIS301C | VB_SIS307T)
 #define VB_SISPART4SCALER	(VB_SIS301C | VB_SIS307T | VB_SIS302ELV | VB_SIS307LV)
@@ -173,8 +155,8 @@
 #define SupportRAMDAC2_162      0x0200  /* B, C          (<= 162Mhz) */
 #define SupportRAMDAC2_202      0x0400  /* C             (<= 202Mhz) */
 #define InterlaceMode           0x0080
-#define SyncPP                  0x0000
 #define HaveWideTiming		0x2000	/* Have specific wide- and non-wide timing */
+#define SyncPP                  0x0000
 #define SyncPN                  0x4000
 #define SyncNP                  0x8000
 #define SyncNN                  0xc000
@@ -213,7 +195,7 @@
 
 #define TVSetYPbPrProg		(TVSetYPbPr525p | TVSetYPbPr625p | TVSetYPbPr750p)
 #define TVSetPALTiming		(TVSetPAL | TVSetYPbPr625i | TVSetYPbPr625p)
-
+#define TVSetInterlace                  (TVSetPAL |TVSetNTSCJ|TVSetNTSC1024|TVSetPALM|TVSetPALN|TVSetYPbPr525i|TVSetYPbPr625i)
 /* YPbPr flag (>=315, <661; converted to TVMode) */
 #define YPbPr525p               0x0001
 #define YPbPr750p               0x0002
@@ -227,6 +209,7 @@
 #define SF_Is652		0x0004
 #define SF_IsM652		0x0008
 #define SF_IsM653		0x0010
+#define SF_Is65x		(SF_Is651 | SF_IsM650 | SF_Is652 | SF_IsM652 | SF_IsM653)
 #define SF_IsM661		0x0020
 #define SF_IsM741		0x0040
 #define SF_IsM760		0x0080
@@ -431,6 +414,8 @@
 #define Panel661_1680x1050      0x0d
 #define Panel661_1280x720       0x0e
 #define Panel661_Custom		0x0f
+/*#define Panel661_1440x900	0x?? */
+/*#define Panel661_1920x1200	0x?? */
 
 #define Panel_800x600           0x01	/* Unified values */
 #define Panel_1024x768          0x02    /* MUST match BIOS values from 0-e */
@@ -457,6 +442,9 @@
 #define Panel_1280x800_2	0x17    /* 30xLV */
 #define Panel_856x480		0x18
 #define Panel_1280x854		0x19	/* 661etc */
+#define Panel_1440x900		0x1a
+#define Panel_1920x1200		0x1b 
+#define Panel_1366x768          0x1c  /*315+307LV, Ivans@090109*/
 
 /* Index in ModeResInfo table */
 #define SIS_RI_320x200    0
@@ -494,6 +482,9 @@
 #define SIS_RI_960x540   32
 #define SIS_RI_960x600   33
 #define SIS_RI_1280x854  34
+#define SIS_RI_1440x900  35
+#define SIS_RI_1920x1200 36
+#define SIS_RI_1366x768  37 //Ivans@090109
 
 /* CR5F */
 #define IsM650                  0x80
@@ -501,6 +492,7 @@
 /* Timing data */
 #define NTSCHT                  1716
 #define NTSC2HT                 1920
+#define NTSC3HT					1907				/* (karma) for TV composite mode 1024x768 */
 #define NTSCVT                  525
 #define PALHT                   1728
 #define PALVT                   625
@@ -550,6 +542,8 @@
 #define VCLK_1360x768		0x58
 #define VCLK_1280x800_315	0x6c
 #define VCLK_1280x854		0x76
+#define VCLKLCD1440_900		0x77
+#define VCLKLCD1366_768         0x7b /*1366x768 LVDS. Ivans@090109*/
 
 #define TVCLKBASE_300		0x21   /* Indices on TV clocks in VCLKData table (300) */
 #define TVCLKBASE_315	        0x3a   /* Indices on TV clocks in (VB)VCLKData table (315) */
diff --git a/src/initextx.c b/src/initextx.c
index a9db870..7b25496 100644
--- a/src/initextx.c
+++ b/src/initextx.c
@@ -43,12 +43,6 @@ SiS_MakeClockRegs(ScrnInfoPtr pScrn, int clock, unsigned char *p2b, unsigned cha
    int          out_n, out_dn, out_div, out_sbit, out_scale;
    unsigned int vclk[5];
 
-#define Midx         0
-#define Nidx         1
-#define VLDidx       2
-#define Pidx         3
-#define PSNidx       4
-
    if(SiS_compute_vclk(clock, &out_n, &out_dn, &out_div, &out_sbit, &out_scale)) {
       (*p2b) = (out_div == 2) ? 0x80 : 0x00;
       (*p2b) |= ((out_n - 1) & 0x7f);
@@ -61,20 +55,21 @@ SiS_MakeClockRegs(ScrnInfoPtr pScrn, int clock, unsigned char *p2b, unsigned cha
 #endif
    } else {
       SiSCalcClock(pScrn, clock, 2, vclk);
-      (*p2b) = (vclk[VLDidx] == 2) ? 0x80 : 0x00;
-      (*p2b) |= (vclk[Midx] - 1) & 0x7f;
-      (*p2c) = (vclk[Nidx] - 1) & 0x1f;
-      if(vclk[Pidx] <= 4) {
+      (*p2b) = (vclk[SIS_VCLK_VLDidx] == 2) ? 0x80 : 0x00;
+      (*p2b) |= (vclk[SIS_VCLK_Midx] - 1) & 0x7f;
+      (*p2c) = (vclk[SIS_VCLK_Nidx] - 1) & 0x1f;
+      if(vclk[SIS_VCLK_Pidx] <= 4) {
 	 /* postscale 1,2,3,4 */
-	 (*p2c) |= ((vclk[Pidx] - 1) & 3) << 5;
+	 (*p2c) |= ((vclk[SIS_VCLK_Pidx] - 1) & 3) << 5;
       } else {
 	 /* postscale 6,8 */
-	 (*p2c) |= (((vclk[Pidx] / 2) - 1) & 3) << 5;
+	 (*p2c) |= (((vclk[SIS_VCLK_Pidx] / 2) - 1) & 3) << 5;
 	 (*p2c) |= 0x80;
       }
 #ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clock %d: n %d dn %d div %d sc %d\n",
-		clock, vclk[Midx], vclk[Nidx], vclk[VLDidx], vclk[Pidx]);
+		clock, vclk[SIS_VCLK_Midx], vclk[SIS_VCLK_Nidx],
+		vclk[SIS_VCLK_VLDidx], vclk[SIS_VCLK_Pidx]);
 #endif
    }
 }
@@ -183,8 +178,8 @@ SiS_CheckBuildCustomMode(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VB
 }
 
 /* Build a list of supported modes:
- * Built-in modes for which we have all data are M_T_DEFAULT,
- * modes derived from DDC or database data are M_T_BUILTIN
+ * - Built-in modes for which we have all data are M_T_DEFAULT,
+ * - modes derived from DDC or database data are M_T_BUILTIN
  */
 DisplayModePtr
 SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfordvi,
@@ -200,13 +195,28 @@ SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfo
    DisplayModePtr backup = NULL;
 #endif
 
-   pSiS->backupmodelist = NULL;
+   /*chaoyu modified: some important modes that most scalers support*/
+    unsigned char RefIndex_ModeIDMask[] = {0x6a,/*800x600*/\
+           					    0x2e,/*640*480*/\
+						    0x37,/*1024*768*/\
+						    0x3a,/*1280*1024*/\
+						    0x3c,/*1600*1200*/\
+						    0x68,/*1920*1440*/\
+						    0x6c,/*2048*1536*/\
+						    0x14,/*1280*800*/\
+						    0x3a,/*1280*1024*/\
+						    0x26,/*1400x1050*/\
+						    0x67,/*1440x900 Ivans added.*/\
+						    0x7f,/*1366x768 Ivans@090109*/\
+						    0xff};
+
    pSiS->AddedPlasmaModes = FALSE;
 
    UseWide = pSiS->SiS_Pr->SiS_UseWide;
    if(IsForCRT2) UseWide = pSiS->SiS_Pr->SiS_UseWideCRT2;
 
-   if(!SiSInitPtr(pSiS->SiS_Pr)) return NULL;
+   if(!SiSInitPtr(pSiS->SiS_Pr))
+      return NULL;
 
    i = 0;
    while(pSiS->SiS_Pr->SiS_RefIndex[i].Ext_InfoFlag != 0xFFFF) {
@@ -240,6 +250,43 @@ SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfo
 	 continue;
       }
 
+     
+     /* chaoyu modified: If the display is CRT2_LCD (such as laptops), we prune some unsuitable modes.
+
+        This is because the LCD scaler may not support these modes.*/
+   
+     if (pSiS->VBFlags & CRT2_LCD) {
+        j=0;
+        k=0;	
+        while(RefIndex_ModeIDMask[j] != 0xff){
+            if (pSiS->SiS_Pr->SiS_RefIndex[i].ModeID == RefIndex_ModeIDMask[j]) {
+                k=1;
+                break;
+            }
+            j++;
+	}
+     
+        if(k == 0) {
+	  i++;
+	  continue;
+	} 	
+      }
+      if((pSiS->LCDwidth==1440)&&(pSiS->LCDheight==900)){ /*Ivans block1280x800 on 1440x900 Panel.*/
+	 if(pSiS->SiS_Pr->SiS_RefIndex[i].ModeID==0x14){
+		i++;
+		continue;
+	 }
+      }
+      if(pSiS->LCDwidth == 1366){/*block 640x480 on 1366x768 panel. Ivans@090109*/
+        if(pSiS->SiS_Pr->SiS_RefIndex[i].ModeID==0x2e){
+	    i++;
+	    continue;  
+	}
+      }
+
+
+
+
       if(!(new = xalloc(sizeof(DisplayModeRec)))) return first;
       memset(new, 0, sizeof(DisplayModeRec));
       if(!(new->name = xalloc(10))) {
@@ -253,7 +300,6 @@ SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfo
       }
 
       current = new;
-
       sprintf(current->name, "%dx%d", pSiS->SiS_Pr->SiS_RefIndex[i].XRes,
 				      pSiS->SiS_Pr->SiS_RefIndex[i].YRes);
 
@@ -337,7 +383,7 @@ SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfo
 	 current->VSyncEnd >>= 1;
 	 current->VTotal >>= 1;
       }
-
+     
 #ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	"Built-in: %s %.2f %d %d %d %d %d %d %d %d\n",
@@ -363,7 +409,7 @@ SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfo
 
      if(SiS_PlasmaTable[i].vendor == pSiS->SiS_Pr->CP_Vendor) {
 
-	for(j=0; j<SiS_PlasmaTable[i].productnum; j++) {
+	for(j = 0; j < SiS_PlasmaTable[i].productnum; j++) {
 
 	    if(SiS_PlasmaTable[i].product[j] == pSiS->SiS_Pr->CP_Product) {
 
@@ -371,7 +417,7 @@ SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN includelcdmodes, BOOLEAN isfo
 		  "Identified %s panel, adding specific modes\n",
 		  SiS_PlasmaTable[i].plasmaname);
 
-	       for(k=0; k<SiS_PlasmaTable[i].modenum; k++) {
+	       for(k = 0; k < SiS_PlasmaTable[i].modenum; k++) {
 
 		  if(isfordvi) {
 		     if(!(SiS_PlasmaTable[i].plasmamodes[k] & 0x80)) continue;
@@ -597,6 +643,20 @@ SiSTranslateToOldMode(int modenumber)
    return modenumber;
 }
 
+unsigned short
+SiS_GetModeNumber(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags)
+{
+   SISPtr  pSiS = SISPTR(pScrn);
+   UShort  i = pSiS->CurrentLayout.bytesPerPixel - 1;
+   BOOLEAN FSTN = pSiS->FSTN ? TRUE : FALSE;
+
+#ifdef SISDUALHEAD
+   if(pSiS->DualHeadMode && pSiS->SecondHead) FSTN = FALSE;
+#endif
+   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
+			i, FSTN, pSiS->LCDwidth, pSiS->LCDheight));
+}
+
 BOOLEAN
 SiS_GetPanelID(struct SiS_Private *SiS_Pr)
 {
@@ -750,14 +810,18 @@ SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
    int retry, i;
    int panel1280x960 = (pSiS->VGAEngine == SIS_315_VGA) ? Panel310_1280x960 : Panel300_1280x960;
    unsigned char buffer[256];
+   xf86MonPtr pMonitor;
 
-   for(i=0; i<7; i++) SiS_Pr->CP_DataValid[i] = FALSE;
+   for(i = 0; i < 7; i++) {
+      SiS_Pr->CP_DataValid[i] = FALSE;
+   }
    SiS_Pr->CP_HaveCustomData = FALSE;
    SiS_Pr->CP_MaxX = SiS_Pr->CP_MaxY = SiS_Pr->CP_MaxClock = 0;
    SiS_Pr->CP_PreferredX = SiS_Pr->CP_PreferredY = 0;
    SiS_Pr->CP_PreferredIndex = -1;
    SiS_Pr->CP_PrefClock = 0;
    SiS_Pr->PanelSelfDetected = FALSE;
+   SiSFreeEDID(pSiS->pScrn, &pSiS->currcrt2digitaledid);
 
    if(!(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE)) return 0;
    if(pSiS->VBFlags2 & VB2_30xBDH) return 0;
@@ -772,7 +836,8 @@ SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
    adapternum = 1;
    if(SiS_Pr->DDCPortMixup) adapternum = 0;
 
-   if(SiS_InitDDCRegs(SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, adapternum, 0, FALSE, pSiS->VBFlags2) == 0xFFFF)
+   if(SiS_InitDDCRegs(SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine,
+			adapternum, 0, FALSE, pSiS->VBFlags2) == 0xFFFF)
       return 0;
 
    SiS_Pr->SiS_DDC_SecAddr = 0x00;
@@ -835,6 +900,14 @@ SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
 	 return 0;
       }
 
+      /* save current CRT2 (digital) EDID */
+      if(pSiS->haveDDC) {
+         if((pMonitor = xf86InterpretEDID(pSiS->pScrn->scrnIndex, buffer))) {
+            pMonitor->rawData = NULL;
+            pMonitor = SiSSetEDIDPtr(&pSiS->currcrt2digitaledid, pMonitor);
+         }
+      }
+
       /* Save given gamma */
       pSiS->CRT2LCDMonitorGamma = (buffer[0x17] + 100) * 10;
 
@@ -1148,7 +1221,9 @@ SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
 	 return 0;
       }
 
-      /* Save given gamma */
+      /* No function for EDID V2, no point in saving */
+
+      /* save given gamma */
       pSiS->CRT2LCDMonitorGamma = (buffer[0x56] + 100) * 10;
 
       SiS_Pr->CP_Vendor = panelvendor = buffer[2] | (buffer[1] << 8);
@@ -1395,6 +1470,9 @@ SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
    BOOLEAN foundcrt = FALSE;
    int retry;
    unsigned char buffer[256];
+   xf86MonPtr pMonitor;
+
+   SiSFreeEDID(pSiS->pScrn, &pSiS->currcrt2analogedid);
 
    if(!(pSiS->VBFlags2 & VB2_SISVGA2BRIDGE)) return 0;
 
@@ -1408,7 +1486,8 @@ SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
     * Hence, no reliable CRT detection here... we need to fall back to
     * the sensing stuff in sis_vb.c.
     */
-   if(SiS_Pr->DDCPortMixup) return 0;
+   if(SiS_Pr->DDCPortMixup)
+      return 0;
 
    if(SiS_InitDDCRegs(SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, 2, 0, FALSE, pSiS->VBFlags2) == 0xFFFF)
       return 0;
@@ -1464,7 +1543,15 @@ SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
       SiS_Pr->CP_Product = buffer[10] | (buffer[11] << 8);
       foundcrt = TRUE;
 
-      /* Save given gamma */
+      /* save current CRT2 (analog) EDID */
+      if(pSiS->haveDDC) {
+         if((pMonitor = xf86InterpretEDID(pSiS->pScrn->scrnIndex, buffer))) {
+            pMonitor->rawData = NULL;
+            pMonitor = SiSSetEDIDPtr(&pSiS->currcrt2analogedid, pMonitor);
+         }
+      }
+
+      /* save given gamma */
       pSiS->CRT2VGAMonitorGamma = (buffer[0x17] + 100) * 10;
 
       break;
@@ -1489,7 +1576,9 @@ SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
       SiS_Pr->CP_Product = buffer[3] | (buffer[4] << 8);
       foundcrt = TRUE;
 
-      /* Save given gamma */
+      /* No interpret function for EDID V2, no point in saving it */
+
+      /* save given gamma */
       pSiS->CRT2VGAMonitorGamma = (buffer[0x56] + 100) * 10;
 
       break;
@@ -1498,7 +1587,8 @@ SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS)
    if(foundcrt) {
       SiS_SetRegOR(SiS_Pr->SiS_P3d4,0x32,0x10);
    }
-   return(0);
+
+   return 0;
 }
 
 /* 4-tap scaler for 301C and later */
@@ -1621,8 +1711,10 @@ SiS_SetGroup2_C_ELV(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned
    if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) {
       SiS_CalcXTapScaler(SiS_Pr, SiS_Pr->SiS_VGAVDE, SiS_Pr->SiS_VDE, 4, FALSE);
    }
-
    temp = 0x10;
+   if(SiS_Pr->ChipType>=SIS_761){
+       temp = 0; 
+   }
    if(SiS_Pr->SiS_VBInfo & SetCRT2ToTV) temp |= 0x04;
    SiS_SetRegANDOR(SiS_Pr->SiS_Part2Port,0x4e,0xeb,temp);
 }
diff --git a/src/initextx.h b/src/initextx.h
index 5439b64..76e4237 100644
--- a/src/initextx.h
+++ b/src/initextx.h
@@ -462,6 +462,7 @@ unsigned short	SiS_CheckBuildCustomMode(ScrnInfoPtr pScrn, DisplayModePtr mode,
 DisplayModePtr	SiSBuildBuiltInModeList(ScrnInfoPtr pScrn, BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN);
 int		SiSTranslateToVESA(ScrnInfoPtr pScrn, int modenumber);
 int		SiSTranslateToOldMode(int modenumber);
+unsigned short	SiS_GetModeNumber(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags);
 BOOLEAN		SiS_GetPanelID(struct SiS_Private *SiS_Pr);
 
 unsigned short	SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS);
@@ -482,6 +483,8 @@ extern int		SiS_compute_vclk(int Clock, int *out_n, int *out_dn, int *out_div,
 extern void		SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD, unsigned int *vclk);
 extern void		SiS_CalcCRRegisters(struct SiS_Private *SiS_Pr, int depth);
 extern BOOLEAN		SiSInitPtr(struct SiS_Private *SiS_Pr);
+extern unsigned short	SiS_GetModeID(int VGAEngine, unsigned int VBFlags, int HDisplay, int VDisplay,
+				int Depth, BOOLEAN FSTN, int LCDwith, int LCDheight);
 extern unsigned short	SiS_GetRefCRT1CRTC(struct SiS_Private *SiS_Pr, unsigned short Index, int UseWide);
 extern unsigned short	SiS_GetRefCRTVCLK(struct SiS_Private *SiS_Pr, unsigned short Index, int UseWide);
 extern void		SiS_Generic_ConvertCRData(struct SiS_Private *SiS_Pr, unsigned char *crdata,
diff --git a/src/sis.h b/src/sis.h
index 3f5c2d3..7a85980 100644
--- a/src/sis.h
+++ b/src/sis.h
@@ -1,5 +1,5 @@
 /* $XFree86$ */
-/* $XdotOrg: driver/xf86-video-sis/src/sis.h,v 1.67 2006/04/07 21:05:21 ajax Exp $ */
+/* $XdotOrg$ */
 /*
  * Main global data and definitions
  *
@@ -35,14 +35,9 @@
 #ifndef _SIS_H_
 #define _SIS_H_
 
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include <setjmp.h>
-
-#define SISDRIVERVERSIONYEAR    5
-#define SISDRIVERVERSIONMONTH   9
-#define SISDRIVERVERSIONDAY     20
+#define SISDRIVERVERSIONYEAR    6
+#define SISDRIVERVERSIONMONTH   10
+#define SISDRIVERVERSIONDAY     17
 #define SISDRIVERREVISION       1
 
 #define SISDRIVERIVERSION ((SISDRIVERVERSIONYEAR << 16) |  \
@@ -62,12 +57,7 @@
 #endif
 
 #if 0
-#define TWDEBUG    /* for debugging */
-#endif
-
-#undef SIS_CP
-#if 0
-#include "siscp.H"
+#define TWDEBUG    
 #endif
 
 #include "compiler.h"
@@ -81,9 +71,24 @@
 #include "xf86cmap.h"
 #include "vbe.h"
 
+/*I.L. modified*/
+#include "sispcirename.h" 
+
+#ifdef XSERVER_LIBPCIACCESS
+#include <pciaccess.h>
+#else
+#include "xf86_ansic.h"
+#endif
+
+
 #define SIS_HaveDriverFuncs 0
 
 #undef SISISXORG6899900
+#undef SISISXORG6899901
+#undef SIS_HAVE_RR_FUNC
+#undef SIS_HAVE_RANDR_SIZE_PATCH
+#undef SIS_HAVE_RR_GET_MODE_MM
+
 #ifdef XORG_VERSION_CURRENT
 #include "xorgVersion.h"
 #define SISMYSERVERNAME "X.org"
@@ -92,33 +97,68 @@
 	(((major) * 10000000) + ((minor) * 100000) + ((patch) * 1000) + snap)
 #define XF86_VERSION_CURRENT XF86_VERSION_NUMERIC(4,3,99,902,0)
 #endif
-#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(6,8,99,900,0)
-#define SISISXORG6899900
+
+/*** Xorg Version Path <= X-Server 2.0 ***/
+/* K.T for xorg 1.3 */
+#if XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(2,0,0,0,0)
+#if XORG_VERSION_CURRENT == XORG_VERSION_NUMERIC(1,3,0,0,0)
+#define XORG_VERSION_CURRENT (((7) * 10000000) + ((2) * 100000) + ((0) * 1000) + 0)
+/* IvansLee for Xorg 1.4 */
+#elif XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,4,0,0,0)
+#define XORG_VERSION_CURRENT (((7) * 10000000) + ((2) * 100000) + ((0) * 1000) + 0)
+#define NEW_XORG_VERSION 1
 #endif
-#if 0
+#endif
+
+#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(6,8,0,0,0)
+#define SIS_HAVE_RR_FUNC
 #ifdef HaveDriverFuncs
-#define SIS_HAVE_DRIVER_FUNC
 #undef  SIS_HaveDriverFuncs
 #define SIS_HaveDriverFuncs HaveDriverFuncs
-#endif
-#endif
-#else
+#define SIS_HAVE_DRIVER_FUNC
+#endif /* HaveDriverFuncs */
+#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(6,8,99,900,0)
+#define SISISXORG6899900
+#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(6,8,99,901,0)
+#define SISISXORG6899901
+#ifdef RANDR
+#define SIS_HAVE_RR_GET_MODE_MM
+#define SIS_HAVE_RANDR_SIZE_PATCH
+#endif /* RANDR */
+#endif /* >= 6.8.99.901 */
+#endif /* >= 6.8.99.900 */
+#endif /* >= 6.8.0.0    */
+#else   /* XORG_VERSION_CURRENT */
 #include "xf86Version.h"
 #define SISMYSERVERNAME "XFree86"
 #endif
 
+/*I.L. modified*/
+//#define NEC_CASE  /*It used the old Xorg_Version with new PCI structure.*/
+
+#ifdef XSERVER_LIBPCIACCESS
+#ifdef NEC_CASE
+#define XORG_VERSION_CURRENT (((7) * 10000000) + ((1) * 100000) + ((0) * 1000) + 0)
+#else
+#define XORG_VERSION_CURRENT (((7) * 10000000) + ((4) * 100000) + ((0) * 1000) + 0)
+#endif
+#endif
+
+
 #define SIS_NAME                "SIS"
 #define SIS_DRIVER_NAME         "sis"
 #define SIS_MAJOR_VERSION       0
-#ifdef SISISXORG6899900
-#define SIS_MINOR_VERSION       9	/* DRI changes */
-#define SIS_PATCHLEVEL		1
-#else
+
+/* chris, sync. with DRI(3D driver) request version */
+/*#ifdef SISISXORG6899900*/
+#define SIS_MINOR_VERSION       8	/* DRI changes */
+/*#else
 #define SIS_MINOR_VERSION       7
-#define SIS_PATCHLEVEL          1
-#endif
+#endif*/
+#define SIS_PATCHLEVEL          0
 #define SIS_CURRENT_VERSION     ((SIS_MAJOR_VERSION << 16) | \
-                                 (SIS_MINOR_VERSION << 8) | SIS_PATCHLEVEL )
+				 (SIS_MINOR_VERSION <<  8) | \
+				 (SIS_PATCHLEVEL))
 
 #if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
 #include "xf86xv.h"
@@ -175,7 +215,7 @@
 #if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,14,0)
 #define SISNEWDRI
 #endif
-#undef SIS315DRI		/* define this if dri is adapted for 315/330 series */
+#define SIS315DRI		/* define this if dri is adapted for 315/330 series */
 #include "xf86drm.h"
 #include "sarea.h"
 #define _XF86DRI_SERVER_
@@ -184,56 +224,14 @@
 #include "sis_dri.h"
 #endif /* XF86DRI */
 
-/* Configurable stuff: ------------------------------------- */
-
-#define SISDUALHEAD		/* Include Dual Head code  */
-
-#define SISMERGED		/* Include Merged-FB code */
-
-#undef SISXINERAMA
-#ifdef SISMERGED
-#define SISXINERAMA		/* Include SiS Pseudo-Xinerama for MergedFB mode */
-#define SIS_XINERAMA_MAJOR_VERSION  1
-#define SIS_XINERAMA_MINOR_VERSION  1
-#endif
-
-#define SIS_ARGB_CURSOR		/* Include code for color hardware cursors */
-
-#define ENABLE_YPBPR		/* Include YPbPr support on SiS bridges (315 series and 661/741/760) */
-
-#define SISVRAMQ		/* Use VRAM queue mode on 315/330/340/XGI series */
-
-#undef INCL_YUV_BLIT_ADAPTOR
-#ifdef SISVRAMQ
-#define INCL_YUV_BLIT_ADAPTOR	/* Include support for YUV->RGB blit adaptors (VRAM queue mode only) */
-#endif
-
-#if 1
-#define SIS_USE_XAA		/* Include code for XAA */
-#endif
-
-#ifdef SISVRAMQ
-#ifdef XORG_VERSION_CURRENT
-#if defined(SIS_HAVE_EXA) || (defined(XF86EXA) && (XF86EXA != 0))
-#if 1
-#define SIS_USE_EXA		/* Include code for EXA */
-#endif
-#endif
-#endif
-#endif
-
-#if 0
-#define SISDEINT		/* Include Xv deinterlacer code (not functional yet!) */
-#endif
-
-#if 0
-#define XV_SD_DEPRECATED	/* Include deprecated XV SD interface for SiSCtrl */
-#endif
-
-/* End of configurable stuff --------------------------------- */
+#include "sis_config.h"
 
 #define UNLOCK_ALWAYS		/* Always unlock the registers (should be set!) */
 
+/* HWMC Surfaces */
+#define SIS_MAX_SURFACES 6
+#define SIS_MAX_SUBPICTURES 2
+
 #if !defined(SIS_USE_XAA) && !defined(SIS_USE_EXA)
 #define SIS_USE_XAA
 #endif
@@ -251,6 +249,23 @@
 #include "extnsionst.h" 			/* required */
 #include <X11/extensions/panoramiXproto.h> 	/* required */
 
+#ifndef RR_Rotate_0
+#define RR_Rotate_0 1
+#endif
+#ifndef RR_Rotate_90
+#define RR_Rotate_90 2
+#endif
+#ifndef RR_Rotate_180
+#define RR_Rotate_180 4
+#endif
+#ifndef RR_Rotate_270
+#define RR_Rotate_270 8
+#endif
+
+#ifndef M_T_EDID
+#define M_T_EDID  0x040
+#endif
+
 #undef SISCHECKOSSSE
 #ifdef XORG_VERSION_CURRENT
 #if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(6,8,99,13,0)
@@ -279,13 +294,19 @@
 #endif
 #endif
 
+#if 0
+#define SIS761MEMFIX		/* Does the 761 need the same special care as the 760? */
+#endif				/* (apparently not) */
+#if 0
+#define SIS770MEMFIX		/* Does the 770 need the same special care as the 760? */
+#endif				/* (Hopefully no) */
+
 #ifdef TWDEBUG
 #define SISVERBLEVEL 3
 #else
 #define SISVERBLEVEL 4
 #endif
 
-/* For SiS315/550/650/740/330/660 - these should be moved elsewhere! */
 #ifndef PCI_CHIP_SIS315H
 #define PCI_CHIP_SIS315H	0x0310
 #endif
@@ -310,6 +331,12 @@
 #ifndef PCI_CHIP_SIS340
 #define PCI_CHIP_SIS340		0x0340
 #endif
+#ifndef PCI_CHIP_SIS670
+#define PCI_CHIP_SIS670		0x6350	/* 670_VGA, 770_VGA */
+#endif
+#ifndef PCI_CHIP_SIS671
+#define PCI_CHIP_SIS671		0x6351	/* 671_VGA, 771_VGA */
+#endif
 
 #ifndef PCI_VENDOR_XGI
 #define PCI_VENDOR_XGI		0x18ca
@@ -318,7 +345,6 @@
 #ifndef PCI_CHIP_XGIXG20
 #define PCI_CHIP_XGIXG20	0x0020
 #endif
-
 #ifndef PCI_CHIP_XGIXG40
 #define PCI_CHIP_XGIXG40	0x0040
 #endif
@@ -413,7 +439,7 @@
 #define VB2_302LV		0x00002000
 #define VB2_302ELV		0x00004000
 #define VB2_307LV		0x00008000
-#define VB2_30xBDH		0x08000000      /* 30xB DH version (w/o LCD support) */
+#define VB2_30xBDH		0x08000000	/* 30xB DH version (w/o LCD support) */
 #define VB2_CONEXANT		0x10000000	/* >=661 series only */
 #define VB2_TRUMPION		0x20000000	/* 300 series only */
 #define VB2_LVDS		0x40000000
@@ -426,7 +452,7 @@
 #define VB2_SISTMDSLCDABRIDGE	(VB2_301C | VB2_307T)
 #define VB2_SISLCDABRIDGE	(VB2_SISTMDSLCDABRIDGE | VB2_301LV | VB2_302LV | VB2_302ELV | VB2_307LV)
 
-#define VB2_SISHIVISIONBRIDGE	(VB2_301  | VB2_301B | VB2_302B)
+#define VB2_SISHIVISIONBRIDGE	(VB2_301  | VB2_301B | VB2_302B | VB2_307T | VB2_307LV)
 #define VB2_SISYPBPRBRIDGE	(VB2_301C | VB2_307T | VB2_SISLVDSBRIDGE)
 #define VB2_SISYPBPRARBRIDGE	(VB2_301C | VB2_307T | VB2_307LV)
 #define VB2_SISTAP4SCALER	(VB2_301C | VB2_307T | VB2_302ELV | VB2_307LV)
@@ -450,24 +476,29 @@
 #define VB2_RAMDAC202MHZBRIDGE	(VB2_301C  | VB2_307T)
 
 /* pSiS->VBFlags3 (for future use) */
-#define VB3_CRT1_TV		0x00000001
-#define VB3_CRT1_LCD		0x00000002
-#define VB3_CRT1_VGA		0x00000004
-#define TV1_AVIDEO		0x00000100
+#define VB3_CRT1_TV		0x00000001  /* TV via CRT1-bridge */
+#define VB3_CRT1_LCD		0x00000002  /* LCD via CRT1-bridge, NOT LCDA! */
+#define VB3_CRT1_VGA		0x00000004  /* VGA via CRT1 (direct) - as usual */
+#define TV1_AVIDEO		0x00000100  /* CRT1-TV status: */
 #define TV1_SVIDEO		0x00000200
 #define TV1_SCART		0x00000400
-#define TV1_NTSC		0x00000800
-#define TV1_PAL			0x00001000
-#define TV1_YPBPR		0x00002000
+#define TV1_YPBPR		0x00000800
+#define TV1_NTSC		0x00001000
+#define TV1_PAL			0x00002000
 #define TV1_PALM		0x00004000
 #define TV1_PALN		0x00008000
 #define TV1_NTSCJ		0x00010000
-#define TV1_YPBPR525I		0x00020000
-#define TV1_YPBPR525P		0x00040000
-#define TV1_YPBPR625I		0x00080000
-#define TV1_YPBPR625P		0x00100000
-#define TV1_YPBPR750P		0x00200000
-#define TV1_YPBPR1080I		0x00400000
+#define TV1_YPBPR525I		0x00040000
+#define TV1_YPBPR525P		0x00080000
+#define TV1_YPBPR625I		0x00100000
+#define TV1_YPBPR625P		0x00200000
+#define TV1_YPBPR750P		0x00400000
+#define TV1_YPBPR1080I		0x00800000
+
+#define VB3_CRT1_TYPE		(VB3_CRT1_TV | VB3_CRT1_LCD | VB3_CRT1_VGA)
+#define VB3_CRT1_TVPLUG		(TV1_AVIDEO | TV1_SVIDEO | TV1_SCART | TV1_YPBPR)
+#define VB3_CRT1_TVSTD		(TV1_NTSC | TV1_PAL | TV1_PALM | TV1_PALN | TV1_NTSCJ)
+#define VB3_CRT1_YPBPRTYPE	(TV1_YPBPR525I | TV1_YPBPR525P | TV1_YPBPR625I | TV1_YPBPR625P | TV1_YPBPR750P | TV1_YPBPR1080I)
 
 /* pSiS->VBLCDFlags */
 #define VB_LCD_320x480		0x00000001	/* DSTN/FSTN for 550 */
@@ -493,10 +524,14 @@
 #define VB_LCD_856x480		0x00100000
 #define VB_LCD_1280x854		0x00200000
 #define VB_LCD_1920x1200	0x00400000
+#define VB_LCD_1440x900		0x00800000
 #define VB_LCD_UNKNOWN		0x10000000
 #define VB_LCD_BARCO1366	0x20000000
 #define VB_LCD_CUSTOM		0x40000000
 #define VB_LCD_EXPANDING	0x80000000
+/*1366x768x60hz. Ivans@090109*/
+#define VB_LCD_1366x768      0x02000000
+
 
 #define VB_FORBID_CRT2LCD_OVER_1600		/* CRT2/LCD supports only up to 1600 pixels */
 
@@ -509,10 +544,14 @@
 #define MISC_CRT1OVERLAY	0x00000001  /* Current display mode supports overlay (CRT1) */
 #define MISC_PANELLINKSCALER	0x00000002  /* Panel link is currently scaling */
 #define MISC_CRT1OVERLAYGAMMA	0x00000004  /* Current display mode supports overlay gamma corr on CRT1 */
-#define MISC_TVNTSC1024		0x00000008  /* Current display mode is TV NTSC/PALM/YPBPR525I 1024x768  */
 #define MISC_CRT2OVERLAY	0x00000010  /* Current display mode supports overlay (CRT2) */
-#define MISC_SIS760ONEOVERLAY	0x00000020  /* SiS760/761: Only one overlay available currently */
+#define MISC_SIS760ONEOVERLAY	0x00000020  /* SiS760: Only one overlay available currently */
 #define MISC_STNMODE		0x00000040  /* SiS550: xSTN active */
+#define MISC_INTERLACE		0x00000080  /* Current mode is interlaced */
+#define MISC_NOMONOHWCURSOR	0x00000100  /* no mono hw cursor in current display mode */
+#define MISC_NORGBHWCURSOR	0x00000200  /* no argb hw cursor in current display mode */
+#define MISC_CURSORDOUBLESIZE	0x00000400  /* need to stretch cursor image (double scan modes) */
+#define MISC_CURSORMAXHALF	0x00000800  /* maximum cursor size is half */
 
 /* pSiS->SiS6326Flags */
 #define SIS6326_HASTV		0x00000001
@@ -522,6 +561,12 @@
 #define SIS6326_TVDETECTED	0x00000010
 #define SIS6326_TVON		0x80000000
 
+/* pSiS->Hkey_Device_Switch_State is current state for hotkey device switch. */
+#define LCD_only 0 
+#define LCD_VGA_mirror 1
+#define VGA_only 2
+
+
 #ifdef  DEBUG
 #define PDEBUG(p)       p
 #else
@@ -549,7 +594,8 @@ typedef unsigned char  UChar;
 #define SIS_530_VGA 1
 #define SIS_OLD_VGA 2
 #define SIS_300_VGA 3
-#define SIS_315_VGA 4   /* Includes 330/660/661/741/760/340/761 and M versions thereof, XGI */
+#define SIS_315_VGA 4   /* Includes all later chips (+XGI) */
+#define SIS_342_VGA 5   /*671 and 771 version A and B */
 
 /* pSiS->oldChipset */
 #define OC_UNKNOWN   0
@@ -572,7 +618,6 @@ typedef unsigned char  UChar;
 
 /* pSiS->ChipFlags */
 /* Use only lower 16 bit for chip id! (sisctrl) */
-#define SiSCF_LARGEOVERLAY  0x00000001
 #define SiSCF_Is651         0x00000002
 #define SiSCF_IsM650        0x00000004
 #define SiSCF_IsM652        0x00000008
@@ -590,20 +635,28 @@ typedef unsigned char  UChar;
 #define SiSCF_IsXGIV5	    SiSCF_IsM650/* Volari V5 */
 #define SiSCF_IsXGIDUO	    SiSCF_IsM652/* Volari Duo */
 /* ... */
-#define SiSCF_315Core       0x00010000  /* 3D: Real 315 */
-#define SiSCF_Real256ECore  0x00020000  /* 3D: Similar to 315 core, no T&L? (65x, 661, 740, 741) */
-#define SiSCF_XabreCore     0x00040000  /* 3D: Real Xabre */
-#define SiSCF_Ultra256Core  0x00080000  /* 3D: aka "Mirage 2"; similar to Xabre, no T&L?, no P:Shader? (760) */
 #define SiSCF_MMIOPalette   0x00100000  /* HW supports MMIO palette writing/reading */
-#define SiSCF_IsXGI	    0x00200000  /* Is XGI chip (Z7, V3, V5, V8) */
-#define SiSCF_UseLCDA       0x01000000
-#define SiSCF_760LFB        0x08000000  /* 76x: LFB active (if not set, UMA only) */
-#define SiSCF_760UMA        0x10000000  /* 76x: UMA active (if not set, LFB only) */
-#define SiSCF_CRT2HWCKaputt 0x20000000  /* CRT2 Mono HWCursor engine buggy (SiS 330) */
-#define SiSCF_Glamour3      0x40000000
+#define SiSCF_IsXGI	    0x00200000  /* Is XGI chip (Z7, V3XT, V5, V8) */
+#define SiSCF_HaveStrBB     0x00400000  /* Chip has accelerated stretched bitblt */
+#define SiSCF_NoCurHide     0x00800000  /* Chip supports changing hw cursor image without hiding */
+#define SiSCF_DualPipe	    0x04000000
+#define SiSCF_760LFB        0x08000000  /* 760: LFB active (if not set, UMA only) */
+#define SiSCF_760UMA        0x10000000  /* 760: UMA active (if not set, LFB only) */
+#define SiSCF_CRT2HWCKaputt 0x20000000  /* CRT2 Mono HWCursor engine buggy (330) */
+#define SiSCF_761A0	    0x40000000  /* Is 761 rev A0 */
 #define SiSCF_Integrated    0x80000000
 
-/* SiS Direct Xv-API */
+/* pSiS->EngineType3D */
+#define SiS3D_315Core       0x00000001  /* 3D: 315PRO */
+#define SiS3D_Real256ECore  0x00000002  /* 3D: "Mirage": HW DX7, no pixel shader (65x, 661, 740, 741) */
+#define SiS3D_XabreCore     0x00000004  /* 3D: 330/Xabre */
+#define SiS3D_Mirage1       0x00000008	/* 3D: "Mirage 1": HW DX7, no pixel shader (662, 761) */
+#define SiS3D_Ultra256Core  0x00000010  /* 3D: "Mirage 2": HW DX8.1, pixel shader 1.3 (760) */
+#define SiS3D_Mirage3       0x00000020  /* 3D: "Mirage 3": HW DX9, pixel shader 2.0 (670, 770) */
+#define SiS3D_XG40Core	    0x00000040  /* 3D: XG40 core (XGI V5, V8) */
+#define SiS3D_XG42Core	    0x00000080  /* 3D: XG42 core (XGI V3XT) */
+
+/* SiS utility API */
 #define SiS_SD_IS300SERIES     0x00000001
 #define SiS_SD_IS315SERIES     0x00000002
 #define SiS_SD_IS330SERIES     0x00000004
@@ -680,6 +733,10 @@ typedef unsigned char  UChar;
 #define SiS_SD3_NEWOUTPUTSW    0x00000020   /* Supports NEWSETVBFLAGS (for future use) */
 #define SiS_SD3_CRT1SATGAIN    0x00000040   /* Supports CRT1 saturation gain */
 #define SiS_SD3_CRT2SATGAIN    0x00000080   /* Supports CRT2 saturation gain (apart from TV, see SiS_SD2_SUPPTVSAT) */
+#define SiS_SD3_DYNMODELISTS   0x00000100   /* Driver handles modelists dynamically; re-read after output dev change */
+#define SiS_SD3_IS350SERIES    0x00000200   /* 350 core (670, 770) */
+#define SiS_SD3_REDETECTCRT1   0x00000400   /* Support redetection of CRT1 */
+#define SiS_SD3_MFBDYNPOS      0x00000800   /* Support MergedFB dynamic mode-wise placements */
 
 #define SIS_DIRECTKEY          0x03145792
 
@@ -705,11 +762,11 @@ typedef unsigned char  UChar;
 
 /* AGP stuff for DRI */
 #define AGP_PAGE_SIZE 4096
-#define AGP_PAGES     2048	 /* Default: 2048 pages @ 4096 = 8MB */
+#define AGP_PAGES     8192	 /* Default: 8192 pages @ 4096 = 32MB */
 /* 300 */
 #define AGP_CMDBUF_PAGES 256
 #define AGP_CMDBUF_SIZE (AGP_PAGE_SIZE * AGP_CMDBUF_PAGES)
-/* 315/330 */
+/* 315/330/340/XGI */
 #define AGP_VTXBUF_PAGES 512
 #define AGP_VTXBUF_SIZE (AGP_PAGE_SIZE * AGP_VTXBUF_PAGES)
 
@@ -734,6 +791,13 @@ typedef unsigned char  UChar;
 #define SIS_CPUFL_SSE2  0x0080
 #define SIS_CPUFL_FLAG  0x8000
 
+/* Indices for array of SiSCalcClock() */
+#define SIS_VCLK_Midx    0
+#define SIS_VCLK_Nidx    1
+#define SIS_VCLK_VLDidx  2
+#define SIS_VCLK_Pidx    3
+#define SIS_VCLK_PSNidx  4
+
 /* Convenience macro for sisfb version checks */
 #define SISFB_VERSION(a,b,c) ((a << 16) | (b << 8) | c)
 
@@ -747,11 +811,11 @@ typedef struct {
     UChar  sisRegs3D4[0xff];
     UChar  sisRegs3C2;
     UChar  sisCapt[0x60];
-    UChar  sisVid[0x50];
+    UChar  sisVid[0x80];
     UChar  VBPart1[0x80];
     UChar  VBPart2[0x100];
     UChar  VBPart3[0x50];
-    UChar  VBPart4[0x50];
+    UChar  VBPart4[0x90];
     UShort ch70xx[64];
     unsigned int sisMMIO85C0;
     UChar  sis6326tv[0x46];
@@ -776,6 +840,7 @@ typedef struct _sisModeInfoPtr {
  */
 typedef struct {
     int		    bitsPerPixel;    /* = pScrn->bitsPerPixel */
+    int		    bytesPerPixel;
     int		    depth;	     /* = pScrn->depth */
     int		    displayWidth;    /* = pScrn->displayWidth */
     int		    displayHeight;   /* = imageHeight from DGA mode; ONLY WHEN DGA IS ACTIVE!!! */
@@ -784,9 +849,21 @@ typedef struct {
     DisplayModePtr  mode;	     /* = pScrn->currentMode */
 } SISFBLayout;
 
+//#define ENABLEXvMC
+/* for XvMC */
+typedef struct {
+   unsigned long Start; 
+   unsigned long End;
+   unsigned long Size;
+   BOOLEAN DRM_Success;     /* Karma@080304 Check DRM Enbale to avoid 2D driver failing on kernel 2.6.22*/
+} SiSMemRange;/* PHY address */
+
 /* For extended memcpy() */
 typedef void (*vidCopyFunc)(UChar *, const UChar *, int);
 
+/* For driver-internal shadowfb */
+typedef void (*SiSRefreshAreaFuncPtr)(ScrnInfoPtr, int, BoxPtr);
+
 #ifdef SISISXORG6899900
 #define SISAGPHTYPE drm_handle_t
 #else
@@ -811,7 +888,7 @@ typedef struct {
     UChar		*agpCmdBufBase;
     unsigned int	agpCmdBufSize;
     unsigned int	agpCmdBufFree;
-    ULong		agpVtxBufAddr;		/* 315/330 series */
+    ULong		agpVtxBufAddr;		/* 315/330+ series */
     UChar       	*agpVtxBufBase;
     unsigned int	agpVtxBufSize;
     unsigned int	agpVtxBufFree;
@@ -913,7 +990,6 @@ typedef struct {
     int			HWCursorMBufNum, HWCursorCBufNum;
     Bool		ROM661New;
     Bool		HaveXGIBIOS;
-    Bool		XvUseMemcpy;
     Bool		BenchMemCpy;
     Bool		HaveFastVidCpy;
     vidCopyFunc		SiSFastVidCopy, SiSFastMemCopy;
@@ -925,9 +1001,6 @@ typedef struct {
     UShort		MapCountIOPBase;	/* map/unmap queue counter */
     Bool		forceUnmapIOPBase;	/* ignore counter and unmap */
 #endif
-#ifdef SIS_CP
-    SIS_CP_H_ENT
-#endif
 } SISEntRec, *SISEntPtr;
 #endif
 
@@ -949,17 +1022,43 @@ typedef struct _region {
 
 typedef struct {
     ScrnInfoPtr		pScrn;
+    struct SiS_Private	*SiS_Pr;	/* For mode switching code */
+/*I.L. modified PciInfo struct*/
+#ifdef XSERVER_LIBPCIACCESS
+    struct pci_device *PciInfo;
+#else
     pciVideoPtr		PciInfo;
-    int			PciBus, PciDevice, PciFunc;
+#endif
+    
     PCITAG		PciTag;
+    int			PciBus, PciDevice, PciFunc;
     EntityInfoPtr	pEnt;
     int			Chipset;
     unsigned char	ChipType;
     int			ChipRev;
     int			VGAEngine;	/* see above */
-    int			hasTwoOverlays;	/* Chipset supports two video overlays? */
-    struct SiS_Private	*SiS_Pr;	/* For mode switching code */
-    int			DSTN;		/* For 550 FSTN/DSTN; set by option, no detection */
+    CARD32		EngineType3D;
+    int			oldChipset;	/* Type of old chipset */
+    ULong		ChipFlags;
+    ULong		SiS_SD_Flags, SiS_SD2_Flags, SiS_SD3_Flags, SiS_SD4_Flags;
+
+    OptionInfoPtr	Options;
+
+#ifdef SISDUALHEAD
+    Bool		DualHeadMode;		/* TRUE if we use dual head mode */
+    Bool		SecondHead;		/* TRUE is this is the second head */
+    SISEntPtr		entityPrivate;		/* Ptr to private entity (see above) */
+    Bool		SiSXinerama;		/* Do we use Xinerama mode? */
+#endif
+
+    /* Port access */
+    SISIOADDRESS        RelIO;		/* Relocated IO Ports baseaddress */
+#ifdef SISUSEDEVPORT
+    Bool		sisdevportopen;
+#endif
+    ULong		lockcalls;	/* Count unlock calls for debug */
+
+    /* FB and MMIO */
     ULong		FbAddress;	/* VRAM physical address (in DHM: for each Fb!) */
     ULong		realFbAddress;	/* For DHM/PCI mem mapping: store global FBAddress */
     UChar 		*FbBase;	/* VRAM virtual linear address */
@@ -970,46 +1069,54 @@ typedef struct {
 #ifdef __alpha__
     UChar		*IOBaseDense;	/* MMIO for Alpha platform */
 #endif
-    SISIOADDRESS        RelIO;		/* Relocated IO Ports baseaddress */
-    UChar		*BIOS;
-    int			MemClock;
-    int			BusWidth;
-    int			MinClock;
-    int			MaxClock;
-    int			Flags;		/* HW config flags */
     long		FbMapSize;	/* Used for Mem Mapping - DON'T CHANGE THIS */
     long		availMem;	/* Really available Fb mem (minus TQ, HWCursor) */
     unsigned int	maxxfbmem;	/* limit fb memory X is to use to this (KB) */
     unsigned int	sisfbHeapStart;	/* heapstart of sisfb (if running) */
     unsigned int	dhmOffset;	/* Offset to memory for each head (0 or ..); also used on SiS76x/UMA+LFB */
     unsigned int	FbBaseOffset;
-    DGAModePtr		DGAModes;
-    int			numDGAModes;
-    Bool		DGAactive;
-    int			DGAViewportStatus;
-    UChar       	OldMode;	/* Back old modeNo (if available) */
-    Bool		NoAccel;
-    Bool		NoXvideo;
-    Bool		XvOnCRT2;	/* see sis_opt.c */
-    Bool		HWCursor;
+    ULong		mmioSize;
+    int			mapPhys, mapOff, mapSize;
+    int			RealVideoRam;	/* 6326 can only address 4MB, but TQ can be above */
+    int			SiS76xLFBSize;
+    int			SiS76xUMASize;
+    ULong		UMAsize, LFBsize;	/* For SiSCtrl extension info only */
+    unsigned int	VGAMapSize;		/* SiSVGA stuff */
+    ULong		VGAMapPhys;
+    void 		*VGAMemBase; /* mapped */
+    Bool		VGAPaletteEnabled;
+    Bool		VGACMapSaved;
+
+    int			MemClock;
+    int			BusWidth;
+    int			MinClock;
+    int			MaxClock;
+    int			Flags;		/* HW config flags */
+    Bool		FastVram;	/* now unused */
+    int			newFastVram;	/* Replaces FastVram */
     Bool		UsePCIRetry;
-    Bool		TurboQueue;
-    int			VESA;
+    Bool		HostBus;	/* Enable/disable 5597/5598 host bus */
+
+    /* ROM */
+    UChar		*BIOS;
+    int			OptROMUsage;
+    int               BIOSVersion;
+    Bool		ROM661New;
+    Bool             ROMPCIENew;
+    Bool		HaveXGIBIOS;
+    Bool		NewCRLayout;
+
+    /* Output device related */
     int			ForceCRT1Type;
+    int			forceCRT1;
+    Bool		CRT1changed;
     Bool		CRT1Detected, CRT1TypeForced;
+    int			CRT1isoff;
     int			ForceCRT2Type;
     int			OptTVStand;
     int			OptTVOver;
-    int			OptROMUsage;
     int			UseCHOverScan;
-    Bool		ValidWidth;
-    Bool		FastVram;		/* now unused */
-    int			forceCRT1;
-    Bool		CRT1changed;
-    UChar		oldCR17, oldCR63, oldSR1F;
-    UChar		oldCR32, oldCR36, oldCR37;
-    UChar		myCR32, myCR36, myCR37, myCR63;
-    UChar		newCR32;
+    CARD32		detectedCRT2Devices;	/* detected CRT2 devices before mask-out */
     unsigned int	VBFlags;		/* Video bridge configuration (dynamic) */
     unsigned int	VBFlags2;		/* Video bridge configuration 2 (static flags only) */
     unsigned int	VBFlags3, VBFlags4;	/* Video bridge configuration 3, 4 (dynamic) */
@@ -1017,17 +1124,109 @@ typedef struct {
     unsigned int	VBFlags_backup3;	/* Backup for SlaveMode-modes */
     unsigned int	VBFlags_backup4;	/* Backup for SlaveMode-modes */
     unsigned int	VBLCDFlags, VBLCDFlags2;
+    unsigned int	VBFlagsInit, VBFlags3Init;
+    DisplayModePtr	currentModeLast;
     int			ChrontelType;		/* CHRONTEL_700x or CHRONTEL_701x */
+    UChar		oldCR17, oldCR63, oldSR1F;
+    UChar		oldCR32, oldCR36, oldCR37;
+    UChar		myCR32, myCR36, myCR37, myCR63;
+    UChar		newCR32;
+    UChar       	postVBCR32;
     unsigned int	PDC, PDCA;		/* PanelDelayCompensation */
+    int			DSTN;			/* For 550 FSTN/DSTN; set by option, no detection */
+    int			FSTN;
+    Bool		haveDDC;
+    UShort		SiS_DDC2_Index;
+    UShort		SiS_DDC2_Data;
+    UShort		SiS_DDC2_Clk;
+    Bool		restorebyset;
+    UChar       	OldMode;		/* Back old modeNo (if available) */
+    UChar		BIOSModeSave;
+    int			CRT1off;		/* 1=CRT1 off, 0=CRT1 on */
+    CARD16		LCDheight;		/* Vertical resolution of LCD panel */
+    CARD16		LCDwidth;		/* Horizontal resolution of LCD panel */
+    int			ForceTVType, SenseYPbPr;
+    int			NonDefaultPAL, NonDefaultNTSC;
+    unsigned int	ForceYPbPrType, ForceYPbPrAR;
+    int			chtvtype;
+    Bool		nocrt2ddcdetection;
+    Bool		forceLCDcrt1;
+    Bool		forcecrt2redetection;
+    int			vb;
+    int			UsePanelScaler, CenterLCD;
+    int			OptUseOEM;		/* Use internal OEM data? */
+    int			chtvlumabandwidthcvbs;  /* TV settings for Chrontel TV encoder */
+    int			chtvlumabandwidthsvideo;
+    int			chtvlumaflickerfilter;
+    int			chtvchromabandwidth;
+    int			chtvchromaflickerfilter;
+    int			chtvcvbscolor;
+    int			chtvtextenhance;
+    int			chtvcontrast;
+    int			sistvedgeenhance;	/* TV settings for SiS bridges */
+    int			sistvantiflicker;
+    int			sistvsaturation;
+    int			sistvcolcalibc;
+    int			sistvcolcalibf;
+    int			sistvcfilter;
+    int			sistvyfilter;
+    int			OptTVSOver;		/* Chrontel 7005: Superoverscan */
+    int			tvxpos, tvypos;
+    int			tvxscale, tvyscale;
+    int			SiS6326Flags;		/* SiS6326 TV settings */
+    int			sis6326enableyfilter;
+    int			sis6326yfilterstrong;
+    int			sis6326tvplug;
+    int			sis6326fscadjust;
+    Bool		sis6326tvumode;
+    int			siscrt1satgain;
+    Bool		crt1satgaingiven;
+    UShort		tvx, tvy;		/* Backup TV position registers */
+    UChar		p2_01, p2_02, p2_1f, p2_20, p2_43, p2_42, p2_2b; /* Backup TV position registers */
+    UShort      	tvx1, tvx2, tvx3, tvy1;	/* Backup TV position registers */
+    UChar		p2_44, p2_45, p2_46;
+    unsigned int	sistvccbase;
+    UChar		p2_35, p2_36, p2_37, p2_38, p2_48, p2_49, p2_4a;
+    UChar		p2_0a, p2_2f, p2_30, p2_47;
+    UChar		scalingp1[9], scalingp4[9], scalingp2[64];
+    UChar		SR2b, SR2c;
+
+    /* HWCursor */
+    Bool		HWCursor;
+    CARD16		CursorSize;		/* Size of HWCursor area (bytes) */
+    CARD32		cursorOffset;		/* see sis_driver.c and sis_cursor.c */
+    Bool		HideHWCursor;		/* Custom application */
+    Bool		HWCursorIsVisible;
+    unsigned int	HWCursorBackup[16];
+    int			HWCursorMBufNum, HWCursorCBufNum;
+    UChar		*CursorScratch;
+    Bool		ForceCursorOff;
+    Bool		UseHWARGBCursor;
+    int			OptUseColorCursor;
+    int			OptUseColorCursorBlend;
+    CARD32		OptColorCursorBlendThreshold;
+    UShort		cursorBufferNum;
+    int			CursorW, CursorH;
+#ifdef SISMERGED
+    int			CurHotX, CurHotY;
+#endif
+    Bool		CursorDoubleSize;
+    CARD32		CurFGCol, CurBGCol;
+    UChar		*CurMonoSrc;
+    CARD32		*CurARGBDest;
+
+    /* Accel */
+    Bool		NoAccel;
+    Bool		TurboQueue;
+    Bool		ValidWidth;
     short		scrnOffset;		/* Screen pitch (data) */
     short		scrnPitch;		/* Screen pitch (display; regarding interlace) */
+    short		scrnPitch2;
     short		DstColor;
     unsigned int	SiS310_AccelDepth;	/* used in accel for 315 series */
     int			MaxCMDQueueLen;
     int			CurCMDQueueLen;
     int			MinCMDQueueLen;
-    CARD16		CursorSize;		/* Size of HWCursor area (bytes) */
-    CARD32		cursorOffset;		/* see sis_driver.c and sis_cursor.c */
     Bool		useEXA;
     void 		(*InitAccel)(ScrnInfoPtr pScrn);
     void 		(*SyncAccel)(ScrnInfoPtr pScrn);
@@ -1038,6 +1237,10 @@ typedef struct {
     Bool		ClipEnabled;
     int			Xdirection;		/* for temp use in accel */
     int			Ydirection;		/* for temp use in accel */
+    CARD32		CmdQueLenMask;		/* Mask of queue length in MMIO register */
+    CARD32		CmdQueLenFix;           /* Fix value to subtract from QueLen (530/620) */
+    CARD32		CmdQueMaxLen;           /* (6326/5597/5598) Amount of cmds the queue can hold */
+    CARD32		TurboQueueLen;		/* For future use */
 #ifdef SIS_USE_XAA
     XAAInfoRecPtr	AccelInfoPtr;
     UChar 		*XAAScanlineColorExpandBuffers[2];
@@ -1075,7 +1278,7 @@ typedef struct {
     unsigned int	cmdQueueSize;
     unsigned int	cmdQueueSizeMask;
     unsigned int	cmdQ_SharedWritePort_2D;
-    unsigned int	*cmdQ_SharedWritePort;
+    volatile unsigned int	*cmdQ_SharedWritePort;
     unsigned int	*cmdQ_SharedWritePortBackup;
     unsigned int	cmdQueueSize_div2;
     unsigned int	cmdQueueSize_div4;
@@ -1125,6 +1328,10 @@ typedef struct {
     CARD32		ColorExpandBufferScreenOffset[32];
     CARD32		ColorExpandBase;
 
+    /* RandR support */
+    int			constantDPI; /* -1 = auto, 0 = off, 1 = on */
+    int			SiSDPIVX, SiSDPIVY;
+    int			virtualX, virtualY;
     int			Rotate, Reflect;
     void		(*PointerMoved)(int index, int x, int y);
 
@@ -1133,12 +1340,9 @@ typedef struct {
     UChar		*ShadowPtr;
     int			ShadowPitch;
 
-#ifdef SISUSEDEVPORT
-    Bool		sisdevportopen;
-#endif
-
     /* DRI */
     Bool		loadDRI;
+    Bool		DRIEnabled;
 #ifdef XF86DRI
     Bool		directRenderingEnabled;
     DRIInfoPtr 		pDRIInfo;
@@ -1147,9 +1351,29 @@ typedef struct {
     __GLXvisualConfig*	pVisualConfigs;
     SISConfigPrivPtr	pVisualConfigsPriv;
     SISRegRec		DRContextRegs;
+#ifdef ENABLEXvMC
+     /* XvMC */
+    unsigned int surfaceAllocation[SIS_MAX_SURFACES];
+    int numSurfaces;
+    SiSMemRange MC_AgpAlloc;
+    drm_handle_t MC_AgpAllocHandle;
+    drm_handle_t mc_agp_handle;  /* agp handle */
+    drm_handle_t fb_handle;
+    drm_handle_t xvmcContext;
+    void *FBBufferHandle;
+    unsigned int FBBuffSize;
+    unsigned int FBBuffOffset;
+    unsigned int subpictureAllocation[SIS_MAX_SUBPICTURES];
+    void* SubpictBuffHandle;
+    unsigned int SubpictBuffSize;
+    unsigned int SubpictBuffOffset;
+#endif
 #endif
 
     /* Xv */
+    Bool		NoXvideo;
+    int			hasTwoOverlays;	/* Chipset supports two video overlays? */
+    Bool		XvOnCRT2;	/* see sis_opt.c */
     XF86VideoAdaptorPtr adaptor;
     XF86VideoAdaptorPtr blitadaptor;
     void		*blitPriv;
@@ -1158,13 +1382,46 @@ typedef struct {
     void		(*ResetXv)(ScrnInfoPtr);
     void		(*ResetXvDisplay)(ScrnInfoPtr);
     void		(*ResetXvGamma)(ScrnInfoPtr);
+    Bool		HaveBlitAdaptor;
+    int			NoYV12;		/* Disable Xv YV12 support (old series) */
+    Atom		xvBrightness, xvContrast, xvColorKey, xvHue, xvSaturation;
+    Atom		xvAutopaintColorKey, xvSetDefaults, xvSwitchCRT;
+    Atom		xvDisableGfx, xvDisableGfxLR, xvTVXPosition, xvTVYPosition;
+    Atom		xvDisableColorkey, xvUseChromakey, xvChromaMin, xvChromaMax;
+    Atom		xvInsideChromakey, xvYUVChromakey, xvVSync;
+    Atom		xvGammaRed, xvGammaGreen, xvGammaBlue;
+#ifdef TWDEBUG
+    Atom		xv_STR;
+#endif
+    int			xv_sisdirectunlocked;
+    int			XvDefCon, XvDefBri, XvDefHue, XvDefSat;
+    Bool		XvDefDisableGfx, XvDefDisableGfxLR, XvDefAdaptorBlit;
+    Bool		XvUseChromaKey, XvDisableColorKey;
+    Bool		XvInsideChromaKey, XvYUVChromaKey;
+    int			XvChromaMin, XvChromaMax;
+    int			XvGammaRed, XvGammaGreen, XvGammaBlue;
+    int			XvGammaRedDef, XvGammaGreenDef, XvGammaBlueDef;
+    CARD8		XvGammaRampRed[256], XvGammaRampGreen[256], XvGammaRampBlue[256];
+    Bool		disablecolorkeycurrent, nocolorkey;
+    CARD32		colorKey;
 
-    /* misc */
-    OptionInfoPtr	Options;
-    UChar		BIOSModeSave;
-    int			CRT1off;		/* 1=CRT1 off, 0=CRT1 on */
-    CARD16		LCDheight;		/* Vertical resolution of LCD panel */
-    CARD16		LCDwidth;		/* Horizontal resolution of LCD panel */
+   
+    /* AdjustFrame wrapper */
+    xf86AdjustFrameProc *AdjustFrame;
+    Bool		AdjustFramePending;
+    int			AdjustFrameX;
+    int			AdjustFrameY;
+    int			AdjustFrameFlags;
+
+    /* DGA */
+    DGAModePtr		DGAModes;
+    int			numDGAModes;
+    Bool		DGAactive;
+    int			DGAViewportStatus;
+    SISFBLayout		CurrentLayout;		/* Current framebuffer layout */
+
+    /* VBE, int10 */
+    int			VESA;
     vbeInfoPtr 		pVbe;			/* For VESA mode switching */
     CARD16		vesamajor;
     CARD16		vesaminor;
@@ -1173,57 +1430,15 @@ typedef struct {
     xf86MonPtr		monitor;
     CARD16		maxBytesPerScanline;
     CARD32		*pal, *savedPal;
-    int			mapPhys, mapOff, mapSize;
     int			statePage, stateSize, stateMode;
     CARD8		*fonts;
     CARD8		*state, *pstate;
     void		*base, *VGAbase;
-#ifdef SISDUALHEAD
-    Bool		DualHeadMode;		/* TRUE if we use dual head mode */
-    Bool		SecondHead;		/* TRUE is this is the second head */
-    SISEntPtr		entityPrivate;		/* Ptr to private entity (see above) */
-    Bool		SiSXinerama;		/* Do we use Xinerama mode? */
-#endif
-    SISFBLayout		CurrentLayout;		/* Current framebuffer layout */
-    UShort		SiS_DDC2_Index;
-    UShort		SiS_DDC2_Data;
-    UShort		SiS_DDC2_Clk;
     Bool		Primary;		/* Display adapter is primary */
     Bool		VGADecodingEnabled;	/* a0000 memory adress decoding is enabled */
     xf86Int10InfoPtr	pInt;			/* Our int10 */
-    int			oldChipset;		/* Type of old chipset */
-    int			RealVideoRam;		/* 6326 can only address 4MB, but TQ can be above */
-    CARD32		CmdQueLenMask;		/* Mask of queue length in MMIO register */
-    CARD32		CmdQueLenFix;           /* Fix value to subtract from QueLen (530/620) */
-    CARD32		CmdQueMaxLen;           /* (6326/5597/5598) Amount of cmds the queue can hold */
-    CARD32		TurboQueueLen;		/* For future use */
-    CARD32		detectedCRT2Devices;	/* detected CRT2 devices before mask-out */
-    Bool		HostBus;		/* Enable/disable 5597/5598 host bus */
-    Bool		noInternalModes;	/* Use our own default modes? */
-    int			OptUseOEM;		/* Use internal OEM data? */
-    int			chtvlumabandwidthcvbs;  /* TV settings for Chrontel TV encoder */
-    int			chtvlumabandwidthsvideo;
-    int			chtvlumaflickerfilter;
-    int			chtvchromabandwidth;
-    int			chtvchromaflickerfilter;
-    int			chtvcvbscolor;
-    int			chtvtextenhance;
-    int			chtvcontrast;
-    int			sistvedgeenhance;	/* TV settings for SiS bridges */
-    int			sistvantiflicker;
-    int			sistvsaturation;
-    int			sistvcolcalibc;
-    int			sistvcolcalibf;
-    int			sistvcfilter;
-    int			sistvyfilter;
-    int			OptTVSOver;		/* Chrontel 7005: Superoverscan */
-    int			tvxpos, tvypos;
-    int			tvxscale, tvyscale;
-    int			SiS6326Flags;		/* SiS6326 TV settings */
-    int			sis6326enableyfilter;
-    int			sis6326yfilterstrong;
-    int			sis6326tvplug;
-    int			sis6326fscadjust;
+
+    /* sisfb */
     Bool		sisfbfound;
     Bool		donttrustpdc;		/* Don't trust the detected PDC */
     UChar		sisfbpdc, sisfbpdca;
@@ -1233,8 +1448,6 @@ typedef struct {
     Bool		sisfb_haveemi, sisfb_haveemilcd, sisfb_tvposvalid, sisfb_havelock;
     UChar		sisfb_emi30,sisfb_emi31,sisfb_emi32,sisfb_emi33;
     int			sisfb_tvxpos, sisfb_tvypos;
-    int			siscrt1satgain;
-    Bool		crt1satgaingiven;
     Bool		sisfbHaveNewHeapDef;
     unsigned int	sisfbHeapSize, sisfbVideoOffset;
     Bool		sisfbxSTN;
@@ -1243,106 +1456,33 @@ typedef struct {
     char		sisfbdevname[16];
     int			EMI;
     int			PRGB;
-    int			NoYV12;			/* Disable Xv YV12 support (old series) */
-    UChar       	postVBCR32;
-    int			newFastVram;		/* Replaces FastVram */
-    int			ForceTVType, SenseYPbPr;
-    int			NonDefaultPAL, NonDefaultNTSC;
-    unsigned int	ForceYPbPrType, ForceYPbPrAR;
-    ULong		lockcalls;		/* Count unlock calls for debug */
-    UShort		tvx, tvy;		/* Backup TV position registers */
-    UChar		p2_01, p2_02, p2_1f, p2_20, p2_43, p2_42, p2_2b; /* Backup TV position registers */
-    UShort      	tvx1, tvx2, tvx3, tvy1;	/* Backup TV position registers */
-    UChar		p2_44, p2_45, p2_46;
-    unsigned int	sistvccbase;
-    UChar		p2_35, p2_36, p2_37, p2_38, p2_48, p2_49, p2_4a;
-    UChar		p2_0a, p2_2f, p2_30, p2_47;
-    UChar		scalingp1[9], scalingp4[9], scalingp2[64];
-    Bool		ForceCursorOff;
+
+    /* misc */
+    Bool		noInternalModes;	/* Use our own default modes? */
     Bool		HaveCustomModes;
     Bool		IsCustom;
-    DisplayModePtr	backupmodelist;
-    int			chtvtype;
-    Atom		xvBrightness, xvContrast, xvColorKey, xvHue, xvSaturation;
-    Atom		xvAutopaintColorKey, xvSetDefaults, xvSwitchCRT;
-    Atom		xvDisableGfx, xvDisableGfxLR, xvTVXPosition, xvTVYPosition;
-    Atom		xvDisableColorkey, xvUseChromakey, xvChromaMin, xvChromaMax;
-    Atom		xvInsideChromakey, xvYUVChromakey, xvVSync;
-#ifdef SISDEINT
-    Atom		xvdeintmeth;
-#endif
-    Atom		xvGammaRed, xvGammaGreen, xvGammaBlue;
-#ifdef XV_SD_DEPRECATED
-    Atom		xv_QVF, xv_QVV, xv_USD, xv_SVF, xv_QDD, xv_TAF, xv_TSA, xv_TEE, xv_GSF;
-    Atom		xv_TTE, xv_TCO, xv_TCC, xv_TCF, xv_TLF, xv_CMD, xv_CMDR, xv_CT1, xv_SGA;
-    Atom		xv_GDV, xv_GHI, xv_OVR, xv_GBI, xv_TXS, xv_TYS, xv_CFI, xv_COC, xv_COF;
-    Atom		xv_YFI, xv_GSS, xv_BRR, xv_BRG, xv_BRB, xv_PBR, xv_PBG, xv_PBB, xv_SHC;
-    Atom		xv_BRR2, xv_BRG2, xv_BRB2, xv_PBR2, xv_PBG2, xv_PBB2, xv_PMD, xv_RDT;
-    Atom		xv_GARC2,xv_GAGC2,xv_GABC2, xv_GSF2;
-    Atom		xv_BRRC2, xv_BRGC2, xv_BRBC2, xv_PBRC2, xv_PBGC2, xv_PBBC2;
-#ifdef TWDEBUG
-    Atom		xv_STR;
-#endif
-    unsigned int	xv_sd_result;
-#endif /* XV_SD_DEPRECATED */
-    int			xv_sisdirectunlocked;
-    int			SiS76xLFBSize;
-    int			SiS76xUMASize;
-    int			CRT1isoff;
-    ULong		UMAsize, LFBsize;	/* For SiSCtrl extension info only */
-#ifdef SIS_CP
-    SIS_CP_H
-#endif
-    ULong		ChipFlags;
-    ULong		SiS_SD_Flags, SiS_SD2_Flags, SiS_SD3_Flags, SiS_SD4_Flags;
-    Bool		UseHWARGBCursor;
-    int			OptUseColorCursor;
-    int			OptUseColorCursorBlend;
-    CARD32		OptColorCursorBlendThreshold;
-    UShort		cursorBufferNum;
-    int			vb;
-    Bool		restorebyset;
-    Bool		nocrt2ddcdetection;
-    Bool		forcecrt2redetection;
-    Bool		CRT1gamma, CRT1gammaGiven, CRT2gamma, XvGamma, XvGammaGiven;
-    int			XvDefCon, XvDefBri, XvDefHue, XvDefSat;
-    Bool		XvDefDisableGfx, XvDefDisableGfxLR, XvDefAdaptorBlit;
-    Bool		XvUseMemcpy;
-    Bool		XvUseChromaKey, XvDisableColorKey;
-    Bool		XvInsideChromaKey, XvYUVChromaKey;
-    int			XvChromaMin, XvChromaMax;
-    int			XvGammaRed, XvGammaGreen, XvGammaBlue;
-    int			XvGammaRedDef, XvGammaGreenDef, XvGammaBlueDef;
-    CARD8		XvGammaRampRed[256], XvGammaRampGreen[256], XvGammaRampBlue[256];
-    Bool		disablecolorkeycurrent;
-    CARD32		colorKey;
+    Bool		UseDynamicModelists;
+    Bool		AddedPlasmaModes;
+    DisplayModePtr	UserModes;
+    int			BackupNVHSync, BackupNVRefresh;
+    range		BackupHSync[MAX_HSYNC], BackupVRefresh[MAX_VREFRESH];
+    xf86MonPtr		currcrt1analogedid, currcrt1digitaledid;
+    xf86MonPtr		currcrt2analogedid, currcrt2digitaledid;
+    Bool		havewide1, havewide2;
+
+
     CARD32		MiscFlags;
-    int			UsePanelScaler, CenterLCD;
+    ExtensionEntry	*SiSCtrlExtEntry;
+    char		devsectname[32];
+    Bool		SCLogQuiet;
+
     float		zClearVal;
     ULong		bClrColor, dwColor;
     int			AllowHotkey;
     Bool		enablesisctrl;
     short		Video_MaxWidth, Video_MaxHeight;
-    int			FSTN;
-    Bool		AddedPlasmaModes;
-    short		scrnPitch2;
-    CARD32		CurFGCol, CurBGCol;
-    UChar		*CurMonoSrc;
-    CARD32		*CurARGBDest;
-    int			GammaBriR, GammaBriG, GammaBriB;
-    unsigned int	CRT1MonGamma, CRT2MonGamma;
-    unsigned int	CRT1VGAMonitorGamma, CRT2LCDMonitorGamma, CRT2VGAMonitorGamma;
-    Bool		HideHWCursor;  /* Custom application */
-    Bool		HWCursorIsVisible;
-    unsigned int	HWCursorBackup[16];
-    int			HWCursorMBufNum, HWCursorCBufNum;
-    ULong		mmioSize;
-    Bool		ROM661New;
-    Bool		HaveXGIBIOS;
-    Bool		NewCRLayout;
+
     Bool		skipswitchcheck;
-    unsigned int	VBFlagsInit;
-    DisplayModePtr	currentModeLast;
     IOADDRESS		MyPIOOffset;
     Bool		OverruleRanges;
     Bool		BenchMemCpy;
@@ -1355,11 +1495,11 @@ typedef struct {
     Bool		XvSSEMemcpy;
 #endif
     char		messagebuffer[64];
-    unsigned int	VGAMapSize;		/* SiSVGA stuff */
-    ULong		VGAMapPhys;
-    void 		*VGAMemBase; /* mapped */
-    Bool		VGAPaletteEnabled;
-    Bool		VGACMapSaved;
+
+    Bool		CRT1gamma, CRT1gammaGiven, CRT2gamma, XvGamma, XvGammaGiven;
+    int			GammaBriR, GammaBriG, GammaBriB;
+    unsigned int	CRT1MonGamma, CRT2MonGamma;
+    unsigned int	CRT1VGAMonitorGamma, CRT1LCDMonitorGamma, CRT2LCDMonitorGamma, CRT2VGAMonitorGamma;
     Bool		CRT2SepGamma;		/* CRT2 separate gamma stuff */
     int			*crt2cindices;
     LOCO		*crt2gcolortable, *crt2colors;
@@ -1371,13 +1511,12 @@ typedef struct {
     float		NewGammaConR, NewGammaConG, NewGammaConB;
     float		NewGammaBriR2, NewGammaBriG2, NewGammaBriB2;
     float		NewGammaConR2, NewGammaConG2, NewGammaConB2;
-    ExtensionEntry	*SiSCtrlExtEntry;
-    char		devsectname[32];
-    Bool		SCLogQuiet;
+
 #ifdef SIS_NEED_MAP_IOP
     CARD32		IOPAddress;		/* I/O port physical address */
     UChar 		*IOPBase;		/* I/O port linear address */
 #endif
+
 #ifdef SISMERGED
     Bool		MergedFB, MergedFBAuto;
     SiSScrn2Rel		CRT2Position;
@@ -1394,22 +1533,39 @@ typedef struct {
     Bool		CheckForCRT2;
     Bool		IsCustomCRT2;
     Bool		HaveCustomModes2;
-    int			maxCRT1_X1, maxCRT1_X2, maxCRT1_Y1, maxCRT1_Y2;
-    int			maxCRT2_X1, maxCRT2_X2, maxCRT2_Y1, maxCRT2_Y2;
-    int			maxClone_X1, maxClone_X2, maxClone_Y1, maxClone_Y2;
     int			MergedFBXDPI, MergedFBYDPI;
     int			CRT1XOffs, CRT1YOffs, CRT2XOffs, CRT2YOffs;
-    int			MBXNR1XMAX, MBXNR1YMAX, MBXNR2XMAX, MBXNR2YMAX;
+    int			MBXNRXMAX, MBXNRYMAX;
     Bool		NonRect, HaveNonRect, HaveOffsRegions, MouseRestrictions;
     region		NonRectDead, OffDead1, OffDead2;
+    int			SiSMergedDPIVX, SiSMergedDPIVY, SiSMergedDPIRot;
+    SiSScrn2Rel		MergedDPISRel;
 #ifdef SISXINERAMA
     Bool		UseSiSXinerama;
     Bool		CRT2IsScrn0;
+    Bool		MFBScr0LR, MFBScr0TB;
     ExtensionEntry	*XineramaExtEntry;
-    int			SiSXineramaVX, SiSXineramaVY;
+    int			SiSXineramaVX, SiSXineramaVY, SiSXineramaRot;
+    int			maxCRT1_X1, maxCRT1_X2, maxCRT1_Y1, maxCRT1_Y2;
+    int			maxCRT2_X1, maxCRT2_X2, maxCRT2_Y1, maxCRT2_Y2;
+    int			maxClone_X1, maxClone_X2, maxClone_Y1, maxClone_Y2;
+    SiSScrn2Rel		XineSRel;
     Bool		AtLeastOneNonClone;
+    int			XineVerb;
 #endif
 #endif
+    /*Hkey is using for device switch on NB.*/
+    /*this parameter is record the current state for Hkey pressing to next state.*/
+    /*state=0(LCD=ON,VGA=OFF), state=1(LCD=ON,VGA=ON), state=2(LCD=OFF,VGA=ON)*/
+    unsigned char       Hkey_Device_Switch_State; /*Ivans adding.*/
+    unsigned char       suspended;/*suspend/resume state.*/
+
+   /*Ivans added: CRT1 detection help function flag from VBIOS */
+    Bool  trace_VGA_MISCW;
+
+  /* Enable special 1366x768x60hz mode of LVDS panel. Ivans@090109 */
+    Bool  EnablePanel_1366x768;
+	
 } SISRec, *SISPtr;
 
 typedef struct _ModeInfoData {
@@ -1495,6 +1651,16 @@ typedef struct _SiSXineramaData {
     int width;
     int height;
 } SiSXineramaData;
+
+extern void SiSUpdateXineramaScreenInfo(ScrnInfoPtr pScrn);
+#endif
+#ifndef SIS_HAVE_RR_GET_MODE_MM
+extern void SiSMFBResetDpi(ScrnInfoPtr pScrn, Bool force);
+#endif
+#ifdef SIS_HAVE_RR_GET_MODE_MM
+extern void SiSMFBCalcDPIPerMode(ScrnInfoPtr pScrn, DisplayModePtr mode,
+			int virtX, int virtY,
+			int *mmWidth, int *mmHeight);
 #endif
 #endif
 
@@ -1516,6 +1682,10 @@ extern Bool  SiS315AccelInit(ScreenPtr pScreen);
 extern void  SISInitVideo(ScreenPtr pScreen);
 extern void  SIS6326InitVideo(ScreenPtr pScreen);
 extern Bool  SISDGAInit(ScreenPtr pScreen);
+extern Bool  SISDGAReInit(ScrnInfoPtr pScrn);
+
+extern xf86MonPtr SiSSetEDIDPtr(xf86MonPtr *ptr, xf86MonPtr pMonitor);
+extern void       SiSFreeEDID(ScrnInfoPtr pScrn, xf86MonPtr *ptr);
 
 /* For extended mempy() support */
 extern unsigned int SiSGetCPUFlags(ScrnInfoPtr pScrn);
@@ -1570,7 +1740,7 @@ extern int   SiS_GetTVyscale(ScrnInfoPtr pScrn);
 extern int   SiS_GetSISCRT1SaturationGain(ScrnInfoPtr pScrn);
 extern void  SiS_SetSISCRT1SaturationGain(ScrnInfoPtr pScrn, int val);
 
-#endif  /* _SIS_H_ */
 
+#endif  /* _SIS_H_ */
 
 
diff --git a/src/sis300_accel.c b/src/sis300_accel.c
index d46635c..154fc91 100644
--- a/src/sis300_accel.c
+++ b/src/sis300_accel.c
@@ -169,7 +169,7 @@ SiSSetupForSolidFill(ScrnInfoPtr pScrn,
 {
 	SISPtr pSiS = SISPTR(pScrn);
 
-	if(pSiS->disablecolorkeycurrent) {
+	if(pSiS->disablecolorkeycurrent || pSiS->nocolorkey) {
 	   if((CARD32)color == pSiS->colorKey) {
 	      rop = 5;  /* NOOP */
 	   }
@@ -896,7 +896,7 @@ SiSPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planemask, Pixel fg)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
 	SISPtr pSiS = SISPTR(pScrn);
-	CARD32 dstbase;
+	CARD16 pitch;
 
 	/* Planemask not supported */
 	if((planemask & ((1 << pPixmap->drawable.depth) - 1)) !=
@@ -915,25 +915,26 @@ SiSPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planemask, Pixel fg)
 		  (pPixmap->drawable.bitsPerPixel != 32))
 	   return FALSE;
 
-	if(pSiS->disablecolorkeycurrent) {
-	   if((CARD32)fg == pSiS->colorKey) {
-	      alu = 5;  /* NOOP */
-	   }
-	}
-
 	/* Check that the pitch matches the hardware's requirements. Should
 	 * never be a problem due to pixmapPitchAlign and fbScreenInit.
 	 */
-	if(exaGetPixmapPitch(pPixmap) & 3)
+	if((pitch = exaGetPixmapPitch(pPixmap)) & 3)
 	   return FALSE;
 
-	dstbase = (CARD32)exaGetPixmapOffset(pPixmap) + HEADOFFSET;
+	if(pSiS->disablecolorkeycurrent || pSiS->nocolorkey) {
+	   if((CARD32)fg == pSiS->colorKey) {
+	      /* NOOP - does not work: Pixmap is not neccessarily in the frontbuffer */
+	      /* alu = 5; */ /* NOOP */
+	      /* Fill it black; better than blue anyway */
+	      fg = 0;
+	   }
+	}
 
 	SiSSetupPATFG(fg)
-	SiSSetupDSTRect(exaGetPixmapPitch(pPixmap), -1)
+	SiSSetupDSTRect(pitch, -1)
 	SiSSetupDSTColorDepth(dstcol[pPixmap->drawable.bitsPerPixel >> 4]);
 	SiSSetupROP(SiSGetPatternROP(alu))
-	SiSSetupDSTBase(dstbase)
+	SiSSetupDSTBase(((CARD32)exaGetPixmapOffset(pPixmap) + HEADOFFSET))
 	/* SiSSetupCMDFlag(PATFG) - is zero */
 
 	return TRUE;
@@ -964,7 +965,7 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 {
 	ScrnInfoPtr pScrn = xf86Screens[pDstPixmap->drawable.pScreen->myNum];
 	SISPtr pSiS = SISPTR(pScrn);
-	CARD32 srcbase, dstbase;
+	CARD16 srcpitch, dstpitch;
 
 	/* Planemask not supported */
 	if((planemask & ((1 << pSrcPixmap->drawable.depth) - 1)) !=
@@ -986,14 +987,14 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 	/* Check that the pitch matches the hardware's requirements. Should
 	 * never be a problem due to pixmapPitchAlign and fbScreenInit.
 	 */
-	if(exaGetPixmapPitch(pSrcPixmap) & 3)
+	if((srcpitch = exaGetPixmapPitch(pSrcPixmap)) & 3)
 	   return FALSE;
-	if(exaGetPixmapPitch(pDstPixmap) & 3)
+	if((dstpitch = exaGetPixmapPitch(pDstPixmap)) & 3)
 	   return FALSE;
 
 	SiSSetupDSTColorDepth(dstcol[pDstPixmap->drawable.bitsPerPixel >> 4]);
-	SiSSetupSRCPitch(exaGetPixmapPitch(pSrcPixmap))
-	SiSSetupDSTRect(exaGetPixmapPitch(pDstPixmap), -1)
+	SiSSetupSRCPitch(srcpitch)
+	SiSSetupDSTRect(dstpitch, -1)
 
 	SiSSetupROP(SiSGetCopyROP(alu))
 
@@ -1004,12 +1005,8 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 	   SiSSetupCMDFlag(Y_INC)
 	}
 
-	srcbase = (CARD32)exaGetPixmapOffset(pSrcPixmap) + HEADOFFSET;
-
-	dstbase = (CARD32)exaGetPixmapOffset(pDstPixmap) + HEADOFFSET;
-
-	SiSSetupSRCBase(srcbase);
-	SiSSetupDSTBase(dstbase);
+	SiSSetupSRCBase(((CARD32)exaGetPixmapOffset(pSrcPixmap) + HEADOFFSET));
+	SiSSetupDSTBase(((CARD32)exaGetPixmapOffset(pDstPixmap) + HEADOFFSET));
 
 	return TRUE;
 }
@@ -1042,6 +1039,7 @@ SiSDoneCopy(PixmapPtr pDstPixmap)
 
 #endif /* EXA */
 
+
 /* For DGA usage */
 
 static void
@@ -1101,7 +1099,7 @@ SiS300AccelInit(ScreenPtr pScreen)
 #endif
 #ifdef SIS_USE_EXA
 	   if(pSiS->useEXA) {
-	      if(!(pSiS->EXADriverPtr = exaDriverAlloc())) {
+	      if(!(pSiS->EXADriverPtr = xnfcalloc(sizeof(ExaDriverRec), 1))) {
 		 pSiS->NoAccel = TRUE;
 		 pSiS->NoXvideo = TRUE; /* No fbmem manager -> no xv */
 	      }
@@ -1118,6 +1116,7 @@ SiS300AccelInit(ScreenPtr pScreen)
 	   pSiS->FillRect  = SiSDGAFillRect;
 	   pSiS->BlitRect  = SiSDGABlitRect;
 
+
 #ifdef SIS_USE_XAA	/* ----------------------- XAA ----------------------- */
 	   if(!pSiS->useEXA) {
 
@@ -1232,9 +1231,66 @@ SiS300AccelInit(ScreenPtr pScreen)
 
 #ifdef SIS_USE_EXA	/* ----------------------- EXA ----------------------- */
 	   if(pSiS->useEXA) {
+#if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+         
+	      if(pSiS->scrnOffset < 8192) {
+	         int obase = 0;
+	         /* data */
+		 pSiS->EXADriverPtr->card.memoryBase = pSiS->FbBase;
+		 pSiS->EXADriverPtr->card.memorySize = pSiS->maxxfbmem;
+
+
+	         if(!obase) {
+	            obase = pScrn->displayWidth * pScrn->virtualY * (pScrn->bitsPerPixel >> 3);
+	         }
+
+		 pSiS->EXADriverPtr->card.offScreenBase = obase;
+		 if(pSiS->EXADriverPtr->card.memorySize > pSiS->EXADriverPtr->card.offScreenBase) {
+		    pSiS->EXADriverPtr->card.flags = EXA_OFFSCREEN_PIXMAPS;
+		 } else {
+		    pSiS->NoXvideo = TRUE;
+		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			"Not enough video RAM for offscreen memory manager. Xv disabled\n");
+		 }
+		 
+#if  XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(6,8,2,0,0)
+                 pSiS->EXADriverPtr->card.offscreenByteAlign = 16;	/* src/dst: double quad word boundary */
+		 pSiS->EXADriverPtr->card.offscreenPitch = 4;	
+#else
+		 pSiS->EXADriverPtr->card.pixmapOffsetAlign = 16;	/* src/dst: double quad word boundary */
+		 pSiS->EXADriverPtr->card.pixmapPitchAlign = 4;		/* pitch:   double word boundary      */
+#endif
+		 if(pSiS->VGAEngine == SIS_300_VGA) {
+		    pSiS->EXADriverPtr->card.maxX = 4095;
+		    pSiS->EXADriverPtr->card.maxY = 4095;
+		 } else {
+		    pSiS->EXADriverPtr->card.maxX = 2047;
+		    pSiS->EXADriverPtr->card.maxY = 2047;
+		 }
+
+		 /* Sync */
+		 pSiS->EXADriverPtr->accel.WaitMarker = SiSEXASync;
+
+		 /* Solid fill */
+		 pSiS->EXADriverPtr->accel.PrepareSolid = SiSPrepareSolid;
+		 pSiS->EXADriverPtr->accel.Solid = SiSSolid;
+		 pSiS->EXADriverPtr->accel.DoneSolid = SiSDoneSolid;
+
+		 /* Copy */
+		 pSiS->EXADriverPtr->accel.PrepareCopy = SiSPrepareCopy;
+		 pSiS->EXADriverPtr->accel.Copy = SiSCopy;
+		 pSiS->EXADriverPtr->accel.DoneCopy = SiSDoneCopy;
+
+		 /* Composite not supported */
 
+		 /* Upload, download to/from Screen */
+		 pSiS->EXADriverPtr->accel.UploadToScreen = SiSUploadToScreen;
+		 pSiS->EXADriverPtr->accel.DownloadFromScreen = SiSDownloadFromScreen;
+	   }
+#else  /*xorg>7.0*/
+	   
 	      pSiS->EXADriverPtr->exa_major = 2;
-	      pSiS->EXADriverPtr->exa_major = 0;
+	      pSiS->EXADriverPtr->exa_minor = 0;
 
 	      if(pSiS->scrnOffset < 8192) {
 
@@ -1279,7 +1335,10 @@ SiS300AccelInit(ScreenPtr pScreen)
 		 pSiS->EXADriverPtr->UploadToScreen = SiSUploadToScreen;
 		 pSiS->EXADriverPtr->DownloadFromScreen = SiSDownloadFromScreen;
 
-	      } else {
+	      } 
+#endif
+
+	   }   else {
 
 		 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 			"Virtual screen width too large for accelerator engine\n");
@@ -1289,8 +1348,6 @@ SiS300AccelInit(ScreenPtr pScreen)
 		 pSiS->NoXvideo = TRUE; /* No fbmem manager -> no xv */
 
 	      }
-
-	   }
 #endif /* EXA */
 
 
@@ -1348,8 +1405,10 @@ SiS300AccelInit(ScreenPtr pScreen)
 			"Framebuffer from (%d,%d) to (%d,%d)\n",
 			Avail.x1, Avail.y1, Avail.x2 - 1, Avail.y2 - 1);
 
+
 	   xf86InitFBManager(pScreen, &Avail);
 
+
 	   if(!pSiS->NoAccel) {
 	      return XAAInit(pScreen, infoPtr);
 	   }
@@ -1370,10 +1429,18 @@ SiS300AccelInit(ScreenPtr pScreen)
 	      /* Reserve locked offscreen scratch area of 128K for glyph data */
 	      pSiS->exa_scratch = exaOffscreenAlloc(pScreen, 128 * 1024, 16, TRUE,
 						SiSScratchSave, pSiS);
-	      if(pSiS->exa_scratch) {
+    
+    #if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+              if(pSiS->exa_scratch) {
+		 pSiS->exa_scratch_next = pSiS->exa_scratch->offset;
+		 pSiS->EXADriverPtr->accel.UploadToScratch = SiSUploadToScratch;
+	      }
+    #else
+              if(pSiS->exa_scratch) {
 		 pSiS->exa_scratch_next = pSiS->exa_scratch->offset;
 		 pSiS->EXADriverPtr->UploadToScratch = SiSUploadToScratch;
 	      }
+    #endif
 
 	   } else {
 
diff --git a/src/sis300_accel.h b/src/sis300_accel.h
index b01185f..4e01b47 100644
--- a/src/sis300_accel.h
+++ b/src/sis300_accel.h
@@ -90,6 +90,8 @@
 #define NO_RESET_COUNTER        0x00400000
 #define NO_LAST_PIXEL           0x00200000
 
+#define SBB_DEFAULT_ROP		0x0000CC00
+
 
 /* Macros to do useful things with the SIS BitBLT engine */
 
@@ -152,9 +154,9 @@
 
 #define SiSSetupDSTColorDepth(bpp) \
                 if(pSiS->VGAEngine != SIS_530_VGA) { \
-                  if (CmdQueLen <= 0)  SiSIdle;\
-                  SIS_MMIO_OUT16(pSiS->IOBase, BR(1)+2, bpp);\
-                  CmdQueLen--; \
+                   if (CmdQueLen <= 0)  SiSIdle;\
+                   SIS_MMIO_OUT16(pSiS->IOBase, BR(1)+2, bpp);\
+                   CmdQueLen--; \
 		}
 
 #define SiSSetupRect(w,h) \
@@ -297,13 +299,13 @@
                 CmdQueLen--;
 
 
-/* Set Pattern register */    
+/* Set Pattern register */
 #define SiSSetPattern(num, value) \
       if (CmdQueLen <= 0)  SiSIdle; \
       SIS_MMIO_OUT32(pSiS->IOBase, (PATTERN_REG + (num * 4)), value); \
       CmdQueLen--;
 
-            
+
 /* 3D stuff (used for RENDER) */
 
 /*
@@ -442,6 +444,7 @@
 #define REG_3D_Texture1TransparencyColorHigh   0x8AE4
 #define REG_3D_Texture1TransparencyColorLow    0x8AE8
 #define REG_3D_Texture1BorderColor             0x8AEC
+
 #define REG_3D_Texture1Address0                0x8AF0
 #define REG_3D_Texture1Address1                0x8AF4
 #define REG_3D_Texture1Address2                0x8AF8
@@ -454,9 +457,9 @@
 #define REG_3D_Texture1Address9                0x8B14
 #define REG_3D_Texture1Address10               0x8B18
 #define REG_3D_Texture1Address11               0x8B1C
-#define REG_3D_Texture1Pitch0                  0x8B20
-#define REG_3D_Texture1Pitch1                  0x8B20
-#define REG_3D_Texture1Pitch2                  0x8B24
+#define REG_3D_Texture1Pitch0                  0x8B20  /* lower 16 bit for tex 0 */
+#define REG_3D_Texture1Pitch1                  0x8B20  /* upper 16 bit for tex 1 */
+#define REG_3D_Texture1Pitch2                  0x8B24  /* ... */
 #define REG_3D_Texture1Pitch3                  0x8B24
 #define REG_3D_Texture1Pitch4                  0x8B28
 #define REG_3D_Texture1Pitch5                  0x8B28
@@ -482,11 +485,14 @@
  * REG_3D_ParsingSet - Parsing Mask (89F4h-89F7h)
  */
 #define MASK_VertexDWSize		0xF0000000
+
 #define MASK_VertexDataFormat		0x0FFF0000
+
 #define MASK_PsVertex_HAS_RHW           0x08000000
 #define MASK_PsVertex_HAS_NORMALXYZ     0x04000000
 #define MASK_PsVertex_HAS_DIFFUSE       0x02000000
 #define MASK_PsVertex_HAS_SPECULAR      0x01000000
+
 #define MASK_PsUVSet                    0x00FF0000
 #define MASK_PsVertex_HAS_1SetUV        0x00800000
 #define MASK_PsVertex_HAS_2SetUV        0x00C00000
@@ -494,15 +500,20 @@
 #define MASK_PsVertex_HAS_UVSet1        0x00800000
 #define MASK_PsVertex_HAS_UVSet2        0x00400000
 #define MASK_PsVertex_HAS_UVSet3        0x00200000
+
 #define MASK_PsCullDirection_CCW        0x00008000
+
 #define MASK_PsShadingMode              0x00007000
+
 #define MASK_PsTextureFrom              0x000003F0
+
 #define MASK_PsTexture0FromA            0x00000000
 #define MASK_PsTexture1FromA            0x00000000
 #define MASK_PsTexture1FromB            0x00000040
 #define MASK_PsBumpTextureFromA         0x00000000
 #define MASK_PsBumpTextureFromB         0x00000010
 #define MASK_PsBumpTextureFromC         0x00000020
+
 #define MASK_PsDataType                 0x0000000F
 #define MASK_PsPointList                0x00000000
 #define MASK_PsLineList                 0x00000004
@@ -510,6 +521,8 @@
 #define MASK_PsTriangleList             0x00000008
 #define MASK_PsTriangleStrip            0x00000009
 #define MASK_PsTriangleFan              0x0000000A
+
+
 /*
  * REG_3D_PrimitiveSet - Fire Primitive Mask (89F8h-89FBh)
  */
@@ -520,6 +533,52 @@
 #define MASK_Texture0From               0x00300000
 #define MASK_ShadingMode                0x07000000
 #define MASK_CullDirection              0x08000000
+
+#define OP_3D_POINT_DRAW                0x00000000
+#define OP_3D_LINE_DRAW                 0x00000001
+#define OP_3D_TRIANGLE_DRAW             0x00000002
+
+#define OP_3D_DIRECTION_RIGHT           0x00000000
+#define OP_3D_DIRECTION_LEFT            0x00000100
+#define OP_3D_DIRECTION_HORIZONTAL      0x00000000
+#define OP_3D_DIRECTION_VERTICAL        0x00000100
+
+#define OP_3D_FIRE_TFIRE                0x00000000
+#define OP_3D_FIRE_TSARGBa              0x00000100
+#define OP_3D_FIRE_TSWa                 0x00000200
+#define OP_3D_FIRE_TSVAa                0x00000300
+#define OP_3D_FIRE_TSVBa                0x00000400
+#define OP_3D_FIRE_TSVCa                0x00000500
+
+#define OP_3D_FIRE_TSARGBb              0x00000900
+#define OP_3D_FIRE_TSWb                 0x00000a00
+#define OP_3D_FIRE_TSVAb                0x00000b00
+#define OP_3D_FIRE_TSVBb                0x00000c00
+#define OP_3D_FIRE_TSVCb                0x00000d00
+
+#define OP_3D_FIRE_TSARGBc              0x00001100
+#define OP_3D_FIRE_TSWc                 0x00001200
+#define OP_3D_FIRE_TSVAc                0x00001300
+#define OP_3D_FIRE_TSVBc                0x00001400
+#define OP_3D_FIRE_TSVCc                0x00001500
+
+#define OP_3D_Texture0FromA             0x00000000
+#define OP_3D_Texture0FromB             0x00100000
+#define OP_3D_Texture0FromC             0x00200000
+#define OP_3D_Texture1FromA             0x00000000
+#define OP_3D_Texture1FromB             0x00040000
+#define OP_3D_Texture1FromC             0x00080000
+#define OP_3D_TextureBumpFromA          0x00000000
+#define OP_3D_TextureBumpFromB          0x00010000
+#define OP_3D_TextureBumpFromC          0x00020000
+
+#define SHADE_FLAT_VertexA              0x01000000
+#define SHADE_FLAT_VertexB              0x02000000
+#define SHADE_FLAT_VertexC              0x03000000
+#define SHADE_GOURAUD                   0x04000000
+
+
+
 /*
  *  Command Queue Length Mask (89FCh-89FF)
  */
@@ -540,7 +599,7 @@
 #define MASK_TexturePerspectiveEnable   0x00000200
 #define MASK_TextureEnable              0x00000400
 #define MASK_CullEnable                 0x00000800
-#define MASK_TextureNumUsed             0x0000F000
+#define MASK_TextureNumUsed             0x0000F000 /* number used= 1, 2, ... if MASK_TextureEnable set */
 #define MASK_AlphaBufferEnable          0x00010000
 #define MASK_AlphaTestEnable            0x00020000
 #define MASK_AlphaWriteEnable           0x00040000
@@ -591,6 +650,30 @@
 #define MASK_ZBufferInSystem            0x00080000
 #define MASK_ZBufferFormat              0x01F00000
 
+#define Z_BUFFER_FORMAT_Z16             0x00000000
+#define Z_BUFFER_FORMAT_Z16_INT         0x00100000
+#define Z_BUFFER_FORMAT_S1Z15           0x00400000
+#define Z_BUFFER_FORMAT_S1Z15_INT       0x00500000
+#define Z_BUFFER_FORMAT_Z32             0x00800000
+#define Z_BUFFER_FORMAT_S1Z31           0x00C00000
+#define Z_BUFFER_FORMAT_S2Z30           0x00D00000
+#define Z_BUFFER_FORMAT_S4Z28           0x00E00000
+#define Z_BUFFER_FORMAT_S8Z24           0x00F00000
+#define Z_BUFFER_FORMAT_FZ30            0x01800000
+#define Z_BUFFER_FORMAT_FS1Z30          0x01C00000
+#define Z_BUFFER_FORMAT_FS2Z30          0x01D00000
+#define MASK_Z_BUFFER_FORMAT            0x01F00000
+
+/* (Duplicates) */
+#define Z_16				0x00000000
+#define S_1_Z_15			0x00400000
+#define Z_32				0x00800000
+#define S_1_Z_31			0x00c00000
+#define S_2_Z_30			0x00d00000
+#define S_4_Z_28			0x00e00000
+#define S_8_Z_24			0x00f00000
+
+
 /*
  * REG_3D_ZBias -- Define Z Buffer Setting Mask (8A0Ch-8A0Fh)
  */
@@ -615,15 +698,22 @@
 #define MASK_AlphaBufferInSystem        0x08000000
 #define MASK_AlphaBufferFormat          0x30000000
 
+#define ALPHA_BUFFER_FORMAT_1           0x00000000
+#define ALPHA_BUFFER_FORMAT_2           0x10000000
+#define ALPHA_BUFFER_FORMAT_4           0x20000000
+#define ALPHA_BUFFER_FORMAT_8           0x30000000
+
+
 /*
  * REG_3D_AlphaAddress -- Define Alpha Buffer Base Address(8A1Ch-8A1Fh)
  */
 #define MASK_AlphaAddress               0xFFFFFFFF
 
+
 /*
  * REG_3D_DstSet -- Define Destination Buffer Setting Mask (8A20h-8A23h)
  */
-#define MASK_DstBufferPitch             0x00000FFF
+#define MASK_DstBufferPitch             0x00000FFF /* max dest pitch: 4095!!! */
 #define MASK_DstBufferFormat            0x000F0000
 #define MASK_DstBufferBitDepth          0x00300000
 #define MASK_DstBufferRgbOrder          0x00400000
@@ -631,17 +721,58 @@
 #define MASK_Dst7BitFormat              0x007F0000
 #define MASK_ROP2                       0x0F000000
 
+#define DST_FORMAT_RGB_555              0x00100000
+#define DST_FORMAT_RGB_565              0x00110000
+#define DST_FORMAT_ARGB_1555            0x00120000
+#define DST_FORMAT_ARGB_4444            0x00130000
+#define DST_FORMAT_ARGB_1888            0x00300000
+#define DST_FORMAT_ARGB_2888            0x00310000
+#define DST_FORMAT_ARGB_4888            0x00320000
+#define DST_FORMAT_ARGB_8888            0x00330000
+#define DST_FORMAT_ARGB_0888            0x00340000
+
+#define DST_FORMAT_BGR_555              0x00500000
+#define DST_FORMAT_BGR_565              0x00510000
+#define DST_FORMAT_ABGR_1555            0x00520000
+#define DST_FORMAT_ABGR_4444            0x00530000
+#define DST_FORMAT_ABGR_1888            0x00700000
+#define DST_FORMAT_ABGR_2888            0x00710000
+#define DST_FORMAT_ABGR_4888            0x00720000
+#define DST_FORMAT_ABGR_8888            0x00730000
+#define DST_FORMAT_ABGR_0888            0x00740000
+
+/* Logic Op */
+#define LOP_CLEAR			0x00000000
+#define LOP_NOR				0x01000000
+#define LOP_AND_INVERTED		0x02000000
+#define LOP_COPY_INVERTED		0x03000000
+#define LOP_AND_REVERSE			0x04000000
+#define LOP_INVERT			0x05000000
+#define LOP_XOR				0x06000000
+#define LOP_NAND			0x07000000
+#define LOP_AND				0x08000000
+#define LOP_EQUIV			0x09000000
+#define LOP_NOOP			0x0a000000
+#define LOP_OR_INVERTED			0x0b000000
+#define LOP_COPY			0x0c000000
+#define LOP_OR_REVERSE			0x0d000000
+#define LOP_OR				0x0e000000
+#define LOP_SET				0x0f000000
+
+
 /*
  * REG_3D_DstAlphaWriteMask -- Define Destination/Alpha  Buffer Write Mask (8A24h-8A27h)
  */
 #define MASK_ColorWriteMask             0x00FFFFFF
 #define MASK_AlphaWriteMask             0xFF000000
 
+
 /*
  * REG_3D_DstAddress -- Define Destination Buffer Base Address(8A1Ch-8A1Fh)
  */
 #define MASK_DstAddress                 0xFFFFFFFF
 
+
 /*
  * REG_3D_LinePattern -- Define Line Pattern (8A2Ch-8A2Fh)
  */
@@ -649,6 +780,7 @@
 #define MASK_LinePatternLastPixelFlag   0x00008000
 #define MASK_LinePattern                0xFFFF0000
 
+
 /*
  * REG_3D_FogSet -- Define Fog Mask (8A30h-8A33h)
  */
@@ -656,6 +788,12 @@
 #define MASK_FogMode                    0x07000000
 #define MASK_FogZLookup		        0x08000000
 
+#define FOGMODE_CHEAP                  	0x04000000
+#define FOGMODE_LINEAR                  0x05000000
+#define FOGMODE_EXP                     0x06000000
+#define FOGMODE_EXP2                    0x07000000
+
+
 /*
  * REG_3D_FogStartEnd -- Define Fog Start End Setting (8A34h-8A37h)
  */
@@ -669,6 +807,11 @@
 #define MASK_FogDensity                 0x0003FFFF
 #define MASK_FogFactor                  0xFF000000
 
+
+/* TW: REG_3D_StencilSet               0x8A44
+       REG_3D_StencilSet2              0x8A48
+       REG_3D_StencilAddress           0x8A4C
+*/
 #define MASK_StencilMaskValue           0x000000FF
 #define MASK_StencilReferenceValue      0x0000FF00
 #define MASK_StencilTestMode            0x07000000
@@ -687,6 +830,10 @@
 #define MASK_StencilFailOp_REPLACE      0x00200000
 #define MASK_StencilAddress             0xFFFFFFFF
 
+
+/* TW: REG_3D_DstBlendMode             0x8A50
+       REG_3D_SrcBlendMode             0x8A50
+*/
 #define MASK_SrcBlendMode                       0x0000000F
 #define MASK_DstBlendMode                       0x000000F0
 #define MASK_DSTBLEND_ZERO                      0x00000000
@@ -715,12 +862,23 @@
 #define MASK_SRCBLEND_BOTH_SRC_ALPHA            0x0000000B
 #define MASK_SRCBLEND_BOTH_INV_SRC_ALPHA        0x0000000C
 
+
+/* TW: REG_3D_ClipTopBottom            0x8A54
+       REG_3D_ClipLeftRight            0x8A58
+*/
 #define MASK_BottomClip                0x00001FFF
 #define MASK_TopClip                   0x03FFE000
 
 #define MASK_RightClip                 0x00001FFF
 #define MASK_LeftClip                  0x03FFE000
 
+
+/* TW: REG_3D_BumpMapSet               0x8A68
+       REG_3D_BumpMapAddress           0x8A6C
+       REG_3D_BumpMapPitch             0x8A70
+       REG_3D_BumpMapMatrix0           0x8A74
+       REG_3D_BumpMapMatrix1           0x8A78
+*/
 #define MASK_BMMemoryInSystem          0x00000080
 #define MASK_BMHeight                  0x00000F00
 #define MASK_BMWidth                   0x0000F000
@@ -740,137 +898,27 @@
 #define MASK_BMMatrix10                0x000007FF
 #define MASK_BMMatrix11                0x07FF0000
 
+
+/* TW: REG_3D_TextureSet                     0x8A7C
+       REG_3D_TextureWidthHeight             0x8A7C
+*/
 #define MASK_TextureHeight             0x0000000F
 #define MASK_TextureWidth              0x000000F0
 #define MASK_TextureLevel              0x00000F00
 #define MASK_TextureSignYUVFormat      0x00001000
 #define MASK_TextureMappingMode        0x00FF0000
-#define MASK_TextureWrapU              0x00010000
-#define MASK_TextureWrapV              0x00020000
+#define MASK_TextureWrapU              0x00010000  /* "Wrap" = repeat; WrapS == REPEAT */
+#define MASK_TextureWrapV              0x00020000  /* WrapT == REPEAT */
 #define MASK_TextureMirrorU            0x00040000
 #define MASK_TextureMirrorV            0x00080000
-#define MASK_TextureClampU             0x00100000
-#define MASK_TextureClampV             0x00200000
+#define MASK_TextureClampU             0x00100000  /* WrapT == CLAMP */
+#define MASK_TextureClampV             0x00200000  /* WrapS == CLAMP */
 #define MASK_TextureBorderU            0x00400000
 #define MASK_TextureBorderV            0x00800000
 #define MASK_TextureFormat             0xFF000000
 #define MASK_TextureBitDepth           0x70000000
 #define MASK_TextureRgbOrder           0x80000000
 
-#define MASK_TextureAnisotropyRatio    0x0000000F
-#define MASK_TextureMipmapLodBias      0x00003FF0
-#define MASK_TextureFilterMin          0x0001C000
-#define MASK_TextureFilterMag          0x00020000
-#define MASK_TextureFilter             0x0003C000
-#define MASK_TextureLevelInSystem      0x3FFC0000
-#define MASK_TextureLevel0InSystem     0x00040000
-#define MASK_TextureBlockLength        0xF0000000
-
-#define MASK_TextureTransparencyColorHighB  0x000000FF
-#define MASK_TextureTransparencyColorHighG  0x0000FF00
-#define MASK_TextureTransparencyColorHighR  0x00FF0000
-#define MASK_TextureAlphaTransparencyMode   0x08000000
-
-#define MASK_TextureTransparencyColorLowB   0x000000FF
-#define MASK_TextureTransparencyColorLowG   0x0000FF00
-#define MASK_TextureTransparencyColorLowR   0x00FF0000
-#define MASK_TextureBlockHeight             0x07000000
-#define MASK_TextureBlockWidth              0x70000000
-
-#define MASK_TextureBorderColorB        0x000000FF
-#define MASK_TextureBorderColorG        0x0000FF00
-#define MASK_TextureBorderColorR        0x00FF0000
-#define MASK_TextureBorderColorA        0xFF000000
-
-#define MASK_TexturePitchOdd            0x000003FF
-#define MASK_TexturePitchEven           0x03FF0000
-#define SHIFT_TexturePitchEven          16
-
-#define MASK_TextureRealInSystem        0x00000001
-#define MASK_TextureDowngrade           0x00000002
-
-#define OP_3D_POINT_DRAW                0x00000000
-#define OP_3D_LINE_DRAW                 0x00000001
-#define OP_3D_TRIANGLE_DRAW             0x00000002
-
-#define OP_3D_DIRECTION_RIGHT           0x00000000
-#define OP_3D_DIRECTION_LEFT            0x00000100
-#define OP_3D_DIRECTION_HORIZONTAL      0x00000000
-#define OP_3D_DIRECTION_VERTICAL        0x00000100
-
-#define OP_3D_FIRE_TFIRE                0x00000000
-#define OP_3D_FIRE_TSARGBa              0x00000100
-#define OP_3D_FIRE_TSWa                 0x00000200
-#define OP_3D_FIRE_TSVAa                0x00000300
-#define OP_3D_FIRE_TSVBa                0x00000400
-#define OP_3D_FIRE_TSVCa                0x00000500
-
-#define OP_3D_FIRE_TSARGBb              0x00000900
-#define OP_3D_FIRE_TSWb                 0x00000a00
-#define OP_3D_FIRE_TSVAb                0x00000b00
-#define OP_3D_FIRE_TSVBb                0x00000c00
-#define OP_3D_FIRE_TSVCb                0x00000d00
-
-#define OP_3D_FIRE_TSARGBc              0x00001100
-#define OP_3D_FIRE_TSWc                 0x00001200
-#define OP_3D_FIRE_TSVAc                0x00001300
-#define OP_3D_FIRE_TSVBc                0x00001400
-#define OP_3D_FIRE_TSVCc                0x00001500
-
-#define OP_3D_Texture0FromA             0x00000000
-#define OP_3D_Texture0FromB             0x00100000
-#define OP_3D_Texture0FromC             0x00200000
-#define OP_3D_Texture1FromA             0x00000000
-#define OP_3D_Texture1FromB             0x00040000
-#define OP_3D_Texture1FromC             0x00080000
-#define OP_3D_TextureBumpFromA          0x00000000
-#define OP_3D_TextureBumpFromB          0x00010000
-#define OP_3D_TextureBumpFromC          0x00020000
-
-#define SHADE_FLAT_VertexA              0x01000000
-#define SHADE_FLAT_VertexB              0x02000000
-#define SHADE_FLAT_VertexC              0x03000000
-#define SHADE_GOURAUD                   0x04000000
-
-#define Z_BUFFER_FORMAT_Z16             0x00000000
-#define Z_BUFFER_FORMAT_Z16_INT         0x00100000
-#define Z_BUFFER_FORMAT_S1Z15           0x00400000
-#define Z_BUFFER_FORMAT_S1Z15_INT       0x00500000
-#define Z_BUFFER_FORMAT_Z32             0x00800000
-#define Z_BUFFER_FORMAT_S1Z31           0x00C00000
-#define Z_BUFFER_FORMAT_S2Z30           0x00D00000
-#define Z_BUFFER_FORMAT_S4Z28           0x00E00000
-#define Z_BUFFER_FORMAT_S8Z24           0x00F00000
-#define Z_BUFFER_FORMAT_FZ30            0x01800000
-#define Z_BUFFER_FORMAT_FS1Z30          0x01C00000
-#define Z_BUFFER_FORMAT_FS2Z30          0x01D00000
-#define MASK_Z_BUFFER_FORMAT            0x01F00000
-
-#define ALPHA_BUFFER_FORMAT_1           0x00000000
-#define ALPHA_BUFFER_FORMAT_2           0x10000000
-#define ALPHA_BUFFER_FORMAT_4           0x20000000
-#define ALPHA_BUFFER_FORMAT_8           0x30000000
-
-#define DST_FORMAT_RGB_555              0x00100000
-#define DST_FORMAT_RGB_565              0x00110000
-#define DST_FORMAT_ARGB_1555            0x00120000
-#define DST_FORMAT_ARGB_4444            0x00130000
-#define DST_FORMAT_ARGB_1888            0x00300000
-#define DST_FORMAT_ARGB_2888            0x00310000
-#define DST_FORMAT_ARGB_4888            0x00320000
-#define DST_FORMAT_ARGB_8888            0x00330000
-#define DST_FORMAT_ARGB_0888            0x00340000
-
-#define DST_FORMAT_BGR_555              0x00500000
-#define DST_FORMAT_BGR_565              0x00510000
-#define DST_FORMAT_ABGR_1555            0x00520000
-#define DST_FORMAT_ABGR_4444            0x00530000
-#define DST_FORMAT_ABGR_1888            0x00700000
-#define DST_FORMAT_ABGR_2888            0x00710000
-#define DST_FORMAT_ABGR_4888            0x00720000
-#define DST_FORMAT_ABGR_8888            0x00730000
-#define DST_FORMAT_ABGR_0888            0x00740000
-
 #define MASK_TEXTURE_FORMAT        	0xFF000000
 
 #define TEXEL_INDEX1                    0x00000000
@@ -954,24 +1002,19 @@
 #define TEXEL_LUV655                    0x02800000
 #define TEXEL_LUV888                    0x03000000
 
-#define FOGMODE_CHEAP                  	0x04000000
-#define FOGMODE_LINEAR                  0x05000000
-#define FOGMODE_EXP                     0x06000000
-#define FOGMODE_EXP2                    0x07000000
-
-#define Z_16				0x00000000
-#define S_1_Z_15			0x00400000
-#define Z_32				0x00800000
-#define S_1_Z_31			0x00c00000
-#define S_2_Z_30			0x00d00000
-#define S_4_Z_28			0x00e00000
-#define S_8_Z_24			0x00f00000
 
-#define S_1				0x00000000
-#define S_2				0x10000000
-#define S_4				0x20000000
-#define S_8				0x30000000
+/* TW: REG_3D_TextureMip                     0x8A80
+*/
+#define MASK_TextureAnisotropyRatio    0x0000000F
+#define MASK_TextureMipmapLodBias      0x00003FF0 /* (-128 - 127) << 4 */
+#define MASK_TextureFilterMin          0x0001C000
+#define MASK_TextureFilterMag          0x00020000
+#define MASK_TextureFilter             0x0003C000
+#define MASK_TextureLevelInSystem      0x3FFC0000
+#define MASK_TextureLevel0InSystem     0x00040000 /* if in AGP space */
+#define MASK_TextureBlockLength        0xF0000000
 
+/* These for min */
 #define TEXTURE_FILTER_NEAREST			0x00000000
 #define TEXTURE_FILTER_LINEAR			0x00004000
 #define TEXTURE_FILTER_NEAREST_MIP_NEAREST	0x00008000
@@ -979,6 +1022,10 @@
 #define TEXTURE_FILTER_LINEAR_MIP_NEAREST	0x0000c000
 #define TEXTURE_FILTER_LINEAR_MIP_LINEAR	0x00014000
 
+/* These for mag */
+#define TEXTURE_FILTER_MAG_NEAREST		0x00000000
+#define TEXTURE_FILTER_MAG_LINEAR		0x00020000
+
 #define A_REPLACE_RGB_STAGE0		0xa1485000
 #define A_REPLACE_A_STAGE0		0xc3230000
 #define L_REPLACE__RGB_STAGE0		0xc1485000
@@ -1038,7 +1085,7 @@
 #define RGB_REPLACE__A_STAGE1		0xa3230000
 #define RGBA_REPLACE__RGB_STAGE1	0xe1485000
 #define RGBA_REPLACE__A_STAGE1		0xe3230000
-	
+
 #define A_MODULATE_RGB_STAGE1		0xa1485000
 #define A_MODULATE_A_STAGE1		0xa3e30000
 #define L_MODULATE__RGB_STAGE1		0xa1785000
@@ -1068,8 +1115,50 @@
 #define RGB_BLEND__RGB_STAGE1		0x45394001
 #define RGB_BLEND__A_STAGE1		0xa3230000
 #define RGBA_BLEND__RGB_STAGE1		0x45394001
-#define RGBA_BLEND__A_STAGE1		0xa3e30000     
+#define RGBA_BLEND__A_STAGE1		0xa3e30000
+
 
+/* TW: REG_3D_TextureTransparencyColorHigh    0x8A84
+*/
+#define MASK_TextureTransparencyColorHighB  0x000000FF
+#define MASK_TextureTransparencyColorHighG  0x0000FF00
+#define MASK_TextureTransparencyColorHighR  0x00FF0000
+#define MASK_TextureAlphaTransparencyMode   0x08000000
+
+/* TW: REG_3D_TextureTransparencyColorLow     0x8A88
+*/
+#define MASK_TextureTransparencyColorLowB   0x000000FF
+#define MASK_TextureTransparencyColorLowG   0x0000FF00
+#define MASK_TextureTransparencyColorLowR   0x00FF0000
+#define MASK_TextureBlockHeight             0x07000000
+#define MASK_TextureBlockWidth              0x70000000
+
+/* TW: REG_3D_TextureBorderColor              0x8A8C
+*/
+#define MASK_TextureBorderColorB        0x000000FF
+#define MASK_TextureBorderColorG        0x0000FF00
+#define MASK_TextureBorderColorR        0x00FF0000
+#define MASK_TextureBorderColorA        0xFF000000
+
+/* TW: REG_3D_Texture1Pitch0                  0x8B20
+*/
+#define MASK_TexturePitchOdd            0x000003FF
+#define MASK_TexturePitchEven           0x03FF0000
+#define SHIFT_TexturePitchEven          16
+
+#define MASK_TextureRealInSystem        0x00000001
+#define MASK_TextureDowngrade           0x00000002
+
+
+/* ? */
+#define S_1				0x00000000
+#define S_2				0x10000000
+#define S_4				0x20000000
+#define S_8				0x30000000
+
+
+
+/* ------------ */
 
 #define INIT_6327_CapsEnable            0x00000080
 #define INIT_6327_CapsEnable2           0x00000000
@@ -1158,23 +1247,7 @@
 #define SiS_S_ONE_MINUS_DST_COLOR       0x00000009
 #define SiS_S_SRC_ALPHA_SATURATE        0x0000000a
 
-/* Logic Op */
-#define LOP_CLEAR			0x00000000
-#define LOP_NOR				0x01000000
-#define LOP_AND_INVERTED		0x02000000
-#define LOP_COPY_INVERTED		0x03000000
-#define LOP_AND_REVERSE			0x04000000
-#define LOP_INVERT			0x05000000
-#define LOP_XOR				0x06000000
-#define LOP_NAND			0x07000000
-#define LOP_AND				0x08000000
-#define LOP_EQUIV			0x09000000
-#define LOP_NOOP			0x0a000000
-#define LOP_OR_INVERTED			0x0b000000
-#define LOP_COPY			0x0c000000
-#define LOP_OR_REVERSE			0x0d000000
-#define LOP_OR				0x0e000000
-#define LOP_SET				0x0f000000
+
 
 #define SiSWait3DCmdQueue(wLen)\
 do{ \
@@ -1182,5 +1255,5 @@ do{ \
       CmdQueLen = (SIS_MMIO_IN16(pSiS->IOBase, 0x8240) & pSiS->CmdQueLenMask) - pSiS->CmdQueLenFix; \
   } \
   CmdQueLen -= (int)(wLen); \
-} while(0) 
+} while(0)
 
diff --git a/src/sis310_accel.c b/src/sis310_accel.c
index 13f085b..2ae260f 100644
--- a/src/sis310_accel.c
+++ b/src/sis310_accel.c
@@ -43,11 +43,9 @@
 #define SIS_NEED_ACCELBUF
 #include "sis_regs.h"
 #include "sis310_accel.h"
-
-#if 0
+/*
 #define ACCELDEBUG
-#endif
-
+*/
 #define FBOFFSET 	(pSiS->dhmOffset)
 
 #define DEV_HEIGHT	0xfff	/* "Device height of destination bitmap" */
@@ -58,33 +56,6 @@
 
 #ifdef SIS_USE_XAA
 
-#undef TRAP		/* Use/Don't use Trapezoid Fills
-			 * DOES NOT WORK. XAA sometimes provides illegal
-			 * trapezoid data (left and right edges cross each
-			 * other) which causes drawing errors. Since
-			 * checking the trapezoid for such a case is very
-			 * time-intensive, it is faster to let it be done
-			 * by the generic polygon functions.
-			 * Does not work on 330 series at all, hangs the engine.
-			 * Even with correct trapezoids, this is slower than
-			 * doing it by the CPU.
-                         */
-
-#undef CTSCE		/* Use/Don't use CPUToScreenColorExpand. Disabled
-			 * because it is slower than doing it by the CPU.
-			 * Indirect mode does not work in VRAM queue mode.
-			 * Does not work on 330 series (even in MMIO mode).
-			 */
-#undef CTSCE_DIRECT	/* Use direct method - This works (on both 315 and 330 at
-			 * least in VRAM queue mode) but we don't use this either,
-			 * because it's slower than doing it by the CPU. (Using it
-			 * would require defining CTSCE)
-			 */
-
-#undef STSCE		/* Use/Don't use ScreenToScreenColorExpand - does not work,
-			 * see comments below.
-			 */
-
 #define INCL_RENDER	/* Use/Don't use RENDER extension acceleration */
 
 #ifdef INCL_RENDER
@@ -110,24 +81,23 @@
 #define SIS_HAVE_COMPOSITE		/* Have our own EXA composite */
 #endif
 #ifdef SIS_HAVE_COMPOSITE
+#if 0
 #ifndef SIS_NEED_ARRAY
 #define SIS_NEED_ARRAY
 #endif
 #endif
 #endif
+#endif
 
-#ifdef SIS_USE_XAA		/* XAA */
-#ifdef INCL_RENDER
-#ifdef RENDER
+#if defined(SIS_USE_XAA) && defined(INCL_RENDER) && defined(RENDER)  /* XAA */
 static CARD32 SiSAlphaTextureFormats[2] = { PICT_a8      , 0 };
 static CARD32 SiSTextureFormats[2]      = { PICT_a8r8g8b8, 0 };
+static CARD32 SiS3DAlphaTextureFormats[2] = { PICT_a8r8g8b8, 0 };
 #ifdef SISNEWRENDER
 static CARD32 SiSDstTextureFormats16[2] = { PICT_r5g6b5  , 0 };
 static CARD32 SiSDstTextureFormats32[3] = { PICT_x8r8g8b8, PICT_a8r8g8b8, 0 };
 #endif
-#endif /* RENDER */
-#endif /* INCL_RENDER */
-#endif /* XAA */
+#endif
 
 #ifdef SIS_USE_EXA		/* EXA */
 void SiSScratchSave(ScreenPtr pScreen, ExaOffscreenArea *area);
@@ -136,15 +106,51 @@ Bool SiSUploadToScratch(PixmapPtr pSrc, PixmapPtr pDst);
 Bool SiSDownloadFromScreen(PixmapPtr pSrc, int x, int y, int w, int h, char *dst, int dst_pitch);
 #endif /* EXA */
 
-#ifdef INCL_YUV_BLIT_ADAPTOR
 void SISWriteBlitPacket(SISPtr pSiS, CARD32 *packet);
-#endif
 
 extern unsigned char SiSGetCopyROP(int rop);
 extern unsigned char SiSGetPatternROP(int rop);
 
-CARD32 dummybuf;
 
+pthread_mutex_t *CmdQ_Lock;
+
+void SiSOccpyCmdQue(SISPtr pSiS)
+{
+	if(pSiS->DRIEnabled)
+			pthread_mutex_lock(CmdQ_Lock);
+	
+	return;
+}
+
+
+void SiSReleaseCmdQue(SISPtr pSiS)
+{
+	if(pSiS->DRIEnabled)
+		pthread_mutex_unlock(CmdQ_Lock);
+	return;
+}
+
+/* 3D-engine accel */
+extern Bool
+SiSSetupForCPUToScreenAlphaTexture3D (ScrnInfoPtr pScrn,
+	int op, CARD16 red, CARD16 green,
+	CARD16 blue, CARD16 alpha,
+#ifdef SISNEWRENDER			
+	CARD32 alphaType, CARD32 dstType,
+#else			
+	int alphaType,
+#endif			
+	CARD8 *alphaPtr,
+	int alphaPitch, int width,
+	int height, int	flags);
+
+extern void SiSSubsequentCPUToScreenTexture3D(ScrnInfoPtr pScrn,
+	int dst_x, int dst_y,
+	int src_x, int src_y,
+	int width, int height);
+
+volatile CARD32 dummybuf;
+	
 #ifdef SIS_NEED_ARRAY
 #if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,0,0,0)
 #define SiSRenderOpsMAX 0x2b
@@ -214,14 +220,6 @@ SiSSync(ScrnInfoPtr pScrn)
 
 #ifdef SIS_USE_XAA
 	if(!pSiS->useEXA) {
-#ifdef CTSCE
-#ifdef CTSCE_DIRECT
-	   if(pSiS->DoColorExpand) {
-	      SiSDoCMD
-	      pSiS->ColorExpandBusy = TRUE;
-	   }
-#endif
-#endif
 	   pSiS->DoColorExpand = FALSE;
 	}
 #endif
@@ -231,6 +229,16 @@ SiSSync(ScrnInfoPtr pScrn)
 	SiSIdle
 }
 
+#ifdef SISVRAMQ
+static CARD32
+SISSiSUpdateQueue(SISPtr pSiS, CARD32 ttt, pointer tt)
+{
+	SiSUpdateQueue
+
+	return ttt;
+}
+#endif
+
 static void
 SiSSyncAccel(ScrnInfoPtr pScrn)
 {
@@ -251,6 +259,8 @@ SiSInitializeAccelerator(ScrnInfoPtr pScrn)
 
 	if(!pSiS->NoAccel) {
 
+
+	
 #ifndef SISVRAMQ
 	   if(pSiS->ChipFlags & SiSCF_Integrated) {
 	      CmdQueLen = 0;
@@ -260,7 +270,7 @@ SiSInitializeAccelerator(ScrnInfoPtr pScrn)
 #endif
 
 #ifdef SISVRAMQ
-	   if(pSiS->ChipType == XGI_40) {
+	   if(pSiS->ChipFlags & SiSCF_DualPipe) {
 	      SiSSync(pScrn);
 	      SiSDualPipe(1);	/* 1 = disable, 0 = enable */
 	      SiSSync(pScrn);
@@ -277,6 +287,11 @@ SiSSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
 {
 	SISPtr  pSiS = SISPTR(pScrn);
 
+	SiSOccpyCmdQue(pSiS);
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, "XAA calling ScreenToScreenCopy\n");
+#endif
+
 #ifdef SISVRAMQ
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	SiSCheckQueue(16 * 2);
@@ -304,6 +319,7 @@ SiSSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
 #ifdef SISVRAMQ
 	SiSSyncWP
 #endif
+	SiSReleaseCmdQue(pSiS);
 
 	/* The chip is smart enough to know the direction */
 }
@@ -317,6 +333,10 @@ SiSSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
 	CARD32 srcbase, dstbase;
 	int    mymin, mymax;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, "XAA calling SubsequentScreenToScreenCopy\n");
+#endif
+
 	srcbase = dstbase = 0;
 	mymin = min(src_y, dst_y);
 	mymax = max(src_y, dst_y);
@@ -378,6 +398,7 @@ SiSSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
 	srcbase += FBOFFSET;
 	dstbase += FBOFFSET;
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 3);
 	SiSSetupSRCDSTBase(srcbase, dstbase)
@@ -391,6 +412,8 @@ SiSSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
 	SiSSetupDSTXY(dst_x, dst_y)
 	SiSDoCMD
 #endif
+	SiSReleaseCmdQue(pSiS);
+
 }
 
 static void
@@ -399,12 +422,17 @@ SiSSetupForSolidFill(ScrnInfoPtr pScrn, int color,
 {
 	SISPtr  pSiS = SISPTR(pScrn);
 
-	if(pSiS->disablecolorkeycurrent) {
+	if(pSiS->disablecolorkeycurrent || pSiS->nocolorkey) {
 	   if((CARD32)color == pSiS->colorKey) {
 	      rop = 5;  /* NOOP */
 	   }
 	}
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, "XAA calling SolidFill\n");
+#endif
+
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	SiSCheckQueue(16 * 1);
@@ -419,6 +447,7 @@ SiSSetupForSolidFill(ScrnInfoPtr pScrn, int color,
 	SiSSetupROP(SiSGetPatternROP(rop))
 	SiSSetupCMDFlag(PATFG | pSiS->SiS310_AccelDepth)
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -428,6 +457,10 @@ SiSSubsequentSolidFillRect(ScrnInfoPtr pScrn,
 	SISPtr pSiS = SISPTR(pScrn);
 	CARD32 dstbase = 0;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, "XAA calling SubsequentSolidFillRect\n");
+#endif
+
 	if(y >= 2048) {
 	   dstbase = pSiS->scrnOffset * y;
 	   y = 0;
@@ -442,6 +475,7 @@ SiSSubsequentSolidFillRect(ScrnInfoPtr pScrn,
 
 	/* SiSSetupCMDFlag(BITBLT)  - BITBLT = 0 */
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 2)
 	SiSSetupDSTXYRect(x, y, w, h)
@@ -452,95 +486,22 @@ SiSSubsequentSolidFillRect(ScrnInfoPtr pScrn,
 	SiSSetupRect(w, h)
 	SiSDoCMD
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 #ifdef SIS_USE_XAA  /* ---------------------------- XAA -------------------------- */
 
-/* Trapezoid */
-/* This would work better if XAA would provide us with valid trapezoids.
- * In fact, with small trapezoids the left and the right edge often cross
- * each other which causes drawing errors (filling over whole scanline).
- * DOES NOT WORK ON 330 SERIES, HANGS THE ENGINE.
- */
-#ifdef TRAP
-static void
-SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
-			int left,  int dxL, int dyL, int eL,
-			int right, int dxR, int dyR, int eR )
-{
-	SISPtr pSiS = SISPTR(pScrn);
-	CARD32 dstbase = 0;
-
-	if(y >= 2048) {
-	   dstbase = pSiS->scrnOffset * y;
-	   y = 0;
-	}
-
-	dstbase += FBOFFSET;
-
-#ifdef SISVRAMQ	/* Not optimized yet */
-	SiSCheckQueue(16 * 10)
-#else
-	SiSSetupDSTBase(dstbase)
-#endif
-
-#if 1
-	SiSSetupPATFG(0xff0000) /* FOR TESTING */
-#endif
-
-	/* Clear CommandReg because SetUp can be used for Rect and Trap */
-	pSiS->CommandReg &= ~(T_L_X_INC | T_L_Y_INC |
-	                      T_R_X_INC | T_R_Y_INC |
-	                      T_XISMAJORL | T_XISMAJORR |
-			      BITBLT);
-
-        xf86DrvMsg(0, X_INFO, "Trap (%d %d %d %d) dxL %d dyL %d eL %d   dxR %d dyR %d eR %d\n",
-		left, right, y, h, dxL, dyL, eL, dxR, dyR, eR);
-
-	/* Determine egde angles */
-	if(dxL < 0) 	{ dxL = -dxL; }
-	else 		{ SiSSetupCMDFlag(T_L_X_INC) }
-	if(dxR < 0) 	{ dxR = -dxR; }
-	else 		{ SiSSetupCMDFlag(T_R_X_INC) }
-
-	/* (Y direction always positive - do this anyway) */
-	if(dyL < 0) 	{ dyL = -dyL; }
-	else 		{ SiSSetupCMDFlag(T_L_Y_INC) }
-	if(dyR < 0) 	{ dyR = -dyR; }
-	else 		{ SiSSetupCMDFlag(T_R_Y_INC) }
-
-	/* Determine major axis */
-	if(dxL >= dyL) {  SiSSetupCMDFlag(T_XISMAJORL) }
-	if(dxR >= dyR) {  SiSSetupCMDFlag(T_XISMAJORR) }
-
-	SiSSetupCMDFlag(TRAPAZOID_FILL);
-
-#ifdef SISVRAMQ
-	SiSSetupYHLR(y, h, left, right)
-	SiSSetupdLdR(dxL, dyL, dxR, dyR)
-	SiSSetupELER(eL, eR)
-	SiSSetupDSTBaseDoCMD(dstbase)
-#else
-	/* Set up deltas */
-	SiSSetupdL(dxL, dyL)
-	SiSSetupdR(dxR, dyR)
-	/* Set up y, h, left, right */
-	SiSSetupYH(y, h)
-	SiSSetupLR(left, right)
-	/* Set up initial error term */
-	SiSSetupEL(eL)
-	SiSSetupER(eR)
-	SiSDoCMD
-#endif
-}
-#endif
-
 static void
 SiSSetupForSolidLine(ScrnInfoPtr pScrn, int color, int rop,
 			unsigned int planemask)
 {
 	SISPtr pSiS = SISPTR(pScrn);
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, "XAA calling SolidLine\n");
+#endif
+
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	SiSCheckQueue(16 * 3);
@@ -557,6 +518,7 @@ SiSSetupForSolidLine(ScrnInfoPtr pScrn, int color, int rop,
 	SiSSetupROP(SiSGetPatternROP(rop))
 	SiSSetupCMDFlag(PATFG | LINE | pSiS->SiS310_AccelDepth)
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -567,6 +529,10 @@ SiSSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
 	int    miny, maxy;
 	CARD32 dstbase = 0;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, "XAA calling SubsequentSolidTwoPointLine\n");
+#endif
+
 	miny = (y1 > y2) ? y2 : y1;
 	maxy = (y1 > y2) ? y1 : y2;
 	if(maxy >= 2048) {
@@ -583,6 +549,7 @@ SiSSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
 	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
 	}
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 2);
 	SiSSetupX0Y0X1Y1(x1, y1, x2, y2)
@@ -593,6 +560,7 @@ SiSSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
 	SiSSetupX1Y1(x2, y2)
 	SiSDoCMD
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -602,6 +570,10 @@ SiSSubsequentSolidHorzVertLine(ScrnInfoPtr pScrn,
 	SISPtr pSiS = SISPTR(pScrn);
 	CARD32 dstbase = 0;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SubsequentSolidTwoPointLine\n");
+#endif
+
 	len--; /* starting point is included! */
 
 	if((y >= 2048) || ((y + len) >= 2048)) {
@@ -611,6 +583,7 @@ SiSSubsequentSolidHorzVertLine(ScrnInfoPtr pScrn,
 
 	dstbase += FBOFFSET;
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 2);
 	if(dir == DEGREES_0) {
@@ -629,6 +602,7 @@ SiSSubsequentSolidHorzVertLine(ScrnInfoPtr pScrn,
 	}
 	SiSDoCMD
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -638,6 +612,11 @@ SiSSetupForDashedLine(ScrnInfoPtr pScrn,
 {
 	SISPtr pSiS = SISPTR(pScrn);
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SetupForDashedLine\n");
+#endif
+
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	SiSCheckQueue(16 * 3);
@@ -670,6 +649,7 @@ SiSSetupForDashedLine(ScrnInfoPtr pScrn,
 #ifdef SISVRAMQ
         SiSSyncWP
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -680,6 +660,10 @@ SiSSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
 	SISPtr pSiS = SISPTR(pScrn);
 	CARD32 dstbase, miny, maxy;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SubsequentDashedTwoPointLine\n");
+#endif
+
 	dstbase = 0;
 	miny = (y1 > y2) ? y2 : y1;
 	maxy = (y1 > y2) ? y1 : y2;
@@ -697,6 +681,7 @@ SiSSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
 	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
 	}
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 2);
 	SiSSetupX0Y0X1Y1(x1, y1, x2, y2)
@@ -707,6 +692,7 @@ SiSSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
 	SiSSetupX1Y1(x2, y2)
 	SiSDoCMD
 #endif
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -716,6 +702,11 @@ SiSSetupForMonoPatternFill(ScrnInfoPtr pScrn,
 {
 	SISPtr pSiS = SISPTR(pScrn);
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SetupForMonoPatternFill\n");
+#endif
+
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	SiSCheckQueue(16 * 3);
@@ -745,6 +736,8 @@ SiSSetupForMonoPatternFill(ScrnInfoPtr pScrn,
 #ifdef SISVRAMQ
 	SiSSyncWP
 #endif
+	SiSReleaseCmdQue(pSiS);
+
 }
 
 static void
@@ -755,6 +748,11 @@ SiSSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
 	SISPtr pSiS = SISPTR(pScrn);
 	CARD32 dstbase = 0;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SubsequentMonoPatternFill\n");
+
+#endif
+
 	if(y >= 2048) {
 	   dstbase = pSiS->scrnOffset * y;
 	   y = 0;
@@ -767,7 +765,8 @@ SiSSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
 			      T_L_X_INC | T_L_Y_INC |
 			      T_R_X_INC | T_R_Y_INC |
 			      TRAPAZOID_FILL);
-
+	
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 2);
 	SiSSetupDSTXYRect(x,y,w,h)
@@ -778,76 +777,9 @@ SiSSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
 	SiSSetupRect(w,h)
 	SiSDoCMD
 #endif
-}
-
-/* --- Trapezoid --- */
-
-/* Does not work at all on 330 series */
-
-#ifdef TRAP
-static void
-SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
-			int patx, int paty,
-			int y, int h,
-			int left, int dxL, int dyL, int eL,
-			int right, int dxR, int dyR, int eR)
-{
-	SISPtr pSiS = SISPTR(pScrn);
-	CARD32 dstbase = 0;
-
-	if(y >= 2048) {
-	   dstbase=pSiS->scrnOffset*y;
-	   y = 0;
-	}
-
-	dstbase += FBOFFSET;
-
-#ifdef SISVRAMQ
-	SiSCheckQueue(16 * 4);
-#else
-	SiSSetupDSTBase(dstbase)
-#endif
-
-	/* Clear CommandReg because SetUp can be used for Rect and Trap */
-	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
-			      T_L_X_INC | T_L_Y_INC |
-			      T_R_X_INC | T_R_Y_INC |
-			      BITBLT);
-
-	if(dxL < 0) 	{ dxL = -dxL;  }
-	else 		{ SiSSetupCMDFlag(T_L_X_INC) }
-	if(dxR < 0) 	{ dxR = -dxR; }
-	else 		{ SiSSetupCMDFlag(T_R_X_INC) }
-
-	if(dyL < 0) 	{ dyL = -dyL; }
-	else 		{ SiSSetupCMDFlag(T_L_Y_INC) }
-	if(dyR < 0) 	{ dyR = -dyR; }
-	else 		{ SiSSetupCMDFlag(T_R_Y_INC) }
-
-	/* Determine major axis */
-	if(dxL >= dyL)  { SiSSetupCMDFlag(T_XISMAJORL) }
-	if(dxR >= dyR)  { SiSSetupCMDFlag(T_XISMAJORR) }
-
-	SiSSetupCMDFlag(TRAPAZOID_FILL);
+	SiSReleaseCmdQue(pSiS);
 
-#ifdef SISVRAMQ
-	SiSSetupYHLR(y, h, left, right)
-	SiSSetupdLdR(dxL, dyL, dxR, dyR)
-	SiSSetupELER(eL, eR)
-	SiSSetupDSTBaseDoCMD(dstbase)
-#else
-	SiSSetupYH(y, h)
-	SiSSetupLR(left, right)
-	SiSSetupdL(dxL, dyL)
-	SiSSetupdR(dxR, dyR)
-	SiSSetupEL(eL)
-	SiSSetupER(eR)
-	SiSDoCMD
-#endif
 }
-#endif
-
-/* Color 8x8 pattern */
 
 #ifdef SISVRAMQ
 static void
@@ -855,14 +787,21 @@ SiSSetupForColor8x8PatternFill(ScrnInfoPtr pScrn, int patternx, int patterny,
 			int rop, unsigned int planemask, int trans_col)
 {
 	SISPtr pSiS = SISPTR(pScrn);
-	int j = pScrn->bitsPerPixel >> 3;
+	int j = pSiS->CurrentLayout.bytesPerPixel;
 	CARD32 *patadr = (CARD32 *)(pSiS->FbBase + (patterny * pSiS->scrnOffset) +
 				(patternx * j));
 
+
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling ForColor8x8PatternFill\n");
+#endif
+
+	SiSOccpyCmdQue(pSiS);
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	SiSCheckQueue(16 * 3);
 
-	SiSSetupDSTRectBurstHeader(pSiS->scrnOffset, DEV_HEIGHT, PATTERN_REG, (pScrn->bitsPerPixel << 1))
+	SiSSetupDSTRectBurstHeader(pSiS->scrnOffset, DEV_HEIGHT,
+			PATTERN_REG, (pSiS->CurrentLayout.bitsPerPixel << 1))
 
 	while(j--) {
 	   SiSSetupPatternRegBurst(patadr[0],  patadr[1],  patadr[2],  patadr[3]);
@@ -877,6 +816,8 @@ SiSSetupForColor8x8PatternFill(ScrnInfoPtr pScrn, int patternx, int patterny,
 	SiSSetupCMDFlag(PATPATREG)
 
 	SiSSyncWP
+
+	SiSReleaseCmdQue(pSiS);
 }
 
 static void
@@ -886,432 +827,28 @@ SiSSubsequentColor8x8PatternFillRect(ScrnInfoPtr pScrn, int patternx,
 	SISPtr pSiS = SISPTR(pScrn);
 	CARD32 dstbase = 0;
 
-	if(y >= 2048) {
-	   dstbase = pSiS->scrnOffset * y;
-	   y = 0;
-	}
-
-	dstbase += FBOFFSET;
-
-	/* SiSSetupCMDFlag(BITBLT)  - BITBLT = 0 */
-
-	SiSCheckQueue(16 * 2)
-	SiSSetupDSTXYRect(x, y, w, h)
-	SiSSetupDSTBaseDoCMD(dstbase)
-}
-#endif
-
-/* ---- CPUToScreen Color Expand --- */
-
-#ifdef CTSCE
-
-#ifdef CTSCE_DIRECT
-
-/* Direct method */
-
-/* This is somewhat a fake. We let XAA copy its data not to an
- * aperture, but to video RAM, and then do a ScreenToScreen
- * color expansion.
- * Since the data is sent AFTER the call to Subsequent, we
- * don't execute the command here, but set a flag and do
- * that in the (subsequent) call to Sync()
- */
-
-static void
-SiSSetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
-			int fg, int bg, int rop, unsigned int planemask)
-{
-	SISPtr pSiS=SISPTR(pScrn);
-
-#ifdef SISVRAMQ
-	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
-	SiSSetupROP(SiSGetCopyROP(rop));
-	SiSSetupSRCFGDSTRect(fg, pSiS->scrnOffset, DEV_HEIGHT)
-	if(bg == -1) {
-	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | SRCVIDEO);
-	} else {
-	   SiSSetupSRCBG(bg);
-	   SiSSetupCMDFlag(ENCOLOREXP | SRCVIDEO);
-	}
-	SiSSyncWP
-#else
-	SiSSetupSRCXY(0,0);
-	SiSSetupROP(SiSGetCopyROP(rop));
-	SiSSetupSRCFG(fg);
-	SiSSetupDSTRect(pSiS->scrnOffset, DEV_HEIGHT);
-	SiSSetupDSTColorDepth(pSiS->DstColor);
-	if(bg == -1) {
-	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | SRCVIDEO
-				       | pSiS->SiS310_AccelDepth);
-	} else {
-	   SiSSetupSRCBG(bg);
-	   SiSSetupCMDFlag(ENCOLOREXP | SRCVIDEO | pSiS->SiS310_AccelDepth);
-	}
-#endif
-}
-
-static void
-SiSSubsequentCPUToScreenColorExpandFill(
-			ScrnInfoPtr pScrn, int x, int y, int w,
-			int h, int skipleft)
-{
-	SISPtr pSiS = SISPTR(pScrn);
-	int _x0, _y0, _x1, _y1;
-	CARD32 srcbase, dstbase;
-
-	srcbase = pSiS->ColorExpandBase;
-
-	dstbase = 0;
-	if(y >= 2048) {
-	   dstbase = pSiS->scrnOffset*y;
-	   y = 0;
-	}
-
-	srcbase += FBOFFSET;
-	dstbase += FBOFFSET;
-
-#ifdef SISVRAMQ
-	SiSSetupSRCDSTBase(srcbase,dstbase);
-#else
-	SiSSetupSRCBase(srcbase);
-	SiSSetupDSTBase(dstbase)
-#endif
-
-	if(skipleft > 0) {
-	   _x0 = x + skipleft;
-	   _y0 = y;
-	   _x1 = x + w;
-	   _y1 = y + h;
-#ifdef SISVRAMQ
-	   SiSSetupClip(_x0, _y0, _x1, _y1);
-#else
-	   SiSSetupClipLT(_x0, _y0);
-	   SiSSetupClipRB(_x1, _y1);
-#endif
-	   SiSSetupCMDFlag(CLIPENABLE);
-	} else {
-	   pSiS->CommandReg &= (~CLIPENABLE);
-	}
-
-#ifdef SISVRAMQ
-	SiSSetupRectSRCPitch(w, h, ((((w + 7) >> 3) + 3) >> 2) << 2);
-	SiSSetupSRCDSTXY(0, 0, x, y);
-#else
-	SiSSetupRect(w, h);
-	SiSSetupSRCPitch(((((w+7)/8)+3) >> 2) * 4);
-	SiSSetupDSTXY(x, y);
-#endif
-
-	if(pSiS->ColorExpandBusy) {
-	   pSiS->ColorExpandBusy = FALSE;
-	   SiSIdle
-	}
-
-	pSiS->DoColorExpand = TRUE;
-}
-
-#else
-
-/* Indirect method */
-
-/* This is SLOW, slower than the CPU on most chipsets */
-/* Does not work in VRAM queue mode. */
-
-static void
-SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
-			int fg, int bg, int rop, unsigned int planemask)
-{
-	SISPtr pSiS=SISPTR(pScrn);
-
-#ifdef SISVRAMQ
-        SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
-#endif
-
-	/* !!! DOES NOT WORK IN VRAM QUEUE MODE !!! */
-
-	/* (hence this is not optimized for VRAM mode) */
-#ifndef SISVRAMQ
-	SiSIdle
-#endif
-	SiSSetupSRCXY(0,0);
-
-	SiSSetupROP(SiSGetCopyROP(rop));
-	SiSSetupSRCFG(fg);
-	SiSSetupDSTRect(pSiS->scrnOffset, DEV_HEIGHT);
-#ifndef SISVRAMQ
-	SiSSetupDSTColorDepth(pSiS->DstColor);
-#endif
-	if(bg == -1) {
-#ifdef SISVRAMQ
-	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | SRCVIDEO);
-#else
-	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | SRCCPUBLITBUF
-				       | pSiS->SiS310_AccelDepth);
-#endif
-	} else {
-	   SiSSetupSRCBG(bg);
-#ifdef SISVRAMQ
-	   SiSSetupCMDFlag(ENCOLOREXP | SRCCPUBLITBUF);
-#else
-	   SiSSetupCMDFlag(ENCOLOREXP | SRCCPUBLITBUF | pSiS->SiS310_AccelDepth);
-#endif
-	};
-
-}
-
-static void
-SiSSubsequentScanlineCPUToScreenColorExpandFill(
-			ScrnInfoPtr pScrn, int x, int y, int w,
-			int h, int skipleft)
-{
-	SISPtr pSiS = SISPTR(pScrn);
-	int _x0, _y0, _x1, _y1;
-	CARD32 dstbase = 0;
-
-	if(y >= 2048) {
-	   dstbase = pSiS->scrnOffset*y;
-	   y = 0;
-	}
-
-	dstbase += FBOFFSET;
-
-#ifndef SISVRAMQ
-        if((SIS_MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000) {
-	   SiSIdle;
-        }
-#endif
-
-	SiSSetupDSTBase(dstbase)
-
-	if(skipleft > 0) {
-	   _x0 = x+skipleft;
-	   _y0 = y;
-	   _x1 = x+w;
-	   _y1 = y+h;
-#ifdef SISVRAMQ
-           SiSSetupClip(_x0, _y0, _x1, _y1);
-#else
-	   SiSSetupClipLT(_x0, _y0);
-	   SiSSetupClipRB(_x1, _y1);
-#endif
-	   SiSSetupCMDFlag(CLIPENABLE);
-	} else {
-	   pSiS->CommandReg &= (~CLIPENABLE);
-	}
-	SiSSetupRect(w, 1);
-	SiSSetupSRCPitch(((((w+7)/8)+3) >> 2) * 4);
-	pSiS->ycurrent = y;
-	pSiS->xcurrent = x;
-
-}
-
-static void
-SiSSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
-{
-	SISPtr pSiS = SISPTR(pScrn);
-	CARD32 cbo;
-
-	cbo = pSiS->ColorExpandBufferScreenOffset[bufno];
-	cbo += FBOFFSET;
-
-#ifndef SISVRAMQ
-	if((SIS_MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000) {
-	   SiSIdle;
-        }
-#endif
-
-	SiSSetupSRCBase(cbo);
-
-	SiSSetupDSTXY(pSiS->xcurrent, pSiS->ycurrent);
-
-	SiSDoCMD
-
-	pSiS->ycurrent++;
-#ifndef SISVRAMQ
-	SiSIdle
-#endif
-}
-#endif
-#endif
-
-/* --- Screen To Screen Color Expand --- */
-
-/* This method blits in a single task; this does not work because
- * the hardware does not use the source pitch as scanline offset
- * but to calculate pattern address from source X and Y and to
- * limit the drawing width (similar to width set by SetupRect).
- * XAA provides the pattern bitmap with scrnOffset (displayWidth * bpp/8)
- * offset, but this is not supported by the hardware.
- * DOES NOT WORK ON 330 SERIES, HANGS ENGINE.
- */
-
-#ifdef STSCE
-static void
-SiSSetupForScreenToScreenColorExpand(ScrnInfoPtr pScrn,
-			int fg, int bg,
-			int rop, unsigned int planemask)
-{
-	SISPtr          pSiS = SISPTR(pScrn);
-
-#ifdef SISVRAMQ
-        SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
-#else
-	SiSSetupDSTColorDepth(pSiS->DstColor)
-#endif
-	SiSSetupDSTRect(pSiS->scrnOffset, DEV_HEIGHT)
-	SiSSetupROP(SiSGetCopyROP(rop))
-	SiSSetupSRCFG(fg)
-	/* SiSSetupSRCXY(0,0) */
-
-	if(bg == -1) {
-	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | SRCVIDEO);
-	} else {
-	   SiSSetupSRCBG(bg);
-	   SiSSetupCMDFlag(ENCOLOREXP | SRCVIDEO);
-	};
-
-#ifdef SISVRAMQ
-        SiSSyncWP
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SubsequentColor8x8PatternFillRect\n");
 #endif
-}
-
-/* For testing, these are the methods: (use only one at a time!) */
-
-#undef npitch 		/* Normal: Use srcx/y as srcx/y, use scrnOffset as source pitch
-			 * Does not work on 315 series, because the hardware does not
-			 * regard the src x and y. Apart from this problem:
-			 * This would work if the hareware used the source pitch for
-			 * incrementing the source address after each scanline - but
-			 * it doesn't do this! The first line of the area is correctly
-			 * color expanded, but since the source pitch is ignored and
-			 * the source address not incremented correctly, the following
-			 * lines are color expanded with any bit pattern that is left
-			 * in the unused space of the source bitmap (which is organized
-			 * with the depth of the screen framebuffer hence with a pitch
-			 * of scrnOffset).
-			 */
-
-#undef pitchdw    	/* Use source pitch "displayWidth / 8" instead
-			 * of scrnOffset (=displayWidth * bpp / 8)
-			 * This can't work, because the pitch of the source
-			 * bitmap is scrnoffset!
-			 */
-
-#define nopitch 	/* Calculate srcbase with srcx and srcy, set the
-			 * pitch to scrnOffset (which IS the correct pitch
-			 * for the source bitmap) and set srcx and srcy both
-			 * to 0.
-			 * This would work if the hareware used the source pitch for
-			 * incrementing the source address after each scanline - but
-			 * it doesn't do this! Again: The first line of the area is
-			 * correctly color expanded, but since the source pitch is
-			 * ignored for scanline address incremention, the following
-			 * lines are not correctly color expanded.
-			 * This is the only way it works (apart from the problem
-			 * described above). The hardware does not regard the src
-			 * x and y values in any way.
-			 */
 
-static void
-SiSSubsequentScreenToScreenColorExpand(ScrnInfoPtr pScrn,
-			int x, int y, int w, int h,
-			int srcx, int srcy, int skipleft)
-{
-	SISPtr pSiS = SISPTR(pScrn);
-        CARD32 srcbase, dstbase;
-#if 0
-	int _x0, _y0, _x1, _y1;
-#endif
-#ifdef pitchdw
-	int newsrcx, newsrcy;
 
-	/* srcx and srcy are provided based on a scrnOffset pitch ( = displayWidth * bpp / 8 )
-	 * We recalulate srcx and srcy based on pitch = displayWidth / 8
-	 */
-        newsrcy = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) /
-					  (pScrn->displayWidth/8);
-        newsrcx = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) %
-					  (pScrn->displayWidth/8);
-#endif
-	xf86DrvMsg(0, X_INFO, "Sub ScreenToScreen ColorExp(%d,%d, %d,%d, %d,%d, %d)\n",
-					x, y, w, h, srcx, srcy, skipleft);
 
-	srcbase = dstbase = 0;
-
-#ifdef pitchdw
-	if(newsrcy >= 2048) {
-	   srcbase = (pScrn->displayWidth / 8) * newsrcy;
-	   newsrcy = 0;
-	}
-#endif
-#ifdef nopitch
-	srcbase = (pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8));
-#endif
-#ifdef npitch
-	if(srcy >= 2048) {
-	   srcbase = pSiS->scrnOffset * srcy;
-	   srcy = 0;
-	}
-#endif
 	if(y >= 2048) {
 	   dstbase = pSiS->scrnOffset * y;
 	   y = 0;
 	}
 
-	srcbase += FBOFFSET;
 	dstbase += FBOFFSET;
 
-	SiSSetupSRCBase(srcbase)
-	SiSSetupDSTBase(dstbase)
-
-	/* 315 series seem to treat the src pitch as
-	 * a "drawing limit", but still (as 300 series)
-	 * does not use it for incrementing the
-	 * address pointer for the next scanline. ARGH!
-	 */
-
-#ifdef pitchdw
-	SiSSetupSRCPitch(pScrn->displayWidth/8)
-#endif
-#ifdef nopitch
-	SiSSetupSRCPitch(pScrn->displayWidth/8)
-	/* SiSSetupSRCPitch(1024/8) */ /* For test */
-#endif
-#ifdef npitch
-	SiSSetupSRCPitch(pScrn->displayWidth/8)
-	/* SiSSetupSRCPitch(pSiS->scrnOffset) */
-#endif
-
-	SiSSetupRect(w,h)
+	/* SiSSetupCMDFlag(BITBLT)  - BITBLT = 0 */
 
-#if 0   /* How do I implement the offset? Not this way, that's for sure.. */
-	if (skipleft > 0) {
-		_x0 = x+skipleft;
-		_y0 = y;
-		_x1 = x+w;
-		_y1 = y+h;
-		SiSSetupClipLT(_x0, _y0);
-		SiSSetupClipRB(_x1, _y1);
-		SiSSetupCMDFlag(CLIPENABLE);
-	}
-#endif
-#ifdef pitchdw
-	SiSSetupSRCXY(newsrcx, newsrcy)
-#endif
-#ifdef nopitch
-	SiSSetupSRCXY(0,0)
-#endif
-#ifdef npitch
-	SiSSetupSRCXY(srcx, srcy)
-#endif
+	SiSOccpyCmdQue(pSiS);
 
-	SiSSetupDSTXY(x,y)
+	SiSCheckQueue(16 * 2)
+	SiSSetupDSTXYRect(x, y, w, h)
+	SiSSetupDSTBaseDoCMD(dstbase)
 
-	SiSDoCMD
-#ifdef SISVRAMQ
-	/* We MUST sync here, there must not be 2 or more color expansion commands in the queue */
-	SiSIdle
-#endif
+	SiSReleaseCmdQue(pSiS);
 }
 #endif
 
@@ -1329,13 +866,16 @@ SiSRestoreAccelState(ScrnInfoPtr pScrn)
 
 /* ---- RENDER ---- */
 
-#ifdef INCL_RENDER
-#ifdef RENDER
+#if defined(RENDER) && defined(INCL_RENDER)
 static void
 SiSRenderCallback(ScrnInfoPtr pScrn)
 {
 	SISPtr pSiS = SISPTR(pScrn);
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SiSRenderCallback\n");
+#endif
+
 	if((currentTime.milliseconds > pSiS->RenderTime) && pSiS->AccelLinearScratch) {
 	   xf86FreeOffscreenLinear(pSiS->AccelLinearScratch);
 	   pSiS->AccelLinearScratch = NULL;
@@ -1348,7 +888,9 @@ SiSRenderCallback(ScrnInfoPtr pScrn)
 
 #define RENDER_DELAY 15000
 
-static Bool
+
+/* for extern referred, we remove the  type "static"*/
+Bool
 SiSAllocateLinear(ScrnInfoPtr pScrn, int sizeNeeded)
 {
 	SISPtr pSiS = SISPTR(pScrn);
@@ -1356,6 +898,10 @@ SiSAllocateLinear(ScrnInfoPtr pScrn, int sizeNeeded)
 	pSiS->RenderTime = currentTime.milliseconds + RENDER_DELAY;
 	pSiS->RenderCallback = SiSRenderCallback;
 
+#ifdef ACCELDEBUG
+	xf86DrvMsg(0, X_INFO, " XAA calling SiSAllocateLinear\n");
+#endif
+
 	if(pSiS->AccelLinearScratch) {
 	   if(pSiS->AccelLinearScratch->size >= sizeNeeded) {
 	      return TRUE;
@@ -1396,7 +942,7 @@ SiSSetupForCPUToScreenAlphaTexture(ScrnInfoPtr pScrn,
 	unsigned char *renderaccelarray;
 	CARD32 *dstPtr;
 	int    x, pitch, sizeNeeded;
-	int    sbpp = pSiS->CurrentLayout.bitsPerPixel >> 3;
+	int    sbpp = pSiS->CurrentLayout.bytesPerPixel;
 	int    sbppshift = sbpp >> 1;	/* 8->0, 16->1, 32->2 */
 	CARD8  myalpha;
 	Bool   docopy = TRUE;
@@ -1433,6 +979,8 @@ SiSSetupForCPUToScreenAlphaTexture(ScrnInfoPtr pScrn,
 	green &= 0xff00;
 	blue &= 0xff00;
 
+	SiSOccpyCmdQue(pSiS);
+
 #ifdef SISVRAMQ
 	SiSSetupDSTColorDepth(pSiS->SiS310_AccelDepth);
 	switch(op) {
@@ -1478,6 +1026,7 @@ SiSSetupForCPUToScreenAlphaTexture(ScrnInfoPtr pScrn,
 	SiSSetupROP(0)
 	SiSSetupCMDFlag(ALPHA_BLEND | SRCVIDEO | A_PERPIXELALPHA | pSiS->SiS310_AccelDepth)
 #endif
+	SiSReleaseCmdQue(pSiS);
 
 	/* Don't need source for clear and dest */
 	if(!docopy) return TRUE;
@@ -1539,7 +1088,7 @@ SiSSetupForCPUToScreenTexture(ScrnInfoPtr pScrn,
 	SISPtr  pSiS = SISPTR(pScrn);
 	CARD8   *dst;
 	int     pitch, sizeNeeded;
-	int     sbpp = pSiS->CurrentLayout.bitsPerPixel >> 3;
+	int     sbpp = pSiS->CurrentLayout.bytesPerPixel;
 	int     sbppshift = sbpp >> 1;	          	  /* 8->0, 16->1, 32->2 */
 	int     bppshift = PICT_FORMAT_BPP(texType) >> 4; /* 8->0, 16->1, 32->2 */
 	Bool    docopy = TRUE;
@@ -1549,6 +1098,7 @@ SiSSetupForCPUToScreenTexture(ScrnInfoPtr pScrn,
 		texType, op, width, height, texPitch);
 #endif
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	if(op > SiSRenderOpsMAX) return FALSE;
 	if(!SiSRenderOps[op])    return FALSE;
@@ -1620,7 +1170,7 @@ SiSSetupForCPUToScreenTexture(ScrnInfoPtr pScrn,
 	SiSSetupAlpha(0x00)
 	SiSSetupCMDFlag(ALPHA_BLEND | SRCVIDEO | A_PERPIXELALPHA | pSiS->SiS310_AccelDepth)
 #endif
-
+	SiSReleaseCmdQue(pSiS);
 	/* Don't need source for clear and dest */
 	if(!docopy) return TRUE;
 
@@ -1666,8 +1216,11 @@ SiSSubsequentCPUToScreenTexture(ScrnInfoPtr pScrn,
 	srcbase += FBOFFSET;
 	dstbase += FBOFFSET;
 
+	SiSOccpyCmdQue(pSiS);
 #ifdef SISVRAMQ
 	SiSCheckQueue(16 * 3)
+	if(pSiS->ChipType == SIS_770)	
+		SiSSetupSafeReg(0x26a90000)
 	SiSSetupSRCDSTBase(srcbase,dstbase);
 	SiSSetupSRCDSTXY(src_x, src_y, dst_x, dst_y)
 	SiSSetRectDoCMD(width,height)
@@ -1679,10 +1232,11 @@ SiSSubsequentCPUToScreenTexture(ScrnInfoPtr pScrn,
 	SiSSetupDSTXY(dst_x, dst_y)
 	SiSDoCMD
 #endif
+	SiSReleaseCmdQue(pSiS);
+
 	pSiS->alphaBlitBusy = TRUE;
 }
-#endif
-#endif
+#endif  /* RENDER && INCL_RENDER */
 
 #endif /* XAA */
 
@@ -1701,6 +1255,7 @@ SiSPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planemask, Pixel fg)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
 	SISPtr pSiS = SISPTR(pScrn);
+	CARD16 pitch;
 
 	/* Planemask not supported */
 	if((planemask & ((1 << pPixmap->drawable.depth) - 1)) !=
@@ -1713,21 +1268,24 @@ SiSPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planemask, Pixel fg)
 	   (pPixmap->drawable.bitsPerPixel != 32))
 	   return FALSE;
 
-	if(pSiS->disablecolorkeycurrent) {
-	   if((CARD32)fg == pSiS->colorKey) {
-	      alu = 5;  /* NOOP */
-	   }
-	}
-
 	/* Check that the pitch matches the hardware's requirements. Should
 	 * never be a problem due to pixmapPitchAlign and fbScreenInit.
 	 */
-	if(exaGetPixmapPitch(pPixmap) & 3)
+	if(((pitch = exaGetPixmapPitch(pPixmap)) & 3))
 	   return FALSE;
 
+	if(pSiS->disablecolorkeycurrent || pSiS->nocolorkey) {
+	   if((CARD32)fg == pSiS->colorKey) {
+	      /* NOOP - does not work: Pixmap is not neccessarily in the frontbuffer */
+	      /* alu = 5; */
+	      /* Fill it black; better than blue anyway */
+	      fg = 0;
+	   }
+	}
+
 	SiSSetupDSTColorDepth((pPixmap->drawable.bitsPerPixel >> 4) << 16);
 	SiSCheckQueue(16 * 1);
-	SiSSetupPATFGDSTRect(fg, exaGetPixmapPitch(pPixmap), DEV_HEIGHT)
+	SiSSetupPATFGDSTRect(fg, pitch, DEV_HEIGHT)
 	SiSSetupROP(SiSGetPatternROP(alu))
 	SiSSetupCMDFlag(PATFG)
 	SiSSyncWP
@@ -1762,6 +1320,7 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 	ScrnInfoPtr pScrn = xf86Screens[pDstPixmap->drawable.pScreen->myNum];
 	SISPtr pSiS = SISPTR(pScrn);
 	CARD32 srcbase, dstbase;
+	CARD16 srcpitch, dstpitch;
 
 	/* Planemask not supported */
 	if((planemask & ((1 << pSrcPixmap->drawable.depth) - 1)) !=
@@ -1777,9 +1336,9 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 	/* Check that the pitch matches the hardware's requirements. Should
 	 * never be a problem due to pixmapPitchAlign and fbScreenInit.
 	 */
-	if(exaGetPixmapPitch(pSrcPixmap) & 3)
+	if((srcpitch = exaGetPixmapPitch(pSrcPixmap)) & 3)
 	   return FALSE;
-	if(exaGetPixmapPitch(pDstPixmap) & 3)
+	if((dstpitch = exaGetPixmapPitch(pDstPixmap)) & 3)
 	   return FALSE;
 
 	srcbase = (CARD32)exaGetPixmapOffset(pSrcPixmap) + FBOFFSET;
@@ -1795,8 +1354,7 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 
 	SiSSetupDSTColorDepth((pDstPixmap->drawable.bitsPerPixel >> 4) << 16);
 	SiSCheckQueue(16 * 3);
-	SiSSetupSRCPitchDSTRect(exaGetPixmapPitch(pSrcPixmap),
-					exaGetPixmapPitch(pDstPixmap), DEV_HEIGHT)
+	SiSSetupSRCPitchDSTRect(srcpitch, dstpitch, DEV_HEIGHT)
 	SiSSetupROP(SiSGetCopyROP(alu))
 	SiSSetupSRCDSTBase(srcbase, dstbase)
 	SiSSyncWP
@@ -1906,28 +1464,61 @@ SiSUploadToScratch(PixmapPtr pSrc, PixmapPtr pDst)
 
 	w = pSrc->drawable.width;
 
+#if  XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(6,8,2,0,0)
+	dst_pitch = ((w * (pSrc->drawable.bitsPerPixel >> 3)) +
+		     pSiS->EXADriverPtr->card.offscreenPitch - 1) &
+		    ~(pSiS->EXADriverPtr->card.offscreenPitch - 1);
+#elif XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+	dst_pitch = ((w * (pSrc->drawable.bitsPerPixel >> 3)) +
+		     pSiS->EXADriverPtr->card.pixmapPitchAlign - 1) &
+		    ~(pSiS->EXADriverPtr->card.pixmapPitchAlign - 1);
+#else
 	dst_pitch = ((w * (pSrc->drawable.bitsPerPixel >> 3)) +
 		     pSiS->EXADriverPtr->pixmapPitchAlign - 1) &
 		    ~(pSiS->EXADriverPtr->pixmapPitchAlign - 1);
 
+#endif
 	size = dst_pitch * pSrc->drawable.height;
 
 	if(size > pSiS->exa_scratch->size)
 	   return FALSE;
 
+#if  XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(6,8,2,0,0)
+	pSiS->exa_scratch_next = (pSiS->exa_scratch_next +
+				  pSiS->EXADriverPtr->card.offscreenByteAlign - 1) &
+				  ~(pSiS->EXADriverPtr->card.offscreenByteAlign - 1);
+#elif  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+	pSiS->exa_scratch_next = (pSiS->exa_scratch_next +
+				  pSiS->EXADriverPtr->card.pixmapOffsetAlign - 1) &
+				  ~(pSiS->EXADriverPtr->card.pixmapOffsetAlign - 1);
+#else
 	pSiS->exa_scratch_next = (pSiS->exa_scratch_next +
 				  pSiS->EXADriverPtr->pixmapOffsetAlign - 1) &
 				  ~(pSiS->EXADriverPtr->pixmapOffsetAlign - 1);
+#endif
 
+#if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+	if(pSiS->exa_scratch_next + size >
+	   pSiS->exa_scratch->offset + pSiS->exa_scratch->size) {
+	   (pSiS->EXADriverPtr->accel.WaitMarker)(pSrc->drawable.pScreen, 0);
+	   pSiS->exa_scratch_next = pSiS->exa_scratch->offset;
+	}
+#else
 	if(pSiS->exa_scratch_next + size >
 	   pSiS->exa_scratch->offset + pSiS->exa_scratch->size) {
 	   (pSiS->EXADriverPtr->WaitMarker)(pSrc->drawable.pScreen, 0);
 	   pSiS->exa_scratch_next = pSiS->exa_scratch->offset;
 	}
+#endif
 
 	memcpy(pDst, pSrc, sizeof(*pDst));
 	pDst->devKind = dst_pitch;
+
+#if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+	pDst->devPrivate.ptr = pSiS->EXADriverPtr->card.memoryBase + pSiS->exa_scratch_next;
+#else
 	pDst->devPrivate.ptr = pSiS->EXADriverPtr->memoryBase + pSiS->exa_scratch_next;
+#endif
 
 	pSiS->exa_scratch_next += size;
 
@@ -1975,9 +1566,8 @@ SiSDownloadFromScreen(PixmapPtr pSrc, int x, int y, int w, int h, char *dst, int
 }
 #endif /* EXA */
 
-/* Helper for xv video blitter */
+/* Helper for xv video blitter and rotation */
 
-#ifdef INCL_YUV_BLIT_ADAPTOR
 void
 SISWriteBlitPacket(SISPtr pSiS, CARD32 *packet)
 {
@@ -1991,7 +1581,7 @@ SISWriteBlitPacket(SISPtr pSiS, CARD32 *packet)
 	SiSSyncWP;
 	(void)dummybuf; /* Suppress compiler warning */
 }
-#endif
+
 
 /* For DGA usage */
 
@@ -2021,12 +1611,6 @@ SiS315AccelInit(ScreenPtr pScreen)
 	XAAInfoRecPtr   infoPtr = NULL;
 	int		topFB, reservedFbSize, usableFbSize;
 	BoxRec          Avail;
-#ifdef CTSCE
-	unsigned char   *AvailBufBase;
-#ifndef CTSCE_DIRECT
-	int             i;
-#endif
-#endif
 #endif /* XAA */
 
 	pSiS->ColorExpandBufferNumber = 0;
@@ -2055,7 +1639,7 @@ SiS315AccelInit(ScreenPtr pScreen)
 #endif
 #ifdef SIS_USE_EXA
 	   if(pSiS->useEXA) {
-	      if(!(pSiS->EXADriverPtr = exaDriverAlloc())) {
+	      if(!(pSiS->EXADriverPtr = xnfcalloc(sizeof(ExaDriverRec), 1))) {
 		 pSiS->NoAccel = TRUE;
 		 pSiS->NoXvideo = TRUE; /* No fbmem manager -> no xv */
 	      }
@@ -2072,6 +1656,7 @@ SiS315AccelInit(ScreenPtr pScreen)
 	   pSiS->FillRect  = SiSDGAFillRect;
 	   pSiS->BlitRect  = SiSDGABlitRect;
 
+
 #ifdef SIS_USE_XAA	/* ----------------------- XAA ----------------------- */
 	   if(!pSiS->useEXA) {
 
@@ -2090,15 +1675,6 @@ SiS315AccelInit(ScreenPtr pScreen)
 	      /* solid fills */
 	      infoPtr->SetupForSolidFill = SiSSetupForSolidFill;
 	      infoPtr->SubsequentSolidFillRect = SiSSubsequentSolidFillRect;
-#ifdef TRAP
-	      if((pSiS->Chipset != PCI_CHIP_SIS660) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS330) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS340) &&
-		 (pSiS->Chipset != PCI_CHIP_XGIXG20) &&
-		 (pSiS->Chipset != PCI_CHIP_XGIXG40)) {
-	         infoPtr->SubsequentSolidFillTrap = SiSSubsequentSolidFillTrap;
-	      }
-#endif
 	      infoPtr->SolidFillFlags = NO_PLANEMASK;
 
 	      /* solid line */
@@ -2117,20 +1693,13 @@ SiS315AccelInit(ScreenPtr pScreen)
 	      /* 8x8 mono pattern fill */
 	      infoPtr->SetupForMono8x8PatternFill = SiSSetupForMonoPatternFill;
 	      infoPtr->SubsequentMono8x8PatternFillRect = SiSSubsequentMonoPatternFill;
-#ifdef TRAP
-              if((pSiS->Chipset != PCI_CHIP_SIS660) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS330) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS340) &&
-		 (pSiS->Chipset != PCI_CHIP_XGIXG20) &&
-		 (pSiS->Chipset != PCI_CHIP_XGIXG40)) {
-	         infoPtr->SubsequentMono8x8PatternFillTrap = SiSSubsequentMonoPatternFillTrap;
-	      }
-#endif
 	      infoPtr->Mono8x8PatternFillFlags = NO_PLANEMASK |
 						 HARDWARE_PATTERN_SCREEN_ORIGIN |
 						 HARDWARE_PATTERN_PROGRAMMED_BITS |
 						 BIT_ORDER_IN_BYTE_MSBFIRST;
 
+
+
 #ifdef SISVRAMQ
 	      /* 8x8 color pattern fill (MMIO support not implemented) */
 	      infoPtr->SetupForColor8x8PatternFill = SiSSetupForColor8x8PatternFill;
@@ -2140,116 +1709,48 @@ SiS315AccelInit(ScreenPtr pScreen)
 						  NO_TRANSPARENCY;
 #endif
 
-#ifdef STSCE
-	      /* Screen To Screen Color Expand */
-	      /* The hardware does not support this the way we need it, because
-	       * the mono-bitmap is not provided with a pitch of (width), but
-	       * with a pitch of scrnOffset (= width * bpp / 8).
-	       */
-	      infoPtr->SetupForScreenToScreenColorExpandFill =
-				SiSSetupForScreenToScreenColorExpand;
-	      infoPtr->SubsequentScreenToScreenColorExpandFill =
-				SiSSubsequentScreenToScreenColorExpand;
-	      infoPtr->ScreenToScreenColorExpandFillFlags = NO_PLANEMASK |
-							    BIT_ORDER_IN_BYTE_MSBFIRST ;
-#endif
-
-#ifdef CTSCE
-#ifdef CTSCE_DIRECT
-	      /* CPU color expansion - direct method
-	       *
-	       * We somewhat fake this function here in the following way:
-	       * XAA copies its mono-bitmap data not into an aperture, but
-	       * into our video RAM buffer. We then do a ScreenToScreen
-	       * color expand.
-	       * Unfortunately, XAA sends the data to the aperture AFTER
-	       * the call to Subsequent(), therefore we do not execute the
-	       * command in Subsequent, but in the following call to Sync().
-	       * (Hence, the SYNC_AFTER_COLOR_EXPAND flag MUST BE SET)
-	       *
-	       * This is slower than doing it by the CPU.
-	       */
-
-	       pSiS->ColorExpandBufferNumber = 48;
-	       pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;
-	       infoPtr->SetupForCPUToScreenColorExpandFill = SiSSetupForCPUToScreenColorExpandFill;
-	       infoPtr->SubsequentCPUToScreenColorExpandFill = SiSSubsequentCPUToScreenColorExpandFill;
-	       infoPtr->ColorExpandRange = pSiS->ColorExpandBufferNumber * pSiS->PerColorExpandBufferSize;
-	       infoPtr->CPUToScreenColorExpandFillFlags =
-			NO_PLANEMASK |
-			CPU_TRANSFER_PAD_DWORD |
-			SCANLINE_PAD_DWORD |
-			BIT_ORDER_IN_BYTE_MSBFIRST |
-			LEFT_EDGE_CLIPPING |
-			SYNC_AFTER_COLOR_EXPAND;
-#else
-              /* CPU color expansion - per-scanline / indirect method
-	       *
-	       * SLOW! SLOWER! SLOWEST!
-	       *
-	       * Does not work on 330 series, hangs the engine (both VRAM and MMIO).
-	       * Does not work in VRAM queue mode.
-	       */
-#ifndef SISVRAMQ
-	      if((pSiS->Chipset != PCI_CHIP_SIS650) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS660) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS330) &&
-	         (pSiS->Chipset != PCI_CHIP_SIS340) &&
-		 (pSiS->Chipset != PCI_CHIP_XGIXG20) &&
-		 (pSiS->Chipset != PCI_CHIP_XGIXG40)) {
-		 pSiS->ColorExpandBufferNumber = 16;
-		 pSiS->ColorExpandBufferCountMask = 0x0F;
-		 pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;
-		 infoPtr->NumScanlineColorExpandBuffers = pSiS->ColorExpandBufferNumber;
-		 infoPtr->ScanlineColorExpandBuffers = (unsigned char **)&pSiS->ColorExpandBufferAddr[0];
-		 infoPtr->SetupForScanlineCPUToScreenColorExpandFill = SiSSetupForScanlineCPUToScreenColorExpandFill;
-		 infoPtr->SubsequentScanlineCPUToScreenColorExpandFill = SiSSubsequentScanlineCPUToScreenColorExpandFill;
-		 infoPtr->SubsequentColorExpandScanline = SiSSubsequentColorExpandScanline;
-		 infoPtr->ScanlineCPUToScreenColorExpandFillFlags =
-				NO_PLANEMASK |
-				CPU_TRANSFER_PAD_DWORD |
-				SCANLINE_PAD_DWORD |
-				BIT_ORDER_IN_BYTE_MSBFIRST |
-				LEFT_EDGE_CLIPPING;
-	      }
-#endif
-#endif
-#endif
 
-#ifdef INCL_RENDER
-#ifdef RENDER
+#if defined(RENDER) && defined(INCL_RENDER)
 	      /* Render */
 	      SiSCalcRenderAccelArray(pScrn);
-
 	      if(pSiS->RenderAccelArray) {
 	         pSiS->AccelLinearScratch = NULL;
 
+/* for sis671, we have not supported the render expansion */
 #ifdef SISNEWRENDER
-		 infoPtr->SetupForCPUToScreenAlphaTexture2 = SiSSetupForCPUToScreenAlphaTexture;
+		 infoPtr->SetupForCPUToScreenAlphaTexture2 = (pSiS->ChipType == SIS_671)? 
+		 		NULL/*SiSSetupForCPUToScreenAlphaTexture3D*/ : SiSSetupForCPUToScreenAlphaTexture;
 		 infoPtr->CPUToScreenAlphaTextureDstFormats = (pScrn->bitsPerPixel == 16) ?
 				SiSDstTextureFormats16 : SiSDstTextureFormats32;
 #else
-		 infoPtr->SetupForCPUToScreenAlphaTexture = SiSSetupForCPUToScreenAlphaTexture;
+		 infoPtr->SetupForCPUToScreenAlphaTexture = (pSiS->ChipType == SIS_671)? 
+		 		SiSSetupForCPUToScreenAlphaTexture3D : SiSSetupForCPUToScreenAlphaTexture;
+
 #endif
-		 infoPtr->SubsequentCPUToScreenAlphaTexture = SiSSubsequentCPUToScreenTexture;
-		 infoPtr->CPUToScreenAlphaTextureFormats = SiSAlphaTextureFormats;
+		 infoPtr->SubsequentCPUToScreenAlphaTexture = (pSiS->ChipType == SIS_671)? 
+		 		NULL/*SiSSubsequentCPUToScreenTexture3D*/ : SiSSubsequentCPUToScreenTexture;
+		 infoPtr->CPUToScreenAlphaTextureFormats = (pSiS->ChipType == SIS_671)? 
+				NULL/*SiS3DAlphaTextureFormats*/ : SiSAlphaTextureFormats;  /*3D accelerator needs a8r8g8b8 format*/
 		 infoPtr->CPUToScreenAlphaTextureFlags = XAA_RENDER_NO_TILE;
 
 #ifdef SISNEWRENDER
-		 infoPtr->SetupForCPUToScreenTexture2 = SiSSetupForCPUToScreenTexture;
+		 infoPtr->SetupForCPUToScreenTexture2 = (pSiS->ChipType == SIS_671)? 
+		 		NULL/*SiSSubsequentCPUToScreenTexture3D*/ : SiSSetupForCPUToScreenTexture;
 		 infoPtr->CPUToScreenTextureDstFormats = (pScrn->bitsPerPixel == 16) ?
 				SiSDstTextureFormats16 : SiSDstTextureFormats32;
 #else
-		 infoPtr->SetupForCPUToScreenTexture = SiSSetupForCPUToScreenTexture;
+		 infoPtr->SetupForCPUToScreenTexture = (pSiS->ChipType == SIS_671)? 
+		 		NULL/*SiSSubsequentCPUToScreenTexture3D*/ : SiSSetupForCPUToScreenTexture;
 #endif
-		 infoPtr->SubsequentCPUToScreenTexture = SiSSubsequentCPUToScreenTexture;
-		 infoPtr->CPUToScreenTextureFormats = SiSTextureFormats;
-		 infoPtr->CPUToScreenTextureFlags = XAA_RENDER_NO_TILE;
+		 infoPtr->SubsequentCPUToScreenTexture = (pSiS->ChipType == SIS_671)? 
+		 		NULL/*SiSSubsequentCPUToScreenTexture3D*/ : SiSSubsequentCPUToScreenTexture;
+		 infoPtr->CPUToScreenTextureFormats = (pSiS->ChipType == SIS_671)? 
+		 		NULL/*SiSSubsequentCPUToScreenTexture3D*/ : SiSTextureFormats;
+		 infoPtr->CPUToScreenTextureFlags = (pSiS->ChipType == SIS_671)? 
+		 		0/*SiSSubsequentCPUToScreenTexture3D*/ : XAA_RENDER_NO_TILE;
 
-		 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "RENDER acceleration enabled\n");
 	      }
-#endif
-#endif
+#endif /* RENDER && INCL_RENDER */
 
 #ifdef SISDUALHEAD
 	      if(pSiS->DualHeadMode) {
@@ -2261,8 +1762,69 @@ SiS315AccelInit(ScreenPtr pScreen)
 
 #ifdef SIS_USE_EXA	/* ----------------------- EXA ----------------------- */
 	   if(pSiS->useEXA) {
+#if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+
+	      int obase = 0;
+
+	      /* data */
+	      pSiS->EXADriverPtr->card.memoryBase = pSiS->FbBase;
+	      pSiS->EXADriverPtr->card.memorySize = pSiS->maxxfbmem;
+
+	      if(!obase) {
+	         obase = pScrn->displayWidth * pScrn->virtualY * (pScrn->bitsPerPixel >> 3);
+	      }
+
+	      pSiS->EXADriverPtr->card.offScreenBase = obase;
+	      if(pSiS->EXADriverPtr->card.memorySize > pSiS->EXADriverPtr->card.offScreenBase) {
+		 pSiS->EXADriverPtr->card.flags = EXA_OFFSCREEN_PIXMAPS;
+	      } else {
+		 pSiS->NoXvideo = TRUE;
+		 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			"Not enough video RAM for offscreen memory manager. Xv disabled\n");
+	      }
+
+#if  XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(6,8,2,0,0)
+	      pSiS->EXADriverPtr->card.offscreenByteAlign = 16;	/* src/dst: double quad word boundary */
+	      pSiS->EXADriverPtr->card.offscreenPitch = 4;	/* pitch:   double word boundary      */
+#else
+	      pSiS->EXADriverPtr->card.pixmapOffsetAlign = 16;	/* src/dst: double quad word boundary */
+	      pSiS->EXADriverPtr->card.pixmapPitchAlign = 4;	/* pitch:   double word boundary      */
+#endif
+	      pSiS->EXADriverPtr->card.maxX = 4095;
+	      pSiS->EXADriverPtr->card.maxY = 4095;
+
+	      /* Sync */
+	      pSiS->EXADriverPtr->accel.WaitMarker = SiSEXASync;
+
+	      /* Solid fill */
+	      pSiS->EXADriverPtr->accel.PrepareSolid = SiSPrepareSolid;
+	      pSiS->EXADriverPtr->accel.Solid = SiSSolid;
+	      pSiS->EXADriverPtr->accel.DoneSolid = SiSDoneSolid;
+
+	      /* Copy */
+	      pSiS->EXADriverPtr->accel.PrepareCopy = SiSPrepareCopy;
+	      pSiS->EXADriverPtr->accel.Copy = SiSCopy;
+	      pSiS->EXADriverPtr->accel.DoneCopy = SiSDoneCopy;
+
+	      /* Composite */
+#ifdef SIS_HAVE_COMPOSITE
+	      SiSCalcRenderAccelArray(pScrn);
+	      if(pSiS->RenderAccelArray) {
+		 pSiS->EXADriverPtr->accel.CheckComposite = SiSCheckComposite;
+		 pSiS->EXADriverPtr->accel.PrepareComposite = SiSPrepareComposite;
+		 pSiS->EXADriverPtr->accel.Composite = SiSComposite;
+		 pSiS->EXADriverPtr->accel.DoneComposite = SiSDoneComposite;
+	      }
+#endif
+
+	      /* Upload, download to/from Screen */
+	      pSiS->EXADriverPtr->accel.UploadToScreen = SiSUploadToScreen;
+	      pSiS->EXADriverPtr->accel.DownloadFromScreen = SiSDownloadFromScreen;
+
+#else /*Xorg>= 7.0*/
+
 	      pSiS->EXADriverPtr->exa_major = 2;
-	      pSiS->EXADriverPtr->exa_major = 0;
+	      pSiS->EXADriverPtr->exa_minor = 0;
 
 	      /* data */
 	      pSiS->EXADriverPtr->memoryBase = pSiS->FbBase;
@@ -2308,10 +1870,10 @@ SiS315AccelInit(ScreenPtr pScreen)
 	      /* Upload, download to/from Screen */
 	      pSiS->EXADriverPtr->UploadToScreen = SiSUploadToScreen;
 	      pSiS->EXADriverPtr->DownloadFromScreen = SiSDownloadFromScreen;
-
+#endif /*end of Xorg>=7.0*/ 
+	   
 	   }
-#endif
-
+#endif /*end of EXA accelation*/
 	}  /* NoAccel */
 
 	/* Init framebuffer memory manager */
@@ -2333,42 +1895,24 @@ SiS315AccelInit(ScreenPtr pScreen)
 
 #ifdef SIS_USE_XAA
 	if(!pSiS->useEXA) {
-
 	   topFB = pSiS->maxxfbmem; /* relative to FbBase */
 
 	   reservedFbSize = pSiS->ColorExpandBufferNumber * pSiS->PerColorExpandBufferSize;
 
-	   usableFbSize = topFB - reservedFbSize;
-
-#ifdef CTSCE
-	   AvailBufBase = pSiS->FbBase + usableFbSize;
-	   if(pSiS->ColorExpandBufferNumber) {
-#ifdef CTSCE_DIRECT
-	      infoPtr->ColorExpandBase = (unsigned char *)AvailBufBase;
-	      pSiS->ColorExpandBase = usableFbSize;
-#else
-	      for(i = 0; i < pSiS->ColorExpandBufferNumber; i++) {
-		 pSiS->ColorExpandBufferAddr[i] = AvailBufBase +
-		       i * pSiS->PerColorExpandBufferSize;
-		 pSiS->ColorExpandBufferScreenOffset[i] = usableFbSize +
-		       i * pSiS->PerColorExpandBufferSize;
-	      }
-#endif
-	   }
-#endif
 
+	   usableFbSize = topFB - reservedFbSize;
 	   Avail.x1 = 0;
 	   Avail.y1 = 0;
 	   Avail.x2 = pScrn->displayWidth;
-	   Avail.y2 = (usableFbSize / (pScrn->displayWidth * pScrn->bitsPerPixel/8)) - 1;
+	   Avail.y2 = (usableFbSize / (pScrn->displayWidth * pScrn->bitsPerPixel / 8)) - 1;
 
-	   if(Avail.y2 < 0) Avail.y2 = 32767;
 
+	   if(Avail.y2 < 0) Avail.y2 = 32767;
 	   if(Avail.y2 < pScrn->currentMode->VDisplay) {
 	      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			"Not enough video RAM for accelerator. At least "
+			"Not enough video RAM for accelerator. "
 			"%dKB needed, %dKB available\n",
-			((((pScrn->displayWidth * pScrn->bitsPerPixel/8)   /* +8 for make it sure */
+			((((pScrn->displayWidth * pScrn->bitsPerPixel / 8)   /* +8 for make it sure */
 			     * pScrn->currentMode->VDisplay) + reservedFbSize) / 1024) + 8,
 			pSiS->maxxfbmem/1024);
 	      pSiS->NoAccel = TRUE;
@@ -2382,8 +1926,10 @@ SiS315AccelInit(ScreenPtr pScreen)
 		   "Framebuffer from (%d,%d) to (%d,%d)\n",
 		   Avail.x1, Avail.y1, Avail.x2 - 1, Avail.y2 - 1);
 
+
 	   xf86InitFBManager(pScreen, &Avail);
 
+
 	   if(!pSiS->NoAccel) {
 	      return XAAInit(pScreen, infoPtr);
 	   }
@@ -2406,8 +1952,12 @@ SiS315AccelInit(ScreenPtr pScreen)
 						SiSScratchSave, pSiS);
 	      if(pSiS->exa_scratch) {
 		 pSiS->exa_scratch_next = pSiS->exa_scratch->offset;
-		 pSiS->EXADriverPtr->UploadToScratch = SiSUploadToScratch;
-	      }
+        #if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+		 pSiS->EXADriverPtr->accel.UploadToScratch = SiSUploadToScratch;
+	#else
+                 pSiS->EXADriverPtr->UploadToScratch = SiSUploadToScratch;
+        #endif
+               }
 
 	   } else {
 
diff --git a/src/sis310_accel.h b/src/sis310_accel.h
index 7f77e47..cae85db 100644
--- a/src/sis310_accel.h
+++ b/src/sis310_accel.h
@@ -37,19 +37,21 @@
 /* SiS315 and 330 engine commands */
 #define BITBLT                  0x00000000  /* Blit */
 #define COLOREXP                0x00000001  /* Color expand */
-#define ENCOLOREXP              0x00000002  /* Enhanced color expand (315 only?) */
-#define MULTIPLE_SCANLINE       0x00000003  /* 315 only, not 330 */
+#define ENCOLOREXP              0x00000002  /* Enhanced color expand */
+#define MULTIPLE_SCANLINE       0x00000003  /* 315 only, not 330+ */
 #define LINE                    0x00000004  /* Draw line */
-#define TRAPAZOID_FILL          0x00000005  /* Fill trapezoid */
+#define TRAPAZOID_FILL          0x00000005  /* Fill trapezoid (315 only, not 330+) */
 #define TRANSPARENT_BITBLT      0x00000006  /* Transparent Blit */
 #define ALPHA_BLEND		0x00000007  /* Alpha blended BitBlt */
-#define A3D_FUNCTION		0x00000008  /* 3D command ? */
-#define	CLEAR_Z_BUFFER		0x00000009  /* ? */
+#define A3D_FUNCTION		0x00000008  /* 3D command */
+#define	CLEAR_Z_BUFFER		0x00000009  /* Clear z buffer */
 #define GRADIENT_FILL		0x0000000A  /* Gradient fill */
-#define STRETCH_BITBLT		0x0000000B  /* Stretched BitBlit */
 
-#define YUVRGB_BLIT_325		0x0000000C
-#define YUVRGB_BLIT_330		0x00000003
+#define YUVRGB_BLIT_325		0x0000000C  /* YUV->RGB blit (315) */
+#define YUVRGB_BLIT_330		0x00000003  /* YUV->RGB blit (330+) */
+
+#define STRETCH_BITBLT		0x0000000b  /* scaling */
+
 
 /* Command bits */
 
@@ -78,22 +80,27 @@
 #define A_CONSTANTALPHA         0x00000000
 #define A_PERPIXELALPHA		0x00080000
 #define A_NODESTALPHA		0x00100000
-#define A_3DFULLSCENE		0x00180000
+#define A_3DFULLSCENE		0x00180000  /* Not 330+ */
 
 /* Destination */
 #define DSTAGP                  0x02000000
 #define DSTVIDEO                0x00000000
 
+/* Scanline trigger (not implemented in hardware) */
+#define SCANLINE_TR_CRT1        0x00000000
+#define SCANLINE_TR_CRT2        0x01000000
+#define SCANLINE_TRIGGER_ENABLE 0x80000000
+
 /* Subfunctions for Color/Enhanced Color Expansion */
 #define COLOR_TO_MONO		0x00100000
 #define AA_TEXT			0x00200000
 
-/* Line */
+/* Subfunctions for Line */
 #define LINE_STYLE              0x00800000
 #define NO_RESET_COUNTER        0x00400000
 #define NO_LAST_PIXEL           0x00200000
 
-/* Trapezoid (315 only?) */
+/* Subfunctions for Trapezoid (315 only) */
 #define T_XISMAJORL             0x00800000  /* X axis is driving axis (left) */
 #define T_XISMAJORR             0x08000000  /* X axis is driving axis (right) */
 #define T_L_Y_INC               0x00000020  /* left edge direction Y */
@@ -101,7 +108,7 @@
 #define T_R_Y_INC               0x00400000  /* right edge direction Y */
 #define T_R_X_INC               0x00200000  /* right edge direction X */
 
-/* YUV to RGB blit */
+/* Subfunctions for YUV to RGB blit */
 #define YUV_FORMAT_YUY2		0x00000000
 #define YUV_FORMAT_YVYU		0x00002000
 #define YUV_FORMAT_UYVY		0x00004000
@@ -111,10 +118,22 @@
 
 #define YUV_CMD_YUV		0x00800000
 
-/* Scanline trigger (315 only, not 330) */
-#define SCANLINE_TR_CRT1        0x00000000
-#define SCANLINE_TR_CRT2        0x01000000
-#define SCANLINE_TRIGGER_ENABLE 0x80000000
+
+/* Stretch direction */
+#define STRETCH_SRC_X_INC		0x00200000
+#define STRETCH_SRC_Y_INC		0x00400000
+#define STRETCH_DST_X_INC		0x00080000
+#define STRETCH_DST_Y_INC		0x00100000
+
+/* Subfunctions for 3D func */
+#define A3D_SSAA_2x1		0x00000000
+#define A3D_SSAA_2x2		0x00000040
+#define A3D_SSAA_1x2		0x00000080
+
+#define A3D_SSAA		0x00000000
+#define A3D_16_TO_32		0x00200000
+#define A3D_AA			0x00400000
+
 
 /* Some general registers */
 #define SRC_ADDR		0x8200
@@ -142,6 +161,7 @@
 #define FIRE_TRIGGER      	0x8240
 
 #define PATTERN_REG		0x8300  /* 384 bytes pattern buffer */
+#define SAFE_REG		0x8240	/* save register */
 
 /* Line registers */
 #define LINE_X0			SRC_Y
@@ -178,18 +198,27 @@
 #define Q_STATUS		0x85CC  /* queue status */
 
 /* VRAM queue operation command header definitions */
-#define SIS_SPKC_HEADER 	0x16800000L
+#define SIS_SPKC_HEADER		0x16800000L
 #define SIS_BURST_HEADER0	0x568A0000L
 #define SIS_BURST_HEADER1	0x62100000L
 #define SIS_PACKET_HEARER0 	0x968A0000L
 #define SIS_PACKET_HEADER1	0x62100000L
 #define SIS_NIL_CMD		0x168F0000L
 
+#define SIS_PACKET1_HEADER0	0x968A0001L
+#define SIS_PACKET1_HEADER1	0x62100008L
+
 #define SIS_PACKET12_HEADER0	0x968A000CL
 #define SIS_PACKET12_HEADER1	0x62100010L
 #define SIS_PACKET12_LENGTH	80
 
-/* Macros to do useful things with the SiS315/330 BitBLT engine */
+#define SIS_SPKC3D_HEADER	0x36800000L
+#define SIS_BURST3D_HEADER0	0x768A0000L
+#define SIS_PACKET3D_HEARER0	0xb68A0000L
+#define SIS_PACKET3D_HEADER1	SIS_PACKET_HEADER1
+#define SIS_NIL3D_CMD		0x368F0000L
+
+/* Macros to do useful things with the SiS315/330/340 BitBLT engine */
 
 /* Q_STATUS:
    bit 31 = 1: All engines idle and all queues empty
@@ -224,22 +253,43 @@
 #define SiSGetSwWP() (CARD32)(*(pSiS->cmdQ_SharedWritePort))
 #define SiSGetHwRP() (CARD32)(SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR))
 
-#define SiSFlushCmdBuf  \
-  if(pSiS->NeedFlush) { \
-     CARD32 ttt = ((SiSGetSwWP()) - 4) & pSiS->cmdQueueSizeMask;	\
-     pointer tt = (char *)pSiS->cmdQueueBase + ttt; 			\
-     dummybuf = SIS_RQINDEX(0);						\
-  }
+#if 1	/* Sync for AMD64 (32 and 64bit mode) -------------- */
+
+#if defined(__i386__) || defined(__AMD64__) || defined(__amd64__) || defined(__x86_64__)
+#define SiSFence() outSISREG(pSiS->RelIO + 0x50, 0)
+#else
+#define SiSFence() mem_barrier()
+#endif
+
+#define SiSFlush(i) {					\
+  dummybuf = SIS_RQINDEX(i);				\
+  SiSFence();						\
+  dummybuf = ((volatile CARD32 *)pSiS->FbBase)[0];	\
+  mem_barrier();					\
+}
+
+#else
 
-#define SiSSyncWP    \
-  SiSFlushCmdBuf;    \
-  SIS_MMIO_OUT32(pSiS->IOBase, Q_WRITE_PTR, (CARD32)(*(pSiS->cmdQ_SharedWritePort)));
+#define SiSFlush(i) {		\
+  dummybuf = SIS_RQINDEX(i);	\
+}
+
+#endif  /* Sync for AMD64 ---------------------------------- */
+
+#define SiSSyncWP								\
+	if(pSiS->NeedFlush) {							\
+	   CARD32 ttt = ((SiSGetSwWP()) - 4) & pSiS->cmdQueueSizeMask;		\
+	   pointer tt = (char *)pSiS->cmdQueueBase + ttt; 			\
+	   SiSFlush(0)								\
+	};									\
+	SIS_MMIO_OUT32(pSiS->IOBase, Q_WRITE_PTR, (CARD32)(*(pSiS->cmdQ_SharedWritePort)));
 
 #define SiSSetHwWP(p) \
-  *(pSiS->cmdQ_SharedWritePort) = (p);   	\
-  SIS_MMIO_OUT32(pSiS->IOBase, Q_WRITE_PTR, (p));
+	SIS_MMIO_OUT32(pSiS->IOBase, Q_WRITE_PTR, (p)); \
+	*(pSiS->cmdQ_SharedWritePort) = (p);
 
-#define SiSSetSwWP(p) *(pSiS->cmdQ_SharedWritePort) = (p);
+#define SiSSetSwWP(p) \
+	*(pSiS->cmdQ_SharedWritePort) = (p);
 
 #define SiSCheckQueue(amount)
 
@@ -260,24 +310,9 @@
       }
 #endif
 
-#define SiSUpdateQueue \
-      SiSWriteQueue(tt); \
+#define SiSUpdateQueue {\
       ttt += 16; \
       ttt &= pSiS->cmdQueueSizeMask; \
-      if(!ttt) { \
-	 while(SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR) < pSiS->cmdQueueSize_div4) {} \
-      } else if(ttt == pSiS->cmdQueueSize_div4) { \
-	 CARD32 temppp; \
-	 do { \
-	    temppp = SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR); \
-	 } while(temppp >= ttt && temppp <= pSiS->cmdQueueSize_div2); \
-      } else if(ttt == pSiS->cmdQueueSize_div2) { \
-	 CARD32 temppp; \
-	 do { \
-	    temppp = SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR); \
-	 } while(temppp >= ttt && temppp <= pSiS->cmdQueueSize_4_3); \
-      } else if(ttt == pSiS->cmdQueueSize_4_3) { \
-	 while(SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR) > ttt) {} \
       }
 
 /* Write-updates MUST be 128bit aligned. */
@@ -289,6 +324,21 @@
 
 #ifdef SISVRAMQ
 
+#define SIS_QUEUE_SIZE_GUARD 1024
+
+#define SiSQueueSpace(_wo, _hr, _qs)\
+(((_wo) >= (_hr)) ? (_qs) - (_wo) + (_hr) : (_hr) - (_wo))
+
+#define SiSWaitQueue(_size) \
+{\
+  CARD32 hwRead = SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR);\
+  while(SiSQueueSpace(ttt, hwRead, pSiS->cmdQueueSize) < \
+	((_size) + SIS_QUEUE_SIZE_GUARD)) {\
+      hwRead = SIS_MMIO_IN32(pSiS->IOBase, Q_READ_PTR);\
+   }\
+}
+
+
 #define SiSIdle \
   { \
      while( (SIS_MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000) {}; \
@@ -297,10 +347,21 @@
      while( (SIS_MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000) {}; \
   }
 
+#define SiSSetupSafeReg(safe) \
+      { \
+	 CARD32 ttt = SiSGetSwWP(); \
+	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
+	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SAFE_REG); 	\
+	 SIS_WQINDEX(1) = (CARD32)(safe); 				\
+	 SiSNILandUpdateSWQueue \
+      }
+
 #define SiSSetupSRCDSTBase(srcbase,dstbase) \
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_ADDR); \
 	 SIS_WQINDEX(1) = (CARD32)(srcbase); 			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + DST_ADDR); \
@@ -313,6 +374,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_Y); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((sx)<<16) | (sy));		\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + DST_Y); 	\
@@ -325,6 +387,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + DST_Y); 		\
 	 SIS_WQINDEX(1) = (CARD32)(((x)<<16) | (y));	 		\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + RECT_WIDTH); 	\
@@ -337,6 +400,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_PITCH); 	\
 	 SIS_WQINDEX(1) = (CARD32)(pitch);				\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + DST_PITCH); 	\
@@ -349,6 +413,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_ADDR); 	\
 	 SIS_WQINDEX(1) = (CARD32)(base); 				\
 	 SiSNILandUpdateSWQueue \
@@ -358,6 +423,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_PITCH); 	\
 	 SIS_WQINDEX(1) = (CARD32)(pitch);				\
 	 SiSNILandUpdateSWQueue \
@@ -367,6 +433,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_Y); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((x)<<16) | (y));		\
 	 SiSNILandUpdateSWQueue \
@@ -376,6 +443,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + DST_ADDR); 	\
 	 SIS_WQINDEX(1) = (CARD32)(base);				\
 	 SiSNILandUpdateSWQueue \
@@ -385,6 +453,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + DST_Y); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((x)<<16) | (y));	 	\
 	 SiSNILandUpdateSWQueue \
@@ -394,6 +463,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + DST_PITCH); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((y)<<16) | (x));		\
 	 SiSNILandUpdateSWQueue \
@@ -403,6 +473,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + DST_PITCH);	\
 	 SIS_WQINDEX(1) = (CARD32)(((y)<<16) | (x));			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_BURST_HEADER0 + reg); 		\
@@ -418,6 +489,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + PAT_FGCOLOR); 	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + DST_PITCH); 	\
@@ -430,6 +502,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_FGCOLOR); 	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + DST_PITCH); 	\
@@ -442,6 +515,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + RECT_WIDTH); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((h)<<16) | (w));			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + SRC_PITCH); 	\
@@ -454,6 +528,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + RECT_WIDTH); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((h)<<16) | (w));			\
 	 SiSNILandUpdateSWQueue \
@@ -463,6 +538,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + PAT_FGCOLOR); 	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 			\
 	 SiSNILandUpdateSWQueue \
@@ -472,6 +548,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + PAT_BGCOLOR);	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 			\
 	 SiSNILandUpdateSWQueue \
@@ -481,6 +558,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_FGCOLOR);	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 			\
 	 SiSNILandUpdateSWQueue \
@@ -490,6 +568,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + SRC_BGCOLOR);	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 			\
 	 SiSNILandUpdateSWQueue \
@@ -499,6 +578,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + TRANS_SRC_KEY_HIGH);	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 				\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + TRANS_SRC_KEY_LOW);	\
@@ -511,6 +591,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + TRANS_DST_KEY_HIGH);	\
 	 SIS_WQINDEX(1) = (CARD32)(color);	 				\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + TRANS_DST_KEY_LOW);	\
@@ -523,6 +604,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + MONO_MASK);		\
 	 SIS_WQINDEX(1) = (CARD32)(p0);	 				\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + MONO_MASK + 4);	\
@@ -535,6 +617,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + LEFT_CLIP);	\
 	 SIS_WQINDEX(1) = (CARD32)(((left) & 0xFFFF) | ((top)<<16));   	\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + RIGHT_CLIP);	\
@@ -547,6 +630,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + DST_ADDR); 	\
 	 SIS_WQINDEX(1) = (CARD32)(base);				\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + COMMAND_READY);	\
@@ -560,6 +644,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + RECT_WIDTH); 	\
 	 SIS_WQINDEX(1) = (CARD32)(((h)<<16) | (w));	 		\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + COMMAND_READY);	\
@@ -576,6 +661,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + COMMAND_READY);	\
 	 SIS_WQINDEX(1) = (CARD32)(pSiS->CommandReg); 			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_NIL_CMD); 			\
@@ -590,6 +676,7 @@
 	 CARD32 ttt = SiSGetSwWP(); \
 	 CARD32 _tmp = SIS_MMIO_IN32(pSiS->IOBase, FIRE_TRIGGER) & ~(1 << 10);	\
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+         SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + FIRE_TRIGGER);	\
 	 SIS_WQINDEX(1) = (CARD32)(_tmp | ((disable & 1) << 10)); 	\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_NIL_CMD); 			\
@@ -605,6 +692,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + LINE_X0);	\
 	 SIS_WQINDEX(1) = (CARD32)(((y1)<<16) | (x1)); 		\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + LINE_X1);	\
@@ -617,6 +705,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + LINE_X0);	\
 	 SIS_WQINDEX(1) = (CARD32)(((y)<<16) | (x)); 		\
 	 SiSNILandUpdateSWQueue \
@@ -626,6 +715,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + LINE_X1);	\
 	 SIS_WQINDEX(1) = (CARD32)(((y)<<16) | (x)); 		\
 	 SiSNILandUpdateSWQueue \
@@ -635,6 +725,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + LINE_COUNT);	\
 	 SIS_WQINDEX(1) = (CARD32)(((p) << 16) | (c)); 			\
 	 SiSNILandUpdateSWQueue \
@@ -644,6 +735,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + LINE_STYLE_0);	\
 	 SIS_WQINDEX(1) = (CARD32)(ls);					\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + LINE_STYLE_1);	\
@@ -652,12 +744,13 @@
 	 SiSSetSwWP(ttt); \
       }
 
-/* Trapezoid */
+/* Trapezoid (315 only) */
 
 #define SiSSetupYHLR(y,h,left,right) \
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + TRAP_YH);	\
 	 SIS_WQINDEX(1) = (CARD32)(((y)<<16) | (h)); 		\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + TRAP_LR);	\
@@ -671,6 +764,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + TRAP_DL);	\
 	 SIS_WQINDEX(1) = (CARD32)(((dyL)<<16) | (dxL)); 	\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + TRAP_DR);	\
@@ -683,6 +777,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + TRAP_EL);	\
 	 SIS_WQINDEX(1) = (CARD32)(eL);	 			\
 	 SIS_WQINDEX(2) = (CARD32)(SIS_SPKC_HEADER + TRAP_ER);	\
@@ -697,6 +792,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + ALPHA_ALPHA);	\
 	 SIS_WQINDEX(1) = (CARD32)(alpha);	 			\
 	 SiSNILandUpdateSWQueue \
@@ -706,6 +802,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(SIS_SPKC_HEADER + (PATTERN_REG + (num * 4)));	\
 	 SIS_WQINDEX(1) = (CARD32)(value); 						\
 	 SiSNILandUpdateSWQueue \
@@ -715,6 +812,7 @@
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(pat1);		\
 	 SIS_WQINDEX(1) = (CARD32)(pat2);		\
 	 SIS_WQINDEX(2) = (CARD32)(pat3);		\
@@ -723,6 +821,26 @@
 	 SiSSetSwWP(ttt); \
       }
 
+typedef struct _SiS_Packet1 {
+      CARD32 P1_Header0;
+      CARD32 P1_Header1;
+      CARD32 P1_SrcAddr;	/* 8200 source base address */
+      CARD16 P1_SrcPitch;	/* 8204 source pitch (16bit) */
+      CARD16 P1_Unused1;	/* 8206 */
+      CARD16 P1_SrcY;		/* 8208 source y */
+      CARD16 P1_SrcX;		/* 820a source x */
+      CARD16 P1_DstY;		/* 820c dest y */
+      CARD16 P1_DstX;		/* 820e dest x */
+      CARD32 P1_DstAddr;	/* 8210 dest base address */
+      CARD16 P1_DstPitch;	/* 8214 dest pitch */
+      CARD16 P1_DstHeight;	/* 8216 */
+      CARD16 P1_RectWidth;	/* 8218 */
+      CARD16 P1_RectHeight;	/* 821a */
+      CARD32 P1_Command;	/* 823c */
+      CARD32 P1_Null1;
+      CARD32 P1_Null2;
+} SiS_Packet1;
+
 typedef struct _SiS_Packet12_YUV {
       CARD32 P12_Header0;
       CARD32 P12_Header1;
@@ -754,10 +872,46 @@ typedef struct _SiS_Packet12_YUV {
       CARD32 P12_Null2;
 } SiS_Packet12_YUV;
 
+typedef struct _SiS_Packet12_Stretch {
+      CARD32 P12_Header0;
+      CARD32 P12_Header1;
+      CARD32 P12_SrcAddr;	/* 8200 */
+      CARD16 P12_SrcPitch;	/* 8204 Y if planar */
+      CARD16 P12_AGPBase;	/* 8206 */
+      CARD16 P12_SrcY;	/* 8208 */
+      CARD16 P12_SrcX;	/* 820a */
+      CARD16 P12_DstY;		/* 820c */
+      CARD16 P12_DstX;		/* 820e */
+      CARD32 P12_DstAddr;	/* 8210 */
+      CARD16 P12_DstPitch;	/* 8214 */
+      CARD16 P12_DstHeight;	/* 8216 */
+      CARD16 P12_RectWidth;	/* 8218 */
+      CARD16 P12_RectHeight;	/* 821a */
+      CARD16 P12_SrcWidth;	/* 821c */
+      CARD16 P12_SrcHeight;	/* 821e */
+      CARD16 P12_X_K1;		/* 8220 */
+      CARD16 P12_X_K2;		/* 8222 */      
+      CARD16 P12_Y_K1;		/* 8224 */
+      CARD16 P12_Y_K2;		/* 8226 */
+      CARD16 P12_InitErrorX;	/* 8228 */
+      CARD16 P12_InitErrorY;	/* 822a */
+      CARD32 P12_Unused0;	/* 822c */
+      CARD32 P12_Unused1;	/* 8230 */
+      CARD16 P12_ClipLeft;	/* 8234 */
+      CARD16 P12_ClipTop;	/* 8236 */
+      CARD16 P12_ClipRight;	/* 8238 */
+      CARD16 P12_ClipBottom;	/* 823a */
+      CARD32 P12_Command;	/* 823c */
+      CARD32 P12_Null1;
+      CARD32 P12_Null2;
+}SiS_Packet12_Stretch;
+
+
 #define SiSWritePacketPart(part1, part2, part3, part4) \
       { \
 	 CARD32 ttt = SiSGetSwWP(); \
 	 pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+     SiSWaitQueue(16); \
 	 SIS_WQINDEX(0) = (CARD32)(part1);	\
 	 SIS_WQINDEX(1) = (CARD32)(part2);	\
 	 SIS_WQINDEX(2) = (CARD32)(part3);	\
diff --git a/src/sis6326_video.c b/src/sis6326_video.c
index 2571832..7b3172b 100644
--- a/src/sis6326_video.c
+++ b/src/sis6326_video.c
@@ -72,8 +72,7 @@ static void 	SIS6326QueryBestSize(ScrnInfoPtr, Bool, short, short, short,
 			short, unsigned int *,unsigned int *, pointer);
 static int 	SIS6326PutImage( ScrnInfoPtr,
 			short, short, short, short, short, short, short, short,
-			int, unsigned char*, short, short, Bool, RegionPtr, pointer,
-			DrawablePtr);
+			int, unsigned char*, short, short, Bool, RegionPtr, pointer);
 static int 	SIS6326QueryImageAttributes(ScrnInfoPtr,
 			int, unsigned short *, unsigned short *, int *, int *);
 static void 	SIS6326VideoTimerCallback(ScrnInfoPtr pScrn, Time now);
@@ -1232,14 +1231,11 @@ SIS6326PutImage(
   int id, unsigned char* buf,
   short width, short height,
   Bool sync,
-  RegionPtr clipBoxes, pointer data,
-  DrawablePtr pDraw
+  RegionPtr clipBoxes, pointer data
 ){
    SISPtr pSiS = SISPTR(pScrn);
    SISPortPrivPtr pPriv = (SISPortPrivPtr)data;
    int totalSize=0;
-   CARD32 *src, *dest;
-   unsigned long i;
 
    if(pPriv->grabbedByV4L) return Success;
 
@@ -1309,18 +1305,7 @@ SIS6326PutImage(
    pPriv->bufAddr[1] = pPriv->bufAddr[0] + totalSize;
 
    /* copy data */
-   if((pSiS->XvUseMemcpy) || (totalSize < 16)) {
-      SiSMemCopyToVideoRam(pSiS, pSiS->FbBase + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
-   } else {
-      dest = (CARD32 *)(pSiS->FbBase + pPriv->bufAddr[pPriv->currentBuf]);
-      src  = (CARD32 *)buf;
-      for(i = 0; i < (totalSize/16); i++) {
-	 *dest++ = *src++;
-	 *dest++ = *src++;
-	 *dest++ = *src++;
-	 *dest++ = *src++;
-      }
-   }
+   SiSMemCopyToVideoRam(pSiS, pSiS->FbBase + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
 
    SIS6326DisplayVideo(pScrn, pPriv);
 
diff --git a/src/sis_3daccel.c b/src/sis_3daccel.c
new file mode 100644
index 0000000..31a3ffd
--- /dev/null
+++ b/src/sis_3daccel.c
@@ -0,0 +1,681 @@
+/* $XFree86$ */
+/* $XdotOrg$ */
+/*
+ * 2D Acceleration for SiS 671 chip
+ * Copyright (c) 2007 SiS Corp. All Rights Reserved.
+ * Copyright (c) 2007 Chaoyu Chen. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sis.h"
+#define SIS_NEED_MYMMIO
+#define SIS_NEED_ACCELBUF
+#include "sis_regs.h"
+#include "sis310_accel.h"
+#include "sis_3daccel.h"
+
+/*
+#define ACCELDEBUG_3D
+*/
+
+#define FBOFFSET 	(pSiS->dhmOffset)
+
+#define DEV_HEIGHT	0xfff	/* "Device height of destination bitmap" */
+
+#undef SIS_NEED_ARRAY
+
+/* For XAA */
+
+#ifdef SIS_USE_XAA
+
+#define INCL_RENDER	/* Use/Don't use RENDER extension acceleration */
+
+#ifdef INCL_RENDER
+# ifdef RENDER
+#  include "mipict.h"
+#  include "dixstruct.h"
+#  define SIS_NEED_ARRAY
+#  undef SISNEWRENDER
+#  ifdef XORG_VERSION_CURRENT
+#   if XORG_VERSION_CURRENT > XORG_VERSION_NUMERIC(6,7,0,0,0)
+#    define SISNEWRENDER
+#   endif
+#  endif
+# endif
+#endif
+
+#endif /* XAA */
+
+/* For EXA */
+
+#ifdef SIS_USE_EXA
+#if 0
+#define SIS_HAVE_COMPOSITE		/* Have our own EXA composite */
+#endif
+#ifdef SIS_HAVE_COMPOSITE
+#if 0
+#ifndef SIS_NEED_ARRAY
+#define SIS_NEED_ARRAY
+#endif
+#endif
+#endif
+#endif
+
+
+#ifdef SIS_USE_EXA		/* EXA */
+void SiSScratchSave(ScreenPtr pScreen, ExaOffscreenArea *area);
+Bool SiSUploadToScreen(PixmapPtr pDst, int x, int y, int w, int h, char *src, int src_pitch);
+Bool SiSUploadToScratch(PixmapPtr pSrc, PixmapPtr pDst);
+Bool SiSDownloadFromScreen(PixmapPtr pSrc, int x, int y, int w, int h, char *dst, int dst_pitch);
+#endif /* EXA */
+
+
+
+#define _SHT_PS_SrcNum	        6
+#define _SHT_PS_DstNum	        18
+#define _SHT_PS_DstL   14
+#define _SHT_PS_SrcL   14
+
+
+#define MSK_PS_SrcR            0x08
+#define MSK_PS_SrcG            0x04
+#define MSK_PS_SrcB            0x02
+#define MSK_PS_SrcA            0x01
+#define MSK_PS_SrcSwizzleXYZW   0x00
+#define MSK_PS_DstoCn           0x100
+#define MSK_PS_SrcNULL         0x07C0
+#define MSK_PS_ModifierSat      0x80000000
+#define MSK_PS_TEXLD            (0x04<<23)
+#define MSK_PS_DstR             (0x08 << _SHT_PS_DstL)
+#define MSK_PS_DstG             (0x04 << _SHT_PS_DstL)
+#define MSK_PS_DstB             (0x02 << _SHT_PS_DstL)
+#define MSK_PS_DstA             (0x01 << _SHT_PS_DstL)
+
+#define MSK_PS_MOV              (0x11<<23)
+#define MSK_PS_SrcRGB          (MSK_PS_SrcR | MSK_PS_SrcG | MSK_PS_SrcB) 
+#define MSK_PS_SrcRGBA         (MSK_PS_SrcRGB | MSK_PS_SrcA)
+#define MSK_PS_DstALL           (MSK_PS_DstR | MSK_PS_DstG | MSK_PS_DstB | MSK_PS_DstA)
+#define MSK_PS_DstRGBA          (MSK_PS_DstALL)
+#define MSK_PS_SrcNoSwizzle     (MSK_PS_SrcSwizzleXYZW | MSK_PS_SrcRGBA)
+
+
+
+#define PS_DstTemp(R,Param)     ((R) <<_SHT_PS_DstNum | Param)
+#define PS_DstR(R,Param)        PS_DstTemp(R, Param)
+#define PS_SrcS(S)			    (0x0700 | (S))
+#define PS_SrcR(R, Param)		((R) << _SHT_PS_SrcNum |  (Param)) 
+#define PS_DstColor(C)          ((MSK_PS_DstoCn | (C)) << _SHT_PS_DstL)
+
+float HwIdentityMatrix_340[40] = {
+    /* T1*/
+    1.0f,        /* M_00, M_10, M_20, M_30*/
+    0.0f,
+    0.0f,
+    0.0f,
+    0.0f,        /* M_01, M_11, M_21, M_31*/
+    1.0f,
+    0.0f,
+    0.0f,
+    0.0f,        /* M_02, M_12, M_22, M_32*/
+    0.0f,
+    1.0f,
+    0.0f,
+    0.0f,        /* M_03, M_13, M_23, M_33*/
+    0.0f,
+    0.0f,
+    1.0f,
+
+    /*WV*/
+    1.0f,        /* M_00, M_10, M_20, M_30*/
+    0.0f,
+    0.0f,
+    0.0f,
+    0.0f,        /* M_01, M_11, M_21, M_31*/
+    1.0f,
+    0.0f,
+    0.0f,
+    0.0f,        /* M_02, M_12, M_22, M_32*/
+    0.0f,
+    1.0f,
+    0.0f,
+
+    /*IWV*/
+    1.0f,        /* M_00, M_10, M_20, Reserved_30*/
+    0.0f,
+    0.0f,
+    0.0f,
+    0.0f,        /* M_01, M_11, M_21, Reserved_31*/
+    1.0f,
+    0.0f,
+    0.0f,
+    0.0f,        /* M_02, M_12, M_22, Reserved_32*/
+    0.0f,
+    1.0f,
+    0.0f,
+};
+
+typedef struct _CoordVectData{
+	unsigned long sx, sy, sz;
+	unsigned long tu, tv;
+	float u, v, m, n;
+}CoordVectData;
+
+unsigned long MRTCWMask[5][2] =
+{
+    {0x00000000, 0x00000000},
+    {0x0000FFFF, 0x00000000},
+    {0xFFFFFFFF, 0x00000000},
+    {0xFFFFFFFF, 0x0000FFFF},
+    {0xFFFFFFFF, 0xFFFFFFFF}
+};
+
+unsigned long FVF_TexCoord_771[33][6] =
+{
+    {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x40250000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x40250000, 0x00004026, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x40250000, 0x40274026, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+    {0x40250000, 0x40274026, 0x00004028, 0x00000000, 0x00000000, 0x00000000},
+    {0x40250000, 0x40274026, 0x40294028, 0x00000000, 0x00000000, 0x00000000},
+    {0x40250000, 0x40274026, 0x40294028, 0x0000402A, 0x00000000, 0x00000000},
+    {0x40250000, 0x40274026, 0x40294028, 0x402B402A, 0x00000000, 0x00000000},
+    {0x40250000, 0x40274026, 0x40294028, 0x402B402A, 0x0000402C, 0x00000000},
+    {0xC0650000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t0, for diffuse*/
+    {0xC0650000, 0x0000C066, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t0, for diffuse, specular*/
+    {0xC0650000, 0x4027C066, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t0, for diffuse, specular, fog*/
+    {0x40250000, 0x0000C066, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t1, for diffuse*/
+    {0x40250000, 0xC067C066, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t1, for diffuse, specular*/
+    {0x40250000, 0xC067C066, 0x00004028, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t1, for diffuse, specular, fog*/
+    {0x40250000, 0xC0674026, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t2, for diffuse	// tyhuang modified, fix the typo of the copytype after diffuse, [2006/10/12]*/
+    {0x40250000, 0xC0674026, 0x0000C068, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t2, for diffuse, specular	// tyhuang modified, fix the typo of the copytype after diffuse, [2006/10/12]*/
+    {0x40250000, 0xC0674026, 0x4029C068, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t2, for diffuse, specular, fog	// tyhuang modified, fix the typo of the copytype after diffuse, [2006/10/12]*/
+    {0x40250000, 0x40274026, 0x0000C068, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t3, for diffuse*/
+    {0x40250000, 0x40274026, 0xC069C068, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t3, for diffuse, specular*/
+    {0x40250000, 0x40274026, 0xC069C068, 0x0000402A, 0x00000000, 0x00000000}, /*Ext from t3, for diffuse, specular, fog*/
+    {0x40250000, 0x40274026, 0xC0694028, 0x00000000, 0x00000000, 0x00000000}, /*Ext from t4, for diffuse*/
+    {0x40250000, 0x40274026, 0xC0694028, 0x0000C06A, 0x00000000, 0x00000000}, /*Ext from t4, for diffuse, specular*/
+    {0x40250000, 0x40274026, 0xC0694028, 0x402BC06A, 0x00000000, 0x00000000}, /*Ext from t4, for diffuse, specular, fog*/
+    {0x40250000, 0x40274026, 0x40294028, 0x0000C06A, 0x00000000, 0x00000000}, /*Ext from t5, for diffuse*/
+    {0x40250000, 0x40274026, 0x40294028, 0xC06BC06A, 0x00000000, 0x00000000}, /*Ext from t5, for diffuse, specular*/
+    {0x40250000, 0x40274026, 0x40294028, 0xC06BC06A, 0x0000402B, 0x00000000}, /*Ext from t5, for diffuse, specular, fog*/
+    {0x40250000, 0x40274026, 0x40294028, 0xC06B402A, 0x00000000, 0x00000000}, /*Ext from t6, for diffuse*/
+    {0x40250000, 0x40274026, 0x40294028, 0xC06B402A, 0x0000C06C, 0x00000000}, /*Ext from t6, for diffuse, specular*/
+    {0x40250000, 0x40274026, 0x40294028, 0xC06B402A, 0x402DC06C, 0x00000000}, /*Ext from t6, for diffuse, specular, fog*/
+    {0x40250000, 0x40274026, 0x40294028, 0x402B402A, 0xC06D402C, 0x00000000}, /*Ext from t7, for diffuse*/
+    {0x40250000, 0x40274026, 0x40294028, 0x402B402A, 0xC06D402C, 0x0000C06E}, /*Ext from t7, for diffuse, specular*/
+    {0x40250000, 0x40274026, 0x40294028, 0x402B402A, 0xC06D402C, 0x402FC06E}, /*Ext from t7, for diffuse, specular, fog*/
+};
+
+unsigned long VertexActBitsL_771[9] = {0x00000007, 0x0000001F, 0x0000007F, 0x000001FF,
+                          0x000007FF, 0x00001FFF, 0x00007FFF, 0x0001FFFF,
+                          0x0007FFFF};
+unsigned long VertexActBitsLEx_771[4] = {0x00000000, 0x0000000F, 0x000000FF, 0x000003FF};
+
+unsigned long dwStamp=0L;
+
+
+extern Bool SiSAllocateLinear(ScrnInfoPtr pScrn, int sizeNeeded);
+
+
+#define PS_Packing(index, wOP, wDst, wSrc1, wSrc2, wSrc3)\
+{\
+	dwInst[index++] = ((wSrc2 << _SHT_PS_SrcL) | (wSrc3));\
+	dwInst[index++] = (wOP) | (wDst) | (wSrc1);\
+}
+
+#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
+#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
+
+#define FBOFFSET	(pSiS->dhmOffset)
+
+unsigned long Float2FixedS7(unsigned long dwValue)
+{
+    unsigned long dwMantissa;
+    int nTemp;
+
+    if(dwValue == 0) return 0;
+    *(float*)&dwValue = MAX(-1.0f, MIN(1.0f,*(float*)&dwValue));
+    nTemp = (int) (dwValue & 0x7F800000) >> 23;
+    nTemp = nTemp - 127 + 7 - 23;
+    dwMantissa = (dwValue & 0x007FFFFF) | 0x00800000;   /* Mantissa*/
+
+
+    if(nTemp > 0){
+        dwMantissa <<= nTemp;
+    }
+    else{
+        dwMantissa >>= -nTemp;
+    }
+    if(dwValue & 0x80000000)        /* negative*/
+    {
+        dwMantissa = ~dwMantissa + 1;
+        dwMantissa &= 0x0000007F;
+        dwMantissa |= 0x80;
+        if (dwMantissa == 0x80)
+        {
+            if ( *(float*)&dwValue < -0.9f )
+                dwMantissa = 0x81; /* overflow when dwValue close to -1 (0x80) ==> (0x81)*/
+            else
+                dwMantissa = 0xFF; /* overflow when dwValue close to -0 (0x80) ==> (0xFF)*/
+        }
+    }
+    else if (dwMantissa == 0x80)    /* overflow, 1(0x80) ==> 0.9999..(7F)*/
+    {
+        dwMantissa = 0x7F;
+    }
+    return dwMantissa;
+}
+
+
+
+unsigned long Float2Fixed(unsigned long dwValue, int nInterger, int nFraction)
+{
+    unsigned long dwMantissa, dwMantissa_771;
+    int nTemp;
+
+    if(dwValue == 0) return 0;
+    nTemp = (int) (dwValue & 0x7F800000) >> 23;
+    nTemp = nTemp - 127 + nFraction - 23;
+    dwMantissa_771=dwMantissa = (dwValue & 0x007FFFFF) | 0x00800000;   /*  Mantissa */
+
+    /* if(nTemp < -25) return 0; */
+    if(nTemp > 0)
+   {
+	 if(nTemp >= 32)
+	 {
+            dwMantissa = (0x1FFFFFFF >> (32-nInterger-nFraction));
+	 }
+	 else 
+              dwMantissa <<= nTemp;
+    }	 
+    else
+   {
+	if(nTemp <= -32)
+	   dwMantissa = 0;	
+	else
+          dwMantissa >>= -nTemp;
+	
+           if(-nTemp > 4)
+              dwMantissa_771 = dwMantissa_771 >>= ((-nTemp)-4);
+	   /* if(d3d.Registry.PatchFloat2Fix == 1)
+	    { */          
+              /* if((dwMantissa_771 & d3d.Registry.ManMsk) >= d3d.Registry.ManVal)  .ManMsk = 0xf, ManVal = 0xc */
+                   dwMantissa = dwMantissa +1;
+	   /* } */
+    }
+    if(dwValue & 0x80000000)    /*  negative number */
+    {
+        int nShift = 32-(nInterger+nFraction+1);
+        dwMantissa = ~dwMantissa + 1;
+        dwMantissa <<= nShift;
+        dwMantissa >>= nShift;
+        if(/*d3d.Registry.FixSign31 &&*/ (nInterger == 13) && (nFraction == 4))
+        {
+            if (dwMantissa)  /* sis3412, 2006-3-22, if assign bit when it's zero, it will become a very large negative number */
+                dwMantissa = (dwMantissa & 0x0001FFFF) | 0x80000000;
+        }
+    }
+    return dwMantissa;
+}
+
+
+
+Bool IsPower2(unsigned long dw)
+{
+    unsigned long i;
+
+    if (!dw) return(0);
+
+    for(i=0x80000000; i>0; i>>=1){
+        if(dw & i) break;
+    }
+
+    return(dw & (i-1) ? FALSE : TRUE);
+}
+
+
+unsigned long GetTexturePitch(unsigned long dwPitch)
+{
+    unsigned long i = 0;
+    if(dwPitch == 0)
+        return 0;
+
+    while( ((dwPitch & 1) == 0) && (i < 15) )
+    {
+        dwPitch >>= 1;
+        i++;
+    }
+
+    return dwPitch | (i<<9);
+}
+
+
+
+Bool
+SiSSetupForCPUToScreenAlphaTexture3D(ScrnInfoPtr pScrn,
+			int op, CARD16 red, CARD16 green,
+			CARD16 blue, CARD16 alpha,
+#ifdef SISNEWRENDER
+			CARD32 alphaType, CARD32 dstType,
+#else
+			int alphaType,
+#endif
+			CARD8 *alphaPtr,
+			int alphaPitch, int width,
+			int height, int	flags)
+{
+	
+
+
+
+	SISPtr pSiS = SISPTR(pScrn);
+	static unsigned char *renderaccelarray;
+	CARD32 *dstPtr;
+	int    sbpp = pSiS->CurrentLayout.bytesPerPixel;
+	int    sbppshift = sbpp >> 1;	/* 8->0, 16->1, 32->2 */
+	int    pitch, sizeNeeded;
+	CARD8  myalpha;
+	Bool   docopy = TRUE;
+
+
+	int i,x;
+	unsigned long dwEnable0, dwEnable1, dwEnable2;
+	unsigned long dwTexCoorNum, dwTexCoorExtNum, dwFrontEnable2;
+	unsigned long dwSet, dwFormat, dwPitch;
+	unsigned long dwTexSet;
+	unsigned long dwAlphaBlend, dwBlendMode, dwBlendCst;
+	unsigned long dwInstNum, dwDstNum, dwPSSet;
+	unsigned long dwCount, dwInst[NUM_MAX_PS_INST340*PS_INST_DWSIZE];
+        int InstIndex;	
+	unsigned long dwTexCoorSet;
+	unsigned long dwTexPitch;
+	unsigned long dwTexCoordDim;
+	unsigned long TexCrdIdx, dwExt;
+	unsigned long dwExtDWNum;
+
+	/*For Init_Read*/
+	unsigned long PSSet1;
+	unsigned long PSInitRead[8];
+	
+#ifdef ACCELDEBUG_3D
+	xf86DrvMsg(0, X_INFO, "AT3D(1): op %d t %x ARGB %x %x %x %x, w %d h %d pch %d\n",
+		op, alphaType, alpha, red, green, blue, width, height, alphaPitch);
+
+#endif 
+
+
+
+	if((width > 2048) || (height > 2048)) return FALSE;
+
+	if(!((renderaccelarray = pSiS->RenderAccelArray)))
+	   return FALSE;
+
+	pitch = (width+15)& ~15;
+	sizeNeeded = (pitch << 2) * height;
+
+	if(!SiSAllocateLinear(pScrn,(sizeNeeded + sbpp - 1) >> sbppshift))	
+		return FALSE;
+
+	
+	dwEnable0 = MSK_En_Blend_340/* | 0x00400000 | 0x00008000*/;
+	dwEnable1 = MSK_En_TexCache_340 |MSK_En_TexL2Cache_340 |/* MSK_En_AGPRqBurst_340 |*/\
+				MSK_En_DRAM128b_342 |MSK_En_PixelShader_340 | MSK_En_TexMap_340;
+	dwEnable2 = VAL_SolidFill_340 |VAL_SolidCCWFill_340 |MSK_En_ArbPreCharge_340; 
+
+	
+
+	dwTexCoorNum = dwTexCoorExtNum = 1;
+	dwFrontEnable2 = 0xffffffff >> (32 - dwTexCoorNum); /*PtSprite*/
+	dwFrontEnable2 |= (1L << SHT_TnDiffuse_771 | 1L<<SHT_TnSpecular_771);
+	dwTexCoorSet = dwTexCoordDim =0;
+	for(i=0; i < dwTexCoorExtNum; i++)
+	{
+                if(i < 2)
+                {
+                	dwTexCoorSet |= 2 << ((i+ dwTexCoorNum)*2);
+			dwTexCoordDim |= 2 << ((i+ dwTexCoorNum)*2);
+			dwFrontEnable2 |= 1 << (dwTexCoorNum + i);
+                }
+	}
+
+	
+	if (sbppshift == 2)		dwFormat = VAL_Dst_A8R8G8B8_340; /*32 bpp*/
+	else 	dwFormat = VAL_Dst_R5G6B5_340;
+
+	dwPitch = pSiS->scrnOffset;  /*the screen is the dest*/
+	dwSet = 0x0C000000 |dwFormat |dwPitch;
+
+
+	dwTexSet = ((dwTexCoorNum + dwTexCoorExtNum) << SHT_FrontTXNUM_340) |
+				((dwTexCoorNum + dwTexCoorExtNum) << SHT_TXNUM_340);
+
+
+	
+	dwAlphaBlend = (VAL_CBLSRC_One_340 << 4) | VAL_CBLDST_InvSrc_Alpha_340;
+	dwBlendMode = INI_BlendMode_340 |dwAlphaBlend;
+	float fAlpha = ((float)alpha)/255.0f;
+	float fRed = ((float)red)/255.0f;
+	float fGreen = ((float)green)/255.0f;
+	float fBlue = ((float)blue)/255.0f;
+	dwBlendCst = ((Float2FixedS7(*(unsigned long*)(&fAlpha)) << 24) |  /* A */
+                                  (Float2FixedS7(*(unsigned long*)(&fRed)) << 16)  |   /* R */
+                                  (Float2FixedS7(*(unsigned long*)(&fGreen)) << 8) |   /* G */
+                                  (Float2FixedS7(*(unsigned long*)(&fBlue))));          /* B */
+
+
+
+	dwInstNum = 2;
+	dwDstNum = 1;
+	dwPSSet = VAL_PSReName_NormalMode | MSK_PS_ElementGamma_340 | VAL_PS_PixelNum64_340 | (dwInstNum -1);
+
+
+        InstIndex = 0;	
+	dwCount = dwInstNum * PS_INST_DWSIZE;
+	PS_Packing(InstIndex, MSK_PS_TEXLD, PS_DstR(2, MSK_PS_DstRGBA), PS_SrcS(0), PS_SrcR(0,MSK_PS_SrcNoSwizzle),MSK_PS_SrcNULL)
+  	PS_Packing(InstIndex, MSK_PS_MOV | MSK_PS_ModifierSat, PS_DstColor(0), PS_SrcR(2,MSK_PS_SrcNoSwizzle), MSK_PS_SrcNULL, MSK_PS_SrcNULL)
+
+
+	dwTexPitch = pitch << 2;
+	
+	
+	
+	dwExt = (dwTexCoorExtNum) ? 1 : 0;
+	TexCrdIdx = (dwExt) ? (dwTexCoorNum*3 + 8 + dwTexCoorExtNum) : dwTexCoorNum;
+
+
+	dwExtDWNum = (dwTexCoorExtNum == 3) ? 10 : (dwTexCoorExtNum*4);
+
+
+	/* For Init_Read */
+	PSSet1 = 0x0 | MSK_EGenTXInitR;
+	PSInitRead[0] = 0x0 | (0x0<<24) | (0x0<<16) | 0x2f;
+	for(i=1; i<8 ; i++)	PSInitRead[i]=0x0;	
+
+
+	/*Copy the Source*/
+	/* Don't need source for clear and dest */
+	if(!docopy) return TRUE;
+
+	dstPtr = (CARD32*)(pSiS->FbBase + (pSiS->AccelLinearScratch->offset << sbppshift));
+
+	if(pSiS->alphaBlitBusy) {
+	   pSiS->alphaBlitBusy = FALSE;
+	   SiSIdle
+	}
+
+	if(alpha == 0xffff) {
+
+	   while(height--) {
+	      for(x = 0; x < width; x++) {
+	         myalpha = alphaPtr[x];
+	         dstPtr[x] = (renderaccelarray[(red & 0xff00)+myalpha] << 16)  |
+			     (renderaccelarray[(green & 0xff00) + myalpha] << 8) |
+			     renderaccelarray[(blue & 0xff00) + myalpha]         |
+			     myalpha << 24;
+	      }
+	      dstPtr += pitch;
+	      alphaPtr += alphaPitch;
+	   }
+
+	} else {
+
+	   alpha &= 0xff00;
+
+	   while(height--) {
+	      for(x = 0; x < width; x++) {
+	         myalpha = alphaPtr[x];
+	         dstPtr[x] = (renderaccelarray[alpha + myalpha] << 24) |
+			     (renderaccelarray[(red & 0xff00) + myalpha] << 16)   |
+			     (renderaccelarray[(green & 0xff00) + myalpha] << 8)  |
+			     renderaccelarray[(blue & 0xff00) + myalpha];
+	      }
+	      dstPtr += pitch;
+	      alphaPtr += alphaPitch;
+	   }
+
+	}
+
+
+	
+	SiS3DClearTexCache
+	SiS3DEnableSet(dwEnable0, dwEnable1, dwEnable2)
+	SiS3DFrontEnableSet(dwFrontEnable2)
+	SiS3DSetupDestination0Set(dwSet, 0x00ffffff)
+	SiS3DSetupIdentityT1WVInvWV
+	SiS3DSetupIdentityT2
+	SiS3DSetupTextureSet(dwTexSet)
+	SiS3DSetupAlphaBlend(dwBlendMode, dwBlendCst)
+	SiS3DSetupShaderMRT(dwPSSet, dwDstNum)
+	SiS3DSetupInitRead0(PSSet1,PSInitRead[0])
+	SiS3DSetupPixelInst(dwCount, dwInst)
+	SiS3DSetupBackCoordinate(dwTexCoorSet)
+	SiS3DSetupTexture0Pitch(GetTexturePitch(dwTexPitch))
+	SiS3DSetupDimLight(dwTexCoordDim)
+	SiS3DSetupVertexVector(TexCrdIdx)
+	SiS3DPrimitiveSet
+	SiS3DSetupStream(dwTexCoorNum, dwTexCoorExtNum, dwExtDWNum)
+	SiS3DSetupSwapColor
+
+
+
+	return TRUE;
+}
+
+
+
+
+void
+SiSSubsequentCPUToScreenTexture3D(ScrnInfoPtr pScrn,
+			int dst_x, int dst_y,
+			int src_x, int src_y,
+			int width, int height)
+{
+
+
+	SISPtr pSiS = SISPTR(pScrn);
+	int i;
+	unsigned long dwDstAddr;
+	unsigned long dwClipTB, dwClipLR;
+	unsigned long dwTexSet0, dwTexSet1, dwTexDepth, dwTexFormat, dwTexSize, dwTexAddr;
+	float x1, y1, x2, y2, u1, u2, v1, v2, fzero, fone;
+	CoordVectData vect[4];
+	CARD16 EngineId;
+
+	/*
+	width = 1000;
+	height = 700;
+	dst_x = dst_y = 10;
+	*/
+	/*src_x = src_y = 0;*/
+	
+	dwTexAddr = (unsigned long)pSiS->AccelLinearScratch->offset<< 1;
+	if(pScrn->bitsPerPixel == 32) dwTexAddr <<= 1;
+
+#ifdef ACCELDEBUG_3D
+	xf86DrvMsg(0, X_INFO, "FIRE: srcbase %x sx %d sy %d dx %d dy %d w %d h %d\n",\
+		dwTexAddr, src_x, src_y, dst_x, dst_y, width, height);
+#endif
+
+	dwDstAddr = 0;
+	if((dst_y >= pScrn->virtualY) || (dst_y >= 2048)) {
+	   dwDstAddr = pSiS->scrnOffset * dst_y;
+	   dst_y = 0;
+	}
+	dwTexAddr += FBOFFSET;
+	dwDstAddr += FBOFFSET;
+
+	dwClipTB = (dst_y<<13)|(dst_y + height);
+	dwClipLR = (dst_x<<13)|(dst_x + width);
+
+	Bool bPower2 = IsPower2((unsigned long)width) && IsPower2((unsigned long)height);
+	dwTexSet0 = bPower2 ? 0 : MSK_TXNonPwdTwo_340;
+	dwTexSet1 = VAL_Tex_MinNearest_340|VAL_Tex_MagNearest_340/* |VAL_TxL0InSys_340*/;
+	dwTexDepth = dwTexFormat = VAL_Tex_A8R8G8B8_340;
+	dwTexSize = (width<<SHT_TXW_340)|height;
+
+
+
+	x1 = (float)dst_x/*-0.5f*/;
+	y1 = (float)dst_y - 0.5f;
+	x2 = (float)(dst_x + width)/*-0.5f*/;
+	y2 = (float)(dst_y + height) - 0.5f;
+	u1 = ((float)src_x) / (float)width;
+	v1 = ((float)src_y) / (float)height;
+	u2 = 1.0f; 
+	v2 = 1.0f;
+	fzero = 0.0f;
+	fone = 1.0f;
+
+
+	vect[0].sx = vect[1].sx = Float2Fixed(*(unsigned long*)&x1,13,4);
+	vect[2].sx = vect[3].sx = Float2Fixed(*(unsigned long*)&x2,13,4);
+	vect[0].sy = vect[2].sy = Float2Fixed(*(unsigned long*)&y2,13,4);
+	vect[1].sy = vect[3].sy = Float2Fixed(*(unsigned long*)&y1,13,4);
+	vect[0].sz = vect[1].sz = vect[2].sz = vect[3].sz = *(unsigned long*)&fzero;
+
+	vect[0].tu = vect[1].tu = *(unsigned long*)&u1; 
+	vect[2].tu = vect[3].tu = *(unsigned long*)&u2; 
+	vect[0].tv = vect[2].tv = *(unsigned long*)&v2; 
+	vect[1].tv = vect[3].tv = *(unsigned long*)&v1;
+
+	vect[0].u = vect[1].u = vect[2].u = vect[3].u = vect[0].v = vect[1].v = vect[2].v= vect[3].v =
+	vect[0].m = vect[1].m = vect[2].m = vect[3].m = vect[0].n = vect[1].n= vect[2].n= vect[3].n=*(unsigned long*)&fone;
+
+	
+	EngineId = REG_3D_EngineId_671;
+	
+
+	SiS3DSetupDestination0Addr(dwDstAddr)
+	SiS3DSetupClippingRange(dwClipTB, dwClipLR)
+	SiS3DTexture0Setting(dwTexSet0, dwTexSet1, dwTexDepth, dwTexSize, dwTexAddr)
+	SiS3DSetupVertexData(vect)
+	SiS3DListEnd(EngineId, dwStamp++)
+
+}
diff --git a/src/sis_3daccel.h b/src/sis_3daccel.h
new file mode 100644
index 0000000..e84a61a
--- /dev/null
+++ b/src/sis_3daccel.h
@@ -0,0 +1,576 @@
+/* $XFree86$ */
+/* $XdotOrg$ */
+/*
+ * 2D Acceleration for SiS 671 chip
+ * Copyright (c) 2007 SiS Corp. All Rights Reserved.
+ * Copyright (c) 2007 Chaoyu Chen. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization.
+ */
+
+
+/***** Packet Format *****/
+#define SIS_3D_SPKC_HEADER		0x36800000L
+#define SIS_3D_BUST_HEADER		0x76800000L
+
+
+
+
+/***** Registers *****/
+#define REG_3D_PSInit_340               0x8a84
+#define REG_3D_FSAA_PrimType_340        0x8a8c
+#define REG_3D_ClipTopBottom_340        0x8a98
+#define REG_3D_TEnable0_340	0x8b00
+#define REG_3D_TEnable1_340	0x8b04
+#define REG_3D_BlendMode_340            0x8b28
+#define REG_3D_AlphaBlendConstant_340   0x8b2c
+#define REG_3D_Dst0Set_340              0x8b40
+#define REG_3D_Dst0Addr_340             0x8b48
+#define REG_3D_MRTCWMask0_340            0x8ba4
+#define REG_3D_MRTCWMask1_340            0x8ba8
+#define REG_3D_TexSet_340               0x8cdc
+#define REG_3D_TexCoorSet_340           0x8ce4
+#define REG_3D_TexColorBlendSet00_340   0x8d20
+#define REG_3D_Tex0Set_340              0x8e00
+#define REG_3D_PSSet1_771               0x8fc4
+
+#define REG_3D_PSInitRead0_771          0x9064
+#define REG_3D_FrontEnable0_340	0x9400
+#define REG_3D_Stream01CopyType_340     0x9520
+#define REG_3D_SwapColor_340            0x9540
+#define REG_3D_VtxActiveL_340		0x9560
+#define REG_3D_FTexCoordDim_340         0x9620
+#define REG_GL_ScaleX_340               0x9880
+#define REG_GL_LSet_340                 0x98a4
+
+#define REG_3D_EngineId_671             0x8fc8
+#define REG_3D_ParserFire_340           0x9f04
+#define REG_3D_ListEnd_340              0x9f84
+
+
+/***** Valuables *****/
+#define VAL_FlatShadeA_340          0x00000800
+#define VAL_FireMode_Vertex_340     0x00000004
+#define VAL_LEnd_TSRCA_340          0x00000003
+#define VAL_SolidFill_340           0x03000000
+#define VAL_SolidCCWFill_340        0x0c000000
+#define VAL_Dst_A8R8G8B8_340        0x00300000 
+#define VAL_Dst_R5G6B5_340          0x00110000
+#define VAL_Tex_A8R8G8B8_340        0x60000000
+#define VAL_CBLSRC_One_340              0x01
+#define VAL_CBLDST_InvSrc_Alpha_340     0x05
+#define VAL_PSReName_NormalMode     0x08000000
+#define VAL_PS_PixelNum64_340       0x00300000
+#define VAL_Tex_MinNearest_340      0x00000000
+#define VAL_Tex_MagNearest_340      0x00000000
+#define VAL_TxL0InSys_340           0x00100000
+#define SHT_TXW_340                 15
+#define VAL_DType_TriStrip_340      0x00000009
+
+
+
+#define SNAP4_CONSTANT  786432.0f     /* 2^18 + 2^19 */
+#define SNAP6_CONSTANT  196608.0f     /* 2^16 + 2^17 */
+
+#define INI_BlendMode_340           0x001ff000
+#define NUM_MAX_PS_CONST340             32
+#define PS_CNST_DWSIZE  4
+#define NUM_MAX_PS_INST340     128  
+#define PS_INST_DWSIZE  2
+
+#define SHT_TnDiffuse_771            16 
+#define SHT_TnSpecular_771         20
+#define SHT_FrontTXNUM_340          16
+#define SHT_TXNUM_340               12
+
+
+#define MSK_XDisableClip_340        0xfc000000
+#define MSK_RGXScrCoor_340          0x00000020
+#define MSK_En_DisableCull_340      0x00000004
+#define MSK_En_DisableReject_340    0x00000002
+#define MSK_En_DisableZeroTest_340  0x00000001
+#define MSK_DiffPresent_340         0x00000080
+#define MSK_En_Blend_340            0x00000100
+#define MSK_En_TexCache_340         0x00100000
+#define MSK_En_TexL2Cache_340       0x00040000
+#define MSK_En_AGPRqBurst_340       0x00000010
+#define MSK_En_DRAM128b_342         0x00000080
+#define MSK_En_PixelShader_340      0x00000008
+#define MSK_En_ArbPreCharge_340     0x00000100
+#define MSK_PS_ElementGamma_340     0xf0000000
+#define MSK_TXNonPwdTwo_340         0x00080000
+#define MSK_En_TexMap_340	    0x00080000
+#define MSK_EGenTXInitR		    0x00000020
+
+
+
+#define CMD_QUEUE_CHECK128_Null_3D \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	if (ttt % 16){\
+		SiSWaitQueue(8); \
+		SIS_WQINDEX(0) = (CARD32)(0x368f0000); \
+		SIS_WQINDEX(1) = (CARD32)(0x368f0000); \
+		ttt += 8;\
+		ttt &= pSiS->cmdQueueSizeMask;\
+		SiSSetSwWP(ttt); \
+	}\
+}
+
+#define SiS3DClearTexCache \
+{ \
+	int i; \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	unsigned long dwTEnable = 0x001e0080; \
+	for (i = 0; i<4; i++) {\
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(i*4) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_TEnable1_340); \
+	SIS_WQINDEX(i*4+1) = (CARD32)(dwTEnable); \
+	SIS_WQINDEX(i*4+2) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_TEnable1_340); \
+	SIS_WQINDEX(i*4+3) = (CARD32)(dwTEnable); \
+	SiSUpdateQueue \
+	}\
+	SiSSetSwWP(ttt); \
+}
+
+
+#define SiS3DEnableSet(dwEnable0, dwEnable1, dwEnable2) \
+{ \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_TEnable0_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100006);\
+	SIS_WQINDEX(2) = (CARD32)(dwEnable0);\
+	SIS_WQINDEX(3) = (CARD32)(dwEnable1);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(dwEnable2); \
+	SIS_WQINDEX(5) = (CARD32)(0x0L); \
+	SIS_WQINDEX(6) = (CARD32)(0x0L); \
+	SIS_WQINDEX(7) = (CARD32)(0x0L); \
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DFrontEnableSet(dwFrontEnable2) \
+{ \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_FrontEnable0_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100006);\
+	SIS_WQINDEX(2) = (CARD32)(0x0L);	\
+	SIS_WQINDEX(3) = (CARD32)(VAL_FlatShadeA_340);/* FrontEnable1 */	\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(dwFrontEnable2); /* FrontEnable2 */\
+	SIS_WQINDEX(5) = (CARD32)(MSK_RGXScrCoor_340 |MSK_En_DisableCull_340 |MSK_En_DisableReject_340 |MSK_En_DisableZeroTest_340); /* FrontEnable3 */\
+	SIS_WQINDEX(6) = (CARD32)(MSK_XDisableClip_340);\
+	SIS_WQINDEX(7) = (CARD32)(0x0L);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+
+#define SiS3DSetupDestination0Set(set, CWrMask) \
+{ \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_Dst0Set_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100002);\
+	SIS_WQINDEX(2) = (CARD32)(set); \
+	SIS_WQINDEX(3) = (CARD32)(CWrMask);	\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupDestination0Addr(Addr) \
+{ \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_Dst0Addr_340); \
+	SIS_WQINDEX(1) = (CARD32)(Addr);\
+	SIS_WQINDEX(2) = (CARD32)(0x368f0000); \
+	SIS_WQINDEX(3) = (CARD32)(0x368f0000);	\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+
+
+#define SiS3DSetupClippingRange(TB, LR) \
+{ \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_ClipTopBottom_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100002);\
+	SIS_WQINDEX(2) = (CARD32)(TB); \
+	SIS_WQINDEX(3) = (CARD32)(LR);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupIdentityT1WVInvWV \
+{\
+	int i;\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ParserFire_340); \
+	SIS_WQINDEX(1) = (CARD32)((0x0) << 24) | ((0x0)<<16) | 0x8; /* Packet type */\
+	SIS_WQINDEX(2) = (CARD32)(0xb68a0000); /* 3D Packet command*/\
+	SIS_WQINDEX(3) = (CARD32)(0x62100000 | 40);\
+	SiSUpdateQueue \
+	for (i=0; i<40; i++){\
+		if(i%4 == 0){\
+			SiSWaitQueue(16); \
+			SIS_WQINDEX(i+4) = (CARD32)(HwIdentityMatrix_340[i]); \
+			SIS_WQINDEX(i+5) = (CARD32)(HwIdentityMatrix_340[i+1]);\
+			SIS_WQINDEX(i+6) = (CARD32)(HwIdentityMatrix_340[i+2]);\
+			SIS_WQINDEX(i+7) = (CARD32)(HwIdentityMatrix_340[i+3]);\
+			SiSUpdateQueue \
+		}\
+	}\
+	SiSSetSwWP(ttt); \
+}
+
+
+#define SiS3DSetupIdentityT2 \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_GL_ScaleX_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100006);	\
+	SIS_WQINDEX(2) = (CARD32)(1.0f);\
+	SIS_WQINDEX(3) = (CARD32)(SNAP4_CONSTANT);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(1.0f); \
+	SIS_WQINDEX(5) = (CARD32)(SNAP4_CONSTANT);	\
+	SIS_WQINDEX(6) = (CARD32)(1.0f);\
+	SIS_WQINDEX(7) = (CARD32)(0.0f);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupTextureSet(TexSet) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_TexSet_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100004);	\
+	SIS_WQINDEX(2) = (CARD32)(TexSet);\
+	SIS_WQINDEX(3) = (CARD32)(0L);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(0L);\
+	SIS_WQINDEX(5) = (CARD32)(0L);\
+	SIS_WQINDEX(6) = (CARD32)(0x368f0000); /*alignment */\
+	SIS_WQINDEX(7) = (CARD32)(0x368f0000); /*alignment */\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupAlphaBlend(BlendMode, BlendCst) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_BlendMode_340); \
+	SIS_WQINDEX(1) = (CARD32)(BlendMode);	\
+	SIS_WQINDEX(2) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_AlphaBlendConstant_340);\
+	SIS_WQINDEX(3) = (CARD32)(BlendCst);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupShaderMRT(PsSet, DstNum) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_PSInit_340); \
+	SIS_WQINDEX(1) = (CARD32)(PsSet);	\
+	SIS_WQINDEX(2) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_MRTCWMask0_340);\
+	SIS_WQINDEX(3) = (CARD32)(0x62100004);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(MRTCWMask[DstNum][0]);\
+	SIS_WQINDEX(5) = (CARD32)(MRTCWMask[DstNum][1]);\
+	SIS_WQINDEX(6) = (CARD32)(0L); /*alignment */\
+	SIS_WQINDEX(7) = (CARD32)(0L); /*alignment */\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupInitRead0(PsSet1, InitRead) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_PSSet1_771); \
+	SIS_WQINDEX(1) = (CARD32)(PsSet1);	\
+	SIS_WQINDEX(2) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_PSInitRead0_771);\
+	SIS_WQINDEX(3) = (CARD32)(InitRead);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupPixelCst(count, cnst) \
+{\
+	int i; \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ParserFire_340); \
+	SIS_WQINDEX(1) = (CARD32)((0x10) << 24) | ((0x0)<<16) | 0x8; /* Packet type */\
+	SIS_WQINDEX(2) = (CARD32)(0xb68a0000); /* 3D Packet command*/\
+	SIS_WQINDEX(3) = (CARD32)(0x62100000 | count);\
+	SiSUpdateQueue \
+	\
+	SiSWaitQueue(count*4); \
+	for (i=0; i<count; i++)	SIS_WQINDEX(i+4) = (CARD32)(cnst[i]); \
+	ttt += count*4;\
+	ttt &= pSiS->cmdQueueSizeMask;\
+	SiSSetSwWP(ttt); \
+	CMD_QUEUE_CHECK128_Null_3D \
+}
+
+#define SiS3DSetupPixelInst(count, inst) \
+{\
+	int i;\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ParserFire_340); \
+	SIS_WQINDEX(1) = (CARD32)((0x11) << 24) | ((0x0)<<16) | 0x8; /* Packet type */\
+	SIS_WQINDEX(2) = (CARD32)(0xb68a0000); /* 3D Packet command*/\
+	SIS_WQINDEX(3) = (CARD32)(0x62100000 | count);\
+	SiSUpdateQueue \
+	\
+	SiSWaitQueue(count*4); \
+	for (i=0; i<count; i++)	SIS_WQINDEX(i+4) = (CARD32)(inst[i]); \
+	ttt += count*4;\
+	ttt &= pSiS->cmdQueueSizeMask;\
+	SiSSetSwWP(ttt); \
+	CMD_QUEUE_CHECK128_Null_3D \
+}
+
+
+#define SiS3DSetupBackCoordinate(coord) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_TexCoorSet_340); \
+	SIS_WQINDEX(1) = (CARD32)(coord);\
+	SIS_WQINDEX(2) = (CARD32)(0x368f0000);\
+	SIS_WQINDEX(3) = (CARD32)(0x368f0000);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+
+#define SiS3DTexture0Setting(set0, set1, depth, size, adder) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(64); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_Tex0Set_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100004); \
+	SIS_WQINDEX(2) = (CARD32)(set0);\
+	/*After SiS771, driver can support video stretchblt when video source in AGP. v3.78.03*/ \
+	SIS_WQINDEX(3) = (CARD32)(set1 & ~0x100000);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(depth); \
+	SIS_WQINDEX(5) = (CARD32)(size); \
+ 	SIS_WQINDEX(6) = (CARD32)(0x368f0000);\
+	SIS_WQINDEX(7) = (CARD32)(0x368f0000);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(8) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ParserFire_340); \
+	SIS_WQINDEX(9) = (CARD32)(((0x12) << 24) | (0<<16) | 0x8);/* Packet type */ \
+	SIS_WQINDEX(10) = (CARD32)(0xb68a0000);\
+	SIS_WQINDEX(11) = (CARD32)(0x62100004);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(12) = (CARD32)(adder); \
+	SIS_WQINDEX(13) = (CARD32)(0L); \
+	SIS_WQINDEX(14) = (CARD32)(0L);\
+	SIS_WQINDEX(15) = (CARD32)(0L);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt);\
+}
+
+
+#define SiS3DSetupTexture0Pitch(pitch) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ParserFire_340); \
+	SIS_WQINDEX(1) = (CARD32)(((0x14) << 24) | (0<<16) | 0x8);/* Packet type */ \
+	SIS_WQINDEX(2) = (CARD32)(0xb68a0000);\
+	SIS_WQINDEX(3) = (CARD32)(0x62100004);\
+	SiSUpdateQueue \
+	\
+	SIS_WQINDEX(4) = (CARD32)(pitch); \
+	SIS_WQINDEX(5) = (CARD32)(0L); \
+	SIS_WQINDEX(6) = (CARD32)(0L);\
+	SIS_WQINDEX(7) = (CARD32)(0L);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt);\
+}
+
+#define SiS3DSetupDimLight(TexCoordDim) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_FTexCoordDim_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100004);\
+	SIS_WQINDEX(2) = (CARD32)(TexCoordDim);\
+	SIS_WQINDEX(3) = (CARD32)(0L);/* no wrap*/\
+	SiSUpdateQueue \
+	SIS_WQINDEX(4) = (CARD32)(0L);/* no wrap*/\
+	SIS_WQINDEX(5) = (CARD32)(0x000007ff);\
+	SIS_WQINDEX(6) = (CARD32)(SIS_3D_SPKC_HEADER + REG_GL_LSet_340);\
+	SIS_WQINDEX(7) = (CARD32)(MSK_DiffPresent_340);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupVertexVector(TexCrdIdx) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_Stream01CopyType_340); \
+	SIS_WQINDEX(1) = (CARD32)(0x62100006);\
+	SIS_WQINDEX(2) = (CARD32)(0x00008040 | FVF_TexCoord_771[TexCrdIdx][0]);\
+	SIS_WQINDEX(3) = (CARD32)(FVF_TexCoord_771[TexCrdIdx][1]);\
+	SiSUpdateQueue \
+	SIS_WQINDEX(4) = (CARD32)(FVF_TexCoord_771[TexCrdIdx][2]);\
+	SIS_WQINDEX(5) = (CARD32)(FVF_TexCoord_771[TexCrdIdx][3]);\
+	SIS_WQINDEX(6) = (CARD32)(FVF_TexCoord_771[TexCrdIdx][4]);\
+	SIS_WQINDEX(7) = (CARD32)(FVF_TexCoord_771[TexCrdIdx][5]);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DPrimitiveSet \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_FSAA_PrimType_340);\
+	SIS_WQINDEX(1) = (CARD32)(VAL_DType_TriStrip_340);\
+	SIS_WQINDEX(2) = (CARD32)(0x368f0000);\
+	SIS_WQINDEX(3) = (CARD32)(0x368f0000);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+
+#define SiS3DSetupStream(TexCoorNum, TexCoorExtNum, ExtDWNum)\
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(32); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_BUST_HEADER + REG_3D_VtxActiveL_340);\
+	SIS_WQINDEX(1) = (CARD32)(0x62100006);\
+	SIS_WQINDEX(2) = (CARD32)(VertexActBitsL_771[TexCoorNum] | (VertexActBitsLEx_771[TexCoorExtNum]<<(3+TexCoorNum*2)) );\
+	SIS_WQINDEX(3) = (CARD32)(0L);\
+	SiSUpdateQueue \
+	SIS_WQINDEX(4) = (CARD32)(0L);\
+	SIS_WQINDEX(5) = (CARD32)(0L);\
+	SIS_WQINDEX(6) = (CARD32)( ((TexCoorExtNum + TexCoorNum)<<16) | (3 + TexCoorNum*2 + ExtDWNum) );\
+	SIS_WQINDEX(7) = (CARD32)(4L);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+
+#define SiS3DSetupSwapColor \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_SwapColor_340); \
+	SIS_WQINDEX(1) = (CARD32)(0L);\
+	SIS_WQINDEX(2) = (CARD32)(0x368f0000);\
+	SIS_WQINDEX(3) = (CARD32)(0x368f0000);\
+	SiSUpdateQueue \
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DSetupVertexData(vertex) \
+{\
+	int i; \
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(160); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ParserFire_340); \
+	SIS_WQINDEX(1) = (CARD32)(VAL_FireMode_Vertex_340);\
+	SIS_WQINDEX(2) = (CARD32)(0xb68a0000);\
+	SIS_WQINDEX(3) = (CARD32)(0x62100000 | 36);\
+	for(i=0; i<4; i++){\
+		SIS_WQINDEX(4+i*9) = (CARD32)(vertex[i].sx);\
+		SIS_WQINDEX(5+i*9) = (CARD32)(vertex[i].sy);\
+		SIS_WQINDEX(6+i*9) = (CARD32)(vertex[i].sz);\
+		SIS_WQINDEX(7+i*9) = (CARD32)(vertex[i].tu);\
+		SIS_WQINDEX(8+i*9) = (CARD32)(vertex[i].tv);\
+		SIS_WQINDEX(9+i*9) = (CARD32)(vertex[i].u);\
+		SIS_WQINDEX(10+i*9) = (CARD32)(vertex[i].v);\
+		SIS_WQINDEX(11+i*9) = (CARD32)(vertex[i].m);\
+		SIS_WQINDEX(12+i*9) = (CARD32)(vertex[i].n);\
+	}\
+	ttt += 160;\
+	ttt &= pSiS->cmdQueueSizeMask;\
+	SiSSetSwWP(ttt); \
+}
+
+#define SiS3DListEnd(EngineId, Stamp) \
+{\
+	CARD32 ttt = SiSGetSwWP(); \
+	pointer tt = (char *)pSiS->cmdQueueBase + ttt; \
+	SiSWaitQueue(16); \
+	SIS_WQINDEX(0) = (CARD32)(SIS_3D_SPKC_HEADER + REG_3D_ListEnd_340); \
+	SIS_WQINDEX(1) = (CARD32)(VAL_LEnd_TSRCA_340);\
+	SIS_WQINDEX(2) = (CARD32)(SIS_3D_SPKC_HEADER + EngineId);\
+	SIS_WQINDEX(3) = (CARD32)(Stamp);\
+	SiSUpdateQueue \
+	SiSSetHwWP(ttt); \
+}
+
diff --git a/src/sis_accel.c b/src/sis_accel.c
index e524115..aec88bd 100644
--- a/src/sis_accel.c
+++ b/src/sis_accel.c
@@ -493,10 +493,9 @@ SiSPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planemask, Pixel fg)
 	/* Check that the pitch matches the hardware's requirements. Should
 	 * never be a problem due to pixmapPitchAlign and fbScreenInit.
 	 */
-	if(exaGetPixmapPitch(pPixmap) & 7)
+	if((pSiS->fillPitch = exaGetPixmapPitch(pPixmap)) & 7)
 	   return FALSE;
 
-	pSiS->fillPitch = exaGetPixmapPitch(pPixmap);
 	pSiS->fillBpp = pPixmap->drawable.bitsPerPixel >> 3;
 	pSiS->fillDstBase = (CARD32)exaGetPixmapOffset(pPixmap);
 
@@ -546,16 +545,14 @@ SiSPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir, int ydir,
 	/* Check that the pitch matches the hardware's requirements. Should
 	 * never be a problem due to pixmapPitchAlign and fbScreenInit.
 	 */
-	if(exaGetPixmapPitch(pSrcPixmap) & 3)
+	if((pSiS->copySPitch = exaGetPixmapPitch(pSrcPixmap)) & 3)
 	   return FALSE;
-	if(exaGetPixmapPitch(pDstPixmap) & 7)
+	if((pSiS->copyDPitch = exaGetPixmapPitch(pDstPixmap)) & 7)
 	   return FALSE;
 
 	pSiS->copyXdir = xdir;
 	pSiS->copyYdir = ydir;
 	pSiS->copyBpp = pSrcPixmap->drawable.bitsPerPixel >> 3;
-	pSiS->copySPitch = exaGetPixmapPitch(pSrcPixmap);
-	pSiS->copyDPitch = exaGetPixmapPitch(pDstPixmap);
 	pSiS->copySrcBase = (CARD32)exaGetPixmapOffset(pSrcPixmap);
 	pSiS->copyDstBase = (CARD32)exaGetPixmapOffset(pDstPixmap);
 
@@ -619,7 +616,6 @@ static void
 SiSDoneCopy(PixmapPtr pDstPixmap)
 {
 }
-
 #endif /* EXA */
 
 /* For DGA usage */
@@ -666,6 +662,23 @@ SiSAccelInit(ScreenPtr pScreen)
     pSiS->exa_scratch = NULL;
 #endif
 
+#if 1
+#ifdef SIS_USE_EXA
+    if(!pSiS->NoAccel) {
+       if(pSiS->useEXA && pScrn->bitsPerPixel == 24) {
+          if(exaGetVersion() <= EXA_MAKE_VERSION(0, 1, 0)) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"This version of EXA is broken for 24bpp framebuffers\n");
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"\t- disabling 2D acceleration and Xv\n");
+	     pSiS->NoAccel = TRUE;
+	     pSiS->NoXvideo = TRUE; /* No fbmem manager -> no xv */
+	  }
+       }
+    }
+#endif
+#endif
+
     if(!pSiS->NoAccel) {
 #ifdef SIS_USE_XAA
        if(!pSiS->useEXA) {
@@ -675,7 +688,7 @@ SiSAccelInit(ScreenPtr pScreen)
 #endif
 #ifdef SIS_USE_EXA
        if(pSiS->useEXA) {
-	  if(!(pSiS->EXADriverPtr = exaDriverAlloc())) {
+	  if(!(pSiS->EXADriverPtr = xnfcalloc(sizeof(ExaDriverRec), 1))) {
 	     pSiS->NoAccel = TRUE;
 	     pSiS->NoXvideo = TRUE; /* No fbmem manager -> no xv */
 	  }
@@ -768,8 +781,53 @@ SiSAccelInit(ScreenPtr pScreen)
 
 #ifdef SIS_USE_EXA	/* ----------------------- EXA ----------------------- */
        if(pSiS->useEXA) {
+#if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+
+	  /* data */
+	  pSiS->EXADriverPtr->card.memoryBase = pSiS->FbBase;
+	  pSiS->EXADriverPtr->card.memorySize = pSiS->maxxfbmem;
+	  pSiS->EXADriverPtr->card.offScreenBase = pScrn->displayWidth * pScrn->virtualY
+						* (pScrn->bitsPerPixel >> 3);
+	  if(pSiS->EXADriverPtr->card.memorySize > pSiS->EXADriverPtr->card.offScreenBase) {
+	     pSiS->EXADriverPtr->card.flags = EXA_OFFSCREEN_PIXMAPS;
+	  } else {
+	     pSiS->NoXvideo = TRUE;
+	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		"Not enough video RAM for offscreen memory manager. Xv disabled\n");
+	  }
+#if  XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(6,8,2,0,0)
+	  pSiS->EXADriverPtr->card.offscreenByteAlign = 8;	/* src/dst: double quad word boundary */
+	  pSiS->EXADriverPtr->card.offscreenPitch = 1;
+#else
+	  pSiS->EXADriverPtr->card.pixmapOffsetAlign = 8;	/* src/dst: double quad word boundary */
+	  pSiS->EXADriverPtr->card.pixmapPitchAlign = 8;	/* could possibly be 1, but who knows for sure */
+#endif
+	  pSiS->EXADriverPtr->card.maxX = 2047;
+	  pSiS->EXADriverPtr->card.maxY = 2047;
+
+	  /* Sync */
+	  pSiS->EXADriverPtr->accel.WaitMarker = SiSEXASync;
+
+	  /* Solid fill */
+	  pSiS->EXADriverPtr->accel.PrepareSolid = SiSPrepareSolid;
+	  pSiS->EXADriverPtr->accel.Solid = SiSSolid;
+	  pSiS->EXADriverPtr->accel.DoneSolid = SiSDoneSolid;
+
+	  /* Copy */
+	  pSiS->EXADriverPtr->accel.PrepareCopy = SiSPrepareCopy;
+	  pSiS->EXADriverPtr->accel.Copy = SiSCopy;
+	  pSiS->EXADriverPtr->accel.DoneCopy = SiSDoneCopy;
+
+	  /* Composite not supported */
+
+	  /* Upload, download to/from Screen */
+	  pSiS->EXADriverPtr->accel.UploadToScreen = SiSUploadToScreen;
+	  pSiS->EXADriverPtr->accel.DownloadFromScreen = SiSDownloadFromScreen;
+
+#else /*xorg>=7.0*/
+
 	  pSiS->EXADriverPtr->exa_major = 2;
-	  pSiS->EXADriverPtr->exa_major = 0;
+	  pSiS->EXADriverPtr->exa_minor = 0;
 
 	  /* data */
 	  pSiS->EXADriverPtr->memoryBase = pSiS->FbBase;
@@ -807,6 +865,7 @@ SiSAccelInit(ScreenPtr pScreen)
 	  pSiS->EXADriverPtr->UploadToScreen = SiSUploadToScreen;
 	  pSiS->EXADriverPtr->DownloadFromScreen = SiSDownloadFromScreen;
 
+#endif  /*end of Xorg>=7.0 EXA Setting*/       
        }
 #endif /* EXA */
 
@@ -887,7 +946,11 @@ SiSAccelInit(ScreenPtr pScreen)
 						SiSScratchSave, pSiS);
 	  if(pSiS->exa_scratch) {
 	     pSiS->exa_scratch_next = pSiS->exa_scratch->offset;
-	     pSiS->EXADriverPtr->UploadToScratch = SiSUploadToScratch;
+       #if  XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,0,0,0,0)
+             pSiS->EXADriverPtr->accel.UploadToScratch = SiSUploadToScratch;
+       #else
+             pSiS->EXADriverPtr->UploadToScratch = SiSUploadToScratch;
+       #endif
 	  }
 
        } else {
diff --git a/src/sis_config.h b/src/sis_config.h
new file mode 100644
index 0000000..d2b6758
--- /dev/null
+++ b/src/sis_config.h
@@ -0,0 +1,85 @@
+/* $XFree86$ */
+/* $XdotOrg$ */
+/*
+ * Configurable compile-time options
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2) Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3) The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author:   Thomas Winischhofer <thomas@winischhofer.net>
+ *
+ */
+
+#undef SISDUALHEAD
+#undef SISMERGED
+#undef SISXINERAMA
+#undef SIS_ARGB_CURSOR
+#undef SISVRAMQ
+#undef INCL_YUV_BLIT_ADAPTOR
+#undef SIS_USE_XAA
+#undef SIS_USE_EXA
+
+/* Configurable stuff: ------------------------------------- */
+
+#define SISDUALHEAD		/* Include Dual Head support  */
+
+#define SISMERGED		/* Include Merged-FB support */
+
+#undef SISXINERAMA
+#ifdef SISMERGED
+#define SISXINERAMA		/* Include SiS Pseudo-Xinerama support for MergedFB mode */
+#endif
+
+#if 1
+#define SIS_ARGB_CURSOR		/* Include support for color hardware cursors */
+#endif
+
+#if 1
+#define SISVRAMQ		/* Use VRAM queue mode support on 315+ series */
+#endif
+
+#undef INCL_YUV_BLIT_ADAPTOR
+#ifdef SISVRAMQ
+#if 1
+#define INCL_YUV_BLIT_ADAPTOR	/* Include support for YUV->RGB blit adaptors (VRAM queue mode only) */
+#endif
+#endif
+
+#if 1
+#define SIS_USE_XAA		/* Include support for XAA */
+#endif
+
+#ifdef SISVRAMQ
+#ifdef XORG_VERSION_CURRENT
+#if defined(SIS_HAVE_EXA) || (defined(XF86EXA) && (XF86EXA != 0))
+#if 1
+#define SIS_USE_EXA		/* Include support for EXA */
+#endif
+#endif
+#endif
+#endif
+
+/* End of configurable stuff --------------------------------- */
+
+
diff --git a/src/sis_cursor.c b/src/sis_cursor.c
index 1efcfb4..8e40c99 100644
--- a/src/sis_cursor.c
+++ b/src/sis_cursor.c
@@ -55,20 +55,53 @@
 extern void    SISWaitRetraceCRT1(ScrnInfoPtr pScrn);
 extern void    SISWaitRetraceCRT2(ScrnInfoPtr pScrn);
 
+/* Preface statement: All routines in this file are being executed
+ * asynchronously if SilkenMouse support is enabled (which it is by
+ * default). We need to restore the hardware state.
+ */
+
+/*******************************************/
+/*                 Helpers                 */
+/*******************************************/
+
+
+static void
+SiSUploadMonoCursor(SISPtr pSiS, Bool ds, UChar *src, UChar *dst)
+{
+    UChar *finaldest = dst;
+    UChar *finalsrc = src;
+    int i;
+
+    if(ds) {
+       for(i = 0; i < 32; i++) {
+	  SiSMemCopyToVideoRam(pSiS, finaldest + (32 * i), finalsrc + (16 * i), 16);
+	  SiSMemCopyToVideoRam(pSiS, finaldest + (32 * i) + 16, finalsrc + (16 * i), 16);
+       }
+    } else {
+       SiSMemCopyToVideoRam(pSiS, finaldest, finalsrc, 1024);
+    }
+}
+
+static void
+SiSUploadColorCursor(SISPtr pSiS, Bool ds, UChar *src, CARD32 *dst, int widthheight)
+{
+    SiSMemCopyToVideoRam(pSiS, (UChar *)dst, src, widthheight * 4 * widthheight);
+}
+
 /* Helper function for Xabre to convert mono image to ARGB */
 /* The Xabre's cursor engine for CRT2 is buggy and can't
  * handle mono cursors. We therefore convert the mono image
- * to ARGB
+ * to ARGB.
  */
 static void
 SiSXConvertMono2ARGB(SISPtr pSiS)
 {
    UChar  *src = pSiS->CurMonoSrc;
-   CARD32 *dest = pSiS->CurARGBDest;
+   CARD32 *dest = (CARD32 *)pSiS->CursorScratch;
    CARD8  chunk, mask;
    CARD32 fg = pSiS->CurFGCol | 0xff000000;
    CARD32 bg = pSiS->CurBGCol | 0xff000000;
-   int i,j,k;
+   int i, j, k;
 
    if(!dest || !src) return;
 
@@ -84,6 +117,9 @@ SiSXConvertMono2ARGB(SISPtr pSiS)
       }
       src += 8;
    }
+
+   SiSUploadColorCursor(pSiS, pSiS->CursorDoubleSize, (UChar *)pSiS->CursorScratch,
+   						(CARD32 *)pSiS->CurARGBDest, 64);
 }
 
 #ifdef SISDUALHEAD
@@ -100,12 +136,33 @@ UpdateHWCursorStatus(SISPtr pSiS)
 }
 #endif
 
+
+/*******************************************/
+/*   Old series (5597/5598/6326/530/620)   */
+/*******************************************/
+
+static Bool
+SiSUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
+{
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    SISPtr pSiS = SISPTR(pScrn);
+
+    /* TODO: Doublescan? Interlace? */
+
+    if(pSiS->sis6326tvumode)
+       return FALSE;
+
+    return TRUE;
+}
+
 static void
 SiSHideCursor(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
     UChar  sridx, cridx;
 
+    /* Beware: This is executed asynchronously. */
+
     sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
 
 #ifdef UNLOCK_ALWAYS
@@ -118,232 +175,210 @@ SiSHideCursor(ScrnInfoPtr pScrn)
 }
 
 static void
-SiS300HideCursor(ScrnInfoPtr pScrn)
+SiSShowCursor(ScrnInfoPtr pScrn)
 {
-    SISPtr  pSiS = SISPTR(pScrn);
+    SISPtr pSiS = SISPTR(pScrn);
+    UChar  sridx, cridx;
 
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode && (!pSiS->ForceCursorOff)) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-	  sis300DisableHWCursor()
-	  sis300SetCursorPositionY(2000, 0)
-       } else {
-	  /* Head 1 is always CRT2 */
-	  sis301DisableHWCursor()
-	  sis301SetCursorPositionY(2000, 0)
-       }
-    } else {
-#endif
-       sis300DisableHWCursor()
-       sis300SetCursorPositionY(2000, 0)
-       if(pSiS->VBFlags & CRT2_ENABLE)  {
-          sis301DisableHWCursor()
-	  sis301SetCursorPositionY(2000, 0)
-       }
-#ifdef SISDUALHEAD
-    }
+    /* Beware: This is executed asynchronously. */
+
+    sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
+
+    orSISIDXREG(SISSR, 0x06, 0x40);
+
+    outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
 }
 
 static void
-SiS310HideCursor(ScrnInfoPtr pScrn)
+SiSSetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
 {
-    SISPtr  pSiS = SISPTR(pScrn);
+    SISPtr pSiS = SISPTR(pScrn);
+    DisplayModePtr mode = pSiS->CurrentLayout.mode;
+    UChar  x_preset = 0;
+    UChar  y_preset = 0;
+    UChar  sridx, cridx;
 
-    pSiS->HWCursorIsVisible = FALSE;
+    /* Beware: This is executed asynchronously. */
 
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode && (!pSiS->ForceCursorOff)) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-   	  sis310DisableHWCursor()
-  	  sis310SetCursorPositionY(2000, 0)
-       } else {
-	  /* Head 1 is always CRT2 */
-	  sis301DisableHWCursor310()
-	  sis301SetCursorPositionY310(2000, 0)
-       }
-    } else {
+    sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
-       sis310DisableHWCursor()
-       sis310SetCursorPositionY(2000, 0)
-       if(pSiS->VBFlags2 & VB2_VIDEOBRIDGE) {
-	  sis301DisableHWCursor310()
-	  sis301SetCursorPositionY310(2000, 0)
-       }
-#ifdef SISDUALHEAD
+
+    if(mode->Flags & V_INTERLACE)     y /= 2;
+    else if(mode->Flags & V_DBLSCAN)  y *= 2;
+
+    if(x < 0) {
+       x_preset = (-x);
+       if(x_preset > 63) x_preset = 63;
+       x = 0;
     }
-#endif
+
+    if(y < 0) {
+       y_preset = (-y);
+       if(y_preset > 63) y_preset = 63;
+       y = 0;
+    }
+
+    outSISIDXREG(SISSR, 0x1A, (x & 0xff));
+    outSISIDXREG(SISSR, 0x1B, ((x >> 8) & 0xff));
+
+    outSISIDXREG(SISSR, 0x1D, (y & 0xff));
+    setSISIDXREG(SISSR, 0x1E, 0xF8, ((y >> 8) & 0x07));
+
+    outSISIDXREG(SISSR, 0x1C, x_preset);
+    outSISIDXREG(SISSR, 0x1F, y_preset);
+
+    outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
 }
 
 static void
-SiSShowCursor(ScrnInfoPtr pScrn)
+SiSSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
 {
     SISPtr pSiS = SISPTR(pScrn);
     UChar  sridx, cridx;
 
-    /* Backup current indices of SR and CR since we run async:ly
-     * and might be interrupting an on-going register read/write
-     */
+    /* Beware: This is executed asynchronously. */
+
     sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
 
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
 
-    orSISIDXREG(SISSR, 0x06, 0x40);
+    outSISIDXREG(SISSR, 0x14, ((bg & 0x00FF0000) >> (16+2)));
+    outSISIDXREG(SISSR, 0x15, ((bg & 0x0000FF00) >> (8+2)));
+    outSISIDXREG(SISSR, 0x16, ((bg & 0x000000FF) >> 2));
+    outSISIDXREG(SISSR, 0x17, ((fg & 0x00FF0000) >> (16+2)));
+    outSISIDXREG(SISSR, 0x18, ((fg & 0x0000FF00) >> (8+2)));
+    outSISIDXREG(SISSR, 0x19, ((fg & 0x000000FF) >> 2));
 
     outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
 }
 
 static void
-SiS300ShowCursor(ScrnInfoPtr pScrn)
+SiSLoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
 {
-    SISPtr  pSiS = SISPTR(pScrn);
+    SISPtr pSiS = SISPTR(pScrn);
+    DisplayModePtr mode = pSiS->CurrentLayout.mode;
+    ULong  cursor_addr;
+    UChar  sridx, cridx;
+    Bool doublesize = FALSE;
 
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-	  if(pSiS->UseHWARGBCursor) {
-	     sis300EnableHWARGBCursor()
-	  } else {
-	     sis300EnableHWCursor()
-	  }
-       } else {
-	  /* Head 1 is always CRT2 */
-	  if(pSiS->UseHWARGBCursor) {
-	     sis301EnableHWARGBCursor()
-	  } else {
-	     sis301EnableHWCursor()
-	  }
-       }
-    } else {
+    /* Beware: This is executed asynchronously. */
+
+    sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
-       if(pSiS->UseHWARGBCursor) {
-	  sis300EnableHWARGBCursor()
-	  if(pSiS->VBFlags & CRT2_ENABLE)  {
-	     sis301EnableHWARGBCursor()
-	  }
+
+    cursor_addr = pScrn->videoRam - 1;
+
+    if(mode->Flags & V_DBLSCAN) doublesize = TRUE;
+
+    SiSUploadMonoCursor(pSiS, doublesize, src, (UChar *)pSiS->RealFbBase + (cursor_addr * 1024));
+
+    pSiS->CursorW = 64;
+    pSiS->CursorH = doublesize ? 32 : 64;
+
+    /* copy D[21:18] into the top bits of SR38 */
+    setSISIDXREG(SISSR, 0x38, 0x0f, ((cursor_addr & 0xF00) >> 4));
+
+    if(pSiS->Chipset == PCI_CHIP_SIS530) {
+       /* store the D[22] to SR3E */
+       if(cursor_addr & 0x1000) {
+          orSISIDXREG(SISSR, 0x3E, 0x04);
        } else {
-	  sis300EnableHWCursor()
-	  if(pSiS->VBFlags & CRT2_ENABLE)  {
-             sis301EnableHWCursor()
-	  }
+          andSISIDXREG(SISSR, 0x3E, ~0x04);
        }
-#ifdef SISDUALHEAD
     }
-#endif
+
+    /* set HW cursor pattern, use pattern 0xF */
+    /* disable the hardware cursor side pattern */
+    setSISIDXREG(SISSR, 0x1E, 0xF7, 0xF0);
+
+    outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
 }
 
-static void
-SiS310ShowCursor(ScrnInfoPtr pScrn)
+/*******************************************/
+/*     Common for 300 series and later     */
+/*******************************************/
+
+static Bool
+SiSNewUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
 {
-    SISPtr  pSiS = SISPTR(pScrn);
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    SISPtr pSiS = SISPTR(pScrn);
+    int size = pCurs->bits->height;
 
-    if(pSiS->HideHWCursor) {
-       SiS310HideCursor(pScrn);
-       pSiS->HWCursorIsVisible = TRUE;
-       return;
-    }
+    /* Beware: This is executed asynchronously. */
 
-    pSiS->HWCursorIsVisible = TRUE;
+    if(pSiS->MiscFlags & MISC_NOMONOHWCURSOR)
+       return FALSE;
 
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-	  if(pSiS->UseHWARGBCursor) {
-	     sis310EnableHWARGBCursor()
-	  } else {
-	     sis310EnableHWCursor()
-	  }
-       } else {
-	  /* Head 1 is always CRT2 */
-	  if(pSiS->ChipFlags & SiSCF_CRT2HWCKaputt) {
-	     sis301EnableHWCursor330()
-	  } else {
-	     if(pSiS->UseHWARGBCursor) {
-	        sis301EnableHWARGBCursor310()
-	     } else {
-	        sis301EnableHWCursor310()
-	     }
-	  }
-       }
-    } else {
-#endif
-       if(pSiS->ChipFlags & SiSCF_CRT2HWCKaputt) {
-	  if(pSiS->UseHWARGBCursor) {
-	     sis310EnableHWARGBCursor()
-	  } else {
-	     sis310EnableHWCursor()
-	  }
-	  if(pSiS->VBFlags & CRT2_ENABLE) {
-	     sis301EnableHWCursor330()
-	  }
-       } else {
-          if(pSiS->UseHWARGBCursor) {
-	     sis310EnableHWARGBCursor()
-	     if(pSiS->VBFlags & CRT2_ENABLE)  {
-	        sis301EnableHWARGBCursor310()
-	     }
-	  } else {
-	     sis310EnableHWCursor()
-	     if(pSiS->VBFlags & CRT2_ENABLE) {
-	        sis301EnableHWCursor310()
-	     }
-	  }
-       }
-#ifdef SISDUALHEAD
+    if(pSiS->MiscFlags & MISC_CURSORMAXHALF) {
+       if(size > 32)
+	  return FALSE;
     }
+
+#ifdef SISMERGED
+    pSiS->CurHotX = pCurs->bits->xhot;
+    pSiS->CurHotY = pCurs->bits->yhot;
 #endif
+
+    return TRUE;
 }
 
-static void
-SiSSetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)) && defined(ARGB_CURSOR) && defined(SIS_ARGB_CURSOR)
+static Bool
+SiSUseHWCursorARGB(ScreenPtr pScreen, CursorPtr pCurs)
 {
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
     SISPtr pSiS = SISPTR(pScrn);
-    DisplayModePtr mode = pSiS->CurrentLayout.mode;
-    UChar  x_preset = 0;
-    UChar  y_preset = 0;
-    int    temp;
-    UChar  sridx, cridx;
+    int size = pCurs->bits->height;
+    int maxsize;
 
-    sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
+    /* Beware: This is executed asynchronously. */
 
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
+    if(pSiS->MiscFlags & MISC_NORGBHWCURSOR)
+       return FALSE;
 
-    if(x < 0) {
-       x_preset = (-x);
-       x = 0;
+    switch(pSiS->VGAEngine) {
+       case SIS_300_VGA:
+	  maxsize = 32;
+	  break;
+       case SIS_315_VGA:
+	  maxsize = 64;
+	  break;
+       default:
+	  return FALSE;
     }
 
-    if(y < 0) {
-       y_preset = (-y);
-       y = 0;
-    }
-
-    if(mode->Flags & V_INTERLACE)     y /= 2;
-    else if(mode->Flags & V_DBLSCAN)  y *= 2;
-
-    outSISIDXREG(SISSR, 0x1A, x & 0xff);
-    outSISIDXREG(SISSR, 0x1B, (x & 0xff00) >> 8);
-    outSISIDXREG(SISSR, 0x1D, y & 0xff);
+    if((size > maxsize) || (pCurs->bits->width > maxsize))
+       return FALSE;
 
-    inSISIDXREG(SISSR, 0x1E, temp);
-    temp &= 0xF8;
-    outSISIDXREG(SISSR, 0x1E, temp | ((y >> 8) & 0x07));
+    if(pSiS->MiscFlags & MISC_CURSORMAXHALF) {
+       if(size > (maxsize / 2))
+          return FALSE;
+    }
 
-    outSISIDXREG(SISSR, 0x1C, x_preset);
-    outSISIDXREG(SISSR, 0x1F, y_preset);
+#ifdef SISMERGED
+    pSiS->CurHotX = pCurs->bits->xhot;
+    pSiS->CurHotY = pCurs->bits->yhot;
+#endif
 
-    outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
+    return TRUE;
 }
+#endif
 
 #ifdef SISMERGED
+
 static void
 SiSSetCursorPositionMerged(ScrnInfoPtr pScrn1, int x, int y)
 {
@@ -355,6 +390,11 @@ SiSSetCursorPositionMerged(ScrnInfoPtr pScrn1, int x, int y)
     UShort  y1_preset = 0, y2_preset = 0;
     UShort  maxpreset;
     int     x1, y1, x2, y2;
+    Bool    curoff1 = FALSE, curoff2 = FALSE;
+    int     v1display = mode1->VDisplay;
+    int     v2display = mode2->VDisplay;
+
+    /* Beware: This is executed asynchronously. */
 
     x += pScrn1->frameX0;
     y += pScrn1->frameY0;
@@ -368,39 +408,53 @@ SiSSetCursorPositionMerged(ScrnInfoPtr pScrn1, int x, int y)
     maxpreset = 63;
     if((pSiS->VGAEngine == SIS_300_VGA) && (pSiS->UseHWARGBCursor)) maxpreset = 31;
 
+    if(mode1->Flags & V_DBLSCAN) {
+       y1 *= 2;
+       v1display *= 2;
+       if((pSiS->MiscFlags & MISC_CURSORMAXHALF) && (!(pSiS->MiscFlags & MISC_CURSORDOUBLESIZE))) {
+	  y1 += pSiS->CurHotY;
+       }
+    }
+    if(mode2->Flags & V_DBLSCAN) {
+       y2 *= 2;
+       v2display *= 2;
+       if((pSiS->MiscFlags & MISC_CURSORMAXHALF) && (!(pSiS->MiscFlags & MISC_CURSORDOUBLESIZE))) {
+	  y2 += pSiS->CurHotY;
+       }
+    }
+
     if(x1 < 0) {
        x1_preset = (-x1);
-       if(x1_preset > maxpreset) x1_preset = maxpreset;
+       if(x1_preset > maxpreset) curoff1 = TRUE;
        x1 = 0;
     }
     if(y1 < 0) {
        y1_preset = (-y1);
-       if(y1_preset > maxpreset) y1_preset = maxpreset;
+       if(y1_preset > maxpreset) curoff1 = TRUE;
        y1 = 0;
     }
     if(x2 < 0) {
        x2_preset = (-x2);
-       if(x2_preset > maxpreset) x2_preset = maxpreset;
+       if(x2_preset > maxpreset) curoff2 = TRUE;
        x2 = 0;
     }
     if(y2 < 0) {
        y2_preset = (-y2);
-       if(y2_preset > maxpreset) y2_preset = maxpreset;
+       if(y2_preset > maxpreset) curoff2 = TRUE;
        y2 = 0;
     }
 
-    /* Work around bug in cursor engine if y > display */
-    if(y1 > mode1->VDisplay)		{ y1 = 2000; y1_preset = 0; }
-    else if(mode1->Flags & V_INTERLACE)	{ y1 /= 2; y1_preset /= 2; }
-    else if(mode1->Flags & V_DBLSCAN)	{ y1 *= 2; y1_preset *= 2; }
-
-    if(y2 > mode2->VDisplay)		{ y2 = 2000; y2_preset = 0; }
-    else if(mode2->Flags & V_INTERLACE)	{ y2 /= 2; y2_preset /= 2; }
-    else if(mode2->Flags & V_DBLSCAN)	{ y2 *= 2; y2_preset *= 2; }
+    /* Work around bug in cursor engine if y or x > display */
+    if(curoff1 || (y1 > v1display) || (x1 > mode1->HDisplay)) {
+       y1 = 2000; y1_preset = 0;
+    } else if(pSiS->MiscFlags & MISC_INTERLACE) {
+       y1 /= 2; /* Not preset! */
+    }
 
-    /* Work around bug in cursor engine if x > display */
-    if(x1 > mode1->HDisplay) { y1 = 2000; y1_preset = 0; }
-    if(x2 > mode2->HDisplay) { y2 = 2000; y2_preset = 0; }
+    /* CRT2 is never interlace */
+    if(curoff2 || (y2 > v2display) || (x2 > mode2->HDisplay)) {
+       y2 = 2000; y2_preset = 0;
+    }
 
     if(pSiS->VGAEngine == SIS_300_VGA) {
        sis300SetCursorPositionX(x1, x1_preset)
@@ -416,51 +470,60 @@ SiSSetCursorPositionMerged(ScrnInfoPtr pScrn1, int x, int y)
 }
 #endif
 
+/*******************************************/
+/*                300 series               */
+/*******************************************/
+
 static void
-SiS300SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+SiS300HideCursor(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    DisplayModePtr mode = pSiS->CurrentLayout.mode; /* pScrn->currentMode; */
-    UShort x_preset = 0;
-    UShort y_preset = 0;
 
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       SiSSetCursorPositionMerged(pScrn, x, y);
-       return;
+    /* Beware: This is executed asynchronously. */
+
+#ifdef SISDUALHEAD
+    if(!pSiS->DualHeadMode || pSiS->SecondHead || pSiS->ForceCursorOff) {
+#endif
+       sis300DisableHWCursor()
+       sis300SetCursorPositionY(2000, 0)
+#ifdef SISDUALHEAD
     }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead || pSiS->ForceCursorOff) {
 #endif
+       if(pSiS->VBFlags & CRT2_ENABLE) {
+          sis301DisableHWCursor()
+	  sis301SetCursorPositionY(2000, 0)
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+}
 
-    if(mode->Flags & V_INTERLACE)     y /= 2;
-    else if(mode->Flags & V_DBLSCAN)  y *= 2;
+static void
+SiS300ShowCursor(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
 
-    if(x < 0) {
-       x_preset = (-x);
-       x = 0;
-    }
-    if(y < 0) {
-       y_preset = (-y);
-       y = 0;
-    }
+    /* Beware: This is executed asynchronously. */
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-	  sis300SetCursorPositionX(x, x_preset)
-	  sis300SetCursorPositionY(y, y_preset)
+    if(!pSiS->DualHeadMode || pSiS->SecondHead) {
+#endif
+       if(pSiS->UseHWARGBCursor) {
+	  sis300EnableHWARGBCursor()
        } else {
-	  /* Head 1 is always CRT2 */
-	  sis301SetCursorPositionX(x + 13, x_preset)
-	  sis301SetCursorPositionY(y, y_preset)
+	  sis300EnableHWCursor()
        }
-    } else {
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead) {
 #endif
-       sis300SetCursorPositionX(x, x_preset)
-       sis300SetCursorPositionY(y, y_preset)
        if(pSiS->VBFlags & CRT2_ENABLE) {
-	  sis301SetCursorPositionX(x + 13, x_preset)
-	  sis301SetCursorPositionY(y, y_preset)
+          if(pSiS->UseHWARGBCursor) {
+	     sis301EnableHWARGBCursor()
+	  } else {
+	     sis301EnableHWCursor()
+	  }
        }
 #ifdef SISDUALHEAD
     }
@@ -468,12 +531,15 @@ SiS300SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
 }
 
 static void
-SiS310SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+SiS300SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
 {
     SISPtr pSiS = SISPTR(pScrn);
     DisplayModePtr mode = pSiS->CurrentLayout.mode;
     UShort x_preset = 0;
     UShort y_preset = 0;
+    UShort maxpreset = (pSiS->UseHWARGBCursor) ? 31 : 63;
+
+    /* Beware: This is executed asynchronously. */
 
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
@@ -482,48 +548,33 @@ SiS310SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
     }
 #endif
 
-    if(mode->Flags & V_INTERLACE)     y >>= 1;
-    else if(mode->Flags & V_DBLSCAN)  y <<= 1;
+
+    if(mode->Flags & V_DBLSCAN) y *= 2;
+    /* Cursor engine does not support interlace */
 
     if(x < 0) {
        x_preset = (-x);
+       if(x_preset > maxpreset) x_preset = maxpreset;
        x = 0;
     }
     if(y < 0) {
        y_preset = (-y);
+       if(y_preset > maxpreset) y_preset = maxpreset;
        y = 0;
     }
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-	  sis310SetCursorPositionX(x, x_preset)
-	  sis310SetCursorPositionY(y, y_preset)
-       } else {
-	  /* Head 1 is always CRT2 */
-#if 0
-	  if((pSiS->VBFlags & CRT2_LCD) && (pSiS->FSTN || pSiS->DSTN)) {
-	     y >>= 1;
-	     y_preset >>= 1;
-	  }
+    if(!pSiS->DualHeadMode || pSiS->SecondHead) {
 #endif
-	  sis301SetCursorPositionX310(x + 17, x_preset)
-	  sis301SetCursorPositionY310(y, y_preset)
-       }
-    } else {
+       sis300SetCursorPositionX(x, x_preset)
+       sis300SetCursorPositionY(y, y_preset)
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead) {
 #endif
-       sis310SetCursorPositionX(x, x_preset)
-       sis310SetCursorPositionY(y, y_preset)
        if(pSiS->VBFlags & CRT2_ENABLE) {
-#if 0
-	  if((pSiS->VBFlags & CRT2_LCD) && (pSiS->FSTN || pSiS->DSTN)) {
-	     y >>= 1;
-	     y_preset >>= 1;
-	  }
-#endif
-	  sis301SetCursorPositionX310(x + 17, x_preset)
-	  sis301SetCursorPositionY310(y, y_preset)
+	  sis301SetCursorPositionX(x + 13, x_preset)
+	  sis301SetCursorPositionY(y, y_preset)
        }
 #ifdef SISDUALHEAD
     }
@@ -531,59 +582,24 @@ SiS310SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
 }
 
 static void
-SiSSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    UChar  f_red, f_green, f_blue;
-    UChar  b_red, b_green, b_blue;
-    UChar  sridx, cridx;
-
-    sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
-
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-    f_red   = (fg & 0x00FF0000) >> (16+2);
-    f_green = (fg & 0x0000FF00) >> (8+2);
-    f_blue  = (fg & 0x000000FF) >> 2;
-    b_red   = (bg & 0x00FF0000) >> (16+2);
-    b_green = (bg & 0x0000FF00) >> (8+2);
-    b_blue  = (bg & 0x000000FF) >> 2;
-
-    outSISIDXREG(SISSR, 0x14, b_red);
-    outSISIDXREG(SISSR, 0x15, b_green);
-    outSISIDXREG(SISSR, 0x16, b_blue);
-    outSISIDXREG(SISSR, 0x17, f_red);
-    outSISIDXREG(SISSR, 0x18, f_green);
-    outSISIDXREG(SISSR, 0x19, f_blue);
-
-    outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
-}
-
-static void
 SiS300SetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
 {
     SISPtr pSiS = SISPTR(pScrn);
 
+    /* Beware: This is executed asynchronously. */
+
     if(pSiS->UseHWARGBCursor) return;
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiS->SecondHead) {
-	  /* Head 2 is always CRT1 */
-    	  sis300SetCursorBGColor(bg)
-    	  sis300SetCursorFGColor(fg)
-       } else {
-	  /* Head 1 is always CRT2 */
-          sis301SetCursorBGColor(bg)
-          sis301SetCursorFGColor(fg)
-       }
-    } else {
+    if(!pSiS->DualHeadMode || pSiS->SecondHead) {
 #endif
        sis300SetCursorBGColor(bg)
        sis300SetCursorFGColor(fg)
-       if(pSiS->VBFlags & CRT2_ENABLE)  {
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead) {
+#endif
+       if(pSiS->VBFlags & CRT2_ENABLE) {
           sis301SetCursorBGColor(bg)
           sis301SetCursorFGColor(fg)
        }
@@ -593,153 +609,175 @@ SiS300SetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
 }
 
 static void
-SiS310SetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
+SiS300LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
 {
     SISPtr pSiS = SISPTR(pScrn);
-
-    if(pSiS->UseHWARGBCursor) return;
-
+    ULong  cursor_addr;
+    CARD32 status1 = 0, status2 = 0;
+    UChar  *dest = pSiS->RealFbBase;
+    Bool   sizedouble = FALSE;
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-	if(pSiS->SecondHead) {
-	   /* Head 2 is always CRT1 */
-	   sis310SetCursorBGColor(bg)
-	   sis310SetCursorFGColor(fg)
-        } else {
-	   /* Head 1 is always CRT2 */
-	   if(pSiS->ChipFlags & SiSCF_CRT2HWCKaputt) {
-	      if((fg != pSiS->CurFGCol) || (bg != pSiS->CurBGCol)) {
-	         pSiS->CurFGCol = fg;
-	         pSiS->CurBGCol = bg;
-	         SiSXConvertMono2ARGB(pSiS);
-	      }
-	   } else {
-	      sis301SetCursorBGColor310(bg)
-	      sis301SetCursorFGColor310(fg)
-	   }
-       }
-    } else {
+    SISEntPtr pSiSEnt = pSiS->entityPrivate;
 #endif
-       sis310SetCursorBGColor(bg)
-       sis310SetCursorFGColor(fg)
 
-       if(pSiS->VBFlags & CRT2_ENABLE)  {
-	  if(pSiS->ChipFlags & SiSCF_CRT2HWCKaputt) {
-	     if((fg != pSiS->CurFGCol) || (bg != pSiS->CurBGCol)) {
-	        pSiS->CurFGCol = fg;
-	        pSiS->CurBGCol = bg;
-	        SiSXConvertMono2ARGB(pSiS);
-	     }
-	  } else {
-	     sis301SetCursorBGColor310(bg)
-	     sis301SetCursorFGColor310(fg)
-	  }
-       }
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->MiscFlags & MISC_CURSORDOUBLESIZE)
+       sizedouble = TRUE;
+
+    cursor_addr = pScrn->videoRam - pSiS->cursorOffset - (pSiS->CursorSize/1024);  /* 1K boundary */
+
 #ifdef SISDUALHEAD
-    }
+    /* Use the global FbBase in DHM */
+    if(pSiS->DualHeadMode) dest = pSiSEnt->RealFbBase;
 #endif
-}
 
-static void
-SiSLoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    DisplayModePtr mode = pSiS->CurrentLayout.mode;
-    ULong  cursor_addr;
-    UChar  temp;
-    UChar  sridx, cridx;
+    SiSUploadMonoCursor(pSiS, sizedouble, src, (UChar *)dest + (cursor_addr * 1024));
 
-    sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
+    pSiS->CursorW = 64;
+    pSiS->CursorH = sizedouble ? 32 : 64;
 
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#ifdef SISDUALHEAD
+    if(pSiS->DualHeadMode) {
+       UpdateHWCursorStatus(pSiS);
+    }
 #endif
 
-    cursor_addr = pScrn->videoRam - 1;
-    if(mode->Flags & V_DBLSCAN) {
-       int i;
-       for(i = 0; i < 32; i++) {
-	  SiSMemCopyToVideoRam(pSiS, (UChar *)pSiS->RealFbBase + (cursor_addr * 1024) + (32 * i),
-				src + (16 * i), 16);
-	  SiSMemCopyToVideoRam(pSiS, (UChar *)pSiS->RealFbBase + (cursor_addr * 1024) + (32 * i) + 16,
-				src + (16 * i), 16);
+    if(pSiS->UseHWARGBCursor) {
+       if(pSiS->VBFlags & DISPTYPE_CRT1) {
+	  status1 = sis300GetCursorStatus;
+	  sis300DisableHWCursor()
+	  if(pSiS->VBFlags & CRT2_ENABLE) {
+	     status2 = sis301GetCursorStatus;
+	     sis301DisableHWCursor()
+	  }
+	  SISWaitRetraceCRT1(pScrn);
+	  sis300SwitchToMONOCursor();
+	  if(pSiS->VBFlags & CRT2_ENABLE) {
+	     SISWaitRetraceCRT2(pScrn);
+	     sis301SwitchToMONOCursor();
+	  }
        }
-    } else {
-       SiSMemCopyToVideoRam(pSiS, (UChar *)pSiS->RealFbBase + (cursor_addr * 1024), src, 1024);
+    }
+    sis300SetCursorAddress(cursor_addr);
+    if(status1) {
+       sis300SetCursorStatus(status1)
     }
 
-    /* copy bits [21:18] into the top bits of SR38 */
-    inSISIDXREG(SISSR, 0x38, temp);
-    temp &= 0x0F;
-    outSISIDXREG(SISSR, 0x38, temp | ((cursor_addr & 0xF00) >> 4));
-
-    if(pSiS->Chipset == PCI_CHIP_SIS530) {
-       /* store the bit [22] to SR3E */
-       if(cursor_addr & 0x1000) {
-          orSISIDXREG(SISSR, 0x3E, 0x04);
-       } else {
-          andSISIDXREG(SISSR, 0x3E, ~0x04);
+    if(pSiS->VBFlags & CRT2_ENABLE) {
+       if((pSiS->UseHWARGBCursor) && (!pSiS->VBFlags & DISPTYPE_CRT1)) {
+	  status2 = sis301GetCursorStatus;
+	  sis301DisableHWCursor()
+	  SISWaitRetraceCRT2(pScrn);
+	  sis301SwitchToMONOCursor();
+       }
+       sis301SetCursorAddress(cursor_addr)
+       if(status2) {
+          sis301SetCursorStatus(status2)
        }
     }
 
-    /* set HW cursor pattern, use pattern 0xF */
-    orSISIDXREG(SISSR, 0x1E, 0xF0);
-
-    /* disable the hardware cursor side pattern */
-    andSISIDXREG(SISSR, 0x1E, 0xF7);
-
-    outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
+    pSiS->UseHWARGBCursor = FALSE;
 }
 
+#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)) && defined(ARGB_CURSOR) && defined(SIS_ARGB_CURSOR)
 static void
-SiS300LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
+SiS300LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    ULong  cursor_addr;
-    CARD32 status1 = 0, status2 = 0;
-    UChar  *dest = pSiS->RealFbBase;
-    Bool   sizedouble = FALSE;
+    int cursor_addr, i, j, maxheight = 32;
+    CARD32 *src = pCurs->bits->argb, *p;
+    CARD32 *pb, *dest, *finaldest;
+#define MYSISPTRTYPE CARD32
+    int srcwidth = pCurs->bits->width;
+    int srcheight = pCurs->bits->height;
+    CARD32 temp, status1 = 0, status2 = 0;
+    Bool sizedouble = FALSE;
 #ifdef SISDUALHEAD
     SISEntPtr pSiSEnt = pSiS->entityPrivate;
 #endif
 
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       if((CDMPTR->CRT1->Flags & V_DBLSCAN) && (CDMPTR->CRT2->Flags & V_DBLSCAN)) {
-          sizedouble = TRUE;
-       }
-    } else
-#endif
-           if(pSiS->CurrentLayout.mode->Flags & V_DBLSCAN) {
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->MiscFlags & MISC_CURSORDOUBLESIZE)
        sizedouble = TRUE;
-    }
 
-    cursor_addr = pScrn->videoRam - pSiS->cursorOffset - (pSiS->CursorSize/1024);  /* 1K boundary */
+
+    cursor_addr = pScrn->videoRam - pSiS->cursorOffset - ((pSiS->CursorSize/1024) * 2);
+
+    if(srcwidth > 32)  srcwidth = 32;
+    if(srcheight > 32) srcheight = 32;
 
 #ifdef SISDUALHEAD
-    /* Use the global FbBase in DHM */
-    if(pSiS->DualHeadMode) dest = pSiSEnt->RealFbBase;
+    if (pSiS->DualHeadMode)
+	finaldest = (MYSISPTRTYPE *)((UChar *)pSiSEnt->RealFbBase + (cursor_addr * 1024));
+    else
 #endif
+        finaldest = (MYSISPTRTYPE *)((UChar *)pSiS->RealFbBase + (cursor_addr * 1024));
 
     if(sizedouble) {
-       int i;
-       for(i = 0; i < 32; i++) {
-	  SiSMemCopyToVideoRam(pSiS, (UChar *)dest + (cursor_addr * 1024) + (32 * i),
-	           src + (16 * i), 16);
-	  SiSMemCopyToVideoRam(pSiS, (UChar *)dest + (cursor_addr * 1024) + (32 * i) + 16,
-	           src + (16 * i), 16);
+          if(srcheight > 16) srcheight = 16;
+          maxheight = 16;
+    }
+
+    dest = (CARD32 *)pSiS->CursorScratch;
+    for(i = 0; i < srcheight; i++) {
+       p = src;
+       pb = dest;
+       src += pCurs->bits->width;
+       for(j = 0; j < srcwidth; j++) {
+          temp = *p++;
+          if(pSiS->OptUseColorCursorBlend) {
+             if(temp & 0xffffff) {
+                if((temp & 0xff000000) > pSiS->OptColorCursorBlendThreshold) {
+		   temp &= 0x00ffffff;
+		} else {
+		   temp = 0xff111111;
+		}
+	     } else temp = 0xff000000;
+	  } else {
+	     if(temp & 0xffffff) temp &= 0x00ffffff;
+	     else temp = 0xff000000;
+	  }
+	  sisfbwritelinc(dest, temp); /* *dest++ = temp; */
+       }
+       if(srcwidth < 32) {
+          for(; j < 32; j++) {
+	     sisfbwritelinc(dest, 0xff000000); /* *dest++ = 0xff000000; */
+	  }
+       }
+       if(sizedouble) {
+          for(j = 0; j < 32; j++) {
+             sisfbwritelinc(dest, sisfbreadlinc(pb)); /* *dest++ = *pb++; */
+          }
        }
-    } else {
-       SiSMemCopyToVideoRam(pSiS, (UChar *)dest + (cursor_addr * 1024), src, 1024);
     }
 
+    if(srcheight < maxheight) {
+       for(; i < maxheight; i++) {
+          for(j = 0; j < 32; j++) {
+	     sisfbwritelinc(dest, 0xff000000); /* *dest++ = 0xff000000; */
+	  }
+	  if(sizedouble) {
+	     for(j = 0; j < 32; j++) {
+	        sisfbwritelinc(dest, 0xff000000); /* *dest++ = 0xff000000; */
+	     }
+	  }
+       }
+    }
+
+    SiSUploadColorCursor(pSiS, sizedouble, pSiS->CursorScratch, finaldest, 32);
+
+    pSiS->CursorW = 32;
+    pSiS->CursorH = sizedouble ? 16 : 32;
+
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        UpdateHWCursorStatus(pSiS);
     }
 #endif
 
-    if(pSiS->UseHWARGBCursor) {
+    if(!pSiS->UseHWARGBCursor) {
        if(pSiS->VBFlags & DISPTYPE_CRT1) {
 	  status1 = sis300GetCursorStatus;
 	  sis300DisableHWCursor()
@@ -748,24 +786,25 @@ SiS300LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
 	     sis301DisableHWCursor()
 	  }
 	  SISWaitRetraceCRT1(pScrn);
-	  sis300SwitchToMONOCursor();
+	  sis300SwitchToRGBCursor();
 	  if(pSiS->VBFlags & CRT2_ENABLE) {
 	     SISWaitRetraceCRT2(pScrn);
-	     sis301SwitchToMONOCursor();
+	     sis301SwitchToRGBCursor();
 	  }
        }
     }
+
     sis300SetCursorAddress(cursor_addr);
     if(status1) {
        sis300SetCursorStatus(status1)
     }
 
     if(pSiS->VBFlags & CRT2_ENABLE) {
-       if((pSiS->UseHWARGBCursor) && (!pSiS->VBFlags & DISPTYPE_CRT1)) {
+       if((!pSiS->UseHWARGBCursor) && (!(pSiS->VBFlags & DISPTYPE_CRT1))) {
 	  status2 = sis301GetCursorStatus;
 	  sis301DisableHWCursor()
 	  SISWaitRetraceCRT2(pScrn);
-	  sis301SwitchToMONOCursor();
+	  sis301SwitchToRGBCursor();
        }
        sis301SetCursorAddress(cursor_addr)
        if(status2) {
@@ -773,7 +812,171 @@ SiS300LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
        }
     }
 
-    pSiS->UseHWARGBCursor = FALSE;
+    pSiS->UseHWARGBCursor = TRUE;
+}
+#endif
+
+/*******************************************/
+/*              315 and later              */
+/*******************************************/
+
+static void
+SiS310HideCursor(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    /* Beware: This is executed asynchronously. */
+
+    pSiS->HWCursorIsVisible = FALSE;
+
+#ifdef SISDUALHEAD
+    if(!pSiS->DualHeadMode || pSiS->SecondHead || pSiS->ForceCursorOff) {
+#endif
+       sis310DisableHWCursor()
+       sis310SetCursorPositionY(2000, 0)
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead || pSiS->ForceCursorOff) {
+#endif
+       if(pSiS->VBFlags2 & VB2_VIDEOBRIDGE) {
+	  sis301DisableHWCursor310()
+	  sis301SetCursorPositionY310(2000, 0)
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+}
+
+static void
+SiS310ShowCursor(ScrnInfoPtr pScrn)
+{
+    SISPtr  pSiS = SISPTR(pScrn);
+
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->HideHWCursor) {
+       SiS310HideCursor(pScrn);
+       /* sic! And AFTER HideCursor()! */
+       pSiS->HWCursorIsVisible = TRUE;
+       return;
+    }
+
+    pSiS->HWCursorIsVisible = TRUE;
+
+#ifdef SISDUALHEAD
+    if(!pSiS->DualHeadMode || pSiS->SecondHead) {
+#endif
+       if(pSiS->UseHWARGBCursor) {
+	  sis310EnableHWARGBCursor()
+       } else {
+	  sis310EnableHWCursor()
+       }
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead) {
+#endif
+       if(pSiS->VBFlags & CRT2_ENABLE) {
+          if(pSiS->ChipFlags & SiSCF_CRT2HWCKaputt) {
+	     sis301EnableHWCursor330()
+	  } else {
+	     if(pSiS->UseHWARGBCursor) {
+	        sis301EnableHWARGBCursor310()
+	     } else {
+	        sis301EnableHWCursor310()
+	     }
+	  }
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+}
+
+static void
+SiS310SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    DisplayModePtr mode = pSiS->CurrentLayout.mode;
+    UShort x_preset = 0;
+    UShort y_preset = 0;
+    int y1;
+
+    /* Beware: This is executed asynchronously. */
+
+#ifdef SISMERGED
+    if(pSiS->MergedFB) {
+       SiSSetCursorPositionMerged(pScrn, x, y);
+       return;
+    }
+#endif
+
+
+    if(mode->Flags & V_DBLSCAN) y *= 2;
+
+    if(x < 0) {
+       x_preset = (-x);
+       if(x_preset > 63) x_preset = 63;
+       x = 0;
+    }
+    if(y < 0) {
+       y_preset = (-y);
+       if(y_preset > 63) y_preset = 63;
+       y = 0;
+    }
+
+    y1 = y;
+    if(pSiS->MiscFlags & MISC_INTERLACE) y1 /= 2;
+
+#ifdef SISDUALHEAD
+    if(!pSiS->DualHeadMode || pSiS->SecondHead) {
+#endif
+       sis310SetCursorPositionX(x, x_preset)
+       sis310SetCursorPositionY(y1, y_preset)
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead) {
+#endif
+       if(pSiS->VBFlags & CRT2_ENABLE) {
+          sis301SetCursorPositionX310(x + 17, x_preset)
+          sis301SetCursorPositionY310(y, y_preset)
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+}
+
+static void
+SiS310SetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->UseHWARGBCursor) return;
+
+#ifdef SISDUALHEAD
+    if(!pSiS->DualHeadMode || pSiS->SecondHead) {
+#endif
+       sis310SetCursorBGColor(bg)
+       sis310SetCursorFGColor(fg)
+#ifdef SISDUALHEAD
+    }
+    if(!pSiS->DualHeadMode || !pSiS->SecondHead) {
+#endif
+       if(pSiS->VBFlags & CRT2_ENABLE) {
+	  if(pSiS->ChipFlags & SiSCF_CRT2HWCKaputt) {
+	     if((fg != pSiS->CurFGCol) || (bg != pSiS->CurBGCol)) {
+	        pSiS->CurFGCol = fg;
+	        pSiS->CurBGCol = bg;
+	        SiSXConvertMono2ARGB(pSiS);
+	     }
+	  } else {
+	     sis301SetCursorBGColor310(bg)
+	     sis301SetCursorFGColor310(fg)
+	  }
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
 }
 
 static void
@@ -788,6 +991,8 @@ SiS310LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
 #ifdef SISDUALHEAD
     SISEntPtr pSiSEnt = pSiS->entityPrivate;
 
+    /* Beware: This is executed asynchronously. */
+
     if(pSiS->DualHeadMode) {
        pSiSEnt->HWCursorMBufNum ^= 1;
        bufnum = 1 << pSiSEnt->HWCursorMBufNum;
@@ -799,16 +1004,8 @@ SiS310LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
     }
 #endif
 
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       if((CDMPTR->CRT1->Flags & V_DBLSCAN) && (CDMPTR->CRT2->Flags & V_DBLSCAN)) {
-          sizedouble = TRUE;
-       }
-    } else
-#endif
-           if(pSiS->CurrentLayout.mode->Flags & V_DBLSCAN) {
+    if(pSiS->MiscFlags & MISC_CURSORDOUBLESIZE)
        sizedouble = TRUE;
-    }
 
 #ifdef SISDUALHEAD
     /* Use the global FbBase in DHM */
@@ -821,17 +1018,10 @@ SiS310LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
        cursor_addr = pScrn->videoRam - pSiS->cursorOffset - ((pSiS->CursorSize/1024) * bufnum);
     }
 
-    if(sizedouble) {
-       int i;
-       for(i = 0; i < 32; i++) {
-	  SiSMemCopyToVideoRam(pSiS, (UChar *)dest + (cursor_addr * 1024) + (32 * i),
-		   src + (16 * i), 16);
-	  SiSMemCopyToVideoRam(pSiS, (UChar *)dest + (cursor_addr * 1024) + (32 * i) + 16,
-		   src + (16 * i), 16);
-       }
-    } else {
-       SiSMemCopyToVideoRam(pSiS, (UChar *)dest + (cursor_addr * 1024), src, 1024);
-    }
+    SiSUploadMonoCursor(pSiS, sizedouble, src, (UChar *)dest + (cursor_addr * 1024));
+
+    pSiS->CursorW = 64;
+    pSiS->CursorH = sizedouble ? 32 : 64;
 
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
@@ -846,6 +1036,7 @@ SiS310LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
 
        pSiS->CurMonoSrc = (UChar *)dest + (cursor_addr * 1024);
        pSiS->CurARGBDest = (CARD32 *)((UChar *)dest + (cursor_addr2 * 1024));
+       pSiS->CursorDoubleSize = sizedouble;
 
        SiSXConvertMono2ARGB(pSiS);
 
@@ -907,312 +1098,13 @@ SiS310LoadCursorImage(ScrnInfoPtr pScrn, UChar *src)
     pSiS->UseHWARGBCursor = FALSE;
 }
 
-static Bool
-SiSUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    SISPtr  pSiS = SISPTR(pScrn);
-    DisplayModePtr  mode = pSiS->CurrentLayout.mode;
-
-    if(pSiS->Chipset != PCI_CHIP_SIS6326) return TRUE;
-    if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return TRUE;
-    if((strcmp(mode->name, "PAL800x600U") == 0) ||
-       (strcmp(mode->name, "NTSC640x480U") == 0))
-       return FALSE;
-    else
-       return TRUE;
-}
-
-static Bool
-SiS300UseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    SISPtr  pSiS = SISPTR(pScrn);
-    DisplayModePtr  mode = pSiS->CurrentLayout.mode;
-#ifdef SISMERGED
-    DisplayModePtr  mode2 = NULL;
-
-    if(pSiS->MergedFB) {
-       mode = CDMPTR->CRT1;
-       mode2 = CDMPTR->CRT2;
-    }
-#endif
-
-    switch (pSiS->Chipset)  {
-      case PCI_CHIP_SIS300:
-      case PCI_CHIP_SIS630:
-      case PCI_CHIP_SIS540:
-	 if(mode->Flags & V_INTERLACE)
-	    return FALSE;
-	 if((mode->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	    return FALSE;
-#ifdef SISMERGED
-	 if(pSiS->MergedFB) {
-	    if(mode2->Flags & V_INTERLACE)
-	       return FALSE;
-	    if((mode2->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	       return FALSE;
-	 }
-#endif
-	 break;
-
-      case PCI_CHIP_SIS550:
-#ifdef SISDUALHEAD
-	 if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
-#endif
-	    if((pSiS->FSTN || pSiS->DSTN) && (pSiS->VBFlags & CRT2_LCD))
-	       return FALSE;
-	 /* fall through */
-      case PCI_CHIP_SIS315:
-      case PCI_CHIP_SIS315H:
-      case PCI_CHIP_SIS315PRO:
-      case PCI_CHIP_SIS650:
-      case PCI_CHIP_SIS330:
-      case PCI_CHIP_SIS660:
-      case PCI_CHIP_SIS340:
-      case PCI_CHIP_XGIXG20:
-      case PCI_CHIP_XGIXG40:
-	 if(mode->Flags & V_INTERLACE)
-	    return FALSE;
-	 if((mode->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	    return FALSE;
-#ifdef SISMERGED
-	 if(pSiS->MergedFB) {
-	    if(mode2->Flags & V_INTERLACE)
-	       return FALSE;
-	    if((mode2->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	       return FALSE;
-	 }
-#endif
-	 break;
-
-      default:
-	 if(mode->Flags & V_INTERLACE)
-	    return FALSE;
-	 if((mode->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	    return FALSE;
-	 break;
-    }
-    return TRUE;
-}
-
-#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
-#ifdef ARGB_CURSOR
-#ifdef SIS_ARGB_CURSOR
-static Bool
-SiSUseHWCursorARGB(ScreenPtr pScreen, CursorPtr pCurs)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    SISPtr  pSiS = SISPTR(pScrn);
-    DisplayModePtr  mode = pSiS->CurrentLayout.mode;
-#ifdef SISMERGED
-    DisplayModePtr  mode2 = NULL;
-
-    if(pSiS->MergedFB) {
-       mode = CDMPTR->CRT1;
-       mode2 = CDMPTR->CRT2;
-    }
-#endif
-
-    switch (pSiS->Chipset)  {
-      case PCI_CHIP_SIS300:
-      case PCI_CHIP_SIS630:
-      case PCI_CHIP_SIS540:
-	 if(mode->Flags & V_INTERLACE)
-	    return FALSE;
-	 if((pCurs->bits->height > 32) || (pCurs->bits->width > 32))
-	    return FALSE;
-	 if((mode->Flags & V_DBLSCAN) && (pCurs->bits->height > 16))
-	    return FALSE;
-#ifdef SISMERGED
-	 if(pSiS->MergedFB) {
-	    if(mode2->Flags & V_INTERLACE)
-	       return FALSE;
-	    if((mode2->Flags & V_DBLSCAN) && (pCurs->bits->height > 16))
-	       return FALSE;
-	 }
-#endif
-         break;
-
-      case PCI_CHIP_SIS550:
-#ifdef SISDUALHEAD
-	 if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
-#endif
-	    if((pSiS->FSTN || pSiS->DSTN) && (pSiS->VBFlags & CRT2_LCD))
-	       return FALSE;
-	 /* fall through */
-      case PCI_CHIP_SIS650:
-      case PCI_CHIP_SIS315:
-      case PCI_CHIP_SIS315H:
-      case PCI_CHIP_SIS315PRO:
-      case PCI_CHIP_SIS330:
-      case PCI_CHIP_SIS660:
-      case PCI_CHIP_SIS340:
-      case PCI_CHIP_XGIXG20:
-      case PCI_CHIP_XGIXG40:
-	 if(mode->Flags & V_INTERLACE)
-	    return FALSE;
-	 if((pCurs->bits->height > 64) || (pCurs->bits->width > 64))
-	    return FALSE;
-	 if((mode->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	    return FALSE;
-	 if((pSiS->CurrentLayout.bitsPerPixel == 8) && (pSiS->VBFlags & CRT2_ENABLE))
-	    return FALSE;
-#ifdef SISMERGED
-	 if(pSiS->MergedFB) {
-	    if(mode2->Flags & V_INTERLACE)
-	       return FALSE;
-	    if((mode->Flags & V_DBLSCAN) && (pCurs->bits->height > 32))
-	       return FALSE;
-	 }
-#endif
-	 break;
-
-      default:
-	 return FALSE;
-
-    }
-    return TRUE;
-}
-
+#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)) && defined(ARGB_CURSOR) && defined(SIS_ARGB_CURSOR)
 static void
-SiS300LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    int cursor_addr, i, j, maxheight = 32;
-    CARD32 *src = pCurs->bits->argb, *p;
-    CARD32 *pb, *dest;
-#define MYSISPTRTYPE CARD32
-    int srcwidth = pCurs->bits->width;
-    int srcheight = pCurs->bits->height;
-    CARD32 temp, status1 = 0, status2 = 0;
-    Bool sizedouble = FALSE;
-#ifdef SISDUALHEAD
-    SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       if((CDMPTR->CRT1->Flags & V_DBLSCAN) && (CDMPTR->CRT2->Flags & V_DBLSCAN)) {
-          sizedouble = TRUE;
-       }
-    } else
-#endif
-           if(pSiS->CurrentLayout.mode->Flags & V_DBLSCAN) {
-       sizedouble = TRUE;
-    }
-
-    cursor_addr = pScrn->videoRam - pSiS->cursorOffset - ((pSiS->CursorSize/1024) * 2);
-
-    if(srcwidth > 32)  srcwidth = 32;
-    if(srcheight > 32) srcheight = 32;
-
-#ifdef SISDUALHEAD
-    if (pSiS->DualHeadMode)
-	dest = (MYSISPTRTYPE *)((UChar *)pSiSEnt->RealFbBase + (cursor_addr * 1024));
-    else
-#endif
-        dest = (MYSISPTRTYPE *)((UChar *)pSiS->RealFbBase + (cursor_addr * 1024));
-
-    if(sizedouble) {
-       if(srcheight > 16) srcheight = 16;
-       maxheight = 16;
-    }
-
-    for(i = 0; i < srcheight; i++) {
-	    p = src;
-	    pb = dest;
-	    src += pCurs->bits->width;
-	    for(j = 0; j < srcwidth; j++) {
-	       temp = *p++;
-	       if(pSiS->OptUseColorCursorBlend) {
-	          if(temp & 0xffffff) {
-	             if((temp & 0xff000000) > pSiS->OptColorCursorBlendThreshold) {
-			temp &= 0x00ffffff;
-		     } else {
-			temp = 0xff111111;
-		     }
-		  } else temp = 0xff000000;
-	       } else {
-	           if(temp & 0xffffff) temp &= 0x00ffffff;
-	           else temp = 0xff000000;
-	       }
-	       sisfbwritelinc(dest, temp); /* *dest++ = temp; */
-	    }
-	    if(srcwidth < 32) {
-	       for(; j < 32; j++) {
-	          sisfbwritelinc(dest, 0xff000000); /* *dest++ = 0xff000000; */
-	       }
-	    }
-	    if(sizedouble) {
-	       for(j = 0; j < 32; j++) {
-	          sisfbwritelinc(dest, sisfbreadlinc(pb)); /* *dest++ = *pb++; */
-	       }
-	    }
-
-    }
-    if(srcheight < maxheight) {
-	for(; i < maxheight; i++) {
-	   for(j = 0; j < 32; j++) {
-	      sisfbwritelinc(dest, 0xff000000); /* *dest++ = 0xff000000; */
-	   }
-	   if(sizedouble) {
-	      for(j = 0; j < 32; j++) {
-	      	sisfbwritelinc(dest, 0xff000000); /* *dest++ = 0xff000000; */
-	      }
-	   }
-	}
-    }
-
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       UpdateHWCursorStatus(pSiS);
-    }
-#endif
-
-    if(!pSiS->UseHWARGBCursor) {
-       if(pSiS->VBFlags & DISPTYPE_CRT1) {
-	  status1 = sis300GetCursorStatus;
-	  sis300DisableHWCursor()
-	  if(pSiS->VBFlags & CRT2_ENABLE)  {
-	     status2 = sis301GetCursorStatus;
-	     sis301DisableHWCursor()
-	  }
-	  SISWaitRetraceCRT1(pScrn);
-	  sis300SwitchToRGBCursor();
-	  if(pSiS->VBFlags & CRT2_ENABLE)  {
-	     SISWaitRetraceCRT2(pScrn);
-	     sis301SwitchToRGBCursor();
-	  }
-       }
-    }
-
-    sis300SetCursorAddress(cursor_addr);
-    if(status1) {
-       sis300SetCursorStatus(status1)
-    }
-
-    if(pSiS->VBFlags & CRT2_ENABLE) {
-       if((!pSiS->UseHWARGBCursor) && (!(pSiS->VBFlags & DISPTYPE_CRT1))) {
-	  status2 = sis301GetCursorStatus;
-	  sis301DisableHWCursor()
-	  SISWaitRetraceCRT2(pScrn);
-	  sis301SwitchToRGBCursor();
-       }
-       sis301SetCursorAddress(cursor_addr)
-       if(status2) {
-          sis301SetCursorStatus(status2)
-       }
-    }
-
-    pSiS->UseHWARGBCursor = TRUE;
-}
-
-static void SiS310LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
+SiS310LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
 {
     SISPtr pSiS = SISPTR(pScrn);
     int cursor_addr, i, j, maxheight = 64;
-    CARD32 *src = pCurs->bits->argb, *p, *pb, *dest;
+    CARD32 *src = pCurs->bits->argb, *p, *pb, *dest, *finaldest;
     int srcwidth = pCurs->bits->width;
     int srcheight = pCurs->bits->height;
     CARD32 status1 = 0, status2 = 0;
@@ -1222,16 +1114,11 @@ static void SiS310LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
     SISEntPtr pSiSEnt = pSiS->entityPrivate;
 #endif
 
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       if((CDMPTR->CRT1->Flags & V_DBLSCAN) && (CDMPTR->CRT2->Flags & V_DBLSCAN)) {
-          sizedouble = TRUE;
-       }
-    } else
-#endif
-           if(pSiS->CurrentLayout.mode->Flags & V_DBLSCAN) {
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->MiscFlags & MISC_CURSORDOUBLESIZE)
        sizedouble = TRUE;
-    }
+
 
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
@@ -1256,16 +1143,17 @@ static void SiS310LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
 
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode)
-       dest = (CARD32 *)((UChar *)pSiSEnt->RealFbBase + (cursor_addr * 1024));
+       finaldest = (CARD32 *)((UChar *)pSiSEnt->RealFbBase + (cursor_addr * 1024));
     else
 #endif
-       dest = (CARD32 *)((UChar *)pSiS->RealFbBase + (cursor_addr * 1024));
+       finaldest = (CARD32 *)((UChar *)pSiS->RealFbBase + (cursor_addr * 1024));
 
     if(sizedouble) {
-       if(srcheight > 32) srcheight = 32;
-       maxheight = 32;
+          if(srcheight > 32) srcheight = 32;
+          maxheight = 32;
     }
 
+    dest = (CARD32 *)pSiS->CursorScratch;
     for(i = 0; i < srcheight; i++) {
        p = src;
        pb = dest;
@@ -1289,6 +1177,11 @@ static void SiS310LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
        }
     }
 
+    SiSUploadColorCursor(pSiS, sizedouble, pSiS->CursorScratch, finaldest, 64);
+
+    pSiS->CursorW = 64;
+    pSiS->CursorH = sizedouble ? 32 : 64;
+
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        UpdateHWCursorStatus(pSiS);
@@ -1348,8 +1241,10 @@ static void SiS310LoadCursorImageARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
     pSiS->UseHWARGBCursor = TRUE;
 }
 #endif
-#endif
-#endif
+
+/*******************************************/
+/*                 Set up                  */
+/*******************************************/
 
 Bool
 SiSHWCursorInit(ScreenPtr pScreen)
@@ -1358,98 +1253,95 @@ SiSHWCursorInit(ScreenPtr pScreen)
     SISPtr pSiS = SISPTR(pScrn);
     xf86CursorInfoPtr infoPtr;
 
-    infoPtr = xf86CreateCursorInfoRec();
-    if(!infoPtr) return FALSE;
+    if(!(pSiS->CursorScratch = xcalloc(1, max(2048, pSiS->CursorSize))))
+       return FALSE;
+
+    if(!(infoPtr = xf86CreateCursorInfoRec())) {
+       xfree(pSiS->CursorScratch);
+       pSiS->CursorScratch = NULL;
+       return FALSE;
+    }
 
     pSiS->CursorInfoPtr = infoPtr;
     pSiS->UseHWARGBCursor = FALSE;
 
-    switch(pSiS->Chipset)  {
-      case PCI_CHIP_SIS300:
-      case PCI_CHIP_SIS630:
-      case PCI_CHIP_SIS540:
-        infoPtr->MaxWidth  = 64;
-        infoPtr->MaxHeight = 64;
-        infoPtr->ShowCursor = SiS300ShowCursor;
-        infoPtr->HideCursor = SiS300HideCursor;
-        infoPtr->SetCursorPosition = SiS300SetCursorPosition;
-        infoPtr->SetCursorColors = SiS300SetCursorColors;
-        infoPtr->LoadCursorImage = SiS300LoadCursorImage;
-        infoPtr->UseHWCursor = SiS300UseHWCursor;
-#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
-#ifdef ARGB_CURSOR
-#ifdef SIS_ARGB_CURSOR
-        if(pSiS->OptUseColorCursor) {
+    switch(pSiS->VGAEngine)  {
+      case SIS_300_VGA:
+	infoPtr->MaxWidth  = 64;
+	infoPtr->MaxHeight = 64;
+	infoPtr->UseHWCursor = SiSNewUseHWCursor;
+	infoPtr->ShowCursor = SiS300ShowCursor;
+	infoPtr->HideCursor = SiS300HideCursor;
+	infoPtr->SetCursorPosition = SiS300SetCursorPosition;
+	infoPtr->SetCursorColors = SiS300SetCursorColors;
+	infoPtr->LoadCursorImage = SiS300LoadCursorImage;
+#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)) && defined(ARGB_CURSOR) && defined(SIS_ARGB_CURSOR)
+	if(pSiS->OptUseColorCursor) {
 	   infoPtr->UseHWCursorARGB = SiSUseHWCursorARGB;
 	   infoPtr->LoadCursorARGB = SiS300LoadCursorImageARGB;
 	}
 #endif
-#endif
-#endif
-        infoPtr->Flags =
-            HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
-            HARDWARE_CURSOR_INVERT_MASK |
-            HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
-            HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
-            HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK |
-            HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64;
-        break;
-
-      case PCI_CHIP_SIS315:
-      case PCI_CHIP_SIS315H:
-      case PCI_CHIP_SIS315PRO:
-      case PCI_CHIP_SIS550:
-      case PCI_CHIP_SIS650:
-      case PCI_CHIP_SIS330:
-      case PCI_CHIP_SIS660:
-      case PCI_CHIP_SIS340:
-      case PCI_CHIP_XGIXG20:
-      case PCI_CHIP_XGIXG40:
-        infoPtr->MaxWidth  = 64;
-        infoPtr->MaxHeight = 64;
-        infoPtr->ShowCursor = SiS310ShowCursor;
-        infoPtr->HideCursor = SiS310HideCursor;
-        infoPtr->SetCursorPosition = SiS310SetCursorPosition;
-        infoPtr->SetCursorColors = SiS310SetCursorColors;
-        infoPtr->LoadCursorImage = SiS310LoadCursorImage;
-        infoPtr->UseHWCursor = SiS300UseHWCursor;
-#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
-#ifdef ARGB_CURSOR
-#ifdef SIS_ARGB_CURSOR
-  	if(pSiS->OptUseColorCursor) {
+	infoPtr->Flags =
+		HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+		HARDWARE_CURSOR_INVERT_MASK |
+		HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
+		HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+		HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK |
+		HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64;
+
+	if(pSiS->ChipFlags & SiSCF_NoCurHide) {
+	   infoPtr->Flags |= HARDWARE_CURSOR_UPDATE_UNHIDDEN;
+	}
+	break;
+
+      case SIS_315_VGA:
+	infoPtr->MaxWidth  = 64;
+	infoPtr->MaxHeight = 64;
+	infoPtr->UseHWCursor = SiSNewUseHWCursor;
+	infoPtr->ShowCursor = SiS310ShowCursor;
+	infoPtr->HideCursor = SiS310HideCursor;
+	infoPtr->SetCursorPosition = SiS310SetCursorPosition;
+	infoPtr->SetCursorColors = SiS310SetCursorColors;
+	infoPtr->LoadCursorImage = SiS310LoadCursorImage;
+#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)) && defined(ARGB_CURSOR) && defined(SIS_ARGB_CURSOR)
+	if(pSiS->OptUseColorCursor) {
 	   infoPtr->UseHWCursorARGB = SiSUseHWCursorARGB;
 	   infoPtr->LoadCursorARGB = SiS310LoadCursorImageARGB;
 	}
 #endif
-#endif
-#endif
-        infoPtr->Flags =
-            HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
-            HARDWARE_CURSOR_INVERT_MASK |
-            HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
-            HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
-            HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK |
-            HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64;
-        break;
+	infoPtr->Flags =
+		HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+		HARDWARE_CURSOR_INVERT_MASK |
+		HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
+		HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+		HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK |
+		HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64;
+
+	if(pSiS->ChipFlags & SiSCF_NoCurHide) {
+	    infoPtr->Flags |= HARDWARE_CURSOR_UPDATE_UNHIDDEN;
+	}
+	break;
 
       default:
-        infoPtr->MaxWidth  = 64;
+	infoPtr->MaxWidth  = 64;
 	infoPtr->MaxHeight = 64;
-        infoPtr->SetCursorPosition = SiSSetCursorPosition;
-        infoPtr->ShowCursor = SiSShowCursor;
-        infoPtr->HideCursor = SiSHideCursor;
-        infoPtr->SetCursorColors = SiSSetCursorColors;
-        infoPtr->LoadCursorImage = SiSLoadCursorImage;
-        infoPtr->UseHWCursor = SiSUseHWCursor;
-        infoPtr->Flags =
-            HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
-            HARDWARE_CURSOR_INVERT_MASK |
-            HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
-            HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
-            HARDWARE_CURSOR_NIBBLE_SWAPPED |
-            HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1;
-        break;
-    }
-
-    return(xf86InitCursor(pScreen, infoPtr));
+	infoPtr->UseHWCursor = SiSUseHWCursor;
+	infoPtr->SetCursorPosition = SiSSetCursorPosition;
+	infoPtr->ShowCursor = SiSShowCursor;
+	infoPtr->HideCursor = SiSHideCursor;
+	infoPtr->SetCursorColors = SiSSetCursorColors;
+	infoPtr->LoadCursorImage = SiSLoadCursorImage;
+	infoPtr->Flags =
+		HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+		HARDWARE_CURSOR_INVERT_MASK |
+		HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
+		HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+		HARDWARE_CURSOR_NIBBLE_SWAPPED |
+		HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1;
+	break;
+    }
+
+    return (xf86InitCursor(pScreen, infoPtr));
 }
+
+
diff --git a/src/sis_cursor.h b/src/sis_cursor.h
index 4abf1be..da6e002 100644
--- a/src/sis_cursor.h
+++ b/src/sis_cursor.h
@@ -214,7 +214,7 @@
   SIS_MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
   }
 
-/* 315/330 series CRT1 */
+/* 315/330/later series CRT1 */
 
 /* 80000000 = RGB(1) - MONO(0)
  * 40000000 = enable(1) - disable(0)
diff --git a/src/sis_dac.c b/src/sis_dac.c
index 91ca2b3..d385ec5 100644
--- a/src/sis_dac.c
+++ b/src/sis_dac.c
@@ -82,6 +82,10 @@
 #include "sis_regs.h"
 #include "sis_dac.h"
 
+#if 0
+#define TWDEBUG_VID
+#endif
+
 static void SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
 static void SiSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
 static void SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
@@ -211,9 +215,7 @@ int SiS_compute_vclk(
     }
     *out_n = best_n;
     *out_dn = best_dn;
-    PDEBUG(ErrorF("SiS_compute_vclk: Clock=%d, n=%d, dn=%d, div=%d, sbit=%d,"
-                    " scale=%d\n", Clock, best_n, best_dn, *out_div,
-                    *out_sbit, *out_scale));
+
     return 1;
 }
 
@@ -221,7 +223,7 @@ void
 SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD, unsigned int *vclk)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    int M, N, P , PSN, VLD , PSNx ;
+    int M, N, P, PSN, VLD, PSNx;
     int bestM=0, bestN=0, bestP=0, bestPSN=0, bestVLD=0;
     double abest = 42.0;
     double target;
@@ -229,7 +231,7 @@ SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD, unsigned int *vclk)
     double error, aerror;
 
     /*
-     *  fd = fref*(Numerator/Denumerator)*(Divider/PostScaler)
+     *  fd = fref * (Numerator / Denumerator) * (Divider / PostScaler)
      *
      *  M       = Numerator [1:128]
      *  N       = DeNumerator [1:32]
@@ -237,13 +239,9 @@ SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD, unsigned int *vclk)
      *  P       = Post Scaler : divide by 1, 2, 3, 4
      *  PSN     = Pre Scaler (Reference Divisor Select)
      *
-     * result in vclk[]
+     *  result in vclk[]
      */
-#define Midx    0
-#define Nidx    1
-#define VLDidx  2
-#define Pidx    3
-#define PSNidx  4
+
 #define Fref 14318180
 /* stability constraints for internal VCO -- MAX_VCO also determines
  * the maximum Video pixel clock */
@@ -275,102 +273,105 @@ SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD, unsigned int *vclk)
 
      for(N = low_N; N <= high_N; N++) {
 
-         double M_desired = Fvco / Fref * N;
-         if(M_desired > M_max * max_VLD)  continue;
-
-         if(M_desired > M_max) {
-            M = M_desired / 2 + 0.5;
-            VLD = 2;
-         } else {
-            M = Fvco / Fref * N + 0.5;
-            VLD = 1;
-         }
-
-         Fout = (double)Fref * (M * VLD)/(N * P);
-
-         error = (target - Fout) / target;
-         aerror = (error < 0) ? -error : error;
-         if(aerror < abest) {
-            abest = aerror;
-            bestM = M;
-            bestN = N;
-            bestP = P;
-            bestPSN = PSN;
-            bestVLD = VLD;
-         }
+	double M_desired = Fvco / Fref * N;
+
+	if(M_desired > M_max * max_VLD)
+	   continue;
+
+	if(M_desired > M_max) {
+	   M = M_desired / 2 + 0.5;
+	   VLD = 2;
+	} else {
+	   M = Fvco / Fref * N + 0.5;
+	   VLD = 1;
+	}
+
+	Fout = (double)Fref * (M * VLD) / (N * P);
+
+	error = (target - Fout) / target;
+	aerror = (error < 0) ? -error : error;
+	if(aerror < abest) {
+	   abest = aerror;
+	   bestM = M;
+	   bestN = N;
+	   bestP = P;
+	   bestPSN = PSN;
+	   bestVLD = VLD;
+	}
      }
 
   } else {
 
      for(PSNx = 0; PSNx <= MAX_PSN ; PSNx++) {
 
-        int low_N, high_N;
-        double FrefVLDPSN;
+	int low_N, high_N;
+	double FrefVLDPSN;
 
-        PSN = !PSNx ? 1 : 4;
+	PSN = !PSNx ? 1 : 4;
 
-        low_N = 2;
-        high_N = 32;
+	low_N = 2;
+	high_N = 32;
 
-        for(VLD = 1 ; VLD <= max_VLD ; VLD++) {
+	for(VLD = 1 ; VLD <= max_VLD ; VLD++) {
 
-           FrefVLDPSN = (double)Fref * VLD / PSN;
+	   FrefVLDPSN = (double)Fref * VLD / PSN;
 
 	   for(N = low_N; N <= high_N; N++) {
-              double tmp = FrefVLDPSN / N;
 
-              for(P = 1; P <= 4; P++) {
-                 double Fvco_desired = target * ( P );
-                 double M_desired = Fvco_desired / tmp;
+	      double tmp = FrefVLDPSN / N;
 
-                 /* Which way will M_desired be rounded?
-                  *  Do all three just to be safe.
-                  */
-                 int M_low = M_desired - 1;
-                 int M_hi = M_desired + 1;
+	      for(P = 1; P <= 4; P++) {
 
-                 if(M_hi < M_min || M_low > M_max) continue;
+		 double Fvco_desired = target * P;
+		 double M_desired = Fvco_desired / tmp;
 
-		 if(M_low < M_min)  M_low = M_min;
+		 /* Which way will M_desired be rounded?
+		  * Do all three just to be safe.
+		  */
+		 int M_low = M_desired - 1;
+		 int M_hi  = M_desired + 1;
 
-		 if(M_hi > M_max)   M_hi = M_max;
+		 if(M_hi < M_min || M_low > M_max)
+		    continue;
 
-                 for(M = M_low; M <= M_hi; M++) {
-                    Fvco = tmp * M;
-                    if(Fvco <= MIN_VCO) continue;
-                    if(Fvco > MAX_VCO)  break;
+		 if(M_low < M_min)
+		    M_low = M_min;
 
-                    Fout = Fvco / ( P );
+		 if(M_hi > M_max)
+		    M_hi = M_max;
 
-                    error = (target - Fout) / target;
-                    aerror = (error < 0) ? -error : error;
-                    if(aerror < abest) {
-                       abest = aerror;
-                       bestM = M;
-                       bestN = N;
-                       bestP = P;
-                       bestPSN = PSN;
-                       bestVLD = VLD;
-                    }
-#ifdef TWDEBUG
-                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
-			       "Freq. selected: %.2f MHz, M=%d, N=%d, VLD=%d, P=%d, PSN=%d\n",
-                               (float)(clock / 1000.), M, N, P, VLD, PSN);
-                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
-			       "Freq. set: %.2f MHz\n", Fout / 1.0e6);
-#endif
-                 }
-              }
-           }
-        }
+		 for(M = M_low; M <= M_hi; M++) {
+
+		    Fvco = tmp * M;
+		    if(Fvco <= MIN_VCO) continue;
+		    if(Fvco > MAX_VCO)  break;
+
+		    Fout = Fvco / P;
+
+		    error = (target - Fout) / target;
+
+		    aerror = (error < 0) ? -error : error;
+
+		    if(aerror < abest) {
+		       abest = aerror;
+		       bestM = M;
+		       bestN = N;
+		       bestP = P;
+		       bestPSN = PSN;
+		       bestVLD = VLD;
+		    }
+		 }
+	      }
+	   }
+	}
      }
   }
 
-  vclk[Midx]   = bestM;
-  vclk[Nidx]   = bestN;
-  vclk[VLDidx] = bestVLD;
-  vclk[Pidx]   = bestP;
-  vclk[PSNidx] = bestPSN;
+  vclk[SIS_VCLK_Midx]   = bestM;
+  vclk[SIS_VCLK_Nidx]   = bestN;
+  vclk[SIS_VCLK_VLDidx] = bestVLD;
+  vclk[SIS_VCLK_Pidx]   = bestP;
+  vclk[SIS_VCLK_PSNidx] = bestPSN;
 }
 
 static void
@@ -379,8 +380,6 @@ SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     SISPtr pSiS = SISPTR(pScrn);
     int i, max;
 
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3, "SiSSave()\n"));
-
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
@@ -439,8 +438,6 @@ SiSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     int i, max;
     UChar tmp;
 
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SiSRestore()\n"));
-
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
@@ -479,6 +476,10 @@ SiSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     /* Misc */
     outSISREG(SISMISCW, sisReg->sisRegs3C2);
 
+    #ifdef TWDEBUG
+     xf86DrvMsg(0,X_INFO,"[SISRestore()]:SISMISCW .\n");
+    #endif 
+
     /* MemClock needs this to take effect */
     outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
     usleep(10000);
@@ -516,8 +517,6 @@ SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     SISPtr pSiS = SISPTR(pScrn);
     int i;
 
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3, "SiS300Save()\n"));
-
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
@@ -586,8 +585,6 @@ SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     int i,temp;
     CARD32 temp1, temp2;
 
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SiS300Restore()\n"));
-
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
@@ -729,14 +726,14 @@ SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     SISPtr pSiS = SISPTR(pScrn);
     int i, max;
 
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3, "SiS315Save()\n"));
 
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
 
     /* Save SR registers */
-    for(i = 0x00; i <= 0x60; i++) {
+    /*for(i = 0x00; i <= 0x60; i++) {     //Chaoyu Modified: Register number is wrong.*/
+    for(i = 0x00; i <= 0x3f; i++) {  
        inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
 #ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -748,9 +745,10 @@ SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     sisReg->sisMMIO85C0 = SIS_MMIO_IN32(pSiS->IOBase, 0x85C0);
 
     /* Save CR registers */
-    max = 0x7c;
+    /*max = 0x7c;  //Chaoyu Modified: Register number is wrong.*/
+    max=0x7f;
     if(pSiS->ChipType >= XGI_20) max = 0xff;
-    for(i = 0x00; i <= max; i++)  {
+    for(i = 0x00; i <= max; i++)  {  
        inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
 #ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -768,7 +766,7 @@ SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     }
 
     /* Save video playback registers */
-    for(i = 0x00; i <= 0x3f; i++) {
+    for(i = 0x00; i <= 0x73; i++) {
        inSISIDXREG(SISVID, i, sisReg->sisVid[i]);
 #ifdef TWDEBUG_VID
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -778,6 +776,16 @@ SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
 
     /* Save Misc register */
     sisReg->sisRegs3C2 = inSISREG(SISMISCR);
+    
+    #ifdef TWDEBUG
+     unsigned char  uc = inSISREG(SISMISCW);
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "VGA_MISCR Contents - %02X \n",sisReg->sisRegs3C2);
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                "VGA_MISCW Contents - %02X \n",uc);
+    #endif
+
+
 
     /* Save panel link/video bridge registers */
 #ifndef TWDEBUG
@@ -807,9 +815,7 @@ static void
 SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    int i,temp;
-
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SiS315Restore()\n"));
+    int i, temp;
 
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
@@ -904,6 +910,9 @@ SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
 
     /* Restore Misc register */
     outSISREG(SISMISCW, sisReg->sisRegs3C2);
+     #ifdef TWDEBUG
+     xf86DrvMsg(0,X_INFO,"[SIS315Restore()]:SISMISCW .\n");
+    #endif 
 
     /* Restore panel link/video bridge registers */
     if(!(pSiS->UseVESA)) {
@@ -938,9 +947,15 @@ SiSVBSave(ScrnInfoPtr pScrn, SISRegPtr sisReg, int p1, int p2, int p3, int p4)
     for(i=0; i<=p2; i++)  {
        inSISIDXREG(SISPART2, i, sisReg->VBPart2[i]);
 #ifdef TWDEBUG
-       xf86DrvMsg(0, X_INFO, "301xSave: Part2 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
+       if(i>=0x80&&i<=0xbf)
+           xf86DrvMsg(0, X_INFO, "301xSave: Part2 (H scale coeff) 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
+       else if(i>=0xc0&&i<=0xff)
+           xf86DrvMsg(0, X_INFO, "301xSave: Part2 (V scale coeff) 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
+       else
+           xf86DrvMsg(0, X_INFO, "301xSave: Part2 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
 #endif
     }
+
     for(i=0; i<=p3; i++)  {
        inSISIDXREG(SISPART3, i, sisReg->VBPart3[i]);
 #ifdef TWDEBUG
@@ -1059,8 +1074,10 @@ SiS301BSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     } else if(pSiS->VBFlags2 & (VB2_301C | VB2_302ELV)) {
        Part2max = 0xff;
        Part4max = 0x3c;
-    } /* TODO for 307 */
-
+    } else if(pSiS->VBFlags2 &(VB2_307LV | VB2_307T)){
+       Part2max = 0xff;
+       Part4max = 0xff;
+    }
     SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);
 
     sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
@@ -1083,7 +1100,10 @@ SiS301BRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     } else if(pSiS->VBFlags2 & (VB2_301C|VB2_302ELV)) {
        Part2max = 0xff;
        Part4max = 0x3c;
-    } /* TODO for 307 */
+    } else if(pSiS->VBFlags2 &(VB2_307LV | VB2_307T)){
+       Part2max = 0xff;
+       Part4max = 0x90;
+    }
 
     SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO + 0x30);
     SiSSetLVDSetc(pSiS->SiS_Pr, 0);
@@ -1152,7 +1172,11 @@ SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     int     i;
 
     /* Save Part1 */
-    for(i=0; i<0x46; i++) {
+
+    /*Chaoyu Modified: Number of register should be 0x4e*/
+    /*for(i=0; i<0x46; i++) {*/
+
+   for(i=0; i<0x4e; i++) {
        inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
 #ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -1243,6 +1267,7 @@ SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
     if(pSiS->VGAEngine == SIS_315_VGA) {
        SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
        SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));  /* Panel Link Scaler */
+	outSISIDXREG(SISPART1, 0x24, sisReg->VBPart1[0x24]);  /* Chaoyu Modified:  reg[0x24] si not restored */
     }
 
     /* For 550 DSTN registers */
@@ -1301,6 +1326,8 @@ SiSMclk(SISPtr pSiS)
     case PCI_CHIP_SIS330:
     case PCI_CHIP_SIS660:
     case PCI_CHIP_SIS340:
+    case PCI_CHIP_SIS670:
+    case PCI_CHIP_SIS671:
     case PCI_CHIP_XGIXG20:
     case PCI_CHIP_XGIXG40:
 
@@ -1432,7 +1459,8 @@ SiSEstimateCRT2Clock(ScrnInfoPtr pScrn, Bool FakeForCRT2)
 }
 
 /* Calculate the maximum dotclock */
-int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
+int
+SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2, Bool quiet)
 {
 	SISPtr pSiS = SISPTR(pScrn);
 #ifdef SISDUALHEAD
@@ -1455,31 +1483,26 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 #ifdef __SUNPRO_C
 #undef const
 #endif
+	static const char *maxpixstr = "Maximum pixel clock at %d bpp is %g MHz\n";
 
 	switch(pSiS->Chipset) {
 
 	case PCI_CHIP_SIS5597:
 		total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
 		if(total > 135000) total = 135000;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			"Maximum pixel clock at %d bpp is %g MHz\n",
-			bpp, total/1000);
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, maxpixstr, bpp, total/1000);
 		return(int)(total);
 
 	case PCI_CHIP_SIS6326:
 		total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
 		if(total > 175500) total = 175500;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			"Maximum pixel clock at %d bpp is %g MHz\n",
-			bpp, total/1000);
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, maxpixstr, bpp, total/1000);
 		return(int)(total);
 
 	case PCI_CHIP_SIS530:
 		total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
 		if(total > 230000) total = 230000;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			"Maximum pixel clock at %d bpp is %g MHz\n",
-			bpp, total/1000);
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, maxpixstr, bpp, total/1000);
 		return(int)(total);
 
 	case PCI_CHIP_SIS300:
@@ -1493,6 +1516,8 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 	case PCI_CHIP_SIS330:
 	case PCI_CHIP_SIS660:
 	case PCI_CHIP_SIS340:
+	case PCI_CHIP_SIS670:
+	case PCI_CHIP_SIS671:
 	case PCI_CHIP_XGIXG20:
 	case PCI_CHIP_XGIXG40:
 		switch(pSiS->Chipset) {
@@ -1528,6 +1553,7 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 		       magic = magicINT[bus/64];
 		    }
 		    max = 680000;
+		    break;
 		case PCI_CHIP_SIS340:
 		case PCI_CHIP_XGIXG40:
 		    magic = magicDED[bus/64];
@@ -1537,6 +1563,11 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 		    magic = 1.0; /* magicDED[bus/64]; */
 		    max = 332000;
 		    break;
+		case PCI_CHIP_SIS670:
+		case PCI_CHIP_SIS671:
+		    magic = magicINT[bus/64];
+		    max = 680000; /* ? */
+		    break;
 		}
 
 		PDEBUG(ErrorF("mclk: %d, bus: %d, magic: %g, bpp: %d\n",
@@ -1544,8 +1575,10 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 
 		total = mclk * bus / bpp;
 
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		if(!quiet) {
+		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 			"Memory bandwidth at %d bpp is %g MHz\n", bpp, total/1000);
+		}
 
 		if((pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {
 
@@ -1613,9 +1646,11 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 
 			     }
 
-			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			     if(!quiet) {
+			        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 				  "Bandwidth reserved for CRT2 is %g MHz\n",
 				      crt2used/1000);
+			     }
 
 			} else {
 #ifdef SISDUALHEAD
@@ -1627,20 +1662,26 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 
 			     if(crt2clock) {
 				total -= (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
-				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				   "Bandwidth reserved for CRT2 at %d bpp is %g Mhz\n",
-				      bpp,
-				      (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
+				if(!quiet) {
+				   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				      "Bandwidth reserved for CRT2 at %d bpp is %g Mhz\n",
+				         bpp,
+				         (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
+				}
 			     } else {
 				total -= (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
-				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				   "Bandwidth reserved for CRT2 at %d bpp is %d Mhz\n",
+				if(!quiet) {
+				   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				      "Bandwidth reserved for CRT2 at %d bpp is %d Mhz\n",
 				      bpp,
 				      (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
+				}
 			     }
 
-			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				 "Bandwidth available for CRT1 is %g MHz\n", total/1000);
+			     if(!quiet) {
+			        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				    "Bandwidth available for CRT1 is %g MHz\n", total/1000);
+			     }
 #endif
 			}
 
@@ -1657,11 +1698,13 @@ int SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)
 				crt2used = total;
 			    }
 			}
-			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			  "Bandwidth reserved for CRT2 is %g Mhz\n", crt2used/1000);
 
-			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			  "Bandwidth available for CRT1 is %g MHz\n", total/1000);
+			if(!quiet) {
+			   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"Bandwidth reserved for CRT2 is %g Mhz\n", crt2used/1000);
+			   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"Bandwidth available for CRT1 is %g MHz\n", total/1000);
+			}
 
 		    }
 
@@ -1693,6 +1736,7 @@ SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
      int     i, j, index;
      int     myshift = 8 - pScrn->rgbBits;
      UChar   backup = 0;
+     CARD32  val;
      Bool    dogamma1 = pSiS->CRT1gamma;
      Bool    resetxvgamma = FALSE;
 #ifdef SISDUALHEAD
@@ -1701,8 +1745,6 @@ SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
      if(pSiS->DualHeadMode) dogamma1 = pSiSEnt->CRT1gamma;
 #endif
 
-     PDEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "LoadPalette()\n"));
-
 #ifdef SISDUALHEAD
      if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
 #endif
@@ -1746,12 +1788,11 @@ SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
 		   for(i=0; i<numColors; i++) {
 		      index = indices[i];
 		      if(index < 64) {  /* Paranoia */
+		         val = (colors[index].green     << (myshift + 8))  |
+			       (colors[index >> 1].blue << (myshift + 16)) |
+			       (colors[index >> 1].red  << myshift);
 			 for(j=0; j<4; j++) {
-			    SIS_MMIO_OUT32(pSiS->IOBase, 0x8570,
-					   (colors[index].green     << (myshift + 8))  |
-					   (colors[index >> 1].blue << (myshift + 16)) |
-					   (colors[index >> 1].red  << myshift)        |
-					   (((index << 2) + j)      << 24));
+			    SIS_MMIO_OUT32(pSiS->IOBase, 0x8570,  val | (((index << 2) + j) << 24));
 			 }
 		      }
 		   }
@@ -1832,6 +1873,8 @@ SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
 	   }
 	}
 
+	if(pSiS->ChipType == SIS_770)		andSISIDXREG(SISSR,0x07,~0x04);
+
 #ifdef SISDUALHEAD
     }
 #endif
@@ -1965,35 +2008,20 @@ SISDACPreInit(ScrnInfoPtr pScrn)
        IsForCRT2 = TRUE;
 #endif
 
-    pSiS->MaxClock = SiSMemBandWidth(pScrn, IsForCRT2);
-
-    switch (pSiS->Chipset) {
-       case PCI_CHIP_SIS550:
-       case PCI_CHIP_SIS315:
-       case PCI_CHIP_SIS315H:
-       case PCI_CHIP_SIS315PRO:
-       case PCI_CHIP_SIS650:
-       case PCI_CHIP_SIS330:
-       case PCI_CHIP_SIS660:
-       case PCI_CHIP_SIS340:
-       case PCI_CHIP_XGIXG20:
-       case PCI_CHIP_XGIXG40:
-          pSiS->SiSSave     = SiS315Save;
-          pSiS->SiSRestore  = SiS315Restore;
-          break;
-       case PCI_CHIP_SIS300:
-       case PCI_CHIP_SIS540:
-       case PCI_CHIP_SIS630:
-          pSiS->SiSSave     = SiS300Save;
-          pSiS->SiSRestore  = SiS300Restore;
-          break;
-       case PCI_CHIP_SIS5597:
-       case PCI_CHIP_SIS6326:
-       case PCI_CHIP_SIS530:
-       default:
-          pSiS->SiSSave     = SiSSave;
-          pSiS->SiSRestore  = SiSRestore;
-          break;
+    pSiS->MaxClock = SiSMemBandWidth(pScrn, IsForCRT2, FALSE);
+
+    switch(pSiS->VGAEngine) {
+    case SIS_315_VGA:
+       pSiS->SiSSave     = SiS315Save;
+       pSiS->SiSRestore  = SiS315Restore;
+       break;
+    case SIS_300_VGA:
+       pSiS->SiSSave     = SiS300Save;
+       pSiS->SiSRestore  = SiS300Restore;
+       break;
+    default:
+       pSiS->SiSSave     = SiSSave;
+       pSiS->SiSRestore  = SiSRestore;
     }
 }
 
diff --git a/src/sis_dac.h b/src/sis_dac.h
index 1eee1a0..98c9a33 100644
--- a/src/sis_dac.h
+++ b/src/sis_dac.h
@@ -38,11 +38,14 @@ void SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indicies,
 void SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD,
                         unsigned int *vclk);
 void SiSIODump(ScrnInfoPtr pScrn);
-int  SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2);
+int  SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2, Bool quiet);
 int  SiSMclk(SISPtr pSiS);
 void SiSRestoreBridge(ScrnInfoPtr pScrn, SISRegPtr sisReg);
 void SiS_UpdateGammaCRT2(ScrnInfoPtr pScrn);
 
+extern void	SISWaitRetraceCRT1(ScrnInfoPtr pScrn);
+extern void	SISWaitRetraceCRT2(ScrnInfoPtr pScrn);
+
 extern void	SiS6326SetTVReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data);
 extern UChar	SiS6326GetTVReg(ScrnInfoPtr pScrn, CARD8 index);
 extern void	SiS6326SetXXReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data);
diff --git a/src/sis_dga.c b/src/sis_dga.c
index 648aa0c..12e8477 100644
--- a/src/sis_dga.c
+++ b/src/sis_dga.c
@@ -58,6 +58,9 @@ static void SIS_FillRect(ScrnInfoPtr, int, int, int, int, unsigned long);
 static void SIS_BlitRect(ScrnInfoPtr, int, int, int, int, int, int);
 static void SIS_BlitTransRect(ScrnInfoPtr, int, int, int, int, int, int, unsigned long);
 
+extern DisplayModePtr	SiSSearchMode(ScrnInfoPtr pScrn, DisplayModePtr modelist,
+						DisplayModePtr mode, Bool *needreset);
+
 static
 DGAFunctionRec SISDGAFuncs = {
    SIS_OpenFramebuffer,
@@ -96,7 +99,8 @@ SISSetupDGAMode(
    ULong red,
    ULong green,
    ULong blue,
-   short visualClass
+   short visualClass,
+   Bool quiet
 ){
    SISPtr pSiS = SISPTR(pScrn);
    DGAModePtr newmodes = NULL, currentMode;
@@ -138,9 +142,9 @@ SISSetupDGAMode(
 		 nogood = TRUE;
 	   }
 	   if(nogood) {
-	      if(depth == 16) { /* Print this only the first time */
+	      if((depth == 16) && !quiet) { /* Print this only the first time */
 		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"DGA: MetaMode %dx%d not suitable for DGA, skipping\n",
+			"DGA: MetaMode %dx%d not suitable for DGA\n",
 			pMode->HDisplay, pMode->VDisplay);
 	      }
 	      goto mode_nogood;
@@ -246,79 +250,123 @@ mode_nogood:
     return modes;
 }
 
-Bool
-SISDGAInit(ScreenPtr pScreen)
+static DGAModePtr
+SISDGAMakeModes(ScrnInfoPtr pScrn, int *num, Bool quiet)
 {
-   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-   SISPtr pSiS = SISPTR(pScrn);
-   DGAModePtr modes = NULL;
-   int num = 0;
+    SISPtr pSiS = SISPTR(pScrn);
+    DGAModePtr modes = NULL;
+
+    *num = 0;
 
-   /* 8 */
-   /* We don't support 8bpp modes in dual head or MergedFB mode,
-    * so don't offer them to DGA either.
-    */
+    /* 8 */
+    /* We don't support 8bpp modes in dual head or MergedFB mode,
+     * so don't offer them to DGA either.
+     */
 #ifdef SISDUALHEAD
-   if(!pSiS->DualHeadMode) {
+    if(!pSiS->DualHeadMode) {
 #endif
 #ifdef SISMERGED
-      if(!(pSiS->MergedFB)) {
+       if(!(pSiS->MergedFB)) {
 #endif
-         modes = SISSetupDGAMode(pScrn, modes, &num, 8, 8,
+          modes = SISSetupDGAMode(pScrn, modes, num, 8, 8,
 				 (pScrn->bitsPerPixel == 8),
 				 ((pScrn->bitsPerPixel != 8)
 				     ? 0 : pScrn->displayWidth),
-				 0, 0, 0, PseudoColor);
+				 0, 0, 0, PseudoColor, quiet);
 #ifdef SISMERGED
-      }
+       }
 #endif
 #ifdef SISDUALHEAD
-   }
+    }
 #endif
 
-   /* 16 */
-   modes = SISSetupDGAMode(pScrn, modes, &num, 16, 16,
+    /* 16 */
+    modes = SISSetupDGAMode(pScrn, modes, num, 16, 16,
 			   (pScrn->bitsPerPixel == 16),
 			   ((pScrn->depth != 16)
 				? 0 : pScrn->displayWidth),
-			   0xf800, 0x07e0, 0x001f, TrueColor);
+			   0xf800, 0x07e0, 0x001f, TrueColor, quiet);
 
-   if((pSiS->VGAEngine == SIS_530_VGA) || (pSiS->VGAEngine == SIS_OLD_VGA)) {
-      /* 24 */
-      modes = SISSetupDGAMode(pScrn, modes, &num, 24, 24,
+    /* 24 */
+    if((pSiS->VGAEngine == SIS_530_VGA) || (pSiS->VGAEngine == SIS_OLD_VGA)) {
+       modes = SISSetupDGAMode(pScrn, modes, num, 24, 24,
 			      (pScrn->bitsPerPixel == 24),
 			      ((pScrn->bitsPerPixel != 24)
 				 ? 0 : pScrn->displayWidth),
-			      0xff0000, 0x00ff00, 0x0000ff, TrueColor);
-   }
+			      0xff0000, 0x00ff00, 0x0000ff, TrueColor, quiet);
+    }
 
-   if(pSiS->VGAEngine != SIS_OLD_VGA) {
-      /* 32 */
-      modes = SISSetupDGAMode(pScrn, modes, &num, 32, 24,
+    /* 32 */
+    if(pSiS->VGAEngine != SIS_OLD_VGA) {
+       modes = SISSetupDGAMode(pScrn, modes, num, 32, 24,
 			      (pScrn->bitsPerPixel == 32),
 			      ((pScrn->bitsPerPixel != 32)
 				  ? 0 : pScrn->displayWidth),
-			      0xff0000, 0x00ff00, 0x0000ff, TrueColor);
-   }
-
-   pSiS->numDGAModes = num;
-   pSiS->DGAModes = modes;
-
-   if(num) {
-      if((pSiS->VGAEngine == SIS_300_VGA) ||
-         (pSiS->VGAEngine == SIS_315_VGA) ||
-         (pSiS->VGAEngine == SIS_530_VGA)) {
-         return DGAInit(pScreen, &SISDGAFuncs3xx, modes, num);
-      } else {
-         return DGAInit(pScreen, &SISDGAFuncs, modes, num);
-      }
-   } else {
-      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			      0xff0000, 0x00ff00, 0x0000ff, TrueColor, quiet);
+    }
+
+    return modes;
+}
+
+Bool
+SISDGAInit(ScreenPtr pScreen)
+{
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    SISPtr pSiS = SISPTR(pScrn);
+    int num = 0;
+
+    pSiS->DGAModes = SISDGAMakeModes(pScrn, &num, FALSE);
+    pSiS->numDGAModes = num;
+
+    if(num) {
+       if((pSiS->VGAEngine == SIS_300_VGA) ||
+          (pSiS->VGAEngine == SIS_315_VGA) ||
+          (pSiS->VGAEngine == SIS_530_VGA)) {
+          return DGAInit(pScreen, &SISDGAFuncs3xx, pSiS->DGAModes, num);
+       } else {
+          return DGAInit(pScreen, &SISDGAFuncs, pSiS->DGAModes, num);
+       }
+    } else {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		"No DGA-suitable modes found, disabling DGA\n");
-      return TRUE;
-   }
+       return TRUE;
+    }
+}
+
+/* DGAReInit:
+ * Re-initialize our DGA modes. Needs X.org 6.9+.
+ * For older versions, DGA will be disabled if
+ * the dynamic modelist is enabled.
+ */
+Bool
+SISDGAReInit(ScrnInfoPtr pScrn)
+{
+#ifdef SISISXORG6899900
+    SISPtr pSiS = SISPTR(pScrn);
+    DGAModePtr newdgamodes = NULL;
+    int newdgamodenum = 0;
+
+    /* DGA wasn't enabled */
+    if(!pSiS->DGAModes || !pSiS->numDGAModes)
+       return TRUE;
+
+    newdgamodes = SISDGAMakeModes(pScrn, &newdgamodenum, TRUE);
+
+    if(DGAReInitModes(screenInfo.screens[pScrn->scrnIndex], newdgamodes, newdgamodenum)) {
+       xfree(pSiS->DGAModes);
+       pSiS->DGAModes = newdgamodes;
+       pSiS->numDGAModes = newdgamodenum;
+       return TRUE;
+    } else {
+       xfree(newdgamodes);
+       return FALSE;
+    }
+#else
+    return TRUE;
+#endif
 }
 
+
 static Bool
 SIS_OpenFramebuffer(
    ScrnInfoPtr pScrn,
@@ -359,9 +407,9 @@ SIS_SetMode(
    ScrnInfoPtr pScrn,
    DGAModePtr pMode
 ){
-   static SISFBLayout BackupLayouts[MAXSCREENS];
-   int index = pScrn->pScreen->myNum;
-   SISPtr pSiS = SISPTR(pScrn);
+    static SISFBLayout BackupLayouts[MAXSCREENS];
+    int index = pScrn->pScreen->myNum;
+    SISPtr pSiS = SISPTR(pScrn);
 
     if(!pMode) { /* restore the original mode */
 
@@ -378,6 +426,12 @@ SIS_SetMode(
 
     } else {	/* set new mode */
 
+	/* Check if this mode is still there. This is
+	 * due to our new dynamic modelist handling.
+	 */
+        if(!pMode->mode)
+           return FALSE;
+
         if(!pSiS->DGAactive) {
 	    /* save the old parameters */
 	    memcpy(&BackupLayouts[index], &pSiS->CurrentLayout, sizeof(SISFBLayout));
@@ -385,6 +439,7 @@ SIS_SetMode(
 	}
 
 	pSiS->CurrentLayout.bitsPerPixel  = pMode->bitsPerPixel;
+	pSiS->CurrentLayout.bytesPerPixel = pMode->bitsPerPixel >> 3;
 	pSiS->CurrentLayout.depth         = pMode->depth;
 	pSiS->CurrentLayout.displayWidth  = pMode->bytesPerScanline / (pMode->bitsPerPixel >> 3);
 	pSiS->CurrentLayout.displayHeight = pMode->imageHeight;
@@ -414,12 +469,12 @@ SIS_SetViewport(
    int x, int y,
    int flags
 ){
-   SISPtr pSiS = SISPTR(pScrn);
+    SISPtr pSiS = SISPTR(pScrn);
 
-   (*pScrn->AdjustFrame)(pScrn->pScreen->myNum, x, y, flags);
-   pSiS->DGAViewportStatus = 0;  /* There are never pending Adjusts */
-   pSiS->CurrentLayout.DGAViewportX = x;
-   pSiS->CurrentLayout.DGAViewportY = y;
+    (*pScrn->AdjustFrame)(pScrn->pScreen->myNum, x, y, flags);
+    pSiS->DGAViewportStatus = 0;  /* There are never pending Adjusts */
+    pSiS->CurrentLayout.DGAViewportX = x;
+    pSiS->CurrentLayout.DGAViewportY = y;
 }
 
 static void
diff --git a/src/sis_dri.c b/src/sis_dri.c
index 404290d..26bdf5e 100644
--- a/src/sis_dri.c
+++ b/src/sis_dri.c
@@ -57,8 +57,11 @@ extern Bool drmSiSAgpInit(int driSubFD, int offset, int size);
 #ifdef XORG_VERSION_CURRENT
 #define SISHAVECREATEBUSID
 #if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(6,7,99,1,0)
+ /*I.L. modified*/
+#ifndef XSERVER_LIBPCIACCESS
 extern char *DRICreatePCIBusID(pciVideoPtr PciInfo);
 #endif
+#endif
 #else
 # if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,4,99,9,0)
 # undef SISHAVECREATEBUSID
@@ -106,6 +109,7 @@ static char SISKernelDriverName[] = "sis";
 /* The client side DRI drivers are different: */
 static char SISClientDriverNameSiS300[] = "sis";	/* 300, 540, 630, 730 */
 static char SISClientDriverNameSiS315[] = "sis315";	/* All of 315/330 series */
+static char SISClientDriverNameSiS671[] = "sis671";	/* for sis671 */
 static char SISClientDriverNameXGI[]    = "xgi";	/* XGI V3, V5, V8 */
 
 static Bool SISInitVisualConfigs(ScreenPtr pScreen);
@@ -123,6 +127,10 @@ static void SISDRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index);
 static void SISDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
                    RegionPtr prgnSrc, CARD32 index);
 
+
+
+extern pthread_mutex_t *CmdQ_Lock;
+
 static Bool
 SISInitVisualConfigs(ScreenPtr pScreen)
 {
@@ -204,8 +212,8 @@ SISInitVisualConfigs(ScreenPtr pScreen)
 	        pConfigs[i].accumBlueSize  = 0;
 	        pConfigs[i].accumAlphaSize = 0;
 	     }
-	     if(db) pConfigs[i].doubleBuffer = TRUE;
-	     else   pConfigs[i].doubleBuffer = FALSE;
+	     if(db) pConfigs[i].doubleBuffer = FALSE;
+	     else   pConfigs[i].doubleBuffer = TRUE;
 	     pConfigs[i].stereo = FALSE;
 	     pConfigs[i].bufferSize = -1;
 	     switch(z_stencil) {
@@ -218,11 +226,11 @@ SISInitVisualConfigs(ScreenPtr pScreen)
 	        pConfigs[i].stencilSize = 0;
 	        break;
 	     case 2:
-	       pConfigs[i].depthSize = 32;
+	       pConfigs[i].depthSize = 20;
 	       pConfigs[i].stencilSize = 0;
 	       break;
 	     case 3:
-	       pConfigs[i].depthSize = 24;
+	       pConfigs[i].depthSize = 20;
 	       pConfigs[i].stencilSize = 8;
 	       break;
              }
@@ -258,6 +266,7 @@ SISInitVisualConfigs(ScreenPtr pScreen)
   return TRUE;
 }
 
+
 Bool
 SISDRIScreenInit(ScreenPtr pScreen)
 {
@@ -309,7 +318,10 @@ SISDRIScreenInit(ScreenPtr pScreen)
   } else if(pSIS->ChipFlags & SiSCF_IsXGI) {
      pDRIInfo->clientDriverName = SISClientDriverNameXGI;
   } else {
-     pDRIInfo->clientDriverName = SISClientDriverNameSiS315;
+     if (pSIS->Chipset == PCI_CHIP_SIS671)
+	 	pDRIInfo->clientDriverName = SISClientDriverNameSiS671;
+     else
+	 	pDRIInfo->clientDriverName = SISClientDriverNameSiS315;
   }
 
 #ifdef SISHAVECREATEBUSID
@@ -351,7 +363,10 @@ SISDRIScreenInit(ScreenPtr pScreen)
 #endif
   pDRIInfo->frameBufferSize = pSIS->FbMapSize;
 
-  /* scrnOffset is being calulated in sis_vga.c */
+  /* scrnOffset is being calulated in sis_vga.c. It
+   * is constant throughout server livetime (apart
+   * from when DGA is active)
+   */
   pDRIInfo->frameBufferStride = pSIS->scrnOffset;
 
   pDRIInfo->ddxDrawableTableEntry = SIS_MAX_DRAWABLES;
@@ -362,17 +377,9 @@ SISDRIScreenInit(ScreenPtr pScreen)
      pDRIInfo->maxDrawableTableEntry = SIS_MAX_DRAWABLES;
 
 #ifdef NOT_DONE
-  /* FIXME need to extend DRI protocol to pass this size back to client
-   * for SAREA mapping that includes a device private record
-   */
   pDRIInfo->SAREASize =
     ((sizeof(XF86DRISAREARec) + getpagesize() - 1) & getpagesize()); /* round to page */
-    /* ((sizeof(XF86DRISAREARec) + 0xfff) & 0x1000); */ /* round to page */
-  /* + shared memory device private rec */
 #else
-  /* For now the mapping works by using a fixed size defined
-   * in the SAREA header
-   */
   if(sizeof(XF86DRISAREARec) + sizeof(SISSAREAPriv) > SAREA_MAX) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		"[dri] Data does not fit in SAREA. Disabling the DRI.\n");
@@ -404,6 +411,7 @@ SISDRIScreenInit(ScreenPtr pScreen)
      DRIDestroyInfoRec(pSIS->pDRIInfo);
      pSIS->pDRIInfo = 0;
      pSIS->drmSubFD = -1;
+     pSIS->DRIEnabled = FALSE;
      return FALSE;
   }
 
@@ -430,7 +438,13 @@ SISDRIScreenInit(ScreenPtr pScreen)
         drm_sis_fb_t fb;
         fb.offset = pSIS->DRIheapstart;
         fb.size = pSIS->DRIheapend - pSIS->DRIheapstart;
-        drmCommandWrite(pSIS->drmSubFD, DRM_SIS_FB_INIT, &fb, sizeof(fb));
+        if (drmCommandWrite(pSIS->drmSubFD, DRM_SIS_FB_INIT, &fb, sizeof(fb))) {
+           xf86DrvMsg(pScreen->myNum, X_ERROR,
+                      "[dri] Initializing Video RAM heap failed. Disabling DRI.\n");
+           drmFreeVersion(version);
+           SISDRICloseScreen(pScreen);
+           return FALSE;
+        }
         xf86DrvMsg(pScreen->myNum, X_INFO,
 		"[dri] Video RAM memory heap: 0x%0x to 0x%0x (%dKB)\n",
 		pSIS->DRIheapstart, pSIS->DRIheapend,
@@ -440,20 +454,21 @@ SISDRIScreenInit(ScreenPtr pScreen)
   }
 #endif
 
-  /* MMIO */
-  pSISDRI->regs.size = SISIOMAPSIZE;
-#ifndef SISISXORG6899900
-  pSISDRI->regs.map = 0;
-#endif
+    
+ /* MMIO */
+	pSISDRI->regs.size = SISIOMAPSIZE;
+/* chris, marked */
+/*#ifndef SISISXORG6899900*/
+	pSISDRI->regs.map = 0;
+/*#endif*/
   if(drmAddMap(pSIS->drmSubFD, (drm_handle_t)pSIS->IOAddress,
 		pSISDRI->regs.size, DRM_REGISTERS, 0,
 		&pSISDRI->regs.handle) < 0) {
      SISDRICloseScreen(pScreen);
      return FALSE;
   }
-
-  xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] MMIO registers mapped to 0x%0x\n",
-		pSISDRI->regs.handle);
+	xf86DrvMsg(pScreen->myNum, X_INFO, "[dri] handle = 0x%x, size = %d\n",
+				pSISDRI->regs.handle, pSISDRI->regs.size);
 
   /* AGP */
   do {
@@ -649,6 +664,63 @@ SISDRIScreenInit(ScreenPtr pScreen)
 
   pSISDRI->irqEnabled = pSIS->irqEnabled;
 
+#ifdef ENABLEXvMC  
+   /*XvMC support setting: 
+     Allocate 4K Agp memory for overlay register, and 7 or 8MB for XvMC. 
+     Physical address follow the agp of dri ( for 3d ).
+   */
+   pSIS->numSurfaces = 0;
+   pSIS->MC_AgpAllocHandle = 0;
+   switch(pSIS->ChipType){
+      case SIS_741:
+      case SIS_662:
+      case SIS_671:
+         pSIS->numSurfaces = 6;
+         break;
+      default:
+         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[MC] Sorry, we don't support XvMC on this chip.\n");
+         break;
+   }
+   if (pSIS->numSurfaces) {
+      drm_handle_t agpHandle;
+      pSIS->MC_AgpAlloc.Start = pSIS->agpWantedSize;
+      if (pSIS->numSurfaces == 6) {
+	 pSIS->MC_AgpAlloc.Size = 7 * 1024 * 1024 + 4096;
+	 /*pSIS->MC.Start = pSIS->FbMapSize - 7 * 1024 * 1024*/ ;
+      }
+      if (pSIS->numSurfaces == 8) {
+	 pSIS->MC_AgpAlloc.Size = 9 * 1024 * 1024 + 4096;
+	 /*pSIS->MC.Start = pSIS->FbMapSize - 8 * 1024 * 1024 */;
+      }
+      drmAgpAlloc(pSIS->drmSubFD, pSIS->MC_AgpAlloc.Size, 0, &pSIS->MC_AgpAlloc.Start ,
+		  (drmAddress) &agpHandle);
+      
+      pSIS->MC_AgpAllocHandle = agpHandle;
+
+      if (agpHandle != DRM_AGP_NO_HANDLE) {
+	 if (drmAgpBind(pSIS->drmSubFD, agpHandle, pSIS->agpWantedSize) == 0) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       "[MC] GART: Allocated %dKB for HWMC\n", (pSIS->MC_AgpAlloc.Size/1024));
+	    pSIS->MC_AgpAlloc.End = pSIS->MC_AgpAlloc.Start + pSIS->MC_AgpAlloc.Size;
+           pSIS->MC_AgpAlloc.DRM_Success = TRUE; /* Karma@080304 Check DRM Enbale */
+	 } else {
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "[MC] GART: HWMC bind failed\n");
+	    pSIS->MC_AgpAlloc.Start = 0;
+	    pSIS->MC_AgpAlloc.Size = 0;
+	    pSIS->MC_AgpAlloc.End = 0;
+           pSIS->MC_AgpAlloc.DRM_Success = FALSE; /* Karma@080304 Check DRM Enbale */
+	 }
+      } else {
+	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "[MC] GART: HWMC alloc failed\n");
+	 pSIS->MC_AgpAlloc.Start = 0;
+	 pSIS->MC_AgpAlloc.Size = 0;
+	 pSIS->MC_AgpAlloc.End = 0;
+        pSIS->MC_AgpAlloc.DRM_Success = FALSE; /* Karma@080304 Check DRM Enbale */
+      }
+      pSIS->xvmcContext = 0;
+   }
+#endif
+
   if(!(SISInitVisualConfigs(pScreen))) {
      SISDRICloseScreen(pScreen);
      return FALSE;
@@ -673,6 +745,8 @@ SISDRIFinishScreenInit(ScreenPtr pScreen)
   pSISDRI->deviceID = pSiS->Chipset;
 #ifdef SIS315DRI
   pSISDRI->deviceRev= pSiS->ChipRev;
+  pSISDRI->cmdQueueOffset = pSiS->cmdQueueOffset;
+  pSISDRI->cmdQueueSize = pSiS->cmdQueueSize;
 #endif
   pSISDRI->width    = pScrn->virtualX;
   pSISDRI->height   = pScrn->virtualY;
@@ -682,12 +756,6 @@ SISDRIFinishScreenInit(ScreenPtr pScreen)
   /* TODO */
   pSISDRI->scrnX    = pSISDRI->width;
   pSISDRI->scrnY    = pSISDRI->height;
-
-  /* Offset of the front buffer (relative from beginning
-   * of video RAM). This is usually 0, but eventually not
-   * if running on a SiS76x with LFB and UMA memory.
-   * THE DRI DRIVER DOES NOT USE THIS YET (MESA 6.2.1)
-   */
   pSISDRI->fbOffset      = pSiS->FbBaseOffset;
 
   /* These are unused. Offsets are set up by the DRI */
@@ -705,6 +773,7 @@ SISDRIFinishScreenInit(ScreenPtr pScreen)
     assert(saPriv);
 
     saPriv->CtxOwner = -1;
+	CmdQ_Lock = &(saPriv->CmdQ_Lock);
 
     switch(pSiS->VGAEngine) {
 
@@ -712,18 +781,12 @@ SISDRIFinishScreenInit(ScreenPtr pScreen)
     case SIS_315_VGA:
        saPriv->AGPVtxBufNext = 0;
 
-       saPriv->QueueLength = pSiS->cmdQueueSize;  /* Total (not: current) size, in bytes! */
-
-       /* Copy current queue position to sarea */
+       saPriv->QueueLength = pSiS->cmdQueueSize; 
        saPriv->sharedWPoffset = *(pSiS->cmdQ_SharedWritePort);
-       /* Delegate our shared offset to current queue position */
+       saPriv->agpCmdBufWriteOffset = 0xFFFFFFFF;
        pSiS->cmdQ_SharedWritePortBackup = pSiS->cmdQ_SharedWritePort;
        pSiS->cmdQ_SharedWritePort = &(saPriv->sharedWPoffset);
 
-       saPriv->cmdQueueOffset = pSiS->cmdQueueOffset;
-
-       /* TODO: Reset frame control */
-
        break;
 #endif
 
@@ -779,6 +842,15 @@ SISDRICloseScreen(ScreenPtr pScreen)
      pSIS->irq = 0;
   }
 
+#ifdef ENABLEXvMC
+   if(pSIS->MC_AgpAllocHandle){
+      if(drmAgpUnbind(pSIS->drmSubFD, pSIS->MC_AgpAllocHandle) != 0)
+         xf86DrvMsg(pScreen->myNum, X_ERROR, "[MC] Unbind AGP Failed!\n");
+      if(drmAgpFree(pSIS->drmSubFD, pSIS->MC_AgpAllocHandle) != 0)
+         xf86DrvMsg(pScreen->myNum, X_ERROR, "[MC] Free AGP Failed!\n");
+   }
+#endif
+
   if(pSIS->agpSize){
      xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Freeing AGP memory\n");
      drmAgpUnbind(pSIS->drmSubFD, pSIS->agpHandle);
@@ -788,6 +860,8 @@ SISDRICloseScreen(ScreenPtr pScreen)
      pSIS->agpSize = 0;
   }
 
+
+
   DRICloseScreen(pScreen);
 
   if(pSIS->pDRIInfo) {
diff --git a/src/sis_dri.h b/src/sis_dri.h
index ad57ed6..be42ec7 100644
--- a/src/sis_dri.h
+++ b/src/sis_dri.h
@@ -48,15 +48,19 @@
 #define SIS_MAX_DRAWABLES 256
 #define SISIOMAPSIZE (64*1024)
 
+#include <pthread.h>
+
 typedef struct {
   int CtxOwner;
   int QueueLength;		/* (300: current, 315/etc: total) length of command queue */
   unsigned int AGPCmdBufNext;   /* (rename to AGPVtxBufNext) */
   unsigned int FrameCount;
 #ifdef SIS315DRI
+  unsigned int agpCmdBufWriteOffset;
   unsigned int  sharedWPoffset;	/* Offset to current queue position (shared with 2D) */
-  unsigned int  cmdQueueOffset;	/* Offset of start of command queue in VRAM */
 #endif
+  pthread_mutex_t CmdQ_Lock;
+
 } SISSAREAPriv, *SISSAREAPrivPtr;
 
 #define AGPVtxBufNext AGPCmdBufNext
@@ -68,9 +72,10 @@ typedef struct {
 typedef struct {
   drm_handle_t handle;
   drmSize size;
-#ifndef SISISXORG6899900
+/* chris, remove the variable for compatible with sizeof(SISDRIRec) in 3D driver(sis315_dri.so) */
+/*#ifndef SISISXORG6899900*/
   drmAddress map;
-#endif
+/*#endif*/
 } sisRegion, *sisRegionPtr;
 
 typedef struct {
@@ -94,10 +99,8 @@ typedef struct {
   unsigned int scrnX;			/* TODO: = width = pScrn->virtualX */
   unsigned int scrnY;			/* TODO: = height = pScrn->virtualY */
 #ifdef SIS315DRI
-  unsigned char *AGPCmdBufBase;
-  unsigned long AGPCmdBufAddr;
-  unsigned long AGPCmdBufOffset2;	/* (rename to AGPCmdBufOffset) */
-  unsigned int  AGPCmdBufSize2;		/* (rename to AGPCmdBufSize)   */
+  unsigned int  cmdQueueOffset;	        /* Offset of start of command queue in VRAM */                                            /* Size of VRAM command queue */
+  unsigned int  cmdQueueSize; 
   int deviceRev;			/* Chip revision */
 #endif
 } SISDRIRec, *SISDRIPtr;
diff --git a/src/sis_driver.c b/src/sis_driver.c
index cbbb12d..4c00a8f 100644
--- a/src/sis_driver.c
+++ b/src/sis_driver.c
@@ -28,10 +28,6 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  * Author: Thomas Winischhofer <thomas@winischhofer.net>
- *	- driver entirely rewritten since 2001, only basic structure taken from
- *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
- *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
- *	  new versions of the DRI layer)
  *
  * This notice covers the entire driver code unless indicated otherwise.
  *
@@ -43,6 +39,37 @@
  *           Juanjo Santamarta <santamarta@ctv.es>,
  *           Mitani Hiroshi <hmitani@drl.mei.co.jp>,
  *           David Thomas <davtom@dream.org.uk>.
+ *
+ * TW thoughts:
+ * - start by default in MergedFB mode, even if only one
+ *   device is detected. Check what mode would be used
+ *   if MergedFB mode wasn't enabled, see if a clone mode
+ *   of this mode is defined (or create one if not) and
+ *   use this (meta)mode as the start mode. This allows
+ *   "switching" to mergedfb mode upon output device
+ *   reconfiguration.
+ *   Needs consideration in RebuildModelists: We need to
+ *   eventually create one such clone mode for each
+ *   CRT1 and CRT2.
+ *   Disadvantages: -) high memory consumption because
+ *   the virtual screen size must include eventual
+ *   "reserves" for later; -) ReserveLargeVirtual is
+ *   not implemented for MergedFB mode atm. Would need
+ *   that to fully make sense.
+ * - user should be able to disable one output device
+ *   in any MetaMode. Switch to clone mode automatically?
+ *   (very likely sisctrl-material, not driver material.
+ * - If metamodes statement is missing and we create MetaModes
+ *   out of tallest/widest mode, also add "reverse" modes if
+ *   CRT2Position is not set. (Assume these "reversed" modes
+ *   being "specialxinerama" modes to avoid bad calculation
+ *   of Xinerama info. Problem: These modes (the normal one
+ *   and the reversed one) are of same size, so a RandR
+ *   event will not lead to the window manager updating
+ *   its into. Idea: Perhaps SiSCtrl can switch to a different
+ *   size in the middle when it detects two identically
+ *   sized metamodes? - Ugly...)
+ *
  */
 
 #ifdef HAVE_CONFIG_H
@@ -92,40 +119,23 @@
 /* Globals (yes, these ARE really required to be global) */
 
 #ifdef SISUSEDEVPORT
-int 		sisdevport = 0;
+int		sisdevport = 0;
 #endif
 
 #ifdef SISDUALHEAD
 static int	SISEntityIndex = -1;
 #endif
 
-#ifdef SISMERGED
-#ifdef SISXINERAMA
-static Bool 		SiSnoPanoramiXExtension = TRUE;
-static int		SiSXineramaNumScreens = 0;
-static SiSXineramaData	*SiSXineramadataPtr = NULL;
-static int		SiSXineramaGeneration;
-
-static int SiSProcXineramaQueryVersion(ClientPtr client);
-static int SiSProcXineramaGetState(ClientPtr client);
-static int SiSProcXineramaGetScreenCount(ClientPtr client);
-static int SiSProcXineramaGetScreenSize(ClientPtr client);
-static int SiSProcXineramaIsActive(ClientPtr client);
-static int SiSProcXineramaQueryScreens(ClientPtr client);
-static int SiSSProcXineramaDispatch(ClientPtr client);
-#endif
-#endif
-
 /*
- * This is intentionally screen-independent.  It indicates the binding
+ * This is intentionally screen-independent. It indicates the binding
  * choice made in the first PreInit.
  */
 static int pix24bpp = 0;
 
 /*
  * This contains the functions needed by the server after loading the driver
- * module.  It must be supplied, and gets passed back by the SetupProc
- * function in the dynamic case.  In the static case, a reference to this
+ * module. It must be supplied, and gets passed back by the SetupProc
+ * function in the dynamic case. In the static case, a reference to this
  * is compiled in, and this requires that the name of this DriverRec be
  * an upper-case version of the driver name.
  */
@@ -160,8 +170,10 @@ static SymTabRec SISChipsets[] = {
     { PCI_CHIP_SIS550,	    "SIS550" },
     { PCI_CHIP_SIS650,      "SIS650/M650/651/740" },
     { PCI_CHIP_SIS330,      "SIS330(Xabre)" },
-    { PCI_CHIP_SIS660,      "SIS660/[M]661[F|M]X/[M]670/[M]741[GX]/[M]760[GX]/[M]761[GX]/[M]770[GX]" },
+    { PCI_CHIP_SIS660,      "SIS[M]661[F|M]X/[M]741[GX]/[M]760[GX]/[M]761[GX]/662" },
     { PCI_CHIP_SIS340,      "SIS340" },
+    { PCI_CHIP_SIS670,      "[M]670/[M]770[GX]" },   
+    { PCI_CHIP_SIS671,      "[M]671/[M]771[GX]" },
     { -1,                   NULL }
 };
 
@@ -180,12 +192,14 @@ static PciChipsets SISPciChipsets[] = {
     { PCI_CHIP_SIS330,      PCI_CHIP_SIS330,    RES_SHARED_VGA },
     { PCI_CHIP_SIS660,      PCI_CHIP_SIS660,    RES_SHARED_VGA },
     { PCI_CHIP_SIS340,      PCI_CHIP_SIS340,    RES_SHARED_VGA },
+    { PCI_CHIP_SIS670,      PCI_CHIP_SIS670,    RES_SHARED_VGA },
+    { PCI_CHIP_SIS671,      PCI_CHIP_SIS671,    RES_SHARED_VGA },
     { -1,                   -1,                 RES_UNDEFINED }
 };
 
 static SymTabRec XGIChipsets[] = {
     { PCI_CHIP_XGIXG20,     "Volari Z7 (XG20)" },
-    { PCI_CHIP_XGIXG40,     "Volari V3XT/V5/V8/Duo (XG40)" },
+    { PCI_CHIP_XGIXG40,     "Volari V3XT/V5/V8/Duo (XG40/XG42)" },
     { -1,                   NULL }
 };
 
@@ -207,7 +221,7 @@ static const char *xaaSymbols[] = {
 
 #ifdef SIS_USE_EXA
 static const char *exaSymbols[] = {
-    "exaDriverAccel",
+    "exaGetVersion",
     "exaDriverInit",
     "exaDriverFini",
     "exaOffscreenAlloc",
@@ -236,7 +250,6 @@ static const char *ramdacSymbols[] = {
 
 static const char *ddcSymbols[] = {
     "xf86PrintEDID",
-    "xf86SetDDCproperties",
     "xf86InterpretEDID",
     NULL
 };
@@ -381,24 +394,242 @@ SISIdentify(int flags)
     xf86PrintChipsets(SIS_NAME, "driver for XGI chipsets", XGIChipsets);
 }
 
+/****************************************************/
+/*          DriverFunc (formerly "RRFunc")          */
+/****************************************************/
+
+#ifdef SIS_HAVE_RR_FUNC
+
 #ifdef SIS_HAVE_DRIVER_FUNC
+#define SISDRIVERFUNCOPTYPE xorgDriverFuncOp
+#define SISDRIVERFUNCPTRTYPE pointer
+#else
+#define SISDRIVERFUNCOPTYPE xorgRRFuncFlags
+#define SISDRIVERFUNCPTRTYPE xorgRRRotationPtr
+#endif
+
 static Bool
-SISDriverFunc(ScrnInfoPtr pScrn, xorgDriverFuncOp op, pointer ptr)
+SISDriverFunc(ScrnInfoPtr pScrn, SISDRIVERFUNCOPTYPE op, SISDRIVERFUNCPTRTYPE ptr)
 {
-    CARD32 *flag;
+#ifdef SIS_HAVE_DRIVER_FUNC
+    xorgHWFlags *flag;
+#endif
+    xorgRRRotation *rot;
+#ifdef SIS_HAVE_RR_GET_MODE_MM
+    xorgRRModeMM *modemm;
+#endif
 
     switch(op) {
     case RR_GET_INFO:
+	rot = (xorgRRRotation *)ptr;
+	rot->RRRotations = RR_Rotate_0;
 	break;
     case RR_SET_CONFIG:
+	return TRUE;
+#ifdef SIS_HAVE_RR_GET_MODE_MM
+    case RR_GET_MODE_MM:
+        modemm = (xorgRRModeMM *)ptr;
+        return SiS_GetModeMM(pScrn, modemm->mode, modemm->virtX, modemm->virtY,
+					&modemm->mmWidth, &modemm->mmHeight);
 	break;
+#endif
+#ifdef SIS_HAVE_DRIVER_FUNC
     case GET_REQUIRED_HW_INTERFACES:
+	flag = (xorgHWFlags *)ptr;
+	(*flag) = HW_IO | HW_MMIO;
+	return TRUE;
 	break;
+#endif
+    default:
+	return FALSE;
     }
     return TRUE;
 }
+#undef SISDRIVERFUNCOPTYPE
+#undef SISDRIVERFUNCPTRTYPE
 #endif
 
+
+/****************************************************/
+/*                     Probe()                      */
+/****************************************************/
+
+
+static Bool
+SISProbe(DriverPtr drv, int flags)
+{
+    int     i;
+    GDevPtr *devSections;
+    int     *usedChipsSiS, *usedChipsXGI;
+    int     numDevSections;
+    int     numUsed, numUsedSiS, numUsedXGI;
+    Bool    foundScreen = FALSE;
+
+    /*
+     * The aim here is to find all cards that this driver can handle,
+     * and for the ones not already claimed by another driver, claim
+     * the slot, and allocate a ScrnInfoRec.
+     *
+     * This should be a minimal probe, and it should under no circumstances
+     * change the state of the hardware.  Because a device is found, don't
+     * assume that it will be used.  Don't do any initialisations other than
+     * the required ScrnInfoRec initialisations.  Don't allocate any new
+     * data structures.
+     *
+     */
+
+    /*
+     * Next we check, if there has been a chipset override in the config file.
+     * For this we must find out if there is an active device section which
+     * is relevant, i.e., which has no driver specified or has THIS driver
+     * specified.
+     */
+
+    if((numDevSections = xf86MatchDevice(SIS_DRIVER_NAME, &devSections)) <= 0) {
+       /*
+        * There's no matching device section in the config file, so quit
+        * now.
+        */
+       return FALSE;
+    }
+
+    /*
+     * We need to probe the hardware first.  We then need to see how this
+     * fits in with what is given in the config file, and allow the config
+     * file info to override any contradictions.
+     */
+
+    /*
+     * All of the cards this driver supports are PCI, so the "probing" just
+     * amounts to checking the PCI data that the server has already collected.
+     */
+#ifndef XSERVER_LIBPCIACCESS
+    if(xf86GetPciVideoInfo() == NULL) {
+       /*
+        * We won't let anything in the config file override finding no
+        * PCI video cards at all.
+        */
+       return FALSE;
+    }
+#endif
+
+
+    numUsedSiS = xf86MatchPciInstances(SIS_NAME, PCI_VENDOR_SIS,
+			SISChipsets, SISPciChipsets, devSections,
+			numDevSections, drv, &usedChipsSiS);
+
+    numUsedXGI = xf86MatchPciInstances(SIS_NAME, PCI_VENDOR_XGI,
+			XGIChipsets, XGIPciChipsets, devSections,
+			numDevSections, drv, &usedChipsXGI);
+
+    /* Free it since we don't need that list after this */
+    xfree(devSections);
+
+    numUsed = numUsedSiS + numUsedXGI;
+
+    if(numUsed <= 0)
+       return FALSE;
+
+    if(flags & PROBE_DETECT) {
+
+	foundScreen = TRUE;
+
+    } else for(i = 0; i < numUsed; i++) {
+
+	ScrnInfoPtr pScrn;
+#ifdef SISDUALHEAD
+	EntityInfoPtr pEnt;
+#endif
+
+	/* Allocate a ScrnInfoRec and claim the slot */
+	pScrn = NULL;
+
+	if((pScrn = xf86ConfigPciEntity(pScrn, 0,
+			(i < numUsedSiS) ? usedChipsSiS[i] : usedChipsXGI[i-numUsedSiS],
+			(i < numUsedSiS) ? SISPciChipsets  : XGIPciChipsets,
+			NULL, NULL, NULL, NULL, NULL))) {
+	    /* Fill in what we can of the ScrnInfoRec */
+	    pScrn->driverVersion    = SIS_CURRENT_VERSION;
+	    pScrn->driverName       = SIS_DRIVER_NAME;
+	    pScrn->name             = SIS_NAME;
+	    pScrn->Probe            = SISProbe;
+	    pScrn->PreInit          = SISPreInit;
+	    pScrn->ScreenInit       = SISScreenInit;
+	    pScrn->SwitchMode       = SISSwitchMode;
+	    pScrn->AdjustFrame      = SISAdjustFrame;
+	    pScrn->EnterVT          = SISEnterVT;
+	    pScrn->LeaveVT          = SISLeaveVT;
+	    pScrn->FreeScreen       = SISFreeScreen;
+	    pScrn->ValidMode        = SISValidMode;
+	    pScrn->PMEvent          = SISPMEvent; /*add PM function for ACPI hotkey,Ivans*/
+#ifdef X_XF86MiscPassMessage
+	    if(xf86GetVersion() >= XF86_VERSION_NUMERIC(4,3,99,2,0)) {
+	       pScrn->HandleMessage = SISHandleMessage;
+	    }
+#endif
+	    foundScreen = TRUE;
+	}
+
+#ifdef SISDUALHEAD
+	pEnt = xf86GetEntityInfo((i < numUsedSiS) ? usedChipsSiS[i] : usedChipsXGI[i-numUsedSiS]);
+
+	switch(pEnt->chipset) {
+	case PCI_CHIP_SIS300:
+	case PCI_CHIP_SIS540:
+	case PCI_CHIP_SIS630:
+	case PCI_CHIP_SIS550:
+	case PCI_CHIP_SIS315:
+	case PCI_CHIP_SIS315H:
+	case PCI_CHIP_SIS315PRO:
+	case PCI_CHIP_SIS650:
+	case PCI_CHIP_SIS330:
+	case PCI_CHIP_SIS660:
+	case PCI_CHIP_SIS340:
+	case PCI_CHIP_SIS670:
+	case PCI_CHIP_SIS671:
+	case PCI_CHIP_XGIXG40:
+	    {
+	       SISEntPtr pSiSEnt = NULL;
+	       DevUnion  *pPriv;
+
+	       xf86SetEntitySharable((i < numUsedSiS) ? usedChipsSiS[i] : usedChipsXGI[i-numUsedSiS]);
+	       if(SISEntityIndex < 0) {
+		  SISEntityIndex = xf86AllocateEntityPrivateIndex();
+	       }
+	       pPriv = xf86GetEntityPrivate(pScrn->entityList[0], SISEntityIndex);
+	       if(!pPriv->ptr) {
+		  pPriv->ptr = xnfcalloc(sizeof(SISEntRec), 1);
+		  pSiSEnt = pPriv->ptr;
+		  memset(pSiSEnt, 0, sizeof(SISEntRec));
+		  pSiSEnt->lastInstance = -1;
+	       } else {
+		  pSiSEnt = pPriv->ptr;
+	       }
+	       pSiSEnt->lastInstance++;
+	       xf86SetEntityInstanceForScreen(pScrn, pScrn->entityList[0],
+						pSiSEnt->lastInstance);
+	    }
+	    break;
+
+	default:
+	    break;
+	}
+#endif /* DUALHEAD */
+
+    }
+
+    if(usedChipsSiS) xfree(usedChipsSiS);
+    if(usedChipsXGI) xfree(usedChipsXGI);
+
+    return foundScreen;
+}
+
+/*****************************************************/
+/*                 PreInit() helpers                 */
+/*****************************************************/
+
+/* Allocate/Free pSiS */
+
 static Bool
 SISGetRec(ScrnInfoPtr pScrn)
 {
@@ -406,7 +637,8 @@ SISGetRec(ScrnInfoPtr pScrn)
      * pScrn->driverPrivate is initialised to NULL, so we can check if
      * the allocation has already been done.
      */
-    if(pScrn->driverPrivate != NULL) return TRUE;
+    if(pScrn->driverPrivate != NULL)
+       return TRUE;
 
     pScrn->driverPrivate = xnfcalloc(sizeof(SISRec), 1);
 
@@ -425,16 +657,22 @@ SISFreeRec(ScrnInfoPtr pScrn)
 #endif
 
     /* Just to make sure... */
-    if(!pSiS) return;
+    if(!pSiS)
+       return;
 
 #ifdef SISDUALHEAD
     pSiSEnt = pSiS->entityPrivate;
 #endif
 
-    if(pSiS->pstate) xfree(pSiS->pstate);
-    pSiS->pstate = NULL;
-    if(pSiS->fonts) xfree(pSiS->fonts);
-    pSiS->fonts = NULL;
+    if(pSiS->pstate) {
+       xfree(pSiS->pstate);
+       pSiS->pstate = NULL;
+    }
+
+    if(pSiS->fonts) {
+       xfree(pSiS->fonts);
+       pSiS->fonts = NULL;
+    }
 
 #ifdef SISDUALHEAD
     if(pSiSEnt) {
@@ -444,12 +682,18 @@ SISFreeRec(ScrnInfoPtr pScrn)
 	   * and we need the BIOS image and SiS_Private for the first
 	   * head.
 	   */
-	  if(pSiSEnt->BIOS) xfree(pSiSEnt->BIOS);
+	  if(pSiSEnt->BIOS)
+	     xfree(pSiSEnt->BIOS);
 	  pSiSEnt->BIOS = pSiS->BIOS = NULL;
-	  if(pSiSEnt->SiS_Pr) xfree(pSiSEnt->SiS_Pr);
+
+	  if(pSiSEnt->SiS_Pr)
+	     xfree(pSiSEnt->SiS_Pr);
 	  pSiSEnt->SiS_Pr = pSiS->SiS_Pr = NULL;
-	  if(pSiSEnt->RenderAccelArray) xfree(pSiSEnt->RenderAccelArray);
+
+	  if(pSiSEnt->RenderAccelArray)
+	     xfree(pSiSEnt->RenderAccelArray);
 	  pSiSEnt->RenderAccelArray = pSiS->RenderAccelArray = NULL;
+
 	  pSiSEnt->pScrn_1 = NULL;
        } else {
 	  pSiS->BIOS = NULL;
@@ -459,46 +703,64 @@ SISFreeRec(ScrnInfoPtr pScrn)
        }
     } else {
 #endif
-       if(pSiS->BIOS) xfree(pSiS->BIOS);
-       pSiS->BIOS = NULL;
-       if(pSiS->SiS_Pr) xfree(pSiS->SiS_Pr);
-       pSiS->SiS_Pr = NULL;
-       if(pSiS->RenderAccelArray) xfree(pSiS->RenderAccelArray);
-       pSiS->RenderAccelArray = NULL;
+       if(pSiS->BIOS) {
+          xfree(pSiS->BIOS);
+          pSiS->BIOS = NULL;
+       }
+
+       if(pSiS->SiS_Pr) {
+          xfree(pSiS->SiS_Pr);
+          pSiS->SiS_Pr = NULL;
+       }
+
+       if(pSiS->RenderAccelArray) {
+          xfree(pSiS->RenderAccelArray);
+          pSiS->RenderAccelArray = NULL;
+       }
 #ifdef SISDUALHEAD
     }
 #endif
 #ifdef SISMERGED
-    if(pSiS->CRT2HSync) xfree(pSiS->CRT2HSync);
-    pSiS->CRT2HSync = NULL;
-    if(pSiS->CRT2VRefresh) xfree(pSiS->CRT2VRefresh);
-    pSiS->CRT2VRefresh = NULL;
-    if(pSiS->MetaModes) xfree(pSiS->MetaModes);
-    pSiS->MetaModes = NULL;
+    if(pSiS->CRT2HSync) {
+       xfree(pSiS->CRT2HSync);
+       pSiS->CRT2HSync = NULL;
+    }
+
+    if(pSiS->CRT2VRefresh) {
+       xfree(pSiS->CRT2VRefresh);
+       pSiS->CRT2VRefresh = NULL;
+    }
+
+    if(pSiS->MetaModes) {
+       xfree(pSiS->MetaModes);
+       pSiS->MetaModes = NULL;
+    }
+
     if(pSiS->CRT2pScrn) {
-       if(pSiS->CRT2pScrn->modes) {
-	  while(pSiS->CRT2pScrn->modes)
-	     xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
+       while(pSiS->CRT2pScrn->modes) {
+	  xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
        }
        if(pSiS->CRT2pScrn->monitor) {
-	  if(pSiS->CRT2pScrn->monitor->Modes) {
-	     while(pSiS->CRT2pScrn->monitor->Modes)
-	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
+	  while(pSiS->CRT2pScrn->monitor->Modes) {
+	     xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
 	  }
-	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
 	  xfree(pSiS->CRT2pScrn->monitor);
        }
        xfree(pSiS->CRT2pScrn);
        pSiS->CRT2pScrn = NULL;
     }
+
     if(pSiS->CRT1Modes) {
        if(pSiS->CRT1Modes != pScrn->modes) {
+          /* Free metamodes */
 	  if(pScrn->modes) {
 	     pScrn->currentMode = pScrn->modes;
 	     do {
 	        DisplayModePtr p = pScrn->currentMode->next;
 	        if(pScrn->currentMode->Private)
-	 	  xfree(pScrn->currentMode->Private);
+	 	   xfree(pScrn->currentMode->Private);
+	 	if(pScrn->currentMode->name)
+	 	   xfree(pScrn->currentMode->name);
 	        xfree(pScrn->currentMode);
 	        pScrn->currentMode = p;
 	     } while(pScrn->currentMode != pScrn->modes);
@@ -510,25 +772,65 @@ SISFreeRec(ScrnInfoPtr pScrn)
        }
     }
 #endif
+
+    /* Just clear pointer; it only points to
+     * one of the currcrtXXXXedid areas below
+     */
+    if(pScrn->monitor) {
+       pScrn->monitor->DDC = NULL;
+    }
+
+    if(pSiS->currcrt1analogedid) {
+       xfree(pSiS->currcrt1analogedid);
+       pSiS->currcrt1analogedid = NULL;
+    }
+
+    if(pSiS->currcrt1digitaledid) {
+       xfree(pSiS->currcrt1digitaledid);
+       pSiS->currcrt1digitaledid = NULL;
+    }
+
+    if(pSiS->currcrt2analogedid) {
+       xfree(pSiS->currcrt2analogedid);
+       pSiS->currcrt2analogedid = NULL;
+    }
+
+    if(pSiS->currcrt2digitaledid) {
+       xfree(pSiS->currcrt2digitaledid);
+       pSiS->currcrt2digitaledid = NULL;
+    }
+
+    if(pSiS->UserModes) {
+       while(pSiS->UserModes)
+	  xf86DeleteMode(&pSiS->UserModes, pSiS->UserModes);
+    }
+
     while(pSiS->SISVESAModeList) {
        sisModeInfoPtr mp = pSiS->SISVESAModeList->next;
        xfree(pSiS->SISVESAModeList);
        pSiS->SISVESAModeList = mp;
     }
-    if(pSiS->pVbe) vbeFree(pSiS->pVbe);
-    pSiS->pVbe = NULL;
+
+    if(pSiS->pVbe) {
+       vbeFree(pSiS->pVbe);
+       pSiS->pVbe = NULL;
+    }
 
 #ifdef SISUSEDEVPORT
-    if(pSiS->sisdevportopen)   close(sisdevport);
+    if(pSiS->sisdevportopen)
+       close(sisdevport);
 #endif
 
     if(pScrn->driverPrivate == NULL)
         return;
+
     xfree(pScrn->driverPrivate);
     pScrn->driverPrivate = NULL;
 }
 
-static void
+/* Log error */
+
+void
 SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...)
 {
     va_list ap;
@@ -546,371 +848,1385 @@ SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...)
 }
 
 static void
-SiS_SiSFB_Lock(ScrnInfoPtr pScrn, Bool lock)
+SiSPrintLogHeader(ScrnInfoPtr pScrn)
 {
-    SISPtr  pSiS = SISPTR(pScrn);
-    int     fd;
-    CARD32  parm;
 
-    if(!pSiS->sisfbfound) return;
-    if(!pSiS->sisfb_havelock) return;
+    /* Due to the liberal license terms this is needed for
+     * keeping the copyright notice readable and intact in
+     * binary distributions. Removing this is a copyright
+     * and license infringement. Please read the license
+     * terms above.
+     */
 
-    if((fd = open(pSiS->sisfbdevname, 'r')) != -1) {
-       parm = lock ? 1 : 0;
-       ioctl(fd, SISFB_SET_LOCK, &parm);
-       close(fd);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"SiS driver (%d/%02d/%02d-%d, compiled for " SISMYSERVERNAME " %d.%d.%d.%d)\n",
+	SISDRIVERVERSIONYEAR + 2000, SISDRIVERVERSIONMONTH,
+	SISDRIVERVERSIONDAY, SISDRIVERREVISION,
+#ifdef XORG_VERSION_CURRENT
+	XORG_VERSION_MAJOR, XORG_VERSION_MINOR,
+	XORG_VERSION_PATCH, XORG_VERSION_SNAP
+#else
+	XF86_VERSION_MAJOR, XF86_VERSION_MINOR,
+	XF86_VERSION_PATCH, XF86_VERSION_SNAP
+#endif
+	);
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"Copyright (C) 2001-2005 Thomas Winischhofer <thomas@winischhofer.net> and others\n");
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"*** See http://www.winischhofer.at/linuxsisvga.shtml\n");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"*** for documentation, updates and a Premium Version.\n");
+
+
+
+
+#ifdef XORG_VERSION_CURRENT
+#ifdef SISISXORG6899900
+/*	In some distributions, xorgGetVersion() has been removed.
+	for compatibility, we mark this section.*/
+/*
+    if(xorgGetVersion() != XORG_VERSION_CURRENT) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+         "This driver binary is not compiled for this version of " SISMYSERVERNAME "\n");
     }
+*/
+#endif
+#else
+#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
+	
+	if(xf86GetVersion() != XF86_VERSION_CURRENT) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+         "This driver binary is not compiled for this version of " SISMYSERVERNAME "\n");
+	}
+#endif
+#endif
+
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"RandR rotation support not available in this version.\n");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"Dynamic modelist support not available in this version.\n");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"Screen growing support not available in this version.\n");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"Advanced Xv video blitter not available in this version.\n");
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	"Advanced MergedFB support not available in this version.\n");
 }
 
-/* Probe()
- *
- * Mandatory
- */
-static Bool
-SISProbe(DriverPtr drv, int flags)
+/* Map standard VGA memory area */
+
+#ifdef SIS_PC_PLATFORM
+static void
+SiS_MapVGAMem(ScrnInfoPtr pScrn)
 {
-    int     i;
-    GDevPtr *devSections;
-    int     *usedChipsSiS, *usedChipsXGI;
-    int     numDevSections;
-    int     numUsed, numUsedSiS, numUsedXGI;
-    Bool    foundScreen = FALSE;
+    SISPtr pSiS = SISPTR(pScrn);
 
-    /*
-     * The aim here is to find all cards that this driver can handle,
-     * and for the ones not already claimed by another driver, claim the
-     * slot, and allocate a ScrnInfoRec.
-     *
-     * This should be a minimal probe, and it should under no circumstances
-     * change the state of the hardware.  Because a device is found, don't
-     * assume that it will be used.  Don't do any initialisations other than
-     * the required ScrnInfoRec initialisations.  Don't allocate any new
-     * data structures.
-     *
-     */
+    /* Map 64k VGA window for saving/restoring CGA fonts */
+    pSiS->VGAMapSize = 0x10000;
+    pSiS->VGAMapPhys = 0;	/* Default */
+    if((!pSiS->Primary) || (!pSiS->VGADecodingEnabled)) {
+       /* If card is secondary or if a0000-address decoding
+        * is disabled, set Phys to beginning of our video RAM.
+	*/
+       pSiS->VGAMapPhys = PCI_REGION_BASE( pSiS->PciInfo, 0, REGION_MEM);
+    }
+    if(!SiSVGAMapMem(pScrn)) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+	  "Failed to map VGA memory (0x%lx), can't save/restore console fonts\n",
+	  pSiS->VGAMapPhys);
+    }
+}
+#endif
 
-    /*
-     * Next we check, if there has been a chipset override in the config file.
-     * For this we must find out if there is an active device section which
-     * is relevant, i.e., which has no driver specified or has THIS driver
-     * specified.
+/* Load and initialize VBE module */
+
+static void
+SiS_LoadInitVBE(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    /* Don't load the VBE module for secondary
+     * cards which sisfb POSTed. We don't want
+     * int10 to overwrite our set up (such as
+     * disabled a0000 memory address decoding).
+     * We don't need the VBE anyway because
+     * the card will never be in text mode,
+     * and we can restore graphics modes just
+     * perfectly.
      */
+    if(!pSiS->Primary && pSiS->sisfbcardposted)
+       return;
 
-    if((numDevSections = xf86MatchDevice(SIS_DRIVER_NAME, &devSections)) <= 0) {
-       /*
-        * There's no matching device section in the config file, so quit
-        * now.
-        */
-       return FALSE;
+    if(pSiS->pVbe)
+       return;
+
+    if(xf86LoadSubModule(pScrn, "vbe")) {
+       xf86LoaderReqSymLists(vbeSymbols, NULL);
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
+       pSiS->pVbe = VBEInit(pSiS->pInt, pSiS->pEnt->index);
+#else
+       pSiS->pVbe = VBEExtendedInit(pSiS->pInt, pSiS->pEnt->index,
+	                SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
+#endif
     }
 
-    /*
-     * We need to probe the hardware first.  We then need to see how this
-     * fits in with what is given in the config file, and allow the config
-     * file info to override any contradictions.
-     */
+    if(!pSiS->pVbe) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+	   "Failed to load/initialize vbe module\n");
+    }
+}
 
-    /*
-     * All of the cards this driver supports are PCI, so the "probing" just
-     * amounts to checking the PCI data that the server has already collected.
-     */
-    if(xf86GetPciVideoInfo() == NULL) {
-       /*
-        * We won't let anything in the config file override finding no
-        * PCI video cards at all.
-        */
-       return FALSE;
+static Bool
+SiSLoadInitDDCModule(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    if(pSiS->haveDDC)
+       return TRUE;
+
+    if(xf86LoadSubModule(pScrn, "ddc")) {
+       xf86LoaderReqSymLists(ddcSymbols, NULL);
+       pSiS->haveDDC = TRUE;
+       return TRUE;
     }
 
-    numUsedSiS = xf86MatchPciInstances(SIS_NAME, PCI_VENDOR_SIS,
-			SISChipsets, SISPciChipsets, devSections,
-			numDevSections, drv, &usedChipsSiS);
+    return FALSE;
+}
 
-    numUsedXGI = xf86MatchPciInstances(SIS_NAME, PCI_VENDOR_XGI,
-			XGIChipsets, XGIPciChipsets, devSections,
-			numDevSections, drv, &usedChipsXGI);
+/* Look for and eventually communicate with sisfb */
 
-    /* Free it since we don't need that list after this */
-    xfree(devSections);
+static void
+SiS_CheckKernelFB(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    int        fd, i;
+    CARD32     sisfbinfosize = 0, sisfbversion;
+    sisfb_info *mysisfbinfo;
+    char       name[16];
 
-    numUsed = numUsedSiS + numUsedXGI;
+    pSiS->donttrustpdc = FALSE;
+    pSiS->sisfbpdc = 0xff;
+    pSiS->sisfbpdca = 0xff;
+    pSiS->sisfblcda = 0xff;
+    pSiS->sisfbscalelcd = -1;
+    pSiS->sisfbspecialtiming = CUT_NONE;
+    pSiS->sisfb_haveemi = FALSE;
+    pSiS->sisfbfound = FALSE;
+    pSiS->sisfb_tvposvalid = FALSE;
+    pSiS->sisfbdevname[0] = 0;
+    pSiS->sisfb_havelock = FALSE;
+    pSiS->sisfbHaveNewHeapDef = FALSE;
+    pSiS->sisfbHeapSize = 0;
+    pSiS->sisfbVideoOffset = 0;
+    pSiS->sisfbxSTN = FALSE;
+    pSiS->sisfbcanpost = FALSE;   /* (Old) sisfb can't POST card */
+    pSiS->sisfbcardposted = TRUE; /* If (old) sisfb is running, card must have been POSTed */
+    pSiS->sisfbprimary = FALSE;   /* (Old) sisfb doesn't know */
 
-    if(numUsed <= 0)
+    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+
+       i = 0;
+       do {
+
+	  if(i <= 7) {
+             sprintf(name, "/dev/fb%1d", i);
+	  } else {
+	     sprintf(name, "/dev/fb/%1d", (i - 8));
+	  }
+
+          if((fd = open(name, 'r')) != -1) {
+
+	     Bool gotit = FALSE;
+
+ 	     if(!ioctl(fd, SISFB_GET_INFO_SIZE, &sisfbinfosize)) {
+ 		if((mysisfbinfo = xalloc(sisfbinfosize))) {
+ 		   if(!ioctl(fd, (SISFB_GET_INFO | (sisfbinfosize << 16)), mysisfbinfo)) {
+ 		      gotit = TRUE;
+ 		   } else {
+ 		      xfree(mysisfbinfo);
+ 		      mysisfbinfo = NULL;
+ 		   }
+ 		}
+ 	     } else {
+ 		if((mysisfbinfo = xalloc(sizeof(*mysisfbinfo) + 16))) {
+ 		   if(!ioctl(fd, SISFB_GET_INFO_OLD, mysisfbinfo)) {
+ 		      gotit = TRUE;
+		      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+				"Possibly old version of sisfb detected. Please update.\n");
+		   } else {
+		      xfree(mysisfbinfo);
+		      mysisfbinfo = NULL;
+		   }
+		}
+	     }
+
+	     if(gotit) {
+
+		if(mysisfbinfo->sisfb_id == SISFB_ID) {
+
+		   sisfbversion = (mysisfbinfo->sisfb_version << 16) |
+				  (mysisfbinfo->sisfb_revision << 8) |
+				  (mysisfbinfo->sisfb_patchlevel);
+
+	           if(sisfbversion >= SISFB_VERSION(1, 5, 8)) {
+		      /* Added PCI bus/slot/func into in sisfb Version 1.5.08.
+		       * Check this to make sure we run on the same card as sisfb
+		       */
+		      if((mysisfbinfo->sisfb_pcibus  == pSiS->PciBus)    &&
+			 (mysisfbinfo->sisfb_pcislot == pSiS->PciDevice) &&
+			 (mysisfbinfo->sisfb_pcifunc == pSiS->PciFunc)) {
+			 pSiS->sisfbfound = TRUE;
+		      }
+		   } else pSiS->sisfbfound = TRUE;
+
+		   if(pSiS->sisfbfound) {
+		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			     "%s: SiS kernel fb driver (sisfb) %d.%d.%d detected (PCI:%02d:%02d.%d)\n",
+				&name[5],
+				mysisfbinfo->sisfb_version,
+				mysisfbinfo->sisfb_revision,
+				mysisfbinfo->sisfb_patchlevel,
+				pSiS->PciBus,
+				pSiS->PciDevice,
+				pSiS->PciFunc);
+
+		      /* Added version/rev/pl in sisfb 1.4.0 */
+		      if(mysisfbinfo->sisfb_version == 0) {
+			 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+				"Old version of sisfb found. Please update.\n");
+		      }
+		      /* Basically, we can't trust the pdc register if sisfb is loaded */
+		      pSiS->donttrustpdc = TRUE;
+		      pSiS->sisfbHeapStart = mysisfbinfo->heapstart;
+
+		      if(sisfbversion >= SISFB_VERSION(1, 7, 20)) {
+			 pSiS->sisfbHeapSize = mysisfbinfo->sisfb_heapsize;
+			 pSiS->sisfbVideoOffset = mysisfbinfo->sisfb_videooffset;
+			 pSiS->sisfbHaveNewHeapDef = TRUE;
+			 pSiS->sisfbFSTN = mysisfbinfo->sisfb_curfstn;
+			 pSiS->sisfbDSTN = mysisfbinfo->sisfb_curdstn;
+			 pSiS->sisfbxSTN = TRUE;
+			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"sisfb: memory heap at %dKB, size %dKB, viewport at %dKB\n",
+				(int)pSiS->sisfbHeapStart, (int)pSiS->sisfbHeapSize,
+				(int)pSiS->sisfbVideoOffset/1024);
+		      } else {
+			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"sisfb: memory heap at %dKB\n", (int)pSiS->sisfbHeapStart);
+		      }
+		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"sisfb: using video mode 0x%02x\n", mysisfbinfo->fbvidmode);
+		      pSiS->OldMode = mysisfbinfo->fbvidmode;
+		      if(sisfbversion >= SISFB_VERSION(1, 5, 6)) {
+			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"sisfb: using %s, reserved %dK\n",
+				(mysisfbinfo->sisfb_caps & 0x40) ? "SiS300 series Turboqueue" :
+				   (mysisfbinfo->sisfb_caps & 0x20) ? "AGP command queue" :
+				      (mysisfbinfo->sisfb_caps & 0x10) ? "VRAM command queue" :
+					(mysisfbinfo->sisfb_caps & 0x08) ? "MMIO mode" :
+					   "no command queue",
+				(int)mysisfbinfo->sisfb_tqlen);
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 5, 10)) {
+			 /* We can trust the pdc value if sisfb is of recent version */
+			 if(pSiS->VGAEngine == SIS_300_VGA) pSiS->donttrustpdc = FALSE;
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 5, 11)) {
+			 if(pSiS->VGAEngine == SIS_300_VGA) {
+			    /* As of 1.5.11, sisfb saved the register for us (300 series) */
+			    pSiS->sisfbpdc = mysisfbinfo->sisfb_lcdpdc;
+			    if(!pSiS->sisfbpdc) pSiS->sisfbpdc = 0xff;
+			 }
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 5, 14)) {
+			 if(pSiS->VGAEngine == SIS_315_VGA) {
+			    pSiS->sisfblcda = mysisfbinfo->sisfb_lcda;
+			 }
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 6, 13)) {
+			 pSiS->sisfbscalelcd = mysisfbinfo->sisfb_scalelcd;
+			 pSiS->sisfbspecialtiming = mysisfbinfo->sisfb_specialtiming;
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 6, 16)) {
+			 if(pSiS->VGAEngine == SIS_315_VGA) {
+			    pSiS->donttrustpdc = FALSE;
+			    pSiS->sisfbpdc = mysisfbinfo->sisfb_lcdpdc;
+			    if(sisfbversion >= SISFB_VERSION(1, 6, 24)) {
+			       pSiS->sisfb_haveemi = mysisfbinfo->sisfb_haveemi ? TRUE : FALSE;
+			       pSiS->sisfb_haveemilcd = TRUE;  /* will match most cases */
+			       pSiS->sisfb_emi30 = mysisfbinfo->sisfb_emi30;
+			       pSiS->sisfb_emi31 = mysisfbinfo->sisfb_emi31;
+			       pSiS->sisfb_emi32 = mysisfbinfo->sisfb_emi32;
+			       pSiS->sisfb_emi33 = mysisfbinfo->sisfb_emi33;
+			    }
+			    if(sisfbversion >= SISFB_VERSION(1, 6, 25)) {
+			       pSiS->sisfb_haveemilcd = mysisfbinfo->sisfb_haveemilcd ? TRUE : FALSE;
+			    }
+			    if(sisfbversion >= SISFB_VERSION(1, 6, 31)) {
+			       pSiS->sisfbpdca = mysisfbinfo->sisfb_lcdpdca;
+			    } else {
+			       if(pSiS->sisfbpdc) {
+				  pSiS->sisfbpdca = (pSiS->sisfbpdc & 0xf0) >> 3;
+				  pSiS->sisfbpdc  = (pSiS->sisfbpdc & 0x0f) << 1;
+			       } else {
+				  pSiS->sisfbpdca = pSiS->sisfbpdc = 0xff;
+			       }
+			    }
+			 }
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 7, 0)) {
+		         pSiS->sisfb_havelock = TRUE;
+			 if(sisfbversion >= SISFB_VERSION(1, 7, 1)) {
+			    pSiS->sisfb_tvxpos = mysisfbinfo->sisfb_tvxpos;
+			    pSiS->sisfb_tvypos = mysisfbinfo->sisfb_tvypos;
+			    pSiS->sisfb_tvposvalid = TRUE;
+			 }
+		      }
+		      if(sisfbversion >= SISFB_VERSION(1, 8, 7)) {
+			 pSiS->sisfbcanpost = (mysisfbinfo->sisfb_can_post) ? TRUE : FALSE;
+			 pSiS->sisfbcardposted = (mysisfbinfo->sisfb_card_posted) ? TRUE : FALSE;
+			 pSiS->sisfbprimary = (mysisfbinfo->sisfb_was_boot_device) ? TRUE : FALSE;
+			 /* Validity check */
+			 if(!pSiS->sisfbcardposted) {
+			    pSiS->sisfbprimary = FALSE;
+			 }
+		      }
+		   }
+	        }
+		xfree(mysisfbinfo);
+		mysisfbinfo = NULL;
+	     }
+	     close (fd);
+          }
+	  i++;
+       } while((i <= 15) && (!pSiS->sisfbfound));
+
+       if(pSiS->sisfbfound) {
+          strncpy(pSiS->sisfbdevname, name, 15);
+       } else {
+          xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "sisfb not found\n");
+       }
+    }
+
+    if(!pSiS->sisfbfound) {
+       pSiS->sisfbcardposted = FALSE;
+    }
+}
+
+/* ROM handling helpers */
+
+static Bool
+SISCheckBIOS(SISPtr pSiS, UShort mypciid, UShort mypcivendor, int biossize)
+{
+    UShort romptr, pciid;
+
+    if(!pSiS->BIOS)
        return FALSE;
 
-    if(flags & PROBE_DETECT) {
+    if((pSiS->BIOS[0] != 0x55) || (pSiS->BIOS[1] != 0xaa))
+       return FALSE;
 
-	foundScreen = TRUE;
+    romptr = pSiS->BIOS[0x18] | (pSiS->BIOS[0x19] << 8);
 
-    } else for(i = 0; i < numUsed; i++) {
+    if(romptr > (biossize - 8))
+       return FALSE;
 
-	ScrnInfoPtr pScrn;
+    if((pSiS->BIOS[romptr]   != 'P') || (pSiS->BIOS[romptr+1] != 'C') ||
+       (pSiS->BIOS[romptr+2] != 'I') || (pSiS->BIOS[romptr+3] != 'R'))
+       return FALSE;
+
+    pciid = pSiS->BIOS[romptr+4] | (pSiS->BIOS[romptr+5] << 8);
+    if(pciid != mypcivendor)
+       return FALSE;
+
+    pciid = pSiS->BIOS[romptr+6] | (pSiS->BIOS[romptr+7] << 8);
+    if(pciid != mypciid)
+       return FALSE;
+    return TRUE;
+}
+
+static void
+SiSReadROM(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
 #ifdef SISDUALHEAD
-	EntityInfoPtr pEnt;
+    SISEntPtr pSiSEnt = pSiS->entityPrivate;
 #endif
 
-	/* Allocate a ScrnInfoRec and claim the slot */
-	pScrn = NULL;
+    pSiS->SiS_Pr->VirtualRomBase = NULL;
+    pSiS->BIOS = NULL;
+    pSiS->ROMPCIENew = FALSE;
+    pSiS->SiS_Pr->UseROM = FALSE;
+    pSiS->ROM661New = FALSE;
+    pSiS->HaveXGIBIOS = FALSE;
 
-	if((pScrn = xf86ConfigPciEntity(pScrn, 0,
-			(i < numUsedSiS) ? usedChipsSiS[i] : usedChipsXGI[i-numUsedSiS],
-			(i < numUsedSiS) ? SISPciChipsets  : XGIPciChipsets,
-			NULL, NULL, NULL, NULL, NULL))) {
-	    /* Fill in what we can of the ScrnInfoRec */
-	    pScrn->driverVersion    = SIS_CURRENT_VERSION;
-	    pScrn->driverName       = SIS_DRIVER_NAME;
-	    pScrn->name             = SIS_NAME;
-	    pScrn->Probe            = SISProbe;
-	    pScrn->PreInit          = SISPreInit;
-	    pScrn->ScreenInit       = SISScreenInit;
-	    pScrn->SwitchMode       = SISSwitchMode;
-	    pScrn->AdjustFrame      = SISAdjustFrame;
-	    pScrn->EnterVT          = SISEnterVT;
-	    pScrn->LeaveVT          = SISLeaveVT;
-	    pScrn->FreeScreen       = SISFreeScreen;
-	    pScrn->ValidMode        = SISValidMode;
-#ifdef X_XF86MiscPassMessage
-	    if(xf86GetVersion() >= XF86_VERSION_NUMERIC(4,3,99,2,0)) {
-	       pScrn->HandleMessage = SISHandleMessage;
-	    }
+    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
+#ifdef SISDUALHEAD
+       if(pSiSEnt) {
+	  if(pSiSEnt->BIOS) {
+	     pSiS->BIOS = pSiSEnt->BIOS;
+	     pSiS->SiS_Pr->VirtualRomBase = pSiS->BIOS;
+	     pSiS->ROM661New = pSiSEnt->ROM661New;
+	     pSiS->HaveXGIBIOS = pSiSEnt->HaveXGIBIOS;
+	  }
+       }
 #endif
-	    foundScreen = TRUE;
-	}
+       if(!pSiS->BIOS) {
+	  if(!(pSiS->BIOS = xcalloc(1, BIOS_SIZE))) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		"Could not allocate memory for video BIOS image\n");
+	  } else {
+	     ULong  segstart;
+	     UShort mypciid = pSiS->Chipset;
+	     UShort mypcivendor = (pSiS->ChipFlags & SiSCF_IsXGI) ? PCI_VENDOR_XGI : PCI_VENDOR_SIS;
+	     Bool   found = FALSE, readpci = FALSE;
+	     int    biossize = BIOS_SIZE;
+
+	     switch(pSiS->ChipType) {
+	     case SIS_315:    mypciid = PCI_CHIP_SIS315;
+			      readpci = TRUE;
+			      break;
+	     case SIS_315PRO: mypciid = PCI_CHIP_SIS315PRO;
+			      readpci = TRUE;
+			      break;
+	     case SIS_300:
+	     case SIS_315H:
+	     case SIS_330:
+	     case SIS_340:
+	     case SIS_341:
+	     case SIS_342:
+	     case XGI_40:     readpci = TRUE;
+			      break;
+	     case XGI_20:     readpci = TRUE;
+			      biossize = 0x8000;
+			      break;
+	     }
+
+	     if(readpci) {
+		xf86ReadPciBIOS(0, pSiS->PciTag, 0, pSiS->BIOS, biossize);
+		if(SISCheckBIOS(pSiS, mypciid, mypcivendor, biossize)) {
+		   found = TRUE;
+		}
+	     }
+
+	     if(!found) {
+		for(segstart = BIOS_BASE; segstart < 0x000f0000; segstart += 0x00001000) {
+
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
+		   if(xf86ReadBIOS(segstart, 0, pSiS->BIOS, biossize) != biossize) continue;
+#else
+#ifndef XSERVER_LIBPCIACCESS
+		   if(xf86ReadDomainMemory(pSiS->PciTag, segstart, biossize, pSiS->BIOS) != biossize) continue;
+#else
+		   if(pci_device_read_rom(pSiS->PciInfo, pSiS->BIOS) != biossize) continue;
+#endif
+#endif
+
+		   if(!SISCheckBIOS(pSiS, mypciid, mypcivendor, biossize)) continue;
 
+		   found = TRUE;
+		   break;
+		}
+             }
+
+	     if(found) {
+		UShort romptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
+		pSiS->SiS_Pr->VirtualRomBase = pSiS->BIOS;
+		if(pSiS->ChipFlags & SiSCF_IsXGI) {
+		   pSiS->HaveXGIBIOS = pSiS->SiS_Pr->SiS_XGIROM = TRUE;
+		   pSiS->SiS_Pr->UseROM = FALSE;
+		   if(pSiS->ChipFlags & SiSCF_IsXGIV3) {
+		      if(!(pSiS->BIOS[0x1d1] & 0x01)) {
+			 pSiS->SiS_Pr->DDCPortMixup = TRUE;
+		      }
+	           }
+	        } else {
+		   pSiS->ROM661New = SiSDetermineROMLayout661(pSiS->SiS_Pr);
+		   if(pSiS->ROM661New){
+                       /* The version number begin with 2 support AGP interface, and the version number begin with 3 support PCIE interface. */
+                       if(pSiS->BIOS[romptr]=='3'){
+                           pSiS->ROMPCIENew = TRUE; 
+                           pSiS->BIOSVersion = atoi((char *)(&pSiS->BIOS[romptr+2]));
+                       }
+		   }
+		}
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			"Video BIOS version \"%7s\" found (%s data layout)\n",
+			&pSiS->BIOS[romptr], pSiS->ROM661New ? "new SiS" :
+				(pSiS->HaveXGIBIOS ? "XGI" : "old SiS"));
+		if(pSiS->SiS_Pr->DDCPortMixup) {
+		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			"*** Buggy XGI V3XT card detected: If VGA and DVI are connected at the\n");
+		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			"*** same time, BIOS and driver will be unable to detect DVI connection.\n");
+		}
 #ifdef SISDUALHEAD
-	pEnt = xf86GetEntityInfo((i < numUsedSiS) ? usedChipsSiS[i] : usedChipsXGI[i-numUsedSiS]);
+		if(pSiSEnt) {
+		   pSiSEnt->BIOS = pSiS->BIOS;
+		   pSiSEnt->ROM661New = pSiS->ROM661New;
+		   pSiSEnt->HaveXGIBIOS = pSiS->HaveXGIBIOS;
+		}
+#endif
+	     } else {
+	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			 "Could not find/read video BIOS\n");
+		xfree(pSiS->BIOS);
+		pSiS->BIOS = NULL;
+	     }
+          }
+       }
 
-	if(pEnt->chipset == PCI_CHIP_SIS630 || pEnt->chipset == PCI_CHIP_SIS540 ||
-	   pEnt->chipset == PCI_CHIP_SIS650 || pEnt->chipset == PCI_CHIP_SIS550 ||
-	   pEnt->chipset == PCI_CHIP_SIS315 || pEnt->chipset == PCI_CHIP_SIS315H ||
-	   pEnt->chipset == PCI_CHIP_SIS315PRO || pEnt->chipset == PCI_CHIP_SIS330 ||
-	   pEnt->chipset == PCI_CHIP_SIS300 || pEnt->chipset == PCI_CHIP_SIS660 ||
-	   pEnt->chipset == PCI_CHIP_SIS340 || pEnt->chipset == PCI_CHIP_XGIXG40) {
+       if(!(pSiS->ChipFlags & SiSCF_IsXGI)) {
+          pSiS->SiS_Pr->UseROM = (pSiS->BIOS) ? TRUE : FALSE;
+          if(pSiS->SiS_Pr->UseROM == TRUE) pSiS->SiS_Pr->BIOSVersion = pSiS->BIOSVersion;
+       }
+    }
+}
 
-	    SISEntPtr pSiSEnt = NULL;
-	    DevUnion  *pPriv;
+/* Copy from and to SiS entity */
 
-	    xf86SetEntitySharable((i < numUsedSiS) ? usedChipsSiS[i] : usedChipsXGI[i-numUsedSiS]);
-	    if(SISEntityIndex < 0) {
-	       SISEntityIndex = xf86AllocateEntityPrivateIndex();
-	    }
-	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], SISEntityIndex);
-	    if(!pPriv->ptr) {
-	       pPriv->ptr = xnfcalloc(sizeof(SISEntRec), 1);
-	       pSiSEnt = pPriv->ptr;
-	       memset(pSiSEnt, 0, sizeof(SISEntRec));
-	       pSiSEnt->lastInstance = -1;
-	    } else {
-	       pSiSEnt = pPriv->ptr;
-	    }
-	    pSiSEnt->lastInstance++;
-	    xf86SetEntityInstanceForScreen(pScrn, pScrn->entityList[0],
-	                                   pSiSEnt->lastInstance);
-	}
-#endif /* DUALHEAD */
+#ifdef SISDUALHEAD
+static void
+SiSCopyFromToEntity(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    SISEntPtr pSiSEnt = pSiS->entityPrivate;
 
+    if(pSiS->DualHeadMode) {
+       if(!pSiS->SecondHead) {
+	  /* Copy some option settings to entity private */
+	  pSiSEnt->HWCursor = pSiS->HWCursor;
+	  pSiSEnt->NoAccel = pSiS->NoAccel;
+	  pSiSEnt->useEXA = pSiS->useEXA;
+	  pSiSEnt->restorebyset = pSiS->restorebyset;
+	  pSiSEnt->OptROMUsage = pSiS->OptROMUsage;
+	  pSiSEnt->OptUseOEM = pSiS->OptUseOEM;
+	  pSiSEnt->TurboQueue = pSiS->TurboQueue;
+	  pSiSEnt->forceCRT1 = pSiS->forceCRT1;
+	  pSiSEnt->ForceCRT1Type = pSiS->ForceCRT1Type;
+	  pSiSEnt->CRT1TypeForced = pSiS->CRT1TypeForced;
+	  pSiSEnt->ForceCRT2Type = pSiS->ForceCRT2Type;
+	  pSiSEnt->ForceTVType = pSiS->ForceTVType;
+	  pSiSEnt->ForceYPbPrType = pSiS->ForceYPbPrType;
+	  pSiSEnt->ForceYPbPrAR = pSiS->ForceYPbPrAR;
+	  pSiSEnt->UsePanelScaler = pSiS->UsePanelScaler;
+	  pSiSEnt->CenterLCD = pSiS->CenterLCD;
+	  pSiSEnt->DSTN = pSiS->DSTN;
+	  pSiSEnt->FSTN = pSiS->FSTN;
+	  pSiSEnt->OptTVStand = pSiS->OptTVStand;
+	  pSiSEnt->NonDefaultPAL = pSiS->NonDefaultPAL;
+	  pSiSEnt->NonDefaultNTSC = pSiS->NonDefaultNTSC;
+	  pSiSEnt->chtvtype = pSiS->chtvtype;
+	  pSiSEnt->OptTVOver = pSiS->OptTVOver;
+	  pSiSEnt->OptTVSOver = pSiS->OptTVSOver;
+	  pSiSEnt->chtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
+	  pSiSEnt->chtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
+	  pSiSEnt->chtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
+	  pSiSEnt->chtvchromabandwidth = pSiS->chtvchromabandwidth;
+	  pSiSEnt->chtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
+	  pSiSEnt->chtvtextenhance = pSiS->chtvtextenhance;
+	  pSiSEnt->chtvcontrast = pSiS->chtvcontrast;
+	  pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
+	  pSiSEnt->sistvedgeenhance = pSiS->sistvedgeenhance;
+	  pSiSEnt->sistvantiflicker = pSiS->sistvantiflicker;
+	  pSiSEnt->sistvsaturation = pSiS->sistvsaturation;
+	  pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
+	  pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
+	  pSiSEnt->sistvcolcalibc = pSiS->sistvcolcalibc;
+	  pSiSEnt->sistvcolcalibf = pSiS->sistvcolcalibf;
+	  pSiSEnt->tvxpos = pSiS->tvxpos;
+	  pSiSEnt->tvypos = pSiS->tvypos;
+	  pSiSEnt->tvxscale = pSiS->tvxscale;
+	  pSiSEnt->tvyscale = pSiS->tvyscale;
+	  pSiSEnt->siscrt1satgain = pSiS->siscrt1satgain;
+	  pSiSEnt->crt1satgaingiven = pSiS->crt1satgaingiven;
+	  pSiSEnt->CRT1gamma = pSiS->CRT1gamma;
+	  pSiSEnt->CRT1gammaGiven = pSiS->CRT1gammaGiven;
+	  pSiSEnt->XvGammaRed = pSiS->XvGammaRed;
+	  pSiSEnt->XvGammaGreen = pSiS->XvGammaGreen;
+	  pSiSEnt->XvGammaBlue = pSiS->XvGammaBlue;
+	  pSiSEnt->XvGamma = pSiS->XvGamma;
+	  pSiSEnt->XvGammaGiven = pSiS->XvGammaGiven;
+	  pSiSEnt->CRT2gamma = pSiS->CRT2gamma;
+	  pSiSEnt->XvOnCRT2 = pSiS->XvOnCRT2;
+	  pSiSEnt->AllowHotkey = pSiS->AllowHotkey;
+	  pSiSEnt->enablesisctrl = pSiS->enablesisctrl;
+	  pSiSEnt->SenseYPbPr = pSiS->SenseYPbPr;
+	  pSiSEnt->BenchMemCpy = pSiS->BenchMemCpy;
+       } else {
+	  /* We always use same cursor type on both screens */
+	  pSiS->HWCursor = pSiSEnt->HWCursor;
+	  /* We need identical NoAccel setting */
+	  pSiS->NoAccel = pSiSEnt->NoAccel;
+	  pSiS->useEXA = pSiSEnt->useEXA;
+	  pSiS->TurboQueue = pSiSEnt->TurboQueue;
+	  pSiS->restorebyset = pSiSEnt->restorebyset;
+	  pSiS->AllowHotkey = pSiS->AllowHotkey;
+	  pSiS->OptROMUsage = pSiSEnt->OptROMUsage;
+	  pSiS->OptUseOEM = pSiSEnt->OptUseOEM;
+	  pSiS->forceCRT1 = pSiSEnt->forceCRT1;
+	  pSiS->nocrt2ddcdetection = FALSE;
+	  pSiS->forceLCDcrt1 = FALSE;
+	  pSiS->forcecrt2redetection = FALSE;
+	  pSiS->ForceCRT1Type = pSiSEnt->ForceCRT1Type;
+	  pSiS->ForceCRT2Type = pSiSEnt->ForceCRT2Type;
+	  pSiS->CRT1TypeForced = pSiSEnt->CRT1TypeForced;
+	  pSiS->UsePanelScaler = pSiSEnt->UsePanelScaler;
+	  pSiS->CenterLCD = pSiSEnt->CenterLCD;
+	  pSiS->DSTN = pSiSEnt->DSTN;
+	  pSiS->FSTN = pSiSEnt->FSTN;
+	  pSiS->OptTVStand = pSiSEnt->OptTVStand;
+	  pSiS->NonDefaultPAL = pSiSEnt->NonDefaultPAL;
+	  pSiS->NonDefaultNTSC = pSiSEnt->NonDefaultNTSC;
+	  pSiS->chtvtype = pSiSEnt->chtvtype;
+	  pSiS->ForceTVType = pSiSEnt->ForceTVType;
+	  pSiS->ForceYPbPrType = pSiSEnt->ForceYPbPrType;
+	  pSiS->ForceYPbPrAR = pSiSEnt->ForceYPbPrAR;
+	  pSiS->OptTVOver = pSiSEnt->OptTVOver;
+	  pSiS->OptTVSOver = pSiSEnt->OptTVSOver;
+	  pSiS->chtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
+	  pSiS->chtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
+	  pSiS->chtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
+	  pSiS->chtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
+	  pSiS->chtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
+	  pSiS->chtvcvbscolor = pSiSEnt->chtvcvbscolor;
+	  pSiS->chtvtextenhance = pSiSEnt->chtvtextenhance;
+	  pSiS->chtvcontrast = pSiSEnt->chtvcontrast;
+	  pSiS->sistvedgeenhance = pSiSEnt->sistvedgeenhance;
+	  pSiS->sistvantiflicker = pSiSEnt->sistvantiflicker;
+	  pSiS->sistvsaturation = pSiSEnt->sistvsaturation;
+	  pSiS->sistvcfilter = pSiSEnt->sistvcfilter;
+	  pSiS->sistvyfilter = pSiSEnt->sistvyfilter;
+	  pSiS->sistvcolcalibc = pSiSEnt->sistvcolcalibc;
+	  pSiS->sistvcolcalibf = pSiSEnt->sistvcolcalibf;
+	  pSiS->tvxpos = pSiSEnt->tvxpos;
+	  pSiS->tvypos = pSiSEnt->tvypos;
+	  pSiS->tvxscale = pSiSEnt->tvxscale;
+	  pSiS->tvyscale = pSiSEnt->tvyscale;
+	  pSiS->SenseYPbPr = pSiSEnt->SenseYPbPr;
+	  if(!pSiS->CRT1gammaGiven) {
+	     if(pSiSEnt->CRT1gammaGiven)
+	        pSiS->CRT1gamma = pSiSEnt->CRT1gamma;
+	  }
+	  pSiS->CRT2gamma = pSiSEnt->CRT2gamma;
+	  if(!pSiS->XvGammaGiven) {
+	     if(pSiSEnt->XvGammaGiven) {
+		pSiS->XvGamma = pSiSEnt->XvGamma;
+		pSiS->XvGammaRed = pSiS->XvGammaRedDef = pSiSEnt->XvGammaRed;
+		pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = pSiSEnt->XvGammaGreen;
+		pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = pSiSEnt->XvGammaBlue;
+	     }
+	  }
+	  if(!pSiS->crt1satgaingiven) {
+	     if(pSiSEnt->crt1satgaingiven)
+	        pSiS->siscrt1satgain = pSiSEnt->siscrt1satgain;
+	  }
+	  pSiS->XvOnCRT2 = pSiSEnt->XvOnCRT2;
+	  pSiS->enablesisctrl = pSiSEnt->enablesisctrl;
+	  pSiS->BenchMemCpy = pSiSEnt->BenchMemCpy;
+	  /* Copy gamma brightness to Ent (sic!) for Xinerama */
+	  pSiSEnt->GammaBriR = pSiS->GammaBriR;
+	  pSiSEnt->GammaBriG = pSiS->GammaBriG;
+	  pSiSEnt->GammaBriB = pSiS->GammaBriB;
+	  pSiSEnt->NewGammaBriR = pSiS->NewGammaBriR;
+	  pSiSEnt->NewGammaBriG = pSiS->NewGammaBriG;
+	  pSiSEnt->NewGammaBriB = pSiS->NewGammaBriB;
+	  pSiSEnt->NewGammaConR = pSiS->NewGammaConR;
+	  pSiSEnt->NewGammaConG = pSiS->NewGammaConG;
+	  pSiSEnt->NewGammaConB = pSiS->NewGammaConB;
+       }
     }
+}
+#endif
 
-    if(usedChipsSiS) xfree(usedChipsSiS);
-    if(usedChipsXGI) xfree(usedChipsXGI);
+/* Handle Chrontel GPIO */
 
-    return foundScreen;
+static void
+SiSDetermineChrontelGPIO(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    /* There are some machines out there which require a special
+     * setup of the GPIO registers in order to make the Chrontel
+     * work. Try to find out if we're running on such a machine.
+     */
+
+    pSiS->SiS_Pr->SiS_ChSW = FALSE;
+    if(pSiS->Chipset == PCI_CHIP_SIS630) {
+       int i = 0;
+       do {
+	  if(mychswtable[i].subsysVendor == PCI_SUB_VENDOR_ID( pSiS->PciInfo) &&
+	     mychswtable[i].subsysCard == PCI_SUB_DEVICE_ID(pSiS->PciInfo)) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	         "PCI subsystem ID found in list for Chrontel/GPIO setup:\n");
+	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		 "\tVendor/Card: %s %s (ID %04x)\n",
+		  mychswtable[i].vendorName,
+		  mychswtable[i].cardName,
+		  PCI_SUB_DEVICE_ID(pSiS->PciInfo));
+	     pSiS->SiS_Pr->SiS_ChSW = TRUE;
+	     break;
+          }
+          i++;
+       } while(mychswtable[i].subsysVendor != 0);
+    }
 }
 
-/* Various helpers */
+/* Handle custom timing */
 
-static unsigned short
-calcgammaval(int j, int nramp, float invgamma, float bri, float c)
+static void
+SiSDetermineCustomTiming(ScrnInfoPtr pScrn)
 {
-    float k = (float)j;
-    float nrm1 = (float)(nramp - 1);
-    float con = c * nrm1 / 3.0;
-    float l, v;
+    SISPtr pSiS = SISPTR(pScrn);
+    int    i = 0, j;
+    UShort bversptr = 0;
+    Bool   footprint;
+    CARD32 chksum = 0;
 
-    if(con != 0.0) {
-       l = nrm1 / 2.0;
-       if(con <= 0.0) {
-          k -= l;
-          k *= (l + con) / l;
-       } else {
-          l -= 1.0;
-          k -= l;
-          k *= l / (l - con);
+    if(pSiS->SiS_Pr->SiS_CustomT == CUT_NONE) {
+
+       if(pSiS->SiS_Pr->UseROM) {
+          bversptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
+          for(i = 0; i < 32768; i++) chksum += pSiS->BIOS[i];
        }
-       k += l;
-       if(k < 0.0) k = 0.0;
+
+       i = 0;
+       do {
+	  if( (SiS_customttable[i].chipID == pSiS->ChipType)                            &&
+	      ((!strlen(SiS_customttable[i].biosversion)) ||
+	       (pSiS->SiS_Pr->UseROM &&
+	       (!strncmp(SiS_customttable[i].biosversion, (char *)&pSiS->BIOS[bversptr],
+	                strlen(SiS_customttable[i].biosversion)))))                     &&
+	      ((!strlen(SiS_customttable[i].biosdate)) ||
+	       (pSiS->SiS_Pr->UseROM &&
+	       (!strncmp(SiS_customttable[i].biosdate, (char *)&pSiS->BIOS[0x2c],
+	                strlen(SiS_customttable[i].biosdate)))))			&&
+	      ((!SiS_customttable[i].bioschksum) ||
+	       (pSiS->SiS_Pr->UseROM &&
+	       (SiS_customttable[i].bioschksum == chksum)))				&&
+	      (SiS_customttable[i].pcisubsysvendor == PCI_SUB_VENDOR_ID( pSiS->PciInfo ))	&&
+	      (SiS_customttable[i].pcisubsyscard == PCI_SUB_DEVICE_ID( pSiS->PciInfo )) ) {
+	     footprint = TRUE;
+	     for(j = 0; j < 5; j++) {
+	        if(SiS_customttable[i].biosFootprintAddr[j]) {
+		   if(pSiS->SiS_Pr->UseROM) {
+		      if(pSiS->BIOS[SiS_customttable[i].biosFootprintAddr[j]] !=
+						SiS_customttable[i].biosFootprintData[j])
+		         footprint = FALSE;
+		   } else footprint = FALSE;
+	        }
+	     }
+	     if(footprint) {
+	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	           "Identified %s %s, special timing applies\n",
+		   SiS_customttable[i].vendorName, SiS_customttable[i].cardName);
+	        pSiS->SiS_Pr->SiS_CustomT = SiS_customttable[i].SpecialID;
+	        break;
+	     }
+          }
+          i++;
+       } while(SiS_customttable[i].chipID);
     }
 
-    if(invgamma == 1.0) {
-       v = k / nrm1 * 65535.0;
-    } else {
-       v = pow(k / nrm1, invgamma) * 65535.0 + 0.5;
+    if((pSiS->SiS_Pr->SiS_CustomT == CUT_ICOP550) ||
+       (pSiS->SiS_Pr->SiS_CustomT == CUT_ICOP550_2)) {
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		"This driver version doesn't entirely support this customized\n");
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		"hardware. A special version is available from the author.\n");
+       pSiS->SiS_Pr->SiS_CustomT = CUT_NONE;
     }
 
-    v += (bri * (65535.0 / 3.0)) ;
+}
 
-    if(v < 0.0) v = 0.0;
-    else if(v > 65535.0) v = 65535.0;
+/* Handle PDC and EMI */
 
-    return (unsigned short)v;
+static void
+SiSHandlePDCEMI(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    const char *unable = "Unable to detect LCD PanelDelayCompensation, %s\n";
+    const char *oldsisfb = "please update sisfb";
+    const char *nolcd = "LCD is not active";
+    const char *usingpdc = "Using LCD PanelDelayCompensation 0x%02x%s\n";
+    const char *detected = "Detected LCD PanelDelayCompensation 0x%02x%s\n";
+    const char *forcrt1 = " (for LCD=CRT1)";
+    const char *forcrt2 = " (for LCD=CRT2)";
+    const char *biosuses = "BIOS uses OEM LCD Panel Delay Compensation 0x%02x\n";
+
+#ifdef SISDUALHEAD
+    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
+#endif
+       if(pSiS->VGAEngine == SIS_300_VGA) {
+
+          if(pSiS->VBFlags2 & (VB2_LVDS | VB2_30xBDH)) {
+
+	     /* Save the current PDC if the panel is used at the moment.
+	      * This seems by far the safest way to find out about it.
+	      * If the system is using an old version of sisfb, we can't
+	      * trust the pdc register value. If sisfb saved the pdc for
+	      * us, use it.
+	      */
+	     if(pSiS->sisfbpdc != 0xff) {
+	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
+	     } else {
+	        if(!(pSiS->donttrustpdc)) {
+	           UChar tmp;
+	           inSISIDXREG(SISCR, 0x30, tmp);
+	           if(tmp & 0x20) {
+	              inSISIDXREG(SISPART1, 0x13, pSiS->SiS_Pr->PDC);
+                   } else {
+	             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		          unable, nolcd);
+	           }
+	        } else {
+	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		        unable, oldsisfb);
+	        }
+	     }
+	     if(pSiS->SiS_Pr->PDC != -1) {
+	        pSiS->SiS_Pr->PDC &= 0x3c;
+	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		     detected, pSiS->SiS_Pr->PDC, "");
+	     }
+
+	     /* If we haven't been able to find out, use our other methods */
+	     if(pSiS->SiS_Pr->PDC == -1) {
+		int i=0;
+		do {
+		   if(mypdctable[i].subsysVendor == PCI_SUB_VENDOR_ID(pSiS->PciInfo) &&
+		      mypdctable[i].subsysCard == PCI_SUB_DEVICE_ID( pSiS->PciInfo )) {
+			 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			    "PCI card/vendor identified for non-default PanelDelayCompensation\n");
+			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			     "Vendor: %s, card: %s (ID %04x), PanelDelayCompensation: 0x%02x\n",
+			     mypdctable[i].vendorName, mypdctable[i].cardName,
+			     PCI_SUB_DEVICE_ID( pSiS->PciInfo ), mypdctable[i].pdc);
+			 if(pSiS->PDC == -1) {
+			    pSiS->PDC = mypdctable[i].pdc;
+			 } else {
+			    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+				"PanelDelayCompensation overruled by option\n");
+			 }
+			 break;
+		   }
+		   i++;
+		} while(mypdctable[i].subsysVendor != 0);
+	     }
+
+	     if(pSiS->PDC != -1) {
+		if(pSiS->BIOS) {
+		   if(pSiS->VBFlags2 & VB2_LVDS) {
+		      if(pSiS->BIOS[0x220] & 0x80) {
+			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			     biosuses, pSiS->BIOS[0x220] & 0x3c);
+			 pSiS->BIOS[0x220] &= 0x7f;
+		      }
+		   }
+		   if(pSiS->VBFlags2 & (VB2_301B | VB2_302B)) {
+		      if(pSiS->BIOS[0x220] & 0x80) {
+			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			     biosuses,
+			       (  (pSiS->VBLCDFlags & VB_LCD_1280x1024) ?
+			                 pSiS->BIOS[0x223] : pSiS->BIOS[0x224]  ) & 0x3c);
+			 pSiS->BIOS[0x220] &= 0x7f;
+		      }
+		   }
+		}
+		pSiS->SiS_Pr->PDC = (pSiS->PDC & 0x3c);
+		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+		      usingpdc, pSiS->SiS_Pr->PDC, "");
+	     }
+	  }
+
+       }  /* SIS_300_VGA */
+
+       if(pSiS->VGAEngine == SIS_315_VGA) {
+
+	  UChar tmp, tmp2;
+	  inSISIDXREG(SISCR, 0x30, tmp);
+
+	  /* Save the current PDC if the panel is used at the moment. */
+	  if(pSiS->VBFlags2 & VB2_SISLVDSBRIDGE) {
+
+	     if(pSiS->sisfbpdc != 0xff) {
+	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
+	     }
+	     if(pSiS->sisfbpdca != 0xff) {
+	        pSiS->SiS_Pr->PDCA = pSiS->sisfbpdca;
+	     }
+
+	     if(!pSiS->donttrustpdc) {
+	        if((pSiS->sisfbpdc == 0xff) && (pSiS->sisfbpdca == 0xff)) {
+		   CARD16 tempa, tempb;
+		   inSISIDXREG(SISPART1,0x2d,tmp2);
+		   tempa = (tmp2 & 0xf0) >> 3;
+		   tempb = (tmp2 & 0x0f) << 1;
+		   inSISIDXREG(SISPART1,0x20,tmp2);
+		   tempa |= ((tmp2 & 0x40) >> 6);
+		   inSISIDXREG(SISPART1,0x35,tmp2);
+		   tempb |= ((tmp2 & 0x80) >> 7);
+		   inSISIDXREG(SISPART1,0x13,tmp2);
+		   if(!pSiS->ROM661New) {
+		      if((tmp2 & 0x04) || (tmp & 0x20)) {
+		         pSiS->SiS_Pr->PDCA = tempa;
+		         pSiS->SiS_Pr->PDC  = tempb;
+		      } else {
+			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			     unable, nolcd);
+		      }
+		   } else {
+		      if(tmp2 & 0x04) {
+		         pSiS->SiS_Pr->PDCA = tempa;
+		      } else if(tmp & 0x20) {
+		         pSiS->SiS_Pr->PDC  = tempb;
+		      } else {
+			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			     unable, nolcd);
+		      }
+		   }
+		}
+	     } else {
+		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		    unable, oldsisfb);
+	     }
+	     if(pSiS->SiS_Pr->PDC != -1) {
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		     detected, pSiS->SiS_Pr->PDC, forcrt2);
+	     }
+	     if(pSiS->SiS_Pr->PDCA != -1) {
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		     detected, pSiS->SiS_Pr->PDCA, forcrt1);
+	     }
+	  }
+
+	  /* Let user override (for all bridges) */
+	  if(pSiS->VBFlags2 & VB2_30xBLV) {
+	     if(pSiS->PDC != -1) {
+	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0x1f;
+		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+		     usingpdc, pSiS->SiS_Pr->PDC, forcrt2);
+	     }
+	     if(pSiS->PDCA != -1) {
+		pSiS->SiS_Pr->PDCA = pSiS->PDCA & 0x1f;
+		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+		     usingpdc, pSiS->SiS_Pr->PDCA, forcrt1);
+	     }
+          }
+
+ 	  /* Read the current EMI (if not overruled) */
+	  if(pSiS->VBFlags2 & VB2_SISEMIBRIDGE) {
+	     MessageType from = X_PROBED;
+	     if(pSiS->EMI != -1) {
+		pSiS->SiS_Pr->EMI_30 = (pSiS->EMI >> 24) & 0x60;
+		pSiS->SiS_Pr->EMI_31 = (pSiS->EMI >> 16) & 0xff;
+		pSiS->SiS_Pr->EMI_32 = (pSiS->EMI >> 8)  & 0xff;
+		pSiS->SiS_Pr->EMI_33 = pSiS->EMI & 0xff;
+		pSiS->SiS_Pr->HaveEMI = pSiS->SiS_Pr->HaveEMILCD = TRUE;
+		pSiS->SiS_Pr->OverruleEMI = TRUE;
+		from = X_CONFIG;
+	     } else if((pSiS->sisfbfound) && (pSiS->sisfb_haveemi)) {
+		pSiS->SiS_Pr->EMI_30 = pSiS->sisfb_emi30;
+		pSiS->SiS_Pr->EMI_31 = pSiS->sisfb_emi31;
+		pSiS->SiS_Pr->EMI_32 = pSiS->sisfb_emi32;
+		pSiS->SiS_Pr->EMI_33 = pSiS->sisfb_emi33;
+		pSiS->SiS_Pr->HaveEMI = TRUE;
+		if(pSiS->sisfb_haveemilcd) pSiS->SiS_Pr->HaveEMILCD = TRUE;
+		pSiS->SiS_Pr->OverruleEMI = FALSE;
+	     } else {
+		inSISIDXREG(SISPART4, 0x30, pSiS->SiS_Pr->EMI_30);
+		inSISIDXREG(SISPART4, 0x31, pSiS->SiS_Pr->EMI_31);
+		inSISIDXREG(SISPART4, 0x32, pSiS->SiS_Pr->EMI_32);
+		inSISIDXREG(SISPART4, 0x33, pSiS->SiS_Pr->EMI_33);
+		pSiS->SiS_Pr->HaveEMI = TRUE;
+		if(tmp & 0x20) pSiS->SiS_Pr->HaveEMILCD = TRUE;
+		pSiS->SiS_Pr->OverruleEMI = FALSE;
+	     }
+	     xf86DrvMsg(pScrn->scrnIndex, from,
+		   "302LV/302ELV: Using EMI 0x%02x%02x%02x%02x%s\n",
+		   pSiS->SiS_Pr->EMI_30,pSiS->SiS_Pr->EMI_31,
+		   pSiS->SiS_Pr->EMI_32,pSiS->SiS_Pr->EMI_33,
+		   pSiS->SiS_Pr->HaveEMILCD ? " (LCD)" : "");
+	  }
+
+       } /* SIS_315_VGA */
+#ifdef SISDUALHEAD
+    }
+#endif
+}
+
+/* DDC helpers */
+
+/* We keep EDIDs for CRT1 and CRT2 (each analog and digital)
+ * in memory for our dynamic modelist feature. The following
+ * two routines are used to either set a new EDID, or free
+ * one. The Free-routine also checks that none of our official
+ * monitor->DDC pointer point to the to-be-freed EDID block.
+ */
+
+xf86MonPtr
+SiSSetEDIDPtr(xf86MonPtr *ptr, xf86MonPtr pMonitor)
+{
+   if((*ptr)) {
+      memcpy((*ptr), pMonitor, sizeof(xf86Monitor));
+      xfree(pMonitor);
+   } else {
+      (*ptr) = pMonitor;
+   }
+
+   return (*ptr);
 }
 
-#ifdef SISGAMMARAMP
 void
-SISCalculateGammaRamp(ScreenPtr pScreen, ScrnInfoPtr pScrn)
+SiSFreeEDID(ScrnInfoPtr pScrn, xf86MonPtr *ptr)
 {
    SISPtr pSiS = SISPTR(pScrn);
-   int    i, j, nramp;
-   UShort *ramp[3];
-   float  gamma_max[3], framp;
-   Bool   newmethod = FALSE;
 
-   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_OLDGAMMAINUSE)) {
-      newmethod = TRUE;
-   } else {
-      gamma_max[0] = (float)pSiS->GammaBriR / 1000;
-      gamma_max[1] = (float)pSiS->GammaBriG / 1000;
-      gamma_max[2] = (float)pSiS->GammaBriB / 1000;
+   if((*ptr)) {
+
+      if(pScrn->monitor) {
+         if(pScrn->monitor->DDC == (*ptr)) {
+            pScrn->monitor->DDC = NULL;
+         }
+      }
+
+#ifdef SISMERGED
+      if(pSiS->MergedFB) {
+         if(pSiS->CRT2pScrn && pSiS->CRT2pScrn->monitor) {
+            if(pSiS->CRT2pScrn->monitor->DDC == (*ptr)) {
+               pSiS->CRT2pScrn->monitor->DDC = NULL;
+            }
+         }
+      }
+#endif
+
+      xfree((*ptr));
+      *ptr = NULL;
+
    }
+}
 
-   if(!(nramp = xf86GetGammaRampSize(pScreen))) return;
+xf86MonPtr
+SiSInternalDDC(ScrnInfoPtr pScrn, int crtno)
+{
+   SISPtr     pSiS = SISPTR(pScrn);
+   xf86MonPtr pMonitor = NULL;
+   UShort     temp = 0xffff, temp1, i, realcrtno = crtno;
+   UChar      buffer[256];
 
-   for(i=0; i<3; i++) {
-      ramp[i] = (UShort *)xalloc(nramp * sizeof(UShort));
-      if(!ramp[i]) {
-	 if(ramp[0]) { xfree(ramp[0]); ramp[0] = NULL; }
-	 if(ramp[1]) { xfree(ramp[1]); ramp[1] = NULL; }
-	 return;
+   /* If CRT1 is off, skip DDC */
+   if((pSiS->CRT1off) && (!crtno))
+      return NULL;
+
+   if(crtno) {
+      if(pSiS->VBFlags & CRT2_LCD)      
+      {
+      	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 1 CRT2 realcrtno 1");
+      	realcrtno = 1;
+      }
+      else if(pSiS->VBFlags & CRT2_VGA)
+      {
+       	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 1 CRT2 realcrtno 2");
+     		realcrtno = 2;
+      }
+      else
+      {
+       	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 1 CRT2 NULL");
+     		return NULL;
+      }
+      
+      if(pSiS->SiS_Pr->DDCPortMixup)
+      {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 1 DDCPortMixup");
+   	    realcrtno = 0;
+      }
+      
+   } else {
+      if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
+         /* If CRT1 is LCDA, skip DDC (except 301C: DDC allowed, but uses CRT2 port!) */
+         if(pSiS->VBFlags & CRT1_LCDA) {
+            if(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)
+            {
+			        	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 0 SD3 CRT1 SISTMDSLCD");
+              	 realcrtno = 1;
+            }
+            else
+            {
+		        	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 0 SD3 CRT1");
+            	 return NULL;
+            	}
+          }
+      } else {
+       	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "crtno 0");
+         realcrtno = 0;
       }
    }
 
-   if(newmethod) {
+   i = 3; /* Number of retrys */
+   do {
+      temp1 = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine,
+			realcrtno, 0, &buffer[0], pSiS->VBFlags2);
+      if((temp1) && (temp1 != 0xffff)) temp = temp1;
+   } while((temp == 0xffff) && i--);
 
-      for(i = 0; i < 3; i++) {
+   if(temp != 0xffff) {
 
-         float invgamma = 0.0, bri = 0.0, con = 0.0;
+      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "EL CRT%d DDC supported\n", crtno + 1);
 
-         switch(i) {
-         case 0: invgamma = 1. / pScrn->gamma.red;
-		 bri = pSiS->NewGammaBriR;
-		 con = pSiS->NewGammaConR;
-		 break;
-         case 1: invgamma = 1. / pScrn->gamma.green;
-		 bri = pSiS->NewGammaBriG;
-		 con = pSiS->NewGammaConG;
-		 break;
-         case 2: invgamma = 1. / pScrn->gamma.blue;
-		 bri = pSiS->NewGammaBriB;
-                 con = pSiS->NewGammaConB;
-		 break;
-         }
+      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "EL CRT%d DDC level: %s%s%s%s\n",
+	     crtno + 1,
+	     (temp & 0x1a) ? "" : "[none of the supported]",
+	     (temp & 0x02) ? "2 " : "",
+	     (temp & 0x08) ? "D&P" : "",
+             (temp & 0x10) ? "FPDI-2" : "");
 
-	 for(j = 0; j < nramp; j++) {
-	    ramp[i][j] = calcgammaval(j, nramp, invgamma, bri, con);
-	 }
+      if(temp & 0x02) {
 
-      }
+	 i = 5;  /* Number of retrys */
+	 do {
+	    temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine,
+				realcrtno, 1, &buffer[0], pSiS->VBFlags2);
+	 } while((temp) && i--);
 
-   } else {
+         if(!temp) {
 
-      for(i = 0; i < 3; i++) {
-         int fullscale = 65535 * gamma_max[i];
-         float dramp = 1. / (nramp - 1);
-         float invgamma = 0.0, v;
+	    if((pMonitor = xf86InterpretEDID(pScrn->scrnIndex, &buffer[0]))) {
 
-         switch(i) {
-         case 0: invgamma = 1. / pScrn->gamma.red; break;
-         case 1: invgamma = 1. / pScrn->gamma.green; break;
-         case 2: invgamma = 1. / pScrn->gamma.blue; break;
-         }
+	       int tempvgagamma = 0, templcdgamma = 0;
+		/* X will access rawData, so we should set it null */
+	       /*pMonitor->rawData = NULL; *//* Toss pointer to raw data */
 
-         for(j = 0; j < nramp; j++) {
-	    framp = pow(j * dramp, invgamma);
+	       if(buffer[0x14] & 0x80) {
+	          if((crtno == 0) && (pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
+	             pMonitor = SiSSetEDIDPtr(&pSiS->currcrt1digitaledid, pMonitor);
+	          } else {
+	             pMonitor = SiSSetEDIDPtr(&pSiS->currcrt2digitaledid, pMonitor);
+	          }
+	       } else {
+	          if(crtno == 0) {
+	             pMonitor = SiSSetEDIDPtr(&pSiS->currcrt1analogedid, pMonitor);
+	          } else {
+	             pMonitor = SiSSetEDIDPtr(&pSiS->currcrt2analogedid, pMonitor);
+	          }
+	       }
+
+	       if(buffer[0x14] & 0x80) {
+	          templcdgamma = (buffer[0x17] + 100) * 10;
+	       } else {
+	          tempvgagamma = (buffer[0x17] + 100) * 10;
+	       }
+	       if(crtno == 0) {
+	          pSiS->CRT1LCDMonitorGamma = 0;
+		  if(tempvgagamma) pSiS->CRT1VGAMonitorGamma = tempvgagamma;
+		  if(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI) {
+		     if(templcdgamma) pSiS->CRT1LCDMonitorGamma = templcdgamma;
+		  }
+	       } else {
+	          if(tempvgagamma) pSiS->CRT2VGAMonitorGamma = tempvgagamma;
+	          if(templcdgamma) pSiS->CRT2LCDMonitorGamma = templcdgamma;
+	       }
+
+	       return pMonitor;
+
+	    } else {
+
+	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+	           "CRT%d DDC EDID corrupt\n", crtno + 1);
+
+	    }
+
+	 } else if(temp == 0xFFFE) {
+
+	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		"CRT%d DDC data is from wrong device type (%s)\n",
+			crtno + 1,
+			(realcrtno == 1) ? "analog instead of digital" :
+					   "digital instead of analog");
+
+	 } else {
+
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		"CRT%d DDC reading failed\n", crtno + 1);
+
+	 }
+
+      } else if(temp & 0x18) {
+
+         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	      "DDC for VESA D&P and FPDI-2 not supported yet.\n");
 
-	    v = (fullscale < 0) ? (65535 + fullscale * framp) :
-			       fullscale * framp;
-	    if(v < 0) v = 0;
-	    else if(v > 65535) v = 65535;
-	    ramp[i][j] = (UShort)v;
-         }
       }
 
-   }
+   } else {
 
-   xf86ChangeGammaRamp(pScreen, nramp, ramp[0], ramp[1], ramp[2]);
+      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                "CRT%d DDC probing failed\n", crtno + 1);
 
-   xfree(ramp[0]);
-   xfree(ramp[1]);
-   xfree(ramp[2]);
-   ramp[0] = ramp[1] = ramp[2] = NULL;
+   }
+
+   return NULL;
 }
+
+static xf86MonPtr
+SiSDoPrivateDDC(ScrnInfoPtr pScrn, int *crtnum)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+#ifdef SISDUALHEAD
+    if(pSiS->DualHeadMode) {
+       if(pSiS->SecondHead) {
+          *crtnum = 1;
+	  return SiSInternalDDC(pScrn, 0);
+       } else {
+          *crtnum = 2;
+	  return SiSInternalDDC(pScrn, 1);
+       }
+    } else
 #endif
+    if( (pSiS->CRT1off)			||
+        ( (!pSiS->CRT1Detected) &&
+          (!((pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE) && (pSiS->VBFlags & CRT1_LCDA))) ) ) {
+       *crtnum = 2;
+       return SiSInternalDDC(pScrn, 1);
+    } else {
+       *crtnum = 1;
+       return SiSInternalDDC(pScrn, 0);
+    }
+}
 
 void
-SISCalculateGammaRampCRT2(ScrnInfoPtr pScrn)
+SiSFindAspect(ScrnInfoPtr pScrn, xf86MonPtr pMonitor, int crtnum, Bool quiet)
 {
-   SISPtr pSiS = SISPTR(pScrn);
-   int    i;
-   int    myshift = 16 - pScrn->rgbBits;
-   int    maxvalue = (1 << pScrn->rgbBits) - 1;
-   int    reds = pScrn->mask.red >> pScrn->offset.red;
-   int    greens = pScrn->mask.green >> pScrn->offset.green;
-   int    blues = pScrn->mask.blue >> pScrn->offset.blue;
-   float  framp, invgamma1, invgamma2, invgamma3, v;
+    SISPtr pSiS = SISPTR(pScrn);
+    int UseWide = 0;
+    int aspect = 0;
+    Bool fromdim = FALSE;
 
-   invgamma1  = 1. / pSiS->GammaR2;
-   invgamma2  = 1. / pSiS->GammaG2;
-   invgamma3  = 1. / pSiS->GammaB2;
+    if(pMonitor &&
+       (pSiS->VGAEngine == SIS_315_VGA) &&
+       (!DIGITAL(pMonitor->features.input_type))) {
 
-   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_OLDGAMMAINUSE)) {
+       if(pMonitor->features.hsize && pMonitor->features.vsize) {
+	  aspect = (pMonitor->features.hsize * 1000) / pMonitor->features.vsize;
+	  if(aspect >= 1400) UseWide = 1;
+	  fromdim = TRUE;
+       } else if((PREFERRED_TIMING_MODE(pMonitor->features.msc)) &&
+		 (pMonitor->det_mon[0].type == DT)) {
+	  aspect = (pMonitor->det_mon[0].section.d_timings.h_active * 1000) /
+			pMonitor->det_mon[0].section.d_timings.v_active;
+	  if(aspect >= 1400) UseWide = 1;
+       }
 
-      for(i = 0; i < pSiS->CRT2ColNum; i++) {
-         pSiS->crt2gcolortable[i].red = calcgammaval(i, pSiS->CRT2ColNum, invgamma1,
-			pSiS->NewGammaBriR2, pSiS->NewGammaConR2) >> myshift;
-         pSiS->crt2gcolortable[i].green = calcgammaval(i, pSiS->CRT2ColNum, invgamma2,
-			pSiS->NewGammaBriG2, pSiS->NewGammaConG2) >> myshift;
-         pSiS->crt2gcolortable[i].blue = calcgammaval(i, pSiS->CRT2ColNum, invgamma3,
-			pSiS->NewGammaBriB2, pSiS->NewGammaConB2) >> myshift;
-      }
+       if(!quiet) {
+	  if(aspect) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		"According to %s, CRT%d aspect ratio is %.2f:1 (%s)\n",
+		fromdim ? "DDC size" : "preferred mode",
+		crtnum, (float)aspect / 1000.0, UseWide ? "wide" : "normal");
+	  } else {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		"Unable to determine CRT%d aspect ratio, assuming \"normal\"\n",
+		crtnum);
+	  }
+       }
 
-   } else {
+    }
 
-      int fullscale1 = 65536 * (float)pSiS->GammaBriR2 / 1000;
-      int fullscale2 = 65536 * (float)pSiS->GammaBriG2 / 1000;
-      int fullscale3 = 65536 * (float)pSiS->GammaBriB2 / 1000;
+    /* Only overwrite if we haven't been overruled by options */
+    if((crtnum == 1) && (!pSiS->havewide1)) {
+       pSiS->SiS_Pr->SiS_UseWide = UseWide;
+    } else if((crtnum == 2) && (!pSiS->havewide2)) {
+       pSiS->SiS_Pr->SiS_UseWideCRT2 = UseWide;
+    }
+}
 
-      float dramp = 1. / (pSiS->CRT2ColNum - 1);
+static void
+SiSGetDDCAndEDID(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    Bool didddc2 = FALSE;
+    xf86MonPtr pMonitor = NULL;
+    static const char *ddcsstr = "CRT%d DDC monitor info: *******************************************\n";
+    static const char *ddcestr = "End of CRT%d DDC monitor info *************************************\n";
 
-      for(i = 0; i < pSiS->CRT2ColNum; i++) {
-         framp = pow(i * dramp, invgamma1);
-         v = (fullscale1 < 0) ? (65535 + fullscale1 * framp) : fullscale1 * framp;
-         if(v < 0) v = 0;
-         else if(v > 65535) v = 65535;
-         pSiS->crt2gcolortable[i].red = ((UShort)v) >> myshift;
-         framp = pow(i * dramp, invgamma2);
-         v = (fullscale2 < 0) ? (65535 + fullscale2 * framp) : fullscale2 * framp;
-         if(v < 0) v = 0;
-         else if(v > 65535) v = 65535;
-         pSiS->crt2gcolortable[i].green = ((UShort)v) >> myshift;
-         framp = pow(i * dramp, invgamma3);
-         v = (fullscale3 < 0) ? (65535 + fullscale3 * framp) : fullscale3 * framp;
-         if(v < 0) v = 0;
-         else if(v > 65535) v = 65535;
-         pSiS->crt2gcolortable[i].blue = ((UShort)v) >> myshift;
-      }
+    /* For 300 series and later, we provide our own
+     * routines (in order to probe CRT2 as well).
+     * If these fail, use the VBE.
+     * All other chipsets will use VBE. No need to re-invent
+     * the wheel there.
+     */
 
-   }
+    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
 
-   for(i = 0; i < pSiS->CRT2ColNum; i++) {
-      pSiS->crt2colors[i].red =
-         pSiS->crt2gcolortable[i * maxvalue / reds].red;
-      pSiS->crt2colors[i].green =
-         pSiS->crt2gcolortable[i * maxvalue / greens].green;
-      pSiS->crt2colors[i].blue  =
-         pSiS->crt2gcolortable[i * maxvalue / blues].blue;
-   }
+       if(SiSLoadInitDDCModule(pScrn)) {
+
+	  int crtnum = 0;
+	  if((pMonitor = SiSDoPrivateDDC(pScrn, &crtnum))) {
+	     didddc2 = TRUE;
+	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, crtnum);
+	     xf86PrintEDID(pMonitor);
+	     pScrn->monitor->DDC = pMonitor;
+	     /* Now try to find out aspect ratio */
+	     SiSFindAspect(pScrn, pMonitor, crtnum, FALSE);
+	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, crtnum);
+	  }
+
+       }
+
+    }
+
+#ifdef SISDUALHEAD
+    /* In dual head mode, probe DDC using VBE only for CRT1 (second head) */
+    if((pSiS->DualHeadMode) && (!didddc2) && (!pSiS->SecondHead)) {
+       didddc2 = TRUE;
+    }
+#endif
+
+    if(!didddc2) {
+       /* If CRT1 is off or LCDA, skip DDC via VBE */
+       if((pSiS->CRT1off) || (pSiS->VBFlags & CRT1_LCDA)) {
+          didddc2 = TRUE;
+       }
+    }
+
+    /* Now try via VBE */
+    if(!didddc2) {
+
+       if(SiSLoadInitDDCModule(pScrn)) {
+
+	  SiS_LoadInitVBE(pScrn);
+
+	  if(pSiS->pVbe) {
+	     if((pMonitor = vbeDoEDID(pSiS->pVbe, NULL))) {
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		      "VBE CRT1 DDC monitor info:\n");
+		xf86PrintEDID(pMonitor);
+		if(pMonitor->rawData) {
+		   /* Get rid of raw data */
+		   xfree(pMonitor->rawData);
+		   pMonitor->rawData = NULL;
+		}
+		pScrn->monitor->DDC = pMonitor = SiSSetEDIDPtr(&pSiS->currcrt1analogedid, pMonitor);
+		/* Try to find out aspect ratio */
+		SiSFindAspect(pScrn, pMonitor, 1, FALSE);
+		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		      "End of VBE CRT1 DDC monitor info\n");
+	     }
+	  } else {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		 "Failed to read DDC data\n");
+	  }
+
+       }
+
+    }
 }
 
+/* Deal with HorizSync/VertRefresh */
+
 /* If monitor section has no HSync/VRefresh data,
  * derive it from DDC data.
  */
@@ -1022,13 +2338,13 @@ SiSSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
 
       for(i = 0; i < 11; i++) {
 	 if(myvtiming[i].whichone == 1) temp = ddc->timings1.t1;
-	 else                           temp = ddc->timings1.t2;
+	 else				temp = ddc->timings1.t2;
 	 if(temp & myvtiming[i].mask) {
 	    if((i == 0) || (myvlow > myvtiming[i].rate))
 	       myvlow = myvtiming[i].rate;
 	 }
 	 if(myvtiming[10-i].whichone == 1) temp = ddc->timings1.t1;
-	 else                              temp = ddc->timings1.t2;
+	 else				   temp = ddc->timings1.t2;
 	 if(temp & myvtiming[10-i].mask) {
 	    if((i == 0) || (myvhigh < myvtiming[10-i].rate))
 	       myvhigh = myvtiming[10-i].rate;
@@ -1053,7 +2369,7 @@ SiSSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
 }
 
 static Bool
-SiSAllowSyncOverride(SISPtr pSiS, Bool fromDDC)
+SiSAllowSyncOverride(SISPtr pSiS, Bool fromDDC, int mfbcrt)
 {
    if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE)) return FALSE;
 
@@ -1071,7 +2387,12 @@ SiSAllowSyncOverride(SISPtr pSiS, Bool fromDDC)
 
 #ifdef SISMERGED
    if(pSiS->MergedFB) {
-      if((pSiS->VBFlags & CRT1_LCDA) && (!fromDDC)) return TRUE;
+      if(mfbcrt == 1) {
+         if((pSiS->VBFlags & CRT1_LCDA) && (!fromDDC)) return TRUE;
+      } else {
+         if((pSiS->VBFlags & CRT2_TV) ||
+	    ((pSiS->VBFlags & CRT2_LCD) && (!fromDDC))) return TRUE;
+      }
       return FALSE;
    }
 #endif
@@ -1111,7 +2432,7 @@ SiSCheckForV(float vrefresh, MonPtr monitor)
 }
 
 static Bool
-CheckAndOverruleH(ScrnInfoPtr pScrn, MonPtr monitor)
+SiSCheckAndOverruleH(ScrnInfoPtr pScrn, MonPtr monitor)
 {
    DisplayModePtr mode = monitor->Modes;
    float mymin = 30.0, mymax = 80.0, hsync;
@@ -1145,7 +2466,7 @@ CheckAndOverruleH(ScrnInfoPtr pScrn, MonPtr monitor)
 }
 
 static Bool
-CheckAndOverruleV(ScrnInfoPtr pScrn, MonPtr monitor)
+SiSCheckAndOverruleV(ScrnInfoPtr pScrn, MonPtr monitor)
 {
    DisplayModePtr mode = monitor->Modes;
    float mymin = 59.0, mymax = 61.0, vrefresh;
@@ -1188,1663 +2509,557 @@ CheckAndOverruleV(ScrnInfoPtr pScrn, MonPtr monitor)
    return ret;
 }
 
-/* Some helper functions for MergedFB mode */
+Bool
+SiSFixupHVRanges(ScrnInfoPtr pScrn, int mfbcrt, Bool quiet)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    Bool fromDDC, freqoverruled;
+    static const char *subshstr = "Substituting missing CRT%d monitor HSync range by DDC data\n";
+    static const char *subsvstr = "Substituting missing CRT%d monitor VRefresh range by DDC data\n";
+    static const char *saneh = "Correcting %s CRT%d monitor HSync range\n";
+    static const char *sanev = "Correcting %s CRT%d monitor VRefresh range\n";
+    int crtnum;
 
+#ifdef SISDUALHEAD
+    if(pSiS->DualHeadMode) {
+       crtnum = pSiS->SecondHead ? 1 : 2;
+    } else
+#endif
 #ifdef SISMERGED
+           if(pSiS->MergedFB) {
+       crtnum = mfbcrt;
+    } else
+#endif
+       crtnum = pSiS->CRT1off ? 2 : 1;
 
-/* Helper function for CRT2 monitor vrefresh/hsync options
- * (Code base from mga driver)
- */
-static int
-SiSStrToRanges(range *r, char *s, int max)
-{
-   float num = 0.0;
-   int rangenum = 0;
-   Bool gotdash = FALSE;
-   Bool nextdash = FALSE;
-   char *strnum = NULL;
-   do {
-      switch(*s) {
-      case '0':
-      case '1':
-      case '2':
-      case '3':
-      case '4':
-      case '5':
-      case '6':
-      case '7':
-      case '8':
-      case '9':
-      case '.':
-         if(strnum == NULL) {
-            strnum = s;
-            gotdash = nextdash;
-            nextdash = FALSE;
-         }
-         break;
-      case '-':
-      case ' ':
-      case 0:
-         if(strnum == NULL) break;
-         sscanf(strnum, "%f", &num);
-	 strnum = NULL;
-         if(gotdash) {
-            r[rangenum - 1].hi = num;
-         } else {
-            r[rangenum].lo = num;
-            r[rangenum].hi = num;
-            rangenum++;
-         }
-         if(*s == '-') nextdash = (rangenum != 0);
-	 else if(rangenum >= max) return rangenum;
-         break;
-      default:
-         return 0;
-      }
 
-   } while(*(s++) != 0);
+   /* If there is no HSync or VRefresh data for the monitor,
+    * derive it from DDC data. Essentially done by common layer
+    * since 4.3.99.14, but this is not usable since it is done
+    * too late (in ValidateModes()).
+    * Addendum: I overrule the ranges now in any case unless
+    * it would affect a CRT output device or DDC data is available.
+    * Hence, for LCD(A) and TV, we always get proper ranges. This
+    * is entirely harmless. However, option "NoOverruleRanges" will
+    * disable this behavior.
+    * This should "fix" the - by far - most common configuration
+    * mistakes.
+    */
 
-   return rangenum;
-}
+    freqoverruled = FALSE;
 
-/* Copy and link two modes (i, j) for mergedfb mode
- * (Code base taken from mga driver)
- *
- * - Copy mode i, merge j to copy of i, link the result to dest
- * - Link i and j in private record.
- * - If dest is NULL, return value is copy of i linked to itself.
- * - For mergedfb auto-config, we only check the dimension
- *   against virtualX/Y, if they were user-provided.
- * - No special treatment required for CRTxxOffs.
- * - Provide fake dotclock in order to distinguish between similar
- *   looking MetaModes (for RandR and VidMode extensions)
- * - Set unique VRefresh of dest mode for RandR
- */
-static DisplayModePtr
-SiSCopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest,
-                 DisplayModePtr i, DisplayModePtr j,
-		 SiSScrn2Rel srel)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    DisplayModePtr mode;
-    int dx = 0,dy = 0;
-
-    if(!((mode = xalloc(sizeof(DisplayModeRec))))) return dest;
-    memcpy(mode, i, sizeof(DisplayModeRec));
-    if(!((mode->Private = xalloc(sizeof(SiSMergedDisplayModeRec))))) {
-       xfree(mode);
-       return dest;
-    }
-    ((SiSMergedDisplayModePtr)mode->Private)->CRT1 = i;
-    ((SiSMergedDisplayModePtr)mode->Private)->CRT2 = j;
-    ((SiSMergedDisplayModePtr)mode->Private)->CRT2Position = srel;
-    mode->PrivSize = 0;
-
-    switch(srel) {
-    case sisLeftOf:
-    case sisRightOf:
-       if(!(pScrn->display->virtualX)) {
-          dx = i->HDisplay + j->HDisplay;
-       } else {
-          dx = min(pScrn->virtualX, i->HDisplay + j->HDisplay);
-       }
-       dx -= mode->HDisplay;
-       if(!(pScrn->display->virtualY)) {
-          dy = max(i->VDisplay, j->VDisplay);
-       } else {
-          dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
-       }
-       dy -= mode->VDisplay;
-       break;
-    case sisAbove:
-    case sisBelow:
-       if(!(pScrn->display->virtualY)) {
-          dy = i->VDisplay + j->VDisplay;
-       } else {
-          dy = min(pScrn->virtualY, i->VDisplay + j->VDisplay);
-       }
-       dy -= mode->VDisplay;
-       if(!(pScrn->display->virtualX)) {
-          dx = max(i->HDisplay, j->HDisplay);
-       } else {
-          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
-       }
-       dx -= mode->HDisplay;
-       break;
-    case sisClone:
-       if(!(pScrn->display->virtualX)) {
-          dx = max(i->HDisplay, j->HDisplay);
-       } else {
-          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
+    fromDDC = FALSE;
+    if((pScrn->monitor->nHsync <= 0) || (pSiS->OverruleRanges)) {
+       if((pScrn->monitor->nHsync <= 0) && (pScrn->monitor->DDC)) {
+	  SiSSetSyncRangeFromEdid(pScrn, 1);
+	  if(pScrn->monitor->nHsync > 0) {
+	     if(!quiet)
+	        xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr, crtnum);
+	     fromDDC = TRUE;
+	  }
        }
-       dx -= mode->HDisplay;
-       if(!(pScrn->display->virtualY)) {
-          dy = max(i->VDisplay, j->VDisplay);
-       } else {
-	  dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
+       if((pScrn->monitor->nHsync <= 0) || (pSiS->OverruleRanges)) {
+	  if(SiSAllowSyncOverride(pSiS, fromDDC, mfbcrt)) {
+	     Bool HaveNoRanges = (pScrn->monitor->nHsync <= 0);
+	     /* Set sane ranges for LCD and TV
+	      * (our strict checking will filter out invalid ones anyway)
+	      */
+	     if((freqoverruled = SiSCheckAndOverruleH(pScrn, pScrn->monitor))) {
+	        if(!quiet)
+		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, saneh,
+			HaveNoRanges ? "missing" : "bogus", crtnum);
+	     }
+	  }
        }
-       dy -= mode->VDisplay;
-       break;
-    }
-    mode->HDisplay += dx;
-    mode->HSyncStart += dx;
-    mode->HSyncEnd += dx;
-    mode->HTotal += dx;
-    mode->VDisplay += dy;
-    mode->VSyncStart += dy;
-    mode->VSyncEnd += dy;
-    mode->VTotal += dy;
-
-    mode->type = M_T_DEFAULT;
-#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,2,0)
-    /* Set up as user defined (ie fake that the mode has been named in the
-     * Modes-list in the screen section; corrects cycling with CTRL-ALT-[-+]
-     * when source mode has not been listed there.)
-     */
-    mode->type |= M_T_USERDEF;
-#endif
-
-    /* Set the VRefresh field (in order to make RandR use it for the rates). We
-     * simply set this to the refresh rate for the CRT1 mode (since CRT2 will
-     * mostly be LCD or TV anyway).
-     */
-    mode->VRefresh = SiSCalcVRate(i);
-
-    if( ((mode->HDisplay * ((pScrn->bitsPerPixel + 7) / 8) * mode->VDisplay) > pSiS->maxxfbmem) ||
-	(mode->HDisplay > 4088) ||
-	(mode->VDisplay > 4096) ) {
-
-       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		"Skipped \"%s\" (%dx%d), not enough video RAM or beyond hardware specs\n",
-		mode->name, mode->HDisplay, mode->VDisplay);
-       xfree(mode->Private);
-       xfree(mode);
-
-       return dest;
     }
 
-#ifdef SISXINERAMA
-    if(srel != sisClone) {
-       pSiS->AtLeastOneNonClone = TRUE;
-    }
-#endif
-
-    /* Now see if the resulting mode would be discarded as a "size" by the
-     * RandR extension, and increase its clock by 1000 in case it does.
-     */
-    if(dest) {
-       DisplayModePtr t = dest;
-       do {
-          if((t->HDisplay == mode->HDisplay) &&
-	     (t->VDisplay == mode->VDisplay) &&
-	     ((int)(t->VRefresh + .5) == (int)(mode->VRefresh + .5))) {
-	     mode->VRefresh += 1000.0;
+    fromDDC = FALSE;
+    if((pScrn->monitor->nVrefresh <= 0) || (pSiS->OverruleRanges)) {
+       if((pScrn->monitor->nVrefresh <= 0) && (pScrn->monitor->DDC)) {
+	  SiSSetSyncRangeFromEdid(pScrn, 0);
+	  if(pScrn->monitor->nVrefresh > 0) {
+	     if(!quiet)
+	        xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr, crtnum);
+	     fromDDC = TRUE;
+          }
+       }
+       if((pScrn->monitor->nVrefresh <= 0) || (pSiS->OverruleRanges)) {
+	  if(SiSAllowSyncOverride(pSiS, fromDDC, mfbcrt)) {
+	     Bool HaveNoRanges = (pScrn->monitor->nVrefresh <= 0);
+	     /* Set sane ranges for LCD and TV */
+	     if((freqoverruled = SiSCheckAndOverruleV(pScrn, pScrn->monitor))) {
+	        if(!quiet)
+		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, sanev,
+			HaveNoRanges ? "missing" : "bogus", crtnum);
+	     }
 	  }
-	  t = t->next;
-       } while((t) && (t != dest));
+       }
     }
 
-    /* Provide a fake but unique DotClock in order to trick the vidmode
-     * extension to allow selecting among a number of modes whose merged result
-     * looks identical but consists of different modes for CRT1 and CRT2
-     */
-    mode->Clock = (int)(mode->VRefresh * 1000.0);
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	"Merged \"%s\" (%dx%d) and \"%s\" (%dx%d) to %dx%d (%d)%s\n",
-	i->name, i->HDisplay, i->VDisplay, j->name, j->HDisplay, j->VDisplay,
-	mode->HDisplay, mode->VDisplay, (int)mode->VRefresh,
-	(srel == sisClone) ? " (Clone)" : "");
-
-    mode->next = mode;
-    mode->prev = mode;
+    return freqoverruled;
+}
 
-    if(dest) {
-       mode->next = dest->next; 	/* Insert node after "dest" */
-       dest->next->prev = mode;
-       mode->prev = dest;
-       dest->next = mode;
-    }
 
-    return mode;
-}
+/* Mode list generators */
 
-/* Helper function to find a mode from a given name
- * (Code base taken from mga driver)
- */
-static DisplayModePtr
-SiSGetModeFromName(char* str, DisplayModePtr i)
+Bool
+SiSMakeOwnModeList(ScrnInfoPtr pScrn, Bool acceptcustommodes, Bool includelcdmodes,
+                   Bool isfordvi, Bool *havecustommodes, Bool fakecrt2modes, Bool IsForCRT2)
 {
-    DisplayModePtr c = i;
-    if(!i) return NULL;
-    do {
-       if(strcmp(str, c->name) == 0) return c;
-       c = c->next;
-    } while(c != i);
-    return NULL;
-}
+    DisplayModePtr tempmode, delmode, mymodes;
 
-static DisplayModePtr
-SiSFindWidestTallestMode(DisplayModePtr i, Bool tallest)
-{
-    DisplayModePtr c = i, d = NULL;
-    int max = 0;
-    if(!i) return NULL;
-    do {
-       if(tallest) {
-          if(c->VDisplay > max) {
-	     max = c->VDisplay;
-	     d = c;
-          }
+    if((mymodes = SiSBuildBuiltInModeList(pScrn, includelcdmodes, isfordvi, fakecrt2modes, IsForCRT2))) {
+       if(!acceptcustommodes) {
+          /* Delete all modes */
+	  while(pScrn->monitor->Modes)
+	     xf86DeleteMode(&pScrn->monitor->Modes, pScrn->monitor->Modes);
+	  pScrn->monitor->Modes = mymodes;
        } else {
-          if(c->HDisplay > max) {
-	     max = c->HDisplay;
-	     d = c;
-          }
+          /* Delete all default and built-in modes and link our
+           * new modes at the end of the user-provided ones.
+           * (There shouldn't be any builtins at server-start,
+           * but if we are re-using this for our dynamic modelist
+           * rebuilding, there might be some from previous
+           * instances.)
+           */
+	  delmode = pScrn->monitor->Modes;
+	  while(delmode) {
+	     if(delmode->type & (M_T_DEFAULT | M_T_BUILTIN)) {
+	        tempmode = delmode->next;
+	        xf86DeleteMode(&pScrn->monitor->Modes, delmode);
+	        delmode = tempmode;
+	     } else {
+	        delmode = delmode->next;
+	     }
+	  }
+	  /* Link default modes AFTER user ones */
+	  if((tempmode = pScrn->monitor->Modes)) {
+	     *havecustommodes = TRUE;
+	     while(tempmode) {
+	        if(!tempmode->next) break;
+	        else tempmode = tempmode->next;
+	     }
+	     tempmode->next = mymodes;
+	     mymodes->prev = tempmode;
+	  } else {
+	     pScrn->monitor->Modes = mymodes;
+	  }
        }
-       c = c->next;
-    } while(c != i);
-    return d;
+       return TRUE;
+    } else
+       return FALSE;
 }
 
 static void
-SiSFindWidestTallestCommonMode(DisplayModePtr i, DisplayModePtr j, Bool tallest,
-				DisplayModePtr *a, DisplayModePtr *b)
+SiSSetupModeListParmsCRT1(SISPtr pSiS, unsigned int VBFlags, unsigned int VBFlags3,
+		Bool *acceptcustommodes, Bool *includelcdmodes, Bool *isfordvi,
+		Bool *fakecrt2modes, Bool *IsForCRT2, Bool *AllowInterlace)
 {
-    DisplayModePtr c = i, d;
-    int max = 0;
-    Bool foundone;
-
-    (*a) = (*b) = NULL;
+    (*acceptcustommodes) = TRUE;  /* Accept user modelines */
+    (*includelcdmodes)   = TRUE;  /* Include modes reported by DDC */
+    (*isfordvi)          = FALSE; /* Is for digital DVI output */
+    (*fakecrt2modes)     = FALSE; /* Fake some modes for CRT2 */
+    (*IsForCRT2)	 = FALSE;
+    (*AllowInterlace)    = TRUE;  /* Allow interlace modes */
 
-    if(!i || !j) return;
+    if(pSiS->UseVESA) {
+       (*acceptcustommodes) = FALSE;
+       (*includelcdmodes)   = FALSE;
+    }
 
-    do {
-       d = j;
-       foundone = FALSE;
-       do {
-	  if( (c->HDisplay == d->HDisplay) &&
-	      (c->VDisplay == d->VDisplay) ) {
-	     foundone = TRUE;
-	     break;
-	  }
-	  d = d->next;
-       } while(d != j);
-       if(foundone) {
-	  if(tallest) {
-	     if(c->VDisplay > max) {
-		max = c->VDisplay;
-		(*a) = c;
-		(*b) = d;
+#ifdef SISDUALHEAD  /* Dual head is static. Output devices will not change. */
+    if(pSiS->DualHeadMode) {
+       if(!pSiS->SecondHead) {  /* CRT2: */
+	  if(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) {
+	     if(!(pSiS->VBFlags2 & VB2_30xBDH)) {
+		if(!(VBFlags & (CRT2_LCD|CRT2_VGA))) (*includelcdmodes)   = FALSE;
+		if(VBFlags & CRT2_LCD)               (*isfordvi)          = TRUE;
+		if(VBFlags & CRT2_TV)                (*acceptcustommodes) = FALSE;
+	     } else {
+		if(VBFlags & (CRT2_TV|CRT2_LCD)) {
+		   (*acceptcustommodes) = FALSE;
+		   (*includelcdmodes)   = FALSE;
+		   (*fakecrt2modes)     = TRUE;
+		}
 	     }
 	  } else {
-	     if(c->HDisplay > max) {
-		max = c->HDisplay;
-		(*a) = c;
-		(*b) = d;
+	     (*acceptcustommodes) = FALSE;
+	     (*includelcdmodes)   = FALSE;
+	     if(VBFlags & (CRT2_TV|CRT2_LCD)) {
+		(*fakecrt2modes)  = TRUE;
 	     }
 	  }
+	  (*AllowInterlace) = FALSE;
+	  (*IsForCRT2)      = TRUE;
+       } else {		/* CRT1: */
+	  if(VBFlags & CRT1_LCDA) {
+	     if(!(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)) {
+		(*acceptcustommodes) = FALSE;
+		(*includelcdmodes)   = FALSE;
+		(*fakecrt2modes)     = TRUE;
+		/* Will handle i-lace in mode-switching code */
+	     } else {
+		(*isfordvi)       = TRUE;
+		/* Don't allow i-lace modes */
+		(*AllowInterlace) = FALSE;
+	     }
+	  } else {
+	     (*includelcdmodes) = FALSE;
+	  }
        }
-       c = c->next;
-    } while(c != i);
-}
-
-static DisplayModePtr
-SiSGenerateModeListFromLargestModes(ScrnInfoPtr pScrn,
-		    DisplayModePtr i, DisplayModePtr j,
-		    SiSScrn2Rel srel)
-{
-#ifdef SISXINERAMA
-    SISPtr pSiS = SISPTR(pScrn);
+    } else
 #endif
-    DisplayModePtr mode1 = NULL;
-    DisplayModePtr mode2 = NULL;
-    DisplayModePtr mode3 = NULL;
-    DisplayModePtr mode4 = NULL;
-    DisplayModePtr result = NULL;
-
-#ifdef SISXINERAMA
-    pSiS->AtLeastOneNonClone = FALSE;
-#endif
-
-    /* Now build a default list of MetaModes.
-     * - Non-clone: If the user enabled NonRectangular, we use the
-     * largest mode for each CRT1 and CRT2. If not, we use the largest
-     * common mode for CRT1 and CRT2 (if available). Additionally, and
-     * regardless if the above, we produce a clone mode consisting of
-     * the largest common mode (if available) in order to use DGA.
-     * - Clone: If the (global) CRT2Position is Clone, we use the
-     * largest common mode if available, otherwise the first two modes
-     * in each list.
-     */
-
-    switch(srel) {
-    case sisLeftOf:
-    case sisRightOf:
-       mode1 = SiSFindWidestTallestMode(i, FALSE);
-       mode2 = SiSFindWidestTallestMode(j, FALSE);
-       SiSFindWidestTallestCommonMode(i, j, FALSE, &mode3, &mode4);
-       break;
-    case sisAbove:
-    case sisBelow:
-       mode1 = SiSFindWidestTallestMode(i, TRUE);
-       mode2 = SiSFindWidestTallestMode(j, TRUE);
-       SiSFindWidestTallestCommonMode(i, j, TRUE, &mode3, &mode4);
-       break;
-    case sisClone:
-       SiSFindWidestTallestCommonMode(i, j, FALSE, &mode3, &mode4);
-       if(mode3 && mode4) {
-	  mode1 = mode3;
-	  mode2 = mode4;
+#ifdef SISMERGED  /* MergedFB mode is not static. Output devices may change. */
+    /*else*/ if(pSiS->MergedFB) {
+       if(VBFlags & CRT1_LCDA) {
+	  if(!(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)) {
+	     (*acceptcustommodes) = FALSE;
+	     (*includelcdmodes)   = FALSE;
+	     (*fakecrt2modes)     = TRUE;
+	     /* Will handle i-lace in mode-switching code */
+	  } else {
+	     (*isfordvi)       = TRUE;
+	     /* Don't allow i-lace custom modes */
+	     (*AllowInterlace) = FALSE;
+	  }
        } else {
-	  mode1 = i;
-	  mode2 = j;
-       }
-    }
-
-    if(srel != sisClone) {
-       if(mode3 && mode4 && !pSiS->NonRect) {
-	  mode1 = mode3;
-	  mode2 = mode2;
-       }
-    }
-
-    if(mode1 && mode2) {
-       result = SiSCopyModeNLink(pScrn, result, mode1, mode2, srel);
-    }
-
-    if(srel != sisClone) {
-       if(mode3 && mode4) {
-	  result = SiSCopyModeNLink(pScrn, result, mode3, mode4, sisClone);
+	  (*includelcdmodes) = FALSE;
        }
-    }
-
-    return result;
-}
-
-/* Generate the merged-fb mode modelist
- * (Taken from mga driver)
- */
-static DisplayModePtr
-SiSGenerateModeListFromMetaModes(ScrnInfoPtr pScrn, char* str,
-		    DisplayModePtr i, DisplayModePtr j,
-		    SiSScrn2Rel srel)
-{
-#ifdef SISXINERAMA
-    SISPtr pSiS = SISPTR(pScrn);
-#endif
-    char* strmode = str;
-    char modename[256];
-    Bool gotdash = FALSE;
-    char gotsep = 0;
-    SiSScrn2Rel sr;
-    DisplayModePtr mode1 = NULL;
-    DisplayModePtr mode2 = NULL;
-    DisplayModePtr result = NULL;
-    int myslen;
-
-#ifdef SISXINERAMA
-    pSiS->AtLeastOneNonClone = FALSE;
-#endif
-
-    do {
-        switch(*str) {
-        case 0:
-        case '-':
-	case '+':
-        case ' ':
-	case ',':
-	case ';':
-           if(strmode != str) {
-
-              myslen = str - strmode;
-              if(myslen > 255) myslen = 255;
-  	      strncpy(modename, strmode, myslen);
-  	      modename[myslen] = 0;
-
-              if(gotdash) {
-                 if(mode1 == NULL) {
-  	             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-  	                        "Error parsing MetaModes parameter\n");
-  	             return NULL;
-  	         }
-                 mode2 = SiSGetModeFromName(modename, j);
-                 if(!mode2) {
-                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                        "Mode \"%s\" is not a supported mode for CRT2\n", modename);
-                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                        "\t(Skipping metamode \"%s%c%s\")\n", mode1->name, gotsep, modename);
-                    mode1 = NULL;
-		    gotsep = 0;
-                 }
-              } else {
-                 mode1 = SiSGetModeFromName(modename, i);
-                 if(!mode1) {
-                    char* tmps = str;
-                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                        "Mode \"%s\" is not a supported mode for CRT1\n", modename);
-                    while(*tmps == ' ' || *tmps == ';') tmps++;
-                    /* skip the next mode */
-  	            if(*tmps == '-' || *tmps == '+' || *tmps == ',') {
-                       tmps++;
-		       /* skip spaces */
-		       while(*tmps == ' ' || *tmps == ';') tmps++;
-		       /* skip modename */
-		       while(*tmps && *tmps != ' ' && *tmps != ';' && *tmps != '-' && *tmps != '+' && *tmps != ',') tmps++;
-  	               myslen = tmps - strmode;
-  	               if(myslen > 255) myslen = 255;
-  	               strncpy(modename,strmode,myslen);
-  	               modename[myslen] = 0;
-                       str = tmps - 1;
-                    }
-                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                        "\t(Skipping metamode \"%s\")\n", modename);
-                    mode1 = NULL;
-		    gotsep = 0;
-                 }
-              }
-              gotdash = FALSE;
-           }
-           strmode = str + 1;
-           gotdash |= (*str == '-' || *str == '+' || *str == ',');
-	   if (*str == '-' || *str == '+' || *str == ',')
-  	      gotsep = *str;
-
-           if(*str != 0) break;
-	   /* Fall through otherwise */
-
-        default:
-           if(!gotdash && mode1) {
-              sr = srel;
-	      if(gotsep == '+') sr = sisClone;
-              if(!mode2) {
-                 mode2 = SiSGetModeFromName(mode1->name, j);
-                 sr = sisClone;
-              }
-              if(!mode2) {
-                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                     "Mode \"%s\" is not a supported mode for CRT2\n", mode1->name);
-                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                     "\t(Skipping metamode \"%s\")\n", modename);
-                 mode1 = NULL;
-              } else {
-                 result = SiSCopyModeNLink(pScrn, result, mode1, mode2, sr);
-                 mode1 = NULL;
-                 mode2 = NULL;
-              }
-	      gotsep = 0;
-           }
-           break;
-
-        }
-
-    } while(*(str++) != 0);
-     
-    return result;
-}
-
-static DisplayModePtr
-SiSGenerateModeList(ScrnInfoPtr pScrn, char* str,
-		    DisplayModePtr i, DisplayModePtr j,
-		    SiSScrn2Rel srel)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-
-   if(str != NULL) {
-      return(SiSGenerateModeListFromMetaModes(pScrn, str, i, j, srel));
-   } else {
-      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	"No MetaModes given, linking %s modes by default\n",
-	(srel == sisClone) ? "largest common" :
-	   (pSiS->NonRect ?
-		(((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest" :  "tallest")
-		:
-		(((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest common" :  "tallest common")) );
-      return(SiSGenerateModeListFromLargestModes(pScrn, i, j, srel));
-   }
-}
-
-static void
-SiSRecalcDefaultVirtualSize(ScrnInfoPtr pScrn)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    DisplayModePtr mode, bmode;
-    int maxh, maxv;
-    static const char *str = "MergedFB: Virtual %s %d\n";
-    static const char *errstr = "Virtual %s to small for given CRT2Position offset\n";
-
-    mode = bmode = pScrn->modes;
-    maxh = maxv = 0;
-    do {
-       if(mode->HDisplay > maxh) maxh = mode->HDisplay;
-       if(mode->VDisplay > maxv) maxv = mode->VDisplay;
-       mode = mode->next;
-    } while(mode != bmode);
-
-    maxh += pSiS->CRT1XOffs + pSiS->CRT2XOffs;
-    maxv += pSiS->CRT1YOffs + pSiS->CRT2YOffs;
-
-    if(!(pScrn->display->virtualX)) {
-       if(maxh > 4088) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		"Virtual width with CRT2Position offset beyond hardware specs\n");
-	  pSiS->CRT1XOffs = pSiS->CRT2XOffs = 0;
-	  maxh -= (pSiS->CRT1XOffs + pSiS->CRT2XOffs);
+    } else
+#endif		 /* Mirror mode is not static. Output devices may change. */
+    /*else*/ if(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) {
+       if(!(pSiS->VBFlags2 & VB2_30xBDH)) {
+	  if(!(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)) {
+	     if(!(VBFlags & (CRT2_LCD|CRT2_VGA))) (*includelcdmodes) = FALSE;
+	     if(VBFlags & CRT2_LCD)               (*isfordvi)        = TRUE;
+	  } else {
+	     if(!(VBFlags & (CRT2_LCD|CRT2_VGA|CRT1_LCDA))) (*includelcdmodes) = FALSE;
+	     if(VBFlags & (CRT2_LCD|CRT1_LCDA))             (*isfordvi)        = TRUE;
+	  }
+	  if((!(VBFlags & DISPTYPE_CRT1)) && (!(VBFlags & CRT1_LCDA))) {
+	     (*IsForCRT2) = TRUE;
+	  }
+	  /* Allow user modes, even if CRT2 is TV. Will be filtered through ValidMode();
+	   * leaving the user modes here might have the advantage that such a mode, if
+	   * it matches in resolution with a supported TV mode, allows us to drive eg.
+	   * non standard panels, and still permits switching to TV. This mode will be
+	   * "mapped" to a supported mode of identical resolution for TV. All this is
+	   * taken care of by ValidMode() and ModeInit()/PresetMode().
+	   */
+       } else {
+	  if(VBFlags & (CRT2_TV | CRT2_LCD)) {
+	     (*acceptcustommodes) = FALSE;
+	     (*includelcdmodes)   = FALSE;
+	     if(!(VBFlags & DISPTYPE_CRT1)) {
+		(*fakecrt2modes)  = TRUE;
+		(*IsForCRT2)      = TRUE;
+	     }
+	  }
        }
-       pScrn->virtualX = maxh;
-       pScrn->displayWidth = maxh;
-       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "width", maxh);
-    } else {
-       if(maxh < pScrn->display->virtualX) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, errstr, "width");
-	  pSiS->CRT1XOffs = pSiS->CRT2XOffs = 0;
+    } else if(VBFlags & (CRT2_ENABLE | CRT1_LCDA)) {
+       (*acceptcustommodes) = FALSE;
+       (*includelcdmodes)   = FALSE;
+       if((VBFlags & CRT1_LCDA) || (!(VBFlags & DISPTYPE_CRT1))) {
+	  (*fakecrt2modes)  = TRUE;
+	  (*IsForCRT2)      = TRUE;
        }
-    }
-
-    if(!(pScrn->display->virtualY)) {
-       pScrn->virtualY = maxv;
-       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "height", maxv);
     } else {
-       if(maxv < pScrn->display->virtualY) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, errstr, "height");
-	  pSiS->CRT1YOffs = pSiS->CRT2YOffs = 0;
-       }
+       (*includelcdmodes)   = FALSE;
     }
+    /* Ignore interlace, mode switching code will handle this */
 }
 
-static void
-SiSMergedFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel)
-{
-   SISPtr pSiS = SISPTR(pScrn1);
-   MessageType from = X_DEFAULT;
-   xf86MonPtr DDC1 = (xf86MonPtr)(pScrn1->monitor->DDC);
-   xf86MonPtr DDC2 = (xf86MonPtr)(pScrn2->monitor->DDC);
-   int ddcWidthmm = 0, ddcHeightmm = 0;
-   const char *dsstr = "MergedFB: Display dimensions: (%d, %d) mm\n";
-
-   /* This sets the DPI for MergedFB mode. The problem is that
-    * this can never be exact, because the output devices may
-    * have different dimensions. This function tries to compromise
-    * through a few assumptions, and it just calculates an average DPI
-    * value for both monitors.
-    */
-
-   /* Given DisplaySize should regard BOTH monitors */
-   pScrn1->widthmm = pScrn1->monitor->widthmm;
-   pScrn1->heightmm = pScrn1->monitor->heightmm;
-
-   /* Get DDC display size; if only either CRT1 or CRT2 provided these,
-    * assume equal dimensions for both, otherwise add dimensions
-    */
-   if( (DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) &&
-       (DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0)) ) {
-      ddcWidthmm = max(DDC1->features.hsize, DDC2->features.hsize) * 10;
-      ddcHeightmm = max(DDC1->features.vsize, DDC2->features.vsize) * 10;
-      switch(srel) {
-      case sisLeftOf:
-      case sisRightOf:
-	 ddcWidthmm = (DDC1->features.hsize + DDC2->features.hsize) * 10;
-	 break;
-      case sisAbove:
-      case sisBelow:
-	 ddcHeightmm = (DDC1->features.vsize + DDC2->features.vsize) * 10;
-      default:
-	 break;
-      }
-   } else if(DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) {
-      ddcWidthmm = DDC1->features.hsize * 10;
-      ddcHeightmm = DDC1->features.vsize * 10;
-      switch(srel) {
-      case sisLeftOf:
-      case sisRightOf:
-	 ddcWidthmm *= 2;
-	 break;
-      case sisAbove:
-      case sisBelow:
-	 ddcHeightmm *= 2;
-      default:
-	 break;
-      }
-   } else if(DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0) ) {
-      ddcWidthmm = DDC2->features.hsize * 10;
-      ddcHeightmm = DDC2->features.vsize * 10;
-      switch(srel) {
-      case sisLeftOf:
-      case sisRightOf:
-	 ddcWidthmm *= 2;
-	 break;
-      case sisAbove:
-      case sisBelow:
-	 ddcHeightmm *= 2;
-      default:
-	 break;
-      }
-   }
-
-   if(monitorResolution > 0) {
-
-      /* Set command line given values (overrules given options) */
-      pScrn1->xDpi = monitorResolution;
-      pScrn1->yDpi = monitorResolution;
-      from = X_CMDLINE;
-
-   } else if(pSiS->MergedFBXDPI) {
-
-      /* Set option-wise given values (overrule DisplaySize) */
-      pScrn1->xDpi = pSiS->MergedFBXDPI;
-      pScrn1->yDpi = pSiS->MergedFBYDPI;
-      from = X_CONFIG;
-
-   } else if(pScrn1->widthmm > 0 || pScrn1->heightmm > 0) {
-
-      /* Set values calculated from given DisplaySize */
-      from = X_CONFIG;
-      if(pScrn1->widthmm > 0) {
-	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
-      }
-      if(pScrn1->heightmm > 0) {
-	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
-      }
-      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, pScrn1->widthmm, pScrn1->heightmm);
-
-    } else if(ddcWidthmm && ddcHeightmm) {
-
-      /* Set values from DDC-provided display size */
-      from = X_PROBED;
-      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, ddcWidthmm, ddcHeightmm );
-      pScrn1->widthmm = ddcWidthmm;
-      pScrn1->heightmm = ddcHeightmm;
-      if(pScrn1->widthmm > 0) {
-	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
-      }
-      if(pScrn1->heightmm > 0) {
-	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
-      }
-
-    } else {
-
-      pScrn1->xDpi = pScrn1->yDpi = DEFAULT_DPI;
-
-    }
-
-    /* Sanity check */
-    if(pScrn1->xDpi > 0 && pScrn1->yDpi <= 0)
-       pScrn1->yDpi = pScrn1->xDpi;
-    if(pScrn1->yDpi > 0 && pScrn1->xDpi <= 0)
-       pScrn1->xDpi = pScrn1->yDpi;
-
-    pScrn2->xDpi = pScrn1->xDpi;
-    pScrn2->yDpi = pScrn1->yDpi;
-
-    xf86DrvMsg(pScrn1->scrnIndex, from, "MergedFB: DPI set to (%d, %d)\n",
-		pScrn1->xDpi, pScrn1->yDpi);
-}
-
-/* Pseudo-Xinerama extension for MergedFB mode */
-#ifdef SISXINERAMA
-
-static void
-SiSUpdateXineramaScreenInfo(ScrnInfoPtr pScrn1)
+static Bool
+SiSReplaceModeList(ScrnInfoPtr pScrn, ClockRangePtr clockRanges, Bool quiet)
 {
-    SISPtr pSiS = SISPTR(pScrn1);
-    int crt1scrnnum = 0, crt2scrnnum = 1;
-    int x1=0, x2=0, y1=0, y2=0, h1=0, h2=0, w1=0, w2=0;
-    int realvirtX, realvirtY;
-    DisplayModePtr currentMode, firstMode;
-    Bool infochanged = FALSE;
-    Bool usenonrect = pSiS->NonRect;
-    const char *rectxine = "\t... setting up rectangular Xinerama layout\n";
-
-    pSiS->MBXNR1XMAX = pSiS->MBXNR1YMAX = pSiS->MBXNR2XMAX = pSiS->MBXNR2YMAX = 65536;
-    pSiS->HaveNonRect = pSiS->HaveOffsRegions = FALSE;
-
-    if(!pSiS->MergedFB) return;
-
-    if(SiSnoPanoramiXExtension) return;
-
-    if(!SiSXineramadataPtr) return;
-
-    if(pSiS->CRT2IsScrn0) {
-       crt1scrnnum = 1;
-       crt2scrnnum = 0;
-    }
+    SISPtr pSiS = SISPTR(pScrn);
+    Bool acceptcustommodes;	/* Accept user modelines */
+    Bool includelcdmodes;	/* Include modes reported by DDC */
+    Bool isfordvi;		/* Is for digital DVI output */
+    Bool fakecrt2modes;		/* Fake some modes for CRT2 */
+    Bool IsForCRT2;
+    Bool ret = TRUE;
 
-    /* Attention: Usage of RandR may lead to virtual X and Y dimensions
-     * actually smaller than our MetaModes. To avoid this, we calculate
-     * the maxCRT fields here (and not somewhere else, like in CopyNLink)
-     *
-     * *** Note: RandR is disabled if one of CRTxxOffs is non-zero.
+    /*
+     * Since we have lots of built-in modes for 300 series and later
+     * with vb support, we replace the given default mode list with our
+     * own. In case the video bridge is to be used, we only allow other
+     * modes if
+     *   -) vbtype is a tmds bridge (301, 301B, 301C, 302B), and
+     *   -) crt2 device is not TV, and
+     *   -) crt1 is not LCDA, unless bridge is TMDS/LCDA capable (301C)
      */
 
-    /* "Real" virtual: Virtual without the Offset */
-    realvirtX = pScrn1->virtualX - pSiS->CRT1XOffs - pSiS->CRT2XOffs;
-    realvirtY = pScrn1->virtualY - pSiS->CRT1YOffs - pSiS->CRT2YOffs;
-
-    if((pSiS->SiSXineramaVX != pScrn1->virtualX) || (pSiS->SiSXineramaVY != pScrn1->virtualY)) {
-
-       if(!(pScrn1->modes)) return;
+    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
 
-       pSiS->maxCRT1_X1 = pSiS->maxCRT1_X2 = 0;
-       pSiS->maxCRT1_Y1 = pSiS->maxCRT1_Y2 = 0;
-       pSiS->maxCRT2_X1 = pSiS->maxCRT2_X2 = 0;
-       pSiS->maxCRT2_Y1 = pSiS->maxCRT2_Y2 = 0;
-       pSiS->maxClone_X1 = pSiS->maxClone_X2 = 0;
-       pSiS->maxClone_Y1 = pSiS->maxClone_Y2 = 0;
+       if(!(pSiS->noInternalModes)) {
+          SiSSetupModeListParmsCRT1(pSiS, pSiS->VBFlags, pSiS->VBFlags3,
+			&acceptcustommodes, &includelcdmodes, &isfordvi,
+			&fakecrt2modes, &IsForCRT2, &clockRanges->interlaceAllowed);
 
-       currentMode = firstMode = pScrn1->modes;
 
-       do {
+	  pSiS->HaveCustomModes = FALSE;
 
-          DisplayModePtr p = currentMode->next;
-          DisplayModePtr i = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1;
-          DisplayModePtr j = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2;
-          SiSScrn2Rel srel = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2Position;
+	  if(SiSMakeOwnModeList(pScrn, acceptcustommodes, includelcdmodes,
+			isfordvi, &pSiS->HaveCustomModes, FALSE /*fakecrt2modes*/, IsForCRT2)) {
 
-          if((currentMode->HDisplay <= realvirtX) && (currentMode->VDisplay <= realvirtY) &&
-	     (i->HDisplay <= realvirtX) && (j->HDisplay <= realvirtX) &&
-	     (i->VDisplay <= realvirtY) && (j->VDisplay <= realvirtY)) {
+	     if(!quiet) {
+	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"Replaced %s mode list with built-in modes\n",
+				pSiS->HaveCustomModes ? "default" : "entire");
+	     }
 
-	     if(srel != sisClone) {
-		if(pSiS->maxCRT1_X1 == i->HDisplay) {
-		   if(pSiS->maxCRT1_X2 < j->HDisplay) {
-		      pSiS->maxCRT1_X2 = j->HDisplay;   /* Widest CRT2 mode displayed with widest CRT1 mode */
-		   }
-		} else if(pSiS->maxCRT1_X1 < i->HDisplay) {
-		   pSiS->maxCRT1_X1 = i->HDisplay;      /* Widest CRT1 mode */
-		   pSiS->maxCRT1_X2 = j->HDisplay;
-		}
-		if(pSiS->maxCRT2_X2 == j->HDisplay) {
-		   if(pSiS->maxCRT2_X1 < i->HDisplay) {
-		      pSiS->maxCRT2_X1 = i->HDisplay;   /* Widest CRT1 mode displayed with widest CRT2 mode */
-		   }
-		} else if(pSiS->maxCRT2_X2 < j->HDisplay) {
-		   pSiS->maxCRT2_X2 = j->HDisplay;      /* Widest CRT2 mode */
-		   pSiS->maxCRT2_X1 = i->HDisplay;
-		}
-		if(pSiS->maxCRT1_Y1 == i->VDisplay) {   /* Same as above, but tallest instead of widest */
-		   if(pSiS->maxCRT1_Y2 < j->VDisplay) {
-		      pSiS->maxCRT1_Y2 = j->VDisplay;
-		   }
-		} else if(pSiS->maxCRT1_Y1 < i->VDisplay) {
-		   pSiS->maxCRT1_Y1 = i->VDisplay;
-		   pSiS->maxCRT1_Y2 = j->VDisplay;
-		}
-		if(pSiS->maxCRT2_Y2 == j->VDisplay) {
-		   if(pSiS->maxCRT2_Y1 < i->VDisplay) {
-		      pSiS->maxCRT2_Y1 = i->VDisplay;
+	     if(pSiS->VGAEngine == SIS_315_VGA) {
+		int UseWide = pSiS->SiS_Pr->SiS_UseWide;
+		if(IsForCRT2) UseWide = pSiS->SiS_Pr->SiS_UseWideCRT2;
+		if((!IsForCRT2) || (pSiS->VBFlags2 & VB2_SISVGA2BRIDGE)) {
+		   if(!quiet) {
+		      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"Using %s widescreen modes for CRT%d VGA devices\n",
+			UseWide ? "real" : "fake", IsForCRT2 ? 2 : 1);
+		      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"\t[Use option \"ForceCRT%dVGAAspect\" to overrule]\n",
+			IsForCRT2 ? 2 : 1);
 		   }
-		} else if(pSiS->maxCRT2_Y2 < j->VDisplay) {
-		   pSiS->maxCRT2_Y2 = j->VDisplay;
-		   pSiS->maxCRT2_Y1 = i->VDisplay;
-		}
-	     } else {
-		if(pSiS->maxClone_X1 < i->HDisplay) {
-		   pSiS->maxClone_X1 = i->HDisplay;
-		}
-		if(pSiS->maxClone_X2 < j->HDisplay) {
-		   pSiS->maxClone_X2 = j->HDisplay;
-		}
-		if(pSiS->maxClone_Y1 < i->VDisplay) {
-		   pSiS->maxClone_Y1 = i->VDisplay;
-		}
-		if(pSiS->maxClone_Y2 < j->VDisplay) {
-		   pSiS->maxClone_Y2 = j->VDisplay;
 		}
 	     }
-	  }
-	  currentMode = p;
-
-       } while((currentMode) && (currentMode != firstMode));
 
-       pSiS->SiSXineramaVX = pScrn1->virtualX;
-       pSiS->SiSXineramaVY = pScrn1->virtualY;
-       infochanged = TRUE;
+          } else {
 
-    }
+	     ret = FALSE;
+	     if(!quiet) {
+	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			"Building list of built-in modes failed, using server defaults\n");
+	     }
 
-    if((usenonrect) && (pSiS->CRT2Position != sisClone) && pSiS->maxCRT1_X1) {
-       switch(pSiS->CRT2Position) {
-       case sisLeftOf:
-       case sisRightOf:
-	  if((pSiS->maxCRT1_Y1 != realvirtY) && (pSiS->maxCRT2_Y2 != realvirtY)) {
-	     usenonrect = FALSE;
-	  }
-	  break;
-       case sisAbove:
-       case sisBelow:
-	  if((pSiS->maxCRT1_X1 != realvirtX) && (pSiS->maxCRT2_X2 != realvirtX)) {
-	     usenonrect = FALSE;
-	  }
-	  break;
-       case sisClone:
-	  break;
-       }
-       if(infochanged && !usenonrect) {
-	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-			"Virtual screen size does not match maximum display modes...\n");
-	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO, rectxine);
-
-       }
-    } else if(infochanged && usenonrect) {
-       usenonrect = FALSE;
-       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-		"Only clone modes available for this virtual screen size...\n");
-       xf86DrvMsg(pScrn1->scrnIndex, X_INFO, rectxine);
-    }
-
-    if(pSiS->maxCRT1_X1) {		/* Means we have at least one non-clone mode */
-       switch(pSiS->CRT2Position) {
-       case sisLeftOf:
-	  x1 = min(pSiS->maxCRT1_X2, pScrn1->virtualX - pSiS->maxCRT1_X1);
-	  if(x1 < 0) x1 = 0;
-	  y1 = pSiS->CRT1YOffs;
-	  w1 = pScrn1->virtualX - x1;
-	  h1 = realvirtY;
-	  if((usenonrect) && (pSiS->maxCRT1_Y1 != realvirtY)) {
-	     h1 = pSiS->MBXNR1YMAX = pSiS->maxCRT1_Y1;
-	     pSiS->NonRectDead.x0 = x1;
-	     pSiS->NonRectDead.x1 = x1 + w1 - 1;
-	     pSiS->NonRectDead.y0 = y1 + h1;
-	     pSiS->NonRectDead.y1 = pScrn1->virtualY - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-	  x2 = 0;
-	  y2 = pSiS->CRT2YOffs;
-	  w2 = max(pSiS->maxCRT2_X2, pScrn1->virtualX - pSiS->maxCRT2_X1);
-	  if(w2 > pScrn1->virtualX) w2 = pScrn1->virtualX;
-	  h2 = realvirtY;
-	  if((usenonrect) && (pSiS->maxCRT2_Y2 != realvirtY)) {
-	     h2 = pSiS->MBXNR2YMAX = pSiS->maxCRT2_Y2;
-	     pSiS->NonRectDead.x0 = x2;
-	     pSiS->NonRectDead.x1 = x2 + w2 - 1;
-	     pSiS->NonRectDead.y0 = y2 + h2;
-	     pSiS->NonRectDead.y1 = pScrn1->virtualY - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-	  break;
-       case sisRightOf:
-	  x1 = 0;
-	  y1 = pSiS->CRT1YOffs;
-	  w1 = max(pSiS->maxCRT1_X1, pScrn1->virtualX - pSiS->maxCRT1_X2);
-	  if(w1 > pScrn1->virtualX) w1 = pScrn1->virtualX;
-	  h1 = realvirtY;
-	  if((usenonrect) && (pSiS->maxCRT1_Y1 != realvirtY)) {
-	     h1 = pSiS->MBXNR1YMAX = pSiS->maxCRT1_Y1;
-	     pSiS->NonRectDead.x0 = x1;
-	     pSiS->NonRectDead.x1 = x1 + w1 - 1;
-	     pSiS->NonRectDead.y0 = y1 + h1;
-	     pSiS->NonRectDead.y1 = pScrn1->virtualY - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-	  x2 = min(pSiS->maxCRT2_X1, pScrn1->virtualX - pSiS->maxCRT2_X2);
-	  if(x2 < 0) x2 = 0;
-	  y2 = pSiS->CRT2YOffs;
-	  w2 = pScrn1->virtualX - x2;
-	  h2 = realvirtY;
-	  if((usenonrect) && (pSiS->maxCRT2_Y2 != realvirtY)) {
-	     h2 = pSiS->MBXNR2YMAX = pSiS->maxCRT2_Y2;
-	     pSiS->NonRectDead.x0 = x2;
-	     pSiS->NonRectDead.x1 = x2 + w2 - 1;
-	     pSiS->NonRectDead.y0 = y2 + h2;
-	     pSiS->NonRectDead.y1 = pScrn1->virtualY - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-	  break;
-       case sisAbove:
-	  x1 = pSiS->CRT1XOffs;
-	  y1 = min(pSiS->maxCRT1_Y2, pScrn1->virtualY - pSiS->maxCRT1_Y1);
-	  if(y1 < 0) y1 = 0;
-	  w1 = realvirtX;
-	  h1 = pScrn1->virtualY - y1;
-	  if((usenonrect) && (pSiS->maxCRT1_X1 != realvirtX)) {
-	     w1 = pSiS->MBXNR1XMAX = pSiS->maxCRT1_X1;
-	     pSiS->NonRectDead.x0 = x1 + w1;
-	     pSiS->NonRectDead.x1 = pScrn1->virtualX - 1;
-	     pSiS->NonRectDead.y0 = y1;
-	     pSiS->NonRectDead.y1 = y1 + h1 - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-	  x2 = pSiS->CRT2XOffs;
-	  y2 = 0;
-	  w2 = realvirtX;
-	  h2 = max(pSiS->maxCRT2_Y2, pScrn1->virtualY - pSiS->maxCRT2_Y1);
-	  if(h2 > pScrn1->virtualY) h2 = pScrn1->virtualY;
-	  if((usenonrect) && (pSiS->maxCRT2_X2 != realvirtX)) {
-	     w2 = pSiS->MBXNR2XMAX = pSiS->maxCRT2_X2;
-	     pSiS->NonRectDead.x0 = x2 + w2;
-	     pSiS->NonRectDead.x1 = pScrn1->virtualX - 1;
-	     pSiS->NonRectDead.y0 = y2;
-	     pSiS->NonRectDead.y1 = y2 + h2 - 1;
-	     pSiS->HaveNonRect = TRUE;
 	  }
-	  break;
-       case sisBelow:
-	  x1 = pSiS->CRT1XOffs;
-	  y1 = 0;
-	  w1 = realvirtX;
-	  h1 = max(pSiS->maxCRT1_Y1, pScrn1->virtualY - pSiS->maxCRT1_Y2);
-	  if(h1 > pScrn1->virtualY) h1 = pScrn1->virtualY;
-	  if((usenonrect) && (pSiS->maxCRT1_X1 != realvirtX)) {
-	     w1 = pSiS->MBXNR1XMAX = pSiS->maxCRT1_X1;
-	     pSiS->NonRectDead.x0 = x1 + w1;
-	     pSiS->NonRectDead.x1 = pScrn1->virtualX - 1;
-	     pSiS->NonRectDead.y0 = y1;
-	     pSiS->NonRectDead.y1 = y1 + h1 - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-	  x2 = pSiS->CRT2XOffs;
-	  y2 = min(pSiS->maxCRT2_Y1, pScrn1->virtualY - pSiS->maxCRT2_Y2);
-	  if(y2 < 0) y2 = 0;
-	  w2 = realvirtX;
-	  h2 = pScrn1->virtualY - y2;
-	  if((usenonrect) && (pSiS->maxCRT2_X2 != realvirtX)) {
-	     w2 = pSiS->MBXNR2XMAX = pSiS->maxCRT2_X2;
-	     pSiS->NonRectDead.x0 = x2 + w2;
-	     pSiS->NonRectDead.x1 = pScrn1->virtualX - 1;
-	     pSiS->NonRectDead.y0 = y2;
-	     pSiS->NonRectDead.y1 = y2 + h2 - 1;
-	     pSiS->HaveNonRect = TRUE;
-	  }
-       default:
-	  break;
-       }
 
-       switch(pSiS->CRT2Position) {
-       case sisLeftOf:
-       case sisRightOf:
-	  if(pSiS->CRT1YOffs) {
-	     pSiS->OffDead1.x0 = x1;
-	     pSiS->OffDead1.x1 = x1 + w1 - 1;
-	     pSiS->OffDead1.y0 = 0;
-	     pSiS->OffDead1.y1 = y1 - 1;
-	     pSiS->OffDead2.x0 = x2;
-	     pSiS->OffDead2.x1 = x2 + w2 - 1;
-	     pSiS->OffDead2.y0 = y2 + h2;
-	     pSiS->OffDead2.y1 = pScrn1->virtualY - 1;
-	     pSiS->HaveOffsRegions = TRUE;
-	  } else if(pSiS->CRT2YOffs) {
-	     pSiS->OffDead1.x0 = x2;
-	     pSiS->OffDead1.x1 = x2 + w2 - 1;
-	     pSiS->OffDead1.y0 = 0;
-	     pSiS->OffDead1.y1 = y2 - 1;
-	     pSiS->OffDead2.x0 = x1;
-	     pSiS->OffDead2.x1 = x1 + w1 - 1;
-	     pSiS->OffDead2.y0 = y1 + h1;
-	     pSiS->OffDead2.y1 = pScrn1->virtualY - 1;
-	     pSiS->HaveOffsRegions = TRUE;
-	  }
-	  break;
-       case sisAbove:
-       case sisBelow:
-	  if(pSiS->CRT1XOffs) {
-	     pSiS->OffDead1.x0 = x2 + w2;
-	     pSiS->OffDead1.x1 = pScrn1->virtualX - 1;
-	     pSiS->OffDead1.y0 = y2;
-	     pSiS->OffDead1.y1 = y2 + h2 - 1;
-	     pSiS->OffDead2.x0 = 0;
-	     pSiS->OffDead2.x1 = x1 - 1;
-	     pSiS->OffDead2.y0 = y1;
-	     pSiS->OffDead2.y1 = y1 + h1 - 1;
-	     pSiS->HaveOffsRegions = TRUE;
-	  } else if(pSiS->CRT2XOffs) {
-	     pSiS->OffDead1.x0 = x1 + w1;
-	     pSiS->OffDead1.x1 = pScrn1->virtualX - 1;
-	     pSiS->OffDead1.y0 = y1;
-	     pSiS->OffDead1.y1 = y1 + h1 - 1;
-	     pSiS->OffDead2.x0 = 0;
-	     pSiS->OffDead2.x1 = x2 - 1;
-	     pSiS->OffDead2.y0 = y2;
-	     pSiS->OffDead2.y1 = y2 + h2 - 1;
-	     pSiS->HaveOffsRegions = TRUE;
-	  }
-       default:
-	  break;
-       }
+       } else {
+
+          pSiS->HaveCustomModes = TRUE;
 
-    } else {	/* Only clone-modes left */
-
-       x1 = x2 = 0;
-       y1 = y2 = 0;
-       w1 = w2 = max(pSiS->maxClone_X1, pSiS->maxClone_X2);
-       h1 = h2 = max(pSiS->maxClone_Y1, pSiS->maxClone_Y2);
-
-    }
-
-    SiSXineramadataPtr[crt1scrnnum].x = x1;
-    SiSXineramadataPtr[crt1scrnnum].y = y1;
-    SiSXineramadataPtr[crt1scrnnum].width = w1;
-    SiSXineramadataPtr[crt1scrnnum].height = h1;
-    SiSXineramadataPtr[crt2scrnnum].x = x2;
-    SiSXineramadataPtr[crt2scrnnum].y = y2;
-    SiSXineramadataPtr[crt2scrnnum].width = w2;
-    SiSXineramadataPtr[crt2scrnnum].height = h2;
-
-    if(infochanged) {
-       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-	  "Pseudo-Xinerama: CRT1 (Screen %d) (%d,%d)-(%d,%d)\n",
-	  crt1scrnnum, x1, y1, w1+x1-1, h1+y1-1);
-       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-	  "Pseudo-Xinerama: CRT2 (Screen %d) (%d,%d)-(%d,%d)\n",
-	  crt2scrnnum, x2, y2, w2+x2-1, h2+y2-1);
-       if(pSiS->HaveNonRect) {
-	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-		"Pseudo-Xinerama: Inaccessible area (%d,%d)-(%d,%d)\n",
-		pSiS->NonRectDead.x0, pSiS->NonRectDead.y0,
-		pSiS->NonRectDead.x1, pSiS->NonRectDead.y1);
-       }
-       if(pSiS->HaveOffsRegions) {
-	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-		"Pseudo-Xinerama: Inaccessible offset area (%d,%d)-(%d,%d)\n",
-		pSiS->OffDead1.x0, pSiS->OffDead1.y0,
-		pSiS->OffDead1.x1, pSiS->OffDead1.y1);
-	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-		"Pseudo-Xinerama: Inaccessible offset area (%d,%d)-(%d,%d)\n",
-		pSiS->OffDead2.x0, pSiS->OffDead2.y0,
-		pSiS->OffDead2.x1, pSiS->OffDead2.y1);
-       }
-       if(pSiS->HaveNonRect || pSiS->HaveOffsRegions) {
-	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
-		"Mouse restriction for inaccessible areas is %s\n",
-		pSiS->MouseRestrictions ? "enabled" : "disabled");
        }
     }
-}
 
-/* Proc */
-
-int
-SiSProcXineramaQueryVersion(ClientPtr client)
-{
-    xPanoramiXQueryVersionReply	  rep;
-    register int		  n;
-
-    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
-    rep.type = X_Reply;
-    rep.length = 0;
-    rep.sequenceNumber = client->sequence;
-    rep.majorVersion = SIS_XINERAMA_MAJOR_VERSION;
-    rep.minorVersion = SIS_XINERAMA_MINOR_VERSION;
-    if(client->swapped) {
-        swaps(&rep.sequenceNumber, n);
-        swapl(&rep.length, n);
-        swaps(&rep.majorVersion, n);
-        swaps(&rep.minorVersion, n);
-    }
-    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
-    return (client->noClientException);
-}
-
-int
-SiSProcXineramaGetState(ClientPtr client)
-{
-    REQUEST(xPanoramiXGetStateReq);
-    WindowPtr			pWin;
-    xPanoramiXGetStateReply	rep;
-    register int		n;
-
-    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
-    pWin = LookupWindow(stuff->window, client);
-    if(!pWin) return BadWindow;
-
-    rep.type = X_Reply;
-    rep.length = 0;
-    rep.sequenceNumber = client->sequence;
-    rep.state = !SiSnoPanoramiXExtension;
-    if(client->swapped) {
-       swaps (&rep.sequenceNumber, n);
-       swapl (&rep.length, n);
-       swaps (&rep.state, n);
-    }
-    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
-    return client->noClientException;
+    return ret;
 }
 
-int
-SiSProcXineramaGetScreenCount(ClientPtr client)
-{
-    REQUEST(xPanoramiXGetScreenCountReq);
-    WindowPtr				pWin;
-    xPanoramiXGetScreenCountReply	rep;
-    register int			n;
-
-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
-    pWin = LookupWindow(stuff->window, client);
-    if(!pWin) return BadWindow;
-
-    rep.type = X_Reply;
-    rep.length = 0;
-    rep.sequenceNumber = client->sequence;
-    rep.ScreenCount = SiSXineramaNumScreens;
-    if(client->swapped) {
-       swaps(&rep.sequenceNumber, n);
-       swapl(&rep.length, n);
-       swaps(&rep.ScreenCount, n);
-    }
-    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
-    return client->noClientException;
-}
 
-int
-SiSProcXineramaGetScreenSize(ClientPtr client)
+void
+SiSClearModesPrivate(DisplayModePtr modelist)
 {
-    REQUEST(xPanoramiXGetScreenSizeReq);
-    WindowPtr				pWin;
-    xPanoramiXGetScreenSizeReply	rep;
-    register int			n;
-
-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
-    pWin = LookupWindow (stuff->window, client);
-    if(!pWin)  return BadWindow;
-
-    rep.type = X_Reply;
-    rep.length = 0;
-    rep.sequenceNumber = client->sequence;
-    rep.width  = SiSXineramadataPtr[stuff->screen].width;
-    rep.height = SiSXineramadataPtr[stuff->screen].height;
-    if(client->swapped) {
-       swaps(&rep.sequenceNumber, n);
-       swapl(&rep.length, n);
-       swaps(&rep.width, n);
-       swaps(&rep.height, n);
-    }
-    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
-    return client->noClientException;
-}
+    DisplayModePtr tempmode;
 
-int
-SiSProcXineramaIsActive(ClientPtr client)
-{
-    xXineramaIsActiveReply	rep;
-
-    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
-
-    rep.type = X_Reply;
-    rep.length = 0;
-    rep.sequenceNumber = client->sequence;
-    rep.state = !SiSnoPanoramiXExtension;
-    if(client->swapped) {
-	register int n;
-	swaps(&rep.sequenceNumber, n);
-	swapl(&rep.length, n);
-	swapl(&rep.state, n);
-    }
-    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
-    return client->noClientException;
+    /* Make sure that the Private field is NULL */
+    /* (This way we don't have to care for MergedFB
+     * when freeing the mode; just check the Private
+     * and free it if its anything but NULL)
+     */
+    tempmode = modelist;
+    do {
+       tempmode->Private = NULL;
+       tempmode = tempmode->next;
+    } while(tempmode && (tempmode != modelist));
 }
 
-int
-SiSProcXineramaQueryScreens(ClientPtr client)
+/* Duplicate a mode (including name) */
+DisplayModePtr
+SiSDuplicateMode(DisplayModePtr source)
 {
-    xXineramaQueryScreensReply	rep;
-
-    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
-
-    rep.type = X_Reply;
-    rep.sequenceNumber = client->sequence;
-    rep.number = (SiSnoPanoramiXExtension) ? 0 : SiSXineramaNumScreens;
-    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
-    if(client->swapped) {
-       register int n;
-       swaps(&rep.sequenceNumber, n);
-       swapl(&rep.length, n);
-       swapl(&rep.number, n);
-    }
-    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);
-
-    if(!SiSnoPanoramiXExtension) {
-       xXineramaScreenInfo scratch;
-       int i;
+    DisplayModePtr dest = NULL;
 
-       for(i = 0; i < SiSXineramaNumScreens; i++) {
-	  scratch.x_org  = SiSXineramadataPtr[i].x;
-	  scratch.y_org  = SiSXineramadataPtr[i].y;
-	  scratch.width  = SiSXineramadataPtr[i].width;
-	  scratch.height = SiSXineramadataPtr[i].height;
-	  if(client->swapped) {
-	     register int n;
-	     swaps(&scratch.x_org, n);
-	     swaps(&scratch.y_org, n);
-	     swaps(&scratch.width, n);
-	     swaps(&scratch.height, n);
+    if(source) {
+       if((dest = xalloc(sizeof(DisplayModeRec)))) {
+	  memcpy(dest, source, sizeof(DisplayModeRec));
+	  dest->name = NULL;
+	  dest->next = dest->prev = NULL;
+	  if(!(dest->name = xalloc(strlen(source->name) + 1))) {
+	     xfree(dest);
+	     dest = NULL;
+	  } else {
+	     strcpy(dest->name, source->name);
 	  }
-	  WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
        }
     }
 
-    return client->noClientException;
-}
-
-static int
-SiSProcXineramaDispatch(ClientPtr client)
-{
-    REQUEST(xReq);
-    switch (stuff->data) {
-	case X_PanoramiXQueryVersion:
-	     return SiSProcXineramaQueryVersion(client);
-	case X_PanoramiXGetState:
-	     return SiSProcXineramaGetState(client);
-	case X_PanoramiXGetScreenCount:
-	     return SiSProcXineramaGetScreenCount(client);
-	case X_PanoramiXGetScreenSize:
-	     return SiSProcXineramaGetScreenSize(client);
-	case X_XineramaIsActive:
-	     return SiSProcXineramaIsActive(client);
-	case X_XineramaQueryScreens:
-	     return SiSProcXineramaQueryScreens(client);
-    }
-    return BadRequest;
-}
-
-/* SProc */
-
-static int
-SiSSProcXineramaQueryVersion (ClientPtr client)
-{
-    REQUEST(xPanoramiXQueryVersionReq);
-    register int n;
-    swaps(&stuff->length,n);
-    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
-    return SiSProcXineramaQueryVersion(client);
-}
-
-static int
-SiSSProcXineramaGetState(ClientPtr client)
-{
-    REQUEST(xPanoramiXGetStateReq);
-    register int n;
-    swaps (&stuff->length, n);
-    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
-    return SiSProcXineramaGetState(client);
-}
-
-static int
-SiSSProcXineramaGetScreenCount(ClientPtr client)
-{
-    REQUEST(xPanoramiXGetScreenCountReq);
-    register int n;
-    swaps (&stuff->length, n);
-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
-    return SiSProcXineramaGetScreenCount(client);
-}
-
-static int
-SiSSProcXineramaGetScreenSize(ClientPtr client)
-{
-    REQUEST(xPanoramiXGetScreenSizeReq);
-    register int n;
-    swaps (&stuff->length, n);
-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
-    return SiSProcXineramaGetScreenSize(client);
-}
-
-static int
-SiSSProcXineramaIsActive(ClientPtr client)
-{
-    REQUEST(xXineramaIsActiveReq);
-    register int n;
-    swaps (&stuff->length, n);
-    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
-    return SiSProcXineramaIsActive(client);
-}
-
-static int
-SiSSProcXineramaQueryScreens(ClientPtr client)
-{
-    REQUEST(xXineramaQueryScreensReq);
-    register int n;
-    swaps (&stuff->length, n);
-    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
-    return SiSProcXineramaQueryScreens(client);
+    return dest;
 }
 
-int
-SiSSProcXineramaDispatch(ClientPtr client)
-{
-    REQUEST(xReq);
-    switch (stuff->data) {
-	case X_PanoramiXQueryVersion:
-	     return SiSSProcXineramaQueryVersion(client);
-	case X_PanoramiXGetState:
-	     return SiSSProcXineramaGetState(client);
-	case X_PanoramiXGetScreenCount:
-	     return SiSSProcXineramaGetScreenCount(client);
-	case X_PanoramiXGetScreenSize:
-	     return SiSSProcXineramaGetScreenSize(client);
-	case X_XineramaIsActive:
-	     return SiSSProcXineramaIsActive(client);
-	case X_XineramaQueryScreens:
-	     return SiSSProcXineramaQueryScreens(client);
-    }
-    return BadRequest;
-}
-
-static void
-SiSXineramaResetProc(ExtensionEntry* extEntry)
-{
-    /* Called by CloseDownExtensions() */
-    if(SiSXineramadataPtr) {
-       Xfree(SiSXineramadataPtr);
-       SiSXineramadataPtr = NULL;
-    }
-}
 
-static void
-SiSXineramaExtensionInit(ScrnInfoPtr pScrn)
+static void 
+SiS6326AddHiresAndTVModes(ScrnInfoPtr pScrn)
 {
-    SISPtr	pSiS = SISPTR(pScrn);
-    Bool	success = FALSE;
-
-    if(!(SiSXineramadataPtr)) {
-
-       if(!pSiS->MergedFB) {
-	  SiSnoPanoramiXExtension = TRUE;
-	  pSiS->MouseRestrictions = FALSE;
-	  return;
-       }
-
-#ifdef PANORAMIX
-       if(!noPanoramiXExtension) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	     "Xinerama active, not initializing SiS Pseudo-Xinerama\n");
-	  SiSnoPanoramiXExtension = TRUE;
-	  pSiS->MouseRestrictions = FALSE;
-	  return;
-       }
-#endif
+    SISPtr pSiS = SISPTR(pScrn);
 
-       if(SiSnoPanoramiXExtension) {
+    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
+       if(pScrn->bitsPerPixel == 8) {
+	  SiS6326SIS1600x1200_60Mode.next = pScrn->monitor->Modes;
+	  pScrn->monitor->Modes = &SiS6326SIS1600x1200_60Mode;
 	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	      "SiS Pseudo-Xinerama disabled\n");
-	  pSiS->MouseRestrictions = FALSE;
-	  return;
+	  	"Adding mode \"SIS1600x1200-60\" (depth 8 only)\n");
        }
-
-       if(pSiS->CRT2Position == sisClone) {
+       if(pScrn->bitsPerPixel <= 16) {
+	  SiS6326SIS1280x1024_75Mode.next = pScrn->monitor->Modes;
+	  pScrn->monitor->Modes = &SiS6326SIS1280x1024_75Mode;
 	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	     "Running MergedFB in Clone mode, SiS Pseudo-Xinerama disabled\n");
-	  SiSnoPanoramiXExtension = TRUE;
-	  pSiS->MouseRestrictions = FALSE;
-	  return;
+	  	"Adding mode \"SIS1280x1024-75\" (depths 8, 15 and 16 only)\n");
        }
-
-       if(!(pSiS->AtLeastOneNonClone)) {
+       if((pSiS->SiS6326Flags & SIS6326_HASTV) &&
+	  (pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
 	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	     "Only Clone modes defined, SiS Pseudo-Xinerama disabled\n");
-	  SiSnoPanoramiXExtension = TRUE;
-	  pSiS->MouseRestrictions = FALSE;
-	  return;
+		"Adding %s TV modes to mode list:\n",
+		(pSiS->SiS6326Flags & SIS6326_TVPAL) ? "PAL" : "NTSC");
+	  if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
+	     SiS6326PAL800x600Mode.next = pScrn->monitor->Modes;
+	     pScrn->monitor->Modes = &SiS6326PAL640x480Mode;
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		"\t\"PAL800x600\" \"PAL800x600U\" \"PAL720x540\" \"PAL640x480\"\n");
+	  } else {
+	     SiS6326NTSC640x480Mode.next = pScrn->monitor->Modes;
+	     pScrn->monitor->Modes = &SiS6326NTSC640x400Mode;
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		"\t\"NTSC640x480\" \"NTSC640x480U\" \"NTSC640x400\"\n");
+	  }
        }
+    }
+}
 
-       SiSXineramaNumScreens = 2;
-
-       while(SiSXineramaGeneration != serverGeneration) {
-
-	  pSiS->XineramaExtEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
-					SiSProcXineramaDispatch,
-					SiSSProcXineramaDispatch,
-					SiSXineramaResetProc,
-					StandardMinorOpcode);
-
-	  if(!pSiS->XineramaExtEntry) break;
+/* Build a list of the VESA modes the BIOS reports as valid */
+static void
+SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    int i = 0;
 
-	  if(!(SiSXineramadataPtr = (SiSXineramaData *)
-	        xcalloc(SiSXineramaNumScreens, sizeof(SiSXineramaData)))) break;
+    while(vbe->VideoModePtr[i] != 0xffff) {
+       sisModeInfoPtr m;
+       VbeModeInfoBlock *mode;
+       int id = vbe->VideoModePtr[i++];
 
-	  SiSXineramaGeneration = serverGeneration;
-	  success = TRUE;
+       if((mode = VBEGetModeInfo(pVbe, id)) == NULL) {
+	  continue;
        }
 
-       if(!success) {
-	  SISErrorLog(pScrn, "Failed to initialize SiS Pseudo-Xinerama extension\n");
-	  SiSnoPanoramiXExtension = TRUE;
-	  pSiS->MouseRestrictions = FALSE;
-	  return;
+       m = xnfcalloc(sizeof(sisModeInfoRec), 1);
+       if(!m) {
+	  VBEFreeModeInfo(mode);
+	  continue;
        }
+       m->width = mode->XResolution;
+       m->height = mode->YResolution;
+       m->bpp = mode->BitsPerPixel;
+       m->n = id;
+       m->next = pSiS->SISVESAModeList;
 
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	  "SiS Pseudo-Xinerama extension initialized\n");
+       pSiS->SISVESAModeList = m;
 
-       pSiS->SiSXineramaVX = 0;
-       pSiS->SiSXineramaVY = 0;
+       VBEFreeModeInfo(mode);
 
+       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+	   "VESA BIOS supports mode number 0x%x: %ix%i (%i bpp)\n",
+	   m->n, m->width, m->height, m->bpp);
     }
-
-    SiSUpdateXineramaScreenInfo(pScrn);
-
 }
-#endif  /* End of PseudoXinerama */
 
-static void
-SiSFreeCRT2Structs(SISPtr pSiS)
-{
-    if(pSiS->CRT2pScrn) {
-       if(pSiS->CRT2pScrn->modes) {
-	  while(pSiS->CRT2pScrn->modes)
-	     xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
-       }
-       if(pSiS->CRT2pScrn->monitor) {
-	  if(pSiS->CRT2pScrn->monitor->Modes) {
-	     while(pSiS->CRT2pScrn->monitor->Modes)
-		xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
-	  }
-	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
-	  xfree(pSiS->CRT2pScrn->monitor);
-       }
-       xfree(pSiS->CRT2pScrn);
-       pSiS->CRT2pScrn = NULL;
-   }
-}
-
-#endif	/* End of MergedFB helpers */
-
-static xf86MonPtr
-SiSInternalDDC(ScrnInfoPtr pScrn, int crtno)
-{
-   SISPtr     pSiS = SISPTR(pScrn);
-   xf86MonPtr pMonitor = NULL;
-   UShort     temp = 0xffff, temp1, i, realcrtno = crtno;
-   UChar      buffer[256];
-
-   /* If CRT1 is off, skip DDC */
-   if((pSiS->CRT1off) && (!crtno)) return NULL;
-
-   if(crtno) {
-      if(pSiS->VBFlags & CRT2_LCD)      realcrtno = 1;
-      else if(pSiS->VBFlags & CRT2_VGA) realcrtno = 2;
-      else				return NULL;
-      if(pSiS->SiS_Pr->DDCPortMixup) realcrtno = 0;
-   } else {
-      /* If CRT1 is LCDA, skip DDC (except 301C: DDC allowed, but uses CRT2 port!) */
-      if(pSiS->VBFlags & CRT1_LCDA) {
-         if(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE) realcrtno = 1;
-         else return NULL;
-      }
-   }
-
-   i = 3; /* Number of retrys */
-   do {
-      temp1 = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine,
-			realcrtno, 0, &buffer[0], pSiS->VBFlags2);
-      if((temp1) && (temp1 != 0xffff)) temp = temp1;
-   } while((temp == 0xffff) && i--);
-   if(temp != 0xffff) {
-      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC supported\n", crtno + 1);
-      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC level: %s%s%s%s\n",
-	     crtno + 1,
-	     (temp & 0x1a) ? "" : "[none of the supported]",
-	     (temp & 0x02) ? "2 " : "",
-	     (temp & 0x08) ? "D&P" : "",
-             (temp & 0x10) ? "FPDI-2" : "");
-      if(temp & 0x02) {
-	 i = 5;  /* Number of retrys */
-	 do {
-	    temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine,
-				realcrtno, 1, &buffer[0], pSiS->VBFlags2);
-	 } while((temp) && i--);
-         if(!temp) {
-	    if((pMonitor = xf86InterpretEDID(pScrn->scrnIndex, &buffer[0]))) {
-	       int tempvgagamma = 0, templcdgamma = 0;
-	       if(buffer[0x14] & 0x80) {
-	          templcdgamma = (buffer[0x17] + 100) * 10;
-	       } else {
-	          tempvgagamma = (buffer[0x17] + 100) * 10;;
-	       }
-	       if(crtno == 0) {
-		  if(tempvgagamma) pSiS->CRT1VGAMonitorGamma = tempvgagamma;
-		  /* LCD never via (demanded) CRT1 DDC port */
-	       } else {
-	          if(tempvgagamma) pSiS->CRT2VGAMonitorGamma = tempvgagamma;
-	          if(templcdgamma) pSiS->CRT2LCDMonitorGamma = templcdgamma;
-	       }
-	       return(pMonitor);
-	    } else {
-	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-	           "CRT%d DDC EDID corrupt\n", crtno + 1);
-	    }
-	 } else if(temp == 0xFFFE) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-	    	"CRT%d DDC data is from wrong device type (%s)\n",
-			crtno + 1,
-			(realcrtno == 1) ? "analog instead of digital" : "digital instead of analog");
-	 } else {
-            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-	    	"CRT%d DDC reading failed\n", crtno + 1);
-	 }
-      } else if(temp & 0x18) {
-         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	      "DDC for VESA D&P and FPDI-2 not supported yet.\n");
-      }
-   } else {
-      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-                "CRT%d DDC probing failed\n", crtno + 1);
-   }
-   return(NULL);
-}
+/* Set up min and max pixelclock */
 
-static xf86MonPtr
-SiSDoPrivateDDC(ScrnInfoPtr pScrn, int *crtnum)
+static void
+SiSSetMinMaxPixelClock(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
+    MessageType from;
 
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiS->SecondHead) {
-          *crtnum = 1;
-	  return(SiSInternalDDC(pScrn, 0));
-       } else {
-          *crtnum = 2;
-	  return(SiSInternalDDC(pScrn, 1));
+    /* Set the min pixel clock */
+    pSiS->MinClock = 5000;
+    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
+       pSiS->MinClock = 10000;
+    }
+    xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock is %d MHz\n",
+                pSiS->MinClock / 1000);
+
+    /* If the user has specified ramdac speed in the config
+     * file, we respect that setting.
+     */
+    from = X_PROBED;
+    if(pSiS->pEnt->device->dacSpeeds[0]) {
+       int speed = 0;
+       switch(pScrn->bitsPerPixel) {
+       case 8:  speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP8];
+                break;
+       case 16: speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP16];
+                break;
+       case 24: speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP24];
+                break;
+       case 32: speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP32];
+                break;
        }
-    } else
-#endif
-    if((pSiS->CRT1off) || (!pSiS->CRT1Detected)) {
-       *crtnum = 2;
-       return(SiSInternalDDC(pScrn, 1));
-    } else {
-       *crtnum = 1;
-       return(SiSInternalDDC(pScrn, 0));
+       if(speed == 0) pSiS->MaxClock = pSiS->pEnt->device->dacSpeeds[0];
+       else           pSiS->MaxClock = speed;
+       from = X_CONFIG;
     }
+    xf86DrvMsg(pScrn->scrnIndex, from, "Max pixel clock is %d MHz\n",
+                pSiS->MaxClock / 1000);
 }
 
-static void
-SiSFindAspect(ScrnInfoPtr pScrn, xf86MonPtr pMonitor, int crtnum)
+/* Remove unsuitable modes not detected as such by
+ * xf86ValidModes, and find out maximum dotclock of
+ * all valid modes.
+ */
+
+#if defined(SISDUALHEAD) || defined(SISMERGED)
+int
+SiSRemoveUnsuitableModes(ScrnInfoPtr pScrn, DisplayModePtr initial, const char *reason, Bool quiet)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    int UseWide = 0;
-    int aspect = 0;
-    Bool fromdim = FALSE;
+    DisplayModePtr first, p, n;
+    int maxUsedClock = 0;
+    static const char *notsuitablestr = "Not using mode \"%s\" (not suitable for %s mode)\n";
 
-    if((pSiS->VGAEngine == SIS_315_VGA) && (!DIGITAL(pMonitor->features.input_type))) {
-       if(pMonitor->features.hsize && pMonitor->features.vsize) {
-	  aspect = (pMonitor->features.hsize * 1000) / pMonitor->features.vsize;
-	  if(aspect >= 1400) UseWide = 1;
-	  fromdim = TRUE;
-       } else if((PREFERRED_TIMING_MODE(pMonitor->features.msc)) &&
-		 (pMonitor->det_mon[0].type == DT)) {
-	  aspect = (pMonitor->det_mon[0].section.d_timings.h_active * 1000) /
-			pMonitor->det_mon[0].section.d_timings.v_active;
-	  if(aspect >= 1400) UseWide = 1;
-       }
-       if(aspect) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		"According to %s, CRT%d aspect ratio is %.2f:1 (%s)\n",
-		fromdim ? "DDC size" : "preferred mode",
-		crtnum, (float)aspect / 1000.0, UseWide ? "wide" : "normal");
-       } else {
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		"Unable to determine CRT%d aspect ratio, assuming \"normal\"\n",
-		crtnum);
-       }
-    }
+    if((p = first = initial)) {
 
-    if((crtnum == 1) && (pSiS->SiS_Pr->SiS_UseWide == -1)) {
-       pSiS->SiS_Pr->SiS_UseWide = UseWide;
-    } else if((crtnum == 2) && (pSiS->SiS_Pr->SiS_UseWideCRT2 == -1)) {
-       pSiS->SiS_Pr->SiS_UseWideCRT2 = UseWide;
-    }
-}
+       do {
 
-static Bool
-SiSMakeOwnModeList(ScrnInfoPtr pScrn, Bool acceptcustommodes, Bool includelcdmodes,
-                   Bool isfordvi, Bool *havecustommodes, Bool fakecrt2modes, Bool IsForCRT2)
-{
-    DisplayModePtr tempmode, delmode, mymodes;
+	  n = p->next;
 
-    if((mymodes = SiSBuildBuiltInModeList(pScrn, includelcdmodes, isfordvi, fakecrt2modes, IsForCRT2))) {
-       if(!acceptcustommodes) {
-	  while(pScrn->monitor->Modes)
-             xf86DeleteMode(&pScrn->monitor->Modes, pScrn->monitor->Modes);
-	  pScrn->monitor->Modes = mymodes;
-       } else {
-	  delmode = pScrn->monitor->Modes;
-	  while(delmode) {
-	     if(delmode->type & M_T_DEFAULT) {
-	        tempmode = delmode->next;
-	        xf86DeleteMode(&pScrn->monitor->Modes, delmode);
-	        delmode = tempmode;
-	     } else {
-	        delmode = delmode->next;
-	     }
-	  }
-	  /* Link default modes AFTER user ones */
-	  if((tempmode = pScrn->monitor->Modes)) {
-	     *havecustommodes = TRUE;
-	     while(tempmode) {
-	        if(!tempmode->next) break;
-	        else tempmode = tempmode->next;
+	  /* Modes that require the bridge to operate in SlaveMode
+	   * are not suitable for Dual Head and MergedFB mode.
+	   */
+	  if( (pSiS->VGAEngine == SIS_300_VGA) &&
+	      ((p->Flags & V_DBLSCAN) || (strcmp(p->name, "640x400") == 0)) )  {
+	     p->status = MODE_BAD;
+	     if(!quiet) {
+	        xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, reason);
 	     }
-	     tempmode->next = mymodes;
-	     mymodes->prev = tempmode;
-	  } else {
-	     pScrn->monitor->Modes = mymodes;
 	  }
-#if 0
-	  pScrn->monitor->Modes = mymodes;
-	  while(mymodes) {
-	     if(!mymodes->next) break;
-	     else mymodes = mymodes->next;
-	  }
-	  mymodes->next = tempmode;
-	  if(tempmode) {
-	     tempmode->prev = mymodes;
+
+	  /* Search for the highest clock on first head in order to calculate
+	   * max clock for second head (CRT1)
+	   */
+	  if((p->status == MODE_OK) && (p->Clock > maxUsedClock)) {
+	     maxUsedClock = p->Clock;
 	  }
-#endif
-       }
-       return TRUE;
-    } else
-       return FALSE;
+
+	  p = n;
+
+       } while (p != NULL && p != first);
+
+    }
+
+    return maxUsedClock;
 }
+#endif
 
-static void
-SiSPrintModes(ScrnInfoPtr pScrn)
+/* Print available modes */
+
+void
+SiSPrintModes(ScrnInfoPtr pScrn, Bool printfreq)
 {
     DisplayModePtr p;
     float hsync, refresh = 0.0;
     char *desc, *desc2, *prefix, *uprefix, *output;
 
-    xf86DrvMsg(pScrn->scrnIndex, pScrn->virtualFrom, "Virtual size is %dx%d "
-	       "(pitch %d)\n", pScrn->virtualX, pScrn->virtualY,
-	       pScrn->displayWidth);
+    xf86DrvMsg(pScrn->scrnIndex, pScrn->virtualFrom, "Virtual size is %dx%d (pitch %d)\n",
+	       pScrn->virtualX, pScrn->virtualY, pScrn->displayWidth);
 
     if((p = pScrn->modes) == NULL) return;
 
@@ -2870,7 +3085,7 @@ SiSPrintModes(ScrnInfoPtr pScrn)
 #ifdef M_T_USERDEF
 	if(p->type & M_T_USERDEF)  uprefix = "*";
 #endif
-	if(p->type & M_T_BUILTIN)       {
+	if(p->type & M_T_BUILTIN) {
 	   prefix = "Built-in mode";
 	   output = "";
 	} else if (p->type & M_T_DEFAULT) {
@@ -2879,22 +3094,30 @@ SiSPrintModes(ScrnInfoPtr pScrn)
 	   output = "";
 	}
 
-	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+	if(printfreq) {
+	   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 		"%s%s \"%s\" (%dx%d) (%s%.1f MHz, %.1f kHz, %.1f Hz%s%s)\n",
 		uprefix, prefix, p->name, p->HDisplay, p->VDisplay, output,
 		p->Clock / 1000.0, hsync, refresh, desc, desc2);
+	} else {
+	   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+		"%s%s \"%s\" (%dx%d)\n",
+		uprefix, prefix, p->name, p->HDisplay, p->VDisplay);
+	}
 
 	p = p->next;
     } while (p != NULL && p != pScrn->modes);
 }
 
+/* Find out if hw supports LCDA */
+
 Bool SISDetermineLCDACap(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
 
-    if( ((pSiS->ChipType == SIS_650)    ||
-         (pSiS->ChipType == SIS_315PRO) ||
-         (pSiS->ChipType >= SIS_661))		&&
+    if( ((pSiS->ChipType == SIS_315PRO) ||
+	 (pSiS->ChipType == SIS_650)    ||
+	 (pSiS->ChipType >= SIS_330))		&&
 	(pSiS->ChipType != XGI_20)		&&
         (pSiS->VBFlags2 & VB2_SISLCDABRIDGE)	&&
 	(pSiS->VESA != 1) ) {
@@ -2903,6 +3126,8 @@ Bool SISDetermineLCDACap(ScrnInfoPtr pScrn)
     return FALSE;
 }
 
+/* Store detected devices at a safe place */
+
 void SISSaveDetectedDevices(ScrnInfoPtr pScrn)
 {
     SISPtr  pSiS = SISPTR(pScrn);
@@ -2911,315 +3136,18 @@ void SISSaveDetectedDevices(ScrnInfoPtr pScrn)
                                                  TV_SCART|TV_HIVISION|TV_YPBPR);
 }
 
-static Bool
-SISCheckBIOS(SISPtr pSiS, UShort mypciid, UShort mypcivendor, int biossize)
-{
-    UShort romptr, pciid;
-
-    if(!pSiS->BIOS) return FALSE;
-
-    if((pSiS->BIOS[0] != 0x55) || (pSiS->BIOS[1] != 0xaa)) return FALSE;
-
-    romptr = pSiS->BIOS[0x18] | (pSiS->BIOS[0x19] << 8);
-    if(romptr > (biossize - 8)) return FALSE;
-    if((pSiS->BIOS[romptr]   != 'P') || (pSiS->BIOS[romptr+1] != 'C') ||
-       (pSiS->BIOS[romptr+2] != 'I') || (pSiS->BIOS[romptr+3] != 'R')) return FALSE;
-
-    pciid = pSiS->BIOS[romptr+4] | (pSiS->BIOS[romptr+5] << 8);
-    if(pciid != mypcivendor) return FALSE;
-
-    pciid = pSiS->BIOS[romptr+6] | (pSiS->BIOS[romptr+7] << 8);
-    if(pciid != mypciid) return FALSE;
-
-    return TRUE;
-}
-
-static void
-SiS_LoadInitVBE(ScrnInfoPtr pScrn)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-
-    /* Don't load the VBE module for secondary
-     * cards which sisfb POSTed. We don't want
-     * int10 to overwrite our set up (such as
-     * disabled a0000 memory address decoding).
-     * We don't need the VBE anyway because
-     * the card will never be in text mode,
-     * and we can restore graphics modes just
-     * perfectly.
-     */
-    if( !pSiS->Primary &&
-        pSiS->sisfbcardposted)
-       return;
-
-    if(pSiS->pVbe) return;
-
-    if(xf86LoadSubModule(pScrn, "vbe")) {
-       xf86LoaderReqSymLists(vbeSymbols, NULL);
-#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
-       pSiS->pVbe = VBEInit(pSiS->pInt, pSiS->pEnt->index);
-#else
-       pSiS->pVbe = VBEExtendedInit(pSiS->pInt, pSiS->pEnt->index,
-	                SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
-#endif
-    }
-
-    if(!pSiS->pVbe) {
-       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-	   "Failed to load/initialize vbe module\n");
-    }
-}
+/* Hooks for unsupported functions */
 
-#ifdef SIS_PC_PLATFORM
 static void
-SiS_MapVGAMem(ScrnInfoPtr pScrn)
+SiSPseudo(ScrnInfoPtr pScrn)
 {
-    SISPtr pSiS = SISPTR(pScrn);
-
-    /* Map 64k VGA window for saving/restoring CGA fonts */
-    pSiS->VGAMapSize = 0x10000;
-    pSiS->VGAMapPhys = 0;	/* Default */
-    if((!pSiS->Primary) || (!pSiS->VGADecodingEnabled)) {
-       /* If card is secondary or if a0000-address decoding
-        * is disabled, set Phys to beginning of our video RAM.
-	*/
-       pSiS->VGAMapPhys = pSiS->PciInfo->memBase[0];
-    }
-    if(!SiSVGAMapMem(pScrn)) {
-       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-	  "Failed to map VGA memory (0x%lx), can't save/restore console fonts\n",
-	  pSiS->VGAMapPhys);
-    }
 }
-#endif
-
-static void
-SiS_CheckKernelFB(ScrnInfoPtr pScrn)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    int        fd, i;
-    CARD32     sisfbinfosize = 0, sisfbversion;
-    sisfb_info *mysisfbinfo;
-    char       name[16];
-
-    pSiS->donttrustpdc = FALSE;
-    pSiS->sisfbpdc = 0xff;
-    pSiS->sisfbpdca = 0xff;
-    pSiS->sisfblcda = 0xff;
-    pSiS->sisfbscalelcd = -1;
-    pSiS->sisfbspecialtiming = CUT_NONE;
-    pSiS->sisfb_haveemi = FALSE;
-    pSiS->sisfbfound = FALSE;
-    pSiS->sisfb_tvposvalid = FALSE;
-    pSiS->sisfbdevname[0] = 0;
-    pSiS->sisfb_havelock = FALSE;
-    pSiS->sisfbHaveNewHeapDef = FALSE;
-    pSiS->sisfbHeapSize = 0;
-    pSiS->sisfbVideoOffset = 0;
-    pSiS->sisfbxSTN = FALSE;
-    pSiS->sisfbcanpost = FALSE;   /* (Old) sisfb can't POST card */
-    pSiS->sisfbcardposted = TRUE; /* If (old) sisfb is running, card must have been POSTed */
-    pSiS->sisfbprimary = FALSE;   /* (Old) sisfb doesn't know */
 
-    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
 
-       i = 0;
-       do {
+/**********************************************************/
+/*                       PreInit()                        */
+/**********************************************************/
 
-	  if(i <= 7) {
-             sprintf(name, "/dev/fb%1d", i);
-	  } else {
-	     sprintf(name, "/dev/fb/%1d", (i - 8));
-	  }
-
-          if((fd = open(name, 'r')) != -1) {
-
-	     Bool gotit = FALSE;
-
- 	     if(!ioctl(fd, SISFB_GET_INFO_SIZE, &sisfbinfosize)) {
- 		if((mysisfbinfo = xalloc(sisfbinfosize))) {
- 		   if(!ioctl(fd, (SISFB_GET_INFO | (sisfbinfosize << 16)), mysisfbinfo)) {
- 		      gotit = TRUE;
- 		   } else {
- 		      xfree(mysisfbinfo);
- 		      mysisfbinfo = NULL;
- 		   }
- 		}
- 	     } else {
- 		if((mysisfbinfo = xalloc(sizeof(*mysisfbinfo) + 16))) {
- 		   if(!ioctl(fd, SISFB_GET_INFO_OLD, mysisfbinfo)) {
- 		      gotit = TRUE;
-		      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				"Possibly old version of sisfb detected. Please update.\n");
-		   } else {
-		      xfree(mysisfbinfo);
-		      mysisfbinfo = NULL;
-		   }
-		}
-	     }
-
-	     if(gotit) {
-
-		if(mysisfbinfo->sisfb_id == SISFB_ID) {
-
-		   sisfbversion = (mysisfbinfo->sisfb_version << 16) |
-				  (mysisfbinfo->sisfb_revision << 8) |
-				  (mysisfbinfo->sisfb_patchlevel);
-
-	           if(sisfbversion >= SISFB_VERSION(1, 5, 8)) {
-		      /* Added PCI bus/slot/func into in sisfb Version 1.5.08.
-		       * Check this to make sure we run on the same card as sisfb
-		       */
-		      if((mysisfbinfo->sisfb_pcibus  == pSiS->PciBus)    &&
-			 (mysisfbinfo->sisfb_pcislot == pSiS->PciDevice) &&
-			 (mysisfbinfo->sisfb_pcifunc == pSiS->PciFunc)) {
-			 pSiS->sisfbfound = TRUE;
-		      }
-		   } else pSiS->sisfbfound = TRUE;
-
-		   if(pSiS->sisfbfound) {
-		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			     "%s: SiS kernel fb driver (sisfb) %d.%d.%d detected (PCI:%02d:%02d.%d)\n",
-				&name[5],
-				mysisfbinfo->sisfb_version,
-				mysisfbinfo->sisfb_revision,
-				mysisfbinfo->sisfb_patchlevel,
-				pSiS->PciBus,
-				pSiS->PciDevice,
-				pSiS->PciFunc);
-
-		      /* Added version/rev/pl in sisfb 1.4.0 */
-		      if(mysisfbinfo->sisfb_version == 0) {
-			 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-				"Old version of sisfb found. Please update.\n");
-		      }
-		      /* Basically, we can't trust the pdc register if sisfb is loaded */
-		      pSiS->donttrustpdc = TRUE;
-		      pSiS->sisfbHeapStart = mysisfbinfo->heapstart;
-
-		      if(sisfbversion >= SISFB_VERSION(1, 7, 20)) {
-			 pSiS->sisfbHeapSize = mysisfbinfo->sisfb_heapsize;
-			 pSiS->sisfbVideoOffset = mysisfbinfo->sisfb_videooffset;
-			 pSiS->sisfbHaveNewHeapDef = TRUE;
-			 pSiS->sisfbFSTN = mysisfbinfo->sisfb_curfstn;
-			 pSiS->sisfbDSTN = mysisfbinfo->sisfb_curdstn;
-			 pSiS->sisfbxSTN = TRUE;
-			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"sisfb: memory heap at %dKB, size %dKB, viewport at %dKB\n",
-				(int)pSiS->sisfbHeapStart, (int)pSiS->sisfbHeapSize,
-				(int)pSiS->sisfbVideoOffset/1024);
-		      } else {
-			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"sisfb: memory heap at %dKB\n", (int)pSiS->sisfbHeapStart);
-		      }
-		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"sisfb: using video mode 0x%02x\n", mysisfbinfo->fbvidmode);
-		      pSiS->OldMode = mysisfbinfo->fbvidmode;
-		      if(sisfbversion >= SISFB_VERSION(1, 5, 6)) {
-			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"sisfb: using %s, reserved %dK\n",
-				(mysisfbinfo->sisfb_caps & 0x40) ? "SiS300 series Turboqueue" :
-				   (mysisfbinfo->sisfb_caps & 0x20) ? "SiS315/330/340 series AGP command queue" :
-				      (mysisfbinfo->sisfb_caps & 0x10) ? "SiS315/330/340 series VRAM command queue" :
-					(mysisfbinfo->sisfb_caps & 0x08) ? "SiS315/330/340 series MMIO mode" :
-					   "no command queue",
-				(int)mysisfbinfo->sisfb_tqlen);
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 5, 10)) {
-			 /* We can trust the pdc value if sisfb is of recent version */
-			 if(pSiS->VGAEngine == SIS_300_VGA) pSiS->donttrustpdc = FALSE;
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 5, 11)) {
-			 if(pSiS->VGAEngine == SIS_300_VGA) {
-			    /* As of 1.5.11, sisfb saved the register for us (300 series) */
-			    pSiS->sisfbpdc = mysisfbinfo->sisfb_lcdpdc;
-			    if(!pSiS->sisfbpdc) pSiS->sisfbpdc = 0xff;
-			 }
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 5, 14)) {
-			 if(pSiS->VGAEngine == SIS_315_VGA) {
-			    pSiS->sisfblcda = mysisfbinfo->sisfb_lcda;
-			 }
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 6, 13)) {
-			 pSiS->sisfbscalelcd = mysisfbinfo->sisfb_scalelcd;
-			 pSiS->sisfbspecialtiming = mysisfbinfo->sisfb_specialtiming;
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 6, 16)) {
-			 if(pSiS->VGAEngine == SIS_315_VGA) {
-			    pSiS->donttrustpdc = FALSE;
-			    pSiS->sisfbpdc = mysisfbinfo->sisfb_lcdpdc;
-			    if(sisfbversion >= SISFB_VERSION(1, 6, 24)) {
-			       pSiS->sisfb_haveemi = mysisfbinfo->sisfb_haveemi ? TRUE : FALSE;
-			       pSiS->sisfb_haveemilcd = TRUE;  /* will match most cases */
-			       pSiS->sisfb_emi30 = mysisfbinfo->sisfb_emi30;
-			       pSiS->sisfb_emi31 = mysisfbinfo->sisfb_emi31;
-			       pSiS->sisfb_emi32 = mysisfbinfo->sisfb_emi32;
-			       pSiS->sisfb_emi33 = mysisfbinfo->sisfb_emi33;
-			    }
-			    if(sisfbversion >= SISFB_VERSION(1, 6, 25)) {
-			       pSiS->sisfb_haveemilcd = mysisfbinfo->sisfb_haveemilcd ? TRUE : FALSE;
-			    }
-			    if(sisfbversion >= SISFB_VERSION(1, 6, 31)) {
-			       pSiS->sisfbpdca = mysisfbinfo->sisfb_lcdpdca;
-			    } else {
-			       if(pSiS->sisfbpdc) {
-				  pSiS->sisfbpdca = (pSiS->sisfbpdc & 0xf0) >> 3;
-				  pSiS->sisfbpdc  = (pSiS->sisfbpdc & 0x0f) << 1;
-			       } else {
-				  pSiS->sisfbpdca = pSiS->sisfbpdc = 0xff;
-			       }
-			    }
-			 }
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 7, 0)) {
-		         pSiS->sisfb_havelock = TRUE;
-			 if(sisfbversion >= SISFB_VERSION(1, 7, 1)) {
-			    pSiS->sisfb_tvxpos = mysisfbinfo->sisfb_tvxpos;
-			    pSiS->sisfb_tvypos = mysisfbinfo->sisfb_tvypos;
-			    pSiS->sisfb_tvposvalid = TRUE;
-			 }
-		      }
-		      if(sisfbversion >= SISFB_VERSION(1, 8, 7)) {
-			 pSiS->sisfbcanpost = (mysisfbinfo->sisfb_can_post) ? TRUE : FALSE;
-			 pSiS->sisfbcardposted = (mysisfbinfo->sisfb_card_posted) ? TRUE : FALSE;
-			 pSiS->sisfbprimary = (mysisfbinfo->sisfb_was_boot_device) ? TRUE : FALSE;
-			 /* Validity check */
-			 if(!pSiS->sisfbcardposted) {
-			    pSiS->sisfbprimary = FALSE;
-			 }
-		      }
-		   }
-	        }
-		xfree(mysisfbinfo);
-		mysisfbinfo = NULL;
-	     }
-	     close (fd);
-          }
-	  i++;
-       } while((i <= 15) && (!pSiS->sisfbfound));
-
-       if(pSiS->sisfbfound) {
-          strncpy(pSiS->sisfbdevname, name, 15);
-       } else {
-          xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "sisfb not found\n");
-       }
-    }
-
-    if(!pSiS->sisfbfound) {
-       pSiS->sisfbcardposted = FALSE;
-    }
-}
-
-static void
-SiSPseudo(ScrnInfoPtr pScrn)
-{
-}
-
-/* PreInit()
- *
- * Mandatory
- */
 static Bool
 SISPreInit(ScrnInfoPtr pScrn, int flags)
 {
@@ -3233,32 +3161,14 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     unsigned int i;
     int pix24flags, temp;
     ClockRangePtr clockRanges;
-    xf86MonPtr pMonitor = NULL;
-    Bool didddc2, fromDDC, crt1freqoverruled = FALSE;
+    Bool crt1freqoverruled = FALSE;
     UChar CR5F, tempreg;
-#if defined(SISMERGED) || defined(SISDUALHEAD)
-    DisplayModePtr first, p, n;
-#endif
-#ifdef SISMERGED
-    Bool crt2freqoverruled = FALSE;
-#endif
-
-    static const char *ddcsstr = "CRT%d DDC monitor info: *******************************************\n";
-    static const char *ddcestr = "End of CRT%d DDC monitor info *************************************\n";
-    static const char *subshstr = "Substituting missing CRT%d monitor HSync range by DDC data\n";
-    static const char *subsvstr = "Substituting missing CRT%d monitor VRefresh range by DDC data\n";
-    static const char *saneh = "Correcting %s CRT%d monitor HSync range\n";
-    static const char *sanev = "Correcting %s CRT%d monitor VRefresh range\n";
 #ifdef SISMERGED
     static const char *mergednocrt1 = "CRT1 not detected or forced off. %s.\n";
     static const char *mergednocrt2 = "No CRT2 output selected or no video bridge detected. %s.\n";
     static const char *mergeddisstr = "MergedFB mode disabled";
     static const char *modesforstr = "Modes for CRT%d: **************************************************\n";
     static const char *crtsetupstr = "*************************** CRT%d setup ***************************\n";
-    static const char *crt2monname = "CRT2";
-#endif
-#if defined(SISDUALHEAD) || defined(SISMERGED)
-    static const char *notsuitablestr = "Not using mode \"%s\" (not suitable for %s mode)\n";
 #endif
 
     if(flags & PROBE_DETECT) {
@@ -3282,10 +3192,10 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 
     /*
      * Note: This function is only called once at server startup, and
-     * not at the start of each server generation.  This means that
+     * not at the start of each server generation. This means that
      * only things that are persistent across server generations can
-     * be initialised here.  xf86Screens[] is the array of all screens,
-     * (pScrn is a pointer to one of these).  Privates allocated using
+     * be initialised here. xf86Screens[] is the array of all screens,
+     * (pScrn is a pointer to one of these). Privates allocated using
      * xf86AllocateScrnInfoPrivateIndex() are too, and should be used
      * for data that must persist across server generations.
      *
@@ -3298,47 +3208,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        SISErrorLog(pScrn, "Number of entities is not 1\n");
        return FALSE;
     }
-
-    /* Due to the liberal license terms this is needed for
-     * keeping the copyright notice readable and intact in
-     * binary distributions. Removing this is a copyright
-     * infringement. Please read the license terms above.
-     */
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	"SiS driver (%d/%02d/%02d-%d, compiled for " SISMYSERVERNAME " %d.%d.%d.%d)\n",
-	SISDRIVERVERSIONYEAR + 2000, SISDRIVERVERSIONMONTH,
-	SISDRIVERVERSIONDAY, SISDRIVERREVISION,
-#ifdef XORG_VERSION_CURRENT
-	XORG_VERSION_MAJOR, XORG_VERSION_MINOR,
-	XORG_VERSION_PATCH, XORG_VERSION_SNAP
-#else
-	XF86_VERSION_MAJOR, XF86_VERSION_MINOR,
-	XF86_VERSION_PATCH, XF86_VERSION_SNAP
-#endif
-	);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	"Copyright (C) 2001-2005 Thomas Winischhofer <thomas@winischhofer.net> and others\n");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	"*** See http://www.winischhofer.at/linuxsisvga.shtml\n");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	"*** for documentation and updates.\n");
-
-#ifdef XORG_VERSION_CURRENT
-#if 0  /* no prototype yet */
-    if(xorgGetVersion() != XORG_VERSION_CURRENT) {
-       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-         "This driver binary is not compiled for this version of " SISMYSERVERNAME "\n");
-    }
-#endif
-#else
-#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
-    if(xf86GetVersion() != XF86_VERSION_CURRENT) {
-       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-         "This driver binary is not compiled for this version of " SISMYSERVERNAME "\n");
-    }
-#endif
-#endif
+    /* Print copyright, driver version */
+    SiSPrintLogHeader(pScrn);
 
     /* Allocate the SISRec driverPrivate */
     if(!SISGetRec(pScrn)) {
@@ -3363,7 +3234,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        SISErrorLog(pScrn, "Entity's bus type is not PCI\n");
        goto my_error_0;
     }
-
 #ifdef SISDUALHEAD
     /* Allocate an entity private if necessary */
     if(xf86IsEntityShared(pScrn->entityList[0])) {
@@ -3380,10 +3250,12 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 
     /* Find the PCI info for this screen */
     pSiS->PciInfo = xf86GetPciInfoForEntity(pSiS->pEnt->index);
-    pSiS->PciBus = ((pciConfigPtr)pSiS->PciInfo->thisCard)->busnum;    /*SIS_PCI_BUS(pSiS->PciInfo);*/
-    pSiS->PciDevice = ((pciConfigPtr)pSiS->PciInfo->thisCard)->devnum; /*SIS_PCI_DEVICE(pSiS->PciInfo);*/
-    pSiS->PciFunc = ((pciConfigPtr)pSiS->PciInfo->thisCard)->funcnum;  /*SIS_PCI_FUNC(pSiS->PciInfo);*/
-    pSiS->PciTag = ((pciConfigPtr)pSiS->PciInfo->thisCard)->tag;       /*SIS_PCI_TAG(pSiS->PciInfo);*/
+    pSiS->PciBus = PCI_CFG_BUS(pSiS->PciInfo);    
+    pSiS->PciDevice = PCI_CFG_DEV(pSiS->PciInfo); 
+    pSiS->PciFunc = PCI_CFG_FUNC(pSiS->PciInfo); 
+    pSiS->PciTag = pciTag(	PCI_DEV_BUS(pSiS->PciInfo), 
+							PCI_DEV_DEV(pSiS->PciInfo),
+							PCI_DEV_FUNC(pSiS->PciInfo));
 
 #ifdef SIS_NEED_MAP_IOP
     /********************************************/
@@ -3433,7 +3305,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     {
        SymTabRec *myChipsets = SISChipsets;
 
-       if(pSiS->PciInfo->vendor == PCI_VENDOR_XGI) {
+       if(PCI_DEV_VENDOR_ID(pSiS->PciInfo) == PCI_VENDOR_XGI) {
           myChipsets = XGIChipsets;
        }
 
@@ -3451,7 +3323,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 								pSiS->Chipset);
        } else {
 
-          pSiS->Chipset = pSiS->PciInfo->chipType;
+          pSiS->Chipset = PCI_DEV_DEVICE_ID(pSiS->PciInfo);
           pScrn->chipset = (char *)xf86TokenToString(myChipsets, pSiS->Chipset);
 
        }
@@ -3464,7 +3336,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 								pSiS->ChipRev);
     } else {
 
-       pSiS->ChipRev = pSiS->PciInfo->chipRev;
+       pSiS->ChipRev = PCI_DEV_REVISION(pSiS->PciInfo);
 
     }
 
@@ -3496,10 +3368,12 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        case PCI_CHIP_SIS550:
        case PCI_CHIP_SIS650: /* 650 + 740 */
        case PCI_CHIP_SIS330:
-       case PCI_CHIP_SIS660: /* 660, 661, 741, 760, 761, 670(?), 770 */
+       case PCI_CHIP_SIS660: /* 660, 661, 741, 760, 761 */
        case PCI_CHIP_SIS340:
        case PCI_CHIP_XGIXG20:
        case PCI_CHIP_XGIXG40:
+       case PCI_CHIP_SIS670: /* 670, 770 */
+	case PCI_CHIP_SIS671: /* 670, 770 */
           pSiS->VGAEngine = SIS_315_VGA;
 	  break;
        case PCI_CHIP_SIS530:
@@ -3558,7 +3432,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
      */
     SiS_CheckKernelFB(pScrn);
 
-    /* Now for that primary/secondary mess: Linux kernel
+    /* Now again for that primary/secondary mess: Linux kernel
      * 2.6.12 and later knows what card is primary, and so
      * does any recent version of sisfb. XFree86/X.org takes
      * all adapters as "secondary" if more than one card's
@@ -3648,7 +3522,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
      * by the BIOS. So we can pretty much rely on that these
      * are enabled.
      */
-    pSiS->RelIO = (SISIOADDRESS)(pSiS->PciInfo->ioBase[2] + pSiS->IODBase);
+    pSiS->RelIO = (SISIOADDRESS) (PCI_REGION_BASE(pSiS->PciInfo, 2, REGION_IO) + pSiS->IODBase);
+
     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Relocated I/O registers at 0x%lX\n",
            (ULong)pSiS->RelIO);
 
@@ -3671,6 +3546,13 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        if(tempreg & 0x04) pSiS->VGADecodingEnabled = FALSE;
        break;
     }
+    /*debug information insert here for watching MISCW reg value before 2d driver start on X.*/
+    #ifdef TWDEBUG
+     unsigned char uc = inSISREG(SISMISCR);
+      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,"[SISPreInit()]:VGA_MISCR = 0x%x\n",uc);
+      uc = inSISREG(SISMISCW);
+      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,"[SISPreInit()]:VGA_MISCW = 0x%x\n",uc);
+    #endif
 
     if(!pSiS->VGADecodingEnabled) {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
@@ -3720,7 +3602,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        SISErrorLog(pScrn, "Could not load ramdac module\n");
        goto my_error_1;
     }
-
     xf86LoaderReqSymLists(ramdacSymbols, NULL);
 
     /* Set pScrn->monitor */
@@ -3742,12 +3623,14 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     pSiS->SyncAccel = SiSPseudo;
     pSiS->FillRect  = NULL;
     pSiS->BlitRect  = NULL;
+    pSiS->ForceCursorOff = FALSE;
 
     /* Always do a ValidMode() inside Switchmode() */
     pSiS->skipswitchcheck = FALSE;
 
     /* Determine chipset and its capabilities in detail */
     pSiS->ChipFlags = 0;
+    pSiS->EngineType3D = 0;
     pSiS->SiS_SD_Flags = pSiS->SiS_SD2_Flags = 0;
     pSiS->SiS_SD3_Flags = pSiS->SiS_SD4_Flags = 0;
     pSiS->HWCursorMBufNum = pSiS->HWCursorCBufNum = 0;
@@ -3762,6 +3645,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        case PCI_CHIP_SIS300:
 	  pSiS->ChipType = SIS_300;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
+	  pSiS->ChipFlags |= SiSCF_NoCurHide;
 	  break;
        case PCI_CHIP_SIS540:
 	  pSiS->ChipType = SIS_540;
@@ -3773,10 +3657,12 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	     pSiS->ChipType = SIS_730;
 	  }
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
+	  pSiS->ChipFlags |= SiSCF_NoCurHide;
 	  break;
        case PCI_CHIP_SIS315H:
 	  pSiS->ChipType = SIS_315H;
-	  pSiS->ChipFlags |= (SiSCF_315Core | SiSCF_MMIOPalette);
+	  pSiS->ChipFlags |= SiSCF_MMIOPalette;
+	  pSiS->EngineType3D |= SiS3D_315Core;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	  pSiS->myCR63 = 0x63;
@@ -3785,7 +3671,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	  /* Override for simplicity */
 	  pSiS->Chipset = PCI_CHIP_SIS315H;
 	  pSiS->ChipType = SIS_315;
-	  pSiS->ChipFlags |= (SiSCF_315Core | SiSCF_MMIOPalette);
+	  pSiS->ChipFlags |= SiSCF_MMIOPalette;
+	  pSiS->EngineType3D |= SiS3D_315Core;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	  pSiS->myCR63 = 0x63;
@@ -3794,7 +3681,9 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	  /* Override for simplicity */
 	  pSiS->Chipset = PCI_CHIP_SIS315H;
 	  pSiS->ChipType = SIS_315PRO;
-	  pSiS->ChipFlags |= (SiSCF_315Core | SiSCF_MMIOPalette);
+	  pSiS->ChipFlags |= (	SiSCF_MMIOPalette	|
+				SiSCF_NoCurHide );
+	  pSiS->EngineType3D |= SiS3D_315Core;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	  pSiS->myCR63 = 0x63;
@@ -3811,55 +3700,59 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	  if(pciReadLong(0x00000000, 0x00) == 0x07401039) {
 	     pSiS->ChipType = SIS_740;
 	  }
-	  pSiS->ChipFlags |= (SiSCF_Integrated | SiSCF_Real256ECore | SiSCF_MMIOPalette);
+	  pSiS->ChipFlags |= (	SiSCF_Integrated	|
+				SiSCF_MMIOPalette	|
+				SiSCF_NoCurHide );
+	  pSiS->EngineType3D |= SiS3D_Real256ECore;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	  pSiS->myCR63 = 0x63;
 	  break;
        case PCI_CHIP_SIS330:
 	  pSiS->ChipType = SIS_330;
-	  pSiS->ChipFlags |= (SiSCF_XabreCore | SiSCF_MMIOPalette);
+	  pSiS->ChipFlags |= (	SiSCF_MMIOPalette	|
+				SiSCF_HaveStrBB		|
+				SiSCF_NoCurHide		|
+				SiSCF_CRT2HWCKaputt );
+	  pSiS->EngineType3D |= SiS3D_XabreCore;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	  pSiS->SiS_SD3_Flags |= SiS_SD3_CRT1SATGAIN; /* FIXME ? */
 	  pSiS->myCR63 = 0x53; /* sic! */
 	  break;
-       case PCI_CHIP_SIS660: /* 660, 661, 741, 760, 761, 670(?) */
-	  {
+       case PCI_CHIP_SIS660: /* 660, 661, 741, 760, 761, 662*/
+	  {	  	
 	     ULong hpciid = pciReadLong(0x00000000, 0x00);
 	     switch(hpciid) {
 	     case 0x06601039:
 		pSiS->ChipType = SIS_660;
-		pSiS->ChipFlags |= SiSCF_Ultra256Core;
-		pSiS->NeedFlush = TRUE;
+		pSiS->EngineType3D |= SiS3D_Ultra256Core;
 		break;
 	     case 0x07601039:
 		pSiS->ChipType = SIS_760;
-		pSiS->ChipFlags |= SiSCF_Ultra256Core;
+		pSiS->EngineType3D |= SiS3D_Ultra256Core;
 		pSiS->NeedFlush = TRUE;
 		break;
 	     case 0x07611039:
 		pSiS->ChipType = SIS_761;
-		pSiS->ChipFlags |= SiSCF_Ultra256Core;
-		pSiS->NeedFlush = TRUE;
-		break;
-	     case 0x07701039:
-		pSiS->ChipType = SIS_770;
-		pSiS->ChipFlags |= SiSCF_Ultra256Core;
+		pSiS->EngineType3D |= SiS3D_Mirage1;
 		pSiS->NeedFlush = TRUE;
+		pSiS->ChipFlags |= SiSCF_DualPipe; /* ? */
 		break;
 	     case 0x07411039:
 		pSiS->ChipType = SIS_741;
-		pSiS->ChipFlags |= SiSCF_Real256ECore;
+		pSiS->EngineType3D |= SiS3D_Real256ECore;
+		break;
+	     case 0x06621039:
+		pSiS->ChipType = SIS_662;
+		pSiS->EngineType3D |= SiS3D_Real256ECore;
 		break;
 	     case 0x06611039:
 	     default:
 		pSiS->ChipType = SIS_661;
-		pSiS->ChipFlags |= SiSCF_Real256ECore;
+		pSiS->EngineType3D |= SiS3D_Real256ECore;
 		break;
-	     case 0x06701039:
-		pSiS->ChipType = SIS_670;
-		pSiS->ChipFlags |= SiSCF_Real256ECore;
+
 	     }
 	     /* Detection could also be done by CR5C & 0xf8:
 	      * 0x10 = 661 (CR5F & 0xc0: 0x00 both A0 and A1)
@@ -3867,7 +3760,10 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	      * 0x90 = 741 (CR5F & 0xc0: 0x00 A0,A1 0x40 A2)
 	      * other: 660 (CR5F & 0xc0: 0x00 A0 0x40 A1) (DOA?)
 	      */
-	     pSiS->ChipFlags |= (SiSCF_Integrated | SiSCF_MMIOPalette);
+	     pSiS->ChipFlags |= ( SiSCF_Integrated	|
+				  SiSCF_MMIOPalette	|
+				  SiSCF_HaveStrBB	|
+				  SiSCF_NoCurHide );
 	     pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
 	     pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	     pSiS->SiS_SD3_Flags |= SiS_SD3_CRT1SATGAIN;
@@ -3877,63 +3773,255 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	  break;
        case PCI_CHIP_SIS340:
 	  pSiS->ChipType = SIS_340;
-	  pSiS->ChipFlags |= (SiSCF_XabreCore | SiSCF_MMIOPalette);
+	  pSiS->ChipFlags |= (	SiSCF_MMIOPalette	|
+				SiSCF_HaveStrBB		|
+				SiSCF_NoCurHide		|
+				SiSCF_DualPipe );
+	  pSiS->EngineType3D |= SiS3D_Mirage1;
 	  pSiS->SiS_SD_Flags |= SiS_SD_IS340SERIES;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
 	  pSiS->SiS_SD3_Flags |= SiS_SD3_CRT1SATGAIN;
 	  pSiS->myCR63 = 0x53;
 	  pSiS->NewCRLayout = TRUE;
 	  break;
+       case PCI_CHIP_SIS670: /* 670, 770 */
+	  {
+	     ULong hpciid = pciReadLong(0x00000000, 0x00);
+	     switch(hpciid) {
+	     case 0x06701039:
+		pSiS->ChipType = SIS_670;
+		break;
+	     case 0x07701039:
+	     default:
+		pSiS->ChipType = SIS_770;
+		/* TODO: 772? */
+		/* if() pSiS->ChipType = SIS_772; */
+		pSiS->NeedFlush = TRUE;
+		break;
+	     }
+	     pSiS->ChipFlags |= ( SiSCF_Integrated	|
+				  SiSCF_MMIOPalette	|
+				  SiSCF_HaveStrBB	|
+				  SiSCF_NoCurHide);
+	     pSiS->EngineType3D |= SiS3D_Mirage3;
+	     pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
+	     pSiS->SiS_SD3_Flags |= (SiS_SD3_IS350SERIES | SiS_SD3_CRT1SATGAIN);
+	     pSiS->myCR63 = 0x53; /* sic! */
+	     pSiS->NewCRLayout = TRUE;
+	  }
+	  break;
+	case PCI_CHIP_SIS671:
+	{	     
+		pSiS->ChipType = SIS_671;	     
+		pSiS->ChipFlags |= ( SiSCF_Integrated	|	
+					SiSCF_MMIOPalette	|	
+					SiSCF_HaveStrBB	|
+					SiSCF_NoCurHide);
+		pSiS->EngineType3D |= SiS3D_Mirage3;
+		pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORTXVHUESAT;
+		pSiS->SiS_SD3_Flags |= (SiS_SD3_IS350SERIES | SiS_SD3_CRT1SATGAIN);
+		pSiS->myCR63 = 0x53; /* sic! */
+		pSiS->NewCRLayout = TRUE;
+		}
+	break;
+	
        case PCI_CHIP_XGIXG20:
 	  pSiS->ChipType = XGI_20;
-	  pSiS->ChipFlags |= (SiSCF_XabreCore | SiSCF_MMIOPalette | SiSCF_IsXGI);
+	  pSiS->ChipFlags |= (	SiSCF_MMIOPalette	|
+				SiSCF_IsXGI		|
+				SiSCF_NoCurHide );
 	  pSiS->SiS_SD2_Flags |= (SiS_SD2_NOOVERLAY | SiS_SD2_ISXGI);
 	  pSiS->myCR63 = 0x53;
 	  pSiS->NewCRLayout = TRUE;
 	  break;
-       case PCI_CHIP_XGIXG40:
+	case PCI_CHIP_XGIXG40:
 	  pSiS->ChipType = XGI_40;
-	  pSiS->ChipFlags |= (SiSCF_XabreCore | SiSCF_MMIOPalette | SiSCF_IsXGI);
+	  pSiS->ChipFlags |= (	SiSCF_MMIOPalette	|
+				SiSCF_IsXGI		|
+				SiSCF_HaveStrBB		|
+				SiSCF_NoCurHide		|
+				SiSCF_DualPipe );
 	  pSiS->SiS_SD2_Flags |= (SiS_SD2_SUPPORTXVHUESAT | SiS_SD2_ISXGI);
 	  pSiS->SiS_SD3_Flags |= SiS_SD3_CRT1SATGAIN;
 	  pSiS->myCR63 = 0x53;
 	  pSiS->NewCRLayout = TRUE;
-	  if(pSiS->ChipRev == 2) pSiS->ChipFlags |= SiSCF_IsXGIV3;
+	  if(pSiS->ChipRev == 2) {
+	     pSiS->ChipFlags |= SiSCF_IsXGIV3;
+	     pSiS->EngineType3D |= SiS3D_XG42Core;
+	  } else
+	     pSiS->EngineType3D |= SiS3D_XG40Core;
 	  break;
        default:
 	  pSiS->ChipType = SIS_OLD;
 	  break;
     }
 
-    /*
-     * Now back to real business: Figure out the depth, bpp, etc.
-     * Set SupportConvert... flags since we use the fb layer which
-     * supports this conversion. (24to32 seems not implemented though)
-     * Additionally, determine the size of the HWCursor memory area.
+    /* The following identifies the old chipsets. This is only
+     * partly used since the really old chips are not supported,
+     * but I keep it here for future use.
+     * 205, 215 and 225 are to be treated the same way, 201 and 202
+     * are different.
      */
-    switch(pSiS->VGAEngine) {
-       case SIS_300_VGA:
-	  pSiS->CursorSize = 4096;
-	  pix24flags = Support32bppFb;
+    if(pSiS->VGAEngine == SIS_OLD_VGA || pSiS->VGAEngine == SIS_530_VGA) {
+       switch(pSiS->Chipset) {
+       case PCI_CHIP_SG86C201:
+	  pSiS->oldChipset = OC_SIS86201; break;
+       case PCI_CHIP_SG86C202:
+	  pSiS->oldChipset = OC_SIS86202; break;
+       case PCI_CHIP_SG86C205:
+	  inSISIDXREG(SISSR, 0x10, tempreg);
+	  if(tempreg & 0x80) pSiS->oldChipset = OC_SIS6205B;
+	  else pSiS->oldChipset = (pSiS->ChipRev == 0x11) ?
+					OC_SIS6205C : OC_SIS6205A;
 	  break;
-       case SIS_315_VGA:
-	  pSiS->CursorSize = 16384;
-	  pix24flags = Support32bppFb;
+       case PCI_CHIP_SIS82C204:
+	  pSiS->oldChipset = OC_SIS82204; break;
+       case 0x6225:
+	  pSiS->oldChipset = OC_SIS6225; break;
+       case PCI_CHIP_SIS5597:
+	  pSiS->oldChipset = OC_SIS5597; break;
+       case PCI_CHIP_SIS6326:
+	  pSiS->oldChipset = OC_SIS6326; break;
+       case PCI_CHIP_SIS530:
+	  if(pciReadLong(0x00000000, 0x00) == 0x06201039) {
+	     pSiS->oldChipset = OC_SIS620;
+	  } else {
+	     if((pSiS->ChipRev & 0x0f) < 0x0a)
+		   pSiS->oldChipset = OC_SIS530A;
+	     else  pSiS->oldChipset = OC_SIS530B;
+	  }
 	  break;
-       case SIS_530_VGA:
-	  pSiS->CursorSize = 2048;
-	  pix24flags = Support32bppFb	  |
-		       Support24bppFb	  |
-		       SupportConvert32to24;
-          break;
        default:
-	  pSiS->CursorSize = 2048;
-	  pix24flags = Support24bppFb	    |
-		       SupportConvert32to24 |
-		       PreferConvert32to24;
-	  break;
+	  pSiS->oldChipset = OC_UNKNOWN;
+       }
     }
 
+    /* Further hardware determination:
+     * - Sub-classes of chipsets
+     * - one or two video overlays
+     */
+    pSiS->hasTwoOverlays = FALSE;
+    switch(pSiS->Chipset) {
+       case PCI_CHIP_SIS300:
+       case PCI_CHIP_SIS540:  /* ? (If not, need to add the SwitchCRT Xv attribute!) */
+       case PCI_CHIP_SIS630:
+       case PCI_CHIP_SIS550:
+	  pSiS->hasTwoOverlays = TRUE;
+	  pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
+	  break;
+       case PCI_CHIP_SIS315PRO:
+       case PCI_CHIP_SIS330:
+       case PCI_CHIP_SIS340:
+       case PCI_CHIP_XGIXG40:
+	  break;
+       case PCI_CHIP_SIS650:
+	  {
+	     UChar tempreg1, tempreg2;
+	     static const char *id650str[] = {
+		"650",       "650",       "650",       "650",
+		"650 A0 AA", "650 A2 CA", "650",       "650",
+		"M650 A0",   "M650 A1 AA","651 A0 AA", "651 A1 AA",
+		"M650",      "65?",       "651",       "65?"
+	     };
+	     if(pSiS->ChipType == SIS_650) {
+		inSISIDXREG(SISCR, 0x5f, CR5F);
+		CR5F &= 0xf0;
+		andSISIDXREG(SISCR, 0x5c, 0x07);
+		inSISIDXREG(SISCR, 0x5c, tempreg1);
+		tempreg1 &= 0xf8;
+		orSISIDXREG(SISCR, 0x5c, 0xf8);
+		inSISIDXREG(SISCR, 0x5c, tempreg2);
+		tempreg2 &= 0xf8;
+		if((!tempreg1) || (tempreg2)) {
+		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		      "SiS650 revision ID %x (%s)\n", CR5F, id650str[CR5F >> 4]);
+		   if(CR5F & 0x80) {
+		      pSiS->hasTwoOverlays = TRUE;  /* M650 or 651 */
+		      pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
+		   }
+		   switch(CR5F) {
+		      case 0xa0:
+		      case 0xb0:
+		      case 0xe0:
+		         pSiS->ChipFlags |= SiSCF_Is651;
+		         break;
+		      case 0x80:
+		      case 0x90:
+		      case 0xc0:
+		         pSiS->ChipFlags |= SiSCF_IsM650;
+		         break;
+		   }
+		} else {
+		   pSiS->hasTwoOverlays = TRUE;
+		   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
+		   switch(CR5F) {
+		      case 0x90:
+			 inSISIDXREG(SISCR, 0x5c, tempreg1);
+			 tempreg1 &= 0xf8;
+			 switch(tempreg1) {
+			    case 0x00:
+			       pSiS->ChipFlags |= SiSCF_IsM652;
+			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			           "SiSM652 revision ID %x\n", CR5F);
+			       break;
+			    case 0x40:
+			       pSiS->ChipFlags |= SiSCF_IsM653;
+			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			           "SiSM653 revision ID %x\n", CR5F);
+			       break;
+			    default:
+			       pSiS->ChipFlags |= SiSCF_IsM650;
+			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			           "SiSM650 revision ID %x\n", CR5F);
+			       break;
+			 }
+			 break;
+		      case 0xb0:
+			 pSiS->ChipFlags |= SiSCF_Is652;
+			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			     "SiS652 revision ID %x\n", CR5F);
+			 break;
+		      default:
+			 pSiS->ChipFlags |= SiSCF_IsM650;
+			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			     "SiSM650 revision ID %x\n", CR5F);
+			 break;
+		   }
+		}
+
+		if(pSiS->ChipFlags & SiSCF_Is65x) {
+		   pSiS->ChipFlags |= SiSCF_HaveStrBB;
+		}
+	     }
+	  }
+	  break;
+       case PCI_CHIP_SIS660:
+	  {
+	     /* TODO: Find out about 761/A0, 761/A1 */
+	     /* if() pSiS->ChipFlags |= SiSCF_761A0; */
+	     if(pSiS->ChipType != SIS_761 && pSiS->ChipType != SIS_662) {
+	        pSiS->hasTwoOverlays = TRUE;
+	        pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
+	     }
+	     /* 760:      - UMA only: one/two overlays - dotclock dependent
+			  - UMA+LFB:  two overlays if video data in LFB
+			  - LFB only: two overlays
+		If UMA only: Must switch between one/two overlays on the fly (done
+			     in PostSetMode())
+		If LFB+UMA:  We use LFB memory only and leave UMA to an eventually
+			     written DRI driver.
+	      */
+	  }
+	  break;
+      case PCI_CHIP_SIS670:
+      case PCI_CHIP_SIS671:
+          if(pSiS->ChipType != SIS_770) {
+             /* ? - 770 2D is 342 based... (670, 772 are 350 based) */
+             pSiS->hasTwoOverlays = FALSE;
+	     /*pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;*/ /*ivans blocked*/
+          }
+      }
+
 #ifdef SISDUALHEAD
     /* In case of Dual Head, we need to determine if we are the "master" head or
      * the "slave" head. In order to do that, we set PrimInit to DONE in the
@@ -3989,8 +4077,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        pSiS->devsectname[ttt] = 0;
     }
 
-    pSiS->ForceCursorOff = FALSE;
-
     /* Allocate SiS_Private (for mode switching code) and initialize it */
     pSiS->SiS_Pr = NULL;
 #ifdef SISDUALHEAD
@@ -3998,6 +4084,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        if(pSiSEnt->SiS_Pr) pSiS->SiS_Pr = pSiSEnt->SiS_Pr;
     }
 #endif
+
     if(!pSiS->SiS_Pr) {
        if(!(pSiS->SiS_Pr = xnfcalloc(sizeof(struct SiS_Private), 1))) {
 	  SISErrorLog(pScrn, "Could not allocate memory for SiS_Pr structure\n");
@@ -4006,6 +4093,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 #ifdef SISDUALHEAD
        if(pSiSEnt) pSiSEnt->SiS_Pr = pSiS->SiS_Pr;
 #endif
+
        memset(pSiS->SiS_Pr, 0, sizeof(struct SiS_Private));
        pSiS->SiS_Pr->PciTag = pSiS->PciTag;
        pSiS->SiS_Pr->ChipType = pSiS->ChipType;
@@ -4038,46 +4126,37 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
      * routines inside init.c/init301.c
      */
     pSiS->SiS_Pr->IOAddress = (SISIOADDRESS)(pSiS->RelIO + 0x30);
+    pSiS->SiS_Pr->UseFutroTiming = FALSE;
     SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO + 0x30);
 
-    /* The following identifies the old chipsets. This is only
-     * partly used since the really old chips are not supported,
-     * but I keep it here for future use.
-     * 205, 215 and 225 are to be treated the same way, 201 and 202
-     * are different.
+    /*
+     * Now back to real business: Figure out the depth, bpp, etc.
+     * Set SupportConvert... flags since we use the fb layer which
+     * supports this conversion. (24to32 seems not implemented though)
+     * Additionally, determine the size of the HWCursor memory area.
      */
-    if(pSiS->VGAEngine == SIS_OLD_VGA || pSiS->VGAEngine == SIS_530_VGA) {
-       switch(pSiS->Chipset) {
-       case PCI_CHIP_SG86C201:
-	  pSiS->oldChipset = OC_SIS86201; break;
-       case PCI_CHIP_SG86C202:
-	  pSiS->oldChipset = OC_SIS86202; break;
-       case PCI_CHIP_SG86C205:
-	  inSISIDXREG(SISSR, 0x10, tempreg);
-	  if(tempreg & 0x80) pSiS->oldChipset = OC_SIS6205B;
-	  else pSiS->oldChipset = (pSiS->ChipRev == 0x11) ?
-					OC_SIS6205C : OC_SIS6205A;
+
+    switch(pSiS->VGAEngine) {
+       case SIS_300_VGA:
+	  pSiS->CursorSize = 4096;
+	  pix24flags = Support32bppFb;
 	  break;
-       case PCI_CHIP_SIS82C204:
-	  pSiS->oldChipset = OC_SIS82204; break;
-       case 0x6225:
-	  pSiS->oldChipset = OC_SIS6225; break;
-       case PCI_CHIP_SIS5597:
-	  pSiS->oldChipset = OC_SIS5597; break;
-       case PCI_CHIP_SIS6326:
-	  pSiS->oldChipset = OC_SIS6326; break;
-       case PCI_CHIP_SIS530:
-	  if(pciReadLong(0x00000000, 0x00) == 0x06201039) {
-	     pSiS->oldChipset = OC_SIS620;
-	  } else {
-	     if((pSiS->ChipRev & 0x0f) < 0x0a)
-		   pSiS->oldChipset = OC_SIS530A;
-	     else  pSiS->oldChipset = OC_SIS530B;
-	  }
+       case SIS_315_VGA:
+	  pSiS->CursorSize = 16384;
+	  pix24flags = Support32bppFb;
 	  break;
+       case SIS_530_VGA:
+	  pSiS->CursorSize = 2048;
+	  pix24flags = Support32bppFb	  |
+		       Support24bppFb	  |
+		       SupportConvert32to24;
+          break;
        default:
-	  pSiS->oldChipset = OC_UNKNOWN;
-       }
+	  pSiS->CursorSize = 2048;
+	  pix24flags = Support24bppFb	    |
+		       SupportConvert32to24 |
+		       PreferConvert32to24;
+	  break;
     }
 
     if(!xf86SetDepthBpp(pScrn, 0, 0, 0, pix24flags)) {
@@ -4165,8 +4244,9 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     }
 
     /* Set the current layout parameters */
-    pSiS->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
-    pSiS->CurrentLayout.depth        = pScrn->depth;
+    pSiS->CurrentLayout.bitsPerPixel  = pScrn->bitsPerPixel;
+    pSiS->CurrentLayout.bytesPerPixel = pScrn->bitsPerPixel >> 3;
+    pSiS->CurrentLayout.depth         = pScrn->depth;
     /* (Inside this function, we can use pScrn's contents anyway) */
 
     if(!xf86SetDefaultVisual(pScrn, -1)) {
@@ -4191,132 +4271,21 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     }
 #endif
 
-    /* Read BIOS for 300/315/330/340 series customization */
-    pSiS->SiS_Pr->VirtualRomBase = NULL;
-    pSiS->BIOS = NULL;
-    pSiS->SiS_Pr->UseROM = FALSE;
-    pSiS->ROM661New = FALSE;
-    pSiS->HaveXGIBIOS = FALSE;
-
-    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-#ifdef SISDUALHEAD
-       if(pSiSEnt) {
-	  if(pSiSEnt->BIOS) {
-	     pSiS->BIOS = pSiSEnt->BIOS;
-	     pSiS->SiS_Pr->VirtualRomBase = pSiS->BIOS;
-	     pSiS->ROM661New = pSiSEnt->ROM661New;
-	     pSiS->HaveXGIBIOS = pSiSEnt->HaveXGIBIOS;
-	  }
-       }
-#endif
-       if(!pSiS->BIOS) {
-	  if(!(pSiS->BIOS = xcalloc(1, BIOS_SIZE))) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		"Could not allocate memory for video BIOS image\n");
-	  } else {
-	     ULong  segstart;
-	     UShort mypciid = pSiS->Chipset;
-	     UShort mypcivendor = (pSiS->ChipFlags & SiSCF_IsXGI) ? PCI_VENDOR_XGI : PCI_VENDOR_SIS;
-	     Bool   found = FALSE, readpci = FALSE;
-	     int    biossize = BIOS_SIZE;
-
-	     switch(pSiS->ChipType) {
-	     case SIS_315:    mypciid = PCI_CHIP_SIS315;
-			      readpci = TRUE;
-			      break;
-	     case SIS_315PRO: mypciid = PCI_CHIP_SIS315PRO;
-			      readpci = TRUE;
-			      break;
-	     case SIS_300:
-	     case SIS_315H:
-	     case SIS_330:
-	     case SIS_340:
-	     case XGI_40:     readpci = TRUE;
-			      break;
-	     case XGI_20:     readpci = TRUE;
-			      biossize = 0x8000;
-			      break;
-	     }
-
-	     if(readpci) {
-		xf86ReadPciBIOS(0, pSiS->PciTag, 0, pSiS->BIOS, biossize);
-		if(SISCheckBIOS(pSiS, mypciid, mypcivendor, biossize)) {
-		   found = TRUE;
-		}
-	     }
-
-	     if(!found) {
-		for(segstart = BIOS_BASE; segstart < 0x000f0000; segstart += 0x00001000) {
-
-#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
-		   if(xf86ReadBIOS(segstart, 0, pSiS->BIOS, biossize) != biossize) continue;
-#else
-		   if(xf86ReadDomainMemory(pSiS->PciTag, segstart, biossize, pSiS->BIOS) != biossize) continue;
-#endif
-
-		   if(!SISCheckBIOS(pSiS, mypciid, mypcivendor, biossize)) continue;
-
-		   found = TRUE;
-		   break;
-		}
-             }
-
-	     if(found) {
-		UShort romptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
-		pSiS->SiS_Pr->VirtualRomBase = pSiS->BIOS;
-		if(pSiS->ChipFlags & SiSCF_IsXGI) {
-		   pSiS->HaveXGIBIOS = pSiS->SiS_Pr->SiS_XGIROM = TRUE;
-		   pSiS->SiS_Pr->UseROM = FALSE;
-		   if(pSiS->ChipFlags & SiSCF_IsXGIV3) {
-		      if(!(pSiS->BIOS[0x1d1] & 0x01)) {
-			 pSiS->SiS_Pr->DDCPortMixup = TRUE;
-		      }
-	           }
-	        } else {
-		   pSiS->ROM661New = SiSDetermineROMLayout661(pSiS->SiS_Pr);
-		}
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			"Video BIOS version \"%7s\" found (%s data layout)\n",
-			&pSiS->BIOS[romptr], pSiS->ROM661New ? "new SiS" :
-				(pSiS->HaveXGIBIOS ? "XGI" : "old SiS"));
-		if(pSiS->SiS_Pr->DDCPortMixup) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			"*** Buggy XGI V3XT card detected: If VGA and DVI are connected at the\n");
-		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			"*** same time, BIOS and driver will be unable to detect DVI connection.\n");
-		}
-#ifdef SISDUALHEAD
-		if(pSiSEnt) {
-		   pSiSEnt->BIOS = pSiS->BIOS;
-		   pSiSEnt->ROM661New = pSiS->ROM661New;
-		   pSiSEnt->HaveXGIBIOS = pSiS->HaveXGIBIOS;
-		}
-#endif
-	     } else {
-	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			 "Could not find/read video BIOS\n");
-		xfree(pSiS->BIOS);
-		pSiS->BIOS = NULL;
-	     }
-          }
-       }
-
-       if(!(pSiS->ChipFlags & SiSCF_IsXGI)) {
-          if(pSiS->BIOS) pSiS->SiS_Pr->UseROM = TRUE;
-          else           pSiS->SiS_Pr->UseROM = FALSE;
-       }
-    }
+    /* Read BIOS for 300/315/330/340/350 series customization */
+    SiSReadROM(pScrn);
 
     /* Evaluate options */
     SiSOptions(pScrn);
 
 #ifdef SISMERGED
-    /* Due to palette & timing problems we don't support 8bpp in MFBM */
+    /* Due to palette & timing problems we don't support 8bpp in MFB */
     if((pSiS->MergedFB) && (pScrn->bitsPerPixel <= 8)) {
        SISErrorLog(pScrn, "MergedFB: Color depth %d not supported, %s\n",
 			pScrn->bitsPerPixel, mergeddisstr);
        pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
     }
+
+     pSiS->SiS_Pr->MergedFB = pSiS->MergedFB;
 #endif
 
     /* Probe CPU features */
@@ -4340,157 +4309,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     if(pScrn->depth == 8) pScrn->rgbBits = 8;
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(!pSiS->SecondHead) {
-	  /* Copy some option settings to entity private */
-	  pSiSEnt->HWCursor = pSiS->HWCursor;
-	  pSiSEnt->NoAccel = pSiS->NoAccel;
-	  pSiSEnt->useEXA = pSiS->useEXA;
-	  pSiSEnt->restorebyset = pSiS->restorebyset;
-	  pSiSEnt->OptROMUsage = pSiS->OptROMUsage;
-	  pSiSEnt->OptUseOEM = pSiS->OptUseOEM;
-	  pSiSEnt->TurboQueue = pSiS->TurboQueue;
-	  pSiSEnt->forceCRT1 = pSiS->forceCRT1;
-	  pSiSEnt->ForceCRT1Type = pSiS->ForceCRT1Type;
-	  pSiSEnt->CRT1TypeForced = pSiS->CRT1TypeForced;
-	  pSiSEnt->ForceCRT2Type = pSiS->ForceCRT2Type;
-	  pSiSEnt->ForceTVType = pSiS->ForceTVType;
-	  pSiSEnt->ForceYPbPrType = pSiS->ForceYPbPrType;
-	  pSiSEnt->ForceYPbPrAR = pSiS->ForceYPbPrAR;
-	  pSiSEnt->UsePanelScaler = pSiS->UsePanelScaler;
-	  pSiSEnt->CenterLCD = pSiS->CenterLCD;
-	  pSiSEnt->DSTN = pSiS->DSTN;
-	  pSiSEnt->FSTN = pSiS->FSTN;
-	  pSiSEnt->OptTVStand = pSiS->OptTVStand;
-	  pSiSEnt->NonDefaultPAL = pSiS->NonDefaultPAL;
-	  pSiSEnt->NonDefaultNTSC = pSiS->NonDefaultNTSC;
-	  pSiSEnt->chtvtype = pSiS->chtvtype;
-	  pSiSEnt->OptTVOver = pSiS->OptTVOver;
-	  pSiSEnt->OptTVSOver = pSiS->OptTVSOver;
-	  pSiSEnt->chtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
-	  pSiSEnt->chtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
-	  pSiSEnt->chtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
-	  pSiSEnt->chtvchromabandwidth = pSiS->chtvchromabandwidth;
-	  pSiSEnt->chtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
-	  pSiSEnt->chtvtextenhance = pSiS->chtvtextenhance;
-	  pSiSEnt->chtvcontrast = pSiS->chtvcontrast;
-	  pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
-	  pSiSEnt->sistvedgeenhance = pSiS->sistvedgeenhance;
-	  pSiSEnt->sistvantiflicker = pSiS->sistvantiflicker;
-	  pSiSEnt->sistvsaturation = pSiS->sistvsaturation;
-	  pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
-	  pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
-	  pSiSEnt->sistvcolcalibc = pSiS->sistvcolcalibc;
-	  pSiSEnt->sistvcolcalibf = pSiS->sistvcolcalibf;
-	  pSiSEnt->tvxpos = pSiS->tvxpos;
-	  pSiSEnt->tvypos = pSiS->tvypos;
-	  pSiSEnt->tvxscale = pSiS->tvxscale;
-	  pSiSEnt->tvyscale = pSiS->tvyscale;
-	  pSiSEnt->siscrt1satgain = pSiS->siscrt1satgain;
-	  pSiSEnt->crt1satgaingiven = pSiS->crt1satgaingiven;
-	  pSiSEnt->CRT1gamma = pSiS->CRT1gamma;
-	  pSiSEnt->CRT1gammaGiven = pSiS->CRT1gammaGiven;
-	  pSiSEnt->XvGammaRed = pSiS->XvGammaRed;
-	  pSiSEnt->XvGammaGreen = pSiS->XvGammaGreen;
-	  pSiSEnt->XvGammaBlue = pSiS->XvGammaBlue;
-	  pSiSEnt->XvGamma = pSiS->XvGamma;
-	  pSiSEnt->XvGammaGiven = pSiS->XvGammaGiven;
-	  pSiSEnt->CRT2gamma = pSiS->CRT2gamma;
-	  pSiSEnt->XvOnCRT2 = pSiS->XvOnCRT2;
-	  pSiSEnt->AllowHotkey = pSiS->AllowHotkey;
-	  pSiSEnt->enablesisctrl = pSiS->enablesisctrl;
-	  pSiSEnt->SenseYPbPr = pSiS->SenseYPbPr;
-	  pSiSEnt->XvUseMemcpy = pSiS->XvUseMemcpy;
-	  pSiSEnt->BenchMemCpy = pSiS->BenchMemCpy;
-#ifdef SIS_CP
-	  SIS_CP_DRIVER_COPYOPTIONSENT
-#endif
-       } else {
-	  /* We always use same cursor type on both screens */
-	  pSiS->HWCursor = pSiSEnt->HWCursor;
-	  /* We need identical NoAccel setting */
-	  pSiS->NoAccel = pSiSEnt->NoAccel;
-	  pSiS->useEXA = pSiSEnt->useEXA;
-	  pSiS->TurboQueue = pSiSEnt->TurboQueue;
-	  pSiS->restorebyset = pSiSEnt->restorebyset;
-	  pSiS->AllowHotkey = pSiS->AllowHotkey;
-	  pSiS->OptROMUsage = pSiSEnt->OptROMUsage;
-	  pSiS->OptUseOEM = pSiSEnt->OptUseOEM;
-	  pSiS->forceCRT1 = pSiSEnt->forceCRT1;
-	  pSiS->nocrt2ddcdetection = FALSE;
-	  pSiS->forcecrt2redetection = FALSE;
-	  pSiS->ForceCRT1Type = pSiSEnt->ForceCRT1Type;
-	  pSiS->ForceCRT2Type = pSiSEnt->ForceCRT2Type;
-	  pSiS->CRT1TypeForced = pSiSEnt->CRT1TypeForced;
-	  pSiS->UsePanelScaler = pSiSEnt->UsePanelScaler;
-	  pSiS->CenterLCD = pSiSEnt->CenterLCD;
-	  pSiS->DSTN = pSiSEnt->DSTN;
-	  pSiS->FSTN = pSiSEnt->FSTN;
-	  pSiS->OptTVStand = pSiSEnt->OptTVStand;
-	  pSiS->NonDefaultPAL = pSiSEnt->NonDefaultPAL;
-	  pSiS->NonDefaultNTSC = pSiSEnt->NonDefaultNTSC;
-	  pSiS->chtvtype = pSiSEnt->chtvtype;
-	  pSiS->ForceTVType = pSiSEnt->ForceTVType;
-	  pSiS->ForceYPbPrType = pSiSEnt->ForceYPbPrType;
-	  pSiS->ForceYPbPrAR = pSiSEnt->ForceYPbPrAR;
-	  pSiS->OptTVOver = pSiSEnt->OptTVOver;
-	  pSiS->OptTVSOver = pSiSEnt->OptTVSOver;
-	  pSiS->chtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
-	  pSiS->chtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
-	  pSiS->chtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
-	  pSiS->chtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
-	  pSiS->chtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
-	  pSiS->chtvcvbscolor = pSiSEnt->chtvcvbscolor;
-	  pSiS->chtvtextenhance = pSiSEnt->chtvtextenhance;
-	  pSiS->chtvcontrast = pSiSEnt->chtvcontrast;
-	  pSiS->sistvedgeenhance = pSiSEnt->sistvedgeenhance;
-	  pSiS->sistvantiflicker = pSiSEnt->sistvantiflicker;
-	  pSiS->sistvsaturation = pSiSEnt->sistvsaturation;
-	  pSiS->sistvcfilter = pSiSEnt->sistvcfilter;
-	  pSiS->sistvyfilter = pSiSEnt->sistvyfilter;
-	  pSiS->sistvcolcalibc = pSiSEnt->sistvcolcalibc;
-	  pSiS->sistvcolcalibf = pSiSEnt->sistvcolcalibf;
-	  pSiS->tvxpos = pSiSEnt->tvxpos;
-	  pSiS->tvypos = pSiSEnt->tvypos;
-	  pSiS->tvxscale = pSiSEnt->tvxscale;
-	  pSiS->tvyscale = pSiSEnt->tvyscale;
-	  pSiS->SenseYPbPr = pSiSEnt->SenseYPbPr;
-	  if(!pSiS->CRT1gammaGiven) {
-	     if(pSiSEnt->CRT1gammaGiven)
-	        pSiS->CRT1gamma = pSiSEnt->CRT1gamma;
-	  }
-	  pSiS->CRT2gamma = pSiSEnt->CRT2gamma;
-	  if(!pSiS->XvGammaGiven) {
-	     if(pSiSEnt->XvGammaGiven) {
-		pSiS->XvGamma = pSiSEnt->XvGamma;
-		pSiS->XvGammaRed = pSiS->XvGammaRedDef = pSiSEnt->XvGammaRed;
-		pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = pSiSEnt->XvGammaGreen;
-		pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = pSiSEnt->XvGammaBlue;
-	     }
-	  }
-	  if(!pSiS->crt1satgaingiven) {
-	     if(pSiSEnt->crt1satgaingiven)
-	        pSiS->siscrt1satgain = pSiSEnt->siscrt1satgain;
-	  }
-	  pSiS->XvOnCRT2 = pSiSEnt->XvOnCRT2;
-	  pSiS->enablesisctrl = pSiSEnt->enablesisctrl;
-	  pSiS->XvUseMemcpy = pSiSEnt->XvUseMemcpy;
-	  pSiS->BenchMemCpy = pSiSEnt->BenchMemCpy;
-	  /* Copy gamma brightness to Ent (sic!) for Xinerama */
-	  pSiSEnt->GammaBriR = pSiS->GammaBriR;
-	  pSiSEnt->GammaBriG = pSiS->GammaBriG;
-	  pSiSEnt->GammaBriB = pSiS->GammaBriB;
-	  pSiSEnt->NewGammaBriR = pSiS->NewGammaBriR;
-	  pSiSEnt->NewGammaBriG = pSiS->NewGammaBriG;
-	  pSiSEnt->NewGammaBriB = pSiS->NewGammaBriB;
-	  pSiSEnt->NewGammaConR = pSiS->NewGammaConR;
-	  pSiSEnt->NewGammaConG = pSiS->NewGammaConG;
-	  pSiSEnt->NewGammaConB = pSiS->NewGammaConB;
-#ifdef SIS_CP
-	  SIS_CP_DRIVER_COPYOPTIONS
-#endif
-       }
-    }
+    /* Copy data to/from pSiSEnt (mainly options) */
+    SiSCopyFromToEntity(pScrn);
 #endif
 
     /* Handle UseROMData, NoOEM and UsePanelScaler options */
@@ -4522,7 +4342,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        pSiS->FbAddress = pSiS->pEnt->device->MemBase;
        from = X_CONFIG;
     } else {
-       pSiS->FbAddress = pSiS->PciInfo->memBase[0] & 0xFFFFFFF0;
+       pSiS->FbAddress = PCI_REGION_BASE(pSiS->PciInfo, 0, REGION_MEM) & 0xFFFFFFF0;
        from = X_PROBED;
     }
 
@@ -4546,8 +4366,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        pSiS->IOAddress = pSiS->pEnt->device->IOBase;
        from = X_CONFIG;
     } else {
-       pSiS->IOAddress = pSiS->PciInfo->memBase[1] & 0xFFFFFFF0;
-       from = X_PROBED;
+        pSiS->IOAddress = PCI_REGION_BASE( pSiS->PciInfo, 1, REGION_MEM) & 0xFFFFFFF0;
+		from = X_PROBED;
     }
     xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX (size %ldK)\n",
 	   (ULong)pSiS->IOAddress, pSiS->mmioSize);
@@ -4610,7 +4430,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     pSiS->CurARGBDest = NULL;
     pSiS->CurMonoSrc = NULL;
     pSiS->CurFGCol = pSiS->CurBGCol = 0;
-    pSiS->FbBaseOffset = 0;
+    pSiS->FbBaseOffset = 0; /*1024 * 1024;*/ /*chechun Kuo add offset for 512kB*/
 
     switch(pSiS->VGAEngine) {
 
@@ -4897,145 +4717,15 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %dK of framebuffer memory at offset %dK\n",
 				pSiS->maxxfbmem / 1024, pSiS->FbBaseOffset / 1024);
 
-    /* Find out about sub-classes of some chipsets and check
-     * if the chipset supports two video overlays
-     */
-    if(pSiS->VGAEngine == SIS_300_VGA    ||
-       pSiS->VGAEngine == SIS_315_VGA    ||
-       pSiS->Chipset == PCI_CHIP_SIS530  ||
-       pSiS->Chipset == PCI_CHIP_SIS6326 ||
-       pSiS->Chipset == PCI_CHIP_SIS5597)  {
-       pSiS->hasTwoOverlays = FALSE;
-       switch(pSiS->Chipset) {
-	 case PCI_CHIP_SIS300:
-	 case PCI_CHIP_SIS540:  /* ? (If not, need to add the SwitchCRT Xv attribute!) */
-	 case PCI_CHIP_SIS630:
-	 case PCI_CHIP_SIS550:
-	   pSiS->hasTwoOverlays = TRUE;
-	   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
-	   break;
-	 case PCI_CHIP_SIS315PRO:
-	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
-	   break;
-	 case PCI_CHIP_SIS330:
-	   pSiS->ChipFlags |= (SiSCF_CRT2HWCKaputt | SiSCF_LARGEOVERLAY);
-	   break;
-	 case PCI_CHIP_SIS340:
-	 case PCI_CHIP_XGIXG40: /* Verified: only 1 overlay */
-	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
-	   break;
-	 case PCI_CHIP_SIS650:
-	   {
-	     UChar tempreg1, tempreg2;
-	     static const char *id650str[] = {
-		"650",       "650",       "650",       "650",
-		"650 A0 AA", "650 A2 CA", "650",       "650",
-		"M650 A0",   "M650 A1 AA","651 A0 AA", "651 A1 AA",
-		"M650",      "65?",       "651",       "65?"
-	     };
-	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
-	     if(pSiS->ChipType == SIS_650) {
-		inSISIDXREG(SISCR, 0x5f, CR5F);
-		CR5F &= 0xf0;
-		andSISIDXREG(SISCR, 0x5c, 0x07);
-		inSISIDXREG(SISCR, 0x5c, tempreg1);
-		tempreg1 &= 0xf8;
-		orSISIDXREG(SISCR, 0x5c, 0xf8);
-		inSISIDXREG(SISCR, 0x5c, tempreg2);
-		tempreg2 &= 0xf8;
-		if((!tempreg1) || (tempreg2)) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		      "SiS650 revision ID %x (%s)\n", CR5F, id650str[CR5F >> 4]);
-		   if(CR5F & 0x80) {
-		      pSiS->hasTwoOverlays = TRUE;  /* M650 or 651 */
-		      pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
-		   }
-		   switch(CR5F) {
-		      case 0xa0:
-		      case 0xb0:
-		      case 0xe0:
-		         pSiS->ChipFlags |= SiSCF_Is651;
-		         break;
-		      case 0x80:
-		      case 0x90:
-		      case 0xc0:
-		         pSiS->ChipFlags |= SiSCF_IsM650;
-		         break;
-		   }
-		} else {
-		   pSiS->hasTwoOverlays = TRUE;
-		   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
-		   switch(CR5F) {
-		      case 0x90:
-			 inSISIDXREG(SISCR, 0x5c, tempreg1);
-			 tempreg1 &= 0xf8;
-			 switch(tempreg1) {
-			    case 0x00:
-			       pSiS->ChipFlags |= SiSCF_IsM652;
-			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			           "SiSM652 revision ID %x\n", CR5F);
-			       break;
-			    case 0x40:
-			       pSiS->ChipFlags |= SiSCF_IsM653;
-			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			           "SiSM653 revision ID %x\n", CR5F);
-			       break;
-			    default:
-			       pSiS->ChipFlags |= SiSCF_IsM650;
-			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			           "SiSM650 revision ID %x\n", CR5F);
-			       break;
-			 }
-			 break;
-		      case 0xb0:
-			 pSiS->ChipFlags |= SiSCF_Is652;
-			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			     "SiS652 revision ID %x\n", CR5F);
-			 break;
-		      default:
-			 pSiS->ChipFlags |= SiSCF_IsM650;
-			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			     "SiSM650 revision ID %x\n", CR5F);
-			 break;
-		   }
-		}
-	     }
-	     break;
-	   }
-	 case PCI_CHIP_SIS660:
-	   {
-	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
-	     pSiS->hasTwoOverlays = TRUE;
-	     pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
-	     /* 760/761:  - UMA only: one/two overlays - dotclock dependent
-			  - UMA+LFB:  two overlays if video data in LFB
-			  - LFB only: two overlays
-		If UMA only: Must switch between one/two overlays on the fly (done
-			     in PostSetMode())
-		If LFB+UMA:  We use LFB memory only and leave UMA to an eventually
-			     written DRI driver.
-	      */
-	     break;
-	   }
-       }
-
-       if(!(pSiS->SiS_SD2_Flags & SiS_SD2_NOOVERLAY)) {
-          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		"Hardware supports %s video overlay%s\n",
-		pSiS->hasTwoOverlays ? "two" : "one",
-		pSiS->hasTwoOverlays ? "s" : "");
-       }
 
-       if(pSiS->SiS_SD2_Flags & SiS_SD2_SUPPORT760OO) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		"\n\tDear SiS76x user, your machine is using a shared memory framebuffer.\n"
+    if(pSiS->SiS_SD2_Flags & SiS_SD2_SUPPORT760OO) {
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		"\n\tDear SiS760 user, your machine is using a shared memory framebuffer.\n"
 		  "\tDue to hardware limitations of the SiS chip in combination with the\n"
 		  "\tAMD CPU, video overlay support is very limited on this machine. If you\n"
 		  "\texperience flashing lines in the video and/or the graphics display\n"
 		  "\tduring video playback, reduce the color depth and/or the resolution\n"
 		  "\tand/or the refresh rate. Alternatively, use the video blitter.\n");
-       }
-
     }
 
     /* Backup VB connection and CRT1 on/off register */
@@ -5052,82 +4742,11 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        pSiS->postVBCR32 = pSiS->oldCR32;
     }
 
-    /* There are some machines out there which require a special
-     * setup of the GPIO registers in order to make the Chrontel
-     * work. Try to find out if we're running on such a machine.
-     * Furthermore, there is some highly customized hardware,
-     * which requires some non-standard LVDS timing. Since the
-     * vendors don't seem to care about PCI subsystem ID's we
-     * need to find out using the BIOS version and date strings.
-     */
-    pSiS->SiS_Pr->SiS_ChSW = FALSE;
-    if(pSiS->Chipset == PCI_CHIP_SIS630) {
-       int i = 0;
-       do {
-	  if(mychswtable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
-	     mychswtable[i].subsysCard == pSiS->PciInfo->subsysCard) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	         "PCI subsystem ID found in list for Chrontel/GPIO setup:\n");
-	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		 "\tVendor/Card: %s %s (ID %04x)\n",
-		  mychswtable[i].vendorName,
-		  mychswtable[i].cardName,
-		  pSiS->PciInfo->subsysCard);
-	     pSiS->SiS_Pr->SiS_ChSW = TRUE;
-	     break;
-          }
-          i++;
-       } while(mychswtable[i].subsysVendor != 0);
-    }
-
-    if(pSiS->SiS_Pr->SiS_CustomT == CUT_NONE) {
-       int    i = 0, j;
-       UShort bversptr = 0;
-       Bool   footprint;
-       CARD32 chksum = 0;
+    /* SiS630: Chrontel GPIO */
+    SiSDetermineChrontelGPIO(pScrn);
 
-       if(pSiS->SiS_Pr->UseROM) {
-          bversptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
-          for(i=0; i<32768; i++) chksum += pSiS->BIOS[i];
-       }
-
-       i = 0;
-       do {
-	  if( (SiS_customttable[i].chipID == pSiS->ChipType)                            &&
-	      ((!strlen(SiS_customttable[i].biosversion)) ||
-	       (pSiS->SiS_Pr->UseROM &&
-	       (!strncmp(SiS_customttable[i].biosversion, (char *)&pSiS->BIOS[bversptr],
-	                strlen(SiS_customttable[i].biosversion)))))                     &&
-	      ((!strlen(SiS_customttable[i].biosdate)) ||
-	       (pSiS->SiS_Pr->UseROM &&
-	       (!strncmp(SiS_customttable[i].biosdate, (char *)&pSiS->BIOS[0x2c],
-	                strlen(SiS_customttable[i].biosdate)))))			      &&
-	      ((!SiS_customttable[i].bioschksum) ||
-	       (pSiS->SiS_Pr->UseROM &&
-	       (SiS_customttable[i].bioschksum == chksum)))			      &&
-	      (SiS_customttable[i].pcisubsysvendor == pSiS->PciInfo->subsysVendor)      &&
-	      (SiS_customttable[i].pcisubsyscard == pSiS->PciInfo->subsysCard) ) {
-	     footprint = TRUE;
-	     for(j=0; j<5; j++) {
-	        if(SiS_customttable[i].biosFootprintAddr[j]) {
-		   if(pSiS->SiS_Pr->UseROM) {
-		      if(pSiS->BIOS[SiS_customttable[i].biosFootprintAddr[j]] !=
-						SiS_customttable[i].biosFootprintData[j])
-		         footprint = FALSE;
-		   } else footprint = FALSE;
-	        }
-	     }
-	     if(footprint) {
-	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	           "Identified %s %s, special timing applies\n",
-		   SiS_customttable[i].vendorName, SiS_customttable[i].cardName);
-	        pSiS->SiS_Pr->SiS_CustomT = SiS_customttable[i].SpecialID;
-	        break;
-	     }
-          }
-          i++;
-       } while(SiS_customttable[i].chipID);
-    }
+    /* Determine custom timing */
+    SiSDetermineCustomTiming(pScrn);
 
     /* Handle ForceCRT1 option */
     if(pSiS->forceCRT1 != -1) {
@@ -5135,6 +4754,9 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        else                pSiS->CRT1off = 1;
     } else                 pSiS->CRT1off = -1;
 
+    /* Load DDC module (needed for device detection already) */
+    SiSLoadInitDDCModule(pScrn);
+
     /* Detect video bridge and sense TV/VGA2 */
     SISVGAPreInit(pScrn);
 
@@ -5167,6 +4789,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     pSiS->SiS_SD2_Flags |= SiS_SD2_NEWGAMMABRICON;
 
     pSiS->SiS_SD3_Flags |= SiS_SD3_MFBALLOWOFFCL;
+    pSiS->SiS_SD3_Flags |= SiS_SD3_MFBDYNPOS;
+
 
     if(pSiS->VBFlags2 & VB2_VIDEOBRIDGE) {
        pSiS->SiS_SD2_Flags |= SiS_SD2_VIDEOBRIDGE;
@@ -5204,7 +4828,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        }
     }
 
-#ifdef ENABLE_YPBPR
     if((pSiS->VGAEngine == SIS_315_VGA) &&
        (pSiS->VBFlags2 & VB2_SISYPBPRBRIDGE)) {
        pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPR;
@@ -5217,7 +4840,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     if(pSiS->VBFlags2 & VB2_SISHIVISIONBRIDGE) {
        pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTHIVISION;
     }
-#endif
 
     if((pSiS->VGAEngine != SIS_300_VGA) || (!(pSiS->VBFlags2 & VB2_TRUMPION))) {
        pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSCALE;
@@ -5228,18 +4850,18 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     }
 
 #ifdef SISDUALHEAD
-    if(!pSiS->DualHeadMode) {
-       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTREDETECT;
-    }
+    if(!pSiS->DualHeadMode)
 #endif
+       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTREDETECT;
 
 #ifndef SISCHECKOSSSE
     pSiS->SiS_SD2_Flags |= SiS_SD2_NEEDUSESSE;
 #endif
 
-#ifdef TWDEBUG	/* FOR TESTING */
+#ifdef TWDEBUG	
     pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
     xf86DrvMsg(0, X_INFO, "TEST: Support Aspect Ratio\n");
+
 #endif
 
     /* Detect CRT2-TV and PAL/NTSC mode */
@@ -5264,7 +4886,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "HiVision TV output not supported\n");
        }
     }
-
     if((pSiS->VBFlags2 & VB2_SISTVBRIDGE) ||
        ((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x))) {
        pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
@@ -5306,8 +4927,13 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        (pSiS->SiS_Pr->SiS_CustomT != CUT_UNKNOWNLCD)) {
        if((!pSiS->CRT1TypeForced) && (pSiS->ForceCRT2Type == CRT2_DEFAULT)) {
 	  if(pSiS->VBFlags & CRT2_TV) {
-	     /* If both LCD and TV present, default to LCDA+TV */
-	     pSiS->ForceCRT1Type = CRT1_LCDA;
+	     /* 
+	     	  If both LCD and TV present, default to LCDA+TV.
+	     	  However for newer chips later than 662, (pSiS->VBFlags & CRT2_LCD) is always true.
+	     	  (BIOS's fault?)
+	     	  Therefore we do not set CRT1 as LCDA if new chips.
+		*/
+		if(pSiS->ChipType < SIS_662 || pSiS->ChipType >= XGI_20)	pSiS->ForceCRT1Type = CRT1_LCDA;
 	     pSiS->ForceCRT2Type = CRT2_TV;
 	  } else if(pSiS->LCDwidth > 1600) {
 	     /* If LCD is > 1600, default to LCDA if we don't need CRT1/VGA for other head */
@@ -5341,11 +4967,11 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     } else {
        pSiS->ForceCRT1Type = CRT1_VGA;
     }
-
+	
     pSiS->VBFlags |= pSiS->ForceCRT1Type;
 
 #ifdef TWDEBUG
-    xf86DrvMsg(0, X_INFO, "SDFlags %lx\n", pSiS->SiS_SD_Flags);
+    xf86DrvMsg(0, X_INFO, "SDFlags %lx pSiS->VBFlags = 0x%x\n", pSiS->SiS_SD_Flags, pSiS->VBFlags);
 #endif
 
     /* Eventually overrule detected CRT2 type
@@ -5363,7 +4989,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        else if((pSiS->VBFlags & CRT2_VGA) && (pSiS->ForceCRT1Type == CRT1_VGA))
 	  pSiS->ForceCRT2Type = CRT2_VGA;
     }
-
     switch(pSiS->ForceCRT2Type) {
        case CRT2_TV:
 	  pSiS->VBFlags &= ~(CRT2_LCD | CRT2_VGA);
@@ -5408,7 +5033,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        Gamma zeros = {0.0, 0.0, 0.0};
        xf86SetGamma(pScrn, zeros);
     }
-
 #ifdef SISDUALHEAD
     if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
 #endif
@@ -5440,7 +5064,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 #ifdef SISDUALHEAD
     }
 #endif
-
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) pSiS->CRT2SepGamma = FALSE;
 #endif
@@ -5555,6 +5178,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        pSiS->newCR32 = usScratchCR32;
     }
 
+
     /* Check if CRT1 used (or needed; this eg. if no CRT2 detected) */
     if(pSiS->VBFlags2 & VB2_VIDEOBRIDGE) {
 
@@ -5573,6 +5197,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	}
 
     } else { /* no video bridge? */
+
 	/* Then we NEED CRT1... */
 	pSiS->CRT1off = 0;
 	/* ... and can't use CRT2 for Xv output */
@@ -5634,9 +5259,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        }
     }
 
-#ifdef SIS_CP
-    SIS_CP_DRIVER_RECONFIGOPT
-#endif
 
     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
        if(pSiS->sis6326tvplug != -1) {
@@ -5676,7 +5298,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        }
     }
 
-    /* Do some MergedFB mode initialisation */
+    /* MergedFB: Create CRT2 pScrn and make it a copy of pScrn */
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
        pSiS->CRT2pScrn = xalloc(sizeof(ScrnInfoRec));
@@ -5695,96 +5317,92 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
      *           This requires extra checks in functions using this flag!
      *           (see sis_video.c for example)
      */
+
     if(pSiS->VBFlags & DISPTYPE_DISP2) {
-        if(pSiS->CRT1off) {	/* CRT2 only ------------------------------- */
+
+       if(pSiS->CRT1off) {	/* CRT2 only ------------------------------- */
+
 #ifdef SISDUALHEAD
-	     if(pSiS->DualHeadMode) {
-		SISErrorLog(pScrn,
+	  if(pSiS->DualHeadMode) {
+	     SISErrorLog(pScrn,
 		    "CRT1 not detected or forced off. Dual Head mode can't initialize.\n");
-		if(pSiSEnt) pSiSEnt->DisableDual = TRUE;
-		goto my_error_1;
-	     }
+	     if(pSiSEnt) pSiSEnt->DisableDual = TRUE;
+	     goto my_error_1;
+	  }
 #endif
 #ifdef SISMERGED
-	     if(pSiS->MergedFB) {
-		if(pSiS->MergedFBAuto) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt1, mergeddisstr);
-		} else {
-		   SISErrorLog(pScrn, mergednocrt1, mergeddisstr);
-		}
-		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
-		pSiS->CRT2pScrn = NULL;
-		pSiS->MergedFB = FALSE;
+	  if(pSiS->MergedFB) {
+	     if(pSiS->MergedFBAuto) {
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt1, mergeddisstr);
+	     } else {
+		SISErrorLog(pScrn, mergednocrt1, mergeddisstr);
 	     }
+	     if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
+	     pSiS->CRT2pScrn = NULL;
+	     pSiS->MergedFB = FALSE;
+	  }
 #endif
-	     pSiS->VBFlags |= VB_DISPMODE_SINGLE;
-	     /* No CRT1? Then we use the video overlay on CRT2 */
-	     pSiS->XvOnCRT2 = TRUE;
-	} else			/* CRT1 and CRT2 - mirror or dual head ----- */
+	  pSiS->VBFlags |= VB_DISPMODE_SINGLE;
+	  /* No CRT1? Then we use the video overlay on CRT2 */
+	  pSiS->XvOnCRT2 = TRUE;
+
+       } else			/* CRT1 and CRT2 - mirror or dual head ----- */
+
 #ifdef SISDUALHEAD
-	     if(pSiS->DualHeadMode) {
-		pSiS->VBFlags |= (VB_DISPMODE_DUAL | DISPTYPE_CRT1);
-		if(pSiS->VESA != -1) {
-		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"VESA option not used in Dual Head mode. VESA disabled.\n");
-		}
-		if(pSiSEnt) pSiSEnt->DisableDual = FALSE;
-		pSiS->VESA = 0;
-	     } else
+       if(pSiS->DualHeadMode) {
+	  if(pSiS->VESA != -1) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		  "VESA not used in Dual Head mode. VESA disabled.\n");
+	  }
+	  if(pSiSEnt) pSiSEnt->DisableDual = FALSE;
+	  pSiS->VESA = 0;
+       } else
 #endif
 #ifdef SISMERGED
-		    if(pSiS->MergedFB) {
-		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
-		 if(pSiS->VESA != -1) {
-		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"VESA option not used in MergedFB mode. VESA disabled.\n");
-		 }
-		 pSiS->VESA = 0;
-	     } else
+	      if(pSiS->MergedFB) {
+	  pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
+	  if(pSiS->VESA != -1) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		  "VESA not used in MergedFB mode. VESA disabled.\n");
+	  }
+	  pSiS->VESA = 0;
+       } else
 #endif
-		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
+	  pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
     } else {			/* CRT1 only ------------------------------- */
+
 #ifdef SISDUALHEAD
-	     if(pSiS->DualHeadMode) {
-		SISErrorLog(pScrn,
-		   "No CRT2 output selected or no bridge detected. "
-		   "Dual Head mode can't initialize.\n");
-		goto my_error_1;
-	     }
+	if(pSiS->DualHeadMode) {
+	   SISErrorLog(pScrn,
+		"No CRT2 output selected or no bridge detected. "
+		"Dual Head mode can't initialize.\n");
+	   goto my_error_1;
+	}
 #endif
 #ifdef SISMERGED
-	     if(pSiS->MergedFB) {
-		if(pSiS->MergedFBAuto) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt2, mergeddisstr);
-		} else {
-		   SISErrorLog(pScrn, mergednocrt2, mergeddisstr);
-		}
-		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
-		pSiS->CRT2pScrn = NULL;
-		pSiS->MergedFB = FALSE;
-	     }
+	if(pSiS->MergedFB) {
+	   if(pSiS->MergedFBAuto) {
+	      xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt2, mergeddisstr);
+	   } else {
+	      SISErrorLog(pScrn, mergednocrt2, mergeddisstr);
+	   }
+	   if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
+	   pSiS->CRT2pScrn = NULL;
+	   pSiS->MergedFB = FALSE;
+	}
 #endif
-             pSiS->VBFlags |= (VB_DISPMODE_SINGLE | DISPTYPE_CRT1);
-    }
-
-    if((pSiS->VGAEngine == SIS_315_VGA) || (pSiS->VGAEngine == SIS_300_VGA)) {
-       if((!pSiS->NoXvideo)		&&
-          (!pSiS->hasTwoOverlays)	&&
-	  (!(pSiS->SiS_SD2_Flags & SiS_SD2_NOOVERLAY))) {
-	  xf86DrvMsg(pScrn->scrnIndex, from,
-	      "Using Xv overlay by default on CRT%d\n",
-	      pSiS->XvOnCRT2 ? 2 : 1);
-       }
+        pSiS->VBFlags |= (VB_DISPMODE_SINGLE | DISPTYPE_CRT1);
     }
 
     /* Init ptrs for Save/Restore functions and calc MaxClock */
     SISDACPreInit(pScrn);
-
+	
     /* ********** end of VBFlags setup ********** */
-
     /* VBFlags are initialized now. Back them up for SlaveMode modes. */
     pSiS->VBFlags_backup = pSiS->VBFlags;
-
+    #ifdef TWDEUG
+	 xf86DrvMsg(0, X_INFO,"[SISPreInit( )]:Final VBFlags=0x%x.\n", pSiS->VBFlags);
+    #endif	
     /* Backup CR32,36,37 (in order to write them back after a VT switch) */
     if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
        inSISIDXREG(SISCR,0x32,pSiS->myCR32);
@@ -5792,220 +5410,16 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        inSISIDXREG(SISCR,0x37,pSiS->myCR37);
     }
 
-    /* Find out about paneldelaycompensation and evaluate option */
-#ifdef SISDUALHEAD
-    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
-#endif
-       if(pSiS->VGAEngine == SIS_300_VGA) {
-
-          if(pSiS->VBFlags2 & (VB2_LVDS | VB2_30xBDH)) {
-
-	     /* Save the current PDC if the panel is used at the moment.
-	      * This seems by far the safest way to find out about it.
-	      * If the system is using an old version of sisfb, we can't
-	      * trust the pdc register value. If sisfb saved the pdc for
-	      * us, use it.
-	      */
-	     if(pSiS->sisfbpdc != 0xff) {
-	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
-	     } else {
-	        if(!(pSiS->donttrustpdc)) {
-	           UChar tmp;
-	           inSISIDXREG(SISCR, 0x30, tmp);
-	           if(tmp & 0x20) {
-	              inSISIDXREG(SISPART1, 0x13, pSiS->SiS_Pr->PDC);
-                   } else {
-	             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		          "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
-	           }
-	        } else {
-	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		        "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
-	        }
-	     }
-	     if(pSiS->SiS_Pr->PDC != -1) {
-	        pSiS->SiS_Pr->PDC &= 0x3c;
-	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		     "Detected LCD PanelDelayCompensation 0x%02x\n",
-		     pSiS->SiS_Pr->PDC);
-	     }
-
-	     /* If we haven't been able to find out, use our other methods */
-	     if(pSiS->SiS_Pr->PDC == -1) {
-		int i=0;
-		do {
-		   if(mypdctable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
-		      mypdctable[i].subsysCard == pSiS->PciInfo->subsysCard) {
-			 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			    "PCI card/vendor identified for non-default PanelDelayCompensation\n");
-			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			     "Vendor: %s, card: %s (ID %04x), PanelDelayCompensation: 0x%02x\n",
-			     mypdctable[i].vendorName, mypdctable[i].cardName,
-			     pSiS->PciInfo->subsysCard, mypdctable[i].pdc);
-			 if(pSiS->PDC == -1) {
-			    pSiS->PDC = mypdctable[i].pdc;
-			 } else {
-			    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-				"PanelDelayCompensation overruled by option\n");
-			 }
-			 break;
-		   }
-		   i++;
-		} while(mypdctable[i].subsysVendor != 0);
-	     }
-
-	     if(pSiS->PDC != -1) {
-		if(pSiS->BIOS) {
-		   if(pSiS->VBFlags2 & VB2_LVDS) {
-		      if(pSiS->BIOS[0x220] & 0x80) {
-			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			     "BIOS uses OEM LCD Panel Delay Compensation 0x%02x\n",
-			     pSiS->BIOS[0x220] & 0x3c);
-			 pSiS->BIOS[0x220] &= 0x7f;
-		      }
-		   }
-		   if(pSiS->VBFlags2 & (VB2_301B | VB2_302B)) {
-		      if(pSiS->BIOS[0x220] & 0x80) {
-			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			     "BIOS uses OEM LCD Panel Delay Compensation 0x%02x\n",
-			       (  (pSiS->VBLCDFlags & VB_LCD_1280x1024) ?
-			                 pSiS->BIOS[0x223] : pSiS->BIOS[0x224]  ) & 0x3c);
-			 pSiS->BIOS[0x220] &= 0x7f;
-		      }
-		   }
-		}
-		pSiS->SiS_Pr->PDC = (pSiS->PDC & 0x3c);
-		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		      "Using LCD Panel Delay Compensation 0x%02x\n", pSiS->SiS_Pr->PDC);
-	     }
-	  }
-
-       }  /* SIS_300_VGA */
-
-       if(pSiS->VGAEngine == SIS_315_VGA) {
-
-	  UChar tmp, tmp2;
-	  inSISIDXREG(SISCR, 0x30, tmp);
-
-	  /* Save the current PDC if the panel is used at the moment. */
-	  if(pSiS->VBFlags2 & VB2_SISLVDSBRIDGE) {
-
-	     if(pSiS->sisfbpdc != 0xff) {
-	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
-	     }
-	     if(pSiS->sisfbpdca != 0xff) {
-	        pSiS->SiS_Pr->PDCA = pSiS->sisfbpdca;
-	     }
-
-	     if(!pSiS->donttrustpdc) {
-	        if((pSiS->sisfbpdc == 0xff) && (pSiS->sisfbpdca == 0xff)) {
-		   CARD16 tempa, tempb;
-		   inSISIDXREG(SISPART1,0x2d,tmp2);
-		   tempa = (tmp2 & 0xf0) >> 3;
-		   tempb = (tmp2 & 0x0f) << 1;
-		   inSISIDXREG(SISPART1,0x20,tmp2);
-		   tempa |= ((tmp2 & 0x40) >> 6);
-		   inSISIDXREG(SISPART1,0x35,tmp2);
-		   tempb |= ((tmp2 & 0x80) >> 7);
-		   inSISIDXREG(SISPART1,0x13,tmp2);
-		   if(!pSiS->ROM661New) {
-		      if((tmp2 & 0x04) || (tmp & 0x20)) {
-		         pSiS->SiS_Pr->PDCA = tempa;
-		         pSiS->SiS_Pr->PDC  = tempb;
-		      } else {
-			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			     "Unable to detect PanelDelayCompensation, LCD is not active\n");
-		      }
-		   } else {
-		      if(tmp2 & 0x04) {
-		         pSiS->SiS_Pr->PDCA = tempa;
-		      } else if(tmp & 0x20) {
-		         pSiS->SiS_Pr->PDC  = tempb;
-		      } else {
-			 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			     "Unable to detect PanelDelayCompensation, LCD is not active\n");
-		      }
-		   }
-		}
-	     } else {
-		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		    "Unable to detect PanelDelayCompensation, please update sisfb\n");
-	     }
-	     if(pSiS->SiS_Pr->PDC != -1) {
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		     "Detected LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
-		     pSiS->SiS_Pr->PDC);
-	     }
-	     if(pSiS->SiS_Pr->PDCA != -1) {
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		     "Detected LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
-		     pSiS->SiS_Pr->PDCA);
-	     }
-	  }
-
-	  /* Let user override (for all bridges) */
-	  if(pSiS->VBFlags2 & VB2_30xBLV) {
-	     if(pSiS->PDC != -1) {
-	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0x1f;
-		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		     "Using LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
-		     pSiS->SiS_Pr->PDC);
-	     }
-	     if(pSiS->PDCA != -1) {
-		pSiS->SiS_Pr->PDCA = pSiS->PDCA & 0x1f;
-		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		     "Using LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
-		     pSiS->SiS_Pr->PDCA);
-	     }
-          }
-
- 	  /* Read the current EMI (if not overruled) */
-	  if(pSiS->VBFlags2 & VB2_SISEMIBRIDGE) {
-	     MessageType from = X_PROBED;
-	     if(pSiS->EMI != -1) {
-		pSiS->SiS_Pr->EMI_30 = (pSiS->EMI >> 24) & 0x60;
-		pSiS->SiS_Pr->EMI_31 = (pSiS->EMI >> 16) & 0xff;
-		pSiS->SiS_Pr->EMI_32 = (pSiS->EMI >> 8)  & 0xff;
-		pSiS->SiS_Pr->EMI_33 = pSiS->EMI & 0xff;
-		pSiS->SiS_Pr->HaveEMI = pSiS->SiS_Pr->HaveEMILCD = TRUE;
-		pSiS->SiS_Pr->OverruleEMI = TRUE;
-		from = X_CONFIG;
-	     } else if((pSiS->sisfbfound) && (pSiS->sisfb_haveemi)) {
-		pSiS->SiS_Pr->EMI_30 = pSiS->sisfb_emi30;
-		pSiS->SiS_Pr->EMI_31 = pSiS->sisfb_emi31;
-		pSiS->SiS_Pr->EMI_32 = pSiS->sisfb_emi32;
-		pSiS->SiS_Pr->EMI_33 = pSiS->sisfb_emi33;
-		pSiS->SiS_Pr->HaveEMI = TRUE;
-		if(pSiS->sisfb_haveemilcd) pSiS->SiS_Pr->HaveEMILCD = TRUE;
-		pSiS->SiS_Pr->OverruleEMI = FALSE;
-	     } else {
-		inSISIDXREG(SISPART4, 0x30, pSiS->SiS_Pr->EMI_30);
-		inSISIDXREG(SISPART4, 0x31, pSiS->SiS_Pr->EMI_31);
-		inSISIDXREG(SISPART4, 0x32, pSiS->SiS_Pr->EMI_32);
-		inSISIDXREG(SISPART4, 0x33, pSiS->SiS_Pr->EMI_33);
-		pSiS->SiS_Pr->HaveEMI = TRUE;
-		if(tmp & 0x20) pSiS->SiS_Pr->HaveEMILCD = TRUE;
-		pSiS->SiS_Pr->OverruleEMI = FALSE;
-	     }
-	     xf86DrvMsg(pScrn->scrnIndex, from,
-		   "302LV/302ELV: Using EMI 0x%02x%02x%02x%02x%s\n",
-		   pSiS->SiS_Pr->EMI_30,pSiS->SiS_Pr->EMI_31,
-		   pSiS->SiS_Pr->EMI_32,pSiS->SiS_Pr->EMI_33,
-		   pSiS->SiS_Pr->HaveEMILCD ? " (LCD)" : "");
-	  }
-
-       } /* SIS_315_VGA */
-#ifdef SISDUALHEAD
-    }
-#endif
-
+    /* Handle panel delay compensation and emi, and evaluate options */
+    SiSHandlePDCEMI(pScrn);
 
     /* In dual head mode, both heads (currently) share the maxxfbmem equally.
      * If memory sharing is done differently, the following has to be changed;
      * the other modules (eg. accel and Xv) use dhmOffset for hardware
      * pointer settings relative to VideoRAM start and won't need to be changed.
      *
-     * Addendum: dhmoffset is also used for skipping the UMA area on SiS76x.
+     * Addendum: dhmoffset is also used for skipping the UMA area on SiS76x. So
+     * DO NOT ONLY add it in dualhead mode cases!
      */
 
     pSiS->dhmOffset = pSiS->FbBaseOffset;
@@ -6018,7 +5432,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	  /* ===== First head (always CRT2) ===== */
 	  /* We use only half of the memory available */
 	  pSiS->maxxfbmem /= 2;
-	  /* dhmOffset is 0 (or LFB-base for SiS76x UMA skipping) */
+	  /* dhmOffset is 0 (or LFB-base for SiS760 UMA skipping) */
 	  pSiS->FbAddress += pSiS->dhmOffset;
 	  xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 	      "%dKB video RAM at 0x%lx available for master head (CRT2)\n",
@@ -6067,136 +5481,18 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        pSiS->DRIheapstart = pSiS->DRIheapend = 0;
     }
 
-    /* Now for something completely different: DDC.
-     * For 300 and 315/330/340 series, we provide our
-     * own functions (in order to probe CRT2 as well)
-     * If these fail, use the VBE.
-     * All other chipsets will use VBE. No need to re-invent
-     * the wheel there.
-     */
 
+    /* DDC/EDID handling */
+    /* (DDC eventually uses the VBE. Make sure that our ptr is NULL) */
     pSiS->pVbe = NULL;
-    didddc2 = FALSE;
 
-    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-       if(xf86LoadSubModule(pScrn, "ddc")) {
-	  int crtnum = 0;
-	  xf86LoaderReqSymLists(ddcSymbols, NULL);
-	  if((pMonitor = SiSDoPrivateDDC(pScrn, &crtnum))) {
-	     didddc2 = TRUE;
-	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, crtnum);
-	     xf86PrintEDID(pMonitor);
-	     xf86SetDDCproperties(pScrn, pMonitor);
-	     pScrn->monitor->DDC = pMonitor;
-	     /* Now try to find out aspect ratio */
-	     SiSFindAspect(pScrn, pMonitor, crtnum);
-	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, crtnum);
-	  }
-       }
-    }
-
-#ifdef SISDUALHEAD
-    /* In dual head mode, probe DDC using VBE only for CRT1 (second head) */
-    if((pSiS->DualHeadMode) && (!didddc2) && (!pSiS->SecondHead)) {
-       didddc2 = TRUE;
-    }
-#endif
-
-    if(!didddc2) {
-       /* If CRT1 is off or LCDA, skip DDC via VBE */
-       if((pSiS->CRT1off) || (pSiS->VBFlags & CRT1_LCDA)) {
-          didddc2 = TRUE;
-       }
-    }
-
-    /* Now (re-)load and initialize the DDC module */
-    if(!didddc2) {
-
-       if(xf86LoadSubModule(pScrn, "ddc")) {
-
-	  xf86LoaderReqSymLists(ddcSymbols, NULL);
-
-	  /* Now load and initialize VBE module. */
-	  SiS_LoadInitVBE(pScrn);
-
-	  if(pSiS->pVbe) {
-	     if((pMonitor = vbeDoEDID(pSiS->pVbe,NULL))) {
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		      "VBE CRT1 DDC monitor info:\n");
-		xf86SetDDCproperties(pScrn, xf86PrintEDID(pMonitor));
-		pScrn->monitor->DDC = pMonitor;
-		/* Now try to find out aspect ratio */
-		SiSFindAspect(pScrn, pMonitor, 1);
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		      "End of VBE CRT1 DDC monitor info\n");
-	     }
-	  } else {
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		 "Failed to read DDC data\n");
-	  }
-       }
-    }
+    /* Read DDC (for CRT1; if not present, CRT2) */
+    SiSGetDDCAndEDID(pScrn);
 
+    /* MergedFB: Setup CRT2 Monitor and read DDC */
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
-       pSiS->CRT2pScrn->monitor = xalloc(sizeof(MonRec));
-       if(pSiS->CRT2pScrn->monitor) {
-	  DisplayModePtr tempm = NULL, currentm = NULL, newm = NULL;
-	  memcpy(pSiS->CRT2pScrn->monitor, pScrn->monitor, sizeof(MonRec));
-	  pSiS->CRT2pScrn->monitor->DDC = NULL;
-	  pSiS->CRT2pScrn->monitor->Modes = NULL;
-	  pSiS->CRT2pScrn->monitor->id = (char *)crt2monname;
-	  tempm = pScrn->monitor->Modes;
-	  while(tempm) {
-	     if(!(newm = xalloc(sizeof(DisplayModeRec)))) break;
-	     memcpy(newm, tempm, sizeof(DisplayModeRec));
-	     if(!(newm->name = xalloc(strlen(tempm->name) + 1))) {
-	        xfree(newm);
-		break;
-	     }
-	     strcpy(newm->name, tempm->name);
-	     if(!pSiS->CRT2pScrn->monitor->Modes) pSiS->CRT2pScrn->monitor->Modes = newm;
-	     if(currentm) {
-	        currentm->next = newm;
-		newm->prev = currentm;
-	     }
-	     currentm = newm;
-	     tempm = tempm->next;
-	  }
-	  if(pSiS->CRT2HSync) {
-	     pSiS->CRT2pScrn->monitor->nHsync =
-		SiSStrToRanges(pSiS->CRT2pScrn->monitor->hsync, pSiS->CRT2HSync, MAX_HSYNC);
-	  }
-	  if(pSiS->CRT2VRefresh) {
-	     pSiS->CRT2pScrn->monitor->nVrefresh =
-		SiSStrToRanges(pSiS->CRT2pScrn->monitor->vrefresh, pSiS->CRT2VRefresh, MAX_VREFRESH);
-	  }
-	  if((pMonitor = SiSInternalDDC(pSiS->CRT2pScrn, 1))) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, 2);
-	     xf86PrintEDID(pMonitor);
-	     xf86SetDDCproperties(pSiS->CRT2pScrn, pMonitor);
-	     pSiS->CRT2pScrn->monitor->DDC = pMonitor;
-	     /* Now try to find out aspect ratio */
-	     SiSFindAspect(pScrn, pMonitor, 2);
-	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, 2);
-	     /* use DDC data if no ranges in config file */
-	     if(!pSiS->CRT2HSync) {
-	        pSiS->CRT2pScrn->monitor->nHsync = 0;
-	     }
-	     if(!pSiS->CRT2VRefresh) {
-	        pSiS->CRT2pScrn->monitor->nVrefresh = 0;
-	     }
-	  } else {
-	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		"Failed to read DDC data for CRT2\n");
-	  }
-       } else {
-	  SISErrorLog(pScrn, "Failed to allocate memory for CRT2 monitor, %s.\n",
-	  		mergeddisstr);
-	  if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
-	  pSiS->CRT2pScrn = NULL;
-	  pSiS->MergedFB = FALSE;
-       }
+       SiSMFBInitMergedFB(pScrn);
     }
 #endif
 
@@ -6206,59 +5502,27 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        if(!pSiS->SecondHead) {
-          /* CRT2: Got gamma for LCD or VGA2 */
+          /* CRT2: Got gamma for LCD(A) or VGA2 */
 	  pSiSEnt->CRT2VGAMonitorGamma = pSiS->CRT2VGAMonitorGamma;
        } else {
-          /* CRT1: Got gamma for LCD or VGA */
+          /* CRT1: Got gamma for LCD(A) or VGA */
 	  pSiSEnt->CRT1VGAMonitorGamma = pSiS->CRT1VGAMonitorGamma;
        }
        if(pSiS->CRT2LCDMonitorGamma) pSiSEnt->CRT2LCDMonitorGamma = pSiS->CRT2LCDMonitorGamma;
     }
 #endif
 
-    /* end of DDC */
-
     /* From here, we mainly deal with clocks and modes */
 
 #ifdef SISMERGED
     if(pSiS->MergedFB) xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 1);
 #endif
 
-    /* Set the min pixel clock */
-    pSiS->MinClock = 5000;
-    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-       pSiS->MinClock = 10000;
-    }
-    xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock is %d MHz\n",
-                pSiS->MinClock / 1000);
 
-    /* If the user has specified ramdac speed in the config
-     * file, we respect that setting.
-     */
-    from = X_PROBED;
-    if(pSiS->pEnt->device->dacSpeeds[0]) {
-       int speed = 0;
-       switch(pScrn->bitsPerPixel) {
-       case 8:  speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP8];
-                break;
-       case 16: speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP16];
-                break;
-       case 24: speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP24];
-                break;
-       case 32: speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP32];
-                break;
-       }
-       if(speed == 0) pSiS->MaxClock = pSiS->pEnt->device->dacSpeeds[0];
-       else           pSiS->MaxClock = speed;
-       from = X_CONFIG;
-    }
-    xf86DrvMsg(pScrn->scrnIndex, from, "Max pixel clock is %d MHz\n",
-                pSiS->MaxClock / 1000);
+    /* Set up min and max pixel clock */
+    SiSSetMinMaxPixelClock(pScrn);
 
-    /*
-     * Setup the ClockRanges, which describe what clock ranges are available,
-     * and what sort of modes they can be used for.
-     */
+    /* Setup the ClockRanges */
     clockRanges = xnfcalloc(sizeof(ClockRange), 1);
     clockRanges->next = NULL;
     clockRanges->minClock = pSiS->MinClock;
@@ -6267,285 +5531,18 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     clockRanges->interlaceAllowed = TRUE;
     clockRanges->doubleScanAllowed = TRUE;
 
-    /*
-     * Since we have lots of built-in modes for 300/315/330/340 series
-     * with vb support, we replace the given default mode list with our
-     * own. In case the video bridge is to be used, we only allow other
-     * modes if
-     *   -) vbtype is 301, 301B, 301C or 302B, and
-     *   -) crt2 device is not TV, and
-     *   -) crt1 is not LCDA, unless bridge is TMDS/LCDA capable (301C)
-     */
-    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-       if(!(pSiS->noInternalModes)) {
-          Bool acceptcustommodes = TRUE;  /* Accept user modelines */
-	  Bool includelcdmodes   = TRUE;  /* Include modes reported by DDC */
-	  Bool isfordvi          = FALSE; /* Is for digital DVI output */
-	  Bool fakecrt2modes     = FALSE; /* Fake some modes for CRT2 */
-	  Bool IsForCRT2	 = FALSE;
-	  if(pSiS->UseVESA) {
-	     acceptcustommodes = FALSE;
-	     includelcdmodes   = FALSE;
-	  }
-#ifdef SISDUALHEAD  /* Dual head is static. Output devices will not change. */
-	  if(pSiS->DualHeadMode) {
-	     if(!pSiS->SecondHead) {  /* CRT2: */
-	        if(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) {
-		   if(!(pSiS->VBFlags2 & VB2_30xBDH)) {
-		      if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
-		      if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
-		      if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
-		   } else {
-		      if(pSiS->VBFlags & (CRT2_TV|CRT2_LCD)) {
-		         acceptcustommodes = FALSE;
-		         includelcdmodes   = FALSE;
-			 fakecrt2modes = TRUE;
-		      }
-		   }
-		} else {
-		   acceptcustommodes = FALSE;
-		   includelcdmodes   = FALSE;
-		   if(pSiS->VBFlags & (CRT2_TV|CRT2_LCD)) {
-		      fakecrt2modes = TRUE;
-		   }
-		}
-		clockRanges->interlaceAllowed = FALSE;
-		IsForCRT2 = TRUE;
-	     } else {		/* CRT1: */
-	        if(pSiS->VBFlags & CRT1_LCDA) {
-		   if(!(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)) {
-		      acceptcustommodes = FALSE;
-		      includelcdmodes   = FALSE;
-		      fakecrt2modes     = TRUE;
-		      /* Will handle i-lace in mode-switching code */
-		   } else {
-		      isfordvi = TRUE;
-		      /* Don't allow i-lace modes */
-		      clockRanges->interlaceAllowed = FALSE;
-		   }
-		} else {
-		   includelcdmodes = FALSE;
-		}
-	     }
-	  } else
-#endif
-#ifdef SISMERGED  /* MergedFB mode is not static. Output devices may change. */
-          if(pSiS->MergedFB) {
-	     if(pSiS->VBFlags & CRT1_LCDA) {
-	        if(!(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)) {
-		   acceptcustommodes = FALSE;
-		   includelcdmodes   = FALSE;
-		   fakecrt2modes     = TRUE;
-		   /* Will handle i-lace in mode-switching code */
-		} else {
-		   isfordvi = TRUE;
-		   /* Don't allow i-lace custom modes */
-		   clockRanges->interlaceAllowed = FALSE;
-		}
-	     } else {
-	        includelcdmodes = FALSE;
-	     }
-          } else
-#endif		 /* Mirror mode is not static. Output devices may change. */
-          if(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) {
-	     if(!(pSiS->VBFlags2 & VB2_30xBDH)) {
-		if(!(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE)) {
-		   if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes = FALSE;
-		   if(pSiS->VBFlags & CRT2_LCD)               isfordvi        = TRUE;
-		} else {
-		   if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA|CRT1_LCDA))) includelcdmodes = FALSE;
-		   if(pSiS->VBFlags & (CRT2_LCD|CRT1_LCDA))             isfordvi        = TRUE;
-		}
-		if((!(pSiS->VBFlags & DISPTYPE_CRT1)) && (!(pSiS->VBFlags & CRT1_LCDA))) {
-		   IsForCRT2 = TRUE;
-		}
-		/* Allow user modes, even if CRT2 is TV. Will be filtered through ValidMode();
-		 * leaving the user modes here might have the advantage that such a mode, if
-		 * it matches in resolution with a supported TV mode, allows us to drive eg.
-		 * non standard panels, and still permits switching to TV. This mode will be
-		 * "mapped" to a supported mode of identical resolution for TV. All this is
-		 * taken care of by ValidMode() and ModeInit()/PresetMode().
-		 */
-	     } else {
-		if(pSiS->VBFlags & (CRT2_TV|CRT2_LCD)) {
-		   acceptcustommodes = FALSE;
-		   includelcdmodes   = FALSE;
-		   if(!(pSiS->VBFlags & DISPTYPE_CRT1)) {
-		      fakecrt2modes = TRUE;
-		      IsForCRT2 = TRUE;
-		   }
-		}
-	     }
-	  } else if(pSiS->VBFlags & (CRT2_ENABLE | CRT1_LCDA)) {
-	     acceptcustommodes = FALSE;
-	     includelcdmodes   = FALSE;
-	     if((pSiS->VBFlags & CRT1_LCDA) || (!(pSiS->VBFlags & DISPTYPE_CRT1))) {
-		fakecrt2modes = TRUE;
-		IsForCRT2 = TRUE;
-	     }
-	  } else {
-	     includelcdmodes   = FALSE;
-	  }
-	  /* Ignore interlace, mode switching code will handle this */
-
-	  pSiS->HaveCustomModes = FALSE;
-	  if(SiSMakeOwnModeList(pScrn, acceptcustommodes, includelcdmodes,
-			isfordvi, &pSiS->HaveCustomModes, FALSE /*fakecrt2modes*/, IsForCRT2)) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		 "Replaced %s mode list with built-in modes\n",
-	     pSiS->HaveCustomModes ? "default" : "entire");
-	     if(pSiS->VGAEngine == SIS_315_VGA) {
-		int UseWide = pSiS->SiS_Pr->SiS_UseWide;
-		if(IsForCRT2) UseWide = pSiS->SiS_Pr->SiS_UseWideCRT2;
-		if((!IsForCRT2) || (pSiS->VBFlags2 & VB2_SISVGA2BRIDGE)) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"Using %s widescreen modes for CRT%d VGA devices\n",
-			UseWide ? "real" : "fake", IsForCRT2 ? 2 : 1);
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"\tUse option \"ForceCRT%dVGAAspect\" to overrule\n",
-			IsForCRT2 ? 2 : 1);
-		}
-	     }
-#ifdef TWDEBUG
-             pScrn->modes = pScrn->monitor->Modes;
-	     xf86PrintModes(pScrn);
-	     pScrn->modes = NULL;
-#endif
-          } else {
-	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		"Building list of built-in modes failed, using server defaults\n");
-	  }
-       } else {
-          pSiS->HaveCustomModes = TRUE;
-       }
-    }
+    /* Replace default mode list */
+    SiSReplaceModeList(pScrn, clockRanges, FALSE);
 
     /* Add our built-in hi-res and TV modes on the 6326 */
-    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
-       if(pScrn->bitsPerPixel == 8) {
-	  SiS6326SIS1600x1200_60Mode.next = pScrn->monitor->Modes;
-	  pScrn->monitor->Modes = &SiS6326SIS1600x1200_60Mode;
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	  	"Adding mode \"SIS1600x1200-60\" (depth 8 only)\n");
-       }
-       if(pScrn->bitsPerPixel <= 16) {
-	  SiS6326SIS1280x1024_75Mode.next = pScrn->monitor->Modes;
-	  pScrn->monitor->Modes = &SiS6326SIS1280x1024_75Mode;
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	  	"Adding mode \"SIS1280x1024-75\" (depths 8, 15 and 16 only)\n");
-       }
-       if((pSiS->SiS6326Flags & SIS6326_HASTV) &&
-	  (pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		"Adding %s TV modes to mode list:\n",
-		(pSiS->SiS6326Flags & SIS6326_TVPAL) ? "PAL" : "NTSC");
-	  if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
-	     SiS6326PAL800x600Mode.next = pScrn->monitor->Modes;
-	     pScrn->monitor->Modes = &SiS6326PAL640x480Mode;
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		"\t\"PAL800x600\" \"PAL800x600U\" \"PAL720x540\" \"PAL640x480\"\n");
-	  } else {
-	     SiS6326NTSC640x480Mode.next = pScrn->monitor->Modes;
-	     pScrn->monitor->Modes = &SiS6326NTSC640x400Mode;
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		"\t\"NTSC640x480\" \"NTSC640x480U\" \"NTSC640x400\"\n");
-	  }
-       }
-    }
-
-   /* If there is no HSync or VRefresh data for the monitor,
-    * derive it from DDC data. Essentially done by common layer
-    * since 4.3.99.14, but this is not usable since it is done
-    * too late (in ValidateModes()).
-    * Addendum: I overrule the ranges now in any case unless
-    * it would affect a CRT output device or DDC data is available.
-    * Hence, for LCD(A) and TV, we always get proper ranges. This
-    * is entirely harmless. However, option "NoOverruleRanges" will
-    * disable this behavior.
-    * This should "fix" the - by far - most common configuration
-    * mistakes.
-    */
-
-    crt1freqoverruled = FALSE;
-
-    fromDDC = FALSE;
-    if((pScrn->monitor->nHsync <= 0) || (pSiS->OverruleRanges)) {
-       if((pScrn->monitor->nHsync <= 0) && (pScrn->monitor->DDC)) {
-	  SiSSetSyncRangeFromEdid(pScrn, 1);
-	  if(pScrn->monitor->nHsync > 0) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr,
-#ifdef SISDUALHEAD
-			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
-#endif
-				pSiS->CRT1off ? 2 : 1);
-	     fromDDC = TRUE;
-	  }
-       }
-       if((pScrn->monitor->nHsync <= 0) || (pSiS->OverruleRanges)) {
-	  if(SiSAllowSyncOverride(pSiS, fromDDC)) {
-	     Bool HaveNoRanges = (pScrn->monitor->nHsync <= 0);
-	     /* Set sane ranges for LCD and TV
-	      * (our strict checking will filter out invalid ones anyway)
-	      */
-	     if((crt1freqoverruled = CheckAndOverruleH(pScrn, pScrn->monitor))) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, saneh,
-			HaveNoRanges ? "missing" : "bogus",
-#ifdef SISDUALHEAD
-			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
-#endif
-				pSiS->CRT1off ? 2 : 1);
-	     }
-	  }
-       }
-    }
+    SiS6326AddHiresAndTVModes(pScrn);
 
-    fromDDC = FALSE;
-    if((pScrn->monitor->nVrefresh <= 0) || (pSiS->OverruleRanges)) {
-       if((pScrn->monitor->nVrefresh <= 0) && (pScrn->monitor->DDC)) {
-	  SiSSetSyncRangeFromEdid(pScrn, 0);
-	  if(pScrn->monitor->nVrefresh > 0) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr,
-#ifdef SISDUALHEAD
-			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
-#endif
-				pSiS->CRT1off ? 2 : 1);
-	     fromDDC = TRUE;
-          }
-       }
-       if((pScrn->monitor->nVrefresh <= 0) || (pSiS->OverruleRanges)) {
-	  if(SiSAllowSyncOverride(pSiS, fromDDC)) {
-	     Bool HaveNoRanges = (pScrn->monitor->nVrefresh <= 0);
-	     /* Set sane ranges for LCD and TV */
-	     if((crt1freqoverruled = CheckAndOverruleV(pScrn, pScrn->monitor))) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, sanev,
-			HaveNoRanges ? "missing" : "bogus",
-#ifdef SISDUALHEAD
-			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
-#endif
-				pSiS->CRT1off ? 2 : 1);
-	     }
-	  }
-       }
-    }
+    /* Fixup HorizSync, VertRefresh ranges */
+    crt1freqoverruled = SiSFixupHVRanges(pScrn, 1, FALSE);
 
-    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	  "\"Unknown reason\" in the following list means that the mode\n");
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	  "is not supported on the chipset/bridge/current output device.\n");
-    }
 
-    /*
-     * xf86ValidateModes will check that the mode HTotal and VTotal values
-     * don't exceed the chipset's limit if pScrn->maxHValue and
-     * pScrn->maxVValue are set.  Since our SISValidMode() already takes
-     * care of this, we don't worry about setting them here.
-     */
+    /* Screen size determination, display mode validation */
 
-    /* Select valid modes from those available */
-    /*
-     * Assuming min pitch 256, min height 128
-     */
     {
        int minpitch, maxpitch, minheight, maxheight;
        pointer backupddc = pScrn->monitor->DDC;
@@ -6569,6 +5566,39 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
           break;
        }
 
+       /* Find out user-desired virtual screen size.
+        * If "Virtual" is given, use that. Otherwise,
+        * scan all modes named in the "Modes" list and
+        * find out about the largest one. We then use
+        * this as the virtual, but use RandR in our
+        * CreateScreenResources wrapper to switch to
+        * the size of the largest mode that survived
+        * validation.
+        * All this in order to be able to change the
+        * size upon device hotplugging and redetection.
+        * Since device hotplugging is not supported in
+        * dual head mode, we can skip all this.
+        * TODO: MergedFB mode. That's a real bugger as
+        * it requires scanning through the MetaModes
+        * list. Sigh. I think this can be done way
+        * later since we eventually correct the
+        * virtual screen size anyway. Hm.
+        */
+
+
+      /*
+       * xf86ValidateModes will check that the mode HTotal and VTotal values
+       * don't exceed the chipset's limit if pScrn->maxHValue and
+       * pScrn->maxVValue are set. Since our SISValidMode() already takes
+       * care of this, we don't worry about setting them here.
+       */
+
+       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	     "\"Unknown reason\" in the following list means that the mode\n");
+          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	     "is not supported on the chipset/bridge/current output device.\n");
+       }
 #ifdef SISMERGED
        pSiS->CheckForCRT2 = FALSE;
 #endif
@@ -6576,8 +5606,25 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        /* Suppress bogus DDC warning */
        if(crt1freqoverruled) pScrn->monitor->DDC = NULL;
 
-       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
-			pScrn->display->modes, clockRanges, NULL,
+#if !defined(XORG_VERSION_CURRENT) && (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,5,0,0,0))
+       /* XFree86 4.5+ thinks it's smart to automatically
+        * add EDID modes to the monitor mode list. We do
+        * not like this if we discarded all default and
+        * user modes because they aren't suppored. Hence,
+        * we clear the DDC pointer in that case (and live
+        * with the disadvantage that we don't get any
+        * DDC warnings.)
+        */
+       if(!pSiS->HaveCustomModes) {
+          pScrn->monitor->DDC = NULL;
+       }
+#endif
+
+       i = xf86ValidateModes(pScrn,
+			pScrn->monitor->Modes,
+			pScrn->display->modes,
+			clockRanges,
+			NULL,
 			minpitch, maxpitch,
 			pScrn->bitsPerPixel * 8,
 			minheight, maxheight,
@@ -6596,7 +5643,7 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 
     /* Check the virtual screen against the available memory */
     {
-       ULong memreq = (pScrn->virtualX * ((pScrn->bitsPerPixel + 7) / 8)) * pScrn->virtualY;
+       ULong memreq = pScrn->virtualX * (pScrn->bitsPerPixel >> 3) * pScrn->virtualY;
 
        if(memreq > pSiS->maxxfbmem) {
 	  SISErrorLog(pScrn,
@@ -6614,39 +5661,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 #ifdef SISDUALHEAD
     if((pSiS->DualHeadMode) && (!pSiS->SecondHead)) {
 
-       pSiSEnt->maxUsedClock = 0;
-
-       if((p = first = pScrn->modes)) {
+       pSiSEnt->maxUsedClock = SiSRemoveUnsuitableModes(pScrn, pScrn->modes, "dual head", FALSE);
 
-	  do {
-
-	     n = p->next;
-
-	     /* Modes that require the bridge to operate in SlaveMode
-	      * are not suitable for Dual Head mode.
-	      */
-	     if( (pSiS->VGAEngine == SIS_300_VGA) &&
-		 ( (strcmp(p->name, "320x200") == 0) ||
-		   (strcmp(p->name, "320x240") == 0) ||
-		   (strcmp(p->name, "400x300") == 0) ||
-		   (strcmp(p->name, "512x384") == 0) ||
-		   (strcmp(p->name, "640x400") == 0) ) )  {
-		p->status = MODE_BAD;
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "dual head");
-	     }
-
-	     /* Search for the highest clock on first head in order to calculate
-	      * max clock for second head (CRT1)
-	      */
-	     if((p->status == MODE_OK) && (p->Clock > pSiSEnt->maxUsedClock)) {
-		pSiSEnt->maxUsedClock = p->Clock;
-	     }
-
-	     p = n;
-
-	  } while (p != NULL && p != first);
-
-       }
     }
 #endif
 
@@ -6660,6 +5676,21 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 
     xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V);
 
+    /* Clear the modes' Private field */
+    SiSClearModesPrivate(pScrn->modes);
+
+    /* Save virtualX/Y calculated by ValidateModes
+     * and overwrite them with our values assumed to
+     * be desired.
+     * We let PreInit and ScreenInit run with these
+     * in order to get a screen pixmap and root
+     * window of the maximum (desired) size. After
+     * ScreenInit() and after RandR and other extensions
+     * have been initialized, we reset the values (also
+     * in RandR's private) and call RRSetMode in order
+     * to make them effective.
+     */
+
     /* Set the current mode to the first in the list */
     pScrn->currentMode = pScrn->modes;
 
@@ -6667,7 +5698,6 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     pSiS->CurrentLayout.mode = pScrn->currentMode;
     pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;
     pSiS->CurrentLayout.displayHeight = pScrn->virtualY;
-
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 1);
@@ -6676,14 +5706,19 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 
     /* Print the list of modes being used */
     {
-       Bool usemyprint = FALSE;
+       Bool usemyprint = FALSE, printfreq = TRUE;
 
 #ifdef SISDUALHEAD
        if(pSiS->DualHeadMode) {
 	  if(pSiS->SecondHead) {
 	     if(pSiS->VBFlags & CRT1_LCDA) usemyprint = TRUE;
 	  } else {
-	     if(pSiS->VBFlags & (CRT2_LCD | CRT2_TV)) usemyprint = TRUE;
+	     if(pSiS->VBFlags & (CRT2_LCD | CRT2_TV)) {
+	        usemyprint = TRUE;
+	        if(!(pSiS->VBFlags2 & VB2_SISVGA2BRIDGE)) {
+	           printfreq = FALSE;
+	        }
+	     }
 	  }
        } else
 #endif
@@ -6699,243 +5734,43 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        }
 
        if(usemyprint) {
-	  SiSPrintModes(pScrn);
+	  SiSPrintModes(pScrn, printfreq);
        } else {
 	  xf86PrintModes(pScrn);
        }
     }
 
+    /* MergedFB: Setup CRT2, MetaModes and display size */
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
-       Bool acceptcustommodes = TRUE;
-       Bool includelcdmodes   = TRUE;
-       Bool isfordvi          = FALSE;
-       Bool fakecrt2modes     = FALSE;
-
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 2);
-
-       clockRanges->next = NULL;
-       clockRanges->minClock = pSiS->MinClock;
-       clockRanges->maxClock = SiSMemBandWidth(pSiS->CRT2pScrn, TRUE);
-       clockRanges->clockIndex = -1;
-       clockRanges->interlaceAllowed = FALSE;
-       clockRanges->doubleScanAllowed = FALSE;
-       if(pSiS->VGAEngine == SIS_315_VGA) {
-          clockRanges->doubleScanAllowed = TRUE;
-       }
-
-       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock for CRT2 is %d MHz\n",
-                clockRanges->minClock / 1000);
-       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Max pixel clock for CRT2 is %d MHz\n",
-                clockRanges->maxClock / 1000);
-
-       if(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) {
-          if(!(pSiS->VBFlags2 & VB2_30xBDH)) {
-             if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
-	     if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
-	     /* See above for a remark on handling CRT2 = TV */
-	  } else {
-	     if(pSiS->VBFlags & (CRT2_LCD|CRT2_TV)) {
-		includelcdmodes   = FALSE;
-		acceptcustommodes = FALSE;
-		fakecrt2modes     = TRUE;
-	     }
-	  }
-       } else {
-	  includelcdmodes   = FALSE;
-	  acceptcustommodes = FALSE;
-	  if(pSiS->VBFlags & (CRT2_LCD|CRT2_TV)) {
-	     fakecrt2modes = TRUE;
-	  }
-       }
-
-       pSiS->HaveCustomModes2 = FALSE;
-       if(!SiSMakeOwnModeList(pSiS->CRT2pScrn, acceptcustommodes, includelcdmodes,
-				isfordvi, &pSiS->HaveCustomModes2, FALSE /* fakecrt2modes */, TRUE )) {
-
-	  SISErrorLog(pScrn, "Building list of built-in modes for CRT2 failed, %s\n",
-				mergeddisstr);
-	  SiSFreeCRT2Structs(pSiS);
-	  pSiS->MergedFB = FALSE;
-
-       } else {
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		 "Replaced %s mode list for CRT2 with built-in modes\n",
-		 pSiS->HaveCustomModes2 ? "default" : "entire");
-	  if((pSiS->VGAEngine == SIS_315_VGA) && (pSiS->VBFlags2 & VB2_SISVGA2BRIDGE)) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		 "Using %s widescreen modes for CRT2 VGA devices\n",
-		 pSiS->SiS_Pr->SiS_UseWideCRT2 ? "real" : "fake");
-	  } else pSiS->SiS_Pr->SiS_UseWideCRT2 = 0;
-       }
-
+       SiSMFBHandleModesCRT2(pScrn, clockRanges);
     }
 
     if(pSiS->MergedFB) {
-
-       pointer backupddc;
-
-       crt2freqoverruled = FALSE;
-
-       fromDDC = FALSE;
-       if((pSiS->CRT2pScrn->monitor->nHsync <= 0) || (pSiS->OverruleRanges)) {
-          if((pSiS->CRT2pScrn->monitor->nHsync <= 0) && (pSiS->CRT2pScrn->monitor->DDC)) {
-	     SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 1);
-	     if(pSiS->CRT2pScrn->monitor->nHsync > 0) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr, 2);
-		fromDDC = TRUE;
-	     }
-	  }
-	  if((pSiS->CRT2pScrn->monitor->nHsync <= 0) || (pSiS->OverruleRanges)) {
-	     if( (pSiS->VBFlags & CRT2_TV) ||
-	         ((pSiS->VBFlags & CRT2_LCD) && (!fromDDC)) ) {
-		Bool HaveNoRanges = (pSiS->CRT2pScrn->monitor->nHsync <= 0);
-		/* Set sane ranges for LCD and TV */
-		if((crt2freqoverruled = CheckAndOverruleH(pScrn, pSiS->CRT2pScrn->monitor))) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, saneh,
-			HaveNoRanges ? "missing" : "bogus", 2);
-		}
-	     }
-	  }
-       }
-
-       fromDDC = FALSE;
-       if((pSiS->CRT2pScrn->monitor->nVrefresh <= 0) || (pSiS->OverruleRanges)) {
-	  if((pSiS->CRT2pScrn->monitor->nVrefresh <= 0) && (pSiS->CRT2pScrn->monitor->DDC)) {
-	     SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 0);
-	     if(pSiS->CRT2pScrn->monitor->nVrefresh > 0) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr, 2);
-		fromDDC = TRUE;
-	     }
-          }
-	  if((pSiS->CRT2pScrn->monitor->nVrefresh <= 0) || (pSiS->OverruleRanges)) {
-	     if( (pSiS->VBFlags & CRT2_TV) ||
-	         ((pSiS->VBFlags & CRT2_LCD) && (!fromDDC)) ) {
-		Bool HaveNoRanges = (pSiS->CRT2pScrn->monitor->nVrefresh <= 0);
-		/* Set sane ranges for LCD and TV */
-		if((crt2freqoverruled = CheckAndOverruleV(pScrn, pSiS->CRT2pScrn->monitor))) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, sanev,
-			 HaveNoRanges ? "missing" : "bogus", 2);
-	        }
-	     }
-	  }
-       }
-
-       backupddc = pSiS->CRT2pScrn->monitor->DDC;
-
-       /* Suppress bogus DDC warning */
-       if(crt2freqoverruled) pSiS->CRT2pScrn->monitor->DDC = NULL;
-
-       pSiS->CheckForCRT2 = TRUE;
-
-       i = xf86ValidateModes(pSiS->CRT2pScrn, pSiS->CRT2pScrn->monitor->Modes,
-			pSiS->CRT2pScrn->display->modes, clockRanges,
-			NULL, 256, 4088,
-			pSiS->CRT2pScrn->bitsPerPixel * 8, 128, 4096,
-			pScrn->display->virtualX ? pScrn->virtualX : 0,
-			pScrn->display->virtualY ? pScrn->virtualY : 0,
-			pSiS->maxxfbmem,
-			LOOKUP_BEST_REFRESH);
-
-       pSiS->CheckForCRT2 = FALSE;
-       pSiS->CRT2pScrn->monitor->DDC = backupddc;
-
-       if(i == -1) {
-	  SISErrorLog(pScrn, "xf86ValidateModes() error, %s.\n", mergeddisstr);
-	  SiSFreeCRT2Structs(pSiS);
-	  pSiS->MergedFB = FALSE;
-       }
-
+       SiSMFBMakeModeList(pScrn);
     }
 
     if(pSiS->MergedFB) {
-
-       if((p = first = pSiS->CRT2pScrn->modes)) {
-          do {
-	     n = p->next;
-	     if( (pSiS->VGAEngine == SIS_300_VGA) &&
-		 ( (strcmp(p->name, "320x200") == 0) ||
-		   (strcmp(p->name, "320x240") == 0) ||
-		   (strcmp(p->name, "400x300") == 0) ||
-		   (strcmp(p->name, "512x384") == 0) ||
-		   (strcmp(p->name, "640x400") == 0) ) )  {
-		p->status = MODE_BAD;
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "MergedFB");
-	     }
-	     p = n;
-	  } while (p != NULL && p != first);
-       }
-
-       xf86PruneDriverModes(pSiS->CRT2pScrn);
-
-       if(i == 0 || pSiS->CRT2pScrn->modes == NULL) {
-	  SISErrorLog(pScrn, "No valid modes found for CRT2; %s\n", mergeddisstr);
-	  SiSFreeCRT2Structs(pSiS);
-	  pSiS->MergedFB = FALSE;
-       }
-
-    }
-
-    if(pSiS->MergedFB) {
-
-       xf86SetCrtcForModes(pSiS->CRT2pScrn, INTERLACE_HALVE_V);
-
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 2);
-
-       if(pSiS->VBFlags & (CRT2_LCD | CRT2_TV)) {
-	  SiSPrintModes(pSiS->CRT2pScrn);
-       } else {
-	  xf86PrintModes(pSiS->CRT2pScrn);
-       }
-
-       pSiS->CRT1Modes = pScrn->modes;
-       pSiS->CRT1CurrentMode = pScrn->currentMode;
-
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MergedFB: Generating mode list\n");
-
-       pScrn->modes = SiSGenerateModeList(pScrn, pSiS->MetaModes,
-					  pSiS->CRT1Modes, pSiS->CRT2pScrn->modes,
-					  pSiS->CRT2Position);
-
-       if(!pScrn->modes) {
-
-	  SISErrorLog(pScrn, "Failed to parse MetaModes or no modes found. %s.\n",
-			mergeddisstr);
-	  SiSFreeCRT2Structs(pSiS);
-	  pScrn->modes = pSiS->CRT1Modes;
-	  pSiS->CRT1Modes = NULL;
-	  pSiS->MergedFB = FALSE;
-
-       }
-
-    }
-
-    if(pSiS->MergedFB) {
-
-       /* If no virtual dimension was given by the user,
-	* calculate a sane one now. Adapts pScrn->virtualX,
-	* pScrn->virtualY and pScrn->displayWidth.
-	*/
-       SiSRecalcDefaultVirtualSize(pScrn);
-
-       pScrn->modes = pScrn->modes->next;  /* We get the last from GenerateModeList(), skip to first */
-       pScrn->currentMode = pScrn->modes;
-
-       /* Update CurrentLayout */
-       pSiS->CurrentLayout.mode = pScrn->currentMode;
-       pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;
-       pSiS->CurrentLayout.displayHeight = pScrn->virtualY;
-
+       SiSMFBCorrectVirtualAndLayout(pScrn);
     }
 #endif
 
+    /* Don't need the clock ranges from here on */
+    xfree(clockRanges);
+
     /* Set display resolution */
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
-       SiSMergedFBSetDpi(pScrn, pSiS->CRT2pScrn, pSiS->CRT2Position);
+       SiSMFBSetDpi(pScrn, pSiS->CRT2pScrn, pSiS->CRT2Position);
     } else
 #endif
-       xf86SetDpi(pScrn, 0, 0);
+    {
+       {
+          xf86SetDpi(pScrn, 0, 0);
+          pSiS->SiSDPIVX = pScrn->virtualX;
+          pSiS->SiSDPIVY = pScrn->virtualY;
+       }
+    }
 
     /* Load fb module */
     switch(pScrn->bitsPerPixel) {
@@ -6956,35 +5791,31 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 
     /* Load XAA/EXA (if needed) */
     if(!pSiS->NoAccel) {
+       char *modName = NULL;
        const char **symNames = NULL;
 #ifdef SIS_USE_XAA
        if(!pSiS->useEXA) {
-	  if (!xf86LoadSubModule(pScrn, "xaa")) {
-	    SISErrorLog(pScrn, "Could not load xaa module\n");
-	    goto my_error_1;
-	  }
+	  modName = "xaa";
 	  symNames = xaaSymbols;
        }
 #endif
 #ifdef SIS_USE_EXA
        if(pSiS->useEXA) {
-	  XF86ModReqInfo req;
-	  int errmaj, errmin;
-
-	  memset(&req, 0, sizeof(req));
-	  req.majorversion = 2;
-	  req.minorversion = 0;
-	  if (!LoadSubModule(pScrn->module, "exa", NULL, NULL, NULL, &req,
-	    &errmaj, &errmin)) {
-	    LoaderErrorMsg(NULL, "exa", errmaj, errmin);
-	    goto my_error_1;
-	  }
+	  modName = "exa";
 	  symNames = exaSymbols;
        }
 #endif
-       if(symNames) {
+       if(modName && (!xf86LoadSubModule(pScrn, modName))) {
+	  SISErrorLog(pScrn, "Could not load %s module\n", modName);
+	  pSiS->NoAccel = TRUE;
+#ifdef SIS_USE_EXA
+	  if(pSiS->useEXA) {
+	     pSiS->NoXvideo = TRUE;
+	  }
+#endif
+       } else if(symNames) {
 	  xf86LoaderReqSymLists(symNames, NULL);
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "2D acceleration enabled\n");
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "2D acceleration enabled, modename %s\n",modName);
        }
     }
 
@@ -6992,9 +5823,14 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     if(pSiS->ShadowFB) {
        if(!xf86LoadSubModule(pScrn, "shadowfb")) {
 	  SISErrorLog(pScrn, "Could not load shadowfb module\n");
-	  goto my_error_1;
+	  if(pSiS->ShadowFB) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ShadowFB support disabled\n");
+	     pSiS->ShadowFB = FALSE;
+	     pSiS->Rotate = pSiS->Reflect = 0;
+	  }
+       } else {
+          xf86LoaderReqSymLists(shadowSymbols, NULL);
        }
-       xf86LoaderReqSymLists(shadowSymbols, NULL);
     }
 
     /* Load the dri and glx modules if requested. */
@@ -7013,6 +5849,8 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 	     SISErrorLog(pScrn, "Failed to load dri module\n");
 	  }
        }
+	else 
+		pSiS->DRIEnabled = TRUE;
     }
 #endif
 
@@ -7048,14 +5886,14 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
     xf86SetPrimInitDone(pScrn->entityList[0]);
 #endif
 
-    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
+    sisRestoreExtRegisterLock(pSiS, srlockReg, crlockReg);
 
     if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
     pSiS->pInt = NULL;
 
-    if(pSiS->VGAEngine == SIS_315_VGA) {
+    /* Set up flags */
+    if(pSiS->VGAEngine == SIS_315_VGA)
        pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTXVGAMMA1;
-    }
 
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
@@ -7065,14 +5903,14 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
 #ifdef PANORAMIX
 	if(!noPanoramiXExtension) {
 	   pSiS->SiS_SD_Flags |= SiS_SD_ISDHXINERAMA;
-	   /* pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1); */
 	}
 #endif
     }
 #endif
 
 #ifdef SISMERGED
-    if(pSiS->MergedFB) pSiS->SiS_SD_Flags |= SiS_SD_ISMERGEDFB;
+    if(pSiS->MergedFB)
+       pSiS->SiS_SD_Flags |= SiS_SD_ISMERGEDFB;
 #endif
 
     /* Try to determine if this is a laptop   */
@@ -7108,11 +5946,30 @@ SISPreInit(ScrnInfoPtr pScrn, int flags)
        }
     }
 
-    if(pSiS->enablesisctrl) pSiS->SiS_SD_Flags |= SiS_SD_ENABLED;
+    if(pSiS->enablesisctrl)
+       pSiS->SiS_SD_Flags |= SiS_SD_ENABLED;
 
+    /* Back up currentMode and VBFlags */
     pSiS->currentModeLast = pScrn->currentMode;
     pSiS->VBFlagsInit = pSiS->VBFlags;
+    pSiS->VBFlags3Init = pSiS->VBFlags3;
 
+  /*hot-key switch state flag during booting record here.*/
+    if((pSiS->VBFlags & SINGLE_MODE) && (pSiS->VBFlags & DISPTYPE_DISP2))
+    {
+        pSiS->Hkey_Device_Switch_State = LCD_only;  
+    }	
+    else
+    {	if(pSiS->VBFlags & MIRROR_MODE)
+	{
+	    pSiS->Hkey_Device_Switch_State = LCD_VGA_mirror;
+	}
+    }	
+    pSiS->suspended = FALSE;
+    	
+    /*xf86DrvMsg(0,X_INFO,"CurrentMode=%d. \n",pSiS->Hkey_Device_Switch_State);
+    xf86DrvMsg(0,X_INFO,"Init_VBFlags=0X%x. \n",pSiS->VBFlags);*/
+    
     return TRUE;
 
     /* ---- */
@@ -7129,6 +5986,10 @@ my_error_0:
     return FALSE;
 }
 
+/*************************************************/
+/*             Map/unmap memory, mmio            */
+/*************************************************/
+
 /*
  * Map I/O port area for non-PC platforms
  */
@@ -7144,15 +6005,48 @@ SISMapIOPMem(ScrnInfoPtr pScrn)
         pSiSEnt->MapCountIOPBase++;
         if(!(pSiSEnt->IOPBase)) {
 	     /* Only map if not mapped previously */
+#ifndef XSERVER_LIBPCIACCESS
 	     pSiSEnt->IOPBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
 			pSiS->PciTag, pSiS->IOPAddress, 128);
+#else
+	     {
+	       void **result = (void **)&pSiSEnt->IOPBase;
+	       int err = pci_device_map_range(pSiS->PciInfo,
+					      pSiS->IOPAddress,
+					      128,
+					      PCI_DEV_MAP_FLAG_WRITABLE,
+					      result);
+
+	       if (err) {
+                 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                             "Unable to map IO aperture. %s (%d)\n",
+                             strerror (err), err);
+	       }
+	     }
+#endif
         }
         pSiS->IOPBase = pSiSEnt->IOPBase;
     } else
 #endif
-	pSiS->IOPBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
+#ifndef XSERVER_LIBPCIACCESS
+	     pSiS->IOPBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
 			pSiS->PciTag, pSiS->IOPAddress, 128);
-
+#else
+	     {
+	       void **result = (void **)&pSiS->IOPBase;
+	       int err = pci_device_map_range(pSiS->PciInfo,
+					      pSiS->IOPAddress,
+					      128,
+					      PCI_DEV_MAP_FLAG_WRITABLE,
+					      result);
+
+	       if (err) {
+                 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                             "Unable to map IO aperture. %s (%d)\n",
+                             strerror (err), err);
+	       }
+	     }
+#endif
     if(pSiS->IOPBase == NULL) {
 	SISErrorLog(pScrn, "Could not map I/O port area\n");
 	return FALSE;
@@ -7222,14 +6116,46 @@ SISMapMem(ScrnInfoPtr pScrn)
         pSiSEnt->MapCountIOBase++;
         if(!(pSiSEnt->IOBase)) {
 	     /* Only map if not mapped previously */
+#ifndef XSERVER_LIBPCIACCESS
     	     pSiSEnt->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                          pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
+#else
+	     void **result = (void **)&pSiSEnt->IOBase;
+	     int err = pci_device_map_range(pSiS->PciInfo,
+ 	                                    pSiS->IOAddress,
+	                                    (pSiS->mmioSize * 1024),
+                                            PCI_DEV_MAP_FLAG_WRITABLE,
+                                            result);
+
+             if (err) {
+                 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                             "Unable to map IO aperture. %s (%d)\n",
+                             strerror (err), err);
+	     }
+#endif
         }
         pSiS->IOBase = pSiSEnt->IOBase;
     } else
 #endif
+#ifndef XSERVER_LIBPCIACCESS
     	pSiS->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                         pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
+#else
+       {
+	     void **result = (void **)&pSiS->IOBase;
+	     int err = pci_device_map_range(pSiS->PciInfo,
+ 	                                    pSiS->IOAddress,
+	                                    (pSiS->mmioSize * 1024),
+                                            PCI_DEV_MAP_FLAG_WRITABLE,
+                                            result);
+
+             if (err) {
+                 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                             "Unable to map IO aperture. %s (%d)\n",
+                             strerror (err), err);
+	     }
+       }
+#endif
 
     if(pSiS->IOBase == NULL) {
     	SISErrorLog(pScrn, "Could not map MMIO area\n");
@@ -7246,14 +6172,42 @@ SISMapMem(ScrnInfoPtr pScrn)
         pSiSEnt->MapCountIOBaseDense++;
         if(!(pSiSEnt->IOBaseDense)) {
 	     /* Only map if not mapped previously */
+#ifndef XSERVER_LIBPCIACCESS
 	     pSiSEnt->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                     pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
+#else
+	     void **result = (void **)&pSiSEnt->IOBaseDense;
+	     int err = pci_device_map_range(pSiS->PciInfo,
+ 	                                    pSiS->IOAddress,
+	                                    (pSiS->mmioSize * 1024),
+                                            PCI_DEV_MAP_FLAG_WRITABLE,
+                                            result);
+
+             if (err) {
+                 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                             "Unable to map IO dense aperture. %s (%d)\n",
+                             strerror (err), err);
+#endif
 	}
 	pSiS->IOBaseDense = pSiSEnt->IOBaseDense;
     } else
 #endif
+#ifndef XSERVER_LIBPCIACCESS
     	pSiS->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                     pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
+#else
+	     void **result = (void **)&pSiS->IOBaseDense;
+	     int err = pci_device_map_range(pSiS->PciInfo,
+ 	                                    pSiS->IOAddress,
+	                                    (pSiS->mmioSize * 1024),
+                                            PCI_DEV_MAP_FLAG_WRITABLE,
+                                            result);
+
+             if (err) {
+                 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                             "Unable to map IO dense aperture. %s (%d)\n",
+                             strerror (err), err);
+#endif
 
     if(pSiS->IOBaseDense == NULL) {
        SISErrorLog(pScrn, "Could not map MMIO dense area\n");
@@ -7266,20 +6220,53 @@ SISMapMem(ScrnInfoPtr pScrn)
 	pSiSEnt->MapCountFbBase++;
 	if(!(pSiSEnt->FbBase)) {
 	     /* Only map if not mapped previously */
+#ifndef XSERVER_LIBPCIACCESS
 	     pSiSEnt->FbBase = pSiSEnt->RealFbBase =
 			xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
 			 pSiS->PciTag, (ULong)pSiS->realFbAddress,
 			 pSiS->FbMapSize);
+#else
+         int err = pci_device_map_range(pSiS->PciInfo,
+                                   (ULong)pSiS->realFbAddress,
+                                   pSiS->FbMapSize,
+                                   PCI_DEV_MAP_FLAG_WRITABLE |
+                                   PCI_DEV_MAP_FLAG_WRITE_COMBINE,
+                                   (void *)&pSiSEnt->FbBase);
+	if (err) {
+            xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                        "Unable to map FB aperture. %s (%d)\n",
+                        strerror (err), err);
+            return FALSE;
+        }
+	pSiSEnt->RealFbBase = pSiSEnt->FbBase;
+#endif
 	}
 	pSiS->FbBase = pSiS->RealFbBase = pSiSEnt->FbBase;
 	/* Adapt FbBase (for DHM and SiS76x UMA skipping; dhmOffset is 0 otherwise) */
 	pSiS->FbBase += pSiS->dhmOffset;
     } else {
 #endif
+
+#ifndef XSERVER_LIBPCIACCESS
 	pSiS->FbBase = pSiS->RealFbBase =
 		xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
 			 pSiS->PciTag, (ULong)pSiS->realFbAddress,
 			 pSiS->FbMapSize);
+#else
+         int err = pci_device_map_range(pSiS->PciInfo,
+                                   (ULong)pSiS->realFbAddress,
+                                   pSiS->FbMapSize,
+                                   PCI_DEV_MAP_FLAG_WRITABLE |
+                                   PCI_DEV_MAP_FLAG_WRITE_COMBINE,
+                                   (void *)&pSiS->FbBase);
+	if (err) {
+            xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
+                        "Unable to map FB aperture. %s (%d)\n",
+                        strerror (err), err);
+            return FALSE;
+        }
+	pSiS->RealFbBase = pSiS->FbBase;
+#endif
 	pSiS->FbBase += pSiS->dhmOffset;
 #ifdef SISDUALHEAD
     }
@@ -7364,63 +6351,395 @@ SISUnmapMem(ScrnInfoPtr pScrn)
     return TRUE;
 }
 
-/*
- * This function saves the video state.
- */
-static void
-SISSave(ScrnInfoPtr pScrn)
+/*******************************************************/
+/*                       Various                       */
+/*******************************************************/
+
+/* Check if video bridge is in slave mode */
+Bool
+SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    SISRegPtr sisReg;
-    int flags;
+    UChar  usScrP1_00;
+
+    if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE))
+       return FALSE;
+
+    inSISIDXREG(SISPART1,0x00,usScrP1_00);
+    if( ((pSiS->VGAEngine == SIS_300_VGA) && (usScrP1_00 & 0xa0) == 0x20) ||
+        ((pSiS->VGAEngine == SIS_315_VGA) && (usScrP1_00 & 0x50) == 0x10) ) {
+       return TRUE;
+    }
+
+    return FALSE;
+}
+
+/* Calc dotclock from registers */
+static int
+SiSGetClockFromRegs(UChar sr2b, UChar sr2c)
+{
+   float num, denum, postscalar, divider;
+   int   myclock;
+
+   divider = (sr2b & 0x80) ? 2.0 : 1.0;
+   postscalar = (sr2c & 0x80) ?
+              ( (((sr2c >> 5) & 0x03) == 0x02) ? 6.0 : 8.0 ) :
+	      ( ((sr2c >> 5) & 0x03) + 1.0 );
+   num = (sr2b & 0x7f) + 1.0;
+   denum = (sr2c & 0x1f) + 1.0;
+   myclock = (int)((14318 * (divider / postscalar) * (num / denum)) / 1000);
+   return myclock;
+}
+
+/* Wait for retrace */
+void
+SISWaitRetraceCRT1(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int    watchdog;
+   UChar  temp;
+
+   inSISIDXREG(SISCR,0x17,temp);
+   if(!(temp & 0x80)) return;
+
+   inSISIDXREG(SISSR,0x1f,temp);
+   if(temp & 0xc0) return;
+
+   watchdog = 65536;
+   while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
+   watchdog = 65536;
+   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
+}
+
+void
+SISWaitRetraceCRT2(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int    watchdog;
+   UChar  temp, reg;
+
+   if(SiSBridgeIsInSlaveMode(pScrn)) {
+      SISWaitRetraceCRT1(pScrn);
+      return;
+   }
+
+   switch(pSiS->VGAEngine) {
+   case SIS_300_VGA:
+   	reg = 0x25;
+	break;
+   case SIS_315_VGA:
+   	reg = 0x30;
+	break;
+   default:
+        return;
+   }
 
+   watchdog = 65536;
+   do {
+   	inSISIDXREG(SISPART1, reg, temp);
+	if(!(temp & 0x02)) break;
+   } while(--watchdog);
+   watchdog = 65536;
+   do {
+   	inSISIDXREG(SISPART1, reg, temp);
+	if(temp & 0x02) break;
+   } while(--watchdog);
+}
+
+static void
+SISWaitVBRetrace(ScrnInfoPtr pScrn)
+{
+   SISPtr  pSiS = SISPTR(pScrn);
+
+   if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
 #ifdef SISDUALHEAD
-    /* We always save master & slave */
-    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
+      if(pSiS->DualHeadMode) {
+   	 if(pSiS->SecondHead)
+	    SISWaitRetraceCRT1(pScrn);
+         else
+	    SISWaitRetraceCRT2(pScrn);
+      } else {
+#endif
+	 if(pSiS->VBFlags & DISPTYPE_DISP1) {
+	    SISWaitRetraceCRT1(pScrn);
+	 }
+	 if(pSiS->VBFlags & DISPTYPE_DISP2) {
+	    if(!(SiSBridgeIsInSlaveMode(pScrn))) {
+	       SISWaitRetraceCRT2(pScrn);
+	    }
+	 }
+#ifdef SISDUALHEAD
+      }
 #endif
+   } else {
+      SISWaitRetraceCRT1(pScrn);
+   }
+}
 
-    sisReg = &pSiS->SavedReg;
+/* Enable the Turboqueue/Commandqueue (For 300 series and later only) */
+static void
+SiSEnableTurboQueue(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    UShort SR26, SR27;
+    ULong  temp;
 
-    if( ((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) &&
-        ((pSiS->VBFlags2 & VB2_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) ) {
-       SiSVGASave(pScrn, sisReg, SISVGA_SR_CMAP | SISVGA_SR_MODE);
-#ifdef SIS_PC_PLATFORM
-       if(pSiS->VGAMemBase) {
-          SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
-          SiSSetLVDSetc(pSiS->SiS_Pr, 0);
-          SiS_GetVBType(pSiS->SiS_Pr);
-          SiS_DisableBridge(pSiS->SiS_Pr);
-          SiSVGASave(pScrn, sisReg, SISVGA_SR_FONTS);
-          SiS_EnableBridge(pSiS->SiS_Pr);
-       }
+    switch(pSiS->VGAEngine) {
+	case SIS_300_VGA:
+	   if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
+		/* TQ size is always 512k */
+		temp = (pScrn->videoRam/64) - 8;
+		SR26 = temp & 0xFF;
+		inSISIDXREG(SISSR, 0x27, SR27);
+		SR27 &= 0xFC;
+		SR27 |= (0xF0 | ((temp >> 8) & 3));
+		outSISIDXREG(SISSR, 0x26, SR26);
+		outSISIDXREG(SISSR, 0x27, SR27);
+	   }
+	   break;
+
+	case SIS_315_VGA:
+	   if(!pSiS->NoAccel) {
+	      /* On 315/330/340/350 series, there are three queue modes
+	       * available which are chosen by setting bits 7:5 in SR26:
+	       * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
+	       *    track of the queue, the FIFO, command parsing and so
+	       *    on. This is the one comparable to the 300 series.
+	       * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
+	       *    have to do queue management himself.
+	       * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
+	       *    queue in AGP memory space.
+	       * We go VRAM or MMIO here.
+	       * SR26 bit 4 is called "Bypass H/W queue".
+	       * SR26 bit 1 is called "Enable Command Queue Auto Correction"
+	       * SR26 bit 0 resets the queue
+	       * Size of queue memory is encoded in bits 3:2 like this:
+	       *    00  (0x00)  512K
+	       *    01  (0x04)  1M
+	       *    10  (0x08)  2M
+	       *    11  (0x0C)  4M
+	       * The queue location is to be written to 0x85C0.
+	       */
+#ifdef SISVRAMQ
+	      /* We use VRAM Cmd Queue, not MMIO or AGP */
+	      UChar tempCR55 = 0;
+
+	      /* Set Command Queue Threshold to max value 11111b (?) */
+	      outSISIDXREG(SISSR, 0x27, 0x1F);
+
+	      /* Disable queue flipping */
+	      inSISIDXREG(SISCR, 0x55, tempCR55);
+	      andSISIDXREG(SISCR, 0x55, 0x33);
+	      /* Synchronous reset for Command Queue */
+	      outSISIDXREG(SISSR, 0x26, 0x01);
+	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
+	      /* Enable VRAM Command Queue mode */
+	      if(pSiS->ChipType == XGI_20) {
+		 /* On XGI_20, always 128K */
+		 SR26 = 0x40 | 0x04 | 0x01;
+	      } else {
+	         switch(pSiS->cmdQueueSize) {
+		    case 1*1024*1024: SR26 = (0x40 | 0x04 | 0x01); break;
+		    case 2*1024*1024: SR26 = (0x40 | 0x08 | 0x01); break;
+		    case 4*1024*1024: SR26 = (0x40 | 0x0C | 0x01); break;
+		    default:
+		                      pSiS->cmdQueueSize = 512 * 1024;
+		    case    512*1024: SR26 = (0x40 | 0x00 | 0x01);
+	         }
+	      }
+	      outSISIDXREG(SISSR, 0x26, SR26);
+	      SR26 &= 0xfe;
+	      outSISIDXREG(SISSR, 0x26, SR26);
+	      *(pSiS->cmdQ_SharedWritePort) = (unsigned int)(SIS_MMIO_IN32(pSiS->IOBase, 0x85c8));
+	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85c4, (CARD32)(*(pSiS->cmdQ_SharedWritePort)));
+	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85C0, pSiS->cmdQueueOffset);
+	      temp = (ULong)pSiS->RealFbBase;
+#ifdef SISDUALHEAD
+	      if(pSiS->DualHeadMode) {
+	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
+	         temp = (ULong)pSiSEnt->RealFbBase;
+	      }
 #endif
-    } else {
-       flags = SISVGA_SR_CMAP | SISVGA_SR_MODE;
-#ifdef SIS_PC_PLATFORM
-       if(pSiS->VGAMemBase) flags |= SISVGA_SR_FONTS;
+	      temp += pSiS->cmdQueueOffset;
+	      pSiS->cmdQueueBase = (unsigned int *)temp;
+	      outSISIDXREG(SISCR, 0x55, tempCR55);
+#ifdef TWDEBUG
+	      xf86DrvMsg(0, 0, "CmdQueueOffs 0x%x, CmdQueueAdd %p, shwrp 0x%x, status %x, base %p\n",
+		pSiS->cmdQueueOffset, pSiS->cmdQueueBase, *(pSiS->cmdQ_SharedWritePort),
+		SIS_MMIO_IN32(pSiS->IOBase, 0x85cc), (ULong *)temp);
 #endif
-       SiSVGASave(pScrn, sisReg, flags);
+#else
+	      /* For MMIO */
+	      /* Syncronous reset for Command Queue */
+	      orSISIDXREG(SISSR, 0x26, 0x01);
+	      /* Set Command Queue Threshold to max value 11111b */
+	      outSISIDXREG(SISSR, 0x27, 0x1F);
+	      /* Do some magic (cp readport to writeport) */
+	      temp = SIS_MMIO_IN32(pSiS->IOBase, 0x85C8);
+	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85C4, temp);
+	      /* Enable MMIO Command Queue mode (0x20),
+	       * Enable_command_queue_auto_correction (0x02)
+	       *        (no idea, but sounds good, so use it)
+	       * 512k (0x00) (does this apply to MMIO mode?) */
+	      outSISIDXREG(SISSR, 0x26, 0x22);
+	      /* Calc Command Queue position (Q is always 512k)*/
+	      temp = (pScrn->videoRam - 512) * 1024;
+	      /* Set Q position */
+	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85C0, temp);
+#endif
+	   }
+	   break;
+	default:
+	   break;
     }
+}
 
-    sisSaveUnlockExtRegisterLock(pSiS, &sisReg->sisRegs3C4[0x05], &sisReg->sisRegs3D4[0x80]);
+#ifdef SISVRAMQ
+static void
+SiSRestoreQueueMode(SISPtr pSiS, SISRegPtr sisReg)
+{
+    UChar tempCR55=0;
 
-    (*pSiS->SiSSave)(pScrn, sisReg);
+    if(pSiS->VGAEngine == SIS_315_VGA) {
+       inSISIDXREG(SISCR,0x55,tempCR55);
+       andSISIDXREG(SISCR,0x55,0x33);
+       outSISIDXREG(SISSR,0x26,0x01);
+       SIS_MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
+       outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
+       outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
+       SIS_MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
+       outSISIDXREG(SISCR,0x55,tempCR55);
+    }
+}
+#endif
 
-    if(pSiS->UseVESA) SISVESASaveRestore(pScrn, MODE_SAVE);
+/* Calculate the vertical refresh rate from a mode */
+float
+SiSCalcVRate(DisplayModePtr mode)
+{
+   float hsync, refresh = 0;
 
-    /* "Save" these again as they may have been changed prior to SISSave() call */
+   if(mode->HSync > 0.0)
+       	hsync = mode->HSync;
+   else if(mode->HTotal > 0)
+       	hsync = (float)mode->Clock / (float)mode->HTotal;
+   else
+       	hsync = 0.0;
+
+   if(mode->VTotal > 0)
+       	refresh = hsync * 1000.0 / mode->VTotal;
+
+   if(mode->Flags & V_INTERLACE)
+       	refresh *= 2.0;
+
+   if(mode->Flags & V_DBLSCAN)
+       	refresh /= 2.0;
+
+   if(mode->VScan > 1)
+        refresh /= mode->VScan;
+
+   if(mode->VRefresh > 0.0)
+	refresh = mode->VRefresh;
+
+   if(hsync == 0.0 || refresh == 0.0) return 0.0;
+
+   return refresh;
+}
+
+/* Calculate CR33 (rate index) for CRT1.
+ * Calculation is done using currentmode, therefore it is
+ * recommended to set VertRefresh and HorizSync to correct
+ * values in config file.
+ */
+UChar
+SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode)
+{
+   SISPtr  pSiS = SISPTR(pScrn);
+   int     i = 0, irefresh;
+   UShort  xres = mode->HDisplay;
+   UShort  yres = mode->VDisplay;
+   UChar   index, defindex;
+   Bool    checksis730 = FALSE;
+
+   defindex = (xres == 800 || xres == 1024 || xres == 1280) ? 0x02 : 0x01;
+
+   irefresh = (int)SiSCalcVRate(mode);
+   if(!irefresh) return defindex;
+
+   /* SiS730 has troubles on CRT2 if CRT1 is at 32bpp */
+   if( (pSiS->ChipType == SIS_730)        &&
+       (pSiS->VBFlags2 & VB2_VIDEOBRIDGE) &&
+       (pSiS->CurrentLayout.bitsPerPixel == 32) ) {
+#ifdef SISDUALHEAD
+      if(pSiS->DualHeadMode) {
+         if(pSiS->SecondHead) {
+	    checksis730 = TRUE;
+	 }
+      } else
+#endif
+      if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {
+         checksis730 = TRUE;
+      }
+   }
+
+#ifdef TWDEBUG
+   xf86DrvMsg(0, X_INFO, "Debug: CalcVRate returned %d\n", irefresh);
+#endif
+
+   /* We need the REAL refresh rate here */
+   if(mode->Flags & V_INTERLACE) irefresh /= 2;
+
+   /* Do not multiply by 2 when DBLSCAN! */
+
+#ifdef TWDEBUG
+   xf86DrvMsg(0, X_INFO, "Debug: Rate after correction = %d\n", irefresh);
+#endif
+
+   index = 0;
+   while((sisx_vrate[i].idx != 0) && (sisx_vrate[i].xres <= xres)) {
+      if((sisx_vrate[i].xres == xres) && (sisx_vrate[i].yres == yres)) {
+	 if((checksis730 == FALSE) || (sisx_vrate[i].SiS730valid32bpp == TRUE)) {
+	    if(sisx_vrate[i].refresh == irefresh) {
+	       index = sisx_vrate[i].idx;
+	       break;
+	    } else if(sisx_vrate[i].refresh > irefresh) {
+	       if((sisx_vrate[i].refresh - irefresh) <= 3) {
+		  index = sisx_vrate[i].idx;
+	       } else if( ((checksis730 == FALSE) || (sisx_vrate[i - 1].SiS730valid32bpp == TRUE)) &&
+		          ((irefresh - sisx_vrate[i - 1].refresh) <=  2) &&
+			  (sisx_vrate[i].idx != 1) ) {
+		  index = sisx_vrate[i - 1].idx;
+	       }
+	       break;
+	    } else if((irefresh - sisx_vrate[i].refresh) <= 2) {
+	       index = sisx_vrate[i].idx;
+	       break;
+	    }
+	 }
+      }
+      i++;
+   }
+
+   if(index > 0) return index;
+   else          return defindex;
+}
+
+/* Restore CR32, CR36, CR37 (= our detection results) */
+static void
+SiSRestoreCR323637(SISPtr pSiS)
+{
     if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-       sisReg->sisRegs3C4[0x1f] = pSiS->oldSR1F;
-       sisReg->sisRegs3D4[0x17] = pSiS->oldCR17;
-       sisReg->sisRegs3D4[0x32] = pSiS->oldCR32;
-       sisReg->sisRegs3D4[0x36] = pSiS->oldCR36;
-       sisReg->sisRegs3D4[0x37] = pSiS->oldCR37;
-       if(pSiS->VGAEngine == SIS_315_VGA) {
-	  sisReg->sisRegs3D4[pSiS->myCR63] = pSiS->oldCR63;
-       }
+       outSISIDXREG(SISCR,0x32,pSiS->myCR32);
+       outSISIDXREG(SISCR,0x36,pSiS->myCR36);
+       outSISIDXREG(SISCR,0x37,pSiS->myCR37);
     }
 }
 
+/*******************************************************/
+/*                        Save()                       */
+/*******************************************************/
+
+
 /* VESASaveRestore taken from vesa driver */
 static void
 SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function)
@@ -7470,275 +6789,80 @@ SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function)
     }
 }
 
-/*
- * Initialise a new mode.  This is currently done using the
- * "initialise struct, restore/write struct to HW" model for
- * the old chipsets (5597/530/6326). For newer chipsets,
- * we use our own mode switching code.
- */
-
-static Bool
-SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
+static void
+SISSave(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
     SISRegPtr sisReg;
-#ifdef SISDUALHEAD
-    SISEntPtr pSiSEnt = NULL;
-#endif
-
-    andSISIDXREG(SISCR,0x11,0x7f);	/* Unlock CRTC registers */
-
-    SISModifyModeInfo(mode);		/* Quick check of the mode parameters */
-
-    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-       SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
-    }
-
-    if(pSiS->UseVESA) {  /* With VESA: */
+    int flags;
 
 #ifdef SISDUALHEAD
-       /* No dual head mode when using VESA */
-       if(pSiS->SecondHead) return TRUE;
+    /* We always save master & slave */
+    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
 #endif
 
-       pScrn->vtSema = TRUE;
+    sisReg = &pSiS->SavedReg;
 
-       /*
-	* This order is required:
-	* The video bridge needs to be adjusted before the
-	* BIOS is run as the BIOS sets up CRT2 according to
-	* these register settings.
-	* After the BIOS is run, the bridges and turboqueue
-	* registers need to be readjusted as the BIOS may
-	* very probably have messed them up.
-	*/
-       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
-       }
-       if(!SiSSetVESAMode(pScrn, mode)) {
-	  SISErrorLog(pScrn, "SiSSetVESAMode() failed\n");
-	  return FALSE;
-       }
-       sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
-	  SiSPostSetMode(pScrn, &pSiS->ModeReg);
-       }
-#ifdef TWDEBUG
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "REAL REGISTER CONTENTS AFTER SETMODE:\n");
-#endif
-       if(!(*pSiS->ModeInit)(pScrn, mode)) {
-	  SISErrorLog(pScrn, "ModeInit() failed\n");
-	  return FALSE;
+    if( ((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) &&
+        ((pSiS->VBFlags2 & VB2_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) ) {
+       SiSVGASave(pScrn, sisReg, SISVGA_SR_CMAP | SISVGA_SR_MODE);
+#ifdef SIS_PC_PLATFORM
+       if(pSiS->VGAMemBase) {
+          SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
+          SiSSetLVDSetc(pSiS->SiS_Pr, 0);
+          SiS_GetVBType(pSiS->SiS_Pr);
+          SiS_DisableBridge(pSiS->SiS_Pr);
+          SiSVGASave(pScrn, sisReg, SISVGA_SR_FONTS);
+          SiS_EnableBridge(pSiS->SiS_Pr);
        }
-
-       SiSVGAProtect(pScrn, TRUE);
-       (*pSiS->SiSRestore)(pScrn, &pSiS->ModeReg);
-       SiSVGAProtect(pScrn, FALSE);
-
-    } else { /* Without VESA: */
-
-#ifdef SISDUALHEAD
-       if(pSiS->DualHeadMode) {
-
-	  if(!(*pSiS->ModeInit)(pScrn, mode)) {
-	     SISErrorLog(pScrn, "ModeInit() failed\n");
-	     return FALSE;
-	  }
-
-	  pScrn->vtSema = TRUE;
-
-	  pSiSEnt = pSiS->entityPrivate;
-
-	  if(!(pSiS->SecondHead)) {
-	     /* Head 1 (master) is always CRT2 */
-	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
-	     if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, pScrn, mode, pSiS->IsCustom)) {
-		SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
-		return FALSE;
-	     }
-	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
-	     if(pSiSEnt->pScrn_2) {
-		SISAdjustFrame(pSiSEnt->pScrn_2->scrnIndex,
-			       pSiSEnt->pScrn_2->frameX0,
-			       pSiSEnt->pScrn_2->frameY0, 0);
-	     }
-	  } else {
-	     /* Head 2 (slave) is always CRT1 */
-	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
-	     if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, pScrn, mode, pSiS->IsCustom)) {
-		SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
-		return FALSE;
-	     }
-	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
-	     if(pSiSEnt->pScrn_1) {
-		SISAdjustFrame(pSiSEnt->pScrn_1->scrnIndex,
-			       pSiSEnt->pScrn_1->frameX0,
-			       pSiSEnt->pScrn_1->frameY0, 0);
-	     }
-	  }
-
-       } else {
-#endif
-
-	  if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-
-	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
-		SISErrorLog(pScrn, "ModeInit() failed\n");
-	        return FALSE;
-	     }
-
-	     pScrn->vtSema = TRUE;
-
-#ifdef SISMERGED
-	     if(pSiS->MergedFB) {
-
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting MergedFB mode %dx%d\n",
-				mode->HDisplay, mode->VDisplay);
-
-		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
-
-		if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, pScrn,
-		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
-				       pSiS->IsCustom)) {
-		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
-		   return FALSE;
-		}
-
-		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
-
-		if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, pScrn,
-		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
-				       pSiS->IsCustom)) {
-		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
-		   return FALSE;
-		}
-
-	     } else {
-#endif
-
-		if((pSiS->VBFlags & CRT1_LCDA) || (!(mode->type & M_T_DEFAULT))) {
-
-		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
-
-		   if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, pScrn,
-				mode, pSiS->IsCustom)) {
-		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
-		      return FALSE;
-		   }
-
-		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
-
-		   if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, pScrn,
-				mode, pSiS->IsCustom)) {
-		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
-		      return FALSE;
-		   }
-
-		} else {
-
-		   SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
-
-		   if(!SiSBIOSSetMode(pSiS->SiS_Pr, pScrn,
-				mode, pSiS->IsCustom)) {
-		      SISErrorLog(pScrn, "SiSBIOSSetMode() failed\n");
-		      return FALSE;
-		   }
-
-		}
-
-#ifdef SISMERGED
-	     }
 #endif
-
-	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
-
-#ifdef TWDEBUG
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VBFlags %lx\n", pSiS->VBFlags);
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
-             (*pSiS->ModeInit)(pScrn, mode);
+    } else {
+       flags = SISVGA_SR_CMAP | SISVGA_SR_MODE;
+#ifdef SIS_PC_PLATFORM
+       if(pSiS->VGAMemBase) flags |= SISVGA_SR_FONTS;
 #endif
+       SiSVGASave(pScrn, sisReg, flags);
+    }
 
-	  } else {
-
-	     /* For other chipsets, use the old method */
-
-	     /* Prepare the register contents */
-	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
-	        SISErrorLog(pScrn, "ModeInit() failed\n");
-	        return FALSE;
-	     }
-
-	     pScrn->vtSema = TRUE;
-
-	     /* Program the registers */
-	     SiSVGAProtect(pScrn, TRUE);
-	     sisReg = &pSiS->ModeReg;
-
-	     sisReg->sisRegsATTR[0x10] = 0x01;
-	     if(pScrn->bitsPerPixel > 8) {
-		sisReg->sisRegsGR[0x05] = 0x00;
-	     }
-
-	     SiSVGARestore(pScrn, sisReg, SISVGA_SR_MODE);
-
-	     (*pSiS->SiSRestore)(pScrn, sisReg);
-
-	     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
-	        SiS6326PostSetMode(pScrn, &pSiS->ModeReg);
-	     }
-
-#ifdef TWDEBUG
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
-	     (*pSiS->ModeInit)(pScrn, mode);
-#endif
+    sisSaveUnlockExtRegisterLock(pSiS, &sisReg->sisRegs3C4[0x05], &sisReg->sisRegs3D4[0x80]);
 
-	     SiSVGAProtect(pScrn, FALSE);
+    (*pSiS->SiSSave)(pScrn, sisReg);
 
-	  }
+    if(pSiS->UseVESA) SISVESASaveRestore(pScrn, MODE_SAVE);
 
-#ifdef SISDUALHEAD
+    /* "Save" these again as they may have been changed prior to SISSave() call */
+    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
+       sisReg->sisRegs3C4[0x1f] = pSiS->oldSR1F;
+       sisReg->sisRegs3D4[0x17] = pSiS->oldCR17;
+       sisReg->sisRegs3D4[0x32] = pSiS->oldCR32;
+       sisReg->sisRegs3D4[0x36] = pSiS->oldCR36;
+       sisReg->sisRegs3D4[0x37] = pSiS->oldCR37;
+       if(pSiS->VGAEngine == SIS_315_VGA) {
+	  sisReg->sisRegs3D4[pSiS->myCR63] = pSiS->oldCR63;
        }
-#endif
     }
-
-    /* Update Currentlayout */
-    pSiS->CurrentLayout.mode = pSiS->currentModeLast = mode;
-
-    return TRUE;
 }
 
-static Bool
-SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
-{
-    SISPtr pSiS;
-    int mode;
 
-    pSiS = SISPTR(pScrn);
-
-    if(!(mode = SiSCalcVESAModeIndex(pScrn, pMode))) return FALSE;
+/*******************************************************/
+/*                   Restore(), etc                    */
+/*******************************************************/
 
-    mode |= (1 << 15);	/* Don't clear framebuffer */
-    mode |= (1 << 14); 	/* Use linear adressing */
+static void
+SiS_SiSFB_Lock(ScrnInfoPtr pScrn, Bool lock)
+{
+    SISPtr  pSiS = SISPTR(pScrn);
+    int     fd;
+    CARD32  parm;
 
-    if(VBESetVBEMode(pSiS->pVbe, mode, NULL) == FALSE) {
-       SISErrorLog(pScrn, "Setting VESA mode 0x%x failed\n",
-	             	mode & 0x0fff);
-       return (FALSE);
-    }
+    if(!pSiS->sisfbfound) return;
+    if(!pSiS->sisfb_havelock) return;
 
-    if(pMode->HDisplay != pScrn->virtualX) {
-       VBESetLogicalScanline(pSiS->pVbe, pScrn->virtualX);
+    if((fd = open(pSiS->sisfbdevname, 'r')) != -1) {
+       parm = lock ? 1 : 0;
+       ioctl(fd, SISFB_SET_LOCK, &parm);
+       close(fd);
     }
-
-    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-    	"Setting VESA mode 0x%x succeeded\n",
-	mode & 0x0fff);
-
-    return (TRUE);
 }
 
 static void
@@ -7763,10 +6887,13 @@ SISSpecialRestore(ScrnInfoPtr pScrn)
      * manually.
      */
 
-    if(!(pSiS->ChipFlags & SiSCF_Is65x)) return;
+    if(!(pSiS->ChipFlags & SiSCF_Is65x))
+       return;
+
     inSISIDXREG(SISCR, 0x34, temp);
     temp &= 0x7f;
-    if(temp > 0x13) return;
+    if(temp > 0x13)
+       return;
 
 #ifdef UNLOCK_ALWAYS
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
@@ -7784,8 +6911,11 @@ SISSpecialRestore(ScrnInfoPtr pScrn)
     outSISIDXREG(SISVID, 0x32, ((sisReg->sisVid[0x32] & ~0x04) | 0x01));
     outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);
 
-    if(!(pSiS->ChipFlags & SiSCF_Is651)) return;
-    if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return;
+    if(!(pSiS->ChipFlags & SiSCF_Is651))
+       return;
+
+    if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))
+       return;
 
     inSISIDXREG(SISCR, 0x30, temp);
     if(temp & 0x40) {
@@ -7819,7 +6949,7 @@ SiSFixupSR11(ScrnInfoPtr pScrn)
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
 
-    if(pSiS->ChipType >= SIS_661) {
+    if(pSiS->SiS_Pr->SiS_SensibleSR11) {
        inSISIDXREG(SISSR,0x11,tmpreg);
        if(tmpreg & 0x20) {
           inSISIDXREG(SISSR,0x3e,tmpreg);
@@ -7933,11 +7063,12 @@ SISRestore(ScrnInfoPtr pScrn)
 
 	   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
 	         "Restoring by setting old mode 0x%02x\n", pSiS->OldMode);
-
+	  
 	   if(((pSiS->OldMode <= 0x13) || (!pSiS->sisfbfound)) && (pSiS->pVbe)) {
 	      int vmode = SiSTranslateToVESA(pScrn, pSiS->OldMode);
 	      if(vmode > 0) {
 		 if(vmode > 0x13) vmode |= ((1 << 15) | (1 << 14));
+		 outSISIDXREG(SISCR, 0x7d, sisReg->sisRegs3D4[0x7d]); /* Timing ID */
 		 if(VBESetVBEMode(pSiS->pVbe, vmode, NULL) == TRUE) {
 		    SISSpecialRestore(pScrn);
 		    SiS_GetSetModeID(pScrn,pSiS->OldMode);
@@ -8002,6 +7133,7 @@ SISRestore(ScrnInfoPtr pScrn)
 		    SiS_SetEnableFstn(pSiS->SiS_Pr, TRUE);
 		 }
 	      }
+	      pSiS->SiS_Pr->SiS_EnableBackLight = TRUE;
 	      SiSSetMode(pSiS->SiS_Pr, pScrn, mymode, FALSE);
 	      if(changedmode) {
 		 outSISIDXREG(SISCR,0x34,0x03);
@@ -8024,7 +7156,7 @@ SISRestore(ScrnInfoPtr pScrn)
            outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);
 
 #ifdef SISVRAMQ
-	   /* Restore queue mode registers on 315/330/340 series */
+	   /* Restore queue mode registers on 315/330/340/350 series */
 	   /* (This became necessary due to the switch to VRAM queue) */
 	   SiSRestoreQueueMode(pSiS, sisReg);
 #endif
@@ -8051,8 +7183,6 @@ SISRestore(ScrnInfoPtr pScrn)
            outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
 	}
 
-
-
 	if((pSiS->VBFlags2 & VB2_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
 
 	   /* IMPORTANT: The 30xLV does not handle well being disabled if in
@@ -8161,7 +7291,7 @@ SISVESARestore(ScrnInfoPtr pScrn)
    if(pSiS->UseVESA) {
       SISVESASaveRestore(pScrn, MODE_RESTORE);
 #ifdef SISVRAMQ
-      /* Restore queue mode registers on 315/330/340 series */
+      /* Restore queue mode registers on 315/330/340/350 series */
       /* (This became necessary due to the switch to VRAM queue) */
       SiSRestoreQueueMode(pSiS, sisReg);
 #endif
@@ -8184,7 +7314,1471 @@ SISBridgeRestore(ScrnInfoPtr pScrn)
     }
 }
 
-/* Our BlockHandler */
+/************************************************/
+/*                Mode switching                */
+/************************************************/
+
+/* Things to do before a ModeSwitch. We set up the
+ * video bridge configuration and the TurboQueue.
+ * (300 series and later)
+ */
+static void
+SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, int viewmode)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    UChar  CR30, CR31, CR32, CR33;
+    UChar  CR39 = 0, CR3B = 0;
+    UChar  CR17, CR38 = 0;
+    UChar  CR35 = 0, CR79 = 0;
+    int    temp = 0, crt1rateindex = 0;
+    ULong  vbflag = pSiS->VBFlags;
+    Bool   hcm = pSiS->HaveCustomModes;
+    DisplayModePtr mymode = mode;
+
+    pSiS->IsCustom = FALSE;
+
+    /* NEVER call this with viewmode = SIS_MODE_SIMU
+     * if mode->type is not M_T_DEFAULT!
+     */
+
+#ifdef SISMERGED
+    if(pSiS->MergedFB) {
+       switch(viewmode) {
+       case SIS_MODE_CRT1:
+	  mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
+	  break;
+       case SIS_MODE_CRT2:
+	  mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
+	  hcm = pSiS->HaveCustomModes2;
+       }
+    }
+#endif
+
+    switch(viewmode) {
+    case SIS_MODE_CRT1:
+       if(SiS_CheckModeCRT1(pScrn, mymode, vbflag, pSiS->VBFlags3, hcm) == 0xfe) {
+          pSiS->IsCustom = TRUE;
+       }
+       break;
+    case SIS_MODE_CRT2:
+       if(vbflag & CRT2_ENABLE) {
+          if(SiS_CheckModeCRT2(pScrn, mymode, vbflag, pSiS->VBFlags3, hcm) == 0xfe) {
+	     pSiS->IsCustom = TRUE;
+          }
+       } else {
+          /* This can only happen in mirror mode */
+          if(SiS_CheckModeCRT1(pScrn, mymode, vbflag, pSiS->VBFlags3, hcm) == 0xfe) {
+             pSiS->IsCustom = TRUE;
+          }
+       }
+    }
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);    /* Unlock Registers */
+#endif
+
+    inSISIDXREG(SISCR, 0x30, CR30);
+    inSISIDXREG(SISCR, 0x31, CR31);
+    CR32 = pSiS->newCR32;
+    inSISIDXREG(SISCR, 0x33, CR33);
+
+    if(pSiS->NewCRLayout) {
+
+       inSISIDXREG(SISCR, 0x35, CR35);
+       inSISIDXREG(SISCR, 0x38, CR38);
+       inSISIDXREG(SISCR, 0x39, CR39);
+
+       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, SISVERBLEVEL,
+	   "Before: CR30=0x%02x,CR31=0x%02x,CR32=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=0x%02x\n",
+              CR30, CR31, CR32, CR33, CR35, CR38);
+
+       CR38 &= ~0x07;
+
+    } else {
+
+       if(pSiS->Chipset != PCI_CHIP_SIS300) {
+          switch(pSiS->VGAEngine) {
+             case SIS_300_VGA: temp = 0x35; break;
+             case SIS_315_VGA: temp = 0x38; break;
+          }
+          if(temp) inSISIDXREG(SISCR, temp, CR38);
+       }
+       if(pSiS->VGAEngine == SIS_315_VGA) {
+          inSISIDXREG(SISCR, 0x79, CR79);
+          CR38 &= ~0x3b;   			/* Clear LCDA/DualEdge and YPbPr bits */
+       }
+       inSISIDXREG(SISCR, 0x3b, CR3B);
+
+       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, SISVERBLEVEL,
+	   "Before: CR30=0x%02x, CR31=0x%02x, CR32=0x%02x, CR33=0x%02x, CR%02x=0x%02x\n",
+              CR30, CR31, CR32, CR33, temp, CR38);
+    }
+
+    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, SISVERBLEVEL, "VBFlags=0x%x\n", pSiS->VBFlags);
+
+    CR30 = 0x00;
+    CR31 &= ~0x60;  /* Clear VB_Drivermode & VB_OutputDisable */
+    CR31 |= 0x04;   /* Set VB_NotSimuMode (not for 30xB/1400x1050?) */
+    CR35 = 0x00;
+
+    if(!pSiS->NewCRLayout) {
+       if(!pSiS->AllowHotkey) {
+          CR31 |= 0x80;   /* Disable hotkey-switch */
+       }
+       CR79 &= ~0x10;     /* Enable Backlight control on 315 series */
+    }
+
+    SiS_SetEnableDstn(pSiS->SiS_Pr, FALSE);
+    SiS_SetEnableFstn(pSiS->SiS_Pr, FALSE);
+
+    if((vbflag & CRT1_LCDA) && (viewmode == SIS_MODE_CRT1)) {
+
+       CR38 |= 0x02;
+
+    } else {
+
+       switch(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
+
+       case CRT2_TV:
+          CR38 &= ~0xC0; 	/* Clear Pal M/N bits */
+
+          if((pSiS->VBFlags2 & VB2_CHRONTEL) && (vbflag & TV_CHSCART)) {		/* Chrontel */
+	     CR30 |= 0x10;
+	     CR38 |= 0x04;
+	     CR38 &= ~0x08;
+	     CR31 |= 0x01;
+	  } else if((pSiS->VBFlags2 & VB2_CHRONTEL) && (vbflag & TV_CHYPBPR525I)) {	/* Chrontel */
+	     CR38 |= 0x08;
+	     CR38 &= ~0x04;
+	     CR31 &= ~0x01;
+          } else if(vbflag & TV_HIVISION) {	/* SiS bridge */
+	     if(pSiS->NewCRLayout) {
+	        CR38 |= 0x04;
+	        CR35 |= 0x60;
+	     } else {
+	        CR30 |= 0x80;
+		if(pSiS->VGAEngine == SIS_315_VGA) {
+		   if(pSiS->VBFlags2 & VB2_SISYPBPRBRIDGE) {
+		      CR38 |= (0x08 | 0x30);
+		   }
+		}
+	     }
+	     CR31 |= 0x01;
+	     CR35 |= 0x01;
+	  } else if(vbflag & TV_YPBPR) {					/* SiS bridge */
+	     if(pSiS->NewCRLayout) {
+		CR38 |= 0x04;
+		CR31 &= ~0x01;
+		CR35 &= ~0x01;
+		if(vbflag & (TV_YPBPR525P | TV_YPBPR625P)) CR35 |= 0x20;
+		else if(vbflag & TV_YPBPR750P)             CR35 |= 0x40;
+		else if(vbflag & TV_YPBPR1080I)            CR35 |= 0x60;
+
+		if(vbflag & (TV_YPBPR625I | TV_YPBPR625P)) {
+		   CR31 |= 0x01;
+		   CR35 |= 0x01;
+		}
+
+		CR39 &= ~0x03;
+		if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR39 |= 0x00;
+		else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR39 |= 0x01;
+		else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR39 |= 0x02;
+		else					      CR39 |= 0x03;
+	     } else if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR) {
+		CR30 |= 0x80;
+		CR38 |= 0x08;
+		CR31 &= ~0x01;
+		if(vbflag & (TV_YPBPR525P|TV_YPBPR625P)) CR38 |= 0x10;
+		else if(vbflag & TV_YPBPR750P)  	 CR38 |= 0x20;
+		else if(vbflag & TV_YPBPR1080I)		 CR38 |= 0x30;
+
+		if(vbflag & (TV_YPBPR625I | TV_YPBPR625P)) CR31 |= 0x01;
+
+		if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPRAR) {
+		   CR3B &= ~0x03;
+		   if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR3B |= 0x00;
+		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR3B |= 0x03;
+		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR3B |= 0x01;
+		   else					         CR3B |= 0x03;
+		}
+	     }
+          } else {								/* All */
+	     if(vbflag & TV_SCART)  CR30 |= 0x10;
+	     if(vbflag & TV_SVIDEO) CR30 |= 0x08;
+	     if(vbflag & TV_AVIDEO) CR30 |= 0x04;
+	     if(!(CR30 & 0x1C))	    CR30 |= 0x08;    /* default: SVIDEO */
+
+	     if(vbflag & TV_PAL) {
+		CR31 |= 0x01;
+		CR35 |= 0x01;
+		if( (pSiS->VBFlags2 & VB2_SISBRIDGE) ||
+		    ((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x)) )  {
+		   if(vbflag & TV_PALM) {
+		      CR38 |= 0x40;
+		      CR35 |= 0x04;
+		   } else if(vbflag & TV_PALN) {
+		      CR38 |= 0x80;
+		      CR35 |= 0x08;
+		   }
+	        }
+	     } else {
+		CR31 &= ~0x01;
+		CR35 &= ~0x01;
+		if(vbflag & TV_NTSCJ) {
+		   CR38 |= 0x40;  /* TW, not BIOS */
+		   CR35 |= 0x02;
+		}
+	     }
+	     if(vbflag & TV_SCART) {
+		CR31 |= 0x01;
+		CR35 |= 0x01;
+	     }
+	  }
+
+	  CR31 &= ~0x04;   /* Clear NotSimuMode */
+	  pSiS->SiS_Pr->SiS_CHOverScan = pSiS->UseCHOverScan;
+	  if((pSiS->OptTVSOver == 1) && (pSiS->ChrontelType == CHRONTEL_700x)) {
+	     pSiS->SiS_Pr->SiS_CHSOverScan = TRUE;
+	  } else {
+	     pSiS->SiS_Pr->SiS_CHSOverScan = FALSE;
+	  }
+	  break;
+
+       case CRT2_LCD:
+	  CR30 |= 0x20;
+	  SiS_SetEnableDstn(pSiS->SiS_Pr, pSiS->DSTN);
+	  SiS_SetEnableFstn(pSiS->SiS_Pr, pSiS->FSTN);
+	  break;
+
+       case CRT2_VGA:
+	  CR30 |= 0x40;
+	  break;
+
+       default:
+	  CR30 |= 0x00;
+	  CR31 |= 0x20;    /* VB_OUTPUT_DISABLE */
+	  if(pSiS->UseVESA) {
+	     crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
+	  }
+       }
+
+    }
+
+    if(vbflag & CRT1_LCDA) {
+       switch(viewmode) {
+       case SIS_MODE_CRT1:
+	  CR38 |= 0x01;
+	  break;
+       case SIS_MODE_CRT2:
+	  if(vbflag & (CRT2_TV|CRT2_VGA)) {
+	     CR30 |= 0x02;
+	     CR38 |= 0x01;
+	  } else {
+	     CR38 |= 0x03;
+	  }
+	  break;
+       case SIS_MODE_SIMU:
+       default:
+	  if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
+	     CR30 |= 0x01;
+	  }
+	  break;
+       }
+    } else {
+       if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
+          CR30 |= 0x01;
+       }
+    }
+
+    if(pSiS->UseVESA) {
+       CR31 &= ~0x40;   /* Clear Drivermode */
+       CR31 |= 0x06;    /* Set SlaveMode, Enable SimuMode in Slavemode */
+#ifdef TWDEBUG
+       CR31 |= 0x40;    /* DEBUG (for non-slave mode VESA) */
+       crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
+#endif
+    } else {
+       CR31 |=  0x40;  /* Set Drivermode */
+       CR31 &=  ~0x06; /* Disable SlaveMode, disable SimuMode in SlaveMode */
+       if(!pSiS->IsCustom) {
+          crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
+       }
+    }
+
+    switch(viewmode) {
+	case SIS_MODE_SIMU:
+	   CR33 = 0;
+	   if(!(vbflag & CRT1_LCDA)) {
+	      CR33 |= (crt1rateindex & 0x0f);
+	   }
+	   if(vbflag & CRT2_VGA) {
+	      CR33 |= ((crt1rateindex & 0x0f) << 4);
+	   }
+	   break;
+	case SIS_MODE_CRT1:
+	   CR33 &= 0xf0;
+	   if(!(vbflag & CRT1_LCDA)) {
+	      CR33 |= (crt1rateindex & 0x0f);
+	   }
+	   break;
+	case SIS_MODE_CRT2:
+	   CR33 &= 0x0f;
+	   if(vbflag & CRT2_VGA) {
+	      CR33 |= ((crt1rateindex & 0x0f) << 4);
+	   }
+	   break;
+     }
+
+     if((!pSiS->UseVESA) && (vbflag & CRT2_ENABLE)) {
+	if(pSiS->CRT1off) CR33 &= 0xf0;
+     }
+
+     if(pSiS->NewCRLayout) {
+
+	CR31 &= 0xfe;   /* Clear PAL flag (now in CR35) */
+	CR38 &= 0x07;   /* Use only LCDA and HiVision/YPbPr bits */
+	outSISIDXREG(SISCR, 0x30, CR30);
+	outSISIDXREG(SISCR, 0x31, CR31);
+	outSISIDXREG(SISCR, 0x33, CR33);
+	outSISIDXREG(SISCR, 0x35, CR35);
+	setSISIDXREG(SISCR, 0x38, 0xf8, CR38);
+	outSISIDXREG(SISCR, 0x39, CR39);
+
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, SISVERBLEVEL,
+		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=%02x\n",
+		    CR30, CR31, CR33, CR35, CR38);
+
+     } else {
+
+	outSISIDXREG(SISCR, 0x30, CR30);
+	outSISIDXREG(SISCR, 0x31, CR31);
+	outSISIDXREG(SISCR, 0x33, CR33);
+	if(temp) {
+	   outSISIDXREG(SISCR, temp, CR38);
+	}
+	if(pSiS->VGAEngine == SIS_315_VGA) {
+	   outSISIDXREG(SISCR, 0x3b, CR3B);
+	   outSISIDXREG(SISCR, 0x79, CR79);
+	}
+
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, SISVERBLEVEL,
+		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR%02x=%02x\n",
+		    CR30, CR31, CR33, temp, CR38);
+     }
+
+     pSiS->SiS_Pr->SiS_UseOEM = pSiS->OptUseOEM;
+
+     /* Enable TurboQueue */
+#ifdef SISVRAMQ
+     if(pSiS->VGAEngine != SIS_315_VGA)
+#endif
+	SiSEnableTurboQueue(pScrn);
+
+     if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
+	/* Switch on CRT1 for modes that require the bridge in SlaveMode */
+	andSISIDXREG(SISSR,0x1f,0x3f);
+	inSISIDXREG(SISCR, 0x17, CR17);
+	if(!(CR17 & 0x80)) {
+	   orSISIDXREG(SISCR, 0x17, 0x80);
+	   outSISIDXREG(SISSR, 0x00, 0x01);
+	   usleep(10000);
+	   outSISIDXREG(SISSR, 0x00, 0x03);
+	}
+     }
+}
+
+#ifdef SISDUALHEAD
+static void
+SiS_SetDHFlags(SISPtr pSiS, unsigned int misc, unsigned int sd2)
+{
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiS->DualHeadMode) {
+      if(pSiSEnt->pScrn_1) {
+	 SISPTR(pSiSEnt->pScrn_1)->MiscFlags |= misc;
+	 SISPTR(pSiSEnt->pScrn_1)->SiS_SD2_Flags |= sd2;
+      }
+      if(pSiSEnt->pScrn_2) {
+	 SISPTR(pSiSEnt->pScrn_2)->MiscFlags |= misc;
+	 SISPTR(pSiSEnt->pScrn_2)->SiS_SD2_Flags |= sd2;
+      }
+   }
+}
+#endif
+
+/* PostSetMode: Things to do after a mode switch. (300 and later)
+ * -) Disable CRT1 for saving bandwidth. This doesn't work with VESA;
+ *    VESA uses the bridge in SlaveMode and switching CRT1 off while
+ *    the bridge is in SlaveMode is not that clever...
+ * -) Check if overlay can be used (depending on dotclock)
+ * -) Check if Panel Scaler is active on LVDS for overlay re-scaling
+ * -) Save TV registers for further processing
+ * -) Apply TV and other settings
+ */
+static void
+SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+    SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+    UChar usScratchCR17, sr2b, sr2c, tmpreg;
+    int   myclock1, myclock2, mycoldepth1, mycoldepth2, temp;
+    Bool  flag = FALSE;
+    Bool  doit = TRUE;
+    Bool  IsInSlaveMode;
+
+#ifdef TWDEBUG
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+    	"CRT1off is %d\n", pSiS->CRT1off);
+#endif
+
+    pSiS->CRT1isoff = pSiS->CRT1off;
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+    SiSFixupSR11(pScrn);
+
+    IsInSlaveMode = SiSBridgeIsInSlaveMode(pScrn);
+
+    if(pSiS->VGAEngine == SIS_315_VGA) {
+       andSISIDXREG(SISSR, 0x31, 0xcf);
+       inSISIDXREG(SISSR, 0x2b, pSiS->SR2b);
+       inSISIDXREG(SISSR, 0x2c, pSiS->SR2c);
+    }
+
+    if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
+
+	if(pSiS->VBFlags != pSiS->VBFlags_backup) {
+	   pSiS->VBFlags = pSiS->VBFlags_backup;
+	   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
+			"VBFlags restored to %0x\n", pSiS->VBFlags);
+	}
+
+	/* -) We can't switch off CRT1 if bridge is in SlaveMode.
+	 * -) If we change to a SlaveMode-Mode (like 512x384), we
+	 *    need to adapt VBFlags for eg. Xv.
+	 */
+#ifdef SISDUALHEAD
+	if(!pSiS->DualHeadMode) {
+#endif
+	   if(IsInSlaveMode) {
+	      doit = FALSE;
+	      temp = pSiS->VBFlags;
+	      pSiS->VBFlags &= (~VB_DISPMODE_SINGLE);
+	      pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_DISP1);
+              if(temp != pSiS->VBFlags) {
+		 xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
+		 	"VBFlags changed to 0x%0x\n", pSiS->VBFlags);
+	      }
+	   }
+#ifdef SISDUALHEAD
+	}
+#endif
+
+	if(pSiS->VGAEngine == SIS_315_VGA) {
+
+	   if((pSiS->CRT1off) && (doit)) {
+	      orSISIDXREG(SISCR,pSiS->myCR63,0x40);
+	      orSISIDXREG(SISSR,0x1f,0xc0);
+	      andSISIDXREG(SISSR,0x07,~0x10);
+	      andSISIDXREG(SISSR,0x06,0xe2);
+	      andSISIDXREG(SISSR,0x31,0xcf);
+	      outSISIDXREG(SISSR,0x2b,0x1b);
+	      outSISIDXREG(SISSR,0x2c,0xe1);
+	      outSISIDXREG(SISSR,0x2d,0x01);
+	      outSISIDXREG(SISSR, 0x00, 0x01);
+	      usleep(10000);
+	      outSISIDXREG(SISSR, 0x00, 0x03);
+	   } else {
+	      andSISIDXREG(SISCR,pSiS->myCR63,0xBF);
+	      andSISIDXREG(SISSR,0x1f,0x3f);
+	      orSISIDXREG(SISSR,0x07,0x10);
+	   }
+
+	} else {
+
+	   if(doit) {
+	      inSISIDXREG(SISCR, 0x17, usScratchCR17);
+	      if(pSiS->CRT1off) {
+		 if(usScratchCR17 & 0x80) {
+		    flag = TRUE;
+		    usScratchCR17 &= ~0x80;
+		 }
+		 orSISIDXREG(SISSR,0x1f,0xc0);
+	      } else {
+		 if(!(usScratchCR17 & 0x80)) {
+		    flag = TRUE;
+		    usScratchCR17 |= 0x80;
+		 }
+		 andSISIDXREG(SISSR,0x1f,0x3f);
+	      }
+	      /* Reset only if status changed */
+	      if(flag) {
+		 outSISIDXREG(SISCR, 0x17, usScratchCR17);
+		 outSISIDXREG(SISSR, 0x00, 0x01);
+		 usleep(10000);
+		 outSISIDXREG(SISSR, 0x00, 0x03);
+	      }
+	   }
+	}
+
+    }
+
+    /* Set bridge to "disable CRT2" mode if CRT2 is disabled, LCD-A is enabled */
+    /* (Not needed for CRT1=VGA since CRT2 will really be disabled then) */
+#ifdef SISDUALHEAD
+    if(!pSiS->DualHeadMode) {
+#endif
+       if((pSiS->VGAEngine == SIS_315_VGA)  && (pSiS->VBFlags2 & VB2_SISLCDABRIDGE)) {
+	  if((!pSiS->UseVESA) && (!(pSiS->VBFlags & CRT2_ENABLE)) && (pSiS->VBFlags & CRT1_LCDA)) {
+	     if(!IsInSlaveMode) {
+	        andSISIDXREG(SISPART4,0x0d,~0x07);
+	     }
+	  }
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+
+    /* Reset flags */
+    pSiS->MiscFlags &= ~( MISC_CRT1OVERLAY	|
+			  MISC_CRT2OVERLAY	|
+			  MISC_CRT1OVERLAYGAMMA	|
+			  MISC_SIS760ONEOVERLAY	|
+			  MISC_PANELLINKSCALER	|
+			  MISC_STNMODE		|
+			  MISC_INTERLACE	|
+			  MISC_NOMONOHWCURSOR	|
+			  MISC_NORGBHWCURSOR	|
+			  MISC_CURSORDOUBLESIZE	|
+			  MISC_CURSORMAXHALF );
+
+    pSiS->SiS_SD2_Flags &= ~SiS_SD2_SIS760ONEOVL;
+
+#ifdef SISDUALHEAD
+    if(pSiS->DualHeadMode) {
+       if(pSiSEnt->pScrn_1) {
+	  SISPTR(pSiSEnt->pScrn_1)->MiscFlags &= ~(MISC_SIS760ONEOVERLAY	|
+						   MISC_CRT1OVERLAY		|
+						   MISC_CRT2OVERLAY		|
+						   MISC_CRT1OVERLAYGAMMA	|
+						   MISC_PANELLINKSCALER		|
+						   MISC_STNMODE);
+	  SISPTR(pSiSEnt->pScrn_1)->SiS_SD2_Flags &= ~SiS_SD2_SIS760ONEOVL;
+       }
+       if(pSiSEnt->pScrn_2) {
+	  SISPTR(pSiSEnt->pScrn_2)->MiscFlags &= ~(MISC_SIS760ONEOVERLAY	|
+						   MISC_CRT1OVERLAY		|
+						   MISC_CRT2OVERLAY		|
+						   MISC_CRT1OVERLAYGAMMA	|
+						   MISC_PANELLINKSCALER		|
+						   MISC_STNMODE);
+	  SISPTR(pSiSEnt->pScrn_2)->SiS_SD2_Flags &= ~SiS_SD2_SIS760ONEOVL;
+       }
+    }
+#endif
+
+    /* Determine if the video overlay can be used */
+    if(!pSiS->NoXvideo) {
+
+       int clklimit1=0, clklimit2=0, clklimitg=0;
+       Bool OverlayHandled = FALSE;
+
+       inSISIDXREG(SISSR,0x2b,sr2b);
+       inSISIDXREG(SISSR,0x2c,sr2c);
+       myclock1 = myclock2 = SiSGetClockFromRegs(sr2b, sr2c);
+       inSISIDXREG(SISSR,0x06,tmpreg);
+       switch((tmpreg & 0x1c) >> 2) {
+       case 0:  mycoldepth1 = 1; break;
+       case 1:
+       case 2:  mycoldepth1 = 2; break;
+       default: mycoldepth1 = 4;
+       }
+       mycoldepth2 = mycoldepth1;
+
+       if((!IsInSlaveMode) && (pSiS->VBFlags & CRT2_ENABLE)) {
+	  if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
+	     inSISIDXREG(SISPART4,0x0a,sr2b);
+	     inSISIDXREG(SISPART4,0x0b,sr2c);
+	  } else {
+	     inSISIDXREG(SISSR,0x2e,sr2b);
+	     inSISIDXREG(SISSR,0x2f,sr2c);
+	  }
+	  myclock2 = SiSGetClockFromRegs(sr2b, sr2c);
+	  inSISIDXREG(SISPART1,0x00,tmpreg);
+	  tmpreg &= 0x0f;
+	  switch(tmpreg) {
+	  case 8:  mycoldepth2 = 1; break;
+	  case 4:
+	  case 2:  mycoldepth2 = 2; break;
+	  default: mycoldepth2 = 4;
+	  }
+       }
+
+       switch(pSiS->ChipType) {
+
+	 case SIS_300:
+	 case SIS_540:
+	 case SIS_630:
+	 case SIS_730:
+	    clklimit1 = clklimit2 = clklimitg = 150;
+	    break;
+
+	 case SIS_550:
+	    clklimit1 = clklimit2 = clklimitg = 150; /* ? */
+	    break;
+
+	 case SIS_650:
+	 case SIS_740:
+	    clklimit1 = clklimit2 = 175;  /* verified for 65x */
+	    clklimitg = 166;		  /* ? */
+	    break;
+
+	 case SIS_661:
+	 case SIS_741:
+	 case SIS_670:
+        case SIS_662:
+	 case SIS_671:
+#ifndef SIS761MEMFIX
+	 case SIS_761:
+#endif
+#ifndef SIS770MEMFIX
+	 case SIS_770:
+#endif
+	    clklimit1 = clklimit2 = 170; /* verified M661FX */
+	    clklimitg = 170;		 /* verified M661FX */
+	    break;
+
+	 case SIS_760:
+#ifdef SIS761MEMFIX
+	 case SIS_761:
+#endif
+#ifdef SIS770MEMFIX
+	 case SIS_770:
+#endif
+	    clklimit1 = clklimit2 = 170;    /* ? */
+	    if(pSiS->ChipFlags & SiSCF_760LFB) {		/* LFB only or hybrid */
+	       clklimit1 = clklimit2 = 180; /* ? */
+	    }
+	    clklimitg = 170;		    /* ? */
+
+	    if(pSiS->SiS_SD2_Flags & SiS_SD2_SUPPORT760OO) {	/* UMA only */
+
+	       Bool OnlyOne = FALSE, NoOverlay = FALSE;
+	       int dotclocksum = 0;
+
+	       if(pSiS->VBFlags & DISPTYPE_CRT1)                     dotclocksum += myclock1;
+	       if((!IsInSlaveMode) && (pSiS->VBFlags & CRT2_ENABLE)) dotclocksum += myclock2;
+
+	       /* TODO: Find out under what circumstances only one
+		*	overlay is usable in UMA-only mode.
+		*	This is not entirely accurate; the overlay
+		*	scaler also requires some time, so even though
+		*	the dotclocks are below these values, some
+		*	distortions in the overlay may occure.
+		*	Solution: Don't use a 760 with shared memory
+		*       or use the video blitter by default.
+		*/
+	       if( (pSiS->VBFlags & DISPTYPE_CRT1) &&
+		   (pSiS->VBFlags & CRT2_ENABLE) &&
+		   (mycoldepth1 != mycoldepth2) ) {
+
+		  /* 0. If coldepths are different (only possible in dual head mode),
+		   *    I have no idea to calculate the limits; hence, allow only one
+		   *    overlay in all cases.
+		   */
+		  OnlyOne = TRUE;
+
+	       } else if(pSiS->MemClock < 150000) {
+
+		  /* 1. MCLK <150: If someone seriously considers using such
+		   *    slow RAM, so be it. Only one overlay in call cases.
+		   */
+		  OnlyOne = TRUE;
+
+	       } else if(pSiS->MemClock < 170000) {
+
+		  /* 2. MCLK 166 */
+		  switch(pSiS->CurrentLayout.bitsPerPixel) {
+		     case 32: if(dotclocksum > 133) OnlyOne = TRUE;		/* One overlay; verified */
+			      if(dotclocksum > 180) NoOverlay = TRUE;		/* No overlay; verified */
+			      break;
+		     case 16: if(dotclocksum > 175) OnlyOne = TRUE;		/* One overlay; verified */
+			      if(dotclocksum > 260) NoOverlay = TRUE;;		/* No overlay; FIXME */
+			      break;
+		  }
+
+	       } else if(pSiS->MemClock < 210000) {
+
+		  /* 3. MCLK 200 */
+		  switch(pSiS->CurrentLayout.bitsPerPixel) {
+		     case 32: if(dotclocksum > 160) OnlyOne = TRUE;		/* One overlay; FIXME */
+			      if(dotclocksum > 216) NoOverlay = TRUE;;		/* No overlay; FIXME */
+			      break;
+		     case 16: if(dotclocksum > 210) OnlyOne = TRUE;		/* One overlay; FIXME */
+			      if(dotclocksum > 312) NoOverlay = TRUE;;		/* No overlay; FIXME */
+			      break;
+		  }
+
+	       }
+
+	       if(OnlyOne || NoOverlay) {
+
+		  ULong tmpflags = 0;
+
+		  if(!NoOverlay) {
+		     if(myclock1 <= clklimit1) tmpflags |= MISC_CRT1OVERLAY;
+		     if(myclock2 <= clklimit2) tmpflags |= MISC_CRT2OVERLAY;
+		     if(myclock1 <= clklimitg) tmpflags |= MISC_CRT1OVERLAYGAMMA;
+		     pSiS->MiscFlags |= tmpflags;
+		  }
+		  pSiS->MiscFlags |= MISC_SIS760ONEOVERLAY;
+		  pSiS->SiS_SD2_Flags |= SiS_SD2_SIS760ONEOVL;
+#ifdef SISDUALHEAD
+		  SiS_SetDHFlags(pSiS, (tmpflags | MISC_SIS760ONEOVERLAY), SiS_SD2_SIS760ONEOVL);
+#endif
+		  OverlayHandled = TRUE;
+	       }
+
+	       xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
+			"SiS76x/UMA: %s video overlay(s) available in current mode\n",
+			NoOverlay ? "no" : ((pSiS->MiscFlags & MISC_SIS760ONEOVERLAY) ? "one" : "two"));
+
+#ifdef TWDEBUG
+	       xf86DrvMsg(0, 0, "SiS760: Memclock %d, c1 %d/%d c2 %d/%d, sum %d / %x\n",
+			pSiS->MemClock, myclock1, mycoldepth1,
+			myclock2, mycoldepth2, dotclocksum, pSiS->SiS_SD2_Flags);
+#endif
+	    }
+	    break;
+
+	 case SIS_660:
+	    clklimit1 = clklimit2 = 170;  /* ? */
+	    if(pSiS->ChipFlags & SiSCF_760LFB) {		/* LFB only */
+	       clklimit1 = clklimit2 = 180;
+	    }
+	    clklimitg = 180;		  /* ? */
+	    break;
+
+	 case SIS_315H:
+	 case SIS_315:
+	 case SIS_315PRO:
+	 case SIS_330:
+	    clklimit1 = clklimit2 = 180;  /* ? */
+	    clklimitg = 166;		  /* ? */
+	    break;
+
+	 case SIS_340:
+	 case SIS_341:
+	 case SIS_342:
+	 case XGI_40:
+	    clklimit1 = clklimit2 = 200;  /* ? */
+	    clklimitg = 200;		  /* ? */
+	    break;
+
+	 default:
+	    OverlayHandled = TRUE;
+       }
+
+       if(!OverlayHandled) {
+          ULong tmpflags = 0;
+          if(myclock1 <= clklimit1) tmpflags |= MISC_CRT1OVERLAY;
+          if(myclock2 <= clklimit2) tmpflags |= MISC_CRT2OVERLAY;
+          if(myclock1 <= clklimitg) tmpflags |= MISC_CRT1OVERLAYGAMMA;
+	  pSiS->MiscFlags |= tmpflags;
+#ifdef SISDUALHEAD
+	  SiS_SetDHFlags(pSiS, tmpflags, 0);
+#endif
+          if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
+#ifdef SISDUALHEAD
+             if((!pSiS->DualHeadMode) || (pSiS->SecondHead))
+#endif
+		xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
+		   "Current dotclock (%dMhz) too high for video overlay on CRT1\n",
+		   myclock1);
+          }
+          if((pSiS->VBFlags & CRT2_ENABLE) && (!(pSiS->MiscFlags & MISC_CRT2OVERLAY))) {
+#ifdef SISDUALHEAD
+	     if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
+#endif
+		xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
+		   "Current dotclock (%dMhz) too high for video overlay on CRT2\n",
+		   myclock2);
+	  }
+       }
+
+    }
+
+    /* Determine if mode is interlace (CRT1 only) */
+    /* (Dual head: Do NOT copy this flags over to pSiSEnt;
+     * instead decide for CRT1 only)
+     */
+#ifdef SISDUALHEAD
+    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
+#endif
+       if(pSiS->VBFlags & DISPTYPE_DISP1) {
+	  inSISIDXREG(SISSR, 0x06, tmpreg);
+	  if(tmpreg & 0x20) pSiS->MiscFlags |= MISC_INTERLACE;
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+
+    /* Determine if hw cursor is supported with current mode */
+    /* (Dual head: Do NOT copy these flags over to pSiSEnt;
+     * instead decide for each head)
+     * TODO: Check for interlace on 550, 740
+     */
+    switch(pSiS->VGAEngine) {
+    case SIS_300_VGA:
+       if((pSiS->CurrentLayout.bitsPerPixel == 8) &&
+	  (pSiS->VBFlags & CRT2_ENABLE) &&
+	  !IsInSlaveMode)
+	  pSiS->MiscFlags |= MISC_NORGBHWCURSOR;
+       if(pSiS->MiscFlags & MISC_INTERLACE)
+	  pSiS->MiscFlags |= (MISC_NOMONOHWCURSOR | MISC_NORGBHWCURSOR);
+       break;
+    case SIS_315_VGA:
+       if((pSiS->CurrentLayout.bitsPerPixel == 8) &&
+	  (pSiS->VBFlags & CRT2_ENABLE) &&
+	  !IsInSlaveMode)
+	  pSiS->MiscFlags |= MISC_NORGBHWCURSOR;
+       if(pSiS->Chipset == PCI_CHIP_SIS550) {
+#ifdef SISDUALHEAD
+	  if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
+#endif
+	     if((pSiS->FSTN || pSiS->DSTN) && (pSiS->VBFlags & CRT2_LCD))
+	        pSiS->MiscFlags |= (MISC_NOMONOHWCURSOR | MISC_NORGBHWCURSOR);
+       }
+       break;
+    }
+
+    /* Determine whether the HW cursor image needs to stretched */
+    /* (which is the case in double scan modes)
+     */
+    {
+       unsigned char tmp1 = 0;
+
+       tmpreg = 0;
+
+       if(pSiS->VBFlags & DISPTYPE_DISP1) {
+          inSISIDXREG(SISCR, 0x09, tmpreg);
+          tmpreg &= 0x80;
+       }
+       if(pSiS->VBFlags & DISPTYPE_DISP2) {
+          if(IsInSlaveMode) {
+             inSISIDXREG(SISCR, 0x09, tmp1);
+             tmp1 &= 0x80;
+          } else if(pSiS->VGAEngine == SIS_315_VGA) {
+             inSISIDXREG(SISPART1, 0x2c, tmp1);
+             tmp1 &= 0x80;
+          }
+       }
+
+#ifdef SISDUALHEAD
+       if(pSiS->DualHeadMode) {
+          if(pSiS->SecondHead) {
+             if(tmpreg)
+                pSiS->MiscFlags |= (MISC_CURSORMAXHALF | MISC_CURSORDOUBLESIZE);
+          } else {
+             if(tmp1)
+                pSiS->MiscFlags |= (MISC_CURSORMAXHALF | MISC_CURSORDOUBLESIZE);
+          }
+       } else
+#endif
+#ifdef SISMERGED
+	      if(pSiS->MergedFB) {
+	  if(tmpreg || tmp1) {
+	     pSiS->MiscFlags |= MISC_CURSORMAXHALF;
+	  }
+	  if(tmpreg && tmp1) {
+	     pSiS->MiscFlags |= MISC_CURSORDOUBLESIZE;
+	  }
+       } else
+#endif
+	      if(tmpreg || tmp1) {
+	  pSiS->MiscFlags |= (MISC_CURSORMAXHALF | MISC_CURSORDOUBLESIZE);
+       }
+    }
+
+    /* Determine if the Panel Link scaler is active */
+    if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {
+       ULong tmpflags = 0;
+       if(pSiS->VGAEngine == SIS_300_VGA) {
+	  if(pSiS->VBFlags2 & (VB2_LVDS | VB2_30xBDH)) {
+	     inSISIDXREG(SISPART1,0x1e,tmpreg);
+	     tmpreg &= 0x3f;
+	     if(tmpreg) tmpflags |= MISC_PANELLINKSCALER;
+	  }
+       } else {
+	  if((pSiS->VBFlags2 & (VB2_LVDS | VB2_30xBDH)) || (pSiS->VBFlags & CRT1_LCDA)) {
+	     inSISIDXREG(SISPART1,0x35,tmpreg);
+	     tmpreg &= 0x04;
+	     if(!tmpreg)  tmpflags |= MISC_PANELLINKSCALER;
+	  }
+       }
+       pSiS->MiscFlags |= tmpflags;
+#ifdef SISDUALHEAD
+       SiS_SetDHFlags(pSiS, tmpflags, 0);
+#endif
+    }
+
+    /* Determine if STN is active */
+    if(pSiS->ChipType == SIS_550) {
+       if((pSiS->VBFlags & CRT2_LCD) && (pSiS->FSTN || pSiS->DSTN)) {
+	  inSISIDXREG(SISCR,0x34,tmpreg);
+	  tmpreg &= 0x7f;
+	  if(tmpreg == 0x5a || tmpreg == 0x5b) {
+	     pSiS->MiscFlags |= MISC_STNMODE;
+#ifdef SISDUALHEAD
+	     SiS_SetDHFlags(pSiS, MISC_STNMODE, 0);
+#endif
+	  }
+       }
+    }
+
+    if(pSiS->VGAEngine == SIS_315_VGA) {
+       int i;
+#ifdef SISVRAMQ
+       /* Re-Enable and reset command queue */
+       SiSEnableTurboQueue(pScrn);
+#endif
+       /* Get HWCursor register contents for backup */
+       for(i = 0; i < 16; i++) {
+          pSiS->HWCursorBackup[i] = SIS_MMIO_IN32(pSiS->IOBase, 0x8500 + (i << 2));
+       }
+       if(pSiS->ChipType >= SIS_330) {
+          /* Enable HWCursor protection (Y pos as trigger) */
+          andSISIDXREG(SISCR, 0x5b, ~0x30);
+       }
+    }
+
+    /* Re-initialize accelerator engine */
+    /* (We are sync'ed here) */
+    if(!pSiS->NoAccel) {
+       if(pSiS->InitAccel) {
+          (pSiS->InitAccel)(pScrn);
+       }
+    }
+
+    /* Set display device gamma (for SISCTRL) */
+    if(pSiS->VBFlags3 & VB3_CRT1_LCD)
+       pSiS->CRT1MonGamma = pSiS->CRT1LCDMonitorGamma;
+    else if(pSiS->VBFlags & CRT1_LCDA)
+       pSiS->CRT1MonGamma = pSiS->CRT2LCDMonitorGamma;
+    else
+       pSiS->CRT1MonGamma = pSiS->CRT1VGAMonitorGamma;
+
+    if(pSiS->VBFlags & CRT2_LCD)
+       pSiS->CRT2MonGamma = pSiS->CRT2LCDMonitorGamma;
+    else if(pSiS->VBFlags & CRT2_TV) {
+       if(pSiS->VBFlags & TV_YPBPR)
+          pSiS->CRT2MonGamma = 2200; /* ? */
+       else if(pSiS->VBFlags & TV_HIVISION)
+          pSiS->CRT2MonGamma = 2200; /* ? */
+       else if(pSiS->VBFlags & TV_NTSC)
+          pSiS->CRT2MonGamma = 2200; /* NTSC */
+       else
+          pSiS->CRT2MonGamma = 2800; /* All PAL modes? */
+    } else if(pSiS->VBFlags & CRT2_VGA)
+       pSiS->CRT2MonGamma = pSiS->CRT2VGAMonitorGamma;
+    else
+       pSiS->CRT2MonGamma = 0; /* Unknown */
+
+    /* Reset XV display properties (such as number of overlays, etc) */
+    /* (And copy monitor gamma) */
+#ifdef SISDUALHEAD
+    if(pSiS->DualHeadMode) {
+       if(pSiSEnt->pScrn_1) {
+	  if(SISPTR(pSiSEnt->pScrn_1)->ResetXvDisplay) {
+	     (SISPTR(pSiSEnt->pScrn_1)->ResetXvDisplay)(pSiSEnt->pScrn_1);
+	  }
+	  SISPTR(pSiSEnt->pScrn_1)->CRT1MonGamma = pSiS->CRT1MonGamma;
+	  SISPTR(pSiSEnt->pScrn_1)->CRT2MonGamma = pSiS->CRT2MonGamma;
+       }
+       if(pSiSEnt->pScrn_2) {
+	  if(SISPTR(pSiSEnt->pScrn_2)->ResetXvDisplay) {
+	     (SISPTR(pSiSEnt->pScrn_1)->ResetXvDisplay)(pSiSEnt->pScrn_2);
+	  }
+	  SISPTR(pSiSEnt->pScrn_2)->CRT1MonGamma = pSiS->CRT1MonGamma;
+	  SISPTR(pSiSEnt->pScrn_2)->CRT2MonGamma = pSiS->CRT2MonGamma;
+       }
+    } else {
+#endif
+       if(pSiS->ResetXvDisplay) {
+	  (pSiS->ResetXvDisplay)(pScrn);
+       }
+#ifdef SISDUALHEAD
+    }
+#endif
+
+    /* Reset XV gamma correction */
+    if(pSiS->ResetXvGamma) {
+       (pSiS->ResetXvGamma)(pScrn);
+    }
+
+    /* Reset various display parameters */
+    {
+       int val = pSiS->siscrt1satgain;
+#ifdef SISDUALHEAD
+       if(pSiS->DualHeadMode && pSiSEnt) val = pSiSEnt->siscrt1satgain;
+#endif
+       SiS_SetSISCRT1SaturationGain(pScrn, val);
+    }
+
+    /*  Apply TV settings given by options */
+    if(pSiS->VBFlags & CRT2_TV) {
+       SiSPostSetModeTVParms(pScrn);
+    }
+}
+
+/* Post-set SiS6326 TV registers */
+static void
+SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    UChar tmp;
+    int val;
+
+    if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+    /* Backup default TV position registers */
+    pSiS->tvx1 = SiS6326GetTVReg(pScrn,0x3a);
+    pSiS->tvx1 |= ((SiS6326GetTVReg(pScrn,0x3c) & 0x0f) << 8);
+    pSiS->tvx2 = SiS6326GetTVReg(pScrn,0x26);
+    pSiS->tvx2 |= ((SiS6326GetTVReg(pScrn,0x27) & 0xf0) << 4);
+    pSiS->tvx3 = SiS6326GetTVReg(pScrn,0x12);
+    pSiS->tvx3 |= ((SiS6326GetTVReg(pScrn,0x13) & 0xC0) << 2);
+    pSiS->tvy1 = SiS6326GetTVReg(pScrn,0x11);
+    pSiS->tvy1 |= ((SiS6326GetTVReg(pScrn,0x13) & 0x30) << 4);
+
+    /* Handle TVPosOffset options (BEFORE switching on TV) */
+    if((val = pSiS->tvxpos) != 0) {
+       SiS_SetTVxposoffset(pScrn, val);
+    }
+    if((val = pSiS->tvypos) != 0) {
+       SiS_SetTVyposoffset(pScrn, val);
+    }
+
+    /* Switch on TV output. This is rather complicated, but
+     * if we don't do it, TV output will flicker terribly.
+     */
+    if(pSiS->SiS6326Flags & SIS6326_TVON) {
+       orSISIDXREG(SISSR, 0x01, 0x20);
+       tmp = SiS6326GetTVReg(pScrn,0x00);
+       tmp &= ~0x04;
+       while(!(inSISREG(SISINPSTAT) & 0x08));    /* Wait while NOT vb */
+       SiS6326SetTVReg(pScrn,0x00,tmp);
+       for(val=0; val < 2; val++) {
+         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
+         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
+       }
+       SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
+       tmp = inSISREG(SISINPSTAT);
+       outSISREG(SISAR, 0x20);
+       tmp = inSISREG(SISINPSTAT);
+       while(inSISREG(SISINPSTAT) & 0x01);
+       while(!(inSISREG(SISINPSTAT) & 0x01));
+       andSISIDXREG(SISSR, 0x01, ~0x20);
+       for(val=0; val < 10; val++) {
+         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
+         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
+       }
+       andSISIDXREG(SISSR, 0x01, ~0x20);
+    }
+
+    tmp = SiS6326GetTVReg(pScrn,0x00);
+    if(!(tmp & 0x04)) return;
+
+    /* Apply TV settings given by options */
+    if((val = pSiS->sistvantiflicker) != -1) {
+       SiS_SetSIS6326TVantiflicker(pScrn, val);
+    }
+    if((val = pSiS->sis6326enableyfilter) != -1) {
+       SiS_SetSIS6326TVenableyfilter(pScrn, val);
+    }
+    if((val = pSiS->sis6326yfilterstrong) != -1) {
+       SiS_SetSIS6326TVyfilterstrong(pScrn, val);
+    }
+
+}
+
+/* Get VESA mode number from given resolution/depth */
+static UShort
+SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    sisModeInfoPtr m = pSiS->SISVESAModeList;
+    UShort i = pSiS->CurrentLayout.bytesPerPixel - 1;
+    UShort ModeNumber = 0;
+    int j;
+
+    while(m) {
+       if( (pSiS->CurrentLayout.bitsPerPixel == m->bpp) &&
+	   (mode->HDisplay == m->width)    &&
+	   (mode->VDisplay == m->height) )
+	  return m->n;
+       m = m->next;
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+        "No valid VESA BIOS mode found for %dx%d (%d bpp)\n",
+        mode->HDisplay, mode->VDisplay, pScrn->bitsPerPixel);
+
+    if(!pSiS->ROM661New) {  /* VESA numbers changed! */
+       j = 0;
+       while(VESAModeIndices[j] != 9999) {
+          if( (mode->HDisplay == VESAModeIndices[j]) &&
+	      (mode->VDisplay == VESAModeIndices[j+1]) ) {
+	     ModeNumber = VESAModeIndices[j + 2 + i];
+	     break;
+          }
+          j += 6;
+       }
+
+       if(!ModeNumber) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+	      "No valid mode found for %dx%dx%d in built-in table either.\n",
+	      mode->HDisplay, mode->VDisplay, pScrn->bitsPerPixel);
+       }
+    }
+
+    return(ModeNumber);
+}
+
+static Bool
+SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
+{
+    SISPtr pSiS;
+    int mode;
+
+    pSiS = SISPTR(pScrn);
+
+    if(!(mode = SiSCalcVESAModeIndex(pScrn, pMode)))
+       return FALSE;
+
+    mode |= (1 << 15);	/* Don't clear framebuffer */
+    mode |= (1 << 14); 	/* Use linear adressing */
+
+    if(VBESetVBEMode(pSiS->pVbe, mode, NULL) == FALSE) {
+       SISErrorLog(pScrn, "Setting VESA mode 0x%x failed\n",
+	             	mode & 0x0fff);
+       return FALSE;
+    }
+
+    if(pMode->HDisplay != pScrn->virtualX) {
+       VBESetLogicalScanline(pSiS->pVbe, pScrn->virtualX);
+    }
+
+    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+    	"Setting VESA mode 0x%x succeeded\n",
+	mode & 0x0fff);
+
+    return TRUE;
+}
+
+static void
+SISModifyModeInfo(DisplayModePtr mode)
+{
+    if(mode->CrtcHBlankStart == mode->CrtcHDisplay)
+        mode->CrtcHBlankStart++;
+    if(mode->CrtcHBlankEnd == mode->CrtcHTotal)
+        mode->CrtcHBlankEnd--;
+    if(mode->CrtcVBlankStart == mode->CrtcVDisplay)
+        mode->CrtcVBlankStart++;
+    if(mode->CrtcVBlankEnd == mode->CrtcVTotal)
+        mode->CrtcVBlankEnd--;
+}
+
+static void
+SiS_SiSLVDSBackLight(SISPtr pSiS, Bool blon)
+{
+    unsigned char p4_26;
+    if(pSiS->VBFlags2 & VB2_SISLVDSBRIDGE) {
+       inSISIDXREG(SISPART4, 0x26, p4_26);
+       if(!blon) {
+	  SiS_SiS30xBLOff(pSiS->SiS_Pr);
+       } else {
+          if(p4_26 & 0x02) {
+	     SiS_DDC2Delay(pSiS->SiS_Pr, 0xff00);
+	     SiS_SiS30xBLOn(pSiS->SiS_Pr);
+	  }
+       }
+    }
+}
+
+/* Initialize a new mode */
+
+static Bool
+SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    SISRegPtr sisReg;
+#ifdef SISDUALHEAD
+    SISEntPtr pSiSEnt = NULL;
+#endif
+
+    andSISIDXREG(SISCR,0x11,0x7f);	/* Unlock CRTC registers */
+
+    SISModifyModeInfo(mode);		/* Quick check of the mode parameters */
+
+    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+       SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
+    }
+
+    if(pSiS->UseVESA) {  /* With VESA: */
+
+#ifdef SISDUALHEAD
+       /* No dual head mode when using VESA */
+       if(pSiS->SecondHead) return TRUE;
+#endif
+
+       pScrn->vtSema = TRUE;
+
+       /*
+	* This order is required:
+	* The video bridge needs to be adjusted before the
+	* BIOS is run as the BIOS sets up CRT2 according to
+	* these register settings.
+	* After the BIOS is run, the bridges and turboqueue
+	* registers need to be readjusted as the BIOS may
+	* very probably have messed them up.
+	*/
+       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
+       }
+       if(!SiSSetVESAMode(pScrn, mode)) {
+	  SISErrorLog(pScrn, "SiSSetVESAMode() failed\n");
+	  return FALSE;
+       }
+       sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
+	  SiSPostSetMode(pScrn, &pSiS->ModeReg);
+       }
+#ifdef TWDEBUG
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		   "REAL REGISTER CONTENTS AFTER SETMODE:\n");
+#endif
+       if(!(*pSiS->ModeInit)(pScrn, mode)) {
+	  SISErrorLog(pScrn, "ModeInit() failed\n");
+	  return FALSE;
+       }
+
+       SiSVGAProtect(pScrn, TRUE);
+       (*pSiS->SiSRestore)(pScrn, &pSiS->ModeReg);
+       SiSVGAProtect(pScrn, FALSE);
+
+    } else { /* Without VESA: */
+
+#ifdef SISDUALHEAD
+       if(pSiS->DualHeadMode) {
+
+	  if(!(*pSiS->ModeInit)(pScrn, mode)) {
+	     SISErrorLog(pScrn, "ModeInit() failed\n");
+	     return FALSE;
+	  }
+
+	  pScrn->vtSema = TRUE;
+
+	  pSiSEnt = pSiS->entityPrivate;
+
+	  if(!(pSiS->SecondHead)) {
+	     /* Head 1 (master) is always CRT2 */
+	     pSiS->SiS_Pr->SiS_EnableBackLight = TRUE;
+	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
+	     if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, pScrn, mode, pSiS->IsCustom)) {
+		SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
+		return FALSE;
+	     }
+	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
+	     if(pSiSEnt->pScrn_2) {
+	        /* No need to go through pScrn->AdjustFrame; the coords
+	         * didn't change
+	         */
+		SISAdjustFrame(pSiSEnt->pScrn_2->scrnIndex,
+			       pSiSEnt->pScrn_2->frameX0,
+			       pSiSEnt->pScrn_2->frameY0, 0);
+	     }
+	  } else {
+	     /* Head 2 (slave) is always CRT1 */
+	     pSiS->SiS_Pr->SiS_EnableBackLight = FALSE;
+	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
+	     if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, pScrn, mode, pSiS->IsCustom)) {
+		SiS_SiSLVDSBackLight(pSiS, TRUE);
+		SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
+		return FALSE;
+	     }
+	     SiS_SiSLVDSBackLight(pSiS, TRUE);
+	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
+	     if(pSiSEnt->pScrn_1) {
+	        /* No need to go through pScrn->AdjustFrame; the coords
+	         * didn't change
+	         */
+		SISAdjustFrame(pSiSEnt->pScrn_1->scrnIndex,
+			       pSiSEnt->pScrn_1->frameX0,
+			       pSiSEnt->pScrn_1->frameY0, 0);
+	     }
+	  }
+
+       } else {
+#endif
+
+	  if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+
+	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
+		SISErrorLog(pScrn, "ModeInit() failed\n");
+	        return FALSE;
+	     }
+
+	     pScrn->vtSema = TRUE;
+
+#ifdef SISMERGED
+	     if(pSiS->MergedFB) {
+
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting MergedFB mode %dx%d\n",
+				mode->HDisplay, mode->VDisplay);
+
+		pSiS->SiS_Pr->SiS_EnableBackLight = FALSE;
+
+		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
+
+		if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, pScrn,
+		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
+				       pSiS->IsCustom)) {
+		   SiS_SiSLVDSBackLight(pSiS, TRUE);
+		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
+		   return FALSE;
+		}
+
+		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
+
+		if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, pScrn,
+		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
+				       pSiS->IsCustom)) {
+		   SiS_SiSLVDSBackLight(pSiS, TRUE);
+		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
+		   return FALSE;
+		}
+
+		SiS_SiSLVDSBackLight(pSiS, TRUE);
+
+		(*pScrn->AdjustFrame)(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+
+	     } else {
+#endif
+
+		if((pSiS->VBFlags & CRT1_LCDA) || (!(mode->type & M_T_DEFAULT))) {
+
+		   pSiS->SiS_Pr->SiS_EnableBackLight = FALSE;
+
+		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
+
+		   if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, pScrn,
+				mode, pSiS->IsCustom)) {
+		      SiS_SiSLVDSBackLight(pSiS, TRUE);
+		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
+		      return FALSE;
+		   }
+
+		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
+
+		   if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, pScrn,
+				mode, pSiS->IsCustom)) {
+		      SiS_SiSLVDSBackLight(pSiS, TRUE);
+		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
+		      return FALSE;
+		   }
+
+		   SiS_SiSLVDSBackLight(pSiS, TRUE);
+
+		} else {
+
+		   pSiS->SiS_Pr->SiS_EnableBackLight = TRUE;
+
+		   SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
+
+		   if(!SiSBIOSSetMode(pSiS->SiS_Pr, pScrn,
+					mode, pSiS->IsCustom)) {
+		      SISErrorLog(pScrn, "SiSBIOSSetMode() failed\n");
+		      return FALSE;
+		   }
+
+		}
+
+#ifdef SISMERGED
+	     }
+#endif
+	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
+#ifdef TWDEBUG
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VBFlags %lx\n", pSiS->VBFlags);
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
+             (*pSiS->ModeInit)(pScrn, mode);
+#endif
+
+	  } else {
+
+	     /* For other chipsets, use the old method */
+
+	     /* Prepare the register contents */
+	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
+	        SISErrorLog(pScrn, "ModeInit() failed\n");
+	        return FALSE;
+	     }
+
+	     pScrn->vtSema = TRUE;
+
+	     /* Program the registers */
+	     SiSVGAProtect(pScrn, TRUE);
+	     sisReg = &pSiS->ModeReg;
+
+	     sisReg->sisRegsATTR[0x10] = 0x01;
+	     if(pScrn->bitsPerPixel > 8) {
+		sisReg->sisRegsGR[0x05] = 0x00;
+	     }
+
+	     SiSVGARestore(pScrn, sisReg, SISVGA_SR_MODE);
+
+	     (*pSiS->SiSRestore)(pScrn, sisReg);
+
+	     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
+	        SiS6326PostSetMode(pScrn, &pSiS->ModeReg);
+	     }
+
+#ifdef TWDEBUG
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
+	     (*pSiS->ModeInit)(pScrn, mode);
+#endif
+
+	     SiSVGAProtect(pScrn, FALSE);
+
+	  }
+
+#ifdef SISDUALHEAD
+       }
+#endif
+    }
+
+    /* Update Currentlayout */
+    pSiS->CurrentLayout.mode = pSiS->currentModeLast = mode;
+
+    return TRUE;
+}
+
+
+/*******************************************************/
+/*                 Our BlockHandler                    */
+/*******************************************************/
+
 static void
 SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
 {
@@ -8209,6 +8803,14 @@ SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
     }
 #endif
 
+    if(pSiS->AdjustFramePending && pSiS->AdjustFrame) {
+       (*pSiS->AdjustFrame)(i, pSiS->AdjustFrameX, pSiS->AdjustFrameY, pSiS->AdjustFrameFlags);
+       /* Reset it since Xv insists on installing its own every time. */
+       pScrn->AdjustFrame = SISNewAdjustFrame;
+       pSiS->AdjustFramePending = FALSE;
+    }
+
+
     if(pSiS->VideoTimerCallback) {
        (*pSiS->VideoTimerCallback)(pScrn, currentTime.milliseconds);
     }
@@ -8218,6 +8820,7 @@ SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
        (*pSiS->RenderCallback)(pScrn);
     }
 #endif
+
 #ifdef SIS_USE_EXA
     if(pSiS->ExaRenderCallback) {
        (*pSiS->ExaRenderCallback)(pScrn);
@@ -8225,18 +8828,14 @@ SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
 #endif
 }
 
-
-
-/* Do screen blanking; DPMS handling
- *
- * Mandatory; latter optional
- */
+/*******************************************************/
+/*               DPMS, Screen blanking                 */
+/*******************************************************/
 
 static void
 SiSHandleBackLight(SISPtr pSiS, Bool blon)
 {
     UChar sr11mask = (pSiS->SiS_Pr->SiS_SensibleSR11) ? 0x03 : 0xf3;
-
     if(pSiS->VBFlags2 & VB2_SISLVDSBRIDGE) {
 
        if(!blon) {
@@ -8251,7 +8850,7 @@ SiSHandleBackLight(SISPtr pSiS, Bool blon)
 	        ((pSiS->VBFlags2 & (VB2_LVDS | VB2_CHRONTEL)) == VB2_LVDS)) ) {
 
        if(!blon) {
-	  setSISIDXREG(SISSR, 0x11, sr11mask, 0x08);
+	   		setSISIDXREG(SISSR, 0x11, sr11mask, 0x08);
        } else {
 	  setSISIDXREG(SISSR, 0x11, sr11mask, 0x00);
        }
@@ -8343,7 +8942,6 @@ SISDisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode, int fla
     UChar  p1_13=0, p2_0=0, oldpmreg=0;
 
     if(!pScrn->vtSema) return;
-
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
           "SISDisplayPowerManagementSet(%d)\n", PowerManagementMode);
 
@@ -8482,10 +9080,209 @@ SISDisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode, int fla
 
 }
 
-/* Mandatory
- * This gets called at the start of each server generation
- *
- * We use pScrn and not CurrentLayout here, because the
+/*************************************************************/
+/*                  ScreenInit() helpers                     */
+/*************************************************************/
+
+/* Gamma, brightness, contrast */
+
+static unsigned short
+calcgammaval(int j, int nramp, float invgamma, float bri, float c)
+{
+    float k = (float)j;
+    float nrm1 = (float)(nramp - 1);
+    float con = c * nrm1 / 3.0;
+    float l, v;
+
+    if(con != 0.0) {
+       l = nrm1 / 2.0;
+       if(con <= 0.0) {
+          k -= l;
+          k *= (l + con) / l;
+       } else {
+          l -= 1.0;
+          k -= l;
+          k *= l / (l - con);
+       }
+       k += l;
+       if(k < 0.0) k = 0.0;
+    }
+
+    if(invgamma == 1.0) {
+       v = k / nrm1 * 65535.0;
+    } else {
+       v = pow(k / nrm1, invgamma) * 65535.0 + 0.5;
+    }
+
+    v += (bri * (65535.0 / 3.0)) ;
+
+    if(v < 0.0) v = 0.0;
+    else if(v > 65535.0) v = 65535.0;
+    return (unsigned short)v;
+}
+
+#ifdef SISGAMMARAMP
+void
+SISCalculateGammaRamp(ScreenPtr pScreen, ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int    i, j, nramp;
+   UShort *ramp[3];
+   float  gamma_max[3], framp;
+   Bool   newmethod = FALSE;
+
+   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_OLDGAMMAINUSE)) {
+      newmethod = TRUE;
+   } else {
+      gamma_max[0] = (float)pSiS->GammaBriR / 1000;
+      gamma_max[1] = (float)pSiS->GammaBriG / 1000;
+      gamma_max[2] = (float)pSiS->GammaBriB / 1000;
+   }
+
+   if(!(nramp = xf86GetGammaRampSize(pScreen))) return;
+
+   for(i=0; i<3; i++) {
+      ramp[i] = (UShort *)xalloc(nramp * sizeof(UShort));
+      if(!ramp[i]) {
+	 if(ramp[0]) { xfree(ramp[0]); ramp[0] = NULL; }
+	 if(ramp[1]) { xfree(ramp[1]); ramp[1] = NULL; }
+	 return;
+      }
+   }
+
+   if(newmethod) {
+
+      for(i = 0; i < 3; i++) {
+
+         float invgamma = 0.0, bri = 0.0, con = 0.0;
+
+         switch(i) {
+         case 0: invgamma = 1. / pScrn->gamma.red;
+		 bri = pSiS->NewGammaBriR;
+		 con = pSiS->NewGammaConR;
+		 break;
+         case 1: invgamma = 1. / pScrn->gamma.green;
+		 bri = pSiS->NewGammaBriG;
+		 con = pSiS->NewGammaConG;
+		 break;
+         case 2: invgamma = 1. / pScrn->gamma.blue;
+		 bri = pSiS->NewGammaBriB;
+                 con = pSiS->NewGammaConB;
+		 break;
+         }
+
+	 for(j = 0; j < nramp; j++) {
+	    ramp[i][j] = calcgammaval(j, nramp, invgamma, bri, con);
+	 }
+
+      }
+
+   } else {
+
+      for(i = 0; i < 3; i++) {
+         int fullscale = 65535 * gamma_max[i];
+         float dramp = 1. / (nramp - 1);
+         float invgamma = 0.0, v;
+
+         switch(i) {
+         case 0: invgamma = 1. / pScrn->gamma.red; break;
+         case 1: invgamma = 1. / pScrn->gamma.green; break;
+         case 2: invgamma = 1. / pScrn->gamma.blue; break;
+         }
+
+         for(j = 0; j < nramp; j++) {
+	    framp = pow(j * dramp, invgamma);
+
+	    v = (fullscale < 0) ? (65535 + fullscale * framp) :
+			       fullscale * framp;
+	    if(v < 0) v = 0;
+	    else if(v > 65535) v = 65535;
+	    ramp[i][j] = (UShort)v;
+         }
+      }
+
+   }
+
+   xf86ChangeGammaRamp(pScreen, nramp, ramp[0], ramp[1], ramp[2]);
+
+   xfree(ramp[0]);
+   xfree(ramp[1]);
+   xfree(ramp[2]);
+   ramp[0] = ramp[1] = ramp[2] = NULL;
+}
+#endif
+
+void
+SISCalculateGammaRampCRT2(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int    i;
+   int    myshift = 16 - pScrn->rgbBits;
+   int    maxvalue = (1 << pScrn->rgbBits) - 1;
+   int    reds = pScrn->mask.red >> pScrn->offset.red;
+   int    greens = pScrn->mask.green >> pScrn->offset.green;
+   int    blues = pScrn->mask.blue >> pScrn->offset.blue;
+   float  framp, invgamma1, invgamma2, invgamma3, v;
+
+   invgamma1  = 1. / pSiS->GammaR2;
+   invgamma2  = 1. / pSiS->GammaG2;
+   invgamma3  = 1. / pSiS->GammaB2;
+
+   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_OLDGAMMAINUSE)) {
+
+      for(i = 0; i < pSiS->CRT2ColNum; i++) {
+         pSiS->crt2gcolortable[i].red = calcgammaval(i, pSiS->CRT2ColNum, invgamma1,
+			pSiS->NewGammaBriR2, pSiS->NewGammaConR2) >> myshift;
+         pSiS->crt2gcolortable[i].green = calcgammaval(i, pSiS->CRT2ColNum, invgamma2,
+			pSiS->NewGammaBriG2, pSiS->NewGammaConG2) >> myshift;
+         pSiS->crt2gcolortable[i].blue = calcgammaval(i, pSiS->CRT2ColNum, invgamma3,
+			pSiS->NewGammaBriB2, pSiS->NewGammaConB2) >> myshift;
+      }
+
+   } else {
+
+      int fullscale1 = 65536 * (float)pSiS->GammaBriR2 / 1000;
+      int fullscale2 = 65536 * (float)pSiS->GammaBriG2 / 1000;
+      int fullscale3 = 65536 * (float)pSiS->GammaBriB2 / 1000;
+
+      float dramp = 1. / (pSiS->CRT2ColNum - 1);
+
+      for(i = 0; i < pSiS->CRT2ColNum; i++) {
+         framp = pow(i * dramp, invgamma1);
+         v = (fullscale1 < 0) ? (65535 + fullscale1 * framp) : fullscale1 * framp;
+         if(v < 0) v = 0;
+         else if(v > 65535) v = 65535;
+         pSiS->crt2gcolortable[i].red = ((UShort)v) >> myshift;
+         framp = pow(i * dramp, invgamma2);
+         v = (fullscale2 < 0) ? (65535 + fullscale2 * framp) : fullscale2 * framp;
+         if(v < 0) v = 0;
+         else if(v > 65535) v = 65535;
+         pSiS->crt2gcolortable[i].green = ((UShort)v) >> myshift;
+         framp = pow(i * dramp, invgamma3);
+         v = (fullscale3 < 0) ? (65535 + fullscale3 * framp) : fullscale3 * framp;
+         if(v < 0) v = 0;
+         else if(v > 65535) v = 65535;
+         pSiS->crt2gcolortable[i].blue = ((UShort)v) >> myshift;
+      }
+
+   }
+
+   for(i = 0; i < pSiS->CRT2ColNum; i++) {
+      pSiS->crt2colors[i].red =
+         pSiS->crt2gcolortable[i * maxvalue / reds].red;
+      pSiS->crt2colors[i].green =
+         pSiS->crt2gcolortable[i * maxvalue / greens].green;
+      pSiS->crt2colors[i].blue  =
+         pSiS->crt2gcolortable[i * maxvalue / blues].blue;
+   }
+}
+
+
+/*************************************************************/
+/*                       ScreenInit()                        */
+/*************************************************************/
+
+/* We use pScrn and not CurrentLayout here, because the
  * properties we use have not changed (displayWidth,
  * depth, bitsPerPixel)
  */
@@ -8552,6 +9349,10 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 
     if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
 
+       /* Set up (reset) CR32, CR36, CR37 according to our detection results */
+       /* (For ScreenInit() called after CloseScreen()) */
+       SiSRestoreCR323637(pSiS);
+
        if(!pSiS->OldMode) {
 
           /* Try to find out current (=old) mode number
@@ -8612,6 +9413,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
      */
     if(pScrn->currentMode != pSiS->currentModeLast) {
        pSiS->VBFlags = pSiS->VBFlags_backup = pSiS->VBFlagsInit;
+       pSiS->VBFlags3 = pSiS->VBFlags3Init;
     }
 
     /* Copy our detected monitor gammas, part 2. Note that device redetection
@@ -8630,6 +9432,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     }
 #endif
 
+
     /* Initialize the first mode */
     if(!SISModeInit(pScrn, pScrn->currentMode)) {
        SISErrorLog(pScrn, "SiSModeInit() failed\n");
@@ -8643,7 +9446,26 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
      */
     SISSaveScreen(pScreen, SCREEN_SAVER_ON);
 
-    /* Set the viewport */
+    /* Set the viewport. Reset it if the current settings are bad. */
+    /* If we reserved a larger virtual for later, we run on "false"
+     * pScrn->virtuals here. Hence, we use the ones that will be
+     * set by our CreateScreenResources wrapper later on.
+     */
+    if(pScrn->frameX0 < 0) pScrn->frameX0 = 0;
+    if(pScrn->frameY0 < 0) pScrn->frameY0 = 0;
+    {
+       int virtX = pScrn->virtualX, virtY = pScrn->virtualY;
+       pScrn->frameX1 = pScrn->frameX0 + pScrn->currentMode->HDisplay - 1;
+       pScrn->frameY1 = pScrn->frameY0 + pScrn->currentMode->VDisplay - 1;
+       if(pScrn->frameX1 >= virtX) {
+	  pScrn->frameX0 = virtX - pScrn->currentMode->HDisplay;
+	  pScrn->frameX1 = pScrn->frameX0 + pScrn->currentMode->HDisplay - 1;
+       }
+       if(pScrn->frameY1 >= virtY) {
+	  pScrn->frameY0 = virtY - pScrn->currentMode->VDisplay;
+	  pScrn->frameY1 = pScrn->frameY0 + pScrn->currentMode->VDisplay - 1;
+       }
+    }
     SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
 
     /* Reset visual list. */
@@ -8692,7 +9514,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 
     /* Point cmdQueuePtr to pSiSEnt for shared usage
      * (same technique is then eventually used in DRIScreeninit)
-     * For 315/330 series, this is done in EnableTurboQueue
+     * For 315+ series, this is done in EnableTurboQueue
      * which has already been called during ModeInit().
      */
 #ifdef SISDUALHEAD
@@ -8714,7 +9536,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 		"DRI not supported in Dual Head mode\n");
        } else
 #endif
-	      if(pSiS->VGAEngine != SIS_315_VGA) {
+       if((pSiS->VGAEngine == SIS_315_VGA)||(pSiS->VGAEngine == SIS_300_VGA)) {
 	  /* Force the initialization of the context */
 	  pSiS->directRenderingEnabled = SISDRIScreenInit(pScreen);
        } else {
@@ -8771,8 +9593,18 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     /* Initialize RENDER extension (must be after RGB ordering fixed) */
     fbPictureInit(pScreen, 0, 0);
 
-    /* Hardware cursor needs to wrap this layer */
-    if(!pSiS->ShadowFB) SISDGAInit(pScreen);
+    /* Initialize DGA (must do before cursor initialization) */
+    if(!pSiS->ShadowFB) {
+#ifndef SISISXORG6899900
+       if(pSiS->UseDynamicModelists) {
+          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+          	"Using dynamic modelist. DGA disabled due to incompatibility.\n");
+          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+          	"\tOption \"DynamicModelist\" \"off\" will re-enable DGA.\n");
+       } else
+#endif
+          SISDGAInit(pScreen);
+    }
 
     xf86SetBlackWhitePixels(pScreen);
 
@@ -8803,11 +9635,10 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	     pSiSEnt->SiSFastVidCopy = SiSVidCopyInit(pScreen, &pSiSEnt->SiSFastMemCopy, FALSE);
 	     pSiSEnt->SiSFastVidCopyFrom = SiSVidCopyGetDefault();
 	     pSiSEnt->SiSFastMemCopyFrom = SiSVidCopyGetDefault();
-#ifdef SIS_USE_EXA
-	     if(pSiS->useEXA) {
+	     if(pSiS->useEXA
+						       ) {
 	        pSiSEnt->SiSFastVidCopyFrom = SiSVidCopyInit(pScreen, &pSiSEnt->SiSFastMemCopyFrom, TRUE);
 	     }
-#endif /* EXA */
 	     pSiSEnt->HaveFastVidCpy = TRUE;
 	     pSiS->SiSFastVidCopy = pSiSEnt->SiSFastVidCopy;
 	     pSiS->SiSFastMemCopy = pSiSEnt->SiSFastMemCopy;
@@ -8821,11 +9652,10 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	  pSiS->SiSFastVidCopy = SiSVidCopyInit(pScreen, &pSiS->SiSFastMemCopy, FALSE);
 	  pSiS->SiSFastVidCopyFrom = SiSVidCopyGetDefault();
 	  pSiS->SiSFastMemCopyFrom = SiSVidCopyGetDefault();
-#ifdef SIS_USE_EXA
-	  if(pSiS->useEXA) {
+	  if(pSiS->useEXA
+						    ) {
 	     pSiS->SiSFastVidCopyFrom = SiSVidCopyInit(pScreen, &pSiS->SiSFastMemCopyFrom, TRUE);
 	  }
-#endif /* EXA */
 #ifdef SISDUALHEAD
        }
 #endif
@@ -8839,10 +9669,12 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     /* Initialise cursor functions */
     miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
 
+    /* Initialise HW cursor */
     if(pSiS->HWCursor) {
        SiSHWCursorInit(pScreen);
     }
 
+    /* Set up gamma correction for CRT2 */
 #ifdef SISDUALHEAD
     if(!pSiS->DualHeadMode) {
 #endif
@@ -8890,7 +9722,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
        return FALSE;
     }
 
-    /* Recalculate our gamma ramp for brightness feature */
+    /* Recalculate our gamma ramp for brightness, contrast feature */
 #ifdef SISGAMMARAMP
     if((pSiS->GammaBriR != 1000) ||
        (pSiS->GammaBriB != 1000) ||
@@ -8905,12 +9737,15 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     }
 #endif
 
-    /* Initialize Shadow framebuffer and screen rotation/reflection */
+    /* Backup pScrn->PointerMoved */
+    if(!pSiS->PointerMoved) {
+       pSiS->PointerMoved = pScrn->PointerMoved;
+    }
+
+    /* Initialize shadow framebuffer and screen rotation/reflection */
     if(pSiS->ShadowFB) {
        RefreshAreaFuncPtr refreshArea = SISRefreshArea;
-
        if(pSiS->Rotate) {
-	  if(!pSiS->PointerMoved) pSiS->PointerMoved = pScrn->PointerMoved;
 	  pScrn->PointerMoved = SISPointerMoved;
 	  switch(pScrn->bitsPerPixel) {
 	     case 8:  refreshArea = SISRefreshArea8;  break;
@@ -8925,27 +9760,28 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 #endif
        } else if(pSiS->Reflect) {
           switch(pScrn->bitsPerPixel) {
-	  case 8:
-	  case 16:
-	  case 32:
-             if(!pSiS->PointerMoved) pSiS->PointerMoved = pScrn->PointerMoved;
-	     pScrn->PointerMoved = SISPointerMovedReflect;
-	     refreshArea = SISRefreshAreaReflect;
+	     case 8:
+	     case 16:
+	     case 32:
+		pScrn->PointerMoved = SISPointerMoved;
+		refreshArea = SISRefreshAreaReflect;
 #if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
-	     xf86DisableRandR();
-	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		  "Driver reflection enabled, disabling RandR\n");
+		xf86DisableRandR();
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+			"Driver reflection enabled, disabling RandR\n");
 #endif
-	     break;
-	  default:
-	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-	     	  "Reflection not supported at this framebuffer depth\n");
+		break;
+	     default:
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			"Reflection not supported at this framebuffer depth\n");
 	  }
        }
 
        ShadowFBInit(pScreen, refreshArea);
+
     }
 
+    /* Init DPMS */
     xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSet, 0);
 
     /* Init memPhysBase and fbOffset in pScrn */
@@ -8957,10 +9793,15 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 #if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
     if((!pSiS->NoXvideo) && (!(pSiS->SiS_SD2_Flags & SiS_SD2_NOOVERLAY))) {
 
+       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		"Hardware supports %s video overlay%s\n",
+		pSiS->hasTwoOverlays ? "two" : "one",
+		pSiS->hasTwoOverlays ? "s" : "");
+
        if((pSiS->VGAEngine == SIS_300_VGA) ||
 	  (pSiS->VGAEngine == SIS_315_VGA)) {
 
-	  const char *using = "Using SiS300/315/330/340 series HW Xv";
+	  const char *using = "Using SiS300/315/330/340/350 series HW Xv";
 
 #ifdef SISDUALHEAD
 	  if(pSiS->DualHeadMode) {
@@ -9017,6 +9858,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     }
 #endif
 
+   /* Finish DRI initialisation */
 #ifdef XF86DRI
     if(pSiS->loadDRI) {
        if(pSiS->directRenderingEnabled) {
@@ -9037,8 +9879,7 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     pSiS->SiS_SD_Flags &= ~(SiS_SD_PSEUDOXINERAMA);
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
-       pSiS->PointerMoved = pScrn->PointerMoved;
-       pScrn->PointerMoved = SISMergedPointerMoved;
+       pScrn->PointerMoved = SISMFBPointerMoved;
        pSiS->Rotate = 0;
        pSiS->Reflect = 0;
        pSiS->ShadowFB = FALSE;
@@ -9111,8 +9952,8 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
        }
     } else {
 #endif
-       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
        sisclearvram(pSiS->FbBase, OnScreenSize);
+       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
 #ifdef SISDUALHEAD
     }
 #endif
@@ -9143,41 +9984,492 @@ SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     pSiS->SiS_SD_Flags &= ~SiS_SD_CANSETGAMMA;
 #endif
 
+    /* Initialize SISCTRL extension */
     SiSCtrlExtInit(pScrn);
 
+    pSiS->virtualX = pScrn->virtualX;
+    pSiS->virtualY = pScrn->virtualY;
+#ifdef SIS_HAVE_RR_FUNC
+#ifdef SIS_HAVE_DRIVER_FUNC
+    pScrn->DriverFunc = SISDriverFunc;
+#else
+    pScrn->RRFunc = SISDriverFunc;
+#endif
+#endif
+
+    /* Wrap Adjustframe again (Xv has wrapped it in the meantime)
+     * in order to avoid race conditions due to AdjustFrame being
+     * called asynchonously if silken mouse is enabled.
+     */
+    pSiS->AdjustFramePending = FALSE;
+    pSiS->AdjustFrame = pScrn->AdjustFrame;
+    pScrn->AdjustFrame = SISNewAdjustFrame;
+
+    /* Wrap CreateScreenResources in order to be able to fiddle
+     * with RandR sizes and set an initial RandR size. We do this
+     * only once at server start. Later it's not needed. Although
+     * RandR resets the size on CloseScreen(), the sizes must match
+     * the then current modelist (think dynamic modelist). So
+     * resetting it every time ScreenInit() is called would be
+     * wrong.
+     */
+
     return TRUE;
 }
 
-/* Usually mandatory */
+
+/*********************************************************/
+/*                   ValidMode() etc                     */
+/*********************************************************/
+
+
+static Bool
+SiSValidLCDUserMode(SISPtr pSiS, unsigned int VBFlags, DisplayModePtr mode, Bool isforlcda)
+{
+   if(mode->Flags & V_INTERLACE) return FALSE;
+
+   if(mode->HDisplay > 2048) return FALSE;
+   if(mode->VDisplay > 1536) return FALSE;
+
+   if(pSiS->VBFlags2 & VB2_LCDOVER1600BRIDGE) {
+
+      /* Will this be dual-link? */
+      if(mode->Clock > 162500) return FALSE;  /* temp */
+
+   } else if(pSiS->VBFlags2 & VB2_LCD162MHZBRIDGE) {
+
+      if(mode->Clock > 162500) return FALSE;
+      if(!isforlcda) {
+         if(mode->HDisplay > 1600) return FALSE;
+      }
+
+   } else { /* 301, 301B, 302B (no LCDA!) */
+
+      if(mode->Clock > 130000)  return FALSE;
+      if(mode->Clock > 111000) {
+         xf86DrvMsg(pSiS->pScrn->scrnIndex, X_WARNING,
+	 	"WARNING: Mode clock beyond video bridge specs (%dMHz). Hardware damage might occure.\n",
+		mode->Clock / 1000);
+      }
+      if(mode->HDisplay > 1600) return FALSE;
+      if(mode->VDisplay > 1024) return FALSE;
+
+   }
+
+   return TRUE;
+}
+
+static Bool
+SiSValidVGA2UserMode(SISPtr pSiS, unsigned int VBFlags, DisplayModePtr mode)
+{
+   if(mode->Flags & V_INTERLACE) return FALSE;
+
+   if(mode->HDisplay > 2048) return FALSE;
+   if(mode->VDisplay > 1536) return FALSE;
+
+   if(pSiS->VBFlags2 & VB2_RAMDAC202MHZBRIDGE) {
+      if(mode->Clock > 203000) return FALSE;
+   } else if(pSiS->VBFlags2 & VB2_30xBLV) {
+      if(mode->Clock > 162500) return FALSE;
+   } else {
+      if(mode->Clock > 135500) return FALSE;
+   }
+
+   return TRUE;
+}
+
+UShort
+SiS_CheckModeCRT1(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags,
+			unsigned int VBFlags3, Bool havecustommodes)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UShort i = pSiS->CurrentLayout.bytesPerPixel - 1;
+   int j;
+
+   if((!(VBFlags & CRT1_LCDA)) && (!(VBFlags3 & VB3_CRT1_LCD))) {
+
+      if((havecustommodes) && (!(mode->type & M_T_DEFAULT))) {
+         return 0xfe;
+      }
+
+   } else if(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE) {
+
+      /* if(pSiS->ChipType < ?) {  */
+         if(!(mode->type & M_T_DEFAULT)) {
+            if(mode->HTotal > 2055) return 0;
+	    /* (Default mode will be caught in mode switching code) */
+	 }
+      /* } */
+
+      if(pSiS->SiS_Pr->CP_HaveCustomData) {
+         for(j=0; j<7; j++) {
+            if((pSiS->SiS_Pr->CP_DataValid[j]) &&
+               (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
+               (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
+               (mode->type & M_T_BUILTIN))
+               return 0xfe;
+	 }
+      }
+
+      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
+         return 0xfe;
+
+      if((havecustommodes) &&
+         (pSiS->LCDwidth)  &&	/* = test if LCD present */
+         (!(mode->type & M_T_DEFAULT)) &&
+	 (SiSValidLCDUserMode(pSiS, VBFlags, mode, TRUE)))
+         return 0xfe;
+
+      if((mode->HDisplay > pSiS->LCDwidth) ||
+         (mode->VDisplay > pSiS->LCDheight)) {
+	 return 0;
+      }
+
+   } else {
+
+      if((mode->HDisplay > pSiS->LCDwidth) ||
+         (mode->VDisplay > pSiS->LCDheight)) {
+	  if((pSiS->EnablePanel_1366x768) && /*let the 1366x768 mode valid. Ivans@090109*/
+	     (pSiS->LCDwidth==1366)       &&
+	     (mode->HDisplay==1368)){
+	     ;
+	  } 
+	  else {
+	    return 0;
+	  }
+      }
+
+   }
+
+   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
+   			i, pSiS->FSTN, pSiS->LCDwidth, pSiS->LCDheight));
+}
+
+UShort
+SiS_CheckModeCRT2(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags,
+			unsigned int VBFlags3, Bool havecustommodes)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UShort i = pSiS->CurrentLayout.bytesPerPixel - 1;
+   UShort ModeIndex = 0;
+   int    j;
+
+#ifdef TWDEBUG
+   xf86DrvMsg(0, X_INFO, "Inside CheckCalcModeIndex (VBFlags %lx, mode %dx%d)\n",
+	VBFlags,mode->HDisplay, mode->VDisplay);
+#endif
+
+   if(VBFlags & CRT2_LCD) {			/* CRT2 is LCD */
+
+      if((pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) && (!(pSiS->VBFlags2 & VB2_30xBDH))) {
+
+         if(pSiS->SiS_Pr->CP_HaveCustomData) {
+            for(j=0; j<7; j++) {
+               if((pSiS->SiS_Pr->CP_DataValid[j]) &&
+                  (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
+                  (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
+#ifdef VB_FORBID_CRT2LCD_OVER_1600
+		  (mode->HDisplay <= 1600) 			   &&
+#endif
+                  (mode->type & M_T_BUILTIN))
+                  return 0xfe;
+	    }
+         }
+
+	 /* All plasma modes have HDisplay <= 1600 */
+         if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
+            return 0xfe;
+
+         if((havecustommodes) &&
+            (pSiS->LCDwidth)  &&	/* = test if LCD present */
+	    (!(mode->type & M_T_DEFAULT)) &&
+	    (SiSValidLCDUserMode(pSiS, VBFlags, mode, FALSE)))
+            return 0xfe;
+
+      }
+
+      if( ((mode->HDisplay <= pSiS->LCDwidth) &&
+           (mode->VDisplay <= pSiS->LCDheight)) ||
+	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL848) &&
+	   (((mode->HDisplay == 1360) && (mode->HDisplay == 768)) ||
+	    ((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
+	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ||
+	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL856) &&
+	   (((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
+	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ||
+	   ((pSiS->EnablePanel_1366x768)&&(pSiS->LCDwidth==1366)&&(mode->HDisplay==1368))) {/*let 1366x768 mode valid. Ivans@090109*/
+
+	 ModeIndex = SiS_GetModeID_LCD(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
+				pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight,
+				pSiS->VBFlags2);
+
+      }
+
+   } else if(VBFlags & CRT2_TV) {		/* CRT2 is TV */
+
+      ModeIndex = SiS_GetModeID_TV(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
+					pSiS->VBFlags2);
+
+   } else if(VBFlags & CRT2_VGA) {		/* CRT2 is VGA2 */
+
+      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
+	 return 0xfe;
+
+      if((havecustommodes) &&
+	 (!(mode->type & M_T_DEFAULT)) &&
+	 (SiSValidVGA2UserMode(pSiS, VBFlags, mode)))
+         return 0xfe;
+
+      ModeIndex = SiS_GetModeID_VGA2(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
+					pSiS->VBFlags2);
+
+   } else {					/* no CRT2 */
+
+      /* Return a valid mode number */
+      ModeIndex = 0xfe;
+
+   }
+
+   return ModeIndex;
+}
+
+static ModeStatus
+SISValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
+{
+    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SISPtr pSiS = SISPTR(pScrn);
+
+    if(pSiS->UseVESA) {
+       if(SiSCalcVESAModeIndex(pScrn, mode))
+	  return MODE_OK;
+       else
+	  return MODE_BAD;
+    }
+
+    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+#ifdef SISDUALHEAD
+       if(pSiS->DualHeadMode) {
+          if(pSiS->SecondHead) {
+	     if(SiS_CheckModeCRT1(pScrn, mode, pSiS->VBFlags,
+			pSiS->VBFlags3, pSiS->HaveCustomModes) < 0x14)
+	        return MODE_BAD;
+	  } else {
+	     if(SiS_CheckModeCRT2(pScrn, mode, pSiS->VBFlags,
+			pSiS->VBFlags3, pSiS->HaveCustomModes) < 0x14)
+	        return MODE_BAD;
+	  }
+       } else
+#endif
+#ifdef SISMERGED
+       if(pSiS->MergedFB) {
+	  if(!mode->Private) {
+	     if(!pSiS->CheckForCRT2) {
+	        if(SiS_CheckModeCRT1(pScrn, mode, pSiS->VBFlags,
+				pSiS->VBFlags3, pSiS->HaveCustomModes) < 0x14)
+	           return MODE_BAD;
+	     } else {
+	        if(SiS_CheckModeCRT2(pScrn, mode, pSiS->VBFlags,
+				pSiS->VBFlags3, pSiS->HaveCustomModes2) < 0x14)
+	           return MODE_BAD;
+	     }
+	  } else {
+	     if(SiS_CheckModeCRT1(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
+		                  pSiS->VBFlags, pSiS->VBFlags3, pSiS->HaveCustomModes) < 0x14)
+	        return MODE_BAD;
+
+	     if(SiS_CheckModeCRT2(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
+		                  pSiS->VBFlags, pSiS->VBFlags3, pSiS->HaveCustomModes2) < 0x14)
+	        return MODE_BAD;
+ 	  }
+       } else
+#endif
+       {
+	  if(SiS_CheckModeCRT1(pScrn, mode, pSiS->VBFlags,
+			pSiS->VBFlags3, pSiS->HaveCustomModes) < 0x14)
+	     return MODE_BAD;
+          #ifdef TWDEBUG
+          xf86DrvMsg(0,X_INFO,"[SISValidMode()]: else condition, passing CheckModeCRT1 and MODE_OK.\n");
+          #endif
+	  if(SiS_CheckModeCRT2(pScrn, mode, pSiS->VBFlags,
+			pSiS->VBFlags3, pSiS->HaveCustomModes) < 0x14){
+	       #ifdef TWDEBUG
+		  xf86DrvMsg(0,X_INFO,"[SISValidMode()]: else condition. passing CheckModeCRT2 and MODE_OK.\n");
+	       #endif	  
+	       return MODE_BAD;
+	  }
+          #ifdef  TWDEBUG
+	  xf86DrvMsg(0,X_INFO,"[SISValidMode()]: else condition. passing CheckModeCRT2 and MODE_OK.\n");
+          #endif
+       }
+    }
+
+    return MODE_OK;
+}
+
+/*********************************************************/
+/*                   SwitchMode() etc.                   */
+/*********************************************************/
+
+#ifdef SIS_HAVE_RR_GET_MODE_MM
+static Bool
+SiS_GetModeMM(ScrnInfoPtr pScrn, DisplayModePtr mode, int virtX, int virtY,
+			int *mmWidth, int *mmHeight)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    int width = virtX, height = virtY;
+
+#ifdef SISMERGED
+    if(pSiS->MergedFB) {
+       SiSMFBCalcDPIPerMode(pScrn, mode, virtX, virtY, mmWidth, mmHeight);
+       return TRUE;
+    }
+#endif
+
+    if(pSiS->constantDPI) {
+
+       /* Provide clients with constant DPI values
+        * regardless of the screen size.
+        * DPI will always be what they were at
+        * server start.
+        */
+
+       if(mode) {
+          width = mode->HDisplay;
+          height = mode->VDisplay;
+       }
+       *mmWidth = (width * 254 + pScrn->xDpi * 5) / (pScrn->xDpi * 10);
+       *mmHeight = (height * 254 + pScrn->yDpi * 5) / (pScrn->yDpi * 10);
+
+    } else {
+
+       /* Let RandR mess with the DPI by leaving mmWidth/mmHeight
+	* alone.
+	*
+	* Quick brainstorming on what could be done here:
+	* - 300+: What about a grow of the screen size? Should
+	*   the startup-DPI be the same for the new virtual
+	*   screen size? Right now, the display size will be
+	*   left untouched. This will lead to a growing DPI
+	*   value for larger resolutions, and a shrinking one
+	*   for lower resolutions.
+	*   Alternative: Redo the mmWidth/Height based on the
+	*   largest screen mode/virtual size (whichever is
+	*   the larger) so that the start-up DPI are now based
+	*   on this largest dimension. Disadvantage: This will
+	*   result in even smaller DPI values for lower
+	*   resolutions.
+	*
+	* Note: Due to our hack in RebuildModelist, the provided
+	* virtX/Y does not necessarily represent the maximum!
+	*/
+
+    }
+
+    return TRUE;
+}
+#endif
+
+#if defined(RANDR) && !defined(SIS_HAVE_RR_GET_MODE_MM)
+static void
+SiSResetDPI(ScrnInfoPtr pScrn, Bool force)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
+
+    if(force					||
+       (pSiS->SiSDPIVX != pScrn->virtualX)	||
+       (pSiS->SiSDPIVY != pScrn->virtualY)
+					  ) {
+
+       pScreen->mmWidth = (pScrn->virtualX * 254 + pScrn->xDpi * 5) / (pScrn->xDpi * 10);
+       pScreen->mmHeight = (pScrn->virtualY * 254 + pScrn->yDpi * 5) / (pScrn->yDpi * 10);
+
+       pSiS->SiSDPIVX = pScrn->virtualX;
+       pSiS->SiSDPIVY = pScrn->virtualY;
+
+    }
+}
+#endif
+
 Bool
 SISSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
     SISPtr pSiS = SISPTR(pScrn);
+   /* This is part 2 of the ugly hack in sis_shadow.c:
+    * There we set pScrn->currentMode to something
+    * different in order to overcome the
+    * "if(mode == pscrn->currentMode) return TRUE"
+    * statement in xf86SwitchMode. Now, if we
+    * find pScrn->currentMode == &pSiS->PseudoMode,
+    * we reset pScrn->currentMode, and if the
+    * mode to set is already set, we just recalc
+    * the DPI eventually, and bail out.
+    * (In non-MergedFB mode this is also here in order
+    * to get a cheap update of the HWCursor image)
+    */
 
     if(!pSiS->skipswitchcheck) {
        if(SISValidMode(scrnIndex, mode, TRUE, flags) != MODE_OK) {
           return FALSE;
        }
     }
+/* Mark for 3D full-screen bug */
+/*
+#ifdef XF86DRI    
+    if(pSiS->directRenderingEnabled) {       
+	DRILock(screenInfo.screens[scrnIndex], DRM_LOCK_QUIESCENT);
+    }
+#endif
+*/
 
     (*pSiS->SyncAccel)(pScrn);
 
-    if(!(SISModeInit(xf86Screens[scrnIndex], mode))) return FALSE;
+    if(!(SISModeInit(xf86Screens[scrnIndex], mode)))
+       return FALSE;
 
     /* Since RandR (indirectly) uses SwitchMode(), we need to
      * update our Xinerama info here, too, in case of resizing
+     * (and we didn't bail out above already).
+     * Furthermore, we recalc the DPI eventually. (Note that
+     * the availability of RR_GET_MODE_MM makes DPI recalculation
+     * at this place redundant.)
      */
 #ifdef SISMERGED
-#ifdef SISXINERAMA
     if(pSiS->MergedFB) {
+#if defined(RANDR) && !defined(SIS_HAVE_RR_GET_MODE_MM)
+       SiSMFBResetDpi(pScrn, FALSE);
+#endif
+#ifdef SISXINERAMA
        SiSUpdateXineramaScreenInfo(pScrn);
+#endif
+/* Mark for 3D full-screen bug */
+/*
+#ifdef XF86DRI
+    if(pSiS->directRenderingEnabled) {
+       DRIUnlock(screenInfo.screens[scrnIndex]);
     }
 #endif
+*/
+       return TRUE;
+    }
 #endif
+
+#if defined(RANDR) && !defined(SIS_HAVE_RR_GET_MODE_MM)
+    if(pSiS->constantDPI) {
+       SiSResetDPI(pScrn, FALSE);
+    }
+#endif
+
     return TRUE;
 }
 
+
+/*********************************************************/
+/*                     AdjustFrame()                     */
+/*********************************************************/
+
+
 static void
 SISSetStartAddressCRT1(SISPtr pSiS, ULong base)
 {
@@ -9208,20 +10500,16 @@ SISSetStartAddressCRT2(SISPtr pSiS, ULong base)
     SiS_LockCRT2(pSiS->SiS_Pr);
 }
 
-#ifdef SISMERGED
-static Bool
-InRegion(int x, int y, region r)
-{
-    return (r.x0 <= x) && (x <= r.x1) && (r.y0 <= y) && (y <= r.y1);
-}
 
-static void
+void
 SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y)
 {
     SISPtr pSiS = SISPTR(pScrn);
     ULong base;
 
-    base = y * pSiS->CurrentLayout.displayWidth + x;
+    RecalcScreenPitch(pScrn);
+
+    base = y * (pSiS->scrnPitch / (pSiS->CurrentLayout.bitsPerPixel >> 3)) + x;
     switch(pSiS->CurrentLayout.bitsPerPixel) {
        case 16:  base >>= 1; 	break;
        case 32:  		break;
@@ -9229,15 +10517,19 @@ SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y)
     }
     base += (pSiS->dhmOffset/4);
     SISSetStartAddressCRT1(pSiS, base);
+
+    SiS_SetPitchCRT1(pSiS->SiS_Pr, pScrn);
 }
 
-static void
+void
 SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y)
 {
     SISPtr pSiS = SISPTR(pScrn);
     ULong base;
 
-    base = y * pSiS->CurrentLayout.displayWidth + x;
+    RecalcScreenPitch(pScrn);
+
+    base = y * (pSiS->scrnPitch / (pSiS->CurrentLayout.bitsPerPixel >> 3)) + x;
     switch(pSiS->CurrentLayout.bitsPerPixel) {
        case 16:  base >>= 1; 	break;
        case 32:  		break;
@@ -9245,389 +10537,38 @@ SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y)
     }
     base += (pSiS->dhmOffset/4);
     SISSetStartAddressCRT2(pSiS, base);
-}
-
-static void
-SISMergedPointerMoved(int scrnIndex, int x, int y)
-{
-  ScrnInfoPtr	pScrn1 = xf86Screens[scrnIndex];
-  SISPtr	pSiS = SISPTR(pScrn1);
-  ScrnInfoPtr	pScrn2 = pSiS->CRT2pScrn;
-  region	out, in1, in2, f2, f1;
-  int		deltax, deltay;
-  int		temp1, temp2;
-  int		old1x0, old1y0, old2x0, old2y0;
-  int		CRT1XOffs = 0, CRT1YOffs = 0, CRT2XOffs = 0, CRT2YOffs = 0;
-  int		HVirt = pScrn1->virtualX;
-  int		VVirt = pScrn1->virtualY;
-  int		sigstate;
-  Bool		doit = FALSE, HaveNonRect = FALSE, HaveOffsRegions = FALSE;
-  SiSScrn2Rel   srel = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position;
-
-  if(pSiS->DGAactive) {
-     return;
-     /* DGA: There is no cursor and no panning while DGA is active. */
-     /* If it were, we would need to do: */
-     /* HVirt = pSiS->CurrentLayout.displayWidth;
-        VVirt = pSiS->CurrentLayout.displayHeight;
-        BOUND(x, pSiS->CurrentLayout.DGAViewportX, HVirt);
-        BOUND(y, pSiS->CurrentLayout.DGAViewportY, VVirt); */
-  } else {
-     CRT1XOffs = pSiS->CRT1XOffs;
-     CRT1YOffs = pSiS->CRT1YOffs;
-     CRT2XOffs = pSiS->CRT2XOffs;
-     CRT2YOffs = pSiS->CRT2YOffs;
-     HaveNonRect = pSiS->HaveNonRect;
-     HaveOffsRegions = pSiS->HaveOffsRegions;
-  }
-
-  /* Check if the pointer is inside our dead areas */
-  if((pSiS->MouseRestrictions) && (srel != sisClone) && !SiSnoPanoramiXExtension) {
-     if(HaveNonRect) {
-	if(InRegion(x, y, pSiS->NonRectDead)) {
-	   switch(srel) {
-	   case sisLeftOf:
-	   case sisRightOf: y = pSiS->NonRectDead.y0 - 1;
-			    doit = TRUE;
-			    break;
-	   case sisAbove:
-	   case sisBelow:   x = pSiS->NonRectDead.x0 - 1;
-			    doit = TRUE;
-	   default:	    break;
-	   }
-	}
-     }
-     if(HaveOffsRegions) {
-	if(InRegion(x, y, pSiS->OffDead1)) {
-	   switch(srel) {
-	   case sisLeftOf:
-	   case sisRightOf: y = pSiS->OffDead1.y1;
-			    doit = TRUE;
-			    break;
-	   case sisAbove:
-	   case sisBelow:   x = pSiS->OffDead1.x1;
-			    doit = TRUE;
-	   default:	    break;
-	   }
-	} else if(InRegion(x, y, pSiS->OffDead2)) {
-	   switch(srel) {
-	   case sisLeftOf:
-	   case sisRightOf: y = pSiS->OffDead2.y0 - 1;
-			    doit = TRUE;
-			    break;
-	   case sisAbove:
-	   case sisBelow:   x = pSiS->OffDead2.x0 - 1;
-			    doit = TRUE;
-	   default:	    break;
-	   }
-	}
-     }
-     if(doit) {
-	UpdateCurrentTime();
-	sigstate = xf86BlockSIGIO();
-	miPointerAbsoluteCursor(x, y, currentTime.milliseconds);
-	xf86UnblockSIGIO(sigstate);
-	return;
-     }
-  }
-
-  f1.x0 = old1x0 = pSiS->CRT1frameX0;
-  f1.x1 = pSiS->CRT1frameX1;
-  f1.y0 = old1y0 = pSiS->CRT1frameY0;
-  f1.y1 = pSiS->CRT1frameY1;
-  f2.x0 = old2x0 = pScrn2->frameX0;
-  f2.x1 = pScrn2->frameX1;
-  f2.y0 = old2y0 = pScrn2->frameY0;
-  f2.y1 = pScrn2->frameY1;
-
-  /* Define the outer region. Crossing this causes all frames to move */
-  out.x0 = pScrn1->frameX0;
-  out.x1 = pScrn1->frameX1;
-  out.y0 = pScrn1->frameY0;
-  out.y1 = pScrn1->frameY1;
-
-  /*
-   * Define the inner sliding window. Being outsize both frames but
-   * inside the outer clipping window will slide corresponding frame
-   */
-  in1 = out;
-  in2 = out;
-  switch(srel) {
-     case sisLeftOf:
-        in1.x0 = f1.x0;
-        in2.x1 = f2.x1;
-        break;
-     case sisRightOf:
-        in1.x1 = f1.x1;
-        in2.x0 = f2.x0;
-        break;
-     case sisBelow:
-        in1.y1 = f1.y1;
-        in2.y0 = f2.y0;
-        break;
-     case sisAbove:
-        in1.y0 = f1.y0;
-        in2.y1 = f2.y1;
-        break;
-     case sisClone:
-        break;
-  }
-
-  deltay = 0;
-  deltax = 0;
-
-  if(InRegion(x, y, out)) {	/* inside outer region */
-
-     if(InRegion(x, y, in1) && !InRegion(x, y, f1)) {
-	REBOUND(f1.x0, f1.x1, x);
-	REBOUND(f1.y0, f1.y1, y);
-	deltax = 1;
-     }
-     if(InRegion(x, y, in2) && !InRegion(x, y, f2)) {
-	REBOUND(f2.x0, f2.x1, x);
-	REBOUND(f2.y0, f2.y1, y);
-	deltax = 1;
-     }
-
-  } else {			/* outside outer region */
 
-     if(out.x0 > x) {
-	deltax = x - out.x0;
-     }
-     if(out.x1 < x) {
-	deltax = x - out.x1;
-     }
-     if(deltax) {
-	pScrn1->frameX0 += deltax;
-	pScrn1->frameX1 += deltax;
-	f1.x0 += deltax;
-	f1.x1 += deltax;
-	f2.x0 += deltax;
-	f2.x1 += deltax;
-     }
-
-     if(out.y0 > y) {
-	deltay = y - out.y0;
-     }
-     if(out.y1 < y) {
-	deltay = y - out.y1;
-     }
-     if(deltay) {
-	pScrn1->frameY0 += deltay;
-	pScrn1->frameY1 += deltay;
-	f1.y0 += deltay;
-	f1.y1 += deltay;
-	f2.y0 += deltay;
-	f2.y1 += deltay;
-     }
-
-     switch(srel) {
-	case sisLeftOf:
-	   if(x >= f1.x0) { REBOUND(f1.y0, f1.y1, y); }
-	   if(x <= f2.x1) { REBOUND(f2.y0, f2.y1, y); }
-	   break;
-	case sisRightOf:
-	   if(x <= f1.x1) { REBOUND(f1.y0, f1.y1, y); }
-	   if(x >= f2.x0) { REBOUND(f2.y0, f2.y1, y); }
-	   break;
-	case sisBelow:
-	   if(y <= f1.y1) { REBOUND(f1.x0, f1.x1, x); }
-	   if(y >= f2.y0) { REBOUND(f2.x0, f2.x1, x); }
-	   break;
-	case sisAbove:
-	   if(y >= f1.y0) { REBOUND(f1.x0, f1.x1, x); }
-	   if(y <= f2.y1) { REBOUND(f2.x0, f2.x1, x); }
-	   break;
-	case sisClone:
-	   break;
-     }
-
-  }
-
-  if(deltax || deltay) {
-     pSiS->CRT1frameX0 = f1.x0;
-     pSiS->CRT1frameY0 = f1.y0;
-     pScrn2->frameX0 = f2.x0;
-     pScrn2->frameY0 = f2.y0;
-
-     switch(srel) {
-	case sisLeftOf:
-	case sisRightOf:
-	   if(CRT1YOffs || CRT2YOffs || HaveNonRect) {
-	      if(pSiS->CRT1frameY0 != old1y0) {
-	         if(pSiS->CRT1frameY0 < CRT1YOffs)
-	            pSiS->CRT1frameY0 = CRT1YOffs;
-
-	         temp1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay;
-	         temp2 = min((VVirt - CRT2YOffs), (CRT1YOffs + pSiS->MBXNR1YMAX));
-	         if(temp1 > temp2)
-	            pSiS->CRT1frameY0 -= (temp1 - temp2);
-	      }
-	      if(pScrn2->frameY0 != old2y0) {
-	         if(pScrn2->frameY0 < CRT2YOffs)
-	            pScrn2->frameY0 = CRT2YOffs;
-
-	         temp1 = pScrn2->frameY0 + CDMPTR->CRT2->VDisplay;
-	         temp2 = min((VVirt - CRT1YOffs), (CRT2YOffs + pSiS->MBXNR2YMAX));
-	         if(temp1 > temp2)
-	            pScrn2->frameY0 -= (temp1 - temp2);
-	      }
-	   }
-	   break;
-	case sisBelow:
-	case sisAbove:
-	   if(CRT1XOffs || CRT2XOffs || HaveNonRect) {
-	      if(pSiS->CRT1frameX0 != old1x0) {
-	         if(pSiS->CRT1frameX0 < CRT1XOffs)
-	            pSiS->CRT1frameX0 = CRT1XOffs;
-
-	         temp1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay;
-	         temp2 = min((HVirt - CRT2XOffs), (CRT1XOffs + pSiS->MBXNR1XMAX));
-	         if(temp1 > temp2)
-	            pSiS->CRT1frameX0 -= (temp1 - temp2);
-	      }
-	      if(pScrn2->frameX0 != old2x0) {
-	         if(pScrn2->frameX0 < CRT2XOffs)
-	            pScrn2->frameX0 = CRT2XOffs;
-
-	         temp1 = pScrn2->frameX0 + CDMPTR->CRT2->HDisplay;
-	         temp2 = min((HVirt - CRT1XOffs), (CRT2XOffs + pSiS->MBXNR2XMAX));
-	         if(temp1 > temp2)
-	            pScrn2->frameX0 -= (temp1 - temp2);
-	      }
-	   }
-	   break;
-	case sisClone:
-	   break;
-     }
-
-     pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
-     pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
-     pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
-     pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
-
-     /* No need to update pScrn1->frame?1, done above */
-
-     SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
-     SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
-  }
+    SiS_SetPitchCRT2(pSiS->SiS_Pr, pScrn);
 }
 
 static void
-SISAdjustFrameMerged(int scrnIndex, int x, int y, int flags)
+SISNewAdjustFrame(int scrnIndex, int x, int y, int flags)
 {
-    ScrnInfoPtr pScrn1 = xf86Screens[scrnIndex];
-    SISPtr pSiS = SISPTR(pScrn1);
-    ScrnInfoPtr pScrn2 = pSiS->CRT2pScrn;
-    int HTotal = pSiS->CurrentLayout.mode->HDisplay;
-    int VTotal = pSiS->CurrentLayout.mode->VDisplay;
-    int HMax = HTotal;
-    int VMax = VTotal;
-    int HVirt = pScrn1->virtualX;
-    int VVirt = pScrn1->virtualY;
-    int x1 = x, x2 = x;
-    int y1 = y, y2 = y;
-    int CRT1XOffs = 0, CRT1YOffs = 0, CRT2XOffs = 0, CRT2YOffs = 0;
-    int MBXNR1XMAX = 65536, MBXNR1YMAX = 65536, MBXNR2XMAX = 65536, MBXNR2YMAX = 65536;
-
-    if(pSiS->DGAactive) {
-       HVirt = pSiS->CurrentLayout.displayWidth;
-       VVirt = pSiS->CurrentLayout.displayHeight;
-    } else {
-       CRT1XOffs = pSiS->CRT1XOffs;
-       CRT1YOffs = pSiS->CRT1YOffs;
-       CRT2XOffs = pSiS->CRT2XOffs;
-       CRT2YOffs = pSiS->CRT2YOffs;
-       MBXNR1XMAX = pSiS->MBXNR1XMAX;
-       MBXNR1YMAX = pSiS->MBXNR1YMAX;
-       MBXNR2XMAX = pSiS->MBXNR2XMAX;
-       MBXNR2YMAX = pSiS->MBXNR2YMAX;
-    }
-
-    BOUND(x, 0, HVirt - HTotal);
-    BOUND(y, 0, VVirt - VTotal);
-    if(SDMPTR(pScrn1)->CRT2Position != sisClone) {
-       BOUND(x1, CRT1XOffs, min(HVirt, MBXNR1XMAX + CRT1XOffs) - min(HTotal, MBXNR1XMAX) - CRT2XOffs);
-       BOUND(y1, CRT1YOffs, min(VVirt, MBXNR1YMAX + CRT1YOffs) - min(VTotal, MBXNR1YMAX) - CRT2YOffs);
-       BOUND(x2, CRT2XOffs, min(HVirt, MBXNR2XMAX + CRT2XOffs) - min(HTotal, MBXNR2XMAX) - CRT1XOffs);
-       BOUND(y2, CRT2YOffs, min(VVirt, MBXNR2YMAX + CRT2YOffs) - min(VTotal, MBXNR2YMAX) - CRT1YOffs);
-    }
-
-    switch(SDMPTR(pScrn1)->CRT2Position) {
-        case sisLeftOf:
-            pScrn2->frameX0 = x2;
-            BOUND(pScrn2->frameY0,   y2, y2 + min(VMax, MBXNR2YMAX) - CDMPTR->CRT2->VDisplay);
-            pSiS->CRT1frameX0 = x1 + CDMPTR->CRT2->HDisplay;
-            BOUND(pSiS->CRT1frameY0, y1, y1 + min(VMax, MBXNR1YMAX) - CDMPTR->CRT1->VDisplay);
-            break;
-        case sisRightOf:
-            pSiS->CRT1frameX0 = x1;
-            BOUND(pSiS->CRT1frameY0, y1, y1 + min(VMax, MBXNR1YMAX) - CDMPTR->CRT1->VDisplay);
-            pScrn2->frameX0 = x2 + CDMPTR->CRT1->HDisplay;
-            BOUND(pScrn2->frameY0,   y2, y2 + min(VMax, MBXNR2YMAX) - CDMPTR->CRT2->VDisplay);
-            break;
-        case sisAbove:
-            BOUND(pScrn2->frameX0,   x2, x2 + min(HMax, MBXNR2XMAX) - CDMPTR->CRT2->HDisplay);
-            pScrn2->frameY0 = y2;
-            BOUND(pSiS->CRT1frameX0, x1, x1 + min(HMax, MBXNR1XMAX) - CDMPTR->CRT1->HDisplay);
-            pSiS->CRT1frameY0 = y1 + CDMPTR->CRT2->VDisplay;
-            break;
-        case sisBelow:
-            BOUND(pSiS->CRT1frameX0, x1, x1 + min(HMax, MBXNR1XMAX) - CDMPTR->CRT1->HDisplay);
-            pSiS->CRT1frameY0 = y1;
-            BOUND(pScrn2->frameX0,   x2, x2 + min(HMax, MBXNR2XMAX) - CDMPTR->CRT2->HDisplay);
-            pScrn2->frameY0 = y2 + CDMPTR->CRT1->VDisplay;
-            break;
-        case sisClone:
-            BOUND(pSiS->CRT1frameX0, x,  x + HMax - CDMPTR->CRT1->HDisplay);
-            BOUND(pSiS->CRT1frameY0, y,  y + VMax - CDMPTR->CRT1->VDisplay);
-            BOUND(pScrn2->frameX0,   x,  x + HMax - CDMPTR->CRT2->HDisplay);
-            BOUND(pScrn2->frameY0,   y,  y + VMax - CDMPTR->CRT2->VDisplay);
-            break;
-    }
-
-    BOUND(pSiS->CRT1frameX0, 0, HVirt - CDMPTR->CRT1->HDisplay);
-    BOUND(pSiS->CRT1frameY0, 0, VVirt - CDMPTR->CRT1->VDisplay);
-    BOUND(pScrn2->frameX0,   0, HVirt - CDMPTR->CRT2->HDisplay);
-    BOUND(pScrn2->frameY0,   0, VVirt - CDMPTR->CRT2->VDisplay);
-
-    pScrn1->frameX0 = x;
-    pScrn1->frameY0 = y;
-
-    pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
-    pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
-    pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
-    pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
-
-    pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
-    pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;
-    if(SDMPTR(pScrn1)->CRT2Position != sisClone) {
-       pScrn1->frameX1 += CRT1XOffs + CRT2XOffs;
-       pScrn1->frameY1 += CRT1YOffs + CRT2YOffs;
-    }
-
-    SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
-    SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
+    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SISPtr      pSiS = SISPTR(pScrn);
+
+    pSiS->AdjustFramePending = TRUE;
+    pSiS->AdjustFrameX = x;
+    pSiS->AdjustFrameY = y;
+    pSiS->AdjustFrameFlags = flags;
 }
-#endif
 
-/*
- * This function is used to initialize the Start Address - the first
- * displayed location in the video memory.
- *
- * Usually mandatory
- */
 void
 SISAdjustFrame(int scrnIndex, int x, int y, int flags)
 {
-    ScrnInfoPtr   pScrn = xf86Screens[scrnIndex];
-    SISPtr        pSiS = SISPTR(pScrn);
-    ULong base;
-    UChar temp, cr11backup;
+    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SISPtr      pSiS = SISPTR(pScrn);
+    UChar       temp, cr11backup;
+    ULong       base;
+
+#ifdef UNLOCK_ALWAYS
+    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
 
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
-	SISAdjustFrameMerged(scrnIndex, x, y, flags);
+	SISMFBAdjustFrame(scrnIndex, x, y, flags);
 	return;
     }
 #endif
@@ -9637,112 +10578,92 @@ SISAdjustFrame(int scrnIndex, int x, int y, int flags)
 	return;
     }
 
-    if(pScrn->bitsPerPixel < 8) {
-       base = (y * pSiS->CurrentLayout.displayWidth + x + 3) >> 3;
-    } else {
-       base  = y * pSiS->CurrentLayout.displayWidth + x;
-
-       /* calculate base bpp dep. */
-       switch(pSiS->CurrentLayout.bitsPerPixel) {
-          case 16:
-     	     base >>= 1;
-             break;
-          case 24:
-             base = ((base * 3)) >> 2;
-             base -= base % 6;
-             break;
-          case 32:
-             break;
-          default:      /* 8bpp */
-             base >>= 2;
-             break;
-       }
-    }
-
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-    base += (pSiS->dhmOffset/4);
-
-#ifdef TWDEBUG
-    xf86DrvMsg(0, 0, "AdjustFrame: x %d y %d bpp %d dw %d base %d, dhmOffset %d\n",
-    			x, y, pSiS->CurrentLayout.bitsPerPixel, pSiS->CurrentLayout.displayWidth, base, pSiS->dhmOffset);
-#endif
-
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        if(!pSiS->SecondHead) {
-	  /* Head 1 (master) is always CRT2 */
-	  SISSetStartAddressCRT2(pSiS, base);
+	  SISAdjustFrameHW_CRT2(pScrn, x, y);
        } else {
-	  /* Head 2 (slave) is always CRT1 */
-	  SISSetStartAddressCRT1(pSiS, base);
+	  SISAdjustFrameHW_CRT1(pScrn, x, y);
        }
-    } else {
+       return;
+    }
 #endif
-       switch(pSiS->VGAEngine) {
-	  case SIS_300_VGA:
-	  case SIS_315_VGA:
-	     SISSetStartAddressCRT1(pSiS, base);
-	     if(pSiS->VBFlags & CRT2_ENABLE) {
-		if(!SiSBridgeIsInSlaveMode(pScrn)) {
-		   SISSetStartAddressCRT2(pSiS, base);
-		}
-	     }
-	     break;
-	  default:
-	     /* Unlock CRTC registers */
-	     inSISIDXREG(SISCR,  0x11, cr11backup);
-	     andSISIDXREG(SISCR, 0x11, 0x7F);
-	     outSISIDXREG(SISCR, 0x0D, base & 0xFF);
-	     outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
-	     inSISIDXREG(SISSR,  0x27, temp);
-	     temp &= 0xF0;
-	     temp |= (base & 0x0F0000) >> 16;
-	     outSISIDXREG(SISSR, 0x27, temp);
-	     /* Eventually lock CRTC registers */
-	     setSISIDXREG(SISCR, 0x11, 0x7F, (cr11backup & 0x80));
+
+    switch(pSiS->VGAEngine) {
+    case SIS_300_VGA:
+    case SIS_315_VGA:
+       SISAdjustFrameHW_CRT1(pScrn, x, y);
+       if(pSiS->VBFlags & CRT2_ENABLE) {
+	  if(!SiSBridgeIsInSlaveMode(pScrn)) {
+	     SISAdjustFrameHW_CRT2(pScrn, x, y);
+	  }
        }
-#ifdef SISDUALHEAD
+       break;
+    default:
+       if(pScrn->bitsPerPixel < 8) {
+          base = (y * pSiS->CurrentLayout.displayWidth + x + 3) >> 3;
+       } else {
+          base  = y * pSiS->CurrentLayout.displayWidth + x;
+          switch(pSiS->CurrentLayout.bitsPerPixel) {
+	     case 8:	base >>= 2;
+			break;
+	     case 16:	base >>= 1;
+			break;
+	     case 24:	base = ((base * 3)) >> 2;
+			base -= base % 6;
+          }
+       }
+       base += (pSiS->dhmOffset/4);
+       /* Unlock CRTC registers */
+       inSISIDXREG(SISCR,  0x11, cr11backup);
+       andSISIDXREG(SISCR, 0x11, 0x7F);
+       outSISIDXREG(SISCR, 0x0D, base & 0xFF);
+       outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
+       inSISIDXREG(SISSR,  0x27, temp);
+       temp &= 0xF0;
+       temp |= (base & 0x0F0000) >> 16;
+       outSISIDXREG(SISSR, 0x27, temp);
+       /* Eventually lock CRTC registers */
+       setSISIDXREG(SISCR, 0x11, 0x7F, (cr11backup & 0x80));
     }
-#endif
 
 }
 
-/*
- * This is called when VT switching back to the X server.  Its job is
- * to reinitialise the video mode.
- * Mandatory!
- */
+/*********************************************************/
+/*                       EnterVT()                       */
+/*********************************************************/
+
+
 static Bool
 SISEnterVT(int scrnIndex, int flags)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
     SISPtr pSiS = SISPTR(pScrn);
-
     SiS_SiSFB_Lock(pScrn, TRUE);
 
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 
-    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-       outSISIDXREG(SISCR,0x32,pSiS->myCR32);
-       outSISIDXREG(SISCR,0x36,pSiS->myCR36);
-       outSISIDXREG(SISCR,0x37,pSiS->myCR37);
-    }
+    SiSRestoreCR323637(pSiS);
 
     if(!SISModeInit(pScrn, pScrn->currentMode)) {
        SISErrorLog(pScrn, "SiSEnterVT: SISModeInit() failed\n");
        return FALSE;
     }
 
+    /* No need to go through pScrn->AdjustFrame; Xv's
+     * EnterVT handles the overlay(s) anyway.
+     */
     SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
 
+
+/* Mark for 3D full-screen bug */
+/*
 #ifdef XF86DRI
     if(pSiS->directRenderingEnabled) {
        DRIUnlock(screenInfo.screens[scrnIndex]);
     }
 #endif
+*/
 
 #ifdef SISDUALHEAD
     if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
@@ -9754,11 +10675,12 @@ SISEnterVT(int scrnIndex, int flags)
     return TRUE;
 }
 
-/*
- * This is called when VT switching away from the X server.  Its job is
- * to restore the previous (text) mode.
- * Mandatory!
- */
+
+/*********************************************************/
+/*                       LeaveVT()                       */
+/*********************************************************/
+
+
 static void
 SISLeaveVT(int scrnIndex, int flags)
 {
@@ -9769,7 +10691,8 @@ SISLeaveVT(int scrnIndex, int flags)
 
     if(pSiS->directRenderingEnabled) {
        pScreen = screenInfo.screens[scrnIndex];
-       DRILock(pScreen, 0);
+/* Mark for 3D full-screen bug */
+/*   DRILock(pScreen, 0); */
     }
 #endif
 
@@ -9830,11 +10753,11 @@ SISLeaveVT(int scrnIndex, int flags)
 }
 
 
-/*
- * This is called at the end of each server generation.  It restores the
- * original (text) mode.  It should really also unmap the video memory too.
- * Mandatory!
- */
+/*********************************************************/
+/*                      CloseScreen()                    */
+/*********************************************************/
+
+
 static Bool
 SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
 {
@@ -9844,6 +10767,7 @@ SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
     SISEntPtr pSiSEnt = pSiS->entityPrivate;
 #endif
 
+
     if(pSiS->SiSCtrlExtEntry) {
        SiSCtrlExtUnregister(pSiS, pScrn->scrnIndex);
     }
@@ -9954,6 +10878,11 @@ SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
        pSiS->CursorInfoPtr = NULL;
     }
 
+    if(pSiS->CursorScratch) {
+       xfree(pSiS->CursorScratch);
+       pSiS->CursorScratch = NULL;
+    }
+
     if(pSiS->ShadowPtr) {
        xfree(pSiS->ShadowPtr);
        pSiS->ShadowPtr = NULL;
@@ -9987,6 +10916,14 @@ SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
 
     pScrn->vtSema = FALSE;
 
+#ifdef SIS_HAVE_RR_FUNC
+#ifdef SIS_HAVE_DRIVER_FUNC
+    pScrn->DriverFunc = NULL;
+#else
+    pScrn->RRFunc = NULL;
+#endif
+#endif
+
     /* Restore Blockhandler */
     pScreen->BlockHandler = pSiS->BlockHandler;
 
@@ -9996,9 +10933,12 @@ SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
 }
 
 
+/*********************************************************/
+/*                     FreeScreen()                      */
+/*********************************************************/
+
 /* Free up any per-generation data structures */
 
-/* Optional */
 static void
 SISFreeScreen(int scrnIndex, int flags)
 {
@@ -10021,3903 +10961,9 @@ SISFreeScreen(int scrnIndex, int flags)
 }
 
 
-/* Checks if a mode is suitable for the selected chipset. */
-
-static ModeStatus
-SISValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
-{
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    SISPtr pSiS = SISPTR(pScrn);
-
-    if(pSiS->UseVESA) {
-       if(SiSCalcVESAModeIndex(pScrn, mode))
-	  return(MODE_OK);
-       else
-	  return(MODE_BAD);
-    }
-
-    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-#ifdef SISDUALHEAD
-       if(pSiS->DualHeadMode) {
-          if(pSiS->SecondHead) {
-	     if(SiS_CheckModeCRT1(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
-	        return(MODE_BAD);
-	  } else {
-	     if(SiS_CheckModeCRT2(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
-	        return(MODE_BAD);
-	  }
-       } else
-#endif
-#ifdef SISMERGED
-       if(pSiS->MergedFB) {
-	  if(!mode->Private) {
-	     if(!pSiS->CheckForCRT2) {
-	        if(SiS_CheckModeCRT1(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
-	           return(MODE_BAD);
-	     } else {
-	        if(SiS_CheckModeCRT2(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
-	           return(MODE_BAD);
-	     }
-	  } else {
-	     if(SiS_CheckModeCRT1(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
-		                  pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
-	        return(MODE_BAD);
-
-	     if(SiS_CheckModeCRT2(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
-		                  pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
-	        return(MODE_BAD);
- 	  }
-       } else
-#endif
-       {
-	  if(SiS_CheckModeCRT1(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
-	     return(MODE_BAD);
-
-	  if(SiS_CheckModeCRT2(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
-	     return(MODE_BAD);
-       }
-    }
-
-    return(MODE_OK);
-}
-
-#ifdef DEBUG
-static void
-SiSDumpModeInfo(ScrnInfoPtr pScrn, DisplayModePtr mode)
-{
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Clock : %x\n", mode->Clock);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Display : %x\n", mode->CrtcHDisplay);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank Start : %x\n", mode->CrtcHBlankStart);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync Start : %x\n", mode->CrtcHSyncStart);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync End : %x\n", mode->CrtcHSyncEnd);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank End : %x\n", mode->CrtcHBlankEnd);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Total : %x\n", mode->CrtcHTotal);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Skew : %x\n", mode->CrtcHSkew);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz HAdjusted : %x\n", mode->CrtcHAdjusted);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Display : %x\n", mode->CrtcVDisplay);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank Start : %x\n", mode->CrtcVBlankStart);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync Start : %x\n", mode->CrtcVSyncStart);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync End : %x\n", mode->CrtcVSyncEnd);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank End : %x\n", mode->CrtcVBlankEnd);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Total : %x\n", mode->CrtcVTotal);
-    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt VAdjusted : %x\n", mode->CrtcVAdjusted);
-}
-#endif
-
-static void
-SISModifyModeInfo(DisplayModePtr mode)
-{
-    if(mode->CrtcHBlankStart == mode->CrtcHDisplay)
-        mode->CrtcHBlankStart++;
-    if(mode->CrtcHBlankEnd == mode->CrtcHTotal)
-        mode->CrtcHBlankEnd--;
-    if(mode->CrtcVBlankStart == mode->CrtcVDisplay)
-        mode->CrtcVBlankStart++;
-    if(mode->CrtcVBlankEnd == mode->CrtcVTotal)
-        mode->CrtcVBlankEnd--;
-}
-
-/* Enable the Turboqueue/Commandqueue (For 300 and 315/330/340 series only) */
-static void
-SiSEnableTurboQueue(ScrnInfoPtr pScrn)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    UShort SR26, SR27;
-    ULong  temp;
-
-    switch(pSiS->VGAEngine) {
-	case SIS_300_VGA:
-	   if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
-		/* TQ size is always 512k */
-		temp = (pScrn->videoRam/64) - 8;
-		SR26 = temp & 0xFF;
-		inSISIDXREG(SISSR, 0x27, SR27);
-		SR27 &= 0xFC;
-		SR27 |= (0xF0 | ((temp >> 8) & 3));
-		outSISIDXREG(SISSR, 0x26, SR26);
-		outSISIDXREG(SISSR, 0x27, SR27);
-	   }
-	   break;
-
-	case SIS_315_VGA:
-	   if(!pSiS->NoAccel) {
-	      /* On 315/330/340 series, there are three queue modes available
-	       * which are chosen by setting bits 7:5 in SR26:
-	       * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
-	       *    track of the queue, the FIFO, command parsing and so
-	       *    on. This is the one comparable to the 300 series.
-	       * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
-	       *    have to do queue management himself.
-	       * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
-	       *    queue in AGP memory space.
-	       * We go VRAM or MMIO here.
-	       * SR26 bit 4 is called "Bypass H/W queue".
-	       * SR26 bit 1 is called "Enable Command Queue Auto Correction"
-	       * SR26 bit 0 resets the queue
-	       * Size of queue memory is encoded in bits 3:2 like this:
-	       *    00  (0x00)  512K
-	       *    01  (0x04)  1M
-	       *    10  (0x08)  2M
-	       *    11  (0x0C)  4M
-	       * The queue location is to be written to 0x85C0.
-	       */
-#ifdef SISVRAMQ
-	      /* We use VRAM Cmd Queue, not MMIO or AGP */
-	      UChar tempCR55 = 0;
-
-	      /* Set Command Queue Threshold to max value 11111b (?) */
-	      outSISIDXREG(SISSR, 0x27, 0x1F);
-
-	      /* Disable queue flipping */
-	      inSISIDXREG(SISCR, 0x55, tempCR55);
-	      andSISIDXREG(SISCR, 0x55, 0x33);
-	      /* Synchronous reset for Command Queue */
-	      outSISIDXREG(SISSR, 0x26, 0x01);
-	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
-	      /* Enable VRAM Command Queue mode */
-	      if(pSiS->ChipType == XGI_20) {
-		 /* On XGI_20, always 128K */
-		 SR26 = 0x40 | 0x04 | 0x01;
-	      } else {
-	         switch(pSiS->cmdQueueSize) {
-		    case 1*1024*1024: SR26 = (0x40 | 0x04 | 0x01); break;
-		    case 2*1024*1024: SR26 = (0x40 | 0x08 | 0x01); break;
-		    case 4*1024*1024: SR26 = (0x40 | 0x0C | 0x01); break;
-		    default:
-		                      pSiS->cmdQueueSize = 512 * 1024;
-		    case    512*1024: SR26 = (0x40 | 0x00 | 0x01);
-	         }
-	      }
-	      outSISIDXREG(SISSR, 0x26, SR26);
-	      SR26 &= 0xfe;
-	      outSISIDXREG(SISSR, 0x26, SR26);
-	      *(pSiS->cmdQ_SharedWritePort) = (unsigned int)(SIS_MMIO_IN32(pSiS->IOBase, 0x85c8));
-	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85c4, (CARD32)(*(pSiS->cmdQ_SharedWritePort)));
-	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85C0, pSiS->cmdQueueOffset);
-	      temp = (ULong)pSiS->RealFbBase;
-#ifdef SISDUALHEAD
-	      if(pSiS->DualHeadMode) {
-	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
-	         temp = (ULong)pSiSEnt->RealFbBase;
-	      }
-#endif
-	      temp += pSiS->cmdQueueOffset;
-	      pSiS->cmdQueueBase = (unsigned int *)temp;
-	      outSISIDXREG(SISCR, 0x55, tempCR55);
-#ifdef TWDEBUG
-	      xf86DrvMsg(0, 0, "CmdQueueOffs 0x%x, CmdQueueAdd %p, shwrp 0x%x, status %x, base %p\n",
-		pSiS->cmdQueueOffset, pSiS->cmdQueueBase, *(pSiS->cmdQ_SharedWritePort),
-		SIS_MMIO_IN32(pSiS->IOBase, 0x85cc), (ULong *)temp);
-#endif
-#else
-	      /* For MMIO */
-	      /* Syncronous reset for Command Queue */
-	      orSISIDXREG(SISSR, 0x26, 0x01);
-	      /* Set Command Queue Threshold to max value 11111b */
-	      outSISIDXREG(SISSR, 0x27, 0x1F);
-	      /* Do some magic (cp readport to writeport) */
-	      temp = SIS_MMIO_IN32(pSiS->IOBase, 0x85C8);
-	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85C4, temp);
-	      /* Enable MMIO Command Queue mode (0x20),
-	       * Enable_command_queue_auto_correction (0x02)
-	       *        (no idea, but sounds good, so use it)
-	       * 512k (0x00) (does this apply to MMIO mode?) */
-	      outSISIDXREG(SISSR, 0x26, 0x22);
-	      /* Calc Command Queue position (Q is always 512k)*/
-	      temp = (pScrn->videoRam - 512) * 1024;
-	      /* Set Q position */
-	      SIS_MMIO_OUT32(pSiS->IOBase, 0x85C0, temp);
-#endif
-	   }
-	   break;
-	default:
-	   break;
-    }
-}
-
-#ifdef SISVRAMQ
-static void
-SiSRestoreQueueMode(SISPtr pSiS, SISRegPtr sisReg)
-{
-    UChar tempCR55=0;
-
-    if(pSiS->VGAEngine == SIS_315_VGA) {
-       inSISIDXREG(SISCR,0x55,tempCR55);
-       andSISIDXREG(SISCR,0x55,0x33);
-       outSISIDXREG(SISSR,0x26,0x01);
-       SIS_MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
-       outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
-       outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
-       SIS_MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
-       outSISIDXREG(SISCR,0x55,tempCR55);
-    }
-}
-#endif
-
-/* Things to do before a ModeSwitch. We set up the
- * video bridge configuration and the TurboQueue.
- */
-void SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, int viewmode)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    UChar  CR30, CR31, CR32, CR33;
-    UChar  CR39 = 0, CR3B = 0;
-    UChar  CR17, CR38 = 0;
-    UChar  CR35 = 0, CR79 = 0;
-    int    temp = 0, crt1rateindex = 0;
-    ULong  vbflag = pSiS->VBFlags;
-    Bool   hcm = pSiS->HaveCustomModes;
-    DisplayModePtr mymode = mode;
-
-    pSiS->IsCustom = FALSE;
-
-    /* NEVER call this with viewmode = SIS_MODE_SIMU
-     * if mode->type is not M_T_DEFAULT!
-     */
-
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       switch(viewmode) {
-       case SIS_MODE_CRT1:
-	  mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
-	  break;
-       case SIS_MODE_CRT2:
-	  mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
-	  hcm = pSiS->HaveCustomModes2;
-       }
-    }
-#endif
-
-    switch(viewmode) {
-    case SIS_MODE_CRT1:
-       if(SiS_CheckModeCRT1(pScrn, mymode, vbflag, hcm) == 0xfe) {
-          pSiS->IsCustom = TRUE;
-       }
-       break;
-    case SIS_MODE_CRT2:
-       if(vbflag & CRT2_ENABLE) {
-          if(SiS_CheckModeCRT2(pScrn, mymode, vbflag, hcm) == 0xfe) {
-	     pSiS->IsCustom = TRUE;
-          }
-       } else {
-          /* This can only happen in mirror mode */
-          if(SiS_CheckModeCRT1(pScrn, mymode, vbflag, hcm) == 0xfe) {
-             pSiS->IsCustom = TRUE;
-          }
-       }
-    }
-
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);    /* Unlock Registers */
-#endif
-
-    inSISIDXREG(SISCR, 0x30, CR30);
-    inSISIDXREG(SISCR, 0x31, CR31);
-    CR32 = pSiS->newCR32;
-    inSISIDXREG(SISCR, 0x33, CR33);
-
-    if(pSiS->NewCRLayout) {
-
-       inSISIDXREG(SISCR, 0x35, CR35);
-       inSISIDXREG(SISCR, 0x38, CR38);
-       inSISIDXREG(SISCR, 0x39, CR39);
-
-       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, SISVERBLEVEL,
-	   "Before: CR30=0x%02x,CR31=0x%02x,CR32=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=0x%02x\n",
-              CR30, CR31, CR32, CR33, CR35, CR38);
-
-       CR38 &= ~0x07;
-
-    } else {
-
-       if(pSiS->Chipset != PCI_CHIP_SIS300) {
-          switch(pSiS->VGAEngine) {
-             case SIS_300_VGA: temp = 0x35; break;
-             case SIS_315_VGA: temp = 0x38; break;
-          }
-          if(temp) inSISIDXREG(SISCR, temp, CR38);
-       }
-       if(pSiS->VGAEngine == SIS_315_VGA) {
-          inSISIDXREG(SISCR, 0x79, CR79);
-          CR38 &= ~0x3b;   			/* Clear LCDA/DualEdge and YPbPr bits */
-       }
-       inSISIDXREG(SISCR, 0x3b, CR3B);
-
-       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, SISVERBLEVEL,
-	   "Before: CR30=0x%02x, CR31=0x%02x, CR32=0x%02x, CR33=0x%02x, CR%02x=0x%02x\n",
-              CR30, CR31, CR32, CR33, temp, CR38);
-    }
-
-    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, SISVERBLEVEL, "VBFlags=0x%x\n", pSiS->VBFlags);
-
-    CR30 = 0x00;
-    CR31 &= ~0x60;  /* Clear VB_Drivermode & VB_OutputDisable */
-    CR31 |= 0x04;   /* Set VB_NotSimuMode (not for 30xB/1400x1050?) */
-    CR35 = 0x00;
-
-    if(!pSiS->NewCRLayout) {
-       if(!pSiS->AllowHotkey) {
-          CR31 |= 0x80;   /* Disable hotkey-switch */
-       }
-       CR79 &= ~0x10;     /* Enable Backlight control on 315 series */
-    }
-
-    SiS_SetEnableDstn(pSiS->SiS_Pr, FALSE);
-    SiS_SetEnableFstn(pSiS->SiS_Pr, FALSE);
-
-    if((vbflag & CRT1_LCDA) && (viewmode == SIS_MODE_CRT1)) {
-
-       CR38 |= 0x02;
-
-    } else {
-
-       switch(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
-
-       case CRT2_TV:
-
-          CR38 &= ~0xC0; 	/* Clear Pal M/N bits */
-
-          if((pSiS->VBFlags2 & VB2_CHRONTEL) && (vbflag & TV_CHSCART)) {		/* Chrontel */
-	     CR30 |= 0x10;
-	     CR38 |= 0x04;
-	     CR38 &= ~0x08;
-	     CR31 |= 0x01;
-	  } else if((pSiS->VBFlags2 & VB2_CHRONTEL) && (vbflag & TV_CHYPBPR525I)) {	/* Chrontel */
-	     CR38 |= 0x08;
-	     CR38 &= ~0x04;
-	     CR31 &= ~0x01;
-          } else if(vbflag & TV_HIVISION) {	/* SiS bridge */
-	     if(pSiS->NewCRLayout) {
-	        CR38 |= 0x04;
-	        CR35 |= 0x60;
-	     } else {
-	        CR30 |= 0x80;
-		if(pSiS->VGAEngine == SIS_315_VGA) {
-		   if(pSiS->VBFlags2 & VB2_SISYPBPRBRIDGE) {
-		      CR38 |= (0x08 | 0x30);
-		   }
-		}
-	     }
-	     CR31 |= 0x01;
-	     CR35 |= 0x01;
-	  } else if(vbflag & TV_YPBPR) {					/* SiS bridge */
-	     if(pSiS->NewCRLayout) {
-		CR38 |= 0x04;
-		CR31 &= ~0x01;
-		CR35 &= ~0x01;
-		if(vbflag & (TV_YPBPR525P | TV_YPBPR625P)) CR35 |= 0x20;
-		else if(vbflag & TV_YPBPR750P)             CR35 |= 0x40;
-		else if(vbflag & TV_YPBPR1080I)            CR35 |= 0x60;
-
-		if(vbflag & (TV_YPBPR625I | TV_YPBPR625P)) {
-		   CR31 |= 0x01;
-		   CR35 |= 0x01;
-		}
-
-		CR39 &= ~0x03;
-		if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR39 |= 0x00;
-		else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR39 |= 0x01;
-		else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR39 |= 0x02;
-		else					      CR39 |= 0x03;
-	     } else if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR) {
-		CR30 |= 0x80;
-		CR38 |= 0x08;
-		CR31 &= ~0x01;
-		if(vbflag & (TV_YPBPR525P|TV_YPBPR625P)) CR38 |= 0x10;
-		else if(vbflag & TV_YPBPR750P)  	 CR38 |= 0x20;
-		else if(vbflag & TV_YPBPR1080I)		 CR38 |= 0x30;
-
-		if(vbflag & (TV_YPBPR625I | TV_YPBPR625P)) CR31 |= 0x01;
-
-		if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPRAR) {
-		   CR3B &= ~0x03;
-		   if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR3B |= 0x00;
-		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR3B |= 0x03;
-		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR3B |= 0x01;
-		   else					         CR3B |= 0x03;
-		}
-	     }
-          } else {								/* All */
-	     if(vbflag & TV_SCART)  CR30 |= 0x10;
-	     if(vbflag & TV_SVIDEO) CR30 |= 0x08;
-	     if(vbflag & TV_AVIDEO) CR30 |= 0x04;
-	     if(!(CR30 & 0x1C))	    CR30 |= 0x08;    /* default: SVIDEO */
-
-	     if(vbflag & TV_PAL) {
-		CR31 |= 0x01;
-		CR35 |= 0x01;
-		if( (pSiS->VBFlags2 & VB2_SISBRIDGE) ||
-		    ((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x)) )  {
-		   if(vbflag & TV_PALM) {
-		      CR38 |= 0x40;
-		      CR35 |= 0x04;
-		   } else if(vbflag & TV_PALN) {
-		      CR38 |= 0x80;
-		      CR35 |= 0x08;
-		   }
-	        }
-	     } else {
-		CR31 &= ~0x01;
-		CR35 &= ~0x01;
-		if(vbflag & TV_NTSCJ) {
-		   CR38 |= 0x40;  /* TW, not BIOS */
-		   CR35 |= 0x02;
-		}
-	     }
-	     if(vbflag & TV_SCART) {
-		CR31 |= 0x01;
-		CR35 |= 0x01;
-	     }
-	  }
-
-	  CR31 &= ~0x04;   /* Clear NotSimuMode */
-	  pSiS->SiS_Pr->SiS_CHOverScan = pSiS->UseCHOverScan;
-	  if((pSiS->OptTVSOver == 1) && (pSiS->ChrontelType == CHRONTEL_700x)) {
-	     pSiS->SiS_Pr->SiS_CHSOverScan = TRUE;
-	  } else {
-	     pSiS->SiS_Pr->SiS_CHSOverScan = FALSE;
-	  }
-#ifdef SIS_CP
-	  SIS_CP_DRIVER_CONFIG
-#endif
-	  break;
-
-       case CRT2_LCD:
-	  CR30 |= 0x20;
-	  SiS_SetEnableDstn(pSiS->SiS_Pr, pSiS->DSTN);
-	  SiS_SetEnableFstn(pSiS->SiS_Pr, pSiS->FSTN);
-	  break;
-
-       case CRT2_VGA:
-	  CR30 |= 0x40;
-	  break;
-
-       default:
-	  CR30 |= 0x00;
-	  CR31 |= 0x20;    /* VB_OUTPUT_DISABLE */
-	  if(pSiS->UseVESA) {
-	     crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
-	  }
-       }
-
-    }
-
-    if(vbflag & CRT1_LCDA) {
-       switch(viewmode) {
-       case SIS_MODE_CRT1:
-	  CR38 |= 0x01;
-	  break;
-       case SIS_MODE_CRT2:
-	  if(vbflag & (CRT2_TV|CRT2_VGA)) {
-	     CR30 |= 0x02;
-	     CR38 |= 0x01;
-	  } else {
-	     CR38 |= 0x03;
-	  }
-	  break;
-       case SIS_MODE_SIMU:
-       default:
-	  if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
-	     CR30 |= 0x01;
-	  }
-	  break;
-       }
-    } else {
-       if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
-          CR30 |= 0x01;
-       }
-    }
-
-    if(pSiS->UseVESA) {
-       CR31 &= ~0x40;   /* Clear Drivermode */
-       CR31 |= 0x06;    /* Set SlaveMode, Enable SimuMode in Slavemode */
-#ifdef TWDEBUG
-       CR31 |= 0x40;    /* DEBUG (for non-slave mode VESA) */
-       crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
-#endif
-    } else {
-       CR31 |=  0x40;  /* Set Drivermode */
-       CR31 &=  ~0x06; /* Disable SlaveMode, disable SimuMode in SlaveMode */
-       if(!pSiS->IsCustom) {
-          crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
-       }
-    }
-
-    switch(viewmode) {
-	case SIS_MODE_SIMU:
-	   CR33 = 0;
-	   if(!(vbflag & CRT1_LCDA)) {
-	      CR33 |= (crt1rateindex & 0x0f);
-	   }
-	   if(vbflag & CRT2_VGA) {
-	      CR33 |= ((crt1rateindex & 0x0f) << 4);
-	   }
-	   break;
-	case SIS_MODE_CRT1:
-	   CR33 &= 0xf0;
-	   if(!(vbflag & CRT1_LCDA)) {
-	      CR33 |= (crt1rateindex & 0x0f);
-	   }
-	   break;
-	case SIS_MODE_CRT2:
-	   CR33 &= 0x0f;
-	   if(vbflag & CRT2_VGA) {
-	      CR33 |= ((crt1rateindex & 0x0f) << 4);
-	   }
-	   break;
-     }
-
-     if((!pSiS->UseVESA) && (vbflag & CRT2_ENABLE)) {
-	if(pSiS->CRT1off) CR33 &= 0xf0;
-     }
-
-     if(pSiS->NewCRLayout) {
-
-	CR31 &= 0xfe;   /* Clear PAL flag (now in CR35) */
-	CR38 &= 0x07;   /* Use only LCDA and HiVision/YPbPr bits */
-	outSISIDXREG(SISCR, 0x30, CR30);
-	outSISIDXREG(SISCR, 0x31, CR31);
-	outSISIDXREG(SISCR, 0x33, CR33);
-	outSISIDXREG(SISCR, 0x35, CR35);
-	setSISIDXREG(SISCR, 0x38, 0xf8, CR38);
-	outSISIDXREG(SISCR, 0x39, CR39);
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, SISVERBLEVEL,
-		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=%02x\n",
-		    CR30, CR31, CR33, CR35, CR38);
-
-     } else {
-
-	outSISIDXREG(SISCR, 0x30, CR30);
-	outSISIDXREG(SISCR, 0x31, CR31);
-	outSISIDXREG(SISCR, 0x33, CR33);
-	if(temp) {
-	   outSISIDXREG(SISCR, temp, CR38);
-	}
-	if(pSiS->VGAEngine == SIS_315_VGA) {
-	   outSISIDXREG(SISCR, 0x3b, CR3B);
-	   outSISIDXREG(SISCR, 0x79, CR79);
-	}
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, SISVERBLEVEL,
-		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR%02x=%02x\n",
-		    CR30, CR31, CR33, temp, CR38);
-     }
-
-     pSiS->SiS_Pr->SiS_UseOEM = pSiS->OptUseOEM;
-
-     /* Enable TurboQueue */
-#ifdef SISVRAMQ
-     if(pSiS->VGAEngine != SIS_315_VGA)
-#endif
-	SiSEnableTurboQueue(pScrn);
-
-     if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
-	/* Switch on CRT1 for modes that require the bridge in SlaveMode */
-	andSISIDXREG(SISSR,0x1f,0x3f);
-	inSISIDXREG(SISCR, 0x17, CR17);
-	if(!(CR17 & 0x80)) {
-	   orSISIDXREG(SISCR, 0x17, 0x80);
-	   outSISIDXREG(SISSR, 0x00, 0x01);
-	   usleep(10000);
-	   outSISIDXREG(SISSR, 0x00, 0x03);
-	}
-     }
-}
-
-/* Functions for adjusting various TV settings */
-
-/* These are used by the PostSetMode() functions as well as
- * the display properties tool SiSCtrl.
- *
- * There is each a Set and a Get routine. The Set functions
- * take a value of the same range as the corresponding option.
- * The Get routines return a value of the same range (although
- * not necessarily the same value as previously set because
- * of the lower resolution of the respective setting compared
- * to the valid range).
- * The Get routines return -2 on error (eg. hardware does not
- * support this setting).
- * Note: The x and y positioning routines accept a position
- * RELATIVE to the default position. All other routines
- * take ABSOLUTE values.
- *
- * The Set functions will store the property regardless if TV is
- * currently used or not and if the hardware supports the property
- * or not. The Get routines will return this stored
- * value if TV is not currently used (because the register does
- * not contain the correct value then) or if the hardware supports
- * the respective property. This should make it easier for the
- * display property tool because it does not have to know the
- * hardware features.
- *
- * All the routines are dual head aware. It does not matter
- * if the function is called from the CRT1 or CRT2 session.
- * The values will be in pSiSEnt anyway, and read from there
- * if we're running dual head.
- */
-
-void SiS_SetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvlumabandwidthcvbs = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvlumabandwidthcvbs = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           val /= 8;
-           if((val == 0) || (val == 1)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, val, 0xFE);
-           }
-	   break;
-       case CHRONTEL_701x:
-           val /= 4;
-	   if((val >= 0) && (val <= 3)) {
-	       SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, val, 0xFC);
-	   }
-           break;
-   }
-}
-
-int SiS_GetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvlumabandwidthcvbs;
-      else
-#endif
-           return (int)pSiS->chtvlumabandwidthcvbs;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x01) * 8);
-      case CHRONTEL_701x:
-	   return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x03) * 4);
-      default:
-           return (int)pSiS->chtvlumabandwidthcvbs;
-      }
-   }
-}
-
-void SiS_SetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvlumabandwidthsvideo = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvlumabandwidthsvideo = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           val /= 6;
-           if((val >= 0) && (val <= 2)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, (val << 1), 0xF9);
-           }
-	   break;
-       case CHRONTEL_701x:
-           val /= 4;
-	   if((val >= 0) && (val <= 3)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, (val << 2), 0xF3);
-	   }
-           break;
-   }
-}
-
-int SiS_GetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvlumabandwidthsvideo;
-      else
-#endif
-           return (int)pSiS->chtvlumabandwidthsvideo;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x06) >> 1) * 6);
-      case CHRONTEL_701x:
-	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x0c) >> 2) * 4);
-      default:
-           return (int)pSiS->chtvlumabandwidthsvideo;
-      }
-   }
-}
-
-void SiS_SetCHTVlumaflickerfilter(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvlumaflickerfilter = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvlumaflickerfilter = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           val /= 6;
-           if((val >= 0) && (val <= 2)) {
-	      UShort reg = 0;
-	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
-	      reg = (reg & 0xf0) | ((reg & 0x0c) >> 2) | (val << 2);
-              SiS_SetCH70xx(pSiS->SiS_Pr, 0x01, reg);
-           }
-	   break;
-       case CHRONTEL_701x:
-           val /= 4;
-	   if((val >= 0) && (val <= 3)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x01, (val << 2), 0xF3);
-	   }
-           break;
-   }
-}
-
-int SiS_GetCHTVlumaflickerfilter(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-          return (int)pSiSEnt->chtvlumaflickerfilter;
-      else
-#endif
-          return (int)pSiS->chtvlumaflickerfilter;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x03) * 6);
-      case CHRONTEL_701x:
-	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 4);
-      default:
-           return (int)pSiS->chtvlumaflickerfilter;
-      }
-   }
-}
-
-void SiS_SetCHTVchromabandwidth(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvchromabandwidth = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvchromabandwidth = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           val /= 4;
-           if((val >= 0) && (val <= 3)) {
-              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, (val << 4), 0xCF);
-           }
-	   break;
-       case CHRONTEL_701x:
-           val /= 8;
-	   if((val >= 0) && (val <= 1)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, (val << 4), 0xEF);
-	   }
-           break;
-   }
-}
-
-int SiS_GetCHTVchromabandwidth(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvchromabandwidth;
-      else
-#endif
-           return (int)pSiS->chtvchromabandwidth;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x30) >> 4) * 4);
-      case CHRONTEL_701x:
-	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x10) >> 4) * 8);
-      default:
-           return (int)pSiS->chtvchromabandwidth;
-      }
-   }
-}
-
-void SiS_SetCHTVchromaflickerfilter(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvchromaflickerfilter = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvchromaflickerfilter = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           val /= 6;
-           if((val >= 0) && (val <= 2)) {
-	      UShort reg = 0;
-	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
-	      reg = (reg & 0xc0) | ((reg & 0x0c) >> 2) | ((reg & 0x03) << 2) | (val << 4);
-              SiS_SetCH70xx(pSiS->SiS_Pr, 0x01, reg);
-           }
-	   break;
-       case CHRONTEL_701x:
-           val /= 4;
-	   if((val >= 0) && (val <= 3)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x01, (val << 4), 0xCF);
-	   }
-           break;
-   }
-}
-
-int SiS_GetCHTVchromaflickerfilter(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvchromaflickerfilter;
-      else
-#endif
-           return (int)pSiS->chtvchromaflickerfilter;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 6);
-      case CHRONTEL_701x:
-	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 4);
-      default:
-           return (int)pSiS->chtvchromaflickerfilter;
-      }
-   }
-}
-
-void SiS_SetCHTVcvbscolor(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvcvbscolor = val ? 1 : 0;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, 0x40, 0x00);
-           else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, 0x00, ~0x40);
-	   break;
-       case CHRONTEL_701x:
-           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, 0x00, ~0x20);
-	   else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, 0x20, 0x00);
-           break;
-   }
-}
-
-int SiS_GetCHTVcvbscolor(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvcvbscolor;
-      else
-#endif
-           return (int)pSiS->chtvcvbscolor;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x40) >> 6) ^ 0x01);
-      case CHRONTEL_701x:
-	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x20) >> 5) ^ 0x01);
-      default:
-           return (int)pSiS->chtvcvbscolor;
-      }
-   }
-}
-
-void SiS_SetCHTVtextenhance(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvtextenhance = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvtextenhance = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-           val /= 6;
-           if((val >= 0) && (val <= 2)) {
-	      UShort reg = 0;
-	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
-	      reg = (reg & 0xf0) | ((reg & 0x03) << 2) | val;
-              SiS_SetCH70xx(pSiS->SiS_Pr, 0x01, reg);
-           }
-	   break;
-       case CHRONTEL_701x:
-           val /= 2;
-	   if((val >= 0) && (val <= 7)) {
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, val, 0xF8);
-	   }
-           break;
-   }
-}
-
-int SiS_GetCHTVtextenhance(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvtextenhance;
-      else
-#endif
-           return (int)pSiS->chtvtextenhance;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 6);
-      case CHRONTEL_701x:
-	   return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x07) * 2);
-      default:
-           return (int)pSiS->chtvtextenhance;
-      }
-   }
-}
-
-void SiS_SetCHTVcontrast(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->chtvcontrast = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->chtvcontrast = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   val /= 2;
-   if((val >= 0) && (val <= 7)) {
-       switch(pSiS->ChrontelType) {
-       case CHRONTEL_700x:
-              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x11, val, 0xF8);
-	      break;
-       case CHRONTEL_701x:
-	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x08, val, 0xF8);
-              break;
-       }
-       SiS_DDC2Delay(pSiS->SiS_Pr, 1000);
-   }
-}
-
-int SiS_GetCHTVcontrast(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
-#ifdef SISDUALHEAD
-      if(pSiSEnt && pSiS->DualHeadMode)
-           return (int)pSiSEnt->chtvcontrast;
-      else
-#endif
-           return (int)pSiS->chtvcontrast;
-   } else {
-#ifdef UNLOCK_ALWAYS
-      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-      switch(pSiS->ChrontelType) {
-      case CHRONTEL_700x:
-           return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x11) & 0x07) * 2);
-      case CHRONTEL_701x:
-	   return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x08) & 0x07) * 2);
-      default:
-           return (int)pSiS->chtvcontrast;
-      }
-   }
-}
-
-void SiS_SetSISTVedgeenhance(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->sistvedgeenhance = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->sistvedgeenhance = val;
-#endif
-
-   if(!(pSiS->VBFlags2 & VB2_301))  return;
-   if(!(pSiS->VBFlags & CRT2_TV))   return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   val /= 2;
-   if((val >= 0) && (val <= 7)) {
-      setSISIDXREG(SISPART2,0x3A, 0x1F, (val << 5));
-   }
-}
-
-int SiS_GetSISTVedgeenhance(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int result = pSiS->sistvedgeenhance;
-   UChar temp;
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvedgeenhance;
-#endif
-
-   if(!(pSiS->VBFlags2 & VB2_301))  return result;
-   if(!(pSiS->VBFlags & CRT2_TV))   return result;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-   inSISIDXREG(SISPART2, 0x3a, temp);
-   return(int)(((temp & 0xe0) >> 5) * 2);
-}
-
-void SiS_SetSISTVantiflicker(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->sistvantiflicker = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->sistvantiflicker = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV))      return;
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return;
-   if(pSiS->VBFlags & TV_HIVISION)     return;
-   if((pSiS->VBFlags & TV_YPBPR) &&
-      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR625P | TV_YPBPR750P | TV_YPBPR1080I))) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
-   if((val >= 0) && (val <= 4)) {
-      setSISIDXREG(SISPART2,0x0A,0x8F, (val << 4));
-   }
-}
-
-int SiS_GetSISTVantiflicker(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int result = pSiS->sistvantiflicker;
-   UChar temp;
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvantiflicker;
-#endif
-
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return result;
-   if(!(pSiS->VBFlags & CRT2_TV))        return result;
-   if(pSiS->VBFlags & TV_HIVISION)       return result;
-   if((pSiS->VBFlags & TV_YPBPR) &&
-      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR625P | TV_YPBPR750P | TV_YPBPR1080I))) return result;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-   inSISIDXREG(SISPART2, 0x0a, temp);
-   return(int)((temp & 0x70) >> 4);
-}
-
-void SiS_SetSISTVsaturation(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->sistvsaturation = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->sistvsaturation = val;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV)) return;
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return;
-   if(pSiS->VBFlags2 & VB2_301) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   val /= 2;
-   if((val >= 0) && (val <= 7)) {
-      setSISIDXREG(SISPART4,0x21,0xF8, val);
-   }
-}
-
-int SiS_GetSISTVsaturation(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int result = pSiS->sistvsaturation;
-   UChar temp;
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->sistvsaturation;
-#endif
-
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return result;
-   if(pSiS->VBFlags2 & VB2_301)          return result;
-   if(!(pSiS->VBFlags & CRT2_TV))        return result;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-   inSISIDXREG(SISPART4, 0x21, temp);
-   return(int)((temp & 0x07) * 2);
-}
-
-void SiS_SetSISTVcolcalib(ScrnInfoPtr pScrn, int val, Bool coarse)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-   int ccoarse, cfine, cbase = pSiS->sistvccbase;
-   /* UChar temp; */
-
-#ifdef SISDUALHEAD
-   if(pSiSEnt && pSiS->DualHeadMode) cbase = pSiSEnt->sistvccbase;
-#endif
-
-   if(coarse) {
-      pSiS->sistvcolcalibc = ccoarse = val;
-      cfine = pSiS->sistvcolcalibf;
-#ifdef SISDUALHEAD
-      if(pSiSEnt) {
-         pSiSEnt->sistvcolcalibc = val;
-	 if(pSiS->DualHeadMode) cfine = pSiSEnt->sistvcolcalibf;
-      }
-#endif
-   } else {
-      pSiS->sistvcolcalibf = cfine = val;
-      ccoarse = pSiS->sistvcolcalibc;
-#ifdef SISDUALHEAD
-      if(pSiSEnt) {
-         pSiSEnt->sistvcolcalibf = val;
-         if(pSiS->DualHeadMode) ccoarse = pSiSEnt->sistvcolcalibc;
-      }
-#endif
-   }
-
-   if(!(pSiS->VBFlags & CRT2_TV))               return;
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return;
-   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   if((cfine >= -128) && (cfine <= 127) && (ccoarse >= -120) && (ccoarse <= 120)) {
-      long finalcc = cbase + (((ccoarse * 256) + cfine) * 256);
-
-#if 0
-      inSISIDXREG(SISPART4,0x1f,temp);
-      if(!(temp & 0x01)) {
-         if(pSiS->VBFlags & TV_NTSC) finalcc += 0x21ed8620;
-	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
-	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
-	 else finalcc += 0x2a05d300;
-      }
-#endif
-      setSISIDXREG(SISPART2,0x31,0x80,((finalcc >> 24) & 0x7f));
-      outSISIDXREG(SISPART2,0x32,((finalcc >> 16) & 0xff));
-      outSISIDXREG(SISPART2,0x33,((finalcc >> 8) & 0xff));
-      outSISIDXREG(SISPART2,0x34,(finalcc & 0xff));
-   }
-}
-
-int SiS_GetSISTVcolcalib(ScrnInfoPtr pScrn, Bool coarse)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)
-      if(coarse)  return (int)pSiSEnt->sistvcolcalibc;
-      else        return (int)pSiSEnt->sistvcolcalibf;
-   else
-#endif
-   if(coarse)     return (int)pSiS->sistvcolcalibc;
-   else           return (int)pSiS->sistvcolcalibf;
-}
-
-void SiS_SetSISTVcfilter(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->sistvcfilter = val ? 1 : 0;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV))               return;
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return;
-   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   setSISIDXREG(SISPART2,0x30,~0x10,((pSiS->sistvcfilter << 4) & 0x10));
-}
-
-int SiS_GetSISTVcfilter(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int result = pSiS->sistvcfilter;
-   UChar temp;
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvcfilter;
-#endif
-
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return result;
-   if(!(pSiS->VBFlags & CRT2_TV))               return result;
-   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return result;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-   inSISIDXREG(SISPART2, 0x30, temp);
-   return (int)((temp & 0x10) ? 1 : 0);
-}
-
-void SiS_SetSISTVyfilter(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-   UChar p35,p36,p37,p38,p48,p49,p4a,p30;
-   int i,j;
-
-   pSiS->sistvyfilter = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
-#endif
-
-   if(!(pSiS->VBFlags & CRT2_TV))               return;
-   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return;
-   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
-
-   p35 = pSiS->p2_35; p36 = pSiS->p2_36;
-   p37 = pSiS->p2_37; p38 = pSiS->p2_38;
-   p48 = pSiS->p2_48; p49 = pSiS->p2_49;
-   p4a = pSiS->p2_4a; p30 = pSiS->p2_30;
-#ifdef SISDUALHEAD
-   if(pSiSEnt && pSiS->DualHeadMode) {
-      p35 = pSiSEnt->p2_35; p36 = pSiSEnt->p2_36;
-      p37 = pSiSEnt->p2_37; p38 = pSiSEnt->p2_38;
-      p48 = pSiSEnt->p2_48; p49 = pSiSEnt->p2_49;
-      p4a = pSiSEnt->p2_4a; p30 = pSiSEnt->p2_30;
-   }
-#endif
-   p30 &= 0x20;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   switch(pSiS->sistvyfilter) {
-   case 0:
-      andSISIDXREG(SISPART2,0x30,0xdf);
-      break;
-   case 1:
-      outSISIDXREG(SISPART2,0x35,p35);
-      outSISIDXREG(SISPART2,0x36,p36);
-      outSISIDXREG(SISPART2,0x37,p37);
-      outSISIDXREG(SISPART2,0x38,p38);
-      if(!(pSiS->VBFlags2 & VB2_301)) {
-         outSISIDXREG(SISPART2,0x48,p48);
-         outSISIDXREG(SISPART2,0x49,p49);
-         outSISIDXREG(SISPART2,0x4a,p4a);
-      }
-      setSISIDXREG(SISPART2,0x30,0xdf,p30);
-      break;
-   case 2:
-   case 3:
-   case 4:
-   case 5:
-   case 6:
-   case 7:
-   case 8:
-      if(!(pSiS->VBFlags & (TV_PALM | TV_PALN | TV_NTSCJ))) {
-         int yindex301 = -1, yindex301B = -1;
-	 UChar p3d4_34;
-
-	 inSISIDXREG(SISCR,0x34,p3d4_34);
-
-	 switch((p3d4_34 & 0x7f)) {
-	 case 0x59:  /* 320x200 */
-	 case 0x41:
-	 case 0x4f:
-	 case 0x50:  /* 320x240 */
-	 case 0x56:
-	 case 0x53:
-	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
-	    break;
-	 case 0x2f:  /* 640x400 */
-	 case 0x5d:
-	 case 0x5e:
-	 case 0x2e:  /* 640x480 */
-	 case 0x44:
-	 case 0x62:
-	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
-	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
-	    break;
-	 case 0x31:   /* 720x480 */
-	 case 0x33:
-	 case 0x35:
-	 case 0x32:   /* 720x576 */
-	 case 0x34:
-	 case 0x36:
-	 case 0x5f:   /* 768x576 */
-	 case 0x60:
-	 case 0x61:
-	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
-	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
-	    break;
-	 case 0x51:   /* 400x300 */
-	 case 0x57:
-	 case 0x54:
-	 case 0x30:   /* 800x600 */
-	 case 0x47:
-	 case 0x63:
-	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
-	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
-	    break;
-	 case 0x52:   /* 512x384 */
-	 case 0x58:
-	 case 0x5c:
-	 case 0x38:   /* 1024x768 */
-	 case 0x4a:
-	 case 0x64:
-	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
-	    break;
-	 }
-         if(pSiS->VBFlags2 & VB2_301) {
-            if(yindex301 >= 0) {
-	       for(i=0, j=0x35; i<=3; i++, j++) {
-	          outSISIDXREG(SISPART2,j,(SiSTVFilter301[yindex301].filter[pSiS->sistvyfilter-2][i]));
-	       }
-	    }
-         } else {
-            if(yindex301B >= 0) {
-	       for(i=0, j=0x35; i<=3; i++, j++) {
-	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
-	       }
-	       for(i=4, j=0x48; i<=6; i++, j++) {
-	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
-	       }
-	    }
-         }
-         orSISIDXREG(SISPART2,0x30,0x20);
-      }
-   }
-}
-
-int SiS_GetSISTVyfilter(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)
-      return (int)pSiSEnt->sistvyfilter;
-   else
-#endif
-      return (int)pSiS->sistvyfilter;
-}
-
-void SiS_SetSIS6326TVantiflicker(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UChar tmp;
-
-   pSiS->sistvantiflicker = val;
-
-   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   tmp = SiS6326GetTVReg(pScrn,0x00);
-   if(!(tmp & 0x04)) return;
-
-   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
-   if(val >= 0 && val <= 4) {
-      tmp &= 0x1f;
-      tmp |= (val << 5);
-      SiS6326SetTVReg(pScrn,0x00,tmp);
-   }
-}
-
-int SiS_GetSIS6326TVantiflicker(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UChar tmp;
-
-   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
-      return (int)pSiS->sistvantiflicker;
-   }
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   tmp = SiS6326GetTVReg(pScrn,0x00);
-   if(!(tmp & 0x04)) {
-      return (int)pSiS->sistvantiflicker;
-   } else {
-      return (int)((tmp >> 5) & 0x07);
-   }
-}
-
-void SiS_SetSIS6326TVenableyfilter(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UChar tmp;
-
-   if(val) val = 1;
-   pSiS->sis6326enableyfilter = val;
-
-   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   tmp = SiS6326GetTVReg(pScrn,0x00);
-   if(!(tmp & 0x04)) return;
-
-   tmp = SiS6326GetTVReg(pScrn,0x43);
-   tmp &= ~0x10;
-   tmp |= ((val & 0x01) << 4);
-   SiS6326SetTVReg(pScrn,0x43,tmp);
-}
-
-int SiS_GetSIS6326TVenableyfilter(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UChar tmp;
-
-   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
-      return (int)pSiS->sis6326enableyfilter;
-   }
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   tmp = SiS6326GetTVReg(pScrn,0x00);
-   if(!(tmp & 0x04)) {
-      return (int)pSiS->sis6326enableyfilter;
-   } else {
-      tmp = SiS6326GetTVReg(pScrn,0x43);
-      return (int)((tmp >> 4) & 0x01);
-   }
-}
-
-void SiS_SetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UChar tmp;
-
-   if(val) val = 1;
-   pSiS->sis6326yfilterstrong = val;
-
-   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   tmp = SiS6326GetTVReg(pScrn,0x00);
-   if(!(tmp & 0x04)) return;
-
-   tmp = SiS6326GetTVReg(pScrn,0x43);
-   if(tmp & 0x10) {
-      tmp &= ~0x40;
-      tmp |= ((val & 0x01) << 6);
-      SiS6326SetTVReg(pScrn,0x43,tmp);
-   }
-}
-
-int SiS_GetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UChar tmp;
-
-   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
-      return (int)pSiS->sis6326yfilterstrong;
-   }
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   tmp = SiS6326GetTVReg(pScrn,0x00);
-   if(!(tmp & 0x04)) {
-      return (int)pSiS->sis6326yfilterstrong;
-   } else {
-      tmp = SiS6326GetTVReg(pScrn,0x43);
-      if(!(tmp & 0x10)) {
-         return (int)pSiS->sis6326yfilterstrong;
-      } else {
-         return (int)((tmp >> 6) & 0x01);
-      }
-   }
-}
-
-void SiS_SetTVxposoffset(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   pSiS->tvxpos = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->tvxpos = val;
-#endif
-
-   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-
-      if(pSiS->VBFlags & CRT2_TV) {
-
-         if(pSiS->VBFlags2 & VB2_CHRONTEL) {
-
-	    int x = pSiS->tvx;
-#ifdef SISDUALHEAD
-	    if(pSiSEnt && pSiS->DualHeadMode) x = pSiSEnt->tvx;
-#endif
-	    switch(pSiS->ChrontelType) {
-	    case CHRONTEL_700x:
-	       if((val >= -32) && (val <= 32)) {
-		   x += val;
-		   if(x < 0) x = 0;
-		   SiS_SetCH700x(pSiS->SiS_Pr, 0x0a, (x & 0xff));
-		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x08, ((x & 0x0100) >> 7), 0xFD);
-	       }
-	       break;
-	    case CHRONTEL_701x:
-	       /* Not supported by hardware */
-	       break;
-	    }
-
-	 } else if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
-
-	    if((val >= -32) && (val <= 32)) {
-
-	        UChar p2_1f,p2_20,p2_2b,p2_42,p2_43;
-		UShort temp;
-		int mult;
-
-		p2_1f = pSiS->p2_1f;
-		p2_20 = pSiS->p2_20;
-		p2_2b = pSiS->p2_2b;
-		p2_42 = pSiS->p2_42;
-		p2_43 = pSiS->p2_43;
-#ifdef SISDUALHEAD
-	        if(pSiSEnt && pSiS->DualHeadMode) {
-		   p2_1f = pSiSEnt->p2_1f;
-		   p2_20 = pSiSEnt->p2_20;
-		   p2_2b = pSiSEnt->p2_2b;
-		   p2_42 = pSiSEnt->p2_42;
-		   p2_43 = pSiSEnt->p2_43;
-		}
-#endif
-		mult = 2;
-		if(pSiS->VBFlags & TV_YPBPR) {
-		   if(pSiS->VBFlags & (TV_YPBPR1080I | TV_YPBPR750P)) {
-		      mult = 4;
-		   }
-		}
-
-		temp = p2_1f | ((p2_20 & 0xf0) << 4);
-		temp += (val * mult);
-		p2_1f = temp & 0xff;
-		p2_20 = (temp & 0xf00) >> 4;
-		p2_2b = ((p2_2b & 0x0f) + (val * mult)) & 0x0f;
-		temp = p2_43 | ((p2_42 & 0xf0) << 4);
-		temp += (val * mult);
-		p2_43 = temp & 0xff;
-		p2_42 = (temp & 0xf00) >> 4;
-		SISWaitRetraceCRT2(pScrn);
-	        outSISIDXREG(SISPART2,0x1f,p2_1f);
-		setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
-		setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
-		setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
-		outSISIDXREG(SISPART2,0x43,p2_43);
-	     }
-	 }
-      }
-
-   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
-
-      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
-
-         UChar tmp;
-	 UShort temp1, temp2, temp3;
-
-         tmp = SiS6326GetTVReg(pScrn,0x00);
-         if(tmp & 0x04) {
-
-	    temp1 = pSiS->tvx1;
-            temp2 = pSiS->tvx2;
-            temp3 = pSiS->tvx3;
-            if((val >= -16) && (val <= 16)) {
-	       if(val > 0) {
-	          temp1 += (val * 4);
-	          temp2 += (val * 4);
-	          while((temp1 > 0x0fff) || (temp2 > 0x0fff)) {
-	             temp1 -= 4;
-		     temp2 -= 4;
-	          }
-	       } else {
-	          val = -val;
-	          temp3 += (val * 4);
-	          while(temp3 > 0x03ff) {
-	     	     temp3 -= 4;
-	          }
-	       }
-            }
-            SiS6326SetTVReg(pScrn,0x3a,(temp1 & 0xff));
-            tmp = SiS6326GetTVReg(pScrn,0x3c);
-            tmp &= 0xf0;
-            tmp |= ((temp1 & 0x0f00) >> 8);
-            SiS6326SetTVReg(pScrn,0x3c,tmp);
-            SiS6326SetTVReg(pScrn,0x26,(temp2 & 0xff));
-            tmp = SiS6326GetTVReg(pScrn,0x27);
-            tmp &= 0x0f;
-            tmp |= ((temp2 & 0x0f00) >> 4);
-            SiS6326SetTVReg(pScrn,0x27,tmp);
-            SiS6326SetTVReg(pScrn,0x12,(temp3 & 0xff));
-            tmp = SiS6326GetTVReg(pScrn,0x13);
-            tmp &= ~0xC0;
-            tmp |= ((temp3 & 0x0300) >> 2);
-            SiS6326SetTVReg(pScrn,0x13,tmp);
-	 }
-      }
-   }
-}
-
-int SiS_GetTVxposoffset(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)
-        return (int)pSiSEnt->tvxpos;
-   else
-#endif
-        return (int)pSiS->tvxpos;
-}
-
-void SiS_SetTVyposoffset(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   pSiS->tvypos = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->tvypos = val;
-#endif
-
-   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-
-      if(pSiS->VBFlags & CRT2_TV) {
-
-         if(pSiS->VBFlags2 & VB2_CHRONTEL) {
-
-	    int y = pSiS->tvy;
-#ifdef SISDUALHEAD
-	    if(pSiSEnt && pSiS->DualHeadMode) y = pSiSEnt->tvy;
-#endif
-	    switch(pSiS->ChrontelType) {
-	    case CHRONTEL_700x:
-	       if((val >= -32) && (val <= 32)) {
-		   y -= val;
-		   if(y < 0) y = 0;
-		   SiS_SetCH700x(pSiS->SiS_Pr, 0x0b, (y & 0xff));
-		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x08, ((y & 0x0100) >> 8), 0xFE);
-	       }
-	       break;
-	    case CHRONTEL_701x:
-	       /* Not supported by hardware */
-	       break;
-	    }
-
-	 } else if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
-
-	    if((val >= -32) && (val <= 32)) {
-		char p2_01, p2_02;
-
-		if( (pSiS->VBFlags & TV_HIVISION) ||
-		    ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & (TV_YPBPR1080I|TV_YPBPR750P))) ) {
-		   val *= 2;
-		} else {
-		   val /= 2;  /* 4 */
-		}
-
-		p2_01 = pSiS->p2_01;
-		p2_02 = pSiS->p2_02;
-#ifdef SISDUALHEAD
-	        if(pSiSEnt && pSiS->DualHeadMode) {
-		   p2_01 = pSiSEnt->p2_01;
-		   p2_02 = pSiSEnt->p2_02;
-		}
-#endif
-		p2_01 += val; /* val * 2 */
-		p2_02 += val; /* val * 2 */
-		if(!(pSiS->VBFlags & (TV_YPBPR | TV_HIVISION))) {
-		   while((p2_01 <= 0) || (p2_02 <= 0)) {
-		      p2_01 += 2;
-		      p2_02 += 2;
-		   }
-		} else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR1080I)) {
-		   while(p2_01 <= 8) {
-		      p2_01 += 2;
-		      p2_02 += 2;
-		   }
-		} else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR750P)) {
-		   while(p2_01 <= 10) {
-		      p2_01 += 2;
-		      p2_02 += 2;
-		   }
-		}
-
-		SISWaitRetraceCRT2(pScrn);
-		outSISIDXREG(SISPART2,0x01,p2_01);
-		outSISIDXREG(SISPART2,0x02,p2_02);
-	     }
-	 }
-
-      }
-
-   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
-
-      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
-
-         UChar tmp;
-	 int temp1, limit;
-
-         tmp = SiS6326GetTVReg(pScrn,0x00);
-         if(tmp & 0x04) {
-
-	    if((val >= -16) && (val <= 16)) {
-	      temp1 = (UShort)pSiS->tvy1;
-	      limit = (pSiS->SiS6326Flags & SIS6326_TVPAL) ? 625 : 525;
-	      if(val > 0) {
-                temp1 += (val * 4);
-	        if(temp1 > limit) temp1 -= limit;
-	      } else {
-	        val = -val;
-	        temp1 -= (val * 2);
-	        if(temp1 <= 0) temp1 += (limit -1);
-	      }
-	      SiS6326SetTVReg(pScrn,0x11,(temp1 & 0xff));
-	      tmp = SiS6326GetTVReg(pScrn,0x13);
-	      tmp &= ~0x30;
-	      tmp |= ((temp1 & 0x300) >> 4);
-	      SiS6326SetTVReg(pScrn,0x13,tmp);
-	      if(temp1 == 1)                                 tmp = 0x10;
-	      else {
-	       if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
-	         if((temp1 <= 3) || (temp1 >= (limit - 2)))  tmp = 0x08;
-	         else if(temp1 < 22)		 	     tmp = 0x02;
-	         else 					     tmp = 0x04;
-	       } else {
-	         if((temp1 <= 5) || (temp1 >= (limit - 4)))  tmp = 0x08;
-	         else if(temp1 < 19)			     tmp = 0x02;
-	         else 					     tmp = 0x04;
-	       }
-	     }
-	     SiS6326SetTVReg(pScrn,0x21,tmp);
-           }
-	 }
-      }
-   }
-}
-
-int SiS_GetTVyposoffset(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)
-        return (int)pSiSEnt->tvypos;
-   else
-#endif
-        return (int)pSiS->tvypos;
-}
-
-void SiS_SetTVxscale(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   pSiS->tvxscale = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->tvxscale = val;
-#endif
-
-   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-
-      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags2 & VB2_SISBRIDGE)) {
-
-	 if((val >= -16) && (val <= 16)) {
-
-	    UChar p2_44,p2_45,p2_46;
-	    int scalingfactor, mult;
-
-	    p2_44 = pSiS->p2_44;
-	    p2_45 = pSiS->p2_45 & 0x3f;
-	    p2_46 = pSiS->p2_46 & 0x07;
-#ifdef SISDUALHEAD
-	    if(pSiSEnt && pSiS->DualHeadMode) {
-	       p2_44 = pSiSEnt->p2_44;
-	       p2_45 = pSiSEnt->p2_45 & 0x3f;
-	       p2_46 = pSiSEnt->p2_46 & 0x07;
-	    }
-#endif
-	    scalingfactor = (p2_46 << 13) | ((p2_45 & 0x1f) << 8) | p2_44;
-
-	    mult = 64;
-	    if(pSiS->VBFlags & TV_YPBPR) {
-	       if(pSiS->VBFlags & TV_YPBPR1080I) {
-	          mult = 190;
-	       } else if(pSiS->VBFlags & TV_YPBPR750P) {
-	          mult = 360;
-	       }
-	    } else if(pSiS->VBFlags & TV_HIVISION) {
-	       mult = 190;
-	    }
-
-	    if(val < 0) {
-	       p2_45 &= 0xdf;
-	       scalingfactor += ((-val) * mult);
-	       if(scalingfactor > 0xffff) scalingfactor = 0xffff;
-	    } else if(val > 0) {
-	       p2_45 &= 0xdf;
-	       scalingfactor -= (val * mult);
-	       if(scalingfactor < 1) scalingfactor = 1;
-	    }
-
-	    p2_44 = scalingfactor & 0xff;
-	    p2_45 &= 0xe0;
-	    p2_45 |= ((scalingfactor >> 8) & 0x1f);
-	    p2_46 = ((scalingfactor >> 13) & 0x07);
-
-	    SISWaitRetraceCRT2(pScrn);
-	    outSISIDXREG(SISPART2,0x44,p2_44);
-	    setSISIDXREG(SISPART2,0x45,0xC0,p2_45);
-	    if(!(pSiS->VBFlags2 & VB2_301)) {
-	       setSISIDXREG(SISPART2,0x46,0xF8,p2_46);
-	    }
-
-	 }
-
-      }
-
-   }
-}
-
-int SiS_GetTVxscale(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)
-        return (int)pSiSEnt->tvxscale;
-   else
-#endif
-        return (int)pSiS->tvxscale;
-}
-
-void SiS_SetTVyscale(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   if(val < -4) val = -4;
-   if(val > 3)  val = 3;
-
-   pSiS->tvyscale = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->tvyscale = val;
-#endif
-
-   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
-
-      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags2 & VB2_SISBRIDGE)) {
-
-	 int srindex = -1, newvde, i = 0, j, vlimit, temp, vdediv;
-	 int hdclk = 0;
-	 UChar p3d4_34;
-	 Bool found = FALSE;
-	 Bool usentsc = FALSE;
-	 Bool is750p = FALSE;
-	 Bool is1080i = FALSE;
-	 Bool skipmoveup = FALSE;
-
-	 SiS_UnLockCRT2(pSiS->SiS_Pr);
-
-	 if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525P)) {
-	    vlimit = 525 - 7;
-	    vdediv = 1;
-	    usentsc = TRUE;
-	 } else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR625P)) {
-	    vlimit = 625 - 7;
-	    vdediv = 1;
-	 } else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR750P)) {
-	    vlimit = 750 - 7;
-	    vdediv = 1;
-	    is750p = TRUE;
-	 } else if(((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR1080I)) ||
-	           (pSiS->VBFlags & TV_HIVISION)) {
-	    vlimit = (1125 - 7) / 2;
-	    vdediv = 2;
-	    is1080i = TRUE;
-	 } else {
-	    if( ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) ||
-	        ((!(pSiS->VBFlags & TV_YPBPR)) && (pSiS->VBFlags & (TV_NTSC | TV_PALM))) ) {
-	       usentsc = TRUE;
-	    }
-	    vlimit = usentsc ? 259 : 309;
-	    vdediv = 2;
-	 }
-
-	 inSISIDXREG(SISCR,0x34,p3d4_34);
-
-	 switch((p3d4_34 & 0x7f)) {
-	 case 0x50:   /* 320x240 */
-	 case 0x56:
-	 case 0x53:
-	    hdclk = 1;
-	    /* fall through */
-	 case 0x2e:   /* 640x480 */
-	 case 0x44:
-	 case 0x62:
-	    if(is1080i) {
-	       srindex = 98;
-	    } else if(is750p) {
-	       srindex = 42;
-	    } else {
-	       srindex  = usentsc ? 0 : 21;
-	    }
-	    break;
-	 case 0x31:   /* 720x480 */
-	 case 0x33:
-	 case 0x35:
-	    if(is1080i) {
-	       /* n/a */
-	    } else if(is750p) {
-	       srindex = 49;
-	    } else {
-	       srindex = usentsc ? 7 : 21;
-	    }
-	    break;
-	 case 0x32:   /* 720x576 */
-	 case 0x34:
-	 case 0x36:
-	 case 0x5f:   /* 768x576 */
-	 case 0x60:
-	 case 0x61:
-	    if(is1080i) {
-	       /* n/a */
-	    } else if(is750p) {
-	       srindex = 56;
-	    } else {
-	       srindex  = usentsc ? 147 : 28;
-	    }
-	    break;
-	 case 0x70:   /* 800x480 */
-	 case 0x7a:
-	 case 0x76:
-	    if(is1080i) {
-	       srindex = 105;
-	    } else if(is750p) {
-	       srindex = 63;
-	    } else {
-	       srindex = usentsc ? 175 : 21;
-	    }
-	    break;
-	 case 0x51:   /* 400x300 - hdclk mode */
-	 case 0x57:
-	 case 0x54:
-	    hdclk = 1;
-	    /* fall through */
-	 case 0x30:   /* 800x600 */
-	 case 0x47:
-	 case 0x63:
-	    if(is1080i) {
-	       srindex = 112;
-	    } else if(is750p) {
-	       srindex = 70;
-	    } else {
-	       srindex = usentsc ? 14 : 35;
-	    }
-	    break;
-	 case 0x1d:	/* 960x540 */
-	 case 0x1e:
-	 case 0x1f:
-	    if(is1080i) {
-	       srindex = 196;
-	       skipmoveup = TRUE;
-	    }
-	    break;
-	 case 0x20:	/* 960x600 */
-	 case 0x21:
-	 case 0x22:
-	    if(pSiS->VGAEngine == SIS_315_VGA && is1080i) {
-	       srindex = 203;
-	    }
-	    break;
-	 case 0x71:	/* 1024x576 */
-	 case 0x74:
-	 case 0x77:
-	    if(is1080i) {
-	       srindex = 119;
-	    } else if(is750p) {
-	       srindex = 77;
-	    } else {
-	       srindex  = usentsc ? 182 : 189;
-	    }
-	    break;
-	 case 0x52:	/* 512x384 */
-	 case 0x58:
-	 case 0x5c:
-	    hdclk = 1;
-	    /* fall through */
-	 case 0x38:	/* 1024x768 */
-	 case 0x4a:
-	 case 0x64:
-	    if(is1080i) {
-	       srindex = 126;
-	    } else if(is750p) {
-	       srindex = 84;
-	    } else if(!usentsc) {
-	       srindex = 154;
-	    } else if(vdediv == 1) {
-	       if(!hdclk) srindex = 168;
-	    } else {
-	       if(!hdclk) srindex = 161;
-	    }
-	    break;
-	 case 0x79:	/* 1280x720 */
-	 case 0x75:
-	 case 0x78:
-	    if(is1080i) {
-	       srindex = 133;
-	    } else if(is750p) {
-	       srindex = 91;
-	    }
-	    break;
-	 case 0x3a:	/* 1280x1024 */
-	 case 0x4d:
-	 case 0x65:
-	    if(is1080i) {
-	       srindex = 140;
-	    }
-	    break;
-	 }
-
-	 if(srindex < 0) return;
-
-	 if(pSiS->tvyscale != 0) {
-	    for(j = 0; j <= 1; j++) {
-	       for(i = 0; i <= 6; i++) {
-		  if(SiSTVVScale[srindex+i].sindex == pSiS->tvyscale) {
-		     found = TRUE;
-		     break;
-		  }
-	       }
-	       if(found) break;
-	       if(pSiS->tvyscale > 0) pSiS->tvyscale--;
-	       else pSiS->tvyscale++;
-	    }
-	 }
-
-#ifdef SISDUALHEAD
-	 if(pSiSEnt) pSiSEnt->tvyscale = pSiS->tvyscale;
-#endif
-
-	 if(pSiS->tvyscale == 0) {
-	    UChar p2_0a = pSiS->p2_0a;
-	    UChar p2_2f = pSiS->p2_2f;
-	    UChar p2_30 = pSiS->p2_30;
-	    UChar p2_46 = pSiS->p2_46;
-	    UChar p2_47 = pSiS->p2_47;
-	    UChar p1scaling[9], p4scaling[9];
-	    UChar *p2scaling;
-
-	    for(i = 0; i < 9; i++) {
-	        p1scaling[i] = pSiS->scalingp1[i];
-		p4scaling[i] = pSiS->scalingp4[i];
-	    }
-	    p2scaling = &pSiS->scalingp2[0];
-
-#ifdef SISDUALHEAD
-	    if(pSiSEnt && pSiS->DualHeadMode) {
-	       p2_0a = pSiSEnt->p2_0a;
-	       p2_2f = pSiSEnt->p2_2f;
-	       p2_30 = pSiSEnt->p2_30;
-	       p2_46 = pSiSEnt->p2_46;
-	       p2_47 = pSiSEnt->p2_47;
-	       for(i = 0; i < 9; i++) {
-		  p1scaling[i] = pSiSEnt->scalingp1[i];
-		  p4scaling[i] = pSiSEnt->scalingp4[i];
-	       }
-	       p2scaling = &pSiSEnt->scalingp2[0];
-	    }
-#endif
-            SISWaitRetraceCRT2(pScrn);
-	    if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
-	       for(i = 0; i < 64; i++) {
-	          outSISIDXREG(SISPART2,(0xc0 + i),p2scaling[i]);
-	       }
-	    }
-	    for(i = 0; i < 9; i++) {
-	       outSISIDXREG(SISPART1,SiSScalingP1Regs[i],p1scaling[i]);
-	    }
-	    for(i = 0; i < 9; i++) {
-	       outSISIDXREG(SISPART4,SiSScalingP4Regs[i],p4scaling[i]);
-	    }
-
-	    setSISIDXREG(SISPART2,0x0a,0x7f,(p2_0a & 0x80));
-	    outSISIDXREG(SISPART2,0x2f,p2_2f);
-	    setSISIDXREG(SISPART2,0x30,0x3f,(p2_30 & 0xc0));
-	    if(!(pSiS->VBFlags2 & VB2_301)) {
-	       setSISIDXREG(SISPART2,0x46,0x9f,(p2_46 & 0x60));
-	       outSISIDXREG(SISPART2,0x47,p2_47);
-	    }
-
-	 } else {
-
-	    int realvde, myypos, watchdog = 32;
-	    unsigned short temp1, temp2, vgahde, vgaht, vgavt;
-	    int p1div = 1;
-	    ULong calctemp;
-
-	    srindex += i;
-	    newvde = SiSTVVScale[srindex].ScaleVDE;
-	    realvde = SiSTVVScale[srindex].RealVDE;
-
-	    if(vdediv == 1) p1div = 2;
-
-	    if(!skipmoveup) {
-	       do {
-	          inSISIDXREG(SISPART2,0x01,temp);
-	          temp = vlimit - ((temp & 0x7f) / p1div);
-	          if((temp - (((newvde / vdediv) - 2) + 9)) > 0) break;
-	          myypos = pSiS->tvypos - 1;
-#ifdef SISDUALHEAD
-	          if(pSiSEnt && pSiS->DualHeadMode) myypos = pSiSEnt->tvypos - 1;
-#endif
-	          SiS_SetTVyposoffset(pScrn, myypos);
-	       } while(watchdog--);
-	    }
-
-	    SISWaitRetraceCRT2(pScrn);
-
-	    if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
-	       SiS_CalcXTapScaler(pSiS->SiS_Pr, realvde, newvde, 4, FALSE);
-	    }
-
-	    if(!(pSiS->VBFlags2 & VB2_301)) {
-	       temp = (newvde / vdediv) - 3;
-	       setSISIDXREG(SISPART2,0x46,0x9f,((temp & 0x0300) >> 3));
-	       outSISIDXREG(SISPART2,0x47,(temp & 0xff));
-	    }
-
-	    inSISIDXREG(SISPART1,0x0a,temp1);
-	    inSISIDXREG(SISPART1,0x0c,temp2);
-	    vgahde = ((temp2 & 0xf0) << 4) | temp1;
-	    if(pSiS->VGAEngine == SIS_300_VGA) {
-	       vgahde -= 12;
-	    } else {
-	       vgahde -= 16;
-	       if(hdclk) vgahde <<= 1;
-	    }
-
-	    vgaht = SiSTVVScale[srindex].reg[0];
-	    temp1 = vgaht;
-	    if((pSiS->VGAEngine == SIS_315_VGA) && hdclk) temp1 >>= 1;
-	    temp1--;
-	    outSISIDXREG(SISPART1,0x08,(temp1 & 0xff));
-	    setSISIDXREG(SISPART1,0x09,0x0f,((temp1 >> 4) & 0xf0));
-
-	    temp2 = (vgaht - vgahde) >> 2;
-	    if(pSiS->VGAEngine == SIS_300_VGA) {
-	       temp1 = vgahde + 12 + temp2;
-	       temp2 = temp1 + (temp2 << 1);
-	    } else {
-	       temp1 = vgahde;
-	       if(hdclk) {
-		  temp1 >>= 1;
-		  temp2 >>= 1;
-	       }
-	       temp2 >>= 1;
-	       temp1 = temp1 + 16 + temp2;
-	       temp2 = temp1 + temp2;
-	    }
-	    outSISIDXREG(SISPART1,0x0b,(temp1 & 0xff));
-	    setSISIDXREG(SISPART1,0x0c,0xf0,((temp1 >> 8) & 0x0f));
-	    outSISIDXREG(SISPART1,0x0d,(temp2 & 0xff));
-
-	    vgavt = SiSTVVScale[srindex].reg[1];
-	    temp1 = vgavt - 1;
-	    if(pSiS->VGAEngine == SIS_315_VGA) temp1--;
-	    outSISIDXREG(SISPART1,0x0e,(temp1 & 0xff));
-	    setSISIDXREG(SISPART1,0x12,0xf8,((temp1 >> 8 ) & 0x07));
-	    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->ChipType >= SIS_661)) {
-	       temp1 = (vgavt + SiSTVVScale[srindex].RealVDE) >> 1;
-	       temp2 = ((vgavt - SiSTVVScale[srindex].RealVDE) >> 4) + temp1 + 1;
-	    } else {
-	       temp1 = (vgavt - SiSTVVScale[srindex].RealVDE) >> 2;
-	       temp2 = (temp1 < 4) ? 4 : temp1;
-	       temp1 += SiSTVVScale[srindex].RealVDE;
-	       temp2 = (temp2 >> 2) + temp1 + 1;
-	    }
-	    outSISIDXREG(SISPART1,0x10,(temp1 & 0xff));
-	    setSISIDXREG(SISPART1,0x11,0x8f,((temp1 >> 4) & 0x70));
-	    setSISIDXREG(SISPART1,0x11,0xf0,(temp2 & 0x0f));
-
-	    setSISIDXREG(SISPART2,0x0a,0x7f,((SiSTVVScale[srindex].reg[2] >> 8) & 0x80));
-	    outSISIDXREG(SISPART2,0x2f,((newvde / vdediv) - 2));
-	    setSISIDXREG(SISPART2,0x30,0x3f,((((newvde / vdediv) - 2) >> 2) & 0xc0));
-
-	    outSISIDXREG(SISPART4,0x13,(SiSTVVScale[srindex].reg[2] & 0xff));
-	    outSISIDXREG(SISPART4,0x14,(SiSTVVScale[srindex].reg[3] & 0xff));
-	    setSISIDXREG(SISPART4,0x15,0x7f,((SiSTVVScale[srindex].reg[3] >> 1) & 0x80));
-
-	    temp1 = vgaht - 1;
-	    outSISIDXREG(SISPART4,0x16,(temp1 & 0xff));
-	    setSISIDXREG(SISPART4,0x15,0x87,((temp1 >> 5) & 0x78));
-
-	    temp1 = vgavt - 1;
-	    outSISIDXREG(SISPART4,0x17,(temp1 & 0xff));
-	    setSISIDXREG(SISPART4,0x15,0xf8,((temp1 >> 8) & 0x07));
-
-	    outSISIDXREG(SISPART4,0x18,0x00);
-	    setSISIDXREG(SISPART4,0x19,0xf0,0x00);
-
-	    inSISIDXREG(SISPART4,0x0e,temp1);
-	    if(is1080i) {
-	       if(!(temp1 & 0xe0)) newvde >>= 1;
-	    }
-
-	    temp = 0x40;
-	    if(realvde <= newvde) temp = 0;
-	    else realvde -= newvde;
-
-	    calctemp = (realvde * 256 * 1024) / newvde;
-	    if((realvde * 256 * 1024) % newvde) calctemp++;
-	    outSISIDXREG(SISPART4,0x1b,(calctemp & 0xff));
-	    outSISIDXREG(SISPART4,0x1a,((calctemp >> 8) & 0xff));
-	    setSISIDXREG(SISPART4,0x19,0x8f,(((calctemp >> 12) & 0x70) | temp));
-	 }
-
-      }
-
-   }
-}
-
-int SiS_GetTVyscale(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)
-        return (int)pSiSEnt->tvyscale;
-   else
-#endif
-        return (int)pSiS->tvyscale;
-}
-
-void SiS_SetSISCRT1SaturationGain(ScrnInfoPtr pScrn, int val)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-
-   pSiS->siscrt1satgain = val;
-#ifdef SISDUALHEAD
-   if(pSiSEnt) pSiSEnt->siscrt1satgain = val;
-#endif
-
-   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_CRT1SATGAIN)) return;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-   if((val >= 0) && (val <= 7)) {
-      setSISIDXREG(SISCR,0x53,0xE3, (val << 2));
-   }
-}
-
-int SiS_GetSISCRT1SaturationGain(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int result = pSiS->siscrt1satgain;
-   UChar temp;
-#ifdef SISDUALHEAD
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->siscrt1satgain;
-#endif
-
-   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_CRT1SATGAIN)) return result;
-
-#ifdef UNLOCK_ALWAYS
-   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-   inSISIDXREG(SISCR, 0x53, temp);
-   return (int)((temp >> 2) & 0x07);
-}
-
-/* Calc dotclock from registers */
-static int
-SiSGetClockFromRegs(UChar sr2b, UChar sr2c)
-{
-   float num, denum, postscalar, divider;
-   int   myclock;
-
-   divider = (sr2b & 0x80) ? 2.0 : 1.0;
-   postscalar = (sr2c & 0x80) ?
-              ( (((sr2c >> 5) & 0x03) == 0x02) ? 6.0 : 8.0 ) :
-	      ( ((sr2c >> 5) & 0x03) + 1.0 );
-   num = (sr2b & 0x7f) + 1.0;
-   denum = (sr2c & 0x1f) + 1.0;
-   myclock = (int)((14318 * (divider / postscalar) * (num / denum)) / 1000);
-   return myclock;
-}
-
-#ifdef SISDUALHEAD
-static void
-SiS_SetDHFlags(SISPtr pSiS, unsigned int misc, unsigned int sd2)
-{
-   SISEntPtr pSiSEnt = pSiS->entityPrivate;
-
-   if(pSiS->DualHeadMode) {
-      if(pSiSEnt->pScrn_1) {
-	 SISPTR(pSiSEnt->pScrn_1)->MiscFlags |= misc;
-	 SISPTR(pSiSEnt->pScrn_1)->SiS_SD2_Flags |= sd2;
-      }
-      if(pSiSEnt->pScrn_2) {
-	 SISPTR(pSiSEnt->pScrn_2)->MiscFlags |= misc;
-	 SISPTR(pSiSEnt->pScrn_2)->SiS_SD2_Flags |= sd2;
-      }
-   }
-}
-#endif
-
-/* PostSetMode:
- * -) Disable CRT1 for saving bandwidth. This doesn't work with VESA;
- *    VESA uses the bridge in SlaveMode and switching CRT1 off while
- *    the bridge is in SlaveMode not that clever...
- * -) Check if overlay can be used (depending on dotclock)
- * -) Check if Panel Scaler is active on LVDS for overlay re-scaling
- * -) Save TV registers for further processing
- * -) Apply TV settings
- */
-static void
-SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-    SISEntPtr pSiSEnt = pSiS->entityPrivate;
-#endif
-    UChar usScratchCR17, sr2b, sr2c, tmpreg;
-    int   myclock1, myclock2, mycoldepth1, mycoldepth2, temp;
-    Bool  flag = FALSE;
-    Bool  doit = TRUE;
-    Bool  IsInSlaveMode;
-
-#ifdef TWDEBUG
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-    	"CRT1off is %d\n", pSiS->CRT1off);
-#endif
-    pSiS->CRT1isoff = pSiS->CRT1off;
-
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-    SiSFixupSR11(pScrn);
-
-    IsInSlaveMode = SiSBridgeIsInSlaveMode(pScrn);
-
-    if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
-
-	if(pSiS->VBFlags != pSiS->VBFlags_backup) {
-	   pSiS->VBFlags = pSiS->VBFlags_backup;
-	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"VBFlags restored to %0x\n", pSiS->VBFlags);
-	}
-
-	/* -) We can't switch off CRT1 if bridge is in SlaveMode.
-	 * -) If we change to a SlaveMode-Mode (like 512x384), we
-	 *    need to adapt VBFlags for eg. Xv.
-	 */
-#ifdef SISDUALHEAD
-	if(!pSiS->DualHeadMode) {
-#endif
-	   if(IsInSlaveMode) {
-	      doit = FALSE;
-	      temp = pSiS->VBFlags;
-	      pSiS->VBFlags &= (~VB_DISPMODE_SINGLE);
-	      pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_DISP1);
-              if(temp != pSiS->VBFlags) {
-		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		 	"VBFlags changed to 0x%0x\n", pSiS->VBFlags);
-	      }
-	   }
-#ifdef SISDUALHEAD
-	}
-#endif
-
-	if(pSiS->VGAEngine == SIS_315_VGA) {
-
-	   if((pSiS->CRT1off) && (doit)) {
-	      orSISIDXREG(SISCR,pSiS->myCR63,0x40);
-	      orSISIDXREG(SISSR,0x1f,0xc0);
-	      andSISIDXREG(SISSR,0x07,~0x10);
-	      andSISIDXREG(SISSR,0x06,0xe2);
-	      andSISIDXREG(SISSR,0x31,0xcf);
-	      outSISIDXREG(SISSR,0x2b,0x1b);
-	      outSISIDXREG(SISSR,0x2c,0xe1);
-	      outSISIDXREG(SISSR,0x2d,0x01);
-	      outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
-	      usleep(10000);
-	      outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
-	   } else {
-	      andSISIDXREG(SISCR,pSiS->myCR63,0xBF);
-	      andSISIDXREG(SISSR,0x1f,0x3f);
-	      orSISIDXREG(SISSR,0x07,0x10);
-	   }
-
-	} else {
-
-	   if(doit) {
-	      inSISIDXREG(SISCR, 0x17, usScratchCR17);
-	      if(pSiS->CRT1off) {
-		 if(usScratchCR17 & 0x80) {
-		    flag = TRUE;
-		    usScratchCR17 &= ~0x80;
-		 }
-		 orSISIDXREG(SISSR,0x1f,0xc0);
-	      } else {
-		 if(!(usScratchCR17 & 0x80)) {
-		    flag = TRUE;
-		    usScratchCR17 |= 0x80;
-		 }
-		 andSISIDXREG(SISSR,0x1f,0x3f);
-	      }
-	      /* Reset only if status changed */
-	      if(flag) {
-		 outSISIDXREG(SISCR, 0x17, usScratchCR17);
-		 outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
-		 usleep(10000);
-		 outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
-	      }
-	   }
-	}
-
-    }
-
-    /* Set bridge to "disable CRT2" mode if CRT2 is disabled, LCD-A is enabled */
-    /* (Not needed for CRT1=VGA since CRT2 will really be disabled then) */
-#ifdef SISDUALHEAD
-    if(!pSiS->DualHeadMode) {
-#endif
-       if((pSiS->VGAEngine == SIS_315_VGA)  && (pSiS->VBFlags2 & VB2_SISLCDABRIDGE)) {
-	  if((!pSiS->UseVESA) && (!(pSiS->VBFlags & CRT2_ENABLE)) && (pSiS->VBFlags & CRT1_LCDA)) {
-	     if(!IsInSlaveMode) {
-	        andSISIDXREG(SISPART4,0x0d,~0x07);
-	     }
-	  }
-       }
-#ifdef SISDUALHEAD
-    }
-#endif
-
-    /* Reset flags */
-    pSiS->MiscFlags &= ~( MISC_CRT1OVERLAY      |
-			  MISC_CRT2OVERLAY      |
-			  MISC_CRT1OVERLAYGAMMA |
-			  MISC_SIS760ONEOVERLAY |
-			  MISC_PANELLINKSCALER  |
-			  MISC_STNMODE		|
-			  MISC_TVNTSC1024);
-
-    pSiS->SiS_SD2_Flags &= ~SiS_SD2_SIS760ONEOVL;
-
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiSEnt->pScrn_1) {
-	  SISPTR(pSiSEnt->pScrn_1)->MiscFlags &= ~(MISC_SIS760ONEOVERLAY	|
-						   MISC_CRT1OVERLAY		|
-						   MISC_CRT2OVERLAY		|
-						   MISC_CRT1OVERLAYGAMMA	|
-						   MISC_PANELLINKSCALER		|
-						   MISC_STNMODE			|
-						   MISC_TVNTSC1024);
-	  SISPTR(pSiSEnt->pScrn_1)->SiS_SD2_Flags &= ~SiS_SD2_SIS760ONEOVL;
-       }
-       if(pSiSEnt->pScrn_2) {
-	  SISPTR(pSiSEnt->pScrn_2)->MiscFlags &= ~(MISC_SIS760ONEOVERLAY	|
-						   MISC_CRT1OVERLAY		|
-						   MISC_CRT2OVERLAY		|
-						   MISC_CRT1OVERLAYGAMMA	|
-						   MISC_PANELLINKSCALER		|
-						   MISC_STNMODE			|
-						   MISC_TVNTSC1024);
-	  SISPTR(pSiSEnt->pScrn_2)->SiS_SD2_Flags &= ~SiS_SD2_SIS760ONEOVL;
-       }
-    }
-#endif
-
-    /* Determine if the video overlay can be used */
-    if(!pSiS->NoXvideo) {
-
-       int clklimit1=0, clklimit2=0, clklimitg=0;
-       Bool OverlayHandled = FALSE;
-
-       inSISIDXREG(SISSR,0x2b,sr2b);
-       inSISIDXREG(SISSR,0x2c,sr2c);
-       myclock1 = myclock2 = SiSGetClockFromRegs(sr2b, sr2c);
-       inSISIDXREG(SISSR,0x06,tmpreg);
-       switch((tmpreg & 0x1c) >> 2) {
-       case 0:  mycoldepth1 = 1; break;
-       case 1:
-       case 2:  mycoldepth1 = 2; break;
-       default: mycoldepth1 = 4;
-       }
-       mycoldepth2 = mycoldepth1;
-
-       if((!IsInSlaveMode) && (pSiS->VBFlags & CRT2_ENABLE)) {
-	  if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
-	     inSISIDXREG(SISPART4,0x0a,sr2b);
-	     inSISIDXREG(SISPART4,0x0b,sr2c);
-	  } else {
-	     inSISIDXREG(SISSR,0x2e,sr2b);
-	     inSISIDXREG(SISSR,0x2f,sr2c);
-	  }
-	  myclock2 = SiSGetClockFromRegs(sr2b, sr2c);
-	  inSISIDXREG(SISPART1,0x00,tmpreg);
-	  tmpreg &= 0x0f;
-	  switch(tmpreg) {
-	  case 8:  mycoldepth2 = 1; break;
-	  case 4:
-	  case 2:  mycoldepth2 = 2; break;
-	  default: mycoldepth2 = 4;
-	  }
-       }
-
-       switch(pSiS->ChipType) {
-
-	 case SIS_300:
-	 case SIS_540:
-	 case SIS_630:
-	 case SIS_730:
-	    clklimit1 = clklimit2 = clklimitg = 150;
-	    break;
-
-	 case SIS_550:
-	 case SIS_650:
-	 case SIS_740:
-	    clklimit1 = clklimit2 = 175;  /* verified for 65x */
-	    clklimitg = 166;		  /* ? */
-	    break;
-
-	 case SIS_661:
-	 case SIS_741:
-	    clklimit1 = clklimit2 = 190;  /* ? */
-	    clklimitg = 180;		  /* ? */
-	    break;
-
-	 case SIS_760:
-	 case SIS_761:
-	    clklimit1 = clklimit2 = 190;    /* ? */
-	    if(pSiS->ChipFlags & SiSCF_760LFB) {		/* LFB only or hybrid */
-	       clklimit1 = clklimit2 = 220; /* ? */
-	    }
-	    clklimitg = 200;		    /* ? */
-
-	    if(pSiS->SiS_SD2_Flags & SiS_SD2_SUPPORT760OO) {	/* UMA only */
-
-	       Bool OnlyOne = FALSE, NoOverlay = FALSE;
-	       int dotclocksum = 0;
-
-	       if(pSiS->VBFlags & DISPTYPE_CRT1)                     dotclocksum += myclock1;
-	       if((!IsInSlaveMode) && (pSiS->VBFlags & CRT2_ENABLE)) dotclocksum += myclock2;
-
-	       /* TODO: Find out under what circumstances only one
-		*	overlay is usable in UMA-only mode.
-		*	This is not entirely accurate; the overlay
-		*	scaler also requires some time, so even though
-		*	the dotclocks are below these values, some
-		*	distortions in the overlay may occure.
-		*	Solution: Don't use a 760 with shared memory.
-		*/
-	       if( (pSiS->VBFlags & DISPTYPE_CRT1) &&
-		   (pSiS->VBFlags & CRT2_ENABLE) &&
-		   (mycoldepth1 != mycoldepth2) ) {
-
-		  /* 0. If coldepths are different (only possible in dual head mode),
-		   *    I have no idea to calculate the limits; hence, allow only one
-		   *    overlay in all cases.
-		   */
-		  OnlyOne = TRUE;
-
-	       } else if(pSiS->MemClock < 150000) {
-
-		  /* 1. MCLK <150: If someone seriously considers using such
-		   *    slow RAM, so be it. Only one overlay in call cases.
-		   */
-		  OnlyOne = TRUE;
-
-	       } else if(pSiS->MemClock < 170000) {
-
-		  /* 2. MCLK 166 */
-		  switch(pSiS->CurrentLayout.bitsPerPixel) {
-		     case 32: if(dotclocksum > 133) OnlyOne = TRUE;		/* One overlay; verified */
-			      if(dotclocksum > 180) NoOverlay = TRUE;		/* No overlay; verified */
-			      break;
-		     case 16: if(dotclocksum > 175) OnlyOne = TRUE;		/* One overlay; verified */
-			      if(dotclocksum > 260) NoOverlay = TRUE;;		/* No overlay; FIXME */
-			      break;
-		  }
-
-	       } else if(pSiS->MemClock < 210000) {
-
-		  /* 3. MCLK 200 */
-		  switch(pSiS->CurrentLayout.bitsPerPixel) {
-		     case 32: if(dotclocksum > 160) OnlyOne = TRUE;		/* One overlay; FIXME */
-			      if(dotclocksum > 216) NoOverlay = TRUE;;		/* No overlay; FIXME */
-			      break;
-		     case 16: if(dotclocksum > 210) OnlyOne = TRUE;		/* One overlay; FIXME */
-			      if(dotclocksum > 312) NoOverlay = TRUE;;		/* No overlay; FIXME */
-			      break;
-		  }
-
-	       }
-
-	       if(OnlyOne || NoOverlay) {
-
-		  ULong tmpflags = 0;
-
-		  if(!NoOverlay) {
-		     if(myclock1 <= clklimit1) tmpflags |= MISC_CRT1OVERLAY;
-		     if(myclock2 <= clklimit2) tmpflags |= MISC_CRT2OVERLAY;
-		     if(myclock1 <= clklimitg) tmpflags |= MISC_CRT1OVERLAYGAMMA;
-		     pSiS->MiscFlags |= tmpflags;
-		  }
-		  pSiS->MiscFlags |= MISC_SIS760ONEOVERLAY;
-		  pSiS->SiS_SD2_Flags |= SiS_SD2_SIS760ONEOVL;
-#ifdef SISDUALHEAD
-		  SiS_SetDHFlags(pSiS, (tmpflags | MISC_SIS760ONEOVERLAY), SiS_SD2_SIS760ONEOVL);
-#endif
-		  OverlayHandled = TRUE;
-	       }
-
-	       xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
-			"SiS76x/UMA: %s video overlay(s) available in current mode\n",
-			NoOverlay ? "no" : ((pSiS->MiscFlags & MISC_SIS760ONEOVERLAY) ? "one" : "two"));
-
-#ifdef TWDEBUG
-	       xf86DrvMsg(0, 0, "SiS760: Memclock %d, c1 %d/%d c2 %d/%d, sum %d / %x\n",
-			pSiS->MemClock, myclock1, mycoldepth1,
-			myclock2, mycoldepth2, dotclocksum, pSiS->SiS_SD2_Flags);
-#endif
-	    }
-	    break;
-
-	 case SIS_660:
-	    clklimit1 = clklimit2 = 200;  /* ? */
-	    if(pSiS->ChipFlags & SiSCF_760LFB) {		/* LFB only */
-	       clklimit1 = clklimit2 = 220;
-	    }
-	    clklimitg = 200;		  /* ? */
-	    break;
-
-	 case SIS_315H:
-	 case SIS_315:
-	 case SIS_315PRO:
-	 case SIS_330:
-	    clklimit1 = clklimit2 = 180;  /* ? */
-	    clklimitg = 166;		  /* ? */
-	    break;
-
-	 case SIS_340: /* ? */
-	 case XGI_20:
-	 case XGI_40:
-	    clklimit1 = clklimit2 = 240;  /* ? */
-	    clklimitg = 200;		  /* ? */
-	    break;
-       }
-
-       if(!OverlayHandled) {
-          ULong tmpflags = 0;
-          if(myclock1 <= clklimit1) tmpflags |= MISC_CRT1OVERLAY;
-          if(myclock2 <= clklimit2) tmpflags |= MISC_CRT2OVERLAY;
-          if(myclock1 <= clklimitg) tmpflags |= MISC_CRT1OVERLAYGAMMA;
-	  pSiS->MiscFlags |= tmpflags;
-#ifdef SISDUALHEAD
-	  SiS_SetDHFlags(pSiS, tmpflags, 0);
-#endif
-          if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
-#ifdef SISDUALHEAD
-             if((!pSiS->DualHeadMode) || (pSiS->SecondHead))
-#endif
-		xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
-		   "Current dotclock (%dMhz) too high for video overlay on CRT1\n",
-		   myclock1);
-          }
-          if((pSiS->VBFlags & CRT2_ENABLE) && (!(pSiS->MiscFlags & MISC_CRT2OVERLAY))) {
-#ifdef SISDUALHEAD
-	     if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
-#endif
-		xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
-		   "Current dotclock (%dMhz) too high for video overlay on CRT2\n",
-		   myclock2);
-	  }
-       }
-
-    }
-
-    /* Determine if the Panel Link scaler is active */
-
-    if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {
-       ULong tmpflags = 0;
-       if(pSiS->VGAEngine == SIS_300_VGA) {
-	  if(pSiS->VBFlags2 & (VB2_LVDS | VB2_30xBDH)) {
-	     inSISIDXREG(SISPART1,0x1e,tmpreg);
-	     tmpreg &= 0x3f;
-	     if(tmpreg) tmpflags |= MISC_PANELLINKSCALER;
-	  }
-       } else {
-	  if((pSiS->VBFlags2 & (VB2_LVDS | VB2_30xBDH)) || (pSiS->VBFlags & CRT1_LCDA)) {
-	     inSISIDXREG(SISPART1,0x35,tmpreg);
-	     tmpreg &= 0x04;
-	     if(!tmpreg)  tmpflags |= MISC_PANELLINKSCALER;
-	  }
-       }
-       pSiS->MiscFlags |= tmpflags;
-#ifdef SISDUALHEAD
-       SiS_SetDHFlags(pSiS, tmpflags, 0);
-#endif
-    }
-
-    /* Determine if STN is active */
-    if(pSiS->ChipType == SIS_550) {
-       if((pSiS->VBFlags & CRT2_LCD) && (pSiS->FSTN || pSiS->DSTN)) {
-	  inSISIDXREG(SISCR,0x34,tmpreg);
-	  tmpreg &= 0x7f;
-	  if(tmpreg == 0x5a || tmpreg == 0x5b) {
-	     pSiS->MiscFlags |= MISC_STNMODE;
-#ifdef SISDUALHEAD
-	     SiS_SetDHFlags(pSiS, MISC_STNMODE, 0);
-#endif
-	  }
-       }
-    }
-
-    /* Determine if our very special TV mode is active */
-    if((pSiS->VBFlags2 & VB2_SISBRIDGE) && (pSiS->VBFlags & CRT2_TV) && (!(pSiS->VBFlags & TV_HIVISION))) {
-       if( ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) ||
-	   ((!(pSiS->VBFlags & TV_YPBPR)) && (pSiS->VBFlags & (TV_NTSC | TV_PALM))) ) {
-	  inSISIDXREG(SISCR,0x34,tmpreg);
-	  tmpreg &= 0x7f;
-	  if((tmpreg == 0x64) || (tmpreg == 0x4a) || (tmpreg == 0x38)) {
-	     pSiS->MiscFlags |= MISC_TVNTSC1024;
-#ifdef SISDUALHEAD
-	     SiS_SetDHFlags(pSiS, MISC_TVNTSC1024, 0);
-#endif
-	  }
-       }
-    }
-
-    if(pSiS->VGAEngine == SIS_315_VGA) {
-       int i;
-#ifdef SISVRAMQ
-       /* Re-Enable and reset command queue */
-       SiSEnableTurboQueue(pScrn);
-#endif
-       /* Get HWCursor register contents for backup */
-       for(i = 0; i < 16; i++) {
-          pSiS->HWCursorBackup[i] = SIS_MMIO_IN32(pSiS->IOBase, 0x8500 + (i << 2));
-       }
-       if(pSiS->ChipType >= SIS_330) {
-          /* Enable HWCursor protection (Y pos as trigger) */
-          andSISIDXREG(SISCR, 0x5b, ~0x30);
-       }
-    }
-
-    /* Re-initialize accelerator engine */
-    /* (We are sync'ed here) */
-    if(!pSiS->NoAccel) {
-       if(pSiS->InitAccel) {
-          (pSiS->InitAccel)(pScrn);
-       }
-    }
-
-    /* Set display device gamma (for SISCTRL) */
-    if(pSiS->VBFlags & CRT1_LCDA)
-       pSiS->CRT1MonGamma = pSiS->CRT2LCDMonitorGamma;
-    else
-       pSiS->CRT1MonGamma = pSiS->CRT1VGAMonitorGamma;
-
-    if(pSiS->VBFlags & CRT2_LCD)
-       pSiS->CRT2MonGamma = pSiS->CRT2LCDMonitorGamma;
-    else if(pSiS->VBFlags & CRT2_TV) {
-       if(pSiS->VBFlags & TV_YPBPR)
-          pSiS->CRT2MonGamma = 2200; /* */
-       else if(pSiS->VBFlags & TV_HIVISION)
-          pSiS->CRT2MonGamma = 2200; /* ? */
-       else if(pSiS->VBFlags & TV_NTSC)
-          pSiS->CRT2MonGamma = 2200; /* NTSC */
-       else
-          pSiS->CRT2MonGamma = 2800; /* All PAL modes? */
-    } else if(pSiS->VBFlags & CRT2_VGA)
-       pSiS->CRT2MonGamma = pSiS->CRT2VGAMonitorGamma;
-    else
-       pSiS->CRT2MonGamma = 0; /* Unknown */
-
-    /* Reset XV display properties (such as number of overlays, etc) */
-    /* (And copy monitor gamma) */
-#ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) {
-       if(pSiSEnt->pScrn_1) {
-	  if(SISPTR(pSiSEnt->pScrn_1)->ResetXvDisplay) {
-	     (SISPTR(pSiSEnt->pScrn_1)->ResetXvDisplay)(pSiSEnt->pScrn_1);
-	  }
-	  SISPTR(pSiSEnt->pScrn_1)->CRT1MonGamma = pSiS->CRT1MonGamma;
-	  SISPTR(pSiSEnt->pScrn_1)->CRT2MonGamma = pSiS->CRT2MonGamma;
-       }
-       if(pSiSEnt->pScrn_2) {
-	  if(SISPTR(pSiSEnt->pScrn_2)->ResetXvDisplay) {
-	     (SISPTR(pSiSEnt->pScrn_1)->ResetXvDisplay)(pSiSEnt->pScrn_2);
-	  }
-	  SISPTR(pSiSEnt->pScrn_2)->CRT1MonGamma = pSiS->CRT1MonGamma;
-	  SISPTR(pSiSEnt->pScrn_2)->CRT2MonGamma = pSiS->CRT2MonGamma;
-       }
-    } else {
-#endif
-       if(pSiS->ResetXvDisplay) {
-	  (pSiS->ResetXvDisplay)(pScrn);
-       }
-#ifdef SISDUALHEAD
-    }
-#endif
-
-    /* Reset XV gamma correction */
-    if(pSiS->ResetXvGamma) {
-       (pSiS->ResetXvGamma)(pScrn);
-    }
-
-    /* Reset various display parameters */
-    {
-       int val = pSiS->siscrt1satgain;
-#ifdef SISDUALHEAD
-       if(pSiS->DualHeadMode && pSiSEnt) val = pSiSEnt->siscrt1satgain;
-#endif
-       SiS_SetSISCRT1SaturationGain(pScrn, val);
-    }
-
-    /*  Apply TV settings given by options
-           Do this even in DualHeadMode:
-	   - if this is called by SetModeCRT1, CRT2 mode has been reset by SetModeCRT1
-	   - if this is called by SetModeCRT2, CRT2 mode has changed (duh!)
-	   -> Hence, in both cases, the settings must be re-applied.
-     */
-
-    if(pSiS->VBFlags & CRT2_TV) {
-       int val;
-       if(pSiS->VBFlags2 & VB2_CHRONTEL) {
-	  int mychtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
-	  int mychtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
-	  int mychtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
-	  int mychtvchromabandwidth = pSiS->chtvchromabandwidth;
-	  int mychtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
-	  int mychtvcvbscolor = pSiS->chtvcvbscolor;
-	  int mychtvtextenhance = pSiS->chtvtextenhance;
-	  int mychtvcontrast = pSiS->chtvcontrast;
-	  int mytvxpos = pSiS->tvxpos;
-	  int mytvypos = pSiS->tvypos;
-#ifdef SISDUALHEAD
-	  if(pSiSEnt && pSiS->DualHeadMode) {
-	     mychtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
-	     mychtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
-	     mychtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
-	     mychtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
-	     mychtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
-	     mychtvcvbscolor = pSiSEnt->chtvcvbscolor;
-	     mychtvtextenhance = pSiSEnt->chtvtextenhance;
-	     mychtvcontrast = pSiSEnt->chtvcontrast;
-	     mytvxpos = pSiSEnt->tvxpos;
-	     mytvypos = pSiSEnt->tvypos;
-	  }
-#endif
-	  if((val = mychtvlumabandwidthcvbs) != -1) {
-	     SiS_SetCHTVlumabandwidthcvbs(pScrn, val);
-	  }
-	  if((val = mychtvlumabandwidthsvideo) != -1) {
-	     SiS_SetCHTVlumabandwidthsvideo(pScrn, val);
-	  }
-	  if((val = mychtvlumaflickerfilter) != -1) {
-	     SiS_SetCHTVlumaflickerfilter(pScrn, val);
-	  }
-	  if((val = mychtvchromabandwidth) != -1) {
-	     SiS_SetCHTVchromabandwidth(pScrn, val);
-	  }
-	  if((val = mychtvchromaflickerfilter) != -1) {
-	     SiS_SetCHTVchromaflickerfilter(pScrn, val);
-	  }
-	  if((val = mychtvcvbscolor) != -1) {
-	     SiS_SetCHTVcvbscolor(pScrn, val);
-	  }
-	  if((val = mychtvtextenhance) != -1) {
-	     SiS_SetCHTVtextenhance(pScrn, val);
-	  }
-	  if((val = mychtvcontrast) != -1) {
-	     SiS_SetCHTVcontrast(pScrn, val);
-	  }
-	  /* Backup default TV position registers */
-	  switch(pSiS->ChrontelType) {
-	  case CHRONTEL_700x:
-	     pSiS->tvx = SiS_GetCH700x(pSiS->SiS_Pr, 0x0a);
-	     pSiS->tvx |= (((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
-	     pSiS->tvy = SiS_GetCH700x(pSiS->SiS_Pr, 0x0b);
-	     pSiS->tvy |= ((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x01) << 8);
-#ifdef SISDUALHEAD
-	     if(pSiSEnt) {
-		pSiSEnt->tvx = pSiS->tvx;
-		pSiSEnt->tvy = pSiS->tvy;
-	     }
-#endif
-	     break;
-	  case CHRONTEL_701x:
-	     /* Not supported by hardware */
-	     break;
-	  }
-	  if((val = mytvxpos) != 0) {
-	     SiS_SetTVxposoffset(pScrn, val);
-	  }
-	  if((val = mytvypos) != 0) {
-	     SiS_SetTVyposoffset(pScrn, val);
-	  }
-       }
-       if(pSiS->VBFlags2 & VB2_301) {
-          int mysistvedgeenhance = pSiS->sistvedgeenhance;
-#ifdef SISDUALHEAD
-          if(pSiSEnt && pSiS->DualHeadMode) {
-	     mysistvedgeenhance = pSiSEnt->sistvedgeenhance;
-	  }
-#endif
-          if((val = mysistvedgeenhance) != -1) {
-	     SiS_SetSISTVedgeenhance(pScrn, val);
-	  }
-       }
-       if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
-          int mysistvantiflicker = pSiS->sistvantiflicker;
-	  int mysistvsaturation = pSiS->sistvsaturation;
-	  int mysistvcolcalibf = pSiS->sistvcolcalibf;
-	  int mysistvcolcalibc = pSiS->sistvcolcalibc;
-	  int mysistvcfilter = pSiS->sistvcfilter;
-	  int mysistvyfilter = pSiS->sistvyfilter;
-	  int mytvxpos = pSiS->tvxpos;
-	  int mytvypos = pSiS->tvypos;
-	  int mytvxscale = pSiS->tvxscale;
-	  int mytvyscale = pSiS->tvyscale;
-	  int i;
-	  ULong cbase;
-	  UChar ctemp;
-#ifdef SISDUALHEAD
-          if(pSiSEnt && pSiS->DualHeadMode) {
-	     mysistvantiflicker = pSiSEnt->sistvantiflicker;
-	     mysistvsaturation = pSiSEnt->sistvsaturation;
-	     mysistvcolcalibf = pSiSEnt->sistvcolcalibf;
-	     mysistvcolcalibc = pSiSEnt->sistvcolcalibc;
-	     mysistvcfilter = pSiSEnt->sistvcfilter;
-	     mysistvyfilter = pSiSEnt->sistvyfilter;
-	     mytvxpos = pSiSEnt->tvxpos;
-	     mytvypos = pSiSEnt->tvypos;
-	     mytvxscale = pSiSEnt->tvxscale;
-	     mytvyscale = pSiSEnt->tvyscale;
-	  }
-#endif
-          /* Backup default TV position, scale and colcalib registers */
-	  inSISIDXREG(SISPART2,0x1f,pSiS->p2_1f);
-	  inSISIDXREG(SISPART2,0x20,pSiS->p2_20);
-	  inSISIDXREG(SISPART2,0x2b,pSiS->p2_2b);
-	  inSISIDXREG(SISPART2,0x42,pSiS->p2_42);
-	  inSISIDXREG(SISPART2,0x43,pSiS->p2_43);
-	  inSISIDXREG(SISPART2,0x01,pSiS->p2_01);
-	  inSISIDXREG(SISPART2,0x02,pSiS->p2_02);
-	  inSISIDXREG(SISPART2,0x44,pSiS->p2_44);
-	  inSISIDXREG(SISPART2,0x45,pSiS->p2_45);
-	  if(!(pSiS->VBFlags2 & VB2_301)) {
-	     inSISIDXREG(SISPART2,0x46,pSiS->p2_46);
-	  } else {
-	     pSiS->p2_46 = 0;
-	  }
-	  inSISIDXREG(SISPART2,0x0a,pSiS->p2_0a);
-	  inSISIDXREG(SISPART2,0x31,cbase);
-	  cbase = (cbase & 0x7f) << 8;
-	  inSISIDXREG(SISPART2,0x32,ctemp);
-	  cbase = (cbase | ctemp) << 8;
-	  inSISIDXREG(SISPART2,0x33,ctemp);
-	  cbase = (cbase | ctemp) << 8;
-	  inSISIDXREG(SISPART2,0x34,ctemp);
-	  pSiS->sistvccbase = (cbase | ctemp);
-	  inSISIDXREG(SISPART2,0x35,pSiS->p2_35);
-	  inSISIDXREG(SISPART2,0x36,pSiS->p2_36);
-	  inSISIDXREG(SISPART2,0x37,pSiS->p2_37);
-	  inSISIDXREG(SISPART2,0x38,pSiS->p2_38);
-	  if(!(pSiS->VBFlags2 & VB2_301)) {
-	     inSISIDXREG(SISPART2,0x47,pSiS->p2_47);
-	     inSISIDXREG(SISPART2,0x48,pSiS->p2_48);
-	     inSISIDXREG(SISPART2,0x49,pSiS->p2_49);
-	     inSISIDXREG(SISPART2,0x4a,pSiS->p2_4a);
-	  }
-	  inSISIDXREG(SISPART2,0x2f,pSiS->p2_2f);
-	  inSISIDXREG(SISPART2,0x30,pSiS->p2_30);
-	  for(i=0; i<9; i++) {
-	     inSISIDXREG(SISPART1,SiSScalingP1Regs[i],pSiS->scalingp1[i]);
-	  }
-	  for(i=0; i<9; i++) {
-	     inSISIDXREG(SISPART4,SiSScalingP4Regs[i],pSiS->scalingp4[i]);
-	  }
-	  if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
-	     for(i=0; i<64; i++) {
-	        inSISIDXREG(SISPART2,(0xc0 + i),pSiS->scalingp2[i]);
-  	     }
-	  }
-#ifdef SISDUALHEAD
-	  if(pSiSEnt) {
-	     pSiSEnt->p2_1f = pSiS->p2_1f; pSiSEnt->p2_20 = pSiS->p2_20;
-	     pSiSEnt->p2_42 = pSiS->p2_42; pSiSEnt->p2_43 = pSiS->p2_43;
-	     pSiSEnt->p2_2b = pSiS->p2_2b;
-	     pSiSEnt->p2_01 = pSiS->p2_01; pSiSEnt->p2_02 = pSiS->p2_02;
-	     pSiSEnt->p2_44 = pSiS->p2_44; pSiSEnt->p2_45 = pSiS->p2_45;
-	     pSiSEnt->p2_46 = pSiS->p2_46; pSiSEnt->p2_0a = pSiS->p2_0a;
-	     pSiSEnt->sistvccbase = pSiS->sistvccbase;
-	     pSiSEnt->p2_35 = pSiS->p2_35; pSiSEnt->p2_36 = pSiS->p2_36;
-	     pSiSEnt->p2_37 = pSiS->p2_37; pSiSEnt->p2_38 = pSiS->p2_38;
-	     pSiSEnt->p2_48 = pSiS->p2_48; pSiSEnt->p2_49 = pSiS->p2_49;
-	     pSiSEnt->p2_4a = pSiS->p2_4a; pSiSEnt->p2_2f = pSiS->p2_2f;
-	     pSiSEnt->p2_30 = pSiS->p2_30; pSiSEnt->p2_47 = pSiS->p2_47;
-	     for(i=0; i<9; i++) {
-	        pSiSEnt->scalingp1[i] = pSiS->scalingp1[i];
-	     }
-	     for(i=0; i<9; i++) {
-	        pSiSEnt->scalingp4[i] = pSiS->scalingp4[i];
-	     }
-	     if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
-	        for(i=0; i<64; i++) {
-	           pSiSEnt->scalingp2[i] = pSiS->scalingp2[i];
-  	        }
-	     }
-	  }
-#endif
-          if((val = mysistvantiflicker) != -1) {
-	     SiS_SetSISTVantiflicker(pScrn, val);
-	  }
-	  if((val = mysistvsaturation) != -1) {
-	     SiS_SetSISTVsaturation(pScrn, val);
-	  }
-	  if((val = mysistvcfilter) != -1) {
-	     SiS_SetSISTVcfilter(pScrn, val);
-	  }
-	  if((val = mysistvyfilter) != 1) {
-	     SiS_SetSISTVyfilter(pScrn, val);
-	  }
-	  if((val = mysistvcolcalibc) != 0) {
-	     SiS_SetSISTVcolcalib(pScrn, val, TRUE);
-	  }
-	  if((val = mysistvcolcalibf) != 0) {
-	     SiS_SetSISTVcolcalib(pScrn, val, FALSE);
-	  }
-	  if((val = mytvxpos) != 0) {
-	     SiS_SetTVxposoffset(pScrn, val);
-	  }
-	  if((val = mytvypos) != 0) {
-	     SiS_SetTVyposoffset(pScrn, val);
-	  }
-	  if((val = mytvxscale) != 0) {
-	     SiS_SetTVxscale(pScrn, val);
-	  }
-	  if((val = mytvyscale) != 0) {
-	     SiS_SetTVyscale(pScrn, val);
-	  }
-       }
-    }
-
-}
-
-/* Post-set SiS6326 TV registers */
-static void
-SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    UChar tmp;
-    int val;
-
-    if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
-
-#ifdef UNLOCK_ALWAYS
-    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
-#endif
-
-    /* Backup default TV position registers */
-    pSiS->tvx1 = SiS6326GetTVReg(pScrn,0x3a);
-    pSiS->tvx1 |= ((SiS6326GetTVReg(pScrn,0x3c) & 0x0f) << 8);
-    pSiS->tvx2 = SiS6326GetTVReg(pScrn,0x26);
-    pSiS->tvx2 |= ((SiS6326GetTVReg(pScrn,0x27) & 0xf0) << 4);
-    pSiS->tvx3 = SiS6326GetTVReg(pScrn,0x12);
-    pSiS->tvx3 |= ((SiS6326GetTVReg(pScrn,0x13) & 0xC0) << 2);
-    pSiS->tvy1 = SiS6326GetTVReg(pScrn,0x11);
-    pSiS->tvy1 |= ((SiS6326GetTVReg(pScrn,0x13) & 0x30) << 4);
-
-    /* Handle TVPosOffset options (BEFORE switching on TV) */
-    if((val = pSiS->tvxpos) != 0) {
-       SiS_SetTVxposoffset(pScrn, val);
-    }
-    if((val = pSiS->tvypos) != 0) {
-       SiS_SetTVyposoffset(pScrn, val);
-    }
-
-    /* Switch on TV output. This is rather complicated, but
-     * if we don't do it, TV output will flicker terribly.
-     */
-    if(pSiS->SiS6326Flags & SIS6326_TVON) {
-       orSISIDXREG(SISSR, 0x01, 0x20);
-       tmp = SiS6326GetTVReg(pScrn,0x00);
-       tmp &= ~0x04;
-       while(!(inSISREG(SISINPSTAT) & 0x08));    /* Wait while NOT vb */
-       SiS6326SetTVReg(pScrn,0x00,tmp);
-       for(val=0; val < 2; val++) {
-         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
-         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
-       }
-       SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
-       tmp = inSISREG(SISINPSTAT);
-       outSISREG(SISAR, 0x20);
-       tmp = inSISREG(SISINPSTAT);
-       while(inSISREG(SISINPSTAT) & 0x01);
-       while(!(inSISREG(SISINPSTAT) & 0x01));
-       andSISIDXREG(SISSR, 0x01, ~0x20);
-       for(val=0; val < 10; val++) {
-         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
-         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
-       }
-       andSISIDXREG(SISSR, 0x01, ~0x20);
-    }
-
-    tmp = SiS6326GetTVReg(pScrn,0x00);
-    if(!(tmp & 0x04)) return;
-
-    /* Apply TV settings given by options */
-    if((val = pSiS->sistvantiflicker) != -1) {
-       SiS_SetSIS6326TVantiflicker(pScrn, val);
-    }
-    if((val = pSiS->sis6326enableyfilter) != -1) {
-       SiS_SetSIS6326TVenableyfilter(pScrn, val);
-    }
-    if((val = pSiS->sis6326yfilterstrong) != -1) {
-       SiS_SetSIS6326TVyfilterstrong(pScrn, val);
-    }
-
-}
-
-/* Check if video bridge is in slave mode */
-Bool
-SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    UChar  usScrP1_00;
-
-    if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE)) return FALSE;
-
-    inSISIDXREG(SISPART1,0x00,usScrP1_00);
-    if( ((pSiS->VGAEngine == SIS_300_VGA) && (usScrP1_00 & 0xa0) == 0x20) ||
-        ((pSiS->VGAEngine == SIS_315_VGA) && (usScrP1_00 & 0x50) == 0x10) ) {
-       return TRUE;
-    }
-
-    return FALSE;
-}
-
-/* Build a list of the VESA modes the BIOS reports as valid */
-static void
-SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    int i = 0;
-
-    while(vbe->VideoModePtr[i] != 0xffff) {
-       sisModeInfoPtr m;
-       VbeModeInfoBlock *mode;
-       int id = vbe->VideoModePtr[i++];
-
-       if((mode = VBEGetModeInfo(pVbe, id)) == NULL) {
-	  continue;
-       }
-
-       m = xnfcalloc(sizeof(sisModeInfoRec), 1);
-       if(!m) {
-	  VBEFreeModeInfo(mode);
-	  continue;
-       }
-       m->width = mode->XResolution;
-       m->height = mode->YResolution;
-       m->bpp = mode->BitsPerPixel;
-       m->n = id;
-       m->next = pSiS->SISVESAModeList;
-
-       pSiS->SISVESAModeList = m;
-
-       VBEFreeModeInfo(mode);
-
-       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-	   "VESA BIOS supports mode number 0x%x: %ix%i (%i bpp)\n",
-	   m->n, m->width, m->height, m->bpp);
-    }
-}
-
-/* Get VESA mode number from given resolution/depth */
-static UShort
-SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    sisModeInfoPtr m = pSiS->SISVESAModeList;
-    UShort i = (pScrn->bitsPerPixel+7)/8 - 1;
-    UShort ModeNumber = 0;
-    int j;
-
-    while(m) {
-       if( (pScrn->bitsPerPixel == m->bpp) &&
-	   (mode->HDisplay == m->width)    &&
-	   (mode->VDisplay == m->height) )
-	  return m->n;
-       m = m->next;
-    }
-
-    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-        "No valid VESA BIOS mode found for %dx%d (%d bpp)\n",
-        mode->HDisplay, mode->VDisplay, pScrn->bitsPerPixel);
-
-    if(!pSiS->ROM661New) {  /* VESA numbers changed! */
-       j = 0;
-       while(VESAModeIndices[j] != 9999) {
-          if( (mode->HDisplay == VESAModeIndices[j]) &&
-	      (mode->VDisplay == VESAModeIndices[j+1]) ) {
-	     ModeNumber = VESAModeIndices[j + 2 + i];
-	     break;
-          }
-          j += 6;
-       }
-
-       if(!ModeNumber) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-	      "No valid mode found for %dx%dx%d in built-in table either.\n",
-	      mode->HDisplay, mode->VDisplay, pScrn->bitsPerPixel);
-       }
-    }
-
-    return(ModeNumber);
-}
-
-UShort
-SiS_GetModeNumber(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;
-   BOOLEAN FSTN = pSiS->FSTN ? TRUE : FALSE;
-
-#ifdef SISDUALHEAD
-   if(pSiS->DualHeadMode && pSiS->SecondHead) FSTN = FALSE;
-#endif
-
-   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
-			i, FSTN, pSiS->LCDwidth, pSiS->LCDheight));
-}
-
-static Bool
-SiSValidLCDUserMode(SISPtr pSiS, unsigned int VBFlags, DisplayModePtr mode, Bool isforlcda)
-{
-   if(mode->Flags & V_INTERLACE) return FALSE;
-
-   if(mode->HDisplay > 2048) return FALSE;
-   if(mode->VDisplay > 1536) return FALSE;
-
-   if(pSiS->VBFlags2 & VB2_LCD162MHZBRIDGE) {
-      if(mode->Clock > 162500) return FALSE;
-#ifdef VB_FORBID_CRT2LCD_OVER_1600
-      if(!isforlcda) {
-         if(mode->HDisplay > 1600) return FALSE;
-      }
-#endif
-   } else { /* 301, 301B, 302B (no LCDA!) */
-      if(mode->Clock > 130000)  return FALSE;
-      if(mode->Clock > 111000) {
-         xf86DrvMsg(pSiS->pScrn->scrnIndex, X_WARNING,
-	 	"WARNING: Mode clock beyond video bridge specs (%dMHz). Hardware damage might occure.\n",
-		mode->Clock / 1000);
-      }
-      if(mode->HDisplay > 1600) return FALSE;
-      if(mode->VDisplay > 1024) return FALSE;
-   }
-
-   return TRUE;
-}
-
-static Bool
-SiSValidVGA2UserMode(SISPtr pSiS, unsigned int VBFlags, DisplayModePtr mode)
-{
-   if(mode->Flags & V_INTERLACE) return FALSE;
-
-   if(mode->HDisplay > 2048) return FALSE;
-   if(mode->VDisplay > 1536) return FALSE;
-
-   if(pSiS->VBFlags2 & VB2_RAMDAC202MHZBRIDGE) {
-      if(mode->Clock > 203000) return FALSE;
-   } else if(pSiS->VBFlags2 & VB2_30xBLV) {
-      if(mode->Clock > 162500) return FALSE;
-   } else {
-      if(mode->Clock > 135500) return FALSE;
-   }
-
-   return TRUE;
-}
-
-UShort
-SiS_CheckModeCRT1(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags, Bool havecustommodes)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;
-   int j;
-
-   if(!(VBFlags & CRT1_LCDA)) {
-
-      if((havecustommodes) && (!(mode->type & M_T_DEFAULT))) {
-         return 0xfe;
-      }
-
-   } else if(pSiS->VBFlags2 & VB2_SISTMDSLCDABRIDGE) {
-
-      if(pSiS->ChipType < SIS_661) {  /* < 661 only? */
-         if(!(mode->type & M_T_DEFAULT)) {
-            if(mode->HTotal > 2055) return 0;
-	    /* (Default mode will be caught in mode switching code) */
-	 }
-      }
-
-      if(pSiS->SiS_Pr->CP_HaveCustomData) {
-         for(j=0; j<7; j++) {
-            if((pSiS->SiS_Pr->CP_DataValid[j]) &&
-               (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
-               (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
-               (mode->type & M_T_BUILTIN))
-               return 0xfe;
-	 }
-      }
-
-      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
-         return 0xfe;
-
-      if((havecustommodes) &&
-         (pSiS->LCDwidth)  &&	/* = test if LCD present */
-         (!(mode->type & M_T_DEFAULT)) &&
-	 (SiSValidLCDUserMode(pSiS, VBFlags, mode, TRUE)))
-         return 0xfe;
-
-      if((mode->HDisplay > pSiS->LCDwidth) ||
-         (mode->VDisplay > pSiS->LCDheight)) {
-	 return 0;
-      }
-
-   } else {
-
-      if((mode->HDisplay > pSiS->LCDwidth) ||
-         (mode->VDisplay > pSiS->LCDheight)) {
-	 return 0;
-      }
-
-   }
-
-   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
-   			i, pSiS->FSTN, pSiS->LCDwidth, pSiS->LCDheight));
-}
-
-UShort
-SiS_CheckModeCRT2(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags, Bool havecustommodes)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;
-   UShort ModeIndex = 0;
-   int    j;
-
-#ifdef TWDEBUG
-   xf86DrvMsg(0, X_INFO, "Inside CheckCalcModeIndex (VBFlags %lx, mode %dx%d)\n",
-	VBFlags,mode->HDisplay, mode->VDisplay);
-#endif
-
-   if(VBFlags & CRT2_LCD) {			/* CRT2 is LCD */
-
-      if((pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) && (!(pSiS->VBFlags2 & VB2_30xBDH))) {
-
-         if(pSiS->SiS_Pr->CP_HaveCustomData) {
-            for(j=0; j<7; j++) {
-               if((pSiS->SiS_Pr->CP_DataValid[j]) &&
-                  (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
-                  (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
-#ifdef VB_FORBID_CRT2LCD_OVER_1600
-		  (mode->HDisplay <= 1600) 			   &&
-#endif
-                  (mode->type & M_T_BUILTIN))
-                  return 0xfe;
-	    }
-         }
-
-	 /* All plasma modes have HDisplay <= 1600 */
-         if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
-            return 0xfe;
-
-         if((havecustommodes) &&
-            (pSiS->LCDwidth)  &&	/* = test if LCD present */
-	    (!(mode->type & M_T_DEFAULT)) &&
-	    (SiSValidLCDUserMode(pSiS, VBFlags, mode, FALSE)))
-            return 0xfe;
-
-      }
-
-      if( ((mode->HDisplay <= pSiS->LCDwidth) &&
-           (mode->VDisplay <= pSiS->LCDheight)) ||
-	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL848) &&
-	   (((mode->HDisplay == 1360) && (mode->HDisplay == 768)) ||
-	    ((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
-	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ||
-	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL856) &&
-	   (((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
-	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ) {
-
-	 ModeIndex = SiS_GetModeID_LCD(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
-				pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight,
-				pSiS->VBFlags2);
-
-      }
-
-   } else if(VBFlags & CRT2_TV) {		/* CRT2 is TV */
-
-      ModeIndex = SiS_GetModeID_TV(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
-					pSiS->VBFlags2);
-
-   } else if(VBFlags & CRT2_VGA) {		/* CRT2 is VGA2 */
-
-      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
-	 return 0xfe;
-
-      if((havecustommodes) &&
-	 (!(mode->type & M_T_DEFAULT)) &&
-	 (SiSValidVGA2UserMode(pSiS, VBFlags, mode)))
-         return 0xfe;
-
-      ModeIndex = SiS_GetModeID_VGA2(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
-					pSiS->VBFlags2);
-
-   } else {					/* no CRT2 */
-
-      /* Return a valid mode number */
-      ModeIndex = 0xfe;
-
-   }
-
-   return(ModeIndex);
-}
-
-/* Calculate the vertical refresh rate from a mode */
-float
-SiSCalcVRate(DisplayModePtr mode)
-{
-   float hsync, refresh = 0;
-
-   if(mode->HSync > 0.0)
-       	hsync = mode->HSync;
-   else if(mode->HTotal > 0)
-       	hsync = (float)mode->Clock / (float)mode->HTotal;
-   else
-       	hsync = 0.0;
-
-   if(mode->VTotal > 0)
-       	refresh = hsync * 1000.0 / mode->VTotal;
-
-   if(mode->Flags & V_INTERLACE)
-       	refresh *= 2.0;
-
-   if(mode->Flags & V_DBLSCAN)
-       	refresh /= 2.0;
-
-   if(mode->VScan > 1)
-        refresh /= mode->VScan;
-
-   if(mode->VRefresh > 0.0)
-	refresh = mode->VRefresh;
-
-   if(hsync == 0.0 || refresh == 0.0) return 0.0;
-
-   return refresh;
-}
-
-/* Calculate CR33 (rate index) for CRT1.
- * Calculation is done using currentmode, therefore it is
- * recommended to set VertRefresh and HorizSync to correct
- * values in config file.
- */
-UChar
-SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode)
-{
-   SISPtr  pSiS = SISPTR(pScrn);
-   int     i = 0, irefresh;
-   UShort  xres = mode->HDisplay;
-   UShort  yres = mode->VDisplay;
-   UChar   index, defindex;
-   Bool    checksis730 = FALSE;
-
-   defindex = (xres == 800 || xres == 1024 || xres == 1280) ? 0x02 : 0x01;
-
-   irefresh = (int)SiSCalcVRate(mode);
-   if(!irefresh) return defindex;
-
-   /* SiS730 has troubles on CRT2 if CRT1 is at 32bpp */
-   if( (pSiS->ChipType == SIS_730)        &&
-       (pSiS->VBFlags2 & VB2_VIDEOBRIDGE) &&
-       (pSiS->CurrentLayout.bitsPerPixel == 32) ) {
-#ifdef SISDUALHEAD
-      if(pSiS->DualHeadMode) {
-         if(pSiS->SecondHead) {
-	    checksis730 = TRUE;
-	 }
-      } else
-#endif
-      if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {
-         checksis730 = TRUE;
-      }
-   }
-
-#ifdef TWDEBUG
-   xf86DrvMsg(0, X_INFO, "Debug: CalcVRate returned %d\n", irefresh);
-#endif
-
-   /* We need the REAL refresh rate here */
-   if(mode->Flags & V_INTERLACE) irefresh /= 2;
-
-   /* Do not multiply by 2 when DBLSCAN! */
-
-#ifdef TWDEBUG
-   xf86DrvMsg(0, X_INFO, "Debug: Rate after correction = %d\n", irefresh);
-#endif
-
-   index = 0;
-   while((sisx_vrate[i].idx != 0) && (sisx_vrate[i].xres <= xres)) {
-      if((sisx_vrate[i].xres == xres) && (sisx_vrate[i].yres == yres)) {
-	 if((checksis730 == FALSE) || (sisx_vrate[i].SiS730valid32bpp == TRUE)) {
-	    if(sisx_vrate[i].refresh == irefresh) {
-	       index = sisx_vrate[i].idx;
-	       break;
-	    } else if(sisx_vrate[i].refresh > irefresh) {
-	       if((sisx_vrate[i].refresh - irefresh) <= 3) {
-		  index = sisx_vrate[i].idx;
-	       } else if( ((checksis730 == FALSE) || (sisx_vrate[i - 1].SiS730valid32bpp == TRUE)) &&
-		          ((irefresh - sisx_vrate[i - 1].refresh) <=  2) &&
-			  (sisx_vrate[i].idx != 1) ) {
-		  index = sisx_vrate[i - 1].idx;
-	       }
-	       break;
-	    } else if((irefresh - sisx_vrate[i].refresh) <= 2) {
-	       index = sisx_vrate[i].idx;
-	       break;
-	    }
-	 }
-      }
-      i++;
-   }
-
-   if(index > 0) return index;
-   else          return defindex;
-}
-
-void
-SISWaitRetraceCRT1(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int    watchdog;
-   UChar  temp;
-
-   inSISIDXREG(SISCR,0x17,temp);
-   if(!(temp & 0x80)) return;
-
-   inSISIDXREG(SISSR,0x1f,temp);
-   if(temp & 0xc0) return;
-
-   watchdog = 65536;
-   while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
-   watchdog = 65536;
-   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
-}
-
-void
-SISWaitRetraceCRT2(ScrnInfoPtr pScrn)
-{
-   SISPtr pSiS = SISPTR(pScrn);
-   int    watchdog;
-   UChar  temp, reg;
-
-   if(SiSBridgeIsInSlaveMode(pScrn)) {
-      SISWaitRetraceCRT1(pScrn);
-      return;
-   }
-
-   switch(pSiS->VGAEngine) {
-   case SIS_300_VGA:
-   	reg = 0x25;
-	break;
-   case SIS_315_VGA:
-   	reg = 0x30;
-	break;
-   default:
-        return;
-   }
-
-   watchdog = 65536;
-   do {
-   	inSISIDXREG(SISPART1, reg, temp);
-	if(!(temp & 0x02)) break;
-   } while(--watchdog);
-   watchdog = 65536;
-   do {
-   	inSISIDXREG(SISPART1, reg, temp);
-	if(temp & 0x02) break;
-   } while(--watchdog);
-}
-
-static void
-SISWaitVBRetrace(ScrnInfoPtr pScrn)
-{
-   SISPtr  pSiS = SISPTR(pScrn);
-
-   if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-#ifdef SISDUALHEAD
-      if(pSiS->DualHeadMode) {
-   	 if(pSiS->SecondHead)
-	    SISWaitRetraceCRT1(pScrn);
-         else
-	    SISWaitRetraceCRT2(pScrn);
-      } else {
-#endif
-	 if(pSiS->VBFlags & DISPTYPE_DISP1) {
-	    SISWaitRetraceCRT1(pScrn);
-	 }
-	 if(pSiS->VBFlags & DISPTYPE_DISP2) {
-	    if(!(SiSBridgeIsInSlaveMode(pScrn))) {
-	       SISWaitRetraceCRT2(pScrn);
-	    }
-	 }
-#ifdef SISDUALHEAD
-      }
-#endif
-   } else {
-      SISWaitRetraceCRT1(pScrn);
-   }
-}
+/*********************************************************/
+/*                        Helpers                        */
+/*********************************************************/
 
 #define MODEID_OFF 0x449
 
@@ -14083,3 +11129,328 @@ sisRestoreExtRegisterLock(SISPtr pSiS, UChar reg1, UChar reg2)
 #endif
 }
 
+/**************************************************************************/
+/**                             SISPMEvent   :: Ivans                    **/
+/**************************************************************************/
+static Bool
+SISHotkeySwitchCRT2Status(ScrnInfoPtr pScrn,ULong newvbflags,ULong newvbflags3)
+{
+   SISPtr pSiS = SISPTR(pScrn);	
+   Bool hcm = pSiS->HaveCustomModes;
+   DisplayModePtr mode = pScrn->currentMode;
+
+   if((pSiS->VGAEngine != SIS_300_VGA)&&(pSiS->VGAEngine != SIS_315_VGA))
+   return FALSE;
+
+   if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE))
+   return FALSE;
+   
+   if(pSiS->DualHeadMode)
+   return FALSE;
+
+   if(pSiS->MergedFB)
+   return FALSE;
+
+   newvbflags &= CRT2_ENABLE;
+   newvbflags |= pSiS->VBFlags & ~CRT2_ENABLE;
+
+   newvbflags3 &= VB3_CRT1_TYPE;
+   newvbflags3 |= pSiS->VBFlags3 & ~VB3_CRT1_TYPE;
+
+   if((!(newvbflags & CRT2_ENABLE)) && (!newvbflags & DISPTYPE_CRT1))
+   {
+	  xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"CRT2 can't be switched off while CRT1 is off.\n");
+	   return FALSE;
+   }
+   if(newvbflags & (CRT2_LCD|CRT2_VGA))
+   {
+          newvbflags &= ~CRT1_LCDA;
+   }
+
+   newvbflags &= ~(SINGLE_MODE|MIRROR_MODE);
+   if((newvbflags & DISPTYPE_CRT1)&&(newvbflags & CRT2_ENABLE))
+   {
+          newvbflags |= MIRROR_MODE; 
+   }	   
+   else
+   {
+          newvbflags |= SINGLE_MODE; 
+   }
+  /* while(mode->HDisplay != 1024)
+   {
+	   mode = mode->next;
+   }
+   if(mode->HDisplay == 1024)
+   {
+      xf86DrvMsg(0,X_INFO,"virtualX=%d,virtualY=%d,pitch=%d.\n",pScrn->virtualX,pScrn->virtualY,pScrn->displayWidth);
+   }*/
+   
+   (*pSiS->SyncAccel)(pScrn);
+
+   pSiS->VBFlags = pSiS->VBFlags_backup = newvbflags;
+   pSiS->VBFlags3 = pSiS->VBFlags_backup3 = newvbflags3;  
+ 
+   pSiS->skipswitchcheck = TRUE;
+   if(!((*pScrn->SwitchMode)(pScrn->scrnIndex,pScrn->currentMode,0)))
+   {
+          pSiS->skipswitchcheck = FALSE;
+	  return FALSE;
+   }
+   pSiS->skipswitchcheck = FALSE;
+
+   /*xf86DrvMsg(0,X_INFO,"frameX0=%d, frameY0=%d.\n",pScrn->frameX0,pScrn->frameY0);*/
+
+   SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0,0);
+
+   return TRUE;
+
+}
+
+/**************************************************************************/
+static Bool
+SISHotkeySwitchCRT1Status(ScrnInfoPtr pScrn, int onoff) 
+{
+  SISPtr pSiS = SISPTR(pScrn);
+  DisplayModePtr mode = pScrn->currentMode;
+  ULong vbflags = pSiS->VBFlags;
+  ULong vbflags3 = pSiS->VBFlags3;
+  int crt1off;/*onoff: 0=OFF,1=ON(VGA),2=ON(LCDA),3=CRT1_LCD, 2 AND 3 not support.*/
+
+  if((pSiS->VGAEngine != SIS_300_VGA)&&(pSiS->VGAEngine != SIS_315_VGA))
+     return FALSE;
+
+  if(pSiS->DualHeadMode)
+     return FALSE;
+
+  if((!onoff) && (!(vbflags & CRT2_ENABLE)))
+     return FALSE; 
+
+  if((onoff==2)|(onoff==3))
+     return FALSE;
+
+  if(pSiS->MergedFB)
+     return FALSE; /*now we not support mergedfb switch on/off the CRT1.*/
+
+  vbflags &= ~(DISPTYPE_CRT1 | SINGLE_MODE | MIRROR_MODE | CRT1_LCDA);
+  vbflags3 &= ~(VB3_CRT1_TV | VB3_CRT1_LCD | VB3_CRT1_VGA); 
+  crt1off = 1;
+  
+  if(onoff > 0)
+  {
+          if(onoff == 1)
+	  {
+		  vbflags |= DISPTYPE_CRT1;
+	          crt1off = 0;
+	  }
+          else
+	  {
+		  vbflags3 |= VB3_CRT1_VGA;
+	  }
+	  if(vbflags & CRT2_ENABLE) vbflags |= MIRROR_MODE;
+	  else vbflags |= SINGLE_MODE;
+  }
+  else
+  {
+	  vbflags |= SINGLE_MODE;
+  }
+
+  pSiS->CRT1off = crt1off;
+  pSiS->VBFlags = pSiS->VBFlags_backup = vbflags;
+  pSiS->VBFlags3 = pSiS->VBFlags_backup3 = vbflags3;
+
+ (*pSiS->SyncAccel)(pScrn); 
+  
+ pSiS->skipswitchcheck = TRUE;
+ if(!((*pScrn->SwitchMode)(pScrn->scrnIndex,pScrn->currentMode,0)))
+ {
+       pSiS->skipswitchcheck = FALSE;
+       return FALSE;
+ }
+ pSiS->skipswitchcheck = FALSE;
+
+ SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0,0);
+ 
+ return TRUE;
+}
+/**************************************************************************/
+static Bool
+SISHotkeySwitchMode(ScrnInfoPtr pScrn, Bool adjust)
+{
+   pointer hkeymode;
+   SISPtr pSiS = SISPTR(pScrn);
+   ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
+   int dotClock;
+   int dotclock=65146;
+   int hdisplay=1024;
+
+   if(!VidModeGetCurrentModeline(pScrn->scrnIndex,&hkeymode,&dotClock))
+   return FALSE;
+          
+   if(!VidModeGetFirstModeline(pScrn->scrnIndex,&hkeymode,&dotClock))
+   return FALSE;
+  
+   do{   /* dotclock and hdisplay must given by parameters of 1024*768 */
+       if((VidModeGetDotClock(pScrn->scrnIndex,dotclock)==dotClock)&&(VidModeGetModeValue(hkeymode,0)==hdisplay)) 
+       {
+             pScrn->virtualX = 1024;
+	     pScrn->virtualY = 768;
+	    /* pSiS->scrnPitch = 4096;
+	     pSiS->scrnOffset = 4096;*/
+	     pScrn->zoomLocked=0;/* try for xf86ZoomViewport.*/
+	     pScrn->display->virtualX = 1024;
+	     pScrn->display->virtualY = 768;   
+	    /* xf86RandRSetNewVirtualAndDimensions(pScreen,1024,768,0,0,0);*/  
+	     if(!VidModeSwitchMode(pScrn->scrnIndex,hkeymode))
+             { 
+	            return FALSE;
+	     }	
+            /* xf86ZoomViewport(pScrn,1);*/	     
+       }
+   
+   } while(VidModeGetNextModeline(pScrn->scrnIndex,&hkeymode,&dotClock));   
+
+   xf86DrvMsg(0,X_INFO,"[Layout]:(display)scrnPitch=%d,(data)scrnOffset=%d.\n",pSiS->scrnPitch,pSiS->scrnOffset);
+   
+   xf86DrvMsg(0,X_INFO,"[Layout]:displayWidth=%d,displayHeight=%d.\n",pSiS->CurrentLayout.displayWidth,pSiS->CurrentLayout.displayHeight); 
+  
+   
+               xf86ZoomViewport(pScreen,1);
+
+	       SISAdjustFrame(pScrn->scrnIndex,0,0,0);
+
+   
+   return TRUE;
+}
+
+
+/**************************************************************************/
+static Bool
+SISPMEvent(int scrnIndex, pmEvent event, Bool undo)
+{
+  ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+  SISPtr pSiS = SISPTR(pScrn);
+  unsigned char hotkeyflag = 0;/*check BIOS flag.*/
+  unsigned char checkflag = 0;/*just for test using.*/
+
+  xf86DrvMsg(0,X_INFO,"Enter VT, event %d, undo: %d.\n",event,undo);
+ 
+  switch(event)
+  {
+         case XF86_APM_SYS_SUSPEND:
+         case XF86_APM_CRITICAL_SUSPEND: /*do we want to delay a critical suspend?*/
+         case XF86_APM_USER_SUSPEND:
+         case XF86_APM_SYS_STANDBY:
+         case XF86_APM_USER_STANDBY:
+         {        
+              xf86DrvMsg(0,X_INFO,"PM_EVENT:event=%d,undo=%d.\n",event,undo);		 
+		 if (!undo && !pSiS->suspended) {
+	               pScrn->LeaveVT(scrnIndex, 0);
+	               pSiS->suspended = TRUE;
+	               sleep(0);
+                   } 
+		     else if (undo && pSiS->suspended) {
+	            sleep(0);
+	            pScrn->EnterVT(scrnIndex, 0);
+	            pSiS->suspended = FALSE;
+                  }
+	   }
+      break;
+
+      case XF86_APM_STANDBY_RESUME:
+      case XF86_APM_NORMAL_RESUME:
+      case XF86_APM_CRITICAL_RESUME:
+      {
+	  	  if (pSiS->suspended) {
+	        sleep(0);
+	        pScrn->EnterVT(scrnIndex, 0);
+	        pSiS->suspended = FALSE;
+	        SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
+               }
+	 }
+      break;
+	  
+	case XF86_APM_CAPABILITY_CHANGED:
+      {     
+	                inSISIDXREG(SISCR,0x3d,hotkeyflag);/*check device switch flag from BIOS CR 0x3d bit[2].*/
+                        
+			
+			if(hotkeyflag & 0x04)
+			{	
+						
+			SISCRT1PreInit(pScrn); /*redetecting CRT1, pSiS->CRT1detected will update.*/
+		  
+			switch(pSiS->Hkey_Device_Switch_State) /*checking current stste for next state.*/
+			{ 
+				case LCD_only:
+				{         	
+                                      if( pSiS->CRT1Detected )
+				      {
+				  	      SISHotkeySwitchCRT1Status(pScrn,1); /*open VGA to mirror mode.*/
+					      pSiS->Hkey_Device_Switch_State = LCD_VGA_mirror;
+					      xf86DrvMsg(0,X_INFO,"[Device Switch]LCD->Mirror.(current Mirror mode.)\n");
+					      /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+				      } 
+			              else
+				      {
+				            /* SISHotkeySwitchCRT1Status(pScrn,0);*//*close CRT1*/ 
+					      SISHotkeySwitchCRT2Status(pScrn,0x20080002,0x0); /*redetect LCD.*/	     
+					      pSiS->Hkey_Device_Switch_State = LCD_only;
+                          xf86DrvMsg(0,X_INFO,"[Device Switch]LCD->LCD.(current LCD ONLY.)\n");
+					      /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+
+				      }
+				}	      
+				break;	
+			       
+				case LCD_VGA_mirror:
+				{      
+                                      if( pSiS->CRT1Detected )
+				      { 
+				              SISHotkeySwitchCRT2Status(pScrn,0x40080000,0x0); /*close LCD.*/
+                                              pSiS->Hkey_Device_Switch_State = VGA_only;
+					      xf86DrvMsg(0,X_INFO,"[Device Switch]Mirror->VGA.(current VGA ONLY.)\n");
+					      /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+
+				      }
+			              else
+				      {
+				              SISHotkeySwitchCRT1Status(pScrn,0); /*close VGA.*/
+                                              pSiS->Hkey_Device_Switch_State = LCD_only;
+					      xf86DrvMsg(0,X_INFO,"[Device Swiatach]Mirror->LCD.(current LCD ONLY.)\n");
+					      /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+
+				      }
+				}	      
+				break;
+
+				case VGA_only:
+				{  /*SISHotkeySwitchCRT1Status(pScrn,0);*//*close VGA*/
+                                      SISHotkeySwitchCRT2Status(pScrn,0x20000002,0x0); /*open LCD*/
+				      SISHotkeySwitchCRT1Status(pScrn,0); /*close VGA*/
+                                      pSiS->Hkey_Device_Switch_State = LCD_only;
+				      xf86DrvMsg(0,X_INFO,"[Device Swiatach]VGA->LCD.(current LCD ONLY.)\n");
+				      /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+				}
+				break;
+
+				default:
+				        xf86DrvMsg(0,X_INFO,"Unknow current hotkey DS state, Hkey do nothing.\n");
+			   }
+		           hotkeyflag &= 0xfb;/*clean hotkey flag.*/
+		           outSISIDXREG(SISCR,0x3d,hotkeyflag);
+		           inSISIDXREG(SISCR,0X3d,checkflag);	
+		     }/*hotkeyflag*/
+		     	
+	  }
+	  break;
+        
+	  default:
+          xf86DrvMsg(0,X_INFO,"SISPMEvent: Unknow Event %d is received.\n",event);
+  } 
+  return 1;/*TRUE*/
+}
+
+
+
+
+
diff --git a/src/sis_driver.h b/src/sis_driver.h
index 2f06228..73313cd 100644
--- a/src/sis_driver.h
+++ b/src/sis_driver.h
@@ -97,6 +97,7 @@ static const struct _sis_vrate {
 	{4, 1280, 1024,  85,  TRUE},
 	{1, 1360,  768,  60,  TRUE},
 	{1, 1400, 1050,  60,  TRUE}, {2, 1400, 1050,  75,  TRUE},
+	{1, 1440,  900,  60,  TRUE}, {2, 1440,  900,  75,  TRUE}, {3, 1440,  900,  85,  TRUE},
 	{1, 1600, 1200,  60,  TRUE}, {2, 1600, 1200,  65,  TRUE}, {3, 1600, 1200,  70,  TRUE},
 	{4, 1600, 1200,  75,  TRUE}, {5, 1600, 1200,  85,  TRUE}, {6, 1600, 1200, 100,  TRUE},
 	{7, 1600, 1200, 120,  TRUE},
@@ -133,7 +134,7 @@ static const chswtable mychswtable[] = {
 /*     These machines require special timing/handling
  */
 const customttable SiS_customttable[] = {
-        { SIS_630, "2.00.07", "09/27/2002-13:38:25",
+	{ SIS_630, "2.00.07", "09/27/2002-13:38:25",
 	  0x3240A8,
 	  { 0x220, 0x227, 0x228, 0x229, 0x0ee },
 	  {  0x01,  0xe3,  0x9a,  0x6a,  0xef },
@@ -254,6 +255,20 @@ const customttable SiS_customttable[] = {
 	  "AAEON", "AOP-8060", CUT_AOP8060, "AAEON_AOP_8060"
 	},
 #endif
+	{ SIS_550, "1.02.00", "08/14/2002-10:02:21",
+	  0x312201,
+	  { 0x9560, 0x9600, 0x9768, 0x9c1a, 0 },
+	  { 0x76,   0x84,   0xa7,   0x14,   0 },
+	  0, 0,
+	  "ICOP", "Vortex86-607x", CUT_ICOP550, "ICOP550"
+	},
+	{ SIS_550, "1.03.00", "06/25/2003-17:17:42",
+	  0x2c0600,
+	  { 0x7850, 0x78dc, 0x79e0, 0x7c9c, 0 },
+	  { 0x84,   0x84,   0xa7,   0x90,   0 },
+	  0, 0,
+	  "ICOP", "Vortex86-607x (2)", CUT_ICOP550_2, "ICOP550_2"
+	},
 	{ 4321, "", "",			/* never autodetected */
 	  0,
 	  { 0, 0, 0, 0, 0 },
@@ -672,818 +687,6 @@ static DisplayModeRec SiS6326SIS1600x1200_60Mode = {
 	0.0		/* VRefresh */
 };
 
-/*     TV scaling data for SiS video bridges
- */
-typedef struct _SiSTVVScale {
-        UShort ScaleVDE;
-	int sindex;
-	UShort RealVDE;
-	UShort reg[4];
-} MySiSTVVScale, *MySiSTVVScalePtr;
-
-static const MySiSTVVScale SiSTVVScale[] = {
-	{ 470, 3, 480,			/* NTSC 640x480 */
-	  { 893, 508, 0x004c, 0x008f }
-	},
-	{ 460, 2, 480,
-	  { 874, 513, 0x004c, 0x008f }
-	},
-	{ 450, 1, 480,
-	  { 855, 518, 0x004c, 0x008f }
-	},
-	{ 440, 0, 480,	/* default */
-	  { 836, 523, 0x004c, 0x008f }
-	},
-	{ 430, -1, 480,
-	  { 860, 528, 0x0050, 0x008f }
-	},
-	{ 420, -2, 480,
-	  { 840, 533, 0x0050, 0x008f }
-	},
-	{ 410, -3, 480,
-	  { 820, 538, 0x0050, 0x008f }
-	},
-	{ 470, 3, 480,			/* NTSC 720x480 */
-	  { 893, 509, 0x004c, 0x008f }
-	},
-	{ 460, 2, 480,
-	  { 874, 514, 0x004c, 0x008f }
-	},
-	{ 450, 1, 480,
-	  { 855, 519, 0x004c, 0x008f }
-	},
-	{ 440, 0, 480,	/* default */
-	  { 836, 524, 0x004c, 0x008f }
-	},
-	{ 430, -1, 480,
-	  { 860, 529, 0x0050, 0x008f }
-	},
-	{ 420, -2, 480,
-	  { 840, 534, 0x0050, 0x008f }
-	},
-	{ 410, -3, 480,
-	  { 820, 539, 0x0050, 0x008f }
-	},
-	{ 470, 3, 600,			/* NTSC 800x600 */
-	  { 1081, 628, 0x0073, 0x008f }
-	},
-	{ 460, 2, 600,
-	  { 1058, 633, 0x0073, 0x008f }
-	},
-	{ 450, 1, 600,
-	  { 1044, 638, 0x0074, 0x008f }
-	},
-	{ 440, 0, 600,	/* default */
-	  { 1056, 643, 0x0078, 0x008f }
-	},
-	{ 430, -1, 600,
-	  { 1032, 648, 0x0078, 0x008f }
-	},
-	{ 420, -2, 600,
-	  { 1008, 653, 0x0078, 0x008f }
-	},
-	{ 410, -3, 600,
-	  { 1066, 658, 0x0082, 0x008f }
-	},
-	{ 560, 3, 480,			/* PAL 640x480 */
-	  { 882, 513, 0x0007, 0x0010 }
-	},
-	{ 550, 2, 480,
-	  { 900, 518, 0x0005, 0x000b }
-	},
-	{ 540, 1, 480,
-	  { 864, 523, 0x0004, 0x0009 }
-	},
-	{ 530, 0, 480,	/* default */
-	  { 848, 528, 0x0004, 0x0009 }
-	},
-	{ 520, -1, 480,
-	  { 832, 533, 0x0004, 0x0009 }
-	},
-	{ 510, -2, 480,
-	  { 918, 538, 0x0001, 0x0002 }
-	},
-	{ 500, -3, 480,
-	  { 900, 543, 0x0001, 0x0002 }
-	},
-	{ 560, 2, 576,			/* PAL 720x576 */
-	  { 960, 610, 0x0004, 0x0007 }
-	},
-	{ 550, 1, 576,
-	  { 990, 614, 0x0003, 0x0005 }
-	},
-	{ 540, 0, 576,	/* default */
-	  { 1080, 620, 0x0002, 0x0003 }
-	},
-	{ 530, -1, 576,
-	  { 1060, 625, 0x8002, 0x0003 }
-	},
-	{ 520, -2, 576,
-	  { 1040, 630, 0x0002, 0x0003 }
-	},
-	{ 510, -3, 576,
-	  { 1020, 635, 0x0002, 0x0003 }
-	},
-	{ 500, -4, 576,
-	  { 1000, 640, 0x0002, 0x0003 }
-	},
-	{ 560, 3, 600,			/* PAL 800x600 */
-	  { 1152, 633, 0x0005, 0x0007 }
-	},
-	{ 550, 2, 600,
-	  { 1100, 638, 0x0019, 0x0024 }
-	},
-	{ 540, 1, 600,
-	  { 1080, 643, 0x0019, 0x0024 }
-	},
-	{ 530, 0, 600,	/* default */
-	  { 1060, 648, 0x0019, 0x0024 }
-	},
-	{ 520, -1, 600,
-	  { 1040, 653, 0x0019, 0x0024 }
-	},
-	{ 510, -2, 600,
-	  { 1020, 658, 0x0019, 0x0024 }
-	},
-	{ 500, -3, 600,
-	  { 1080, 663, 0x0003, 0x0004 }
-	},
-	{ 720, 3, 480,			/* 750p 640x480 (42) */
-          { 1238, 500, 0x0001, 0x0002 }
-        },
-        { 693, 2, 480,
-          { 1191, 519, 0x0001, 0x0002 }
-        },
-        { 667, 1, 480,
-          { 1146, 540, 0x0001, 0x0002 }
-        },
-        { 640, 0, 480,
-          { 1100, 563, 0x0001, 0x0002 }
-        },
-        { 613, -1, 480,
-          { 1054, 587, 0x0001, 0x0002 }
-        },
-        { 587, -2, 480,
-          { 1009, 613, 0x0001, 0x0002 }
-        },
-        { 560, -3, 480,
-          { 963, 643, 0x0001, 0x0002 }
-        },
-	{ 720, 3, 480,			/* 750p 720x480 (49) */
-          { 1238, 500, 0x0001, 0x0002 }
-        },
-        { 693, 2, 480,
-          { 1191, 519, 0x0001, 0x0002 }
-        },
-        { 667, 1, 480,
-          { 1146, 540, 0x0001, 0x0002 }
-        },
-        { 640, 0, 480,
-          { 1100, 563, 0x0001, 0x0002 }
-        },
-        { 613, -1, 480,
-          { 1054, 587, 0x0001, 0x0002 }
-        },
-        { 587, -2, 480,
-          { 1009, 613, 0x0001, 0x0002 }
-        },
-        { 560, -3, 480,
-          { 963, 643, 0x0001, 0x0002 }
-        },
-	{ 720, 3, 576,			/* 750p 720/768x576 (56) */
-          { 1238, 600, 0x0003, 0x0005 }
-        },
-        { 693, 2, 576,
-          { 1191, 623, 0x0003, 0x0005 }
-        },
-        { 667, 1, 576,
-          { 1146, 648, 0x0003, 0x0005 }
-        },
-        { 640, 0, 576,
-          { 1100, 675, 0x0003, 0x0005 }
-        },
-        { 613, -1, 576,
-          { 1054, 705, 0x0003, 0x0005 }
-        },
-        { 587, -2, 576,
-          { 1009, 736, 0x0003, 0x0005 }
-        },
-        { 560, -3, 576,
-          { 963, 771, 0x0003, 0x0005 }
-        },
-	{ 720, 3, 480,			/* 750p 800x480 (63) */
-          { 1238, 500, 0x0001, 0x0002 }
-        },
-        { 693, 2, 480,
-          { 1191, 519, 0x0001, 0x0002 }
-        },
-        { 667, 1, 480,
-          { 1146, 540, 0x0001, 0x0002 }
-        },
-        { 640, 0, 480,
-          { 1100, 563, 0x0001, 0x0002 }
-        },
-        { 613, -1, 480,
-          { 1054, 587, 0x0001, 0x0002 }
-        },
-        { 587, -2, 480,
-          { 1009, 613, 0x0001, 0x0002 }
-        },
-        { 560, -3, 480,
-          { 963, 643, 0x0001, 0x0002 }
-        },
-	{ 720, 3, 600,			/* 750p 800x600 (70) */
-          { 1320, 625, 0x0002, 0x0003 }
-        },
-        { 700, 2, 600,
-          { 1283, 643, 0x0002, 0x0003 }
-        },
-        { 680, 1, 600,
-          { 1247, 662, 0x0002, 0x0003 }
-        },
-        { 660, 0, 600,
-          { 1210, 682, 0x0002, 0x0003 }
-        },
-        { 640, -1, 600,
-          { 1173, 703, 0x0002, 0x0003 }
-        },
-        { 620, -2, 600,
-          { 1137, 726, 0x0002, 0x0003 }
-        },
-        { 600, -3, 600,
-          { 1100, 750, 0x0002, 0x0003 }
-        },
-	{ 720, 3, 576,			/* 750p 1024x576 (77) */
-          { 1238, 600, 0x0003, 0x0005 }
-        },
-        { 693, 2, 576,
-          { 1191, 623, 0x0003, 0x0005 }
-        },
-        { 667, 1, 576,
-          { 1146, 648, 0x0003, 0x0005 }
-        },
-        { 640, 0, 576,
-          { 1100, 675, 0x0003, 0x0005 }
-        },
-	{ 630, -1, 576,
-          { 1083, 686, 0x0003, 0x0005 }
-	},
-	{ 620, -2, 576,
-          { 1066, 697, 0x0003, 0x0005 }
-        },
-	{ 616, -3, 576,
-          { 1059, 701, 0x0003, 0x0005 }
-        },
-	{ 720, 3, 768,			/* 750p 1024x768 (84) */
-          { 1547, 800, 0x0001, 0x0001 }
-        },
-        { 693, 2, 768,
-          { 1489, 831, 0x0001, 0x0001 }
-        },
-        { 667, 1, 768,
-          { 1433, 864, 0x0001, 0x0001 }
-        },
-        { 640, 0, 768,
-          { 1375, 900, 0x0001, 0x0001 }
-        },
-        { 613, -1, 768,
-          { 1317, 940, 0x0001, 0x0001 }
-        },
-        { 587, -2, 768,
-          { 1261, 981, 0x0001, 0x0001 }
-        },
-        { 560, -3, 768,
-          { 1203, 1029, 0x0001, 0x0001 }
-        },
-#ifdef OLD1280720P
-	{ 720, 3, 720,			/* 750p 1280x720-old (91) */
-          { 1584, 750, 0x0018, 0x0019 }
-        },
-        { 707, 2, 720,
-          { 1555, 764, 0x0018, 0x0019 }
-        },
-        { 693, 1, 720,
-          { 1525, 779, 0x0018, 0x0019 }
-        },
-        { 680, 0, 720,
-          { 1496, 794, 0x0018, 0x0019 }
-        },
-        { 667, -1, 720,
-          { 1467, 810, 0x0018, 0x0019 }
-        },
-        { 653, -2, 720,
-          { 1437, 827, 0x0018, 0x0019 }
-        },
-        { 640, -3, 720,
-          { 1408, 844, 0x0018, 0x0019 }
-        },
-#endif
-#ifndef OLD1280720P
-	{ 720, 3, 720,			/* 750p 1280x720-new (91) */
-	  { 1650, 750, 0x0001, 0x0001 }
-	},
-	{ 720, 2, 720,
-	  { 1650, 750, 0x0001, 0x0001 }
-	},
-	{ 720, 1, 720,
-	  { 1650, 750, 0x0001, 0x0001 }
-	},
-	{ 720, 0, 720,
-	  { 1650, 750, 0x0001, 0x0001 }
-	},
-	{ 704, -1, 720,
-          { 1613, 767, 0x0001, 0x0001 }
-        },
-        { 688, -2, 720,
-          { 1577, 785, 0x0001, 0x0001 }
-        },
-        { 672, -3, 720,
-          { 1540, 804, 0x0001, 0x0001 }
-        },
-#endif
-	{ 1080, 3, 480,			/* 1080i 640x480 (98) */
-          { 945, 500, 0x8001, 0x0005 }
-        },
-        { 1040, 2, 480,
-          { 910, 519, 0x8001, 0x0005 }
-        },
-        { 1000, 1, 480,
-          { 875, 540, 0x8001, 0x0005 }
-        },
-        { 960, 0, 480,
-          { 840, 563, 0x8001, 0x0005 }
-        },
-        { 920, -1, 480,
-          { 805, 587, 0x8001, 0x0005 }
-        },
-        { 880, -2, 480,
-          { 770, 614, 0x8001, 0x0005 }
-        },
-        { 840, -3, 480,
-          { 735, 643, 0x8001, 0x0005 }
-        },
-	{ 1080, 3, 480,			/* 1080i 800x480 (105) */
-          { 1181, 500, 0x8001, 0x0004 }
-        },
-        { 1040, 2, 480,
-          { 1138, 519, 0x8001, 0x0004 }
-        },
-        { 1000, 1, 480,
-          { 1094, 540, 0x8001, 0x0004 }
-        },
-        { 960, 0, 480,
-          { 1050, 563, 0x8001, 0x0004 }
-        },
-        { 920, -1, 480,
-          { 1006, 587, 0x8001, 0x0004 }
-        },
-        { 880, -2, 480,
-          { 963, 614, 0x8001, 0x0004 }
-        },
-        { 840, -3, 480,
-          { 919, 643, 0x8001, 0x0004 }
-        },
-	{ 1080, 3, 600,			/* 1080i 800x600 (112) */
-          { 1181, 625, 0x8005, 0x0010 }
-        },
-        { 1040, 2, 600,
-          { 1138, 649, 0x8005, 0x0010 }
-        },
-        { 1000, 1, 600,
-          { 1094, 675, 0x8005, 0x0010 }
-        },
-        { 960, 0, 600,
-          { 1050, 703, 0x8005, 0x0010 }
-        },
-        { 920, -1, 600,
-          { 1006, 734, 0x8005, 0x0010 }
-        },
-        { 880, -2, 600,
-          { 963, 767, 0x8005, 0x0010 }
-        },
-        { 840, -3, 600,
-          { 919, 804, 0x8005, 0x0010 }
-        },
-	{ 1080, 3, 576,			/* 1080i 1024x576 (119) */
-          { 1575, 600, 0x0002, 0x0005 }
-        },
-        { 1040, 2, 576,
-          { 1517, 623, 0x0002, 0x0005 }
-        },
-        { 1000, 1, 576,
-          { 1458, 648, 0x0002, 0x0005 }
-        },
-        { 960, 0, 576,
-          { 1400, 675, 0x0002, 0x0005 }
-        },
-        { 920, -1, 576,
-          { 1342, 704, 0x0002, 0x0005 }
-        },
-        { 880, -2, 576,
-          { 1283, 736, 0x0002, 0x0005 }
-        },
-        { 840, -3, 576,
-          { 1225, 771, 0x0002, 0x0005 }
-        },
-	{ 1080, 3, 768,			/* 1080i 1024x768 (126) */
-          { 1418, 800, 0x000c, 0x0019 }
-        },
-        { 1040, 2, 768,
-          { 1365, 831, 0x000c, 0x0019 }
-        },
-        { 1000, 1, 768,
-          { 1313, 864, 0x000c, 0x0019 }
-        },
-        { 960, 0, 768,
-          { 1260, 900, 0x000c, 0x0019 }
-        },
-        { 920, -1, 768,
-          { 1208, 939, 0x000c, 0x0019 }
-        },
-        { 880, -2, 768,
-          { 1155, 982, 0x000c, 0x0019 }
-        },
-        { 840, -3, 768,
-          { 1103, 1029, 0x000c, 0x0019 }
-        },
-	{ 1080, 3, 720,			/* 1080i 1280x720 (133) */
-          { 1969, 750, 0x0005, 0x0008 }
-        },
-        { 1040, 2, 720,
-          { 1896, 779, 0x0005, 0x0008 }
-        },
-        { 1000, 1, 720,
-          { 1823, 810, 0x0005, 0x0008 }
-        },
-        { 960, 0, 720,
-          { 1750, 844, 0x0005, 0x0008 }
-        },
-        { 920, -1, 720,
-          { 1677, 880, 0x0005, 0x0008 }
-        },
-        { 880, -2, 720,
-          { 1604, 920, 0x0005, 0x0008 }
-        },
-        { 840, -3, 720,
-          { 1531, 964, 0x0005, 0x0008 }
-        },
-	{ 1080, 3, 1024,		/* 1080i 1280x1024 (140) */
-          { 1772, 1067, 0x0004, 0x0005 }
-        },
-        { 1040, 2, 1024,
-          { 1706, 1108, 0x0004, 0x0005 }
-        },
-        { 1000, 1, 1024,
-          { 1641, 1152, 0x0004, 0x0005 }
-        },
-        { 960, 0, 1024,
-          { 1575, 1200, 0x0004, 0x0005 }
-        },
-        { 920, -1, 1024,
-          { 1509, 1252, 0x0004, 0x0005 }
-        },
-        { 880, -2, 1024,
-          { 1444, 1309, 0x0004, 0x0005 }
-        },
-        { 840, -3, 1024,
-          { 1378, 1371, 0x0004, 0x0005 }
-        },
-	{ 470, 3, 576,			/* NTSC 720x576 (147) */
-          { 1175, 602, 0x8078, 0x008f }
-        },
-        { 460, 2, 576,
-          { 1150, 614, 0x8078, 0x008f }
-        },
-        { 450, 1, 576,
-          { 1125, 628, 0x8078, 0x008f }
-        },
-        { 440, 0, 576,
-          { 1100, 643, 0x8078, 0x008f }
-        },
-        { 430, -1, 576,
-          { 1075, 658, 0x8078, 0x008f }
-        },
-        { 420, -2, 576,
-          { 1050, 673, 0x8078, 0x008f }
-        },
-        { 410, -3, 576,
-          { 1025, 680, 0x8078, 0x008f }
-        },
-	{ 550, 3, 768,			/* PAL 1024x768 (154) */
-          { 1238, 776, 0x0001, 0x0001 }
-        },
-        { 540, 2, 768,
-          { 1215, 790, 0x0001, 0x0001 }
-        },
-        { 530, 1, 768,
-          { 1193, 805, 0x0001, 0x0001 }
-        },
-        { 520, 0, 768,
-          { 1170, 821, 0x0001, 0x0001 }
-        },
-        { 510, -1, 768,
-          { 1148, 837, 0x0001, 0x0001 }
-        },
-        { 500, -2, 768,
-          { 1125, 853, 0x0001, 0x0001 }
-        },
-        { 490, -3, 768,
-          { 1103, 871, 0x0001, 0x0001 }
-        },
-	{ 470, 3, 768,			/* NTSC 1024 i (161) */
-          { 1175, 759, 0x8001, 0x0001 }
-        },
-        { 460, 2, 768,
-          { 1150, 775, 0x8001, 0x0001 }
-        },
-        { 450, 1, 768,
-          { 1125, 792, 0x8001, 0x0001 }
-        },
-        { 440, 0, 768,
-          { 1100, 811, 0x8001, 0x0001 }
-        },
-        { 430, -1, 768,
-          { 1075, 829, 0x8001, 0x0001 }
-        },
-        { 430, -2, 768,
-          { 1075, 829, 0x8001, 0x0001 }
-        },
-        { 430, -3, 768,
-          { 1075, 829, 0x8001, 0x0001 }
-        },
-	{ 470, 3, 768,			/* NTSC 1024 p (168) */
-          { 1175, 792, 0x0001, 0x0001 }
-        },
-        { 460, 2, 768,
-          { 1150, 809, 0x0001, 0x0001 }
-        },
-        { 450, 1, 768,
-          { 1125, 827, 0x0001, 0x0001 }
-        },
-        { 440, 0, 768,
-          { 1100, 846, 0x0001, 0x0001 }
-        },
-        { 430, -1, 768,
-          { 1075, 865, 0x0001, 0x0001 }
-        },
-        { 430, -2, 768,
-          { 1075, 865, 0x0001, 0x0001 }
-        },
-        { 430, -3, 768,
-          { 1075, 865, 0x0001, 0x0001 }
-        },
-	{ 470, 3, 480,			/* NTSC 800x480 (175) */
-	  { 893, 509, 0x004c, 0x008f }
-	},
-	{ 460, 2, 480,
-	  { 874, 514, 0x004c, 0x008f }
-	},
-	{ 450, 1, 480,
-	  { 855, 519, 0x004c, 0x008f }
-	},
-	{ 440, 0, 480,	/* default */
-	  { 836, 524, 0x004c, 0x008f }
-	},
-	{ 430, -1, 480,
-	  { 860, 529, 0x0050, 0x008f }
-	},
-	{ 420, -2, 480,
-	  { 840, 534, 0x0050, 0x008f }
-	},
-	{ 420, -3, 480,
-	  { 840, 534, 0x0050, 0x008f }
-	},
-	{ 470, 3, 576,			/* NTSC 1024x576 (182) */
-          { 1175, 602, 0x8078, 0x008f }
-        },
-        { 460, 2, 576,
-          { 1150, 614, 0x8078, 0x008f }
-        },
-        { 450, 1, 576,
-          { 1125, 628, 0x8078, 0x008f }
-        },
-        { 440, 0, 576,
-          { 1100, 643, 0x8078, 0x008f }
-        },
-        { 430, -1, 576,
-          { 1075, 658, 0x8078, 0x008f }
-        },
-        { 430, -2, 576,
-          { 1075, 658, 0x8078, 0x008f }
-        },
-        { 430, -3, 576,
-          { 1075, 658, 0x8078, 0x008f }
-        },
-	{ 564, 3, 576,			/* PAL 1024x576 (189) */
-          { 1128, 592, 0x0002, 0x0003 }
-        },
-        { 556, 2, 576,
-          { 1112, 601, 0x0002, 0x0003 }
-        },
-        { 548, 1, 576,
-          { 1096, 610, 0x0002, 0x0003 }
-        },
-        { 540, 0, 576,
-          { 1080, 619, 0x0002, 0x0003 }
-        },
-        { 532, -1, 576,
-          { 1064, 628, 0x0002, 0x0003 }
-        },
-        { 532, -2, 576,
-          { 1064, 628, 0x0002, 0x0003 }
-        },
-        { 532, -3, 576,
-          { 1064, 628, 0x0002, 0x0003 }
-        },
-	{ 1080, 3, 540,			/* 1080i 960x540 (196) */
-          { 1050, 600, 0x0001, 0x0004 }
-        },
-        { 1080, 2, 540,
-          { 1050, 600, 0x0001, 0x0004 }
-        },
-        { 1080, 1, 540,
-          { 1050, 600, 0x0001, 0x0004 }
-        },
-        { 1080, 0, 540,
-          { 1050, 600, 0x0001, 0x0004 }
-        },
-        { 1040, -1, 540,
-          { 1011, 623, 0x0001, 0x0004 }
-        },
-        { 1000, -2, 540,
-          { 1944, 648, 0x0001, 0x0002 }
-        },
-        { 960, -3, 540,
-          { 1866, 675, 0x0001, 0x0002 }
-        },
-	{ 1080, 3, 600,			/* 1080i 960x600 (203) */
-          { 1418, 670, 0x0003, 0x0008 }
-        },
-        { 1040, 2, 600,
-          { 1365, 700, 0x0003, 0x0008 }
-        },
-        { 1000, 1, 600,
-          { 1313, 816, 0x0003, 0x0008 }
-        },
-        { 960, 0, 600,
-          { 1260, 851, 0x0003, 0x0008 }
-        },
-        { 920, -1, 600,
-          { 1208, 887, 0x0003, 0x0008 }
-        },
-        { 880, -2, 600,
-          { 1155, 928, 0x0003, 0x0008 }
-        },
-        { 840, -3, 600,
-          { 1103, 972, 0x0003, 0x0008 }
-        }
-};
-
-static unsigned const char SiSScalingP1Regs[] = {
-	0x08,0x09,0x0b,0x0c,0x0d,0x0e,0x10,0x11,0x12
-};
-static unsigned const char SiSScalingP4Regs[] = {
-	0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b
-};
-
-/*     TV filters for SiS video bridges
- */
-static const struct _SiSTVFilter301 {
-	UChar filter[7][4];
-} SiSTVFilter301[] = {
-	{{ {0x00,0xE0,0x10,0x60},   /* NTSCFilter - 320 */
-	   {0x00,0xEE,0x10,0x44},
-	   {0x00,0xF4,0x10,0x38},
-	   {0xF8,0xF4,0x18,0x38},
-	   {0xFC,0xFB,0x14,0x2A},
-	   {0x00,0x00,0x10,0x20},
-	   {0x00,0x04,0x10,0x18} }},
-	{{ {0xF5,0xEE,0x1B,0x44},   /* NTSCFilter - 640 */
-	   {0xF8,0xF4,0x18,0x38},
-	   {0xEB,0x04,0x25,0x18},
-	   {0xF1,0x05,0x1F,0x16},
-	   {0xF6,0x06,0x1A,0x14},
-	   {0xFA,0x06,0x16,0x14},
-	   {0x00,0x04,0x10,0x18} }},
-	{{ {0xEB,0x04,0x25,0x18},   /* NTSCFilter - 720 */
-	   {0xE7,0x0E,0x29,0x04},
-	   {0xEE,0x0C,0x22,0x08},
-	   {0xF6,0x0B,0x1A,0x0A},
-	   {0xF9,0x0A,0x17,0x0C},
-	   {0xFC,0x0A,0x14,0x0C},
-	   {0x00,0x08,0x10,0x10} }},
-	{{ {0xEC,0x02,0x24,0x1C},   /* NTSCFilter - 800/400 */
-	   {0xF2,0x04,0x1E,0x18},
-	   {0xEB,0x15,0x25,0xF6},
-	   {0xF4,0x10,0x1C,0x00},
-	   {0xF8,0x0F,0x18,0x02},
-	   {0x00,0x04,0x10,0x18},
-	   {0x01,0x06,0x0F,0x14} }},
-	{{ {0x00,0xE0,0x10,0x60},   /* PALFilter - 320 */
-	   {0x00,0xEE,0x10,0x44},
-	   {0x00,0xF4,0x10,0x38},
-	   {0xF8,0xF4,0x18,0x38},
-	   {0xFC,0xFB,0x14,0x2A},
-	   {0x00,0x00,0x10,0x20},
-	   {0x00,0x04,0x10,0x18} }},
-	{{ {0xF5,0xEE,0x1B,0x44},   /* PALFilter - 640 */
-	   {0xF8,0xF4,0x18,0x38},
-	   {0xF1,0xF7,0x1F,0x32},
-	   {0xF5,0xFB,0x1B,0x2A},
-	   {0xF9,0xFF,0x17,0x22},
-	   {0xFB,0x01,0x15,0x1E},
-	   {0x00,0x04,0x10,0x18} }},
-	{{ {0xF5,0xEE,0x1B,0x2A},   /* PALFilter - 720 */
-	   {0xEE,0xFE,0x22,0x24},
-	   {0xF3,0x00,0x1D,0x20},
-	   {0xF9,0x03,0x17,0x1A},
-	   {0xFB,0x02,0x14,0x1E},
-	   {0xFB,0x04,0x15,0x18},
-	   {0x00,0x06,0x10,0x14} }},
-	{{ {0xF5,0xEE,0x1B,0x44},   /* PALFilter - 800/400 */
-	   {0xF8,0xF4,0x18,0x38},
-	   {0xFC,0xFB,0x14,0x2A},
-	   {0xEB,0x05,0x25,0x16},
-	   {0xF1,0x05,0x1F,0x16},
-	   {0xFA,0x07,0x16,0x12},
-	   {0x00,0x07,0x10,0x12} }}
-};
-
-static const struct _SiSTVFilter301B {
-	UChar filter[7][7];
-} SiSTVFilter301B[] = {
-	{{ {0x01,0x02,0xfb,0xf8,0x06,0x27,0x3a},   /* NTSC - 640 */
-	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
-	   {0x01,0x01,0x00,0xf6,0x00,0x28,0x40},
-	   {0xff,0x03,0x02,0xf6,0xfc,0x27,0x46},
-	   {0xff,0x01,0x04,0xf8,0xfa,0x27,0x46},
-	   {0xff,0x01,0x05,0xf9,0xf7,0x26,0x4a},
-	   {0xff,0xff,0x05,0xfc,0xf4,0x24,0x52} }},
-	{{ {0x01,0x00,0xfb,0xfb,0x0b,0x25,0x32},   /* NTSC - 720 (?) */
-	   {0x01,0x01,0xfb,0xf9,0x09,0x26,0x36},
-	   {0x01,0x02,0xfc,0xf8,0x06,0x27,0x38},
-	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
-	   {0x01,0x03,0xff,0xf6,0x00,0x27,0x40},
-	   {0xff,0x03,0x02,0xf6,0xfe,0x27,0x42},
-	   {0xff,0x02,0x03,0xf7,0xfb,0x27,0x46} }},
-	{{ {0x01,0xfe,0xfb,0xfe,0x0e,0x23,0x2e},   /* NTSC - 800 */
-	   {0x01,0xff,0xfb,0xfc,0x0c,0x25,0x30},
-	   {0x01,0x00,0xfb,0xfa,0x0a,0x26,0x34},
-	   {0x01,0x01,0xfc,0xf8,0x08,0x26,0x38},
-	   {0x01,0x02,0xfd,0xf7,0x06,0x27,0x38},
-	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
-	   {0xff,0x03,0x00,0xf6,0x00,0x27,0x42} }},
-	{{ {0xff,0xfd,0xfe,0x05,0x11,0x1e,0x24},   /* NTSC - 1024 */
-	   {0xff,0xfd,0xfd,0x04,0x11,0x1f,0x26},
-	   {0xff,0xfd,0xfc,0x02,0x10,0x22,0x28},
-	   {0xff,0xff,0xfc,0x00,0x0f,0x22,0x28},
-	   {0x01,0xfe,0xfb,0xff,0x0e,0x23,0x2c},
-	   {0x01,0xff,0xfb,0xfd,0x0d,0x24,0x2e},
-	   {0x01,0xff,0xfb,0xfb,0x0c,0x25,0x32} }},
-	{{ {0x01,0x02,0xfb,0xf8,0x06,0x27,0x3a},   /* PAL - 640 */
-	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
-	   {0x01,0x01,0x00,0xf6,0x00,0x28,0x40},
-	   {0xff,0x03,0x02,0xf6,0xfc,0x27,0x46},
-	   {0xff,0x01,0x04,0xf8,0xfa,0x27,0x46},
-	   {0xff,0x01,0x05,0xf9,0xf7,0x26,0x4a},
-	   {0xff,0xff,0x05,0xfc,0xf4,0x24,0x52} }},
-	{{ {0x01,0x00,0xfb,0xfb,0x0b,0x25,0x32},   /* PAL - 720/768 */
-	   {0x01,0x01,0xfb,0xf9,0x09,0x26,0x36},
-	   {0x01,0x02,0xfc,0xf8,0x06,0x27,0x38},
-	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
-	   {0x01,0x03,0xff,0xf6,0x00,0x27,0x40},
-	   {0xff,0x03,0x02,0xf6,0xfe,0x27,0x42},
-	   {0xff,0x02,0x03,0xf7,0xfb,0x27,0x46} }},
-	{{ {0x01,0xfe,0xfb,0xfe,0x0e,0x23,0x2e},   /* PAL - 800 */
-	   {0x01,0xff,0xfb,0xfc,0x0c,0x25,0x30},
-	   {0x01,0x00,0xfb,0xfa,0x0a,0x26,0x34},
-	   {0x01,0x01,0xfc,0xf8,0x08,0x26,0x38},
-	   {0x01,0x02,0xfd,0xf7,0x06,0x27,0x38},
-	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
-	   {0xff,0x03,0x00,0xf6,0x00,0x27,0x42} }},
-	{{ {0xff,0xfd,0xfe,0x05,0x11,0x1e,0x24},   /* PAL - 1024 */
-	   {0xff,0xfd,0xfd,0x04,0x11,0x1f,0x26},
-	   {0xff,0xfd,0xfc,0x02,0x10,0x22,0x28},
-	   {0xff,0xff,0xfc,0x00,0x0f,0x22,0x28},
-	   {0x01,0xfe,0xfb,0xff,0x0e,0x23,0x2c},
-	   {0x01,0xff,0xfb,0xfd,0x0d,0x24,0x2e},
-	   {0x01,0xff,0xfb,0xfb,0x0c,0x25,0x32} }},
-	{{ {0x54,0x69,0x6c,0x6c,0x20,0x53,0x6f},   /* PAL-M - 1024 */
-	   {0x66,0x69,0x61,0x20,0x42,0x65,0x72},
-	   {0x6e,0x74,0x73,0x73,0x6f,0x6e,0x20},
-	   {0x2d,0x20,0x42,0x72,0x6f,0x75,0x67},
-	   {0x68,0x74,0x20,0x74,0x6f,0x20,0x79},
-	   {0x6f,0x75,0x20,0x62,0x79,0x20,0x6e},
-	   {0x6f,0x74,0x20,0x61,0x20,0x6d,0x65,} }},
-	{{ {0x72,0x65,0x20,0x57,0x69,0x7a,0x61},   /* PAL-N - 1024 */
-	   {0x72,0x64,0x20,0x62,0x75,0x74,0x20},
-	   {0x74,0x68,0x65,0x20,0x57,0x69,0x7a},
-	   {0x61,0x72,0x64,0x20,0x45,0x78,0x74},
-	   {0x72,0x61,0x6f,0x72,0x64,0x69,0x6e},
-	   {0x61,0x69,0x72,0x65,0x21,0x20,0x48},
-	   {0x69,0x20,0x44,0x61,0x6c,0x65,0x21} }}
-};
-
 /* For communication with the SiS Linux framebuffer driver (sisfb) */
 
 /* ioctl for identifying and giving some info (esp. memory heap start) */
@@ -1573,67 +776,76 @@ static void SISLeaveVT(int scrnIndex, int flags);
 static Bool SISCloseScreen(int scrnIndex, ScreenPtr pScreen);
 static Bool SISSaveScreen(ScreenPtr pScreen, int mode);
 static Bool SISSwitchMode(int scrnIndex, DisplayModePtr mode, int flags);
-void	    SISAdjustFrame(int scrnIndex, int x, int y, int flags);
+static void SISNewAdjustFrame(int scrnIndex, int x, int y, int flags);
+static Bool SISPMEvent(int scrnIndex, pmEvent event, Bool undo);/*APM-ACPI, adding by Ivans.*/
+
+/* ACPI Device Switch functions */
+static Bool SISHotkeySwitchCRT1Status(ScrnInfoPtr pScrn,int onoff);/*hotkey pressing: switch CRT1 on/off*/
+static Bool SISHotkeySwitchCRT2Status(ScrnInfoPtr pScrn,ULong newvbflags ,ULong newvbflags3);/*LCD on/off*/
+static Bool SISHotkeySwitchMode(ScrnInfoPtr pScrn, Bool adjust);/*Resolution optimal function*/
 
 /* Optional functions */
 #ifdef SISDUALHEAD
-static Bool 	  SISSaveScreenDH(ScreenPtr pScreen, int mode);
+static Bool	SISSaveScreenDH(ScreenPtr pScreen, int mode);
 #endif
 #ifdef X_XF86MiscPassMessage
-extern int	  SISHandleMessage(int scrnIndex, const char *msgtype,
+extern int	SISHandleMessage(int scrnIndex, const char *msgtype,
 				const char *msgval, char **retmsg);
 #endif
-static void       SISFreeScreen(int scrnIndex, int flags);
+static void     SISFreeScreen(int scrnIndex, int flags);
 static ModeStatus SISValidMode(int scrnIndex, DisplayModePtr mode,
 				Bool verbose, int flags);
+#ifdef SIS_HAVE_RR_FUNC
+#ifdef SIS_HAVE_DRIVER_FUNC
+static Bool SISDriverFunc(ScrnInfoPtr pScrn, xorgDriverFuncOp op, pointer p);
+#else
+static Bool SISDriverFunc(ScrnInfoPtr pScrn, xorgRRFuncFlags op, xorgRRRotationPtr p);
+#endif
+#ifdef SISISXORG6899901
+static Bool SiS_GetModeMM(ScrnInfoPtr pScrn, DisplayModePtr mode, int virtX, int virtY,
+					int *mmWidth, int *mmHeight);
+#endif
+#endif
 
 /* Internally used functions */
-static Bool    SISMapMem(ScrnInfoPtr pScrn);
-static Bool    SISUnmapMem(ScrnInfoPtr pScrn);
 #ifdef SIS_NEED_MAP_IOP
-static Bool    SISMapIOPMem(ScrnInfoPtr pScrn);
-static Bool    SISUnmapIOPMem(ScrnInfoPtr pScrn);
-#endif
-static void    SISSave(ScrnInfoPtr pScrn);
-static void    SISRestore(ScrnInfoPtr pScrn);
-static Bool    SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
-static void    SISModifyModeInfo(DisplayModePtr mode);
-static void    SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, int viewmode);
-static void    SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg);
-static void    SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg);
-static Bool    SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode);
-static void    SISVESARestore(ScrnInfoPtr pScrn);
-static void    SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe);
-static UShort  SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode);
-static void    SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function);
-static void    SISBridgeRestore(ScrnInfoPtr pScrn);
-static void    SiSEnableTurboQueue(ScrnInfoPtr pScrn);
-static void    SiSRestoreQueueMode(SISPtr pSiS, SISRegPtr sisReg);
-UChar  	       SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode);
-static void    SISWaitVBRetrace(ScrnInfoPtr pScrn);
-void           SISWaitRetraceCRT1(ScrnInfoPtr pScrn);
-void           SISWaitRetraceCRT2(ScrnInfoPtr pScrn);
-UShort         SiS_CheckModeCRT1(ScrnInfoPtr pScrn, DisplayModePtr mode,
-				 unsigned int VBFlags, Bool hcm);
-UShort         SiS_CheckModeCRT2(ScrnInfoPtr pScrn, DisplayModePtr mode,
-				 unsigned int VBFlags, Bool hcm);
-
-#ifdef SISMERGED
-static Bool    InRegion(int x, int y, region r);
-static void    SISMergedPointerMoved(int scrnIndex, int x, int y);
+static Bool	SISMapIOPMem(ScrnInfoPtr pScrn);
+static Bool	SISUnmapIOPMem(ScrnInfoPtr pScrn);
 #endif
-Bool           SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn);
-UShort	       SiS_GetModeNumber(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned int VBFlags);
-UChar  	       SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, UShort offset, UChar value);
-#ifdef DEBUG
-static void    SiSDumpModeInfo(ScrnInfoPtr pScrn, DisplayModePtr mode);
+void		SISAdjustFrame(int scrnIndex, int x, int y, int flags);
+UChar		SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode);
+UShort		SiS_CheckModeCRT1(ScrnInfoPtr pScrn, DisplayModePtr mode,
+				 unsigned int VBFlags, unsigned int VBFlags3, Bool hcm);
+UShort		SiS_CheckModeCRT2(ScrnInfoPtr pScrn, DisplayModePtr mode,
+				 unsigned int VBFlags, unsigned int VBFlags3, Bool hcm);
+void		SiSPrintModes(ScrnInfoPtr pScrn, Bool printfreq);
+Bool		SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn);
+UChar		SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, UShort offset, UChar value);
+Bool		SISDetermineLCDACap(ScrnInfoPtr pScrn);
+void		SISSaveDetectedDevices(ScrnInfoPtr pScrn);
+void		SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...);
+void		SiSFindAspect(ScrnInfoPtr pScrn, xf86MonPtr pMonitor, int crtnum, Bool q);
+DisplayModePtr	SiSDuplicateMode(DisplayModePtr source);
+Bool		SiSMakeOwnModeList(ScrnInfoPtr pScrn, Bool acceptcustommodes,
+				Bool includelcdmodes, Bool isfordvi, Bool *havecustommodes,
+				Bool fakecrt2modes, Bool IsForCRT2);
+xf86MonPtr	SiSInternalDDC(ScrnInfoPtr pScrn, int crtno);
+Bool		SiSFixupHVRanges(ScrnInfoPtr pScrn, int mfbcrt, Bool quiet);
+void		SiSClearModesPrivate(DisplayModePtr modelist);
+DisplayModePtr	SiSSearchMode(ScrnInfoPtr pScrn, DisplayModePtr modelist,
+			DisplayModePtr mode, Bool *needreset, Bool *needrecalcxine);
+void		SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y);
+void		SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y);
+#if defined(SISDUALHEAD) || defined(SISMERGED)
+int		SiSRemoveUnsuitableModes(ScrnInfoPtr pScrn, DisplayModePtr initial,
+				const char *reason, Bool quiet);
 #endif
-Bool           SISDetermineLCDACap(ScrnInfoPtr pScrn);
-void           SISSaveDetectedDevices(ScrnInfoPtr pScrn);
 #ifdef SISGAMMARAMP
-void	       SISCalculateGammaRamp(ScreenPtr pScreen, ScrnInfoPtr pScrn);
+void		SISCalculateGammaRamp(ScreenPtr pScreen, ScrnInfoPtr pScrn);
 #endif
 
+extern void	RecalcScreenPitch(ScrnInfoPtr pScrn);
+
 /* Our very own vgaHW functions (sis_vga.c) */
 extern void 	SiSVGASave(ScrnInfoPtr pScrn, SISRegPtr save, int flags);
 extern void 	SiSVGARestore(ScrnInfoPtr pScrn, SISRegPtr restore, int flags);
@@ -1646,9 +858,8 @@ extern Bool 	SiSVGAMapMem(ScrnInfoPtr pScrn);
 extern void 	SiSVGAUnmapMem(ScrnInfoPtr pScrn);
 extern Bool 	SiSVGASaveScreen(ScreenPtr pScreen, int mode);
 
-/* shadow */
+/* shadow, randr, randr-rotation */
 extern void 	SISPointerMoved(int index, int x, int y);
-extern void 	SISPointerMovedReflect(int index, int x, int y);
 extern void 	SISRefreshArea(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 extern void 	SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 extern void 	SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
@@ -1664,6 +875,10 @@ extern void 	SISCRT2PreInit(ScrnInfoPtr pScrn, Bool quiet);
 extern void 	SISSense30x(ScrnInfoPtr pScrn, Bool quiet);
 extern void 	SISSenseChrontel(ScrnInfoPtr pScrn, Bool quiet);
 extern void     SiSSetupPseudoPanel(ScrnInfoPtr pScrn);
+extern void	SiSPostSetModeTVParms(ScrnInfoPtr pScrn);
+
+extern unsigned int    SiS_DetectVGA1(ScrnInfoPtr pScrn);/*only probe VGA1.(Ivans Lee)*/
+	
 
 /* utility */
 extern void	SiSCtrlExtInit(ScrnInfoPtr pScrn);
@@ -1696,11 +911,23 @@ extern void		SiS_Chrontel701xBLOn(struct SiS_Private *SiS_Pr);
 extern void		SiS_Chrontel701xBLOff(struct SiS_Private *SiS_Pr);
 extern void		SiS_SiS30xBLOn(struct SiS_Private *SiS_Pr);
 extern void		SiS_SiS30xBLOff(struct SiS_Private *SiS_Pr);
-extern void		SiS_CalcXTapScaler(struct SiS_Private *SiS_Pr, int srcsize, int destsize, int taps, Bool ishoriz);
-/* End of init.c, init301.c ----- */
-
-
-
-
+extern void		SiS_SetPitchCRT1(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn);
+extern void		SiS_SetPitchCRT2(struct SiS_Private *SiS_Pr, ScrnInfoPtr pScrn);
 
+/* MergedFB */
+#ifdef SISMERGED
+extern void		SiSMFBInitMergedFB(ScrnInfoPtr pScrn);
+extern void		SiSMFBHandleModesCRT2(ScrnInfoPtr pScrn, ClockRangePtr clockRanges);
+extern void 		SiSMFBMakeModeList(ScrnInfoPtr pScrn);
+extern void		SiSMFBCorrectVirtualAndLayout(ScrnInfoPtr pScrn);
+extern Bool		SiSMFBRebuildModelist(ScrnInfoPtr pScrn, ClockRangePtr clockRanges);
+extern Bool		SiSMFBRevalidateModelist(ScrnInfoPtr pScrn, ClockRangePtr clockRanges);
+extern void		SiSMFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel);
+extern void		SISMFBPointerMoved(int scrnIndex, int x, int y);
+extern void		SISMFBAdjustFrame(int scrnIndex, int x, int y, int flags);
+#ifdef SISXINERAMA
+extern void		SiSXineramaExtensionInit(ScrnInfoPtr pScrn);
+extern Bool 		SiSnoPanoramiXExtension;
+#endif
+#endif
 
diff --git a/src/sis_hwmc.c b/src/sis_hwmc.c
new file mode 100644
index 0000000..cfb9c95
--- /dev/null
+++ b/src/sis_hwmc.c
@@ -0,0 +1,580 @@
+/***************************************************************************
+
+Copyright 2000 Intel Corporation.  All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL INTEL, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * SiS_hwmc.c: SiS HWMC Driver
+ *
+ * Authors:
+ *      Chaoyu Chen <chaoyu_chen@sis.com>
+ *
+ *
+ */
+
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "xf86.h"
+#include "xf86_OSproc.h"
+#include "xf86Resources.h"
+#include "compiler.h"
+#include "xf86PciInfo.h"
+#include "xf86Pci.h"
+#include "xf86fbman.h"
+#include "regionstr.h"
+
+#include "sis.h"
+#include "sis_dri.h"
+
+#include "xf86xv.h"
+#include "xf86xvmc.h"
+#include <X11/extensions/Xv.h>
+#include <X11/extensions/XvMC.h>
+#include "xaa.h"
+#include "xaalocal.h"
+#include "dixstruct.h"
+#include "fourcc.h"
+#include "sis_common.h"
+
+#ifdef ENABLEXvMC
+
+#define MCDEBUG
+
+
+int SiSXvMCCreateContext (ScrnInfoPtr pScrn, XvMCContextPtr pContext,
+                           int *num_priv, long **priv );
+void SiSXvMCDestroyContext (ScrnInfoPtr pScrn, XvMCContextPtr pContext);
+
+int SiSXvMCCreateSurface (ScrnInfoPtr pScrn, XvMCSurfacePtr pSurf,
+                           int *num_priv, long **priv );
+void SiSXvMCDestroySurface (ScrnInfoPtr pScrn, XvMCSurfacePtr pSurf);
+
+int SiSXvMCCreateSubpicture (ScrnInfoPtr pScrn, XvMCSubpicturePtr pSurf,
+                               int *num_priv, long **priv );
+void SiSXvMCDestroySubpicture (ScrnInfoPtr pScrn, XvMCSubpicturePtr pSurf);
+
+extern unsigned int SISAllocateFBMemory(ScrnInfoPtr pScrn,  void **handle, int bytesize); 
+extern void SISFreeFBMemory(ScrnInfoPtr pScrn, void **handle);
+extern void SISXvMCResetVideo(ScrnInfoPtr pScrn);
+extern void SISXvMCCloseOverlay(ScrnInfoPtr pScrn);
+
+typedef struct {
+  drm_context_t drmcontext;
+  drm_context_t AGPHandle;
+  unsigned long AGPSize;
+  drm_handle_t MMIOHandle;
+  unsigned long MMIOSize;
+  unsigned long FBhandle;
+  unsigned long FBSize;
+  unsigned long ChipID;
+  unsigned long HDisplay;
+  unsigned long VDisplay;
+  char busIdString[10];
+  char pad[2];
+} SiSXvMCCreateContextRec;
+
+typedef struct {
+  unsigned int offsets[3];
+  unsigned int MyNum;
+} SiSXvMCCreateSurfaceRec;
+
+
+static int yv12_subpicture_index_list[1] = 
+{
+  /*FOURCC_IA44,*/
+  FOURCC_AI44
+};
+
+static XF86MCImageIDList yv12_subpicture_list =
+{
+  1,
+  yv12_subpicture_index_list
+};
+ 
+static XF86MCSurfaceInfoRec SiS_YV12_mpg2_surface =
+{
+    FOURCC_YV12,  
+    XVMC_CHROMA_FORMAT_420,
+    0,
+    720,
+    576,
+    720,
+    576,
+    XVMC_MPEG_2,
+    XVMC_OVERLAID_SURFACE | XVMC_SUBPICTURE_INDEPENDENT_SCALING |
+    XVMC_INTRA_UNSIGNED | XVMC_BACKEND_SUBPICTURE,
+    &yv12_subpicture_list
+};
+
+static XF86MCSurfaceInfoRec SiS_YV12_mpg1_surface =
+{
+    FOURCC_YV12,  
+    XVMC_CHROMA_FORMAT_420,
+    0,
+    720,
+    576,
+    720,
+    576,
+    XVMC_MPEG_1,
+    XVMC_OVERLAID_SURFACE | XVMC_SUBPICTURE_INDEPENDENT_SCALING |
+    XVMC_INTRA_UNSIGNED | XVMC_BACKEND_SUBPICTURE,
+    &yv12_subpicture_list
+};
+
+static XF86MCSurfaceInfoPtr ppSI[2] = 
+{
+    (XF86MCSurfaceInfoPtr)&SiS_YV12_mpg2_surface,
+    (XF86MCSurfaceInfoPtr)&SiS_YV12_mpg1_surface
+};
+
+/* List of subpicture types that we support */
+static XF86ImageRec ia44_subpicture = XVIMAGE_IA44;
+static XF86ImageRec ai44_subpicture = XVIMAGE_AI44;
+
+static XF86ImagePtr SiS_subpicture_list[1] =
+{
+/*  (XF86ImagePtr)&ia44_subpicture,*/
+  (XF86ImagePtr)&ai44_subpicture
+};
+
+/* Fill in the device dependent adaptor record. 
+ * This is named "SiS Video Overlay" because this code falls under the
+ * XV extenstion, the name must match or it won't be used.
+ *
+ * Surface and Subpicture - see above
+ * Function pointers to functions below
+ */
+static XF86MCAdaptorRec pAdapt = 
+{
+  "SIS 300/315/330 series Video Overlay",		/* name */
+  2,				/* num_surfaces */
+  ppSI,				/* surfaces */
+  1,				/* num_subpictures */
+  SiS_subpicture_list,		/* subpictures */
+  (xf86XvMCCreateContextProcPtr)SiSXvMCCreateContext,
+  (xf86XvMCDestroyContextProcPtr)SiSXvMCDestroyContext,
+  (xf86XvMCCreateSurfaceProcPtr)SiSXvMCCreateSurface,
+  (xf86XvMCDestroySurfaceProcPtr)SiSXvMCDestroySurface,
+  (xf86XvMCCreateSubpictureProcPtr)SiSXvMCCreateSubpicture,
+  (xf86XvMCDestroySubpictureProcPtr)SiSXvMCDestroySubpicture
+};
+
+static XF86MCAdaptorPtr ppAdapt[1] = 
+{
+	(XF86MCAdaptorPtr)&pAdapt
+};
+
+/**************************************************************************
+ *
+ *  SiSInitMC
+ *
+ *  Initialize the hardware motion compenstation extention for this 
+ *  hardware. The initialization routines want the address of the pointers
+ *  to the structures, not the address of the structures. This means we
+ *  allocate (or create static?) the pointer memory and pass that 
+ *  address. This seems a little convoluted.
+ *
+ *  We need to allocate memory for the device depended adaptor record. 
+ *  This is what holds the pointers to all our device functions.
+ *
+ *  We need to map the overlay registers into the drm.
+ *
+ *  We need to map the surfaces into the drm.
+ *
+ *  Inputs:
+ *    Screen pointer
+ *
+ *  Outputs:
+ *    None, this calls the device independent screen initialization 
+ *    function.
+ *
+ *  Revisions:
+ *  
+ **************************************************************************/
+void SiSInitMC(ScreenPtr pScreen)
+{
+  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+  SISPtr pSIS = SISPTR(pScrn);
+  int i;
+
+  switch(pSIS->ChipType){
+  case SIS_741:
+  case SIS_662:
+  case SIS_671:
+     break;
+  default:
+     xf86DrvMsg(pScreen->myNum, X_INFO, "[MC] %s: This chip does not support XvMC.\n", __FUNCTION__);
+     return;
+  }
+
+  /* Clear the Surface Allocation */
+  for(i=0; i<SIS_MAX_SURFACES; i++) {
+	pSIS->surfaceAllocation[i] = 0;
+  } 
+
+  
+  /* Clear the Subpicture Allocation */
+  for(i=0; i<SIS_MAX_SUBPICTURES; i++) {
+	pSIS->subpictureAllocation[i] = 0;
+  } 
+  pSIS->SubpictBuffOffset = 0;
+
+  if(!pSIS->MC_AgpAlloc.DRM_Success) /* Karma@080304 Check DRM enbale to avoid */
+  {
+     xf86DrvMsg(pScreen->myNum, X_ERROR, "[MC] AddMap (AGP) failed\n");
+     return;
+  }
+  
+  if(drmAddMap(pSIS->drmSubFD, (drm_handle_t)pSIS->MC_AgpAlloc.Start,
+                pSIS->MC_AgpAlloc.Size, DRM_AGP, 0, (drmAddress) &pSIS->mc_agp_handle) < 0) {
+    		xf86DrvMsg(pScreen->myNum, X_ERROR, "[MC] AddMap (AGP) failed\n");
+    		return;
+  }
+  
+  xf86XvMCScreenInit(pScreen, 1, ppAdapt);
+  xf86DrvMsg(pScreen->myNum, X_INFO, "[MC] XvMC adaptor is initialized succfully.\n");
+}
+
+
+/**************************************************************************
+ *
+ *  SiSXvMCCreateContext
+ *
+ *  Some info about the private data:
+ *
+ *  Set *num_priv to the number of 32bit words that make up the size of
+ *  of the data that priv will point to.
+ *
+ *  *priv = (long *) xcalloc (elements, sizeof(element))
+ *  *num_priv = (elements * sizeof(element)) >> 2;
+ *
+ **************************************************************************/
+
+int SiSXvMCCreateContext (ScrnInfoPtr pScrn, XvMCContextPtr pContext,
+                            int *num_priv, long **priv )
+{
+
+
+	
+  SISPtr pSiS = SISPTR(pScrn);
+  DRIInfoPtr pDRIInfo = pSiS->pDRIInfo;
+  SISDRIPtr pSISDRI = (SISDRIPtr)pDRIInfo->devPrivate;
+  SiSXvMCCreateContextRec *contextRec;
+  short src_pitch;
+  int PitchAlignmentMask;
+
+#ifdef MCDEBUG
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[MC] %s() in %s is called.\n",
+				__FUNCTION__, __FILE__);
+#endif
+
+  if(!pSiS->directRenderingEnabled) {
+    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+        "[MC] SiSXvMCCreateContext: Cannot use XvMC without DRI!\n");
+    return BadAlloc;
+  }
+
+  /* Context Already in use! */
+  if(pSiS->xvmcContext) {
+    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+        "[MC] SiSXvMCCreateContext: 2 XvMC Contexts Attempted, not supported.\n");
+    return BadAlloc;
+  }
+
+  *priv = xcalloc(1,sizeof(SiSXvMCCreateContextRec));
+  contextRec = (SiSXvMCCreateContextRec *)*priv;
+
+  if(!*priv) {
+    *num_priv = 0;
+    return BadAlloc;
+  }
+
+  *num_priv = sizeof(SiSXvMCCreateContextRec);
+  if(drmCreateContext(pSiS->drmSubFD, &(contextRec->drmcontext) ) < 0) {
+    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+        "[MC] SiSXvMCCreateContext: Unable to create DRMContext!\n");
+    xfree(*priv);
+    return BadAlloc;
+  }
+
+  drmAuthMagic(pSiS->drmSubFD, pContext->flags);
+
+    
+
+  drmSize FBSize = pScrn->videoRam * 1024;
+  pSiS->fb_handle = 0;
+  if(drmAddMap(pSiS->drmSubFD, pSiS->FbAddress ,FBSize, 
+  	DRM_FRAME_BUFFER, 0, &pSiS->fb_handle) < 0){
+  	
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"[MC] Frame buffer AddMap  failed!\n");
+		xfree(*priv);
+		*num_priv = 0;
+		return BadAlloc;
+  }
+
+  /* identify chip type */
+  switch(pSiS->ChipType){
+  case SIS_741:
+     contextRec->ChipID = 741;
+     PitchAlignmentMask = 7;
+     break;
+  case SIS_662:
+     contextRec->ChipID = 662;
+     PitchAlignmentMask = 63;
+     break;
+  case SIS_671:
+     contextRec->ChipID = 671;
+     PitchAlignmentMask = 63;
+     break;
+  default:
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR," [MC] XvMC is not supposted on this chip! Stop.\n");
+      xfree(*priv);
+      *num_priv = 0;
+      return BadValue;
+  }
+
+
+  /* calculate the size of Frame buffer per surface*/
+  src_pitch = (pContext->width + PitchAlignmentMask) & ~PitchAlignmentMask;
+  pSiS->FBBuffSize = (pContext->height * src_pitch * 3) >> 1;
+  pSiS->FBBuffSize = (pSiS->FBBuffSize  + 15) & ~15;
+  if(!(pSiS->FBBuffOffset = SISAllocateFBMemory(pScrn, &pSiS->FBBufferHandle,
+  	                                                                          pSiS->FBBuffSize * pSiS->numSurfaces))){
+  	                                                                          
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"[MC] Frame buffer allocation failed!\n");
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"[MC] Enlarging the video ram may solve this problem\n");
+      return BadAlloc;
+   }
+
+  pSiS->xvmcContext = contextRec->drmcontext;
+  contextRec->AGPHandle= pSiS->mc_agp_handle;
+  contextRec->AGPSize = pSiS->MC_AgpAlloc.Size;
+  contextRec->MMIOHandle = pSISDRI->regs.handle;
+  contextRec->MMIOSize = pSISDRI->regs.size;
+  contextRec->FBhandle = pSiS->fb_handle;
+  contextRec->FBSize = FBSize;  
+  contextRec->HDisplay = (unsigned long)pSiS->CurrentLayout.mode->HDisplay;
+  contextRec->VDisplay = (unsigned long)pSiS->CurrentLayout.mode->VDisplay;
+  
+  
+  strncpy (contextRec->busIdString, pDRIInfo->busIdString, 9);
+
+  SISXvMCResetVideo(pScrn);
+
+  return Success;
+}
+
+
+int SiSXvMCCreateSurface (ScrnInfoPtr pScrn, XvMCSurfacePtr pSurf,
+                           int *num_priv, long **priv ){
+                           
+  SISPtr pSiS = SISPTR(pScrn);
+  int i;
+  SiSXvMCCreateSurfaceRec* surfaceRec;
+ 
+  
+#ifdef MCDEBUG
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[MC] %s() in %s is called.\n",
+				__FUNCTION__, __FILE__);
+#endif
+
+
+  *priv = xcalloc(1,sizeof(SiSXvMCCreateSurfaceRec));
+  
+
+  if(!*priv) {
+    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+        "[MC] SiSXvMCCreateSurface: Unable to allocate memory!\n");
+    *num_priv = 0;
+    return BadAlloc;
+  }
+  *num_priv = sizeof(SiSXvMCCreateSurfaceRec);
+  surfaceRec = (SiSXvMCCreateSurfaceRec *)*priv;
+
+  /* Surface Arrangement is different based on 6 Surfaces */
+  if(pSiS->numSurfaces == 6) {
+     for(i=0; i<pSiS->numSurfaces; i++) {
+       if(!pSiS->surfaceAllocation[i]) {
+         pSiS->surfaceAllocation[i] = pSurf->surface_id;
+         surfaceRec->offsets[0] = pSiS->FBBuffOffset + i * pSiS->FBBuffSize;
+         surfaceRec->offsets[1] = pSiS->FBBuffOffset + i * pSiS->FBBuffSize + (pSiS->FBBuffSize * 2)/3;
+         surfaceRec->offsets[2] = pSiS->FBBuffOffset + i * pSiS->FBBuffSize + (pSiS->FBBuffSize * 5)/6;
+         surfaceRec->MyNum = (unsigned int)i;		 
+         return Success;
+       }
+     }
+  }
+
+  
+  xfree(*priv);
+  return BadAlloc;
+
+}
+
+int SiSXvMCCreateSubpicture (ScrnInfoPtr pScrn, XvMCSubpicturePtr pSubp,
+                              int *num_priv, long **priv )
+{
+
+	
+   SISPtr pSIS = SISPTR(pScrn);
+   int i;
+    int PitchShift;
+
+#ifdef MCDEBUG
+   xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[MC] %s() in %s is called.\n",
+				  __FUNCTION__, __FILE__);
+#endif
+
+   *priv = (long *)xcalloc(1,sizeof(long));
+
+   if(!*priv) {
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                   "SiSXvMCCreateSubpicture: Unable to allocate memory!\n");
+      *num_priv = 0;
+      return BadAlloc;
+   }
+   *num_priv = 1;
+
+
+   /* Allocate the buffer of Subpicture */
+   switch(pSIS->ChipType){
+   case SIS_741:
+      PitchShift = 15;
+      break;
+   case SIS_662:
+   case SIS_671:
+   	PitchShift = 63;
+      break;
+   }
+   pSIS->SubpictBuffSize = pSubp->width * ((pSubp->height + PitchShift) & ~PitchShift);
+   if(pSIS->SubpictBuffOffset == 0 &&
+   	(!(pSIS->SubpictBuffOffset = SISAllocateFBMemory(pScrn, &pSIS->SubpictBuffHandle,
+  	                                                                                pSIS->SubpictBuffSize * SIS_MAX_SUBPICTURES)))){	                                                                          
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"[MC] Subpicture allocation failed!\n");
+      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"[MC] Enlarging the video ram may solve this problem\n");
+      return BadAlloc;
+   }
+
+   for(i=0; i<SIS_MAX_SUBPICTURES; i++) {
+      if(!pSIS->subpictureAllocation[i]) {
+        pSIS->subpictureAllocation[i] = pSubp->subpicture_id; 
+        (*priv)[0] = pSIS->SubpictBuffOffset + i*pSIS->SubpictBuffSize;  	 
+        return Success;
+      }
+    }
+
+
+   (*priv)[0] = 0;
+   return BadAlloc;
+  
+}
+
+void SiSXvMCDestroyContext (ScrnInfoPtr pScrn, XvMCContextPtr pContext)
+{
+
+   SISPtr pSiS = SISPTR(pScrn);
+   int errorno;
+#ifdef MCDEBUG
+   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[MC] %s() in %s is called.\n",
+				__FUNCTION__, __FILE__);
+#endif
+
+   /* according to the comment of libdrm, Removing map is not necessary */
+   /*
+   if(pSiS->fb_handle){
+      errorno = drmRmMap(pSiS->drmSubFD, pSiS->fb_handle);
+      if(errorno != 0)
+         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
+            "[MC] Removing frame buffer Map (from drm) failed. (ErrorNo: %d)\n", errorno);
+   }
+   */
+   
+   if(pSiS->xvmcContext){
+      errorno = drmDestroyContext(pSiS->drmSubFD,pSiS->xvmcContext);
+      if(errorno != 0)
+         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
+            "[MC] Destroying Context (from drm) failed. (ErrorNo: %d)\n", errorno);
+   }
+   pSiS->xvmcContext = 0;
+   if(pSiS->FBBufferHandle != NULL)  SISFreeFBMemory(pScrn, &pSiS->FBBufferHandle);
+   pSiS->FBBufferHandle = NULL;
+   
+   if(! pSiS->SubpictBuffOffset){
+      SISFreeFBMemory(pScrn, &pSiS->SubpictBuffHandle);
+      pSiS->SubpictBuffOffset = 0;
+   }
+
+   SISXvMCCloseOverlay(pScrn);
+
+}
+
+void SiSXvMCDestroySurface (ScrnInfoPtr pScrn, XvMCSurfacePtr pSurf)
+{
+	
+   SISPtr pSiS = SISPTR(pScrn);
+   int i;
+
+#ifdef MCDEBUG
+   xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[MC] %s() in %s is called.\n",
+   		      __FUNCTION__, __FILE__);
+#endif
+
+   for(i=0; i<SIS_MAX_SURFACES; i++) {
+      if(pSiS->surfaceAllocation[i] == pSurf->surface_id) {
+         pSiS->surfaceAllocation[i] = 0;
+         return;
+      }
+   }
+   return;
+}
+
+void SiSXvMCDestroySubpicture (ScrnInfoPtr pScrn, XvMCSubpicturePtr pSubp)
+{
+
+
+   SISPtr pSiS = SISPTR(pScrn);
+   int i;
+
+#ifdef MCDEBUG
+   xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[MC] %s() in %s is called.\n",
+				__FUNCTION__, __FILE__);
+#endif
+
+   for(i = 0; i < SIS_MAX_SUBPICTURES; i++) {
+      if(pSiS->subpictureAllocation[i] == pSubp->subpicture_id) {
+         pSiS->subpictureAllocation[i] = 0;
+         return;
+      }
+   }
+   return;
+}
+
+#endif
+
diff --git a/src/sis_memcpy.c b/src/sis_memcpy.c
index 67cb7d2..d2844eb 100644
--- a/src/sis_memcpy.c
+++ b/src/sis_memcpy.c
@@ -848,6 +848,10 @@ static char *SiS_GetCPUFreq(ScrnInfoPtr pScrn, char *buf, double *cpuFreq)
 #include <setjmp.h>
 #endif
 
+#ifdef XSERVER_LIBPCIACCESS
+#include <setjmp.h>
+#endif
+
 static jmp_buf sigill_return;
 
 static void sigill_handler(void)
@@ -867,11 +871,11 @@ static Bool CheckOSforSSE(ScrnInfoPtr pScrn)
 
     xf86InterceptSigIll(&sigill_handler);
 
-    if(setjmp(sigill_return)) {
-       signo = 4;
-    } else {
-       __asm__ __volatile__ (" xorps %xmm0, %xmm0\n");
-       /* __asm__ __volatile__ (" .byte 0xff\n"); */  /* For test */
+   	 if(setjmp(sigill_return) ) {
+    	   signo = 4;
+   	 } else {
+     	  __asm__ __volatile__ (" xorps %xmm0, %xmm0\n");
+     	  /* __asm__ __volatile__ (" .byte 0xff\n"); */  /* For test */
     }
 
     xf86InterceptSigIll(NULL);
@@ -1057,7 +1061,7 @@ SiSVidCopyInitGen(ScreenPtr pScreen, SISMCFuncData *MCFunctions, vidCopyFunc *UM
     SISPtr pSiS = SISPTR(pScrn);
     void *fbhandle = NULL;
     char  *frqBuf = NULL;
-    UChar *buf1, *buf2, *buf3;
+    UChar *buf1 = NULL, *buf2 = NULL, *buf3 = NULL;
     double cpuFreq = 0.0;
     unsigned int myCPUflags = pSiS->CPUFlags | Def_FL;
     int best, secondbest;
diff --git a/src/sis_mergedfb.c b/src/sis_mergedfb.c
new file mode 100644
index 0000000..61b4255
--- /dev/null
+++ b/src/sis_mergedfb.c
@@ -0,0 +1,3005 @@
+/* $XFree86$ */
+/* $XdotOrg$ */
+/*
+ * SiS driver MergedFB code
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2) Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3) The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Thomas Winischhofer <thomas@winischhofer.net>
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sis.h"
+
+#ifdef SISMERGED
+
+#include "dixstruct.h"
+#include "globals.h"
+
+#ifdef SISXINERAMA
+#include "resource.h"
+#include "windowstr.h"
+#endif
+
+void		SiSMFBInitMergedFB(ScrnInfoPtr pScrn);
+void		SiSMFBHandleModesCRT2(ScrnInfoPtr pScrn, ClockRangePtr clockRanges);
+void		SiSMFBMakeModeList(ScrnInfoPtr pScrn);
+void		SiSMFBCorrectVirtualAndLayout(ScrnInfoPtr pScrn);
+void		SiSMFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel);
+void		SISMFBPointerMoved(int scrnIndex, int x, int y);
+void		SISMFBAdjustFrame(int scrnIndex, int x, int y, int flags);
+
+Bool		SiSMFBRebuildModelist(ScrnInfoPtr pScrn, ClockRangePtr clockRanges);
+Bool		SiSMFBRevalidateModelist(ScrnInfoPtr pScrn, ClockRangePtr clockRanges);
+
+#ifdef SISXINERAMA
+void		SiSXineramaExtensionInit(ScrnInfoPtr pScrn);
+
+Bool 			SiSnoPanoramiXExtension = TRUE;
+static int		SiSXineramaNumScreens = 0;
+static SiSXineramaData	*SiSXineramadataPtr = NULL;
+static int		SiSXineramaGeneration;
+#endif
+
+extern void		SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...);
+extern int		SiSMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2, Bool quiet);
+extern DisplayModePtr	SiSDuplicateMode(DisplayModePtr source);
+extern xf86MonPtr	SiSInternalDDC(ScrnInfoPtr pScrn, int crtno);
+extern float		SiSCalcVRate(DisplayModePtr mode);
+extern void		SiSFindAspect(ScrnInfoPtr pScrn, xf86MonPtr pMonitor, int crtnum,
+				Bool quiet);
+extern Bool		SiSMakeOwnModeList(ScrnInfoPtr pScrn, Bool acceptcustommodes,
+				Bool includelcdmodes, Bool isfordvi, Bool *havecustommodes,
+				Bool fakecrt2modes, Bool IsForCRT2);
+extern int		SiSRemoveUnsuitableModes(ScrnInfoPtr pScrn, DisplayModePtr initial,
+				const char *reason, Bool quiet);
+extern Bool		SiSFixupHVRanges(ScrnInfoPtr pScrn, int mfbcrt, Bool quiet);
+extern void		SiSClearModesPrivate(DisplayModePtr modelist);
+extern void		SiSPrintModes(ScrnInfoPtr pScrn, Bool printfreq);
+extern void		SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y);
+extern void		SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y);
+
+#define SISSWAP(x, y) {		\
+	int temp = x;		\
+	x = y;			\
+	y = temp;		\
+	}
+
+/* Helper function for CRT2 monitor vrefresh/hsync options
+ * (Code based on code from mga driver)
+ */
+static int
+SiSStrToRanges(range *r, char *s, int max)
+{
+   float num = 0.0;
+   int rangenum = 0;
+   Bool gotdash = FALSE;
+   Bool nextdash = FALSE;
+   char *strnum = NULL;
+   do {
+      switch(*s) {
+      case '0':
+      case '1':
+      case '2':
+      case '3':
+      case '4':
+      case '5':
+      case '6':
+      case '7':
+      case '8':
+      case '9':
+      case '.':
+         if(strnum == NULL) {
+            strnum = s;
+            gotdash = nextdash;
+            nextdash = FALSE;
+         }
+         break;
+      case '-':
+      case ' ':
+      case 0:
+         if(strnum == NULL) break;
+         sscanf(strnum, "%f", &num);
+	 strnum = NULL;
+         if(gotdash) {
+            r[rangenum - 1].hi = num;
+         } else {
+            r[rangenum].lo = num;
+            r[rangenum].hi = num;
+            rangenum++;
+         }
+         if(*s == '-') nextdash = (rangenum != 0);
+	 else if(rangenum >= max) return rangenum;
+         break;
+      default:
+         return 0;
+      }
+
+   } while(*(s++) != 0);
+
+   return rangenum;
+}
+
+/* Copy and link two modes (i, j) for mergedfb mode
+ * (Code formerly based on code from mga driver)
+ *
+ * - Copy mode i, merge j to copy of i, link the result to dest
+ * - Link i and j in private record.
+ * - If dest is NULL, return value is copy of i linked to itself.
+ * - For mergedfb auto-config, we only check the dimension
+ *   against virtualX/Y, if they were user-provided.
+ * - No special treatment required for CRTxxOffs.
+ * - Provide fake dotclock in order to distinguish between similar
+ *   looking MetaModes (for RandR and VidMode extensions)
+ * - Set unique VRefresh of dest mode for RandR
+ */
+static DisplayModePtr
+SiSCopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest,
+		 DisplayModePtr i, DisplayModePtr j,
+		 SiSScrn2Rel srel, Bool quiet)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    DisplayModePtr mode;
+    int dx = 0, dy = 0;
+    char namebuffer[32], namebuf1[64], namebuf2[64];
+    char printbuffer[256];
+
+    if(!((mode = xalloc(sizeof(DisplayModeRec)))))
+       return dest;
+
+    memcpy(mode, i, sizeof(DisplayModeRec));
+
+    if(!((mode->Private = xalloc(sizeof(SiSMergedDisplayModeRec))))) {
+       xfree(mode);
+       return dest;
+    }
+
+    ((SiSMergedDisplayModePtr)mode->Private)->CRT1 = i;
+    ((SiSMergedDisplayModePtr)mode->Private)->CRT2 = j;
+    ((SiSMergedDisplayModePtr)mode->Private)->CRT2Position = srel;
+
+    mode->PrivSize = 0;
+
+    switch(srel) {
+    case sisLeftOf:
+    case sisRightOf:
+       if(!(pScrn->display->virtualX)) {
+          dx = i->HDisplay + j->HDisplay;
+       } else {
+          dx = min(pScrn->virtualX, i->HDisplay + j->HDisplay);
+       }
+       dx -= mode->HDisplay;
+       if(!(pScrn->display->virtualY)) {
+          dy = max(i->VDisplay, j->VDisplay);
+       } else {
+          dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
+       }
+       dy -= mode->VDisplay;
+       break;
+    case sisAbove:
+    case sisBelow:
+       if(!(pScrn->display->virtualY)) {
+          dy = i->VDisplay + j->VDisplay;
+       } else {
+          dy = min(pScrn->virtualY, i->VDisplay + j->VDisplay);
+       }
+       dy -= mode->VDisplay;
+       if(!(pScrn->display->virtualX)) {
+          dx = max(i->HDisplay, j->HDisplay);
+       } else {
+          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
+       }
+       dx -= mode->HDisplay;
+       break;
+    case sisClone:
+       if(!(pScrn->display->virtualX)) {
+          dx = max(i->HDisplay, j->HDisplay);
+       } else {
+          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
+       }
+       dx -= mode->HDisplay;
+       if(!(pScrn->display->virtualY)) {
+          dy = max(i->VDisplay, j->VDisplay);
+       } else {
+	  dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
+       }
+       dy -= mode->VDisplay;
+       break;
+    }
+    mode->HDisplay += dx;
+    mode->HSyncStart += dx;
+    mode->HSyncEnd += dx;
+    mode->HTotal += dx;
+    mode->VDisplay += dy;
+    mode->VSyncStart += dy;
+    mode->VSyncEnd += dy;
+    mode->VTotal += dy;
+
+    mode->type = M_T_DEFAULT;
+#ifdef M_T_USERDEF
+    /* Set up as user defined (ie fake that the mode has been named in the
+     * Modes-list in the screen section; corrects cycling with CTRL-ALT-[-+]
+     * when source mode has not been listed there.)
+     */
+    mode->type |= M_T_USERDEF;
+#endif
+
+    /* Set the VRefresh field (in order to make RandR use it for the rates). We
+     * simply set this to the refresh rate for the CRT1 mode (since CRT2 will
+     * mostly be LCD or TV anyway).
+     */
+    mode->VRefresh = SiSCalcVRate(i);
+
+    if( ((mode->HDisplay * (pScrn->bitsPerPixel >> 3) * mode->VDisplay) > pSiS->maxxfbmem) ||
+	(mode->HDisplay > 4088) ||
+	(mode->VDisplay > 4096) ) {
+
+       if(!quiet) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		"Skipped \"%s\" (%dx%d), not enough video RAM or beyond hardware specs\n",
+		mode->name, mode->HDisplay, mode->VDisplay);
+       }
+       xfree(mode->Private);
+       xfree(mode);
+
+       return dest;
+    }
+
+    /* Find out whether we have at least one non-clone mode
+     * (in order to find out whether we enable pseudo-xinerama)
+     * and whether we have at least one mode which is not of
+     * "!" notation, ie follows the given CRT2Position. We need
+     * this for the Xinerama layout calculation.
+     */
+#ifdef SISXINERAMA
+    if(srel != sisClone) {
+       pSiS->AtLeastOneNonClone = TRUE;
+    }
+#endif
+
+    /* Now see if the resulting mode would be discarded as a "size" by the
+     * RandR extension and bump its clock in steps if 1000 in case it does.
+     */
+    if(dest) {
+       DisplayModePtr t = dest->next; /* Start with first mode (dest is last) */
+       do {
+          if((t->HDisplay == mode->HDisplay) &&
+	     (t->VDisplay == mode->VDisplay) &&
+	     ((int)(t->VRefresh + .5) == (int)(mode->VRefresh + .5))) {
+	     mode->VRefresh += 1000.0;
+	  }
+	  t = t->next;
+       } while((t) && (t != dest->next));
+    }
+
+    /* Provide a fake but unique DotClock in order to trick the vidmode
+     * extension to allow selecting among a number of modes whose merged result
+     * looks identical but consists of different modes for CRT1 and CRT2
+     */
+    mode->Clock = (int)(mode->VRefresh * 1000.0);
+
+    /* Generate a mode name */
+    sprintf(namebuffer, "%dx%d", mode->HDisplay, mode->VDisplay);
+    if((mode->name = xalloc(strlen(namebuffer) + 1))) {
+       strcpy(mode->name, namebuffer);
+    }
+
+    if(!quiet) {
+       Bool printname1 = TRUE, printname2 = TRUE;
+
+       sprintf(printbuffer, (srel == sisClone) ? "Cloned " : "Merged ");
+
+       sprintf(namebuf1, "%dx%d", i->HDisplay, i->VDisplay);
+       if((strcmp(namebuf1, i->name) == 0) ||
+          (strlen(i->name) > 90))
+          printname1 = FALSE;
+
+       sprintf(namebuf2, "%dx%d", j->HDisplay, j->VDisplay);
+       if((strcmp(namebuf2, j->name) == 0) ||
+          (strlen(j->name) > 90))
+          printname2 = FALSE;
+
+       if(printname1) {
+          strcat(printbuffer, "\"");
+          strcat(printbuffer, i->name);
+          strcat(printbuffer, "\" (");
+       }
+
+       strcat(printbuffer, namebuf1);
+
+       if(printname1) {
+          strcat(printbuffer, ")");
+       }
+
+       strcat(printbuffer, " and ");
+
+       if(printname2) {
+          strcat(printbuffer, "\"");
+          strcat(printbuffer, j->name);
+          strcat(printbuffer, "\" (");
+       }
+
+       strcat(printbuffer, namebuf2);
+
+       if(printname2) {
+          strcat(printbuffer, ")");
+       }
+
+       strcat(printbuffer, " to ");
+
+       sprintf(namebuf1, "%dx%d (%d)\n", mode->HDisplay, mode->VDisplay, (int)mode->VRefresh);
+
+       strcat(printbuffer, namebuf1);
+
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, printbuffer);
+    }
+
+    mode->next = mode;
+    mode->prev = mode;
+
+    if(dest) {
+       mode->next = dest->next; 	/* Insert node after "dest" */
+       dest->next->prev = mode;
+       mode->prev = dest;
+       dest->next = mode;
+    }
+
+    return mode;
+}
+
+/* Helper function to find a mode from a given name
+ * (Code base taken from mga driver)
+ */
+static DisplayModePtr
+SiSGetModeFromName(char* str, DisplayModePtr i)
+{
+    DisplayModePtr c = i;
+
+    if(!i)
+       return NULL;
+
+    do {
+       if(strcmp(str, c->name) == 0) return c;
+       c = c->next;
+    } while(c && c != i);
+
+    return NULL;
+}
+
+static DisplayModePtr
+SiSFindWidestTallestMode(DisplayModePtr i, Bool tallest)
+{
+    DisplayModePtr c = i, d = NULL;
+    int max = 0;
+
+    if(!i)
+       return NULL;
+
+    do {
+       if(tallest) {
+          if(c->VDisplay > max) {
+	     max = c->VDisplay;
+	     d = c;
+          }
+       } else {
+          if(c->HDisplay > max) {
+	     max = c->HDisplay;
+	     d = c;
+          }
+       }
+       c = c->next;
+    } while(c != i);
+
+    return d;
+}
+
+static void
+SiSFindWidestTallestCommonMode(DisplayModePtr i, DisplayModePtr j, Bool tallest,
+				DisplayModePtr *a, DisplayModePtr *b)
+{
+    DisplayModePtr c = i, d;
+    int max = 0;
+    Bool foundone;
+
+    (*a) = (*b) = NULL;
+
+    if(!i || !j)
+       return;
+
+    do {
+       d = j;
+       foundone = FALSE;
+       do {
+	  if( (c->HDisplay == d->HDisplay) &&
+	      (c->VDisplay == d->VDisplay) ) {
+	     foundone = TRUE;
+	     break;
+	  }
+	  d = d->next;
+       } while(d != j);
+       if(foundone) {
+	  if(tallest) {
+	     if(c->VDisplay > max) {
+		max = c->VDisplay;
+		(*a) = c;
+		(*b) = d;
+	     }
+	  } else {
+	     if(c->HDisplay > max) {
+		max = c->HDisplay;
+		(*a) = c;
+		(*b) = d;
+	     }
+	  }
+       }
+       c = c->next;
+    } while(c != i);
+}
+
+static DisplayModePtr
+SiSGenerateModeListFromLargestModes(ScrnInfoPtr pScrn,
+		    DisplayModePtr i, DisplayModePtr j,
+		    SiSScrn2Rel srel, Bool quiet)
+{
+#ifdef SISXINERAMA
+    SISPtr pSiS = SISPTR(pScrn);
+#endif
+    DisplayModePtr mode1 = NULL;
+    DisplayModePtr mode2 = NULL;
+    DisplayModePtr mode3 = NULL;
+    DisplayModePtr mode4 = NULL;
+    DisplayModePtr result = NULL;
+
+#ifdef SISXINERAMA
+    pSiS->AtLeastOneNonClone = FALSE;
+#endif
+
+    /* Now build a default list of MetaModes.
+     * - Non-clone: If the user enabled NonRectangular, we use the
+     * largest mode for each CRT1 and CRT2. If not, we use the largest
+     * common mode for CRT1 and CRT2 (if available). Additionally, and
+     * regardless if the above, we produce a clone mode consisting of
+     * the largest common mode (if available) in order to use DGA.
+     * - Clone: If the (global) CRT2Position is Clone, we use the
+     * largest common mode if available, otherwise the first two modes
+     * in each list.
+     */
+
+    switch(srel) {
+    case sisLeftOf:
+    case sisRightOf:
+       mode1 = SiSFindWidestTallestMode(i, FALSE);
+       mode2 = SiSFindWidestTallestMode(j, FALSE);
+       SiSFindWidestTallestCommonMode(i, j, FALSE, &mode3, &mode4);
+       break;
+    case sisAbove:
+    case sisBelow:
+       mode1 = SiSFindWidestTallestMode(i, TRUE);
+       mode2 = SiSFindWidestTallestMode(j, TRUE);
+       SiSFindWidestTallestCommonMode(i, j, TRUE, &mode3, &mode4);
+       break;
+    case sisClone:
+       SiSFindWidestTallestCommonMode(i, j, FALSE, &mode3, &mode4);
+       if(mode3 && mode4) {
+	  mode1 = mode3;
+	  mode2 = mode4;
+       } else {
+	  mode1 = i;
+	  mode2 = j;
+       }
+    }
+
+    if(srel != sisClone) {
+       if(mode3 && mode4 && !pSiS->NonRect) {
+	  mode1 = mode3;
+	  mode2 = mode2;
+       }
+    }
+
+    if(mode1 && mode2) {
+       result = SiSCopyModeNLink(pScrn, result, mode1, mode2, srel, quiet);
+    }
+
+    if(srel != sisClone) {
+       if(mode3 && mode4) {
+	  result = SiSCopyModeNLink(pScrn, result, mode3, mode4, sisClone, quiet);
+       }
+    }
+
+    return result;
+}
+
+/* Generate the merged-fb modelist from given metamodes
+ */
+static void
+SiSMetaModeParseError(ScrnInfoPtr pScrn, char *src, char *curr, char *lastcurr, Bool quiet)
+{
+    if(!quiet) {
+       char backup = *curr;
+       *curr = 0;
+       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		"Error parsing Metamodes at character no %d (near or in \"%s\")\n",
+		curr - src,
+		lastcurr);
+       *curr = backup;
+    }
+}
+
+
+static void
+SiSMetaModeBad(ScrnInfoPtr pScrn, int crtnum, char *modename,
+			char *metaname, char *metaend, Bool quiet)
+{
+    char backup;
+
+    if(!quiet) {
+       while((metaend != metaname) && (*metaend == ' ' || *metaend == ';')) {
+          metaend--;
+       }
+       metaend++;
+       backup = *metaend;
+       *metaend = 0;
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		"\"%s\" is not a supported mode for CRT%d, skipping \"%s\"\n",
+		modename, crtnum, metaname);
+       *metaend = backup;
+    }
+}
+
+static void
+SiSRemoveTrailingSpace(char *string)
+{
+   int idx = strlen(string);
+
+   while(idx) {
+      if(string[idx] == ' ') string[idx] = 0;
+      idx--;
+   };
+}
+
+static DisplayModePtr
+SiSParseMetaModes(ScrnInfoPtr pScrn, char *src,
+			DisplayModePtr i, DisplayModePtr j,
+			SiSScrn2Rel srel, Bool quiet)
+{
+#ifdef SISXINERAMA
+    SISPtr pSiS = SISPTR(pScrn);
+#endif
+    char *curr, *currend, *first, *second, *lastcurr;
+    int len;
+    SiSScrn2Rel connect;
+    Bool isend = FALSE;
+    char dstcrt1[256], dstcrt2[256];
+    DisplayModePtr mode1, mode2 = NULL, result = NULL;
+
+#ifdef SISXINERAMA
+    pSiS->AtLeastOneNonClone = FALSE;
+#endif
+
+    curr = src;
+
+    do {
+
+       first = dstcrt1;
+       second = dstcrt2;
+       connect = srel;
+
+       while(*curr == ' ' || 				/* remove leading spaces and other garbage */
+	     *curr == ';' ||
+	     *curr == ',' ||
+	     *curr == '-' ||
+	     *curr == '+') curr++;
+
+       lastcurr = curr;
+
+       if(*curr == 0) break;
+
+
+       currend = strpbrk(curr, " -,+;");		/* Find delimiter. If delimiting char */
+       if(!currend) {					/* not found, assume end of string as */
+	  currend = curr;				/* delimiter. */
+	  while(*currend) currend++;
+	  isend = TRUE;
+       }
+
+
+       if((currend - curr) == 0) {			/* Must have at least one mode here */
+	  SiSMetaModeParseError(pScrn, src, currend, lastcurr, quiet);
+	  break;
+       }
+
+       len = min((currend - curr), 255);
+       strncpy(first, curr, len);			/* Copy first mode name */
+       first[len] = 0;
+       curr = currend;
+
+       if(isend) {					/* If no more coming, this is a clone mode */
+
+	  strcpy(second, first);
+	  connect = sisClone;
+
+       } else {						/* Otherwise check what's coming next: */
+
+	  while(*curr == ' ') curr++;			/* Check the following non-space char */
+
+	  if(*curr == '-' ||
+	     *curr == '+' ||
+	     *curr == ',') {				/* If it's a mode delimiter, so be it: */
+
+	     if(*curr == '+') {
+		connect = sisClone;
+	     }
+	     curr++;
+	     while(*curr == ' ') curr++;		/*    Skip leading spaces */
+
+	     currend = strpbrk(curr, " ;");		/*    Find head delimiter. If delimiting char */
+	     if(!currend) {				/*    not found, assume end of string as */
+		currend = curr;				/*    delimiter. */
+		while(*currend) currend++;
+		isend = TRUE;
+	     }
+
+	     if((currend - curr) == 0) {
+
+		SiSMetaModeParseError(pScrn, src, currend, lastcurr, quiet);
+
+		strcpy(second, first);
+		connect = sisClone;
+
+	     } else {
+
+		len = min((currend - curr), 255);
+		strncpy(second, curr, len);		/*    Copy second mode name */
+		second[len] = 0;
+
+	     }
+
+	  } else {					/* Otherwise, it's a clone mode */
+
+	     currend = curr - 1;
+
+	     strcpy(second, first);
+	     connect = sisClone;
+
+	  }
+
+       }
+
+       curr = currend;
+
+       SiSRemoveTrailingSpace(first);
+       SiSRemoveTrailingSpace(second);
+
+       mode1 = SiSGetModeFromName(dstcrt1, i);
+       if(!mode1) {
+          SiSMetaModeBad(pScrn, 1, dstcrt1, lastcurr, currend, quiet);
+       } else {
+	  mode2 = SiSGetModeFromName(dstcrt2, j);
+          if(!mode2 && !quiet) {
+             SiSMetaModeBad(pScrn, 2, dstcrt2, lastcurr, currend, quiet);
+	  }
+       }
+
+       if(mode1 && mode2) {
+	  result = SiSCopyModeNLink(pScrn, result, mode1, mode2, connect, quiet);
+       }
+
+    } while (!isend);
+
+    return result;
+}
+
+static DisplayModePtr
+SiSGenerateModeList(ScrnInfoPtr pScrn, char* str,
+		    DisplayModePtr i, DisplayModePtr j,
+		    SiSScrn2Rel srel, Bool quiet)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   DisplayModePtr result;
+
+   if((str != NULL) &&
+      (result = SiSParseMetaModes(pScrn, str, i, j, srel, quiet))) {
+      return result;
+   } else {
+      if(!quiet) {
+         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	   "%s, linking %s modes by default\n",
+	   (str != NULL) ? "Bad MetaModes" : "No MetaModes given",
+	   (srel == sisClone) ? "largest common" :
+	      (pSiS->NonRect ?
+		(((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest" :  "tallest")
+		:
+		(((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest common" :  "tallest common")) );
+      }
+      return SiSGenerateModeListFromLargestModes(pScrn, i, j, srel, quiet);
+   }
+}
+
+static void
+SiSRecalcDefaultVirtualSize(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    DisplayModePtr mode, bmode;
+    int maxh, maxv;
+    static const char *str = "MergedFB: Virtual %s %d\n";
+    static const char *errstr = "Virtual %s to small for given CRT2Position offset\n";
+
+    mode = bmode = pScrn->modes;
+    maxh = maxv = 0;
+    do {
+       if(mode->HDisplay > maxh) maxh = mode->HDisplay;
+       if(mode->VDisplay > maxv) maxv = mode->VDisplay;
+       mode = mode->next;
+    } while(mode != bmode);
+
+    maxh += pSiS->CRT1XOffs + pSiS->CRT2XOffs;
+    maxv += pSiS->CRT1YOffs + pSiS->CRT2YOffs;
+
+    if(!(pScrn->display->virtualX)) {
+       if(maxh > 4088) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		"Virtual width with CRT2Position offset beyond hardware specs\n");
+	  pSiS->CRT1XOffs = pSiS->CRT2XOffs = 0;
+	  maxh -= (pSiS->CRT1XOffs + pSiS->CRT2XOffs);
+       }
+       pScrn->virtualX = maxh;
+       pScrn->displayWidth = maxh;
+       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "width", maxh);
+    } else {
+       if(maxh < pScrn->display->virtualX) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, errstr, "width");
+	  pSiS->CRT1XOffs = pSiS->CRT2XOffs = 0;
+       }
+    }
+
+    if(!(pScrn->display->virtualY)) {
+       pScrn->virtualY = maxv;
+       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "height", maxv);
+    } else {
+       if(maxv < pScrn->display->virtualY) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, errstr, "height");
+	  pSiS->CRT1YOffs = pSiS->CRT2YOffs = 0;
+       }
+    }
+}
+
+static void
+SiSMFBHandleCRT2DDCAndRanges(ScrnInfoPtr pScrn, Bool quiet)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    xf86MonPtr pMonitor = NULL;
+    static const char *ddcsstr = "CRT%d DDC monitor info: *******************************************\n";
+    static const char *ddcestr = "End of CRT%d DDC monitor info *************************************\n";
+
+    if(pSiS->CRT2HSync) {
+       pSiS->CRT2pScrn->monitor->nHsync =
+		SiSStrToRanges(pSiS->CRT2pScrn->monitor->hsync, pSiS->CRT2HSync, MAX_HSYNC);
+    }
+
+    if(pSiS->CRT2VRefresh) {
+       pSiS->CRT2pScrn->monitor->nVrefresh =
+		SiSStrToRanges(pSiS->CRT2pScrn->monitor->vrefresh, pSiS->CRT2VRefresh, MAX_VREFRESH);
+    }
+
+    pSiS->CRT2pScrn->monitor->DDC = NULL;
+
+    if((pMonitor = SiSInternalDDC(pSiS->CRT2pScrn, 1))) {
+
+       if(!quiet) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, 2);
+	  xf86PrintEDID(pMonitor);
+       }
+
+       pSiS->CRT2pScrn->monitor->DDC = pMonitor;
+
+       /* Now try to find out aspect ratio */
+       SiSFindAspect(pScrn, pMonitor, 2, FALSE);
+
+       if(!quiet) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, 2);
+       }
+
+       /* Use DDC data if no ranges in config file */
+       if(!pSiS->CRT2HSync) {
+	  pSiS->CRT2pScrn->monitor->nHsync = 0;
+       }
+       if(!pSiS->CRT2VRefresh) {
+	  pSiS->CRT2pScrn->monitor->nVrefresh = 0;
+       }
+
+    } else if(!quiet) {
+
+       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		"Failed to read DDC data for CRT2\n");
+
+    }
+}
+
+void
+SiSMFBInitMergedFB(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    static const char *crt2monname = "CRT2";
+
+    if(pSiS->MergedFB) {
+
+       pSiS->CRT2pScrn->monitor = xalloc(sizeof(MonRec));
+
+       if(pSiS->CRT2pScrn->monitor) {
+
+	  DisplayModePtr tempm = NULL, currentm = NULL, newm = NULL;
+
+	  /* Make a copy of CRT1's monitor, but clear DDC */
+	  memcpy(pSiS->CRT2pScrn->monitor, pScrn->monitor, sizeof(MonRec));
+	  pSiS->CRT2pScrn->monitor->id = (char *)crt2monname;
+	  pSiS->CRT2pScrn->monitor->DDC = NULL;
+
+	  /* Copy CRT1's monitor->modes. This is only done
+	   * to copy over the user-provided modelines and
+	   * for the case that the internal modes shall not
+	   * be used. (Usually, the default modes will be
+	   * replaced by our own later.)
+	   */
+	  pSiS->CRT2pScrn->monitor->Modes = NULL;
+	  tempm = pScrn->monitor->Modes;
+	  while(tempm) {
+	     if(!(newm = SiSDuplicateMode(tempm)))
+	        break;
+
+	     if(!pSiS->CRT2pScrn->monitor->Modes)
+		pSiS->CRT2pScrn->monitor->Modes = newm;
+
+	     if(currentm) {
+		currentm->next = newm;
+		newm->prev = currentm;
+	     }
+	     currentm = newm;
+	     tempm = tempm->next;
+	  }
+
+	  /* Read DDC and set up horizsync/vrefresh ranges */
+	  SiSMFBHandleCRT2DDCAndRanges(pScrn, FALSE);
+
+       } else {
+
+	  SISErrorLog(pScrn, "Failed to allocate memory for CRT2 monitor, MergedFB mode disabled.\n");
+	  if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
+	  pSiS->CRT2pScrn = NULL;
+	  pSiS->MergedFB = FALSE;
+
+       }
+    }
+}
+
+static void
+SiSFreeCRT2Structs(SISPtr pSiS)
+{
+    if(pSiS->CRT2pScrn) {
+       if(pSiS->CRT2pScrn->modes) {
+	  while(pSiS->CRT2pScrn->modes)
+	     xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
+       }
+       if(pSiS->CRT2pScrn->monitor) {
+	  if(pSiS->CRT2pScrn->monitor->Modes) {
+	     while(pSiS->CRT2pScrn->monitor->Modes)
+		xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
+	  }
+	  pSiS->CRT2pScrn->monitor->DDC = NULL;
+	  xfree(pSiS->CRT2pScrn->monitor);
+       }
+       xfree(pSiS->CRT2pScrn);
+       pSiS->CRT2pScrn = NULL;
+    }
+}
+
+static void
+SiSSetupModeListParmsCRT2(SISPtr pSiS, unsigned int VBFlags, unsigned int VBFlags3,
+		Bool *acceptcustommodes, Bool *includelcdmodes, Bool *isfordvi,
+		Bool *fakecrt2modes)
+{
+    (*acceptcustommodes) = TRUE;
+    (*includelcdmodes)   = TRUE;
+    (*isfordvi)          = FALSE;
+    (*fakecrt2modes)     = FALSE;
+
+    if(pSiS->VBFlags2 & VB2_SISTMDSBRIDGE) {
+       if(!(pSiS->VBFlags2 & VB2_30xBDH)) {
+          if(!(VBFlags & (CRT2_LCD|CRT2_VGA))) (*includelcdmodes) = FALSE;
+	  if(VBFlags & CRT2_LCD)               (*isfordvi)        = TRUE;
+	  /* See above for a remark on handling CRT2 = TV */
+       } else {
+	  if(VBFlags & (CRT2_LCD|CRT2_TV)) {
+	     (*includelcdmodes)   = FALSE;
+	     (*acceptcustommodes) = FALSE;
+	     (*fakecrt2modes)     = TRUE;
+	  }
+       }
+    } else {
+       (*includelcdmodes)   = FALSE;
+       (*acceptcustommodes) = FALSE;
+       if(VBFlags & (CRT2_LCD|CRT2_TV)) {
+          (*fakecrt2modes)  = TRUE;
+       }
+    }
+}
+
+static void
+SiSSetupClockRangesCRT2(ScrnInfoPtr pScrn, ClockRangePtr clockRanges, Bool quiet)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    clockRanges->next = NULL;
+    clockRanges->minClock = pSiS->MinClock;
+    clockRanges->maxClock = SiSMemBandWidth(pSiS->CRT2pScrn, TRUE, quiet);
+    clockRanges->clockIndex = -1;
+    clockRanges->interlaceAllowed = FALSE;
+    clockRanges->doubleScanAllowed = FALSE;
+    if(pSiS->VGAEngine == SIS_315_VGA) {
+       clockRanges->doubleScanAllowed = TRUE;
+    }
+}
+
+void
+SiSMFBHandleModesCRT2(ScrnInfoPtr pScrn, ClockRangePtr clockRanges)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    Bool acceptcustommodes;
+    Bool includelcdmodes;
+    Bool isfordvi;
+    Bool fakecrt2modes;
+    int i;
+
+    static const char *crtsetupstr = "*************************** CRT%d setup ***************************\n";
+    static const char *modesforstr = "Modes for CRT%d: **************************************************\n";
+    static const char *mergeddisstr = "MergedFB mode disabled";
+
+    if(pSiS->MergedFB) {
+
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 2);
+
+       SiSSetupClockRangesCRT2(pScrn, clockRanges, FALSE);
+
+       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock for CRT2 is %d MHz\n",
+                clockRanges->minClock / 1000);
+
+       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Max pixel clock for CRT2 is %d MHz\n",
+                clockRanges->maxClock / 1000);
+
+       SiSSetupModeListParmsCRT2(pSiS, pSiS->VBFlags, pSiS->VBFlags3,
+			&acceptcustommodes, &includelcdmodes, &isfordvi,
+			&fakecrt2modes);
+
+       pSiS->HaveCustomModes2 = FALSE;
+
+       if((pSiS->VGAEngine != SIS_315_VGA) || (!(pSiS->VBFlags2 & VB2_SISVGA2BRIDGE))) {
+          pSiS->SiS_Pr->SiS_UseWideCRT2 = 0;
+       }
+
+       if(!SiSMakeOwnModeList(pSiS->CRT2pScrn, acceptcustommodes, includelcdmodes,
+				isfordvi, &pSiS->HaveCustomModes2, FALSE /* fakecrt2modes */, TRUE )) {
+
+	  SISErrorLog(pScrn, "Building list of built-in modes for CRT2 failed, %s\n", mergeddisstr);
+	  SiSFreeCRT2Structs(pSiS);
+	  pSiS->MergedFB = FALSE;
+
+       } else {
+
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		 "Replaced %s mode list for CRT2 with built-in modes\n",
+		 pSiS->HaveCustomModes2 ? "default" : "entire");
+
+	  if((pSiS->VGAEngine == SIS_315_VGA) && (pSiS->VBFlags2 & VB2_SISVGA2BRIDGE)) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		 "Using %s widescreen modes for CRT2 VGA devices\n",
+		 pSiS->SiS_Pr->SiS_UseWideCRT2 ? "real" : "fake");
+	  }
+
+       }
+
+    }
+
+    if(pSiS->MergedFB) {
+
+       pointer backupddc = pSiS->CRT2pScrn->monitor->DDC;
+
+       /* Suppress bogus DDC warning */
+       if(SiSFixupHVRanges(pSiS->CRT2pScrn, 2, FALSE)) {
+          pSiS->CRT2pScrn->monitor->DDC = NULL;
+       }
+
+#if !defined(XORG_VERSION_CURRENT) && (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,5,0,0,0))
+       /* XFree86 4.5+ thinks it's smart to automatically
+        * add EDID modes to the monitor mode list - and
+        * it even does this in *Validate*Modes()!
+        * We do not like this if we discarded all default
+        * and user modes because they aren't suppored. Hence,
+        * we clear the DDC pointer in that case (and live
+        * with the disadvantage that we don't get any
+        * DDC warnings.)
+        */
+       if(!pSiS->HaveCustomModes2) {
+          pScrn->monitor->DDC = NULL;
+       }
+#endif
+
+       pSiS->CheckForCRT2 = TRUE;
+       i = xf86ValidateModes(pSiS->CRT2pScrn, pSiS->CRT2pScrn->monitor->Modes,
+			pSiS->CRT2pScrn->display->modes, clockRanges,
+			NULL, 256, 4088,
+			pSiS->CRT2pScrn->bitsPerPixel * 8, 128, 4096,
+			pScrn->display->virtualX ? pScrn->virtualX : 0,
+			pScrn->display->virtualY ? pScrn->virtualY : 0,
+			pSiS->maxxfbmem,
+			LOOKUP_BEST_REFRESH);
+       pSiS->CheckForCRT2 = FALSE;
+
+       pSiS->CRT2pScrn->monitor->DDC = backupddc;
+
+       if(i == -1) {
+	  SISErrorLog(pScrn, "xf86ValidateModes() error, %s\n", mergeddisstr);
+	  SiSFreeCRT2Structs(pSiS);
+	  pSiS->MergedFB = FALSE;
+       }
+
+    }
+
+    if(pSiS->MergedFB) {
+
+       SiSRemoveUnsuitableModes(pScrn, pSiS->CRT2pScrn->modes, "MergedFB", FALSE);
+
+       xf86PruneDriverModes(pSiS->CRT2pScrn);
+
+       if(i == 0 || pSiS->CRT2pScrn->modes == NULL) {
+	  SISErrorLog(pScrn, "No valid modes found for CRT2; %s\n", mergeddisstr);
+	  SiSFreeCRT2Structs(pSiS);
+	  pSiS->MergedFB = FALSE;
+       }
+
+    }
+
+    if(pSiS->MergedFB) {
+
+       xf86SetCrtcForModes(pSiS->CRT2pScrn, INTERLACE_HALVE_V);
+
+       /* Clear the modes' Private field */
+       SiSClearModesPrivate(pSiS->CRT2pScrn->modes);
+
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 2);
+
+       if(pSiS->VBFlags & (CRT2_LCD | CRT2_TV)) {
+	  SiSPrintModes(pSiS->CRT2pScrn, (pSiS->VBFlags2 & VB2_SISVGA2BRIDGE) ? TRUE : FALSE);
+       } else {
+	  xf86PrintModes(pSiS->CRT2pScrn);
+       }
+
+    }
+}
+
+void
+SiSMFBMakeModeList(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    if(pSiS->MergedFB) {
+
+       pSiS->CRT1Modes = pScrn->modes;
+       pSiS->CRT1CurrentMode = pScrn->currentMode;
+
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MergedFB: Generating mode list\n");
+
+       pScrn->modes = SiSGenerateModeList(pScrn, pSiS->MetaModes,
+					  pSiS->CRT1Modes, pSiS->CRT2pScrn->modes,
+					  pSiS->CRT2Position, FALSE);
+
+       if(!pScrn->modes) {
+
+	  SISErrorLog(pScrn, "Failed to parse MetaModes or no modes found. MergedFB mode disabled.\n");
+	  SiSFreeCRT2Structs(pSiS);
+	  pScrn->modes = pSiS->CRT1Modes;
+	  pSiS->CRT1Modes = NULL;
+	  pSiS->MergedFB = FALSE;
+
+       }
+
+    }
+}
+
+
+void
+SiSMFBCorrectVirtualAndLayout(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    if(pSiS->MergedFB) {
+
+       /* If no virtual dimension was given by the user,
+	* calculate a sane one now. Adapts pScrn->virtualX,
+	* pScrn->virtualY and pScrn->displayWidth.
+	*/
+       SiSRecalcDefaultVirtualSize(pScrn);
+
+       /* We get the last from GenerateModeList(), skip to first */
+       pScrn->modes = pScrn->modes->next;
+       pScrn->currentMode = pScrn->modes;
+
+       /* Update CurrentLayout */
+       pSiS->CurrentLayout.mode = pScrn->currentMode;
+       pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;
+       pSiS->CurrentLayout.displayHeight = pScrn->virtualY;
+
+    }
+}
+
+static void
+SiSMFBCalcDPI(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel, Bool quiet)
+{
+    SISPtr pSiS = SISPTR(pScrn1);
+    MessageType from = X_DEFAULT;
+    xf86MonPtr DDC1 = (xf86MonPtr)(pScrn1->monitor->DDC);
+    xf86MonPtr DDC2 = (xf86MonPtr)(pScrn2->monitor->DDC);
+    int ddcWidthmm = 0, ddcHeightmm = 0;
+    const char *dsstr = "MergedFB: Display dimensions: %dx%d mm\n";
+
+    /* This sets the DPI for MergedFB mode. The problem is that
+     * this can never be exact, because the output devices may
+     * have different dimensions. This function tries to compromise
+     * through a few assumptions, and it just calculates an average
+     * DPI value for both monitors.
+     */
+
+    /* Copy user-given DisplaySize (which should regard BOTH monitors!) */
+    pScrn1->widthmm = pScrn1->monitor->widthmm;
+    pScrn1->heightmm = pScrn1->monitor->heightmm;
+
+    if(monitorResolution > 0) {
+
+       /* Set command line given values (overrules given options) */
+       pScrn1->xDpi = monitorResolution;
+       pScrn1->yDpi = monitorResolution;
+       from = X_CMDLINE;
+
+    } else if(pSiS->MergedFBXDPI) {
+
+       /* Set option-wise given values (overrules DisplaySize config option) */
+       pScrn1->xDpi = pSiS->MergedFBXDPI;
+       pScrn1->yDpi = pSiS->MergedFBYDPI;
+       from = X_CONFIG;
+
+    } else if(pScrn1->widthmm > 0 || pScrn1->heightmm > 0) {
+
+       /* Set values calculated from given DisplaySize */
+       from = X_CONFIG;
+       if(pScrn1->widthmm > 0) {
+	  pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
+       }
+       if(pScrn1->heightmm > 0) {
+	  pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
+       }
+       if(!quiet) {
+          xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, pScrn1->widthmm, pScrn1->heightmm);
+       }
+
+    } else if(ddcWidthmm && ddcHeightmm) {
+
+       /* Set values from DDC-provided display size */
+
+       /* Get DDC display size; if only either CRT1 or CRT2 provided these,
+	* assume equal dimensions for both, otherwise add dimensions
+	*/
+       if( (DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) &&
+	   (DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0)) ) {
+	  ddcWidthmm = max(DDC1->features.hsize, DDC2->features.hsize) * 10;
+	  ddcHeightmm = max(DDC1->features.vsize, DDC2->features.vsize) * 10;
+	  switch(srel) {
+	  case sisLeftOf:
+	  case sisRightOf:
+	     ddcWidthmm = (DDC1->features.hsize + DDC2->features.hsize) * 10;
+	     break;
+	  case sisAbove:
+	  case sisBelow:
+	     ddcHeightmm = (DDC1->features.vsize + DDC2->features.vsize) * 10;
+	  default:
+	     break;
+	  }
+       } else if(DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) {
+	  ddcWidthmm = DDC1->features.hsize * 10;
+	  ddcHeightmm = DDC1->features.vsize * 10;
+	  switch(srel) {
+	  case sisLeftOf:
+	  case sisRightOf:
+	     ddcWidthmm *= 2;
+	     break;
+	  case sisAbove:
+	  case sisBelow:
+	     ddcHeightmm *= 2;
+	  default:
+	     break;
+          }
+       } else if(DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0) ) {
+	  ddcWidthmm = DDC2->features.hsize * 10;
+	  ddcHeightmm = DDC2->features.vsize * 10;
+	  switch(srel) {
+	  case sisLeftOf:
+	  case sisRightOf:
+	     ddcWidthmm *= 2;
+	     break;
+	  case sisAbove:
+	  case sisBelow:
+	     ddcHeightmm *= 2;
+	  default:
+	     break;
+	  }
+       }
+
+       from = X_PROBED;
+
+       if(!quiet) {
+          xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, ddcWidthmm, ddcHeightmm);
+       }
+
+       pScrn1->widthmm = ddcWidthmm;
+       pScrn1->heightmm = ddcHeightmm;
+       if(pScrn1->widthmm > 0) {
+	  pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
+       }
+       if(pScrn1->heightmm > 0) {
+	  pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
+       }
+
+    } else {
+
+       pScrn1->xDpi = pScrn1->yDpi = DEFAULT_DPI;
+
+    }
+
+    /* Sanity check */
+    if(pScrn1->xDpi > 0 && pScrn1->yDpi <= 0)
+       pScrn1->yDpi = pScrn1->xDpi;
+    if(pScrn1->yDpi > 0 && pScrn1->xDpi <= 0)
+       pScrn1->xDpi = pScrn1->yDpi;
+
+    pScrn2->xDpi = pScrn1->xDpi;
+    pScrn2->yDpi = pScrn1->yDpi;
+
+    if(!quiet) {
+       xf86DrvMsg(pScrn1->scrnIndex, from, "MergedFB: DPI set to (%d, %d)\n",
+		pScrn1->xDpi, pScrn1->yDpi);
+    }
+}
+
+void
+SiSMFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel)
+{
+    SISPtr pSiS = SISPTR(pScrn1);
+
+    SiSMFBCalcDPI(pScrn1, pScrn2, srel, FALSE);
+
+    pSiS->MergedDPISRel = srel;
+    pSiS->SiSMergedDPIVX = pScrn1->virtualX;
+    pSiS->SiSMergedDPIVY = pScrn1->virtualY;
+}
+
+#if defined(RANDR) && !defined(SIS_HAVE_RR_GET_MODE_MM)
+void
+SiSMFBResetDpi(ScrnInfoPtr pScrn, Bool force)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
+    SiSScrn2Rel srel = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position;
+
+    /* This does the same calculation for the DPI as
+     * the initial run. This means that an eventually
+     * given -dpi command line switch will lead to
+     * constant dpi values, regardless of the virtual
+     * screen size.
+     * I consider this consequent. If this is undesired,
+     * one should use the DisplaySize parameter in the
+     * config file instead of the command line switch.
+     * The DPI will be calculated then.
+     */
+
+    if(force						||
+       (pSiS->MergedDPISRel != srel)			||
+       (pSiS->SiSMergedDPIVX != pScrn->virtualX)	||
+       (pSiS->SiSMergedDPIVY != pScrn->virtualY)
+						) {
+
+       SiSMFBCalcDPI(pScrn, pSiS->CRT2pScrn, srel, TRUE);
+
+       pScreen->mmWidth = (pScrn->virtualX * 254 + pScrn->xDpi * 5) / (pScrn->xDpi * 10);
+       pScreen->mmHeight = (pScrn->virtualY * 254 + pScrn->yDpi * 5) / (pScrn->yDpi * 10);
+
+       pSiS->MergedDPISRel = srel;
+       pSiS->SiSMergedDPIVX = pScrn->virtualX;
+       pSiS->SiSMergedDPIVY = pScrn->virtualY;
+
+    }
+}
+#endif
+
+#ifdef SIS_HAVE_RR_GET_MODE_MM
+void
+SiSMFBCalcDPIPerMode(ScrnInfoPtr pScrn, DisplayModePtr mode,
+			int virtX, int virtY,
+			int *mmWidth, int *mmHeight)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+    int width = virtX, height = virtY;
+
+    if(pSiS->constantDPI) {
+
+       /* Provide clients with constant DPI values
+        * regardless of the screen size.
+        * DPI will always be what they were at
+        * server start.
+        */
+
+       if(mode) {
+          width = mode->HDisplay;
+          height = mode->VDisplay;
+       }
+       *mmWidth = (width * 254 + pScrn->xDpi * 5) / (pScrn->xDpi * 10);
+       *mmHeight = (height * 254 + pScrn->yDpi * 5) / (pScrn->yDpi * 10);
+
+    } else {
+
+       /* Let RandR mess with the DPI by leaving mmWidth/mmHeight
+        * alone.
+        * Exception: We need to take care of clone modes. They totally
+        * screw up the DPI (100 100 becomes 50 100 if switching from
+        * modes aside from each other to a clone mode).
+        *
+        * This might need some enhancement when growing the screen
+        * is supported in MergedFB mode (ie "ReserveLargeVirtual").
+        */
+       if(mode && (SiSMergedDisplayModePtr)mode->Private) {
+          if(((SiSMergedDisplayModePtr)mode->Private)->CRT2Position == sisClone) {
+             switch(pSiS->CRT2Position) {
+             case sisLeftOf:
+             case sisRightOf:
+                *mmWidth /= 2;
+                break;
+             case sisAbove:
+             case sisBelow:
+                *mmHeight /= 2;
+                break;
+             default:
+                break;
+             }
+          }
+       } else if(mode) {
+          ErrorF("Internal error: Apparent Metamode lacks private!\n");
+       }
+
+    }
+}
+#endif
+
+
+static Bool
+InRegion(int x, int y, region r)
+{
+    return (r.x0 <= x) && (x <= r.x1) && (r.y0 <= y) && (y <= r.y1);
+}
+
+
+void
+SISMFBPointerMoved(int scrnIndex, int x, int y)
+{
+    ScrnInfoPtr	pScrn1 = xf86Screens[scrnIndex];
+    SISPtr	pSiS = SISPTR(pScrn1);
+    ScrnInfoPtr	pScrn2 = pSiS->CRT2pScrn;
+    region	out, in1, in2, f2, f1;
+    int		deltax, deltay;
+    int		temp1, temp2;
+    int		old1x0, old1y0, old2x0, old2y0;
+    int		CRT1XOffs = 0, CRT1YOffs = 0, CRT2XOffs = 0, CRT2YOffs = 0;
+    int		MBXNR1XMAX = 65536, MBXNR1YMAX = 65536, MBXNR2XMAX = 65536, MBXNR2YMAX = 65536;
+    int		CRT1HDisplay, CRT1VDisplay, CRT2HDisplay, CRT2VDisplay;
+    int		HVirt = pScrn1->virtualX;
+    int		VVirt = pScrn1->virtualY;
+    int		sigstate;
+    Bool	doit = FALSE, HaveNonRect = FALSE, HaveOffsRegions = FALSE;
+    SiSScrn2Rel	srel = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position;
+
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->DGAactive) {
+       return;
+       /* DGA: There is no cursor and no panning while DGA is active. */
+       /* If it were, we would need to do: */
+       /* HVirt = pSiS->CurrentLayout.displayWidth;
+          VVirt = pSiS->CurrentLayout.displayHeight;
+          BOUND(x, pSiS->CurrentLayout.DGAViewportX, HVirt);
+          BOUND(y, pSiS->CurrentLayout.DGAViewportY, VVirt); */
+    } else {
+       CRT1XOffs = pSiS->CRT1XOffs;
+       CRT1YOffs = pSiS->CRT1YOffs;
+       CRT2XOffs = pSiS->CRT2XOffs;
+       CRT2YOffs = pSiS->CRT2YOffs;
+       HaveNonRect = pSiS->HaveNonRect;
+       HaveOffsRegions = pSiS->HaveOffsRegions;
+    }
+
+
+    /* Check if the pointer is inside our dead areas */
+    /* Only do this if the layout is somewhat in sync with
+     * the current display modes. We don't want regions
+     * which are visible but not accessible with the
+     * pointer.
+     */
+#ifdef SISXINERAMA
+    if(!SiSnoPanoramiXExtension							&&
+       (pSiS->MouseRestrictions)						&&
+       (srel != sisClone)) {
+       if(HaveNonRect) {
+	  if(InRegion(x, y, pSiS->NonRectDead)) {
+	     switch(srel) {
+	     case sisLeftOf:
+	     case sisRightOf: y = pSiS->NonRectDead.y0 - 1;
+			      doit = TRUE;
+			      break;
+	     case sisAbove:
+	     case sisBelow:   x = pSiS->NonRectDead.x0 - 1;
+			      doit = TRUE;
+	     default:	      break;
+	     }
+	  }
+       }
+       if(HaveOffsRegions) {
+	  if(InRegion(x, y, pSiS->OffDead1)) {
+	     switch(srel) {
+	     case sisLeftOf:
+	     case sisRightOf: y = pSiS->OffDead1.y1;
+			      doit = TRUE;
+			      break;
+	     case sisAbove:
+	     case sisBelow:   x = pSiS->OffDead1.x1;
+			      doit = TRUE;
+	     default:	      break;
+	     }
+	  } else if(InRegion(x, y, pSiS->OffDead2)) {
+	     switch(srel) {
+	     case sisLeftOf:
+	     case sisRightOf: y = pSiS->OffDead2.y0 - 1;
+			      doit = TRUE;
+			      break;
+	     case sisAbove:
+	     case sisBelow:   x = pSiS->OffDead2.x0 - 1;
+			      doit = TRUE;
+	     default:	      break;
+	     }
+	  }
+       }
+       if(doit) {
+	  UpdateCurrentTime();
+	  sigstate = xf86BlockSIGIO();
+	  miPointerAbsoluteCursor(x, y, currentTime.milliseconds);
+	  xf86UnblockSIGIO(sigstate);
+	  return;
+       }
+    }
+#endif
+
+    f1.x0 = old1x0 = pSiS->CRT1frameX0;
+    f1.x1 = pSiS->CRT1frameX1;
+    f1.y0 = old1y0 = pSiS->CRT1frameY0;
+    f1.y1 = pSiS->CRT1frameY1;
+    f2.x0 = old2x0 = pScrn2->frameX0;
+    f2.x1 = pScrn2->frameX1;
+    f2.y0 = old2y0 = pScrn2->frameY0;
+    f2.y1 = pScrn2->frameY1;
+
+    /* Define the outer region. Crossing this causes all frames to move */
+    out.x0 = pScrn1->frameX0;
+    out.x1 = pScrn1->frameX1;
+    out.y0 = pScrn1->frameY0;
+    out.y1 = pScrn1->frameY1;
+
+    /*
+     * Define the inner sliding window. Being outside both frames but
+     * inside the outer clipping window will slide corresponding frame
+     */
+    in1 = out;
+    in2 = out;
+    switch(srel) {
+    case sisLeftOf:
+       in1.x0 = f1.x0;
+       in2.x1 = f2.x1;
+       break;
+    case sisRightOf:
+       in1.x1 = f1.x1;
+       in2.x0 = f2.x0;
+       break;
+    case sisBelow:
+       in1.y1 = f1.y1;
+       in2.y0 = f2.y0;
+       break;
+    case sisAbove:
+       in1.y0 = f1.y0;
+       in2.y1 = f2.y1;
+       break;
+    case sisClone:
+       break;
+    }
+
+    deltay = 0;
+    deltax = 0;
+
+    if(InRegion(x, y, out)) {	/* inside outer region */
+
+       if(InRegion(x, y, in1) && !InRegion(x, y, f1)) {
+	  REBOUND(f1.x0, f1.x1, x);
+	  REBOUND(f1.y0, f1.y1, y);
+	  deltax = 1;
+       }
+       if(InRegion(x, y, in2) && !InRegion(x, y, f2)) {
+	  REBOUND(f2.x0, f2.x1, x);
+	  REBOUND(f2.y0, f2.y1, y);
+	  deltax = 1;
+       }
+
+    } else {			/* outside outer region */
+
+       if(out.x0 > x) {
+	  deltax = x - out.x0;
+       }
+       if(out.x1 < x) {
+	  deltax = x - out.x1;
+       }
+       if(deltax) {
+	  pScrn1->frameX0 += deltax;
+	  pScrn1->frameX1 += deltax;
+	  f1.x0 += deltax;
+	  f1.x1 += deltax;
+	  f2.x0 += deltax;
+	  f2.x1 += deltax;
+       }
+
+       if(out.y0 > y) {
+	  deltay = y - out.y0;
+       }
+       if(out.y1 < y) {
+	  deltay = y - out.y1;
+       }
+       if(deltay) {
+	  pScrn1->frameY0 += deltay;
+	  pScrn1->frameY1 += deltay;
+	  f1.y0 += deltay;
+	  f1.y1 += deltay;
+	  f2.y0 += deltay;
+	  f2.y1 += deltay;
+       }
+
+       switch(srel) {
+       case sisLeftOf:
+	  if(x >= f1.x0) { REBOUND(f1.y0, f1.y1, y); }
+	  if(x <= f2.x1) { REBOUND(f2.y0, f2.y1, y); }
+	  break;
+       case sisRightOf:
+	  if(x <= f1.x1) { REBOUND(f1.y0, f1.y1, y); }
+	  if(x >= f2.x0) { REBOUND(f2.y0, f2.y1, y); }
+	  break;
+       case sisBelow:
+	  if(y <= f1.y1) { REBOUND(f1.x0, f1.x1, x); }
+	  if(y >= f2.y0) { REBOUND(f2.x0, f2.x1, x); }
+	  break;
+       case sisAbove:
+	  if(y >= f1.y0) { REBOUND(f1.x0, f1.x1, x); }
+	  if(y <= f2.y1) { REBOUND(f2.x0, f2.x1, x); }
+	  break;
+       case sisClone:
+	  break;
+       }
+
+    }
+
+    if(deltax || deltay) {
+       pSiS->CRT1frameX0 = f1.x0;
+       pSiS->CRT1frameY0 = f1.y0;
+       pScrn2->frameX0 = f2.x0;
+       pScrn2->frameY0 = f2.y0;
+
+       CRT1HDisplay = CDMPTR->CRT1->HDisplay;
+       CRT1VDisplay = CDMPTR->CRT1->VDisplay;
+       CRT2HDisplay = CDMPTR->CRT2->HDisplay;
+       CRT2VDisplay = CDMPTR->CRT2->VDisplay;
+
+       switch(srel) {
+       case sisLeftOf:
+       case sisRightOf:
+	  if(CRT1YOffs || CRT2YOffs || HaveNonRect) {
+	     if(srel == sisLeftOf) {
+		if(pSiS->NonRectDead.x0 == 0) MBXNR2YMAX = pSiS->MBXNRYMAX;
+		else			      MBXNR1YMAX = pSiS->MBXNRYMAX;
+	     } else {
+		if(pSiS->NonRectDead.x0 == 0) MBXNR1YMAX = pSiS->MBXNRYMAX;
+		else			      MBXNR2YMAX = pSiS->MBXNRYMAX;
+	     }
+	     if(pSiS->CRT1frameY0 != old1y0) {
+		if(pSiS->CRT1frameY0 < CRT1YOffs)
+		   pSiS->CRT1frameY0 = CRT1YOffs;
+
+		temp1 = pSiS->CRT1frameY0 + CRT1VDisplay;
+		temp2 = min((VVirt - CRT2YOffs), (CRT1YOffs + MBXNR1YMAX));
+		if(temp1 > temp2)
+		   pSiS->CRT1frameY0 -= (temp1 - temp2);
+	     }
+	     if(pScrn2->frameY0 != old2y0) {
+		if(pScrn2->frameY0 < CRT2YOffs)
+		   pScrn2->frameY0 = CRT2YOffs;
+
+		temp1 = pScrn2->frameY0 + CRT2VDisplay;
+		temp2 = min((VVirt - CRT1YOffs), (CRT2YOffs + MBXNR2YMAX));
+		if(temp1 > temp2)
+		   pScrn2->frameY0 -= (temp1 - temp2);
+	     }
+	  }
+	  break;
+       case sisBelow:
+       case sisAbove:
+	  if(CRT1XOffs || CRT2XOffs || HaveNonRect) {
+	     if(srel == sisAbove) {
+		if(pSiS->NonRectDead.y0 == 0) MBXNR2XMAX = pSiS->MBXNRXMAX;
+		else			      MBXNR1XMAX = pSiS->MBXNRXMAX;
+	     } else {
+		if(pSiS->NonRectDead.y0 == 0) MBXNR1XMAX = pSiS->MBXNRXMAX;
+		else			      MBXNR2XMAX = pSiS->MBXNRXMAX;
+	     }
+	     if(pSiS->CRT1frameX0 != old1x0) {
+		if(pSiS->CRT1frameX0 < CRT1XOffs)
+		   pSiS->CRT1frameX0 = CRT1XOffs;
+
+		temp1 = pSiS->CRT1frameX0 + CRT1HDisplay;
+		temp2 = min((HVirt - CRT2XOffs), (CRT1XOffs + MBXNR1XMAX));
+		if(temp1 > temp2)
+		   pSiS->CRT1frameX0 -= (temp1 - temp2);
+	     }
+	     if(pScrn2->frameX0 != old2x0) {
+		if(pScrn2->frameX0 < CRT2XOffs)
+		   pScrn2->frameX0 = CRT2XOffs;
+
+		temp1 = pScrn2->frameX0 + CRT2HDisplay;
+		temp2 = min((HVirt - CRT1XOffs), (CRT2XOffs + MBXNR2XMAX));
+		if(temp1 > temp2)
+		   pScrn2->frameX0 -= (temp1 - temp2);
+	     }
+	  }
+	  break;
+       default:
+	  break;
+       }
+
+       pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CRT1HDisplay - 1;
+       pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CRT1VDisplay - 1;
+       pScrn2->frameX1   = pScrn2->frameX0   + CRT2HDisplay - 1;
+       pScrn2->frameY1   = pScrn2->frameY0   + CRT2VDisplay - 1;
+
+       /* No need to update pScrn1->frame?1, done above */
+
+       /* Need to go the official way to avoid hw access and
+        * to update Xv's overlays
+        */
+       (pScrn1->AdjustFrame)(scrnIndex, pScrn1->frameX0, pScrn1->frameY0, 0);
+    }
+}
+
+void
+SISMFBAdjustFrame(int scrnIndex, int x, int y, int flags)
+{
+    ScrnInfoPtr pScrn1 = xf86Screens[scrnIndex];
+    SISPtr pSiS = SISPTR(pScrn1);
+    ScrnInfoPtr pScrn2 = pSiS->CRT2pScrn;
+    int HTotal = pSiS->CurrentLayout.mode->HDisplay;
+    int VTotal = pSiS->CurrentLayout.mode->VDisplay;
+    int HMax = HTotal;
+    int VMax = VTotal;
+    int HVirt = pScrn1->virtualX;
+    int VVirt = pScrn1->virtualY;
+    int x1 = x, x2 = x;
+    int y1 = y, y2 = y;
+    int CRT1XOffs = 0, CRT1YOffs = 0, CRT2XOffs = 0, CRT2YOffs = 0;
+    int MBXNR1XMAX = 65536, MBXNR1YMAX = 65536, MBXNR2XMAX = 65536, MBXNR2YMAX = 65536;
+    int CRT1HDisplay, CRT1VDisplay, CRT2HDisplay, CRT2VDisplay;
+    SiSScrn2Rel srel = SDMPTR(pScrn1)->CRT2Position;
+
+    if(pSiS->DGAactive) {
+
+       HVirt = pSiS->CurrentLayout.displayWidth;
+       VVirt = pSiS->CurrentLayout.displayHeight;
+
+    } else {
+
+       CRT1XOffs = pSiS->CRT1XOffs;
+       CRT1YOffs = pSiS->CRT1YOffs;
+       CRT2XOffs = pSiS->CRT2XOffs;
+       CRT2YOffs = pSiS->CRT2YOffs;
+
+       if((srel != sisClone) && pSiS->HaveNonRect) {
+	  switch(srel) {
+	  case sisLeftOf:
+	     if(pSiS->NonRectDead.x0 == 0) MBXNR2YMAX = pSiS->MBXNRYMAX;
+	     else			   MBXNR1YMAX = pSiS->MBXNRYMAX;
+	     break;
+	  case sisRightOf:
+	     if(pSiS->NonRectDead.x0 == 0) MBXNR1YMAX = pSiS->MBXNRYMAX;
+	     else			   MBXNR2YMAX = pSiS->MBXNRYMAX;
+	     break;
+	  case sisAbove:
+	     if(pSiS->NonRectDead.y0 == 0) MBXNR2XMAX = pSiS->MBXNRXMAX;
+	     else			   MBXNR1XMAX = pSiS->MBXNRXMAX;
+	     break;
+	  case sisBelow:
+	     if(pSiS->NonRectDead.y0 == 0) MBXNR1XMAX = pSiS->MBXNRXMAX;
+	     else			   MBXNR2XMAX = pSiS->MBXNRXMAX;
+	     break;
+	  default:
+	     break;
+	  }
+       }
+
+
+    }
+
+    BOUND(x, 0, HVirt - HTotal);
+    BOUND(y, 0, VVirt - VTotal);
+
+    if(SDMPTR(pScrn1)->CRT2Position != sisClone) {
+       BOUND(x1, CRT1XOffs, min(HVirt, MBXNR1XMAX + CRT1XOffs) - min(HTotal, MBXNR1XMAX) - CRT2XOffs);
+       BOUND(y1, CRT1YOffs, min(VVirt, MBXNR1YMAX + CRT1YOffs) - min(VTotal, MBXNR1YMAX) - CRT2YOffs);
+       BOUND(x2, CRT2XOffs, min(HVirt, MBXNR2XMAX + CRT2XOffs) - min(HTotal, MBXNR2XMAX) - CRT1XOffs);
+       BOUND(y2, CRT2YOffs, min(VVirt, MBXNR2YMAX + CRT2YOffs) - min(VTotal, MBXNR2YMAX) - CRT1YOffs);
+    }
+
+    CRT1HDisplay = CDMPTR->CRT1->HDisplay;
+    CRT1VDisplay = CDMPTR->CRT1->VDisplay;
+    CRT2HDisplay = CDMPTR->CRT2->HDisplay;
+    CRT2VDisplay = CDMPTR->CRT2->VDisplay;
+
+    switch(srel) {
+    case sisLeftOf:
+       pScrn2->frameX0 = x2;
+       BOUND(pScrn2->frameY0,   y2, y2 + min(VMax, MBXNR2YMAX) - CRT2VDisplay);
+       pSiS->CRT1frameX0 = x1 + CRT2HDisplay;
+       BOUND(pSiS->CRT1frameY0, y1, y1 + min(VMax, MBXNR1YMAX) - CRT1VDisplay);
+       break;
+    case sisRightOf:
+       pSiS->CRT1frameX0 = x1;
+       BOUND(pSiS->CRT1frameY0, y1, y1 + min(VMax, MBXNR1YMAX) - CRT1VDisplay);
+       pScrn2->frameX0 = x2 + CRT1HDisplay;
+       BOUND(pScrn2->frameY0,   y2, y2 + min(VMax, MBXNR2YMAX) - CRT2VDisplay);
+       break;
+    case sisAbove:
+       BOUND(pScrn2->frameX0,   x2, x2 + min(HMax, MBXNR2XMAX) - CRT2HDisplay);
+       pScrn2->frameY0 = y2;
+       BOUND(pSiS->CRT1frameX0, x1, x1 + min(HMax, MBXNR1XMAX) - CRT1HDisplay);
+       pSiS->CRT1frameY0 = y1 + CRT2VDisplay;
+        break;
+    case sisBelow:
+       BOUND(pSiS->CRT1frameX0, x1, x1 + min(HMax, MBXNR1XMAX) - CRT1HDisplay);
+       pSiS->CRT1frameY0 = y1;
+       BOUND(pScrn2->frameX0,   x2, x2 + min(HMax, MBXNR2XMAX) - CRT2HDisplay);
+       pScrn2->frameY0 = y2 + CRT1VDisplay;
+       break;
+    case sisClone:
+       BOUND(pSiS->CRT1frameX0, x,  x + HMax - CRT1HDisplay);
+       BOUND(pSiS->CRT1frameY0, y,  y + VMax - CRT1VDisplay);
+       BOUND(pScrn2->frameX0,   x,  x + HMax - CRT2HDisplay);
+       BOUND(pScrn2->frameY0,   y,  y + VMax - CRT2VDisplay);
+       break;
+    }
+
+    BOUND(pSiS->CRT1frameX0, 0, HVirt - CRT1HDisplay);
+    BOUND(pSiS->CRT1frameY0, 0, VVirt - CRT1VDisplay);
+    BOUND(pScrn2->frameX0,   0, HVirt - CRT2HDisplay);
+    BOUND(pScrn2->frameY0,   0, VVirt - CRT2VDisplay);
+
+    pScrn1->frameX0 = x;
+    pScrn1->frameY0 = y;
+
+    pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CRT1HDisplay - 1;
+    pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CRT1VDisplay - 1;
+    pScrn2->frameX1   = pScrn2->frameX0   + CRT2HDisplay - 1;
+    pScrn2->frameY1   = pScrn2->frameY0   + CRT2VDisplay - 1;
+
+    pScrn1->frameX1 = pScrn1->frameX0 - 1;
+    pScrn1->frameY1 = pScrn1->frameY0 - 1;
+    pScrn1->frameX1 += pSiS->CurrentLayout.mode->HDisplay;
+    pScrn1->frameY1 += pSiS->CurrentLayout.mode->VDisplay;
+
+    if(SDMPTR(pScrn1)->CRT2Position != sisClone) {
+       pScrn1->frameX1 += CRT1XOffs + CRT2XOffs;
+       pScrn1->frameY1 += CRT1YOffs + CRT2YOffs;
+    }
+
+    SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
+    SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
+}
+
+/* Pseudo-Xinerama extension for MergedFB mode */
+#ifdef SISXINERAMA
+
+#define SIS_XINERAMA_MAJOR_VERSION  1
+#define SIS_XINERAMA_MINOR_VERSION  2
+
+/* ---------- stuff to be made public ------------ */
+
+/* If server's xinerama is pre-1.2, we need to defined these */
+
+#ifndef X_XineramaSelectInput
+#define X_XineramaSelectInput 6
+#endif
+
+#ifndef sz_xXineramaSelectInputReq
+typedef struct {
+	CARD8   reqType;
+	CARD8   panoramiXReqType;
+	CARD16  length B16;
+	CARD32  window B32;		/* window requesting notification */
+	CARD16  enable B16;
+	CARD16  pad2 B16;
+} xXineramaSelectInputReq;
+#define sz_xXineramaSelectInputReq 12
+#endif
+
+#ifndef XineramaLayoutChangeNotifyMask
+#define XineramaLayoutChangeNotifyMask  (1L << 0)
+#endif
+
+#ifndef XineramaLayoutChangeNotify
+#define XineramaLayoutChangeNotify	0
+#endif
+
+/*
+ * Each window has a list of clients requesting
+ * XineramaNotify events. Each client has a resource
+ * for each window it selects XineramaNotify input for,
+ * this resource is used to delete the XineramaNotifyRec
+ * entry from the per-window queue.
+ */
+
+#ifndef sz_xXineramaLayoutChangeNotifyEvent
+typedef struct {
+	CARD8 type;			/* always evBase + LayoutChangeNotify */
+	CARD8 pad1;
+	CARD16 sequenceNumber B16;
+	CARD32 window B32;		/* window requesting notification */
+} xXineramaLayoutChangeNotifyEvent;
+#define sz_xXineramaLayoutChangeNotifyEvent 8
+#endif
+
+/* ------- end of public stuff --------- */
+
+typedef struct _SiSXineramaEvent *SiSXineramaEventPtr;
+
+typedef struct _SiSXineramaEvent {
+    SiSXineramaEventPtr  next;
+    ClientPtr	client;
+    WindowPtr	window;
+    XID		clientResource;
+    int		mask;
+} SiSXineramaEventRec;
+
+static RESTYPE ClientType, EventType;
+static int SiSXineramaEventbase;
+static int SiSXineramaClientsListening;
+
+static int
+SiSTellChanged(WindowPtr pWin, pointer value)
+{
+    SiSXineramaEventPtr			*pHead, pXineramaEvent;
+    ClientPtr				client;
+    xXineramaLayoutChangeNotifyEvent	se;
+
+    pHead = (SiSXineramaEventPtr *)LookupIDByType(pWin->drawable.id, EventType);
+    if(!pHead) {
+       return WT_WALKCHILDREN;
+    }
+
+    se.type = XineramaLayoutChangeNotify + SiSXineramaEventbase;
+    se.window = pWin->drawable.id;
+
+    for(pXineramaEvent = *pHead; pXineramaEvent; pXineramaEvent = pXineramaEvent->next) {
+       client = pXineramaEvent->client;
+       if(client == serverClient || client->clientGone)
+	  continue;
+       se.sequenceNumber = client->sequence;
+       if(pXineramaEvent->mask & XineramaLayoutChangeNotifyMask) {
+	  WriteEventsToClient(client, 1, (xEvent *)&se);
+       }
+    }
+
+    return WT_WALKCHILDREN;
+}
+
+void
+SiSUpdateXineramaScreenInfo(ScrnInfoPtr pScrn1)
+{
+    SISPtr pSiS = SISPTR(pScrn1);
+    ScreenPtr pScreen = screenInfo.screens[pScrn1->scrnIndex];
+    int crt1scrnnum, crt2scrnnum;
+    int x1 = 0, x2 = 0, y1 = 0, y2 = 0, h1 = 0, h2 = 0, w1 = 0, w2 = 0;
+    int currH1 = 0, currH2 = 0, currV1 = 0, currV2 = 0;
+    int virtualX, virtualY, realvirtX, realvirtY;
+    DisplayModePtr currentMode, firstMode;
+    Bool infochanged = FALSE;
+    Bool usenonrect = pSiS->NonRect;
+    SiSScrn2Rel currSRel, srel = pSiS->CRT2Position;
+    const char *rectxine = "\t... setting up rectangular Xinerama layout\n";
+
+    pSiS->MBXNRXMAX = pSiS->MBXNRYMAX = 65536;
+    pSiS->HaveNonRect = pSiS->HaveOffsRegions = FALSE;
+
+    if(!pSiS->MergedFB		||
+       SiSnoPanoramiXExtension	||
+       !SiSXineramadataPtr	||
+       !pScrn1->modes)
+       return;
+
+    /* Note: Usage of RandR may lead to virtual X and Y dimensions
+     * actually smaller than our MetaModes. To avoid this, we calculate
+     * the maxCRT fields here (and not somewhere else, like in CopyNLink)
+     *
+     * *** Note: RandR is disabled if one of CRTxxOffs is non-zero.
+     */
+
+    /* "Real" virtual: Virtual without the Offset */
+    realvirtX = pScrn1->virtualX - pSiS->CRT1XOffs - pSiS->CRT2XOffs;
+    realvirtY = pScrn1->virtualY - pSiS->CRT1YOffs - pSiS->CRT2YOffs;
+
+    currentMode = pSiS->CurrentLayout.mode;
+
+    /* Get the current display mode's dimensions */
+    currH1 = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1->HDisplay;
+    currV1 = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1->VDisplay;
+    currH2 = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2->HDisplay;
+    currV2 = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2->VDisplay;
+    currSRel = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2Position;
+
+    /* Determine whether or not to recalculate the layout.
+     * We provide Xinerama 1.2 which allows clients to listen to
+     * XineramaLayoutChanged events. Since this is new and it will
+     * take time until window managers know of and use this technique,
+     * we check whether or not any client (which is supposed to be a
+     * window manager) actually listens to this event and only behave
+     * Xinerama 1.2 compliant (ie recalc our layout on any relevant
+     * display mode changes) if that is the case.
+     * For Xinerama 1.1 aware clients (ie: no client is listening
+     * to our 1.2 events), there is no mechanism for informing them
+     * about layout changes. Modern window managers, however, seem
+     * to re-query the Xinerama extension upon RandR events. Still,
+     * simple display mode changes without a screen resize/rotation
+     * change are not noticed by clients.
+     * So, if there is nobody listening to our 1.2 events, there is
+     * no point in updating our layout unless a RandR event is
+     * triggered at the same time (which is the case if size or
+     * rotation is changed).
+     *
+     * Note that the dead (inaccessible) areas are re-calculated in
+     * any case.
+     */
+
+    if( (pSiS->SiSXineramaVX != pScrn1->virtualX)	||
+        (pSiS->SiSXineramaVY != pScrn1->virtualY)
+							) {
+
+
+	  pSiS->maxCRT1_X1 = pSiS->maxCRT1_X2 = pSiS->maxCRT1_Y1 = pSiS->maxCRT1_Y2 = 0;
+	  pSiS->maxCRT2_X1 = pSiS->maxCRT2_X2 = pSiS->maxCRT2_Y1 = pSiS->maxCRT2_Y2 = 0;
+	  pSiS->maxClone_X1 = pSiS->maxClone_X2 = pSiS->maxClone_Y1 =  pSiS->maxClone_Y2 = 0;
+
+	  currentMode = firstMode = pScrn1->modes;
+
+	  do {
+
+	     DisplayModePtr p = currentMode->next;
+	     DisplayModePtr i = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1;
+	     DisplayModePtr j = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2;
+	     SiSScrn2Rel srelc = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2Position;
+	     int limitX, limitY;
+
+	     limitX = realvirtX;
+	     limitY = realvirtY;
+
+	     if((currentMode->HDisplay <= limitX) &&
+		(currentMode->VDisplay <= limitY) &&
+		(i->HDisplay <= limitX) &&
+		(j->HDisplay <= limitX) &&
+		(i->VDisplay <= limitY) &&
+		(j->VDisplay <= limitY)) {
+
+		int ih = i->HDisplay, iv = i->VDisplay;
+		int jh = j->HDisplay, jv = j->VDisplay;
+
+		if(srelc != sisClone) {
+
+		   /* What we do here is essentially calculating maximum values
+		    * of modes used [LEFT | RIGHT | UP | DOWN] and - despite the
+		    * variable naming - not what's displayed on the specific CRTC
+		    * channels.
+		    */
+
+		   if(pSiS->maxCRT1_X1 == ih) {
+		      if(pSiS->maxCRT1_X2 < jh) {
+			 pSiS->maxCRT1_X2 = jh;   /* Widest CRT2 mode displayed with widest CRT1 mode */
+		      }
+		   } else if(pSiS->maxCRT1_X1 < ih) {
+		      pSiS->maxCRT1_X1 = ih;      /* Widest CRT1 mode */
+		      pSiS->maxCRT1_X2 = jh;
+		   }
+
+		   if(pSiS->maxCRT2_X2 == jh) {
+		      if(pSiS->maxCRT2_X1 < ih) {
+			 pSiS->maxCRT2_X1 = ih;   /* Widest CRT1 mode displayed with widest CRT2 mode */
+		      }
+		   } else if(pSiS->maxCRT2_X2 < jh) {
+		      pSiS->maxCRT2_X2 = jh;      /* Widest CRT2 mode */
+		      pSiS->maxCRT2_X1 = ih;
+		   }
+
+		   if(pSiS->maxCRT1_Y1 == iv) {   /* Same as above, but tallest instead of widest */
+		      if(pSiS->maxCRT1_Y2 < jv) {
+			 pSiS->maxCRT1_Y2 = jv;
+		      }
+		   } else if(pSiS->maxCRT1_Y1 < iv) {
+		      pSiS->maxCRT1_Y1 = iv;
+		      pSiS->maxCRT1_Y2 = jv;
+		   }
+
+		   if(pSiS->maxCRT2_Y2 == jv) {
+		      if(pSiS->maxCRT2_Y1 < iv) {
+			 pSiS->maxCRT2_Y1 = iv;
+		      }
+		   } else if(pSiS->maxCRT2_Y2 < jv) {
+		      pSiS->maxCRT2_Y2 = jv;
+		      pSiS->maxCRT2_Y1 = iv;
+		   }
+
+		} else {
+
+		   if(pSiS->maxClone_X1 < ih) {
+		      pSiS->maxClone_X1 = ih;
+		   }
+		   if(pSiS->maxClone_X2 < jh) {
+		      pSiS->maxClone_X2 = jh;
+		   }
+		   if(pSiS->maxClone_Y1 < iv) {
+		      pSiS->maxClone_Y1 = iv;
+		   }
+		   if(pSiS->maxClone_Y2 < jv) {
+		      pSiS->maxClone_Y2 = jv;
+		   }
+
+		}
+	     }
+
+	     currentMode = p;
+
+	  } while((currentMode) && (currentMode != firstMode));
+
+       infochanged = TRUE;
+
+       pSiS->SiSXineramaVX = pScrn1->virtualX;
+       pSiS->SiSXineramaVY = pScrn1->virtualY;
+
+
+       pSiS->XineSRel = srel;
+
+    }
+
+    srel = pSiS->XineSRel;
+
+    /* Determine if we should set up dead areas (ie make a non-rectangular layout) */
+    if((usenonrect) && (srel != sisClone) && pSiS->maxCRT1_X1) {
+
+       switch(srel) {
+       case sisLeftOf:
+       case sisRightOf:
+	  if((pSiS->maxCRT1_Y1 != realvirtY) && (pSiS->maxCRT2_Y2 != realvirtY)) {
+	     usenonrect = FALSE;
+	  }
+	  break;
+       case sisAbove:
+       case sisBelow:
+	  if((pSiS->maxCRT1_X1 != realvirtX) && (pSiS->maxCRT2_X2 != realvirtX)) {
+	     usenonrect = FALSE;
+	  }
+       default:
+	  break;
+       }
+
+       if(infochanged && !usenonrect) {
+	  xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+			"Current screen size does not match maximum display modes...\n");
+	  xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb, rectxine);
+       }
+
+    } else if(infochanged && usenonrect) {
+
+       usenonrect = FALSE;
+       xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+		"Only clone modes available for this screen size...\n");
+       xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb, rectxine);
+
+    }
+
+    if(pSiS->maxCRT1_X1) {		/* We have at least one non-clone mode */
+
+       /* Use the virtuals from pScrn here; we need absolute
+        * numbers, not the "relative" ones in realVirtual.
+        */
+       virtualX = pScrn1->virtualX;
+       virtualY = pScrn1->virtualY;
+
+       switch(srel) {
+
+       case sisRightOf:
+	  x1 = 0;
+	  w1 = max(pSiS->maxCRT1_X1, virtualX - pSiS->maxCRT1_X2);
+	  if(w1 > virtualX) w1 = virtualX;
+
+	  x2 = min(pSiS->maxCRT2_X1, virtualX - pSiS->maxCRT2_X2);
+	  if(x2 < 0) x2 = 0;
+
+	  /* Avoid overlapping xinerama screens: If the current mode
+	   * fills entire virtual, we use the current mode dimensions
+	   * as screen limits instead of the data calculated above.
+	   * (Can use virtualX instead if realVirtualX here, it is the
+	   * same.)
+	   */
+	  if((x1 + w1) > x2) {
+	     if(currH1 + currH2 == virtualX) {
+		w1 = x2 = currH1;
+	     }
+	  }
+
+	  w2 = virtualX - x2;
+
+	  y1 = pSiS->CRT1YOffs;
+	  h1 = realvirtY;
+
+	  y2 = pSiS->CRT2YOffs;
+	  h2 = realvirtY;
+
+	  break;
+
+       case sisLeftOf:
+	  x1 = min(pSiS->maxCRT1_X2, virtualX - pSiS->maxCRT1_X1);
+	  if(x1 < 0) x1 = 0;
+
+	  x2 = 0;
+	  w2 = max(pSiS->maxCRT2_X2, virtualX - pSiS->maxCRT2_X1);
+	  if(w2 > virtualX) w2 = virtualX;
+
+	  if((x2 + w2) > x1) {
+	     if(currH1 + currH2 == virtualX) {
+		w2 = x1 = currH2;
+	     }
+	  }
+
+	  w1 = virtualX - x1;
+
+	  y1 = pSiS->CRT1YOffs;
+	  h1 = realvirtY;
+
+	  y2 = pSiS->CRT2YOffs;
+	  h2 = realvirtY;
+
+	  break;
+
+       case sisBelow:
+	  x1 = pSiS->CRT1XOffs;
+	  w1 = realvirtX;
+
+	  x2 = pSiS->CRT2XOffs;
+	  w2 = realvirtX;
+
+	  y1 = 0;
+	  h1 = max(pSiS->maxCRT1_Y1, virtualY - pSiS->maxCRT1_Y2);
+	  if(h1 > virtualY) h1 = virtualY;
+
+	  y2 = min(pSiS->maxCRT2_Y1, virtualY - pSiS->maxCRT2_Y2);
+	  if(y2 < 0) y2 = 0;
+
+	  if((y1 + h1) > y2) {
+	     if(currV1 + currV2 == virtualY) {
+		h1 = y2 = currV1;
+	     }
+	  }
+
+	  h2 = virtualY - y2;
+
+	  break;
+
+       case sisAbove:
+	  x1 = pSiS->CRT1XOffs;
+	  w1 = realvirtX;
+
+	  x2 = pSiS->CRT2XOffs;
+	  w2 = realvirtX;
+
+	  y1 = min(pSiS->maxCRT1_Y2, virtualY - pSiS->maxCRT1_Y1);
+	  if(y1 < 0) y1 = 0;
+
+	  y2 = 0;
+	  h2 = max(pSiS->maxCRT2_Y2, virtualY - pSiS->maxCRT2_Y1);
+	  if(h2 > virtualY) h2 = virtualY;
+
+	  if((y2 + h2) > y1) {
+	     if(currV1 + currV2 == virtualY) {
+		h2 = y1 = currV2;
+	     }
+	  }
+
+	  h1 = virtualY - y1;
+
+	  break;
+
+       default:
+	  break;
+       }
+
+       /* Calculate dead areas */
+       switch(srel) {
+
+       case sisLeftOf:
+       case sisRightOf:
+	  if(usenonrect) {
+	     if(pSiS->maxCRT1_Y1 != realvirtY) {
+	        h1 = pSiS->MBXNRYMAX = pSiS->maxCRT1_Y1;
+	        pSiS->NonRectDead.x0 = x1;
+	        pSiS->NonRectDead.x1 = x1 + w1 - 1;
+	        pSiS->NonRectDead.y0 = y1 + h1;
+	        pSiS->NonRectDead.y1 = virtualY - 1;
+	        pSiS->HaveNonRect = TRUE;
+	     } else if(pSiS->maxCRT2_Y2 != realvirtY) {
+	        h2 = pSiS->MBXNRYMAX = pSiS->maxCRT2_Y2;
+	        pSiS->NonRectDead.x0 = x2;
+	        pSiS->NonRectDead.x1 = x2 + w2 - 1;
+	        pSiS->NonRectDead.y0 = y2 + h2;
+	        pSiS->NonRectDead.y1 = virtualY - 1;
+	        pSiS->HaveNonRect = TRUE;
+	     }
+	  }
+
+	  if(pSiS->CRT1YOffs) {
+	     pSiS->OffDead1.x0 = x1;
+	     pSiS->OffDead1.x1 = x1 + w1 - 1;
+	     pSiS->OffDead1.y0 = 0;
+	     pSiS->OffDead1.y1 = y1 - 1;
+	     pSiS->OffDead2.x0 = x2;
+	     pSiS->OffDead2.x1 = x2 + w2 - 1;
+	     pSiS->OffDead2.y0 = y2 + h2;
+	     pSiS->OffDead2.y1 = virtualY - 1;
+	     pSiS->HaveOffsRegions = TRUE;
+	  } else if(pSiS->CRT2YOffs) {
+	     pSiS->OffDead1.x0 = x2;
+	     pSiS->OffDead1.x1 = x2 + w2 - 1;
+	     pSiS->OffDead1.y0 = 0;
+	     pSiS->OffDead1.y1 = y2 - 1;
+	     pSiS->OffDead2.x0 = x1;
+	     pSiS->OffDead2.x1 = x1 + w1 - 1;
+	     pSiS->OffDead2.y0 = y1 + h1;
+	     pSiS->OffDead2.y1 = virtualY - 1;
+	     pSiS->HaveOffsRegions = TRUE;
+	  }
+	  break;
+
+       case sisAbove:
+       case sisBelow:
+	  if(usenonrect) {
+	     if(pSiS->maxCRT1_X1 != realvirtX) {
+		w1 = pSiS->MBXNRXMAX = pSiS->maxCRT1_X1;
+		pSiS->NonRectDead.x0 = x1 + w1;
+		pSiS->NonRectDead.x1 = virtualX - 1;
+		pSiS->NonRectDead.y0 = y1;
+		pSiS->NonRectDead.y1 = y1 + h1 - 1;
+		pSiS->HaveNonRect = TRUE;
+	     } else if(pSiS->maxCRT2_X2 != realvirtX) {
+		w2 = pSiS->MBXNRXMAX = pSiS->maxCRT2_X2;
+		pSiS->NonRectDead.x0 = x2 + w2;
+		pSiS->NonRectDead.x1 = virtualX - 1;
+		pSiS->NonRectDead.y0 = y2;
+		pSiS->NonRectDead.y1 = y2 + h2 - 1;
+		pSiS->HaveNonRect = TRUE;
+	     }
+	  }
+
+	  if(pSiS->CRT1XOffs) {
+	     pSiS->OffDead1.x0 = x2 + w2;
+	     pSiS->OffDead1.x1 = virtualX - 1;
+	     pSiS->OffDead1.y0 = y2;
+	     pSiS->OffDead1.y1 = y2 + h2 - 1;
+	     pSiS->OffDead2.x0 = 0;
+	     pSiS->OffDead2.x1 = x1 - 1;
+	     pSiS->OffDead2.y0 = y1;
+	     pSiS->OffDead2.y1 = y1 + h1 - 1;
+	     pSiS->HaveOffsRegions = TRUE;
+	  } else if(pSiS->CRT2XOffs) {
+	     pSiS->OffDead1.x0 = x1 + w1;
+	     pSiS->OffDead1.x1 = virtualX - 1;
+	     pSiS->OffDead1.y0 = y1;
+	     pSiS->OffDead1.y1 = y1 + h1 - 1;
+	     pSiS->OffDead2.x0 = 0;
+	     pSiS->OffDead2.x1 = x2 - 1;
+	     pSiS->OffDead2.y0 = y2;
+	     pSiS->OffDead2.y1 = y2 + h2 - 1;
+	     pSiS->HaveOffsRegions = TRUE;
+	  }
+       default:
+	  break;
+       }
+
+    } else {	/* Only clone-modes left */
+
+       x1 = x2 = 0;
+       y1 = y2 = 0;
+       w1 = w2 = max(pSiS->maxClone_X1, pSiS->maxClone_X2);
+       h1 = h2 = max(pSiS->maxClone_Y1, pSiS->maxClone_Y2);
+
+    }
+
+    /* Now let's think about the screen number: */
+
+    crt1scrnnum = -1;
+    switch(srel) {
+    case sisRightOf:	/* MFBScr0LR: TRUE = Left is 0, FALSE = Right is 0 */
+       if(pSiS->MFBScr0LR != -1) {
+          crt1scrnnum = (pSiS->MFBScr0LR) ? 0 : 1;
+       }
+       break;
+    case sisLeftOf:
+       if(pSiS->MFBScr0LR != -1) {
+          crt1scrnnum = (pSiS->MFBScr0LR) ? 1 : 0;
+       }
+       break;
+    case sisBelow:	/* MFBScr0TB: TRUE = Top is 0, FALSE = Bottom is 0 */
+       if(pSiS->MFBScr0TB != -1) {
+          crt1scrnnum = (pSiS->MFBScr0TB) ? 0 : 1;
+       }
+       break;
+    case sisAbove:
+       if(pSiS->MFBScr0TB != -1) {
+          crt1scrnnum = (pSiS->MFBScr0TB) ? 1 : 0;
+       }
+    default:
+       break;
+    }
+
+    if(crt1scrnnum == -1) {
+
+       crt1scrnnum = 0;
+
+       if(pSiS->CRT2IsScrn0) {
+          crt1scrnnum = 1;
+       }
+
+    }
+
+    crt2scrnnum = crt1scrnnum ^ 1;
+
+    if((SiSXineramadataPtr[crt1scrnnum].x == x1) &&
+       (SiSXineramadataPtr[crt1scrnnum].y == y1) &&
+       (SiSXineramadataPtr[crt1scrnnum].width == w1) &&
+       (SiSXineramadataPtr[crt1scrnnum].height == h1) &&
+       (SiSXineramadataPtr[crt2scrnnum].x == x2) &&
+       (SiSXineramadataPtr[crt2scrnnum].y == y2) &&
+       (SiSXineramadataPtr[crt2scrnnum].width == w2) &&
+       (SiSXineramadataPtr[crt2scrnnum].height == h2)) {
+       infochanged = FALSE;
+    } else {
+       SiSXineramadataPtr[crt1scrnnum].x = x1;
+       SiSXineramadataPtr[crt1scrnnum].y = y1;
+       SiSXineramadataPtr[crt1scrnnum].width = w1;
+       SiSXineramadataPtr[crt1scrnnum].height = h1;
+       SiSXineramadataPtr[crt2scrnnum].x = x2;
+       SiSXineramadataPtr[crt2scrnnum].y = y2;
+       SiSXineramadataPtr[crt2scrnnum].width = w2;
+       SiSXineramadataPtr[crt2scrnnum].height = h2;
+    }
+
+    if(infochanged) {
+
+       /* Send XineramaLayoutChanged events */
+       WalkTree(pScreen, SiSTellChanged, (pointer)pScreen);
+
+       xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+	  "Pseudo-Xinerama: Screen %d (%d,%d)-(%d,%d)\n",
+	  crt1scrnnum, x1, y1, w1+x1-1, h1+y1-1);
+       xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+	  "Pseudo-Xinerama: Screen %d (%d,%d)-(%d,%d)\n",
+	  crt2scrnnum, x2, y2, w2+x2-1, h2+y2-1);
+
+       if(pSiS->HaveNonRect) {
+	  xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+		"Pseudo-Xinerama: Inaccessible area (%d,%d)-(%d,%d)\n",
+		pSiS->NonRectDead.x0, pSiS->NonRectDead.y0,
+		pSiS->NonRectDead.x1, pSiS->NonRectDead.y1);
+       }
+
+       if(pSiS->HaveOffsRegions) {
+	  xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+		"Pseudo-Xinerama: Inaccessible offset area (%d,%d)-(%d,%d)\n",
+		pSiS->OffDead1.x0, pSiS->OffDead1.y0,
+		pSiS->OffDead1.x1, pSiS->OffDead1.y1);
+	  xf86DrvMsgVerb(pScrn1->scrnIndex, X_INFO, pSiS->XineVerb,
+		"Pseudo-Xinerama: Inaccessible offset area (%d,%d)-(%d,%d)\n",
+		pSiS->OffDead2.x0, pSiS->OffDead2.y0,
+		pSiS->OffDead2.x1, pSiS->OffDead2.y1);
+       }
+
+    }
+}
+
+/* Proc */
+
+static int
+SiSProcXineramaQueryVersion(ClientPtr client)
+{
+    xPanoramiXQueryVersionReply	  rep;
+    register int		  n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+    rep.majorVersion = SIS_XINERAMA_MAJOR_VERSION;
+    rep.minorVersion = SIS_XINERAMA_MINOR_VERSION;
+    if(client->swapped) {
+       swaps(&rep.sequenceNumber, n);
+       swapl(&rep.length, n);
+       swaps(&rep.majorVersion, n);
+       swaps(&rep.minorVersion, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
+    return (client->noClientException);
+}
+
+static int
+SiSProcXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    WindowPtr			pWin;
+    xPanoramiXGetStateReply	rep;
+    register int		n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    pWin = LookupWindow(stuff->window, client);
+    if(!pWin) return BadWindow;
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+    rep.state = !SiSnoPanoramiXExtension;
+    if(client->swapped) {
+       swaps (&rep.sequenceNumber, n);
+       swapl (&rep.length, n);
+       swaps (&rep.state, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
+    return client->noClientException;
+}
+
+static int
+SiSProcXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    WindowPtr				pWin;
+    xPanoramiXGetScreenCountReply	rep;
+    register int			n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    pWin = LookupWindow(stuff->window, client);
+    if(!pWin) return BadWindow;
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+    rep.ScreenCount = SiSXineramaNumScreens;
+    if(client->swapped) {
+       swaps(&rep.sequenceNumber, n);
+       swapl(&rep.length, n);
+       swaps(&rep.ScreenCount, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
+    return client->noClientException;
+}
+
+static int
+SiSProcXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    WindowPtr				pWin;
+    xPanoramiXGetScreenSizeReply	rep;
+    register int			n;
+
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    pWin = LookupWindow (stuff->window, client);
+    if(!pWin)  return BadWindow;
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+    rep.width  = SiSXineramadataPtr[stuff->screen].width;
+    rep.height = SiSXineramadataPtr[stuff->screen].height;
+    if(client->swapped) {
+       swaps(&rep.sequenceNumber, n);
+       swapl(&rep.length, n);
+       swaps(&rep.width, n);
+       swaps(&rep.height, n);
+    }
+    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
+    return client->noClientException;
+}
+
+static int
+SiSProcXineramaIsActive(ClientPtr client)
+{
+    xXineramaIsActiveReply	rep;
+
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+    rep.state = !SiSnoPanoramiXExtension;
+    if(client->swapped) {
+       register int n;
+       swaps(&rep.sequenceNumber, n);
+       swapl(&rep.length, n);
+       swapl(&rep.state, n);
+    }
+    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
+    return client->noClientException;
+}
+
+static int
+SiSProcXineramaQueryScreens(ClientPtr client)
+{
+    xXineramaQueryScreensReply	rep;
+
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.number = (SiSnoPanoramiXExtension) ? 0 : SiSXineramaNumScreens;
+    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
+    if(client->swapped) {
+       register int n;
+       swaps(&rep.sequenceNumber, n);
+       swapl(&rep.length, n);
+       swapl(&rep.number, n);
+    }
+    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);
+
+    if(!SiSnoPanoramiXExtension) {
+       xXineramaScreenInfo scratch;
+       int i;
+
+       for(i = 0; i < SiSXineramaNumScreens; i++) {
+	  scratch.x_org  = SiSXineramadataPtr[i].x;
+	  scratch.y_org  = SiSXineramadataPtr[i].y;
+	  scratch.width  = SiSXineramadataPtr[i].width;
+	  scratch.height = SiSXineramadataPtr[i].height;
+	  if(client->swapped) {
+	     register int n;
+	     swaps(&scratch.x_org, n);
+	     swaps(&scratch.y_org, n);
+	     swaps(&scratch.width, n);
+	     swaps(&scratch.height, n);
+	  }
+	  WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
+       }
+    }
+
+    return client->noClientException;
+}
+
+static int
+SiSProcXineramaSelectInput(ClientPtr client)
+{
+    REQUEST(xXineramaSelectInputReq);
+    WindowPtr pWin;
+    SiSXineramaEventPtr pXineramaEvent, pNewXineramaEvent, *pHead;
+    XID clientResource;
+
+    REQUEST_SIZE_MATCH(xXineramaSelectInputReq);
+    /*IvansLee define NEW_XORG_VERSION.*/
+    #if NEW_XORG_VERSION == 1
+    pWin = SecurityLookupWindow(stuff->window,client,DixWriteAccess);
+    #else
+    pWin = SecurityLookupWindow(stuff->window,client,SecurityWriteAccess);
+    #endif
+    
+    if(!pWin)
+       return BadWindow;
+    #if NEW_XORG_VERSION == 1 /*New Xorg Version >= 1.4 */
+     pHead = (SiSXineramaEventPtr *)SecurityLookupIDByType(client,
+						 pWin->drawable.id, EventType,
+						 DixWriteAccess);
+    #else
+      pHead = (SiSXineramaEventPtr *)SecurityLookupIDByType(client,
+                                                 pWin->drawable.id, EventType,
+                                                 SecurityWriteAccess);
+    #endif
+ 
+    if(stuff->enable & (XineramaLayoutChangeNotifyMask)) {
+
+       /* Check for existing entry */
+       if(pHead) {
+	  for(pXineramaEvent = *pHead; pXineramaEvent; pXineramaEvent = pXineramaEvent->next) {
+	     if(pXineramaEvent->client == client) {
+		return Success;
+	     }
+	  }
+       }
+
+       /* Build a new entry */
+       if(!(pNewXineramaEvent = (SiSXineramaEventPtr)xalloc(sizeof(SiSXineramaEventRec)))) {
+	  return BadAlloc;
+       }
+       pNewXineramaEvent->next = 0;
+       pNewXineramaEvent->client = client;
+       pNewXineramaEvent->window = pWin;
+       pNewXineramaEvent->mask = stuff->enable;
+
+       /*
+	* Add a resource that will be deleted when
+	* the client goes away
+	*/
+       clientResource = FakeClientID(client->index);
+       pNewXineramaEvent->clientResource = clientResource;
+       if(!AddResource(clientResource, ClientType, (pointer)pNewXineramaEvent)) {
+	  return BadAlloc;
+       }
+
+       /*
+	* Create a resource to contain a pointer to the list
+	* of clients selecting input. This must be indirect as
+	* the list may be arbitrarily rearranged which cannot be
+	* done through the resource database.
+	*/
+       if(!pHead) {
+	  pHead = (SiSXineramaEventPtr *)xalloc(sizeof(SiSXineramaEventPtr));
+	  if(!pHead || !AddResource(pWin->drawable.id, EventType, (pointer)pHead)) {
+	     FreeResource(clientResource, RT_NONE);
+	     return BadAlloc;
+	  }
+	  *pHead = NULL;
+       }
+       pNewXineramaEvent->next = *pHead;
+       *pHead = pNewXineramaEvent;
+
+       SiSXineramaClientsListening++;
+
+    } else if(stuff->enable == xFalse) {
+
+       /* Delete the interest */
+       if(pHead) {
+	  pNewXineramaEvent = NULL;
+	  for(pXineramaEvent = *pHead; pXineramaEvent; pXineramaEvent = pXineramaEvent->next) {
+	     if(pXineramaEvent->client == client)
+		break;
+	     pNewXineramaEvent = pXineramaEvent;
+	  }
+	  if(pXineramaEvent) {
+	     FreeResource(pXineramaEvent->clientResource, ClientType);
+	     if(pNewXineramaEvent) {
+		pNewXineramaEvent->next = pXineramaEvent->next;
+	     } else {
+		*pHead = pXineramaEvent->next;
+	     }
+	     xfree(pXineramaEvent);
+	     SiSXineramaClientsListening--;
+	  }
+       }
+
+    } else {
+
+	client->errorValue = stuff->enable;
+	return BadValue;
+
+    }
+
+    return Success;
+}
+
+
+static int
+SiSProcXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff->data) {
+    case X_PanoramiXQueryVersion:
+       return SiSProcXineramaQueryVersion(client);
+    case X_PanoramiXGetState:
+       return SiSProcXineramaGetState(client);
+    case X_PanoramiXGetScreenCount:
+       return SiSProcXineramaGetScreenCount(client);
+    case X_PanoramiXGetScreenSize:
+       return SiSProcXineramaGetScreenSize(client);
+    case X_XineramaIsActive:
+       return SiSProcXineramaIsActive(client);
+    case X_XineramaQueryScreens:
+       return SiSProcXineramaQueryScreens(client);
+    case X_XineramaSelectInput:
+       return SiSProcXineramaSelectInput(client);
+    }
+    return BadRequest;
+}
+
+/* SProc */
+
+static int
+SiSSProcXineramaQueryVersion (ClientPtr client)
+{
+    REQUEST(xPanoramiXQueryVersionReq);
+    register int n;
+    swaps(&stuff->length,n);
+    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
+    return SiSProcXineramaQueryVersion(client);
+}
+
+static int
+SiSSProcXineramaGetState(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetStateReq);
+    register int n;
+    swaps (&stuff->length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
+    return SiSProcXineramaGetState(client);
+}
+
+static int
+SiSSProcXineramaGetScreenCount(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenCountReq);
+    register int n;
+    swaps (&stuff->length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
+    return SiSProcXineramaGetScreenCount(client);
+}
+
+static int
+SiSSProcXineramaGetScreenSize(ClientPtr client)
+{
+    REQUEST(xPanoramiXGetScreenSizeReq);
+    register int n;
+    swaps (&stuff->length, n);
+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
+    return SiSProcXineramaGetScreenSize(client);
+}
+
+static int
+SiSSProcXineramaIsActive(ClientPtr client)
+{
+    REQUEST(xXineramaIsActiveReq);
+    register int n;
+    swaps (&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
+    return SiSProcXineramaIsActive(client);
+}
+
+static int
+SiSSProcXineramaQueryScreens(ClientPtr client)
+{
+    REQUEST(xXineramaQueryScreensReq);
+    register int n;
+    swaps (&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
+    return SiSProcXineramaQueryScreens(client);
+}
+
+static int
+SiSSProcXineramaSelectInput(ClientPtr client)
+{
+    REQUEST(xXineramaSelectInputReq);
+    register int n;
+    swaps(&stuff->length, n);
+    swapl(&stuff->window, n);
+    return SiSProcXineramaSelectInput(client);
+}
+
+static int
+SiSSProcXineramaDispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+    switch (stuff->data) {
+    case X_PanoramiXQueryVersion:
+       return SiSSProcXineramaQueryVersion(client);
+    case X_PanoramiXGetState:
+       return SiSSProcXineramaGetState(client);
+    case X_PanoramiXGetScreenCount:
+       return SiSSProcXineramaGetScreenCount(client);
+    case X_PanoramiXGetScreenSize:
+       return SiSSProcXineramaGetScreenSize(client);
+    case X_XineramaIsActive:
+       return SiSSProcXineramaIsActive(client);
+    case X_XineramaQueryScreens:
+       return SiSSProcXineramaQueryScreens(client);
+    case X_XineramaSelectInput:
+       return SiSSProcXineramaSelectInput(client);
+    }
+    return BadRequest;
+}
+
+static void
+SiSXineramaResetProc(ExtensionEntry* extEntry)
+{
+    /* Called by CloseDownExtensions() */
+    if(SiSXineramadataPtr) {
+       Xfree(SiSXineramadataPtr);
+       SiSXineramadataPtr = NULL;
+    }
+}
+
+static int
+SiSXineramaFreeClient(pointer data, XID id)
+{
+    SiSXineramaEventPtr pXineramaEvent = (SiSXineramaEventPtr)data;
+    SiSXineramaEventPtr *pHead, pCur, pPrev;
+    WindowPtr pWin = pXineramaEvent->window;
+
+    pHead = (SiSXineramaEventPtr *)LookupIDByType(pWin->drawable.id, EventType);
+    if(pHead) {
+       pPrev = NULL;
+       for(pCur = *pHead; pCur && pCur != pXineramaEvent; pCur = pCur->next) {
+	  pPrev = pCur;
+       }
+       if(pCur) {
+	  if(pPrev) pPrev->next = pXineramaEvent->next;
+	  else      *pHead = pXineramaEvent->next;
+       }
+    }
+    xfree((pointer)pXineramaEvent);
+    return 1;
+}
+
+static int
+SiSXineramaFreeEvents(pointer data, XID id)
+{
+    SiSXineramaEventPtr *pHead, pCur, pNext;
+
+    pHead = (SiSXineramaEventPtr *)data;
+    for(pCur = *pHead; pCur; pCur = pNext) {
+       pNext = pCur->next;
+       FreeResource(pCur->clientResource, ClientType);
+       xfree((pointer)pCur);
+    }
+    xfree((pointer)pHead);
+    return 1;
+}
+
+static void
+SXineramaLayoutChangeNotifyEvent(xXineramaLayoutChangeNotifyEvent *from,
+				 xXineramaLayoutChangeNotifyEvent *to)
+{
+    to->type = from->type;
+    cpswapl(from->window, to->window);
+}
+
+void
+SiSXineramaExtensionInit(ScrnInfoPtr pScrn)
+{
+    SISPtr	pSiS = SISPTR(pScrn);
+    Bool	success = FALSE;
+    const char	*sispx = "SiS Pseudo-Xinerama";
+
+    if(!SiSXineramadataPtr) {
+
+       if(!pSiS->MergedFB) {
+	  SiSnoPanoramiXExtension = TRUE;
+	  pSiS->MouseRestrictions = FALSE;
+	  return;
+       }
+
+#ifdef PANORAMIX
+       if(!noPanoramiXExtension) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	     "Xinerama active, not initializing %s\n", sispx);
+	  SiSnoPanoramiXExtension = TRUE;
+	  pSiS->MouseRestrictions = FALSE;
+	  return;
+       }
+#endif
+
+       if(SiSnoPanoramiXExtension) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	      "%s disabled\n", sispx);
+	  pSiS->MouseRestrictions = FALSE;
+	  return;
+       }
+
+       if(pSiS->CRT2Position == sisClone) {
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	     "Running MergedFB in Clone mode, %s disabled\n", sispx);
+	  SiSnoPanoramiXExtension = TRUE;
+	  pSiS->MouseRestrictions = FALSE;
+	  return;
+       }
+
+       SiSXineramaNumScreens = 2;
+
+       while(SiSXineramaGeneration != serverGeneration) {
+
+	  ClientType = CreateNewResourceType(SiSXineramaFreeClient);
+	  if(!ClientType)
+	     break;
+
+	  EventType = CreateNewResourceType(SiSXineramaFreeEvents);
+	  if(!EventType)
+	     break;
+
+	  pSiS->XineramaExtEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 1, 0,
+					SiSProcXineramaDispatch,
+					SiSSProcXineramaDispatch,
+					SiSXineramaResetProc,
+					StandardMinorOpcode);
+
+	  if(!pSiS->XineramaExtEntry) break;
+
+	  if(!(SiSXineramadataPtr = (SiSXineramaData *)
+	        xcalloc(SiSXineramaNumScreens, sizeof(SiSXineramaData)))) break;
+
+	  SiSXineramaEventbase = pSiS->XineramaExtEntry->eventBase;
+	  EventSwapVector[SiSXineramaEventbase + XineramaLayoutChangeNotify] =
+			(EventSwapPtr)SXineramaLayoutChangeNotifyEvent;
+
+	  SiSXineramaGeneration = serverGeneration;
+	  success = TRUE;
+       }
+
+       if(!success) {
+	  SISErrorLog(pScrn, "Failed to initialize %s extension\n", sispx);
+	  SiSnoPanoramiXExtension = TRUE;
+	  pSiS->MouseRestrictions = FALSE;
+	  return;
+       }
+
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	  "%s extension initialized\n", sispx);
+
+       pSiS->SiSXineramaVX = 0;
+       pSiS->SiSXineramaVY = 0;
+       SiSXineramaClientsListening = 0;
+
+       pSiS->XineVerb = 3;
+    }
+
+    SiSUpdateXineramaScreenInfo(pScrn);
+
+}
+#endif  /* End of PseudoXinerama */
+
+#else /* SISMERGED */
+
+int i;	/* Suppress compiler warning */
+
+#endif
+
diff --git a/src/sis_opt.c b/src/sis_opt.c
index 191ad6f..d971d19 100644
--- a/src/sis_opt.c
+++ b/src/sis_opt.c
@@ -27,8 +27,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * Authors:  	Thomas Winischhofer <thomas@winischhofer.net>
- *              ?
+ * Author:	Thomas Winischhofer <thomas@winischhofer.net>
+ *
  */
 
 #ifdef HAVE_CONFIG_H
@@ -68,6 +68,7 @@ typedef enum {
     OPTION_TVSTANDARD,
     OPTION_USEROMDATA,
     OPTION_INTERNALMODES,
+    OPTION_CONSTANTDPI,
     OPTION_USEOEM,
     OPTION_YV12,
     OPTION_CHTVOVERSCAN,
@@ -102,6 +103,7 @@ typedef enum {
     OPTION_USERGBCURSORBLENDTH,
     OPTION_RESTOREBYSET,
     OPTION_DDCFORCRT2,
+    OPTION_FORCECRT1LCD,
     OPTION_FORCECRT2REDETECTION,
     OPTION_SENSEYPBPR,
     OPTION_CRT1GAMMA,
@@ -113,7 +115,6 @@ typedef enum {
     OPTION_XVDEFSATURATION,
     OPTION_XVDEFDISABLEGFX,
     OPTION_XVDEFDISABLEGFXLR,
-    OPTION_XVMEMCPY,
     OPTION_XVBENCHCPY,
 #ifndef SISCHECKOSSSE
     OPTION_XVSSECOPY,
@@ -138,6 +139,7 @@ typedef enum {
     OPTION_CRT2POS,
     OPTION_METAMODES,
     OPTION_SISXINERAMA,
+    OPTION_SCR0,
     OPTION_CRT2ISSCRN0,
     OPTION_MERGEDDPI,
     OPTION_MERGEDFBNONRECT,
@@ -154,41 +156,59 @@ typedef enum {
     OPTION_FORCE1ASPECT,
     OPTION_FORCE2ASPECT,
     OPTION_TVBLUE,
-#ifdef SIS_CP
-    SIS_CP_OPT_OPTIONS
-#endif
-    OPTION_PSEUDO
+    OPTION_PSEUDO,
+    OPTION_FUTRO_TIMING, /*chaoyu's modified: for Fuji-Siemans specail timing*/
+    OPTION_TRACEVGAMISCW,
+    OPTION_USETIMING1366  /*option of enable 1366x768 timing for LVDS panel. Ivans@090109*/
 } SISOpts;
 
 static const OptionInfoRec SISOptions[] = {
+    { OPTION_FAST_VRAM,			"FastVram",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_HOSTBUS,			"HostBus",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_XVBENCHCPY,		"BenchmarkMemcpy",		OPTV_BOOLEAN,	{0}, FALSE },
+#ifndef SISCHECKOSSSE
+    { OPTION_XVSSECOPY, 		"UseSSE",  	  		OPTV_BOOLEAN,	{0}, FALSE },
+#endif
+    { OPTION_MAXXFBMEM,			"MaxXFBMem",			OPTV_INTEGER,	{0}, FALSE },
     { OPTION_ACCEL,			"Accel",			OPTV_BOOLEAN,	{0}, FALSE },
 #if defined(SIS_USE_XAA) && defined(SIS_USE_EXA)
     { OPTION_ACCELMETHOD,		"AccelMethod",			OPTV_STRING,	{0}, FALSE },
 #endif
     { OPTION_TURBOQUEUE,		"TurboQueue",			OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_FAST_VRAM,			"FastVram",			OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_HOSTBUS,			"HostBus",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_RENDER,			"RenderAcceleration",		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_FORCE_CRT1TYPE,		"ForceCRT1Type",		OPTV_STRING,	{0}, FALSE },
-    { OPTION_FORCE_CRT2TYPE,		"ForceCRT2Type",		OPTV_STRING,	{0}, FALSE },
-    { OPTION_SHADOW_FB,			"ShadowFB",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_DRI,			"DRI",				OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_AGP_SIZE,			"AGPSize",			OPTV_INTEGER,	{0}, FALSE },
     { OPTION_AGP_SIZE,			"GARTSize",			OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_VESA,			"Vesa",				OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_MAXXFBMEM,			"MaxXFBMem",			OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SHADOW_FB,			"ShadowFB",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_ROTATE,			"Rotate",			OPTV_STRING,	{0}, FALSE },
+    { OPTION_REFLECT,			"Reflect",			OPTV_STRING,	{0}, FALSE },
     { OPTION_ENABLESISCTRL,		"EnableSiSCtrl",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_SW_CURSOR,			"SWCursor",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_HW_CURSOR,			"HWCursor",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_USERGBCURSOR, 		"ColorHWCursor",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_USERGBCURSOR, 		"UseColorHWCursor",		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_ROTATE,			"Rotate",			OPTV_STRING,	{0}, FALSE },
-    { OPTION_REFLECT,			"Reflect",			OPTV_STRING,	{0}, FALSE },
-    { OPTION_XVIDEO,			"Xvideo",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_USERGBCURSORBLEND,		"ColorHWCursorBlending",	OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_USERGBCURSORBLENDTH,	"ColorHWCursorBlendThreshold",	OPTV_INTEGER,	{0}, FALSE },
     { OPTION_INTERNALMODES,		"InternalModes",		OPTV_BOOLEAN,	{0}, FALSE },
+#ifdef RANDR
+    { OPTION_CONSTANTDPI,		"ConstantDPI",			OPTV_BOOLEAN,	{0}, FALSE },
+#endif
     { OPTION_OVERRULERANGES,		"OverruleFrequencyRanges",	OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_RESTOREBYSET,		"RestoreBySetMode", 		OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_VESA,			"Vesa",				OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_FORCE_CRT1TYPE,		"ForceCRT1Type",		OPTV_STRING,	{0}, FALSE },
     { OPTION_FORCECRT1,			"ForceCRT1",			OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_XVONCRT2,			"XvOnCRT2",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_FORCE_CRT2TYPE,		"ForceCRT2Type",		OPTV_STRING,	{0}, FALSE },
+    { OPTION_DDCFORCRT2,		"CRT2Detection", 		OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_FORCECRT1LCD,		"CRT1LCD", 		OPTV_BOOLEAN,	{0}, FALSE }, /* add by chaoyu: for D-sub LCD */
+    { OPTION_FORCECRT2REDETECTION,	"ForceCRT2ReDetection",		OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_ENABLEHOTKEY,		"EnableHotkey",	   		OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_FORCE1ASPECT,		"ForceCRT1VGAAspect",		OPTV_STRING,	{0}, FALSE },
+    { OPTION_FORCE2ASPECT,		"ForceCRT2VGAAspect",		OPTV_STRING,	{0}, FALSE },
+    { OPTION_USEROMDATA,		"UseROMData",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_USEOEM, 			"UseOEMData",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_SCALELCD,			"ScaleLCD",	   		OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_CENTERLCD,			"CenterLCD",	   		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_PDC,			"PanelDelayCompensation",	OPTV_INTEGER,	{0}, FALSE },
     { OPTION_PDC,			"PDC", 				OPTV_INTEGER,	{0}, FALSE },
     { OPTION_PDC,			"PanelDelayCompensation2",	OPTV_INTEGER,	{0}, FALSE },
@@ -200,9 +220,20 @@ static const OptionInfoRec SISOptions[] = {
     { OPTION_PRGB,			"ForcePanelRGB",		OPTV_INTEGER,	{0}, FALSE },
     { OPTION_SPECIALTIMING,		"SpecialTiming",		OPTV_STRING,	{0}, FALSE },
     { OPTION_TVSTANDARD,		"TVStandard",			OPTV_STRING,	{0}, FALSE },
-    { OPTION_USEROMDATA,		"UseROMData",			OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_USEOEM, 			"UseOEMData",			OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_YV12, 			"YV12",				OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_TVXPOSOFFSET,		"TVXPosOffset", 		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_TVYPOSOFFSET,		"TVYPosOffset", 		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SISTVEDGEENHANCE,		"SISTVEdgeEnhance",		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SISTVANTIFLICKER,		"SISTVAntiFlicker",		OPTV_STRING,	{0}, FALSE },
+    { OPTION_SISTVSATURATION,		"SISTVSaturation",		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SISTVCHROMAFILTER,		"SISTVCFilter",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_SISTVLUMAFILTER,		"SISTVYFilter",	  		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SISTVCOLCALIBFINE,		"SISTVColorCalibFine",		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SISTVCOLCALIBCOARSE,	"SISTVColorCalibCoarse",	OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_TVXSCALE,			"SISTVXScale", 	  		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_TVYSCALE,			"SISTVYScale", 	  		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_SENSEYPBPR,		"SenseYPbPr",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_YPBPRAR,			"YPbPrAspectRatio",		OPTV_STRING,	{0}, FALSE },
+    { OPTION_TVBLUE,			"TVBlueWorkAround",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_CHTVTYPE,			"CHTVType",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_CHTVOVERSCAN,		"CHTVOverscan",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_CHTVSOVERSCAN,		"CHTVSuperOverscan",		OPTV_BOOLEAN,	{0}, FALSE },
@@ -214,29 +245,11 @@ static const OptionInfoRec SISOptions[] = {
     { OPTION_CHTVCVBSCOLOR,		"CHTVCVBSColor",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_CHTVTEXTENHANCE,		"CHTVTextEnhance",		OPTV_INTEGER,	{0}, FALSE },
     { OPTION_CHTVCONTRAST,		"CHTVContrast",			OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_SISTVEDGEENHANCE,		"SISTVEdgeEnhance",		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_SISTVANTIFLICKER,		"SISTVAntiFlicker",		OPTV_STRING,	{0}, FALSE },
-    { OPTION_SISTVSATURATION,		"SISTVSaturation",		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_SISTVCHROMAFILTER,		"SISTVCFilter",			OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_SISTVLUMAFILTER,		"SISTVYFilter",	  		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_SISTVCOLCALIBFINE,		"SISTVColorCalibFine",		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_SISTVCOLCALIBCOARSE,	"SISTVColorCalibCoarse",	OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_TVXSCALE,			"SISTVXScale", 	  		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_TVYSCALE,			"SISTVYScale", 	  		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_TVXPOSOFFSET,		"TVXPosOffset", 		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_TVYPOSOFFSET,		"TVYPosOffset", 		OPTV_INTEGER,	{0}, FALSE },
     { OPTION_SIS6326ANTIFLICKER,	"SIS6326TVAntiFlicker",		OPTV_STRING,	{0}, FALSE },
     { OPTION_SIS6326ENABLEYFILTER,	"SIS6326TVEnableYFilter",	OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_SIS6326YFILTERSTRONG,	"SIS6326TVYFilterStrong",	OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_SIS6326FORCETVPPLUG,	"SIS6326TVForcePlug",		OPTV_STRING,	{0}, FALSE },
     { OPTION_SIS6326FSCADJUST,		"SIS6326FSCAdjust",		OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_YPBPRAR,			"YPbPrAspectRatio",		OPTV_STRING,	{0}, FALSE },
-    { OPTION_TVBLUE,			"TVBlueWorkAround",		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_USERGBCURSORBLEND,		"ColorHWCursorBlending",	OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_USERGBCURSORBLENDTH,	"ColorHWCursorBlendThreshold",	OPTV_INTEGER,	{0}, FALSE },
-    { OPTION_DDCFORCRT2,		"CRT2Detection", 		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_FORCECRT2REDETECTION,	"ForceCRT2ReDetection",		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_SENSEYPBPR,		"SenseYPbPr",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_CRT1GAMMA,			"CRT1Gamma",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_CRT2GAMMA,			"CRT2Gamma",			OPTV_ANYSTR,	{0}, FALSE },
     { OPTION_STOREDBRI,			"GammaBrightness",		OPTV_STRING,	{0}, FALSE },
@@ -251,6 +264,8 @@ static const OptionInfoRec SISOptions[] = {
     { OPTION_NEWSTOREDCON2,		"CRT2Contrast",			OPTV_STRING,	{0}, FALSE },
     { OPTION_NEWSTOREDCON2,		"CRT2NewGammaContrast",		OPTV_STRING,	{0}, FALSE },
     { OPTION_CRT1SATGAIN,		"CRT1Saturation", 		OPTV_INTEGER,	{0}, FALSE },
+    { OPTION_XVIDEO,			"Xvideo",			OPTV_BOOLEAN,	{0}, FALSE },
+    { OPTION_XVONCRT2,			"XvOnCRT2",			OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_XVGAMMA,			"XvGamma", 	  		OPTV_ANYSTR,	{0}, FALSE },
     { OPTION_XVDEFCONTRAST,		"XvDefaultContrast", 		OPTV_INTEGER,	{0}, FALSE },
     { OPTION_XVDEFBRIGHTNESS,		"XvDefaultBrightness",		OPTV_INTEGER,	{0}, FALSE },
@@ -264,17 +279,8 @@ static const OptionInfoRec SISOptions[] = {
     { OPTION_XVINSIDECHROMAKEY,		"XvInsideChromaKey",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_XVYUVCHROMAKEY,		"XvYUVChromaKey",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_XVDISABLECOLORKEY,		"XvDisableColorKey",		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_XVMEMCPY,			"XvUseMemcpy",  		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_XVBENCHCPY,		"BenchmarkMemcpy",		OPTV_BOOLEAN,	{0}, FALSE },
-#ifndef SISCHECKOSSSE
-    { OPTION_XVSSECOPY, 		"UseSSE",  	  		OPTV_BOOLEAN,	{0}, FALSE },
-#endif
     { OPTION_XVDEFAULTADAPTOR,		"XvDefaultAdaptor",		OPTV_STRING,	{0}, FALSE },
-    { OPTION_SCALELCD,			"ScaleLCD",	   		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_CENTERLCD,			"CenterLCD",	   		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_ENABLEHOTKEY,		"EnableHotkey",	   		OPTV_BOOLEAN,	{0}, FALSE },
-    { OPTION_FORCE1ASPECT,		"ForceCRT1VGAAspect",		OPTV_STRING,	{0}, FALSE },
-    { OPTION_FORCE2ASPECT,		"ForceCRT2VGAAspect",		OPTV_STRING,	{0}, FALSE },
+    { OPTION_YV12, 			"YV12",				OPTV_BOOLEAN,	{0}, FALSE },
 #ifdef SISMERGED
     { OPTION_MERGEDFB,			"MergedFB",			OPTV_ANYSTR,	{0}, FALSE },
     { OPTION_MERGEDFB,			"TwinView",			OPTV_ANYSTR,	{0}, FALSE },	/* alias */
@@ -285,19 +291,20 @@ static const OptionInfoRec SISOptions[] = {
     { OPTION_CRT2VREFRESH,		"SecondMonitorVertRefresh", 	OPTV_STRING,	{0}, FALSE },   /* alias */
     { OPTION_CRT2POS,			"CRT2Position",			OPTV_STRING,	{0}, FALSE },
     { OPTION_CRT2POS,			"TwinViewOrientation",		OPTV_STRING,	{0}, FALSE },   /* alias */
-    { OPTION_METAMODES,			"MetaModes",  			OPTV_STRING,	{0}, FALSE },
-    { OPTION_MERGEDDPI,			"MergedDPI", 			OPTV_STRING,	{0}, FALSE },
+    { OPTION_METAMODES,			"MetaModes",			OPTV_STRING,	{0}, FALSE },
+    { OPTION_MERGEDDPI,			"MergedDPI",			OPTV_STRING,	{0}, FALSE },
 #ifdef SISXINERAMA
     { OPTION_SISXINERAMA,		"MergedXinerama",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_SISXINERAMA,		"TwinviewXineramaInfo",		OPTV_BOOLEAN,	{0}, FALSE },   /* alias */
+    { OPTION_SCR0,			"MergedXineramaScreen0",	OPTV_ANYSTR,	{0}, FALSE },
     { OPTION_CRT2ISSCRN0,		"MergedXineramaCRT2IsScreen0",	OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_MERGEDFBNONRECT,		"MergedNonRectangular",		OPTV_BOOLEAN,	{0}, FALSE },
     { OPTION_MERGEDFBMOUSER,		"MergedMouseRestriction",	OPTV_BOOLEAN,	{0}, FALSE },
 #endif
 #endif
-#ifdef SIS_CP
-    SIS_CP_OPTION_DETAIL
-#endif
+    { OPTION_FUTRO_TIMING,		"FutroTiming",			OPTV_BOOLEAN,   {0}, FALSE },/*chaoyu's modified: for Fuji-seimans special timing*/
+    { OPTION_TRACEVGAMISCW,             "TraceVgaMISCW",                OPTV_BOOLEAN,   {0}, FALSE },/*Ivans added for helping detected CRT1 using BIOS setting.*/
+    { OPTION_USETIMING1366,              "UseTiming1366",                  OPTV_BOOLEAN,   {0}, FALSE },/*enable 1366 timing on LVDS, Ivans@090109*/
     { -1,				NULL,				OPTV_NONE,	{0}, FALSE }
 };
 
@@ -436,15 +443,15 @@ SiSOptions(ScrnInfoPtr pScrn)
     MessageType from;
     char        *strptr;
     int         ival;
+    Bool        val, IsDHM = FALSE;
+    Bool	IsSecondHead = FALSE;
     static const char *baddhm     = "Option \"%s\" ignored in Dual Head mode\n";
     static const char *validparm  = "Valid parameters are";
     static const char *disabledstr= "disabled";
     static const char *enabledstr = "enabled";
     static const char *gammaopt   = "%s expects either a boolean, or 1 or 3 real numbers (0.1 - 10.0)\n";
     static const char *briopt     = "%s expects 1 or 3 real numbers (0.1 - 10.0)\n";
-    static const char *newbriopt     = "%s expects 1 or 3 real numbers (-1.0 - 1.0)\n";
-    Bool        val, IsDHM = FALSE;
-    Bool	IsSecondHead = FALSE;
+    static const char *newbriopt  = "%s expects 1 or 3 real numbers (-1.0 - 1.0)\n";
 
     /* Collect all of the relevant option flags (fill in pScrn->options) */
     xf86CollectOptions(pScrn, NULL);
@@ -457,7 +464,9 @@ SiSOptions(ScrnInfoPtr pScrn)
     xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pSiS->Options);
 
     /* Set defaults */
-
+    pSiS->trace_VGA_MISCW = 0;/*Ivans add for using or non-using CRT1 detection by VBIOS.*/
+    pSiS->EnablePanel_1366x768 =0;/*key open 1366x768, now I force it enable. Ivans@090109*/
+    
     pSiS->newFastVram = -1;
     pSiS->HostBus = TRUE;
     pSiS->TurboQueue = TRUE;
@@ -482,6 +491,7 @@ SiSOptions(ScrnInfoPtr pScrn)
 #endif
     pSiS->ShadowFB = FALSE;
     pSiS->loadDRI = FALSE;
+    pSiS->DRIEnabled = FALSE;
 #ifdef XF86DRI
     pSiS->agpWantedPages = AGP_PAGES;
 #endif
@@ -500,6 +510,11 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->OptTVStand = -1;
     pSiS->OptROMUsage = -1;
     pSiS->noInternalModes = FALSE;
+#ifdef RANDR
+    pSiS->constantDPI = -1;
+#else
+    pSiS->constantDPI = FALSE;
+#endif
     pSiS->OptUseOEM = -1;
     pSiS->OptTVOver = -1;
     pSiS->OptTVSOver = -1;
@@ -533,6 +548,7 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->restorebyset = TRUE;
     pSiS->nocrt2ddcdetection = FALSE;
     pSiS->forcecrt2redetection = TRUE;
+    pSiS->havewide1 = pSiS->havewide2 = FALSE;
     pSiS->SenseYPbPr = TRUE;
     pSiS->ForceCRT1Type = CRT1_VGA;
     pSiS->CRT1TypeForced = FALSE;
@@ -547,8 +563,12 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->enablesisctrl = FALSE;
     if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
        pSiS->XvDefBri = 10;
-       pSiS->XvDefCon = 2;
-    } else {
+       if((pSiS->ChipType == SIS_662)||(pSiS->ChipType == SIS_671))
+          pSiS->XvDefCon = 64; /*xv contrast 256 levels,set default be 64.ivans*/
+       else
+          pSiS->XvDefCon = 2;
+    } 
+    else {
        pSiS->XvDefBri = 0;
        pSiS->XvDefCon = 4;
     }
@@ -559,7 +579,6 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->XvDefAdaptorBlit = FALSE;
     pSiS->UsePanelScaler = -1;
     pSiS->CenterLCD = -1;
-    pSiS->XvUseMemcpy = TRUE;
     pSiS->XvUseChromaKey = FALSE;
     pSiS->XvDisableColorKey = FALSE;
     pSiS->XvInsideChromaKey = FALSE;
@@ -580,6 +599,9 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->HWCursorIsVisible = FALSE;
     pSiS->OverruleRanges = TRUE;
     pSiS->BenchMemCpy = TRUE;
+#ifdef ENABLEXvMC
+    pSiS->FBBufferHandle = NULL;
+#endif
 #ifndef SISCHECKOSSSE
     pSiS->XvSSEMemcpy = FALSE;
 #endif
@@ -591,18 +613,18 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->MetaModes = NULL;
     pSiS->MergedFBXDPI = pSiS->MergedFBYDPI = 0;
     pSiS->CRT1XOffs = pSiS->CRT1YOffs = pSiS->CRT2XOffs = pSiS->CRT2YOffs = 0;
-    pSiS->NonRect = pSiS->HaveNonRect = pSiS->HaveOffsRegions = FALSE;
-    pSiS->MBXNR1XMAX = pSiS->MBXNR1YMAX = pSiS->MBXNR2XMAX = pSiS->MBXNR2YMAX = 65536;
+    pSiS->NonRect = TRUE;
+    pSiS->HaveNonRect = pSiS->HaveOffsRegions = FALSE;
+    pSiS->MBXNRXMAX = pSiS->MBXNRYMAX = 65536;
     pSiS->MouseRestrictions = TRUE;
 #ifdef SISXINERAMA
     pSiS->UseSiSXinerama = TRUE;
+    pSiS->MFBScr0LR = TRUE;	/* By default: Left/bottom are screen 0 */
+    pSiS->MFBScr0TB = FALSE;
     pSiS->CRT2IsScrn0 = FALSE;
 #endif
 #endif
-#ifdef SIS_CP
-    SIS_CP_OPT_DEFAULT
-#endif
-
+  
     /* Chipset dependent defaults */
 
     if(pSiS->Chipset == PCI_CHIP_SIS530) {
@@ -635,7 +657,7 @@ SiSOptions(ScrnInfoPtr pScrn)
      * so don't load DRI by default on
      * others.
      */
-    if(pSiS->VGAEngine == SIS_300_VGA) {
+    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
        pSiS->loadDRI = TRUE;
     }
 
@@ -662,6 +684,7 @@ SiSOptions(ScrnInfoPtr pScrn)
        pSiS->AllowHotkey = 1;
     }
 
+
     /* Collect the options */
 
     /* FastVRAM (5597/5598, 6326 and 530/620 only)
@@ -692,17 +715,17 @@ SiSOptions(ScrnInfoPtr pScrn)
     /* MaxXFBMem
      * This options limits the amount of video memory X uses for screen
      * and off-screen buffers. This option should be used if using DRI
-     * is intended. The kernel framebuffer driver required for DRM will
-     * start its memory heap at 12MB if it detects more than 16MB, at 8MB if
-     * between 8 and 16MB are available, otherwise at 4MB. So, if the amount
+     * is intended. The kernel framebuffer driver (formerly required for DRM)
+     * will start its memory heap at 12MB if it detects more than 16MB, at 8MB
+     * if between 8 and 16MB are available, otherwise at 4MB. So, if the amount
      * of memory X uses, a clash between the framebuffer's memory heap
      * and X is avoided. The amount is to be specified in KB.
+     * Starting with Linux 2.6.3, this option is no longer needed. And
+     * neither is sisfb for DRI, since the DRM got a memory manager of its
+     * own.
      */
     if(xf86GetOptValInteger(pSiS->Options, OPTION_MAXXFBMEM, (int *)&pSiS->maxxfbmem)) {
        if(pSiS->maxxfbmem >= 2048) {
-	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		   "MaxXFBMem: Framebuffer memory shall be limited to %d KB\n",
-		    pSiS->maxxfbmem);
 	  pSiS->maxxfbmem *= 1024;
        } else {
 	  pSiS->maxxfbmem = 0;
@@ -724,6 +747,9 @@ SiSOptions(ScrnInfoPtr pScrn)
 #endif
     }
 
+    /* AccelMethod
+     * Chooses between XAA and EXA
+     */
 #if defined(SIS_USE_XAA) && defined(SIS_USE_EXA)
     if(!pSiS->NoAccel) {
        from = X_DEFAULT;
@@ -741,8 +767,8 @@ SiSOptions(ScrnInfoPtr pScrn)
     }
 #endif
 
-    /* RenderAcceleration
-     * En/Disables RENDER acceleration (315/330/340 series only, not 550, not XGI Z7)
+    /* RenderAcceleration (for XAA only)
+     * En/Disables RENDER acceleration (315 and later only, not 550, not XGI Z7)
      */
 #ifdef SIS_USE_XAA
     if((pSiS->VGAEngine == SIS_315_VGA)   &&
@@ -759,6 +785,7 @@ SiSOptions(ScrnInfoPtr pScrn)
     pSiS->doRender = FALSE;
 #endif
 
+
     /* SWCursor, HWCursor
      * Chooses whether to use the hardware or software cursor
      */
@@ -771,11 +798,11 @@ SiSOptions(ScrnInfoPtr pScrn)
        pSiS->HWCursor = FALSE;
        pSiS->OptUseColorCursor = 0;
     }
-    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n",
-                                pSiS->HWCursor ? "HW" : "SW");
+    if(!pSiS->HWCursor) {
+       xf86DrvMsg(pScrn->scrnIndex, from, "Using SW cursor\n");
+    }
 
-    /*
-     * UseColorHWCursor
+    /* UseColorHWCursor
      * ColorHWCursorBlending
      * ColorHWCursorBlendThreshold
      *
@@ -978,8 +1005,44 @@ SiSOptions(ScrnInfoPtr pScrn)
 		if(!val) pSiS->UseSiSXinerama = FALSE;
 	     }
 	     if(pSiS->UseSiSXinerama) {
-		if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2ISSCRN0, &val)) {
+	        if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SCR0))) {
+	           char *tempstr1 = xalloc(strlen(strptr) + 1);
+	           char *tempstr2 = xalloc(strlen(strptr) + 1);
+	           char *tempstr;
+		   int i, result;
+		   pSiS->MFBScr0LR = pSiS->MFBScr0TB = -1;
+		   if((tempstr = strpbrk(strptr, ",;-"))) {
+		      *tempstr = ' ';
+		   }
+		   tempstr = tempstr1;
+		   if((result = sscanf(strptr, "%s %s", tempstr1, tempstr2)) > 0) {
+		      for(i = 1; i <= max(result, 2); i++) {
+			 if(!xf86NameCmp(tempstr, "left")) {
+			    pSiS->MFBScr0LR = TRUE;
+			 } else if(!xf86NameCmp(tempstr, "right")) {
+			    pSiS->MFBScr0LR = FALSE;
+			 } else if(!xf86NameCmp(tempstr, "top")) {
+			    pSiS->MFBScr0TB = TRUE;
+			 } else if(!xf86NameCmp(tempstr, "bottom")) {
+			    pSiS->MFBScr0TB = FALSE;
+			 }
+			 tempstr = tempstr2;
+		      }
+		   }
+		   if(pSiS->MFBScr0LR == -1 || pSiS->MFBScr0TB == -1) {
+		      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			"Bad or incomplete argument(s) for Option \"%s\"\n",
+			pSiS->Options[SiS_FIFT(pSiS->Options, OPTION_SCR0)].name);
+		   }
+		   xfree(tempstr1);
+		   xfree(tempstr2);
+	        } else if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2ISSCRN0, &val)) {
+		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			"Option \"%s\" is deprecated, use \"%s\"\n",
+			pSiS->Options[SiS_FIFT(pSiS->Options, OPTION_CRT2ISSCRN0)].name,
+			pSiS->Options[SiS_FIFT(pSiS->Options, OPTION_SCR0)].name);
 		   pSiS->CRT2IsScrn0 = val ? TRUE : FALSE;
+		   pSiS->MFBScr0LR = pSiS->MFBScr0TB = -1;
 		}
 		if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFBNONRECT, &val)) {
 		   pSiS->NonRect = val ? TRUE : FALSE;
@@ -1017,16 +1080,13 @@ SiSOptions(ScrnInfoPtr pScrn)
 		OPTION_SISTVCHROMAFILTER, OPTION_SISTVLUMAFILTER, OPTION_SISTVCOLCALIBCOARSE,
 		OPTION_SISTVCOLCALIBFINE, OPTION_TVXPOSOFFSET, OPTION_TVYPOSOFFSET,
 		OPTION_TVXSCALE, OPTION_TVYSCALE, OPTION_TVBLUE, OPTION_CRT2GAMMA, OPTION_XVONCRT2,
-		OPTION_XVDEFAULTADAPTOR, OPTION_XVMEMCPY, OPTION_XVBENCHCPY, OPTION_FORCE2ASPECT,
+		OPTION_XVDEFAULTADAPTOR, OPTION_XVBENCHCPY, OPTION_FORCE2ASPECT,
 #if defined(SIS_USE_XAA) && defined(SIS_USE_EXA)
 		OPTION_ACCELMETHOD,
 #endif
 #ifndef SISCHECKOSSSE
 		OPTION_XVSSECOPY,
 #endif
-#ifdef SIS_CP
-		SIS_CP_OPT_DH_WARN
-#endif
 		-1
        };
 
@@ -1048,7 +1108,7 @@ SiSOptions(ScrnInfoPtr pScrn)
           xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using VRAM command queue, size %dk\n",
 		pSiS->cmdQueueSize / 1024);
 #else
-	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using MMIO command queue, size 512k\n");
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using MMIO command queue\n");
 #endif
 
        } else {
@@ -1060,11 +1120,12 @@ SiSOptions(ScrnInfoPtr pScrn)
 	  }
 	  xf86DrvMsg(pScrn->scrnIndex, from, "TurboQueue %s\n",
 		     pSiS->TurboQueue ? enabledstr : disabledstr);
+
        }
 
        if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
 
-	  /* RestoreBySetMode (300/315/330 series only)
+	  /* RestoreBySetMode (300/315/330 series and later only)
 	   * Set this to force the driver to set the old mode instead of restoring
 	   * the register contents. This can be used to overcome problems with
 	   * LCD panels and video bridges.
@@ -1101,7 +1162,8 @@ SiSOptions(ScrnInfoPtr pScrn)
 		ival ? " in dual head mode" : "");
 	  if(pSiS->Chipset == PCI_CHIP_SIS630 ||
 	     pSiS->Chipset == PCI_CHIP_SIS650 ||
-	     pSiS->Chipset == PCI_CHIP_SIS660) {
+	     pSiS->Chipset == PCI_CHIP_SIS660 ||
+	     pSiS->Chipset == PCI_CHIP_SIS670) {
 	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		 "WARNING: Using the Hotkey might freeze your machine, regardless\n");
 	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -1113,6 +1175,7 @@ SiSOptions(ScrnInfoPtr pScrn)
 	   * specific data from the BIOS ROM. This option can - and
 	   * should - be used in case the driver makes problems
 	   * because SiS changed the location of this data.
+	   * Generally, don't use this.
 	   */
 	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
 	     pSiS->OptROMUsage = val ? 1 : 0;
@@ -1127,6 +1190,7 @@ SiSOptions(ScrnInfoPtr pScrn)
 	   * If this data is incorrect, the TV may lose color and
 	   * the LCD panel might show some strange effects. Use this
 	   * option to disable the usage of this data.
+	   * Generally, don't use this.
 	   */
 	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
 	     pSiS->OptUseOEM = val ? 1 : 0;
@@ -1145,6 +1209,9 @@ SiSOptions(ScrnInfoPtr pScrn)
 	  if(xf86GetOptValBool(pSiS->Options, OPTION_DDCFORCRT2, &val)) {
 	     pSiS->nocrt2ddcdetection = val ? FALSE : TRUE;
 	  }
+	  if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1LCD, &val)) {
+	     pSiS->forceLCDcrt1= val ? TRUE : FALSE;
+	  }
 
 	  /* ForceCRT2ReDetection (315/330 series and later only)
 	   * If set to true, it forces re-detection of the LCD panel and
@@ -1171,37 +1238,37 @@ SiSOptions(ScrnInfoPtr pScrn)
 	   * YPbPr and detect SVideo or CVBS only.
 	   */
 	  if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
-	     if(val) pSiS->SenseYPbPr = TRUE;
-	     else    pSiS->SenseYPbPr = FALSE;
+	     pSiS->SenseYPbPr = val ? TRUE : FALSE;
 	  }
 
 	  /* ForceCRT1Type (315/330 series and later only)
 	   * Used for forcing the driver to initialize CRT1 as
 	   * VGA (analog) or LCDA (for simultanious LCD and TV
-	   * display) - on M650/651 and 661 or later with 301C/30xLV only!
+	   * display) - on M650/651 and 661 or later with 301C/30xLV or later only!
 	   */
-	  if(pSiS->VGAEngine == SIS_315_VGA) {
-	     if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE))) {
-		if((!xf86NameCmp(strptr,"VGA")) || (!xf86NameCmp(strptr,"CRT"))) {
-		   pSiS->ForceCRT1Type = CRT1_VGA;
-		   pSiS->CRT1TypeForced = TRUE;
-		} else if( (!xf86NameCmp(strptr,"LCD"))   ||
-			   (!xf86NameCmp(strptr,"LCDA"))  ||
-			   (!xf86NameCmp(strptr,"DVI-D")) ||
-			   (!xf86NameCmp(strptr,"DVID"))  ||
-			   (!xf86NameCmp(strptr,"DVI"))   ||
-			   (!xf86NameCmp(strptr,"LCD-A")) ) {
-		   pSiS->ForceCRT1Type = CRT1_LCDA;
-		   pSiS->CRT1TypeForced = TRUE;
-		} else if((!xf86NameCmp(strptr,"NONE")) || (!xf86NameCmp(strptr,"OFF"))) {
-		   pSiS->ForceCRT1Type = CRT1_VGA;
-		   pSiS->forceCRT1 = 0;
-		   pSiS->CRT1TypeForced = TRUE;
-		} else {
-		   SiS_PrintBadOpt(pScrn, strptr, OPTION_FORCE_CRT1TYPE);
-		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		       "%s \"VGA\" (alias \"CRT\"), \"LCD\" (alias \"DVI-D\") or NONE\n", validparm);
-		}
+	  if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE))) {
+	     if( (!xf86NameCmp(strptr,"VGA")) ||
+	         (!xf86NameCmp(strptr,"CRT")) ||
+	         SiS_StrIsBoolOn(strptr) ) {
+		pSiS->ForceCRT1Type = CRT1_VGA;
+		pSiS->CRT1TypeForced = TRUE;
+	     } else if( (!xf86NameCmp(strptr,"LCD"))   ||
+			(!xf86NameCmp(strptr,"LCDA"))  ||
+			(!xf86NameCmp(strptr,"DVI-D")) ||
+			(!xf86NameCmp(strptr,"DVID"))  ||
+			(!xf86NameCmp(strptr,"DVI"))   ||
+			(!xf86NameCmp(strptr,"LCD-A")) ) {
+		pSiS->ForceCRT1Type = CRT1_LCDA;
+		pSiS->CRT1TypeForced = TRUE;
+	     } else if( (!xf86NameCmp(strptr,"NONE")) ||
+			SiS_StrIsBoolOff(strptr) ) {
+		pSiS->ForceCRT1Type = CRT1_VGA;
+		pSiS->forceCRT1 = 0;
+		pSiS->CRT1TypeForced = TRUE;
+	     } else {
+		SiS_PrintBadOpt(pScrn, strptr, OPTION_FORCE_CRT1TYPE);
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       "%s \"VGA\" (alias \"CRT\" or \"ON\"), \"LCD\" (alias \"DVI-D\") or NONE (alias \"OFF\")\n", validparm);
 	     }
 	  }
 
@@ -1210,6 +1277,7 @@ SiSOptions(ScrnInfoPtr pScrn)
 	   * intention is mainly for old monitors that can't be detected
 	   * automatically. This is only useful on machines with a video bridge.
 	   * In normal cases, this option won't be necessary.
+	   * This option is deprecated. Use ForceCRT1Type instead.
 	   */
 	  if(pSiS->ForceCRT1Type == CRT1_VGA) {
 	     if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
@@ -1217,6 +1285,8 @@ SiSOptions(ScrnInfoPtr pScrn)
 		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 			"CRT1 shall be forced %s\n",
 			val ? "ON" : "OFF");
+		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			"Option \"ForceCRT1\" is deprecated. Use Option \"ForceCRT1Type\" instead.\n");
 	     }
 	  }
 
@@ -1245,7 +1315,8 @@ SiSOptions(ScrnInfoPtr pScrn)
 	     } else if(!xf86NameCmp(strptr,"SCART")) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_SCART;
-	     } else if((!xf86NameCmp(strptr,"LCD")) || (!xf86NameCmp(strptr,"DVI-D"))) {
+	     } else if( (!xf86NameCmp(strptr,"LCD")) ||
+			(!xf86NameCmp(strptr,"DVI-D")) ) {
 		if(pSiS->ForceCRT1Type == CRT1_VGA) {
 		   pSiS->ForceCRT2Type = CRT2_LCD;
 		} else {
@@ -1253,7 +1324,7 @@ SiSOptions(ScrnInfoPtr pScrn)
 		   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		      "Can't set both CRT1 and CRT2 type to LCD; CRT2 disabled\n");
 		}
-	     } else if((!xf86NameCmp(strptr,"VGA")) ||
+	     } else if((!xf86NameCmp(strptr,"VGA"))   ||
 		       (!xf86NameCmp(strptr,"DVI-A")) ||
 		       (!xf86NameCmp(strptr,"CRT"))) {
 		if(pSiS->ForceCRT1Type == CRT1_VGA) {
@@ -1263,7 +1334,8 @@ SiSOptions(ScrnInfoPtr pScrn)
 		   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		      "CRT2 can only be TV or off while CRT1 is LCD; CRT2 disabled\n");
 		}
-	     } else if(!xf86NameCmp(strptr,"NONE"))
+	     } else if( (!xf86NameCmp(strptr,"NONE")) ||
+			SiS_StrIsBoolOff(strptr) )
 		pSiS->ForceCRT2Type = 0;
 	     else if((!xf86NameCmp(strptr,"DSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
 		if(pSiS->ForceCRT1Type == CRT1_VGA) {
@@ -1275,52 +1347,53 @@ SiSOptions(ScrnInfoPtr pScrn)
 		   pSiS->ForceCRT2Type = CRT2_LCD;
 		   pSiS->FSTN = TRUE;
 		}
-#ifdef ENABLE_YPBPR
 	     } else if(!xf86NameCmp(strptr,"HIVISION")) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_HIVISION;
-	     } else if((!xf86NameCmp(strptr,"YPBPR1080I")) && (pSiS->VGAEngine == SIS_315_VGA)) {
+	     } else if( (!xf86NameCmp(strptr,"YPBPR1080I")) &&
+			(pSiS->VGAEngine == SIS_315_VGA) ) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_YPBPR;
 		pSiS->ForceYPbPrType = TV_YPBPR1080I;
-	     } else if(((!xf86NameCmp(strptr,"YPBPR525I")) || (!xf86NameCmp(strptr,"YPBPR480I"))) &&
-		       (pSiS->VGAEngine == SIS_315_VGA)) {
+	     } else if( ( (!xf86NameCmp(strptr,"YPBPR525I")) ||
+			  (!xf86NameCmp(strptr,"YPBPR480I")) )  &&
+			(pSiS->VGAEngine == SIS_315_VGA) ) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_YPBPR;
 		pSiS->ForceYPbPrType = TV_YPBPR525I;
-	     } else if(((!xf86NameCmp(strptr,"YPBPR525P")) || (!xf86NameCmp(strptr,"YPBPR480P"))) &&
-		       (pSiS->VGAEngine == SIS_315_VGA)) {
+	     } else if( ( (!xf86NameCmp(strptr,"YPBPR525P")) ||
+			  (!xf86NameCmp(strptr,"YPBPR480P")) )  &&
+			(pSiS->VGAEngine == SIS_315_VGA) ) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_YPBPR;
 		pSiS->ForceYPbPrType = TV_YPBPR525P;
-	     } else if(((!xf86NameCmp(strptr,"YPBPR625I")) || (!xf86NameCmp(strptr,"YPBPR576I"))) &&
-		       (pSiS->VGAEngine == SIS_315_VGA)) {
+	     } else if( ( (!xf86NameCmp(strptr,"YPBPR625I")) ||
+			  (!xf86NameCmp(strptr,"YPBPR576I")) )  &&
+			(pSiS->VGAEngine == SIS_315_VGA)) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_YPBPR;
 		pSiS->ForceYPbPrType = TV_YPBPR625I;
-	     } else if(((!xf86NameCmp(strptr,"YPBPR625P")) || (!xf86NameCmp(strptr,"YPBPR576P"))) &&
-		       (pSiS->VGAEngine == SIS_315_VGA)) {
+	     } else if( ( (!xf86NameCmp(strptr,"YPBPR625P")) ||
+			  (!xf86NameCmp(strptr,"YPBPR576P")))  &&
+			(pSiS->VGAEngine == SIS_315_VGA) ) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_YPBPR;
 		pSiS->ForceYPbPrType = TV_YPBPR625P;
-	     } else if(((!xf86NameCmp(strptr,"YPBPR750P")) || (!xf86NameCmp(strptr,"YPBPR720P"))) &&
-	               (pSiS->VGAEngine == SIS_315_VGA)) {
+	     } else if( ( (!xf86NameCmp(strptr,"YPBPR750P")) ||
+			  (!xf86NameCmp(strptr,"YPBPR720P")))  &&
+			(pSiS->VGAEngine == SIS_315_VGA) ) {
 		pSiS->ForceCRT2Type = CRT2_TV;
 		pSiS->ForceTVType = TV_YPBPR;
 		pSiS->ForceYPbPrType = TV_YPBPR750P;
-#endif
 	     } else {
 		SiS_PrintBadOpt(pScrn, strptr, OPTION_FORCE_CRT2TYPE);
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		    "%s \"LCD\" (=\"DVI-D\"), \"TV\", \"SVIDEO\", \"COMPOSITE\",\n"
 		    "\t\"SVIDEO+COMPOSITE\", \"SCART\", \"VGA\" (=\"DVI-A\") or \"NONE\"; on the SiS550\n"
 		    "\talso \"DSTN\" and \"FSTN\""
-#ifdef ENABLE_YPBPR
 		    				"; on SiS 301/301B bridges also \"HIVISION\", and on\n"
-		    "\tSiS315/330/340 series with 301C/30xLV bridge also \"YPBPR480I\", \"YPBPR480P\",\n"
-		    "\t\"YPBPR576I\", \"YPBPR576P\", \"YPBPR720P\" and \"YPBPR1080I\""
-#endif
-		    "\n", validparm);
+		    "\tSiS315/330/340 series with 301C/30xLV/307 also \"YPBPR480I\", \"YPBPR480P\",\n"
+		    "\t\"YPBPR576I\", \"YPBPR576P\", \"YPBPR720P\" and \"YPBPR1080I\"\n", validparm);
 	     }
 
 	     if(pSiS->ForceCRT2Type != CRT2_DEFAULT)
@@ -1345,6 +1418,10 @@ SiSOptions(ScrnInfoPtr pScrn)
 	     }
 	  }
 
+	  /* SpecialTiming
+	   * Override the driver's autodetection of some special
+	   * systems requiring some hacks.
+	   */
 	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING);
 	  if(strptr != NULL) {
 	     int i = 0;
@@ -1408,8 +1485,10 @@ SiSOptions(ScrnInfoPtr pScrn)
 	     if(strptr != NULL) {
 		if(!xf86NameCmp(strptr,"WIDE")) {
 		   pSiS->SiS_Pr->SiS_UseWideCRT2 = TRUE;
+		   pSiS->havewide2 = TRUE;
 		} else if(!xf86NameCmp(strptr,"NORMAL")) {
 		   pSiS->SiS_Pr->SiS_UseWideCRT2 = FALSE;
+		   pSiS->havewide2 = TRUE;
 		} else {
 		   SiS_PrintBadOpt(pScrn, strptr, OPTION_FORCE2ASPECT);
 		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s:\n", validparm);
@@ -1531,10 +1610,12 @@ SiSOptions(ScrnInfoPtr pScrn)
 	     }
 	  }
 
-	 /* TVBlueWorkAround (315/later series only)
+	 /* TVBlueWorkAround (315 series until 661 only)
 	  * TRUE and FALSE are two ways to work around a "blue shade" on
 	  * TV output. This work-around is disabled by not setting the
-	  * option. 315 series + 301B-DH only.
+	  * option. 315 series + 301B-DH only. For 661 and later, the
+	  * BIOS contains the respective values so we can read them
+	  * from there.
 	  */
 	  if(pSiS->VGAEngine == SIS_315_VGA) {
 	     if(xf86GetOptValBool(pSiS->Options, OPTION_TVBLUE, &val)) {
@@ -1611,7 +1692,7 @@ SiSOptions(ScrnInfoPtr pScrn)
 	  }
        }
 
-       /* CHTVType  (315/330/later series + Chrontel only)
+       /* CHTVType (315/330/later series + Chrontel only)
 	* Used for telling the driver if the TV output shall
 	* be 525i YPbPr or SCART.
 	*/
@@ -1842,12 +1923,6 @@ SiSOptions(ScrnInfoPtr pScrn)
 	  }
        }
 
-       if(xf86GetOptValBool(pSiS->Options, OPTION_XVMEMCPY, &val)) {
-	  pSiS->XvUseMemcpy = val ? TRUE : FALSE;
-	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Xv will %suse memcpy()\n",
-		val ? "" : "not ");
-       }
-
 #if defined(__i386__) || defined(__AMD64__) || defined(__amd64__) || defined(__x86_64__)
        if(xf86GetOptValBool(pSiS->Options, OPTION_XVBENCHCPY, &val)) {
 	  pSiS->BenchMemCpy = val ? TRUE : FALSE;
@@ -1866,9 +1941,6 @@ SiSOptions(ScrnInfoPtr pScrn)
 #endif
 #endif /* __i386__ || __AMD64__ || __amd64__ */
 
-#ifdef SIS_CP
-       SIS_CP_OPT_DOOPT
-#endif
 
     }  /* DualHead */
 
@@ -1889,20 +1961,22 @@ SiSOptions(ScrnInfoPtr pScrn)
        if(strptr != NULL) {
 	  if(!xf86NameCmp(strptr,"WIDE")) {
 	     pSiS->SiS_Pr->SiS_UseWide = 1;
+	     pSiS->havewide1 = TRUE;
 	  } else if(!xf86NameCmp(strptr,"NORMAL")) {
 	     pSiS->SiS_Pr->SiS_UseWide = 0;
+	     pSiS->havewide1 = TRUE;
 	  } else {
 	     SiS_PrintBadOpt(pScrn, strptr, OPTION_FORCE1ASPECT);
 	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s:\n", validparm);
 	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t\"NORMAL\" or \"WIDE\"\n");
           }
-	  if(pSiS->SiS_Pr->SiS_UseWide != -1) {
+	  if(pSiS->havewide1) {
 	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 		"CRT1 (VGA) aspect ratio will be assumed %s\n",
 		pSiS->SiS_Pr->SiS_UseWide ? "wide" : "normal");
 	  }
        }
-       if(pSiS->SiS_Pr->SiS_UseWideCRT2 != -1) {
+       if(pSiS->havewide2) {
 	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 		"CRT2 (VGA) aspect ratio will be assumed %s\n",
 		pSiS->SiS_Pr->SiS_UseWideCRT2 ? "wide" : "normal");
@@ -1929,7 +2003,7 @@ SiSOptions(ScrnInfoPtr pScrn)
     }
 
     if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
-       /* InternalModes (300/315/330 series only)
+       /* InternalModes (300/315/330 series and later only)
 	* The default behavior is to replace X's default modes with
 	* a mode list generated out of the known and supported modes. Use
 	* this option to disable this. NOT RECOMMENDED.
@@ -1937,23 +2011,69 @@ SiSOptions(ScrnInfoPtr pScrn)
        if(xf86GetOptValBool(pSiS->Options, OPTION_INTERNALMODES, &val)) {
 	  pSiS->noInternalModes = val ? FALSE : TRUE;
 	  if(pSiS->noInternalModes) {
-	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Usage of built-in modes is %s\n", disabledstr);
+	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
+			"Usage of built-in modes is %s\n", disabledstr);
 	  }
        }
 
+
     }
 
+#ifdef RANDR
+    /* Constant DPI (all chipsets) */
+    /* RandR causes a change of the screen's DPI on size changes
+     * by supplying constant mmWidth/mmHeight dimensions to
+     * the root window. Clients calculate the DPI of the
+     * screen by using mmWidth/mmHeight and projecting these
+     * on the current virtual screen size.
+     * I, for one, hate fonts being resized upon screen size
+     * changes (especially in windows which are already open
+     * when the size change takes place; leads to a nice font
+     * size mixture). If you share this feeling, enable this
+     * option and you will be presented with constant DPI values
+     * even upon size changes.
+     * If RR_GET_MODE_MM is not available, this done more or
+     * less automatically in MergedFB mode. We recalc the DPI
+     * often in order to keep them sane if the user switched
+     * from a normal (side by side) mode to a clone mode/screen
+     * size.
+     * The -dpi command line switch has a special meaning here.
+     * I herewith overrule the idea that -dpi means "use this
+     * dpi only for the default screen size". If you want that,
+     * please give a DisplaySize in your config file. -dpi is now
+     * stronger as it automatically enables constant DPI (unless
+     * the user disables it).
+     */
+    from = X_DEFAULT;
+    if(xf86GetOptValBool(pSiS->Options, OPTION_CONSTANTDPI, &pSiS->constantDPI)) {
+       from = X_CONFIG;
+    } else {
+       if(monitorResolution > 0) {
+	  pSiS->constantDPI = TRUE;
+	  from = X_CMDLINE;
+	  xf86DrvMsg(pScrn->scrnIndex, from,
+		"\"-dpi %d\" given in command line, assuming \"ConstantDPI\" set\n",
+		monitorResolution);
+       } else {
+	  pSiS->constantDPI = FALSE;
+       }
+    }
+    xf86DrvMsg(pScrn->scrnIndex, from,
+	"X server will %skeep DPI constant for all screen sizes\n",
+	pSiS->constantDPI ? "" : "not ");
+#endif
+
     /* ShadowFB */
     from = X_DEFAULT;
     if(xf86GetOptValBool(pSiS->Options, OPTION_SHADOW_FB, &pSiS->ShadowFB)) {
+       from = X_CONFIG;
 #ifdef SISMERGED
        if(pSiS->MergedFB) {
 	  pSiS->ShadowFB = FALSE;
 	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 	      "Shadow Framebuffer not supported in MergedFB mode\n");
-       } else
+       }
 #endif
-	  from = X_CONFIG;
     }
     if(pSiS->ShadowFB) {
 	pSiS->NoAccel = TRUE;
@@ -1985,14 +2105,14 @@ SiSOptions(ScrnInfoPtr pScrn)
        } else {
 	  SiS_PrintBadOpt(pScrn, strptr, OPTION_ROTATE);
 	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	      "%s \"CW\" or \"CCW\"\n", validparm);
+	      "%s \"CW\" (clock-wise) or \"CCW\" (counter clock-wise)\n", validparm);
        }
 
        if(pSiS->Rotate) {
 	  pSiS->ShadowFB = TRUE;
 	  pSiS->NoAccel  = TRUE;
-	  pSiS->HWCursor = FALSE;
 	  pSiS->NoXvideo = TRUE;
+	  pSiS->HWCursor = FALSE;
 	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 	      "Rotating screen %sclockwise (2D acceleration and Xv disabled)\n",
 	      (pSiS->Rotate == -1) ? "counter " : "");
@@ -2029,13 +2149,14 @@ SiSOptions(ScrnInfoPtr pScrn)
        if(pSiS->Reflect) {
 	  pSiS->ShadowFB = TRUE;
 	  pSiS->NoAccel  = TRUE;
-	  pSiS->HWCursor = FALSE;
 	  pSiS->NoXvideo = TRUE;
+	  pSiS->HWCursor = FALSE;
 	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
 	      "Reflecting screen (2D acceleration and Xv disabled)\n");
        }
     }
 
+
 #ifdef XF86DRI
     /* DRI */
     from = X_DEFAULT;
@@ -2101,8 +2222,14 @@ SiSOptions(ScrnInfoPtr pScrn)
 
 	  /* Some Xv properties' defaults can be set by options */
 	  if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFCONTRAST, &ival)) {
-	     if((ival >= 0) && (ival <= 7)) pSiS->XvDefCon = ival;
-	     else SiS_PrintIlRange(pScrn, OPTION_XVDEFCONTRAST, 0, 7, 0);
+	    if((pSiS->ChipType == SIS_662)||(pSiS->ChipType == SIS_671))
+	    {   if((ival >= 0) && (ival <= 255)) pSiS->XvDefCon = ival;
+            else SiS_PrintIlRange(pScrn, OPTION_XVDEFCONTRAST, 0, 255, 0);
+	    }
+	    else{
+            if((ival >= 0) && (ival <= 7)) pSiS->XvDefCon = ival;
+	        else SiS_PrintIlRange(pScrn, OPTION_XVDEFCONTRAST, 0, 7, 0);
+	    }
 	  }
 	  if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFBRIGHTNESS, &ival)) {
 	     if((ival >= -128) && (ival <= 127)) pSiS->XvDefBri = ival;
@@ -2268,6 +2395,31 @@ SiSOptions(ScrnInfoPtr pScrn)
        }
     }
 
+
+	
+    /*chaoyu's modified: here we determind if use Futro timing, which is a special case*/
+    if(xf86GetOptValBool(pSiS->Options, OPTION_FUTRO_TIMING, &val)){
+	if (val) {
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,"We should use Futro special timimg\n");
+		pSiS->SiS_Pr->UseFutroTiming = TRUE;
+	}
+    }
+
+   /*Ivans added,using or non-using CRT1 detection refer to VBIOS*/
+    if(xf86GetOptValBool(pSiS->Options, OPTION_TRACEVGAMISCW, &val)){
+        if (val) {
+                xf86DrvMsg(pScrn->scrnIndex, X_INFO,"Trace CRT1 connection from MISCW. \n");
+                pSiS->trace_VGA_MISCW = TRUE;
+        }
+    }
+    /*Enable to use the panel and timing data on 1366x768 mode. Ivans@090109*/
+    if(xf86GetOptValBool(pSiS->Options, OPTION_USETIMING1366, &val)){
+        if(val){
+                xf86DrvMsg(pScrn->scrnIndex, X_INFO,"Using Special Timing 1366x768 with LVDS.\n");
+                pSiS->EnablePanel_1366x768 = TRUE;		
+        }
+    }
+
 }
 
 const OptionInfoRec *
@@ -2275,3 +2427,4 @@ SISAvailableOptions(int chipid, int busid)
 {
     return SISOptions;
 }
+
diff --git a/src/sis_regs.h b/src/sis_regs.h
index 11dc79e..5512ac2 100644
--- a/src/sis_regs.h
+++ b/src/sis_regs.h
@@ -68,6 +68,7 @@
 
 #define sisfbwriteb(dest, data)        	*(dest)     = (data)
 #define sisfbwritebinc(dest, data)     	*((dest)++) = (data)
+#define sisfbwritebdec(dest, data)     	*((dest)--) = (data)
 #define sisfbwritebp(dest, dataptr)    	*(dest)     = *(dataptr)
 #define sisfbwritebpinc(dest, dataptr) 	*((dest)++) = *((dataptr)++)
 
@@ -317,7 +318,7 @@ static void setSISIDXREGmask(ULong base, UChar idx,
 
 /* Video RAM and MMIO access macros ----- */
 
-#define sisclearvram(where, howmuch) 	bzero(where, howmuch)
+#define sisclearvram(where, howmuch) 	memset(where, 0, howmuch)
 
 /* MMIO */
 #define SIS_MMIO_OUT8   MMIO_OUT8
@@ -448,7 +449,7 @@ static void setSISIDXREGmask(ULong base, UChar idx,
 #define  Index_VI_Overlay_ChromaKey_Blue_V_Max  0x2B
 
 /* Contrast enhancement and brightness control */
-#define  Index_VI_Contrast_Factor               0x2C	/* obviously unused/undefined */
+#define  Index_VI_Contrast_Factor               0x2C
 #define  Index_VI_Brightness                    0x2D
 #define  Index_VI_Contrast_Enh_Ctrl             0x2E
 
@@ -526,9 +527,28 @@ static void setSISIDXREGmask(ULong base, UChar idx,
 
 /* 340 and later: */
 /* DDA registers 0x75 - 0xb4 */
+#define  Horizontal_6Tap_DDA_WeightingMatrix_Index     0x75
+#define  Horizontal_6Tap_DDA_WeightingMatrix_Value      0x76
+#define  Vertical_4Tap_DDA_WeightingMatrix_Index          0x77
+#define  Vertical_4Tap_DDA_WeightingMatrix_Value          0x78
+#define  Index_VI_Control_Misc4                 0x79
+
+
+/*MCE misc regist*/
+#define  Index_VI_MCE_Control_Misc1                 0x8d
+
 /* threshold high 0xb5, 0xb6 */
+#define  Index_VI_Threshold_Ext_Low			0xb5
+#define  Index_VI_Threshold_Ext_High			0xb6
+
 #define  Index_VI_Line_Buffer_Size_High		0xb7
+#define Index_VI_SubPict_Threshold_Ext		0xb8
+
+#define Source_VertLine_Number_Low			0xb9
+#define Source_VertLine_Number_High			0xba
 
+/* for sis671 */
+#define Index_VI_MCE_Control_Misc3			0xc4
 
 /* Bits in Scale control (0x1c) */
 #define  VI_Scale_Ctrl_Horiz_DDA                0x20
diff --git a/src/sis_setup.c b/src/sis_setup.c
index 6a4f015..4081ac7 100644
--- a/src/sis_setup.c
+++ b/src/sis_setup.c
@@ -99,6 +99,145 @@ static const struct _sis6326mclk {
 	{134, 0, 0x4a, 0xa3 }
 };
 
+#include "xf86.h"
+
+
+#ifdef XSERVER_LIBPCIACCESS
+struct pci_device *
+sis_get_device (int device)
+{
+    struct pci_slot_match bridge_match = {
+	0, 0, device, PCI_MATCH_ANY, 0
+    };
+    struct pci_device_iterator	*slot_iterator;
+    struct pci_device		*bridge;
+
+    slot_iterator = pci_slot_match_iterator_create (&bridge_match);
+    bridge = pci_device_next (slot_iterator);
+    pci_iterator_destroy (slot_iterator);
+    return bridge;
+}
+
+unsigned int
+sis_pci_read_device_u32(int device, int offset)
+{
+    struct pci_device *host_bridge = sis_get_device(device);
+    unsigned int result;
+
+    pci_device_cfg_read_u32(host_bridge, &result, offset);
+    return result;
+}
+
+unsigned char
+sis_pci_read_device_u8(int device, int offset)
+{
+    struct pci_device *host_bridge = sis_get_device(device);
+    unsigned char result;
+
+    pci_device_cfg_read_u8(host_bridge, &result, offset);
+    return result;
+}
+
+void
+sis_pci_write_host_bridge_u32(int offset, unsigned int value)
+{
+    struct pci_device *host_bridge = sis_get_device(0);
+    pci_device_cfg_write_u32(host_bridge, value, offset);
+}
+
+void
+sis_pci_write_host_bridge_u8(int offset, unsigned char value)
+{
+    struct pci_device *host_bridge = sis_get_device(0);
+    pci_device_cfg_write_u8(host_bridge, value, offset);
+}
+
+#else
+unsigned int
+sis_pci_read_device_u32(int device, int offset)
+{
+    PCITAG tag = pciTag(0, device, 0);
+    return pciReadLong(tag, offset);
+}
+
+unsigned char
+sis_pci_read_device_u8(int device, int offset)
+{
+    PCITAG tag = pciTag(0, device, 0);
+    return pciReadByte(tag, offset);
+}
+
+void
+sis_pci_write_host_bridge_u32(int offset, unsigned int value)
+{
+    pciWriteLong(0x00000000, offset, value);
+}
+
+void
+sis_pci_write_host_bridge_u8(int offset, unsigned char value)
+{
+    pciWriteByte(0x00000000, offset, value);
+}
+
+
+#endif
+
+unsigned int
+sis_pci_read_host_bridge_u32(int offset)
+{
+    return sis_pci_read_device_u32(0, offset);
+}
+
+unsigned char
+sis_pci_read_host_bridge_u8(int offset)
+{
+    return sis_pci_read_device_u8(0, offset);
+}
+
+static int sisESSPresent(ScrnInfoPtr pScrn)
+{
+  int flags = 0;
+#ifndef XSERVER_LIBPCIACCESS
+  int i;
+  pciConfigPtr pdptr, *systemPCIdevices = NULL;
+
+  if((systemPCIdevices = xf86GetPciConfigInfo())) {
+      i = 0;
+      while((pdptr = systemPCIdevices[i])) {
+	  if((pdptr->pci_vendor == 0x1274) &&
+	     ((pdptr->pci_device == 0x5000) ||
+	      ((pdptr->pci_device & 0xFFF0) == 0x1370))) {
+	      flags |= ESS137xPRESENT;
+	      break;
+	  }
+	  i++;
+      }
+  }
+  return flags;
+#else
+  struct pci_id_match id_match = { 0x1274, PCI_MATCH_ANY,
+				   PCI_MATCH_ANY, PCI_MATCH_ANY,
+				   PCI_MATCH_ANY, PCI_MATCH_ANY,
+				   0 };
+  struct pci_device_iterator *id_iterator;
+  struct pci_device *ess137x;
+
+  id_iterator = pci_id_match_iterator_create(&id_match);
+
+  ess137x = pci_device_next(id_iterator);  
+  while (ess137x) {
+      if ((ess137x->device_id == 0x5000) ||
+	  ((ess137x->device_id & 0xfff0) == 0x1370)) {
+	  flags |= ESS137xPRESENT;
+      }
+      ess137x = pci_device_next(id_iterator);  
+  }
+  return flags;
+#endif
+}
+
+
+
 /* For old chipsets, 5597, 6326, 530/620 */
 static void
 sisOldSetup(ScrnInfoPtr pScrn)
@@ -113,7 +252,7 @@ sisOldSetup(ScrnInfoPtr pScrn)
 #if 0
     UChar  newsr13, newsr28, newsr29;
 #endif
-    pciConfigPtr pdptr, *systemPCIdevices = NULL;
+
 
     if(pSiS->oldChipset <= OC_SIS6225) {
 	inSISIDXREG(SISSR, 0x0F, temp);
@@ -206,24 +345,19 @@ sisOldSetup(ScrnInfoPtr pScrn)
     pSiS->Flags &= ~(ESS137xPRESENT);
     if(pSiS->Chipset == PCI_CHIP_SIS530) {
        if(pSiS->oldChipset == OC_SIS530A) {
-          if((systemPCIdevices = xf86GetPciConfigInfo())) {
-	      i = 0;
-	      while((pdptr = systemPCIdevices[i])) {
-		 if((pdptr->pci_vendor == 0x1274) &&
-		    ((pdptr->pci_device == 0x5000) ||
-		     ((pdptr->pci_device & 0xFFF0) == 0x1370))) {
-		     pSiS->Flags |= ESS137xPRESENT;
-		     break;
-		 }
-		 i++;
-	      }
-	  }
+	   pSiS->Flags |= sisESSPresent(pScrn);
+       }
+       if(pSiS->Flags & ESS137xPRESENT) {
+	   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		      "SiS530/620: Found ESS device\n");
+       }
+    
+    
 	  if(pSiS->Flags & ESS137xPRESENT) {
 	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 		 "SiS530/620: Found ESS device\n");
 	  }
        }
-    }
 
     pSiS->Flags &= ~(SECRETFLAG);
     if(pSiS->oldChipset >= OC_SIS5597) {
@@ -289,20 +423,20 @@ sis300Setup(ScrnInfoPtr pScrn)
     case PCI_CHIP_SIS540:
     case PCI_CHIP_SIS630:
 	pSiS->IsAGPCard = TRUE;
-	pciconfig = pciReadByte(0x00000000, 0x63);
+	pciconfig = sis_pci_read_host_bridge_u8(0x63);
 	if(pciconfig & 0x80) {
 	   pScrn->videoRam = (1 << (((pciconfig & 0x70) >> 4) + 21)) / 1024;
 	   pSiS->BusWidth = 64;
-	   pciconfig = pciReadByte(0x00000000, 0x64);
+	   pciconfig = sis_pci_read_host_bridge_u8(0x64);
 	   if((pciconfig & 0x30) == 0x30) {
 	      pSiS->BusWidth = 128;
 	      pScrn->videoRam <<= 1;
 	   }
-	   ramtype = pciReadByte(0x00000000,0x65);
+	   ramtype = sis_pci_read_host_bridge_u8(0x65);
 	   ramtype &= 0x03;
 	   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 		"Shared Memory Area is on DIMM%d\n", ramtype);
-	   ramtype = pciReadByte(0x00000000,(0x60 + ramtype));
+	   ramtype = sis_pci_read_host_bridge_u8(0x60 + ramtype);
 	   if(ramtype & 0x80) ramtype = 9;
 	   else               ramtype = 4;
 	   pSiS->UMAsize = pScrn->videoRam;
@@ -546,7 +680,7 @@ sis315Setup(ScrnInfoPtr pScrn)
 		pSiS->BusWidth);
 }
 
-/* For 550, 65x, 740, 661, 741, 660, 760, 761 */
+/* For 550, 65x, 740, 661, 741, 660, 760, 761, 670, 770 */
 static void
 sis550Setup(ScrnInfoPtr pScrn)
 {
@@ -562,13 +696,64 @@ sis550Setup(ScrnInfoPtr pScrn)
 
     pSiS->MemClock = SiSMclk(pSiS);
 
-    if(pSiS->Chipset == PCI_CHIP_SIS660) {
+    if(pSiS->Chipset == PCI_CHIP_SIS671){
+       inSISIDXREG(SISCR,0x79,config);
+       /* DDR */
+       ramtype = 8; 
+
+       /* Bus Data Width*/
+       pSiS->BusWidth = (!(config & 0x0C))? 64 : 0;
+       if (pSiS->BusWidth == 0) xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       				"Bad Bus Width!\n");
+
+	/* share mem (UMA) size */
+       	pScrn->videoRam = 0;
+	unsigned int power = (config & 0xf0) >> 4;
+      	if(power){
+		for(pScrn->videoRam = 1; power>0 ; power--)
+			pScrn->videoRam *= 2;
+	}
+	pScrn->videoRam *= 1024; /* K */
+	pSiS->UMAsize = pScrn->videoRam;
+      	pSiS->SiS76xUMASize = pScrn->videoRam * 1024; /* byte */
+	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			"%dK shared video RAM (UMA)\n",
+			pScrn->videoRam);
+	
+
+
+	pSiS->ChipFlags |= SiSCF_760UMA;
+	pSiS->IsPCIExpress = TRUE;
+	alldone = TRUE;
 
-       if(pSiS->ChipType >= SIS_660) {
+
+
+    } else if(pSiS->Chipset == PCI_CHIP_SIS670) {
+
+       pScrn->videoRam = 0;
+       pciconfig = sis_pci_read_host_bridge_u8(0x4c);
+       if(pciconfig & 0xe0) {
+	  pScrn->videoRam = (1 << (((pciconfig & 0xe0) >> 5) - 2)) * 32768;
+	  pSiS->ChipFlags |= SiSCF_760UMA;
+	  pSiS->SiS76xUMASize = pScrn->videoRam * 1024;
+	  pSiS->UMAsize = pScrn->videoRam;
+	  xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		"%dK shared video RAM (UMA)\n",
+		pScrn->videoRam);
+	  pSiS->BusWidth = 64;
+          ramtype = 8;
+          alldone = TRUE;
+       }
+
+    } else if(pSiS->Chipset == PCI_CHIP_SIS660) {
+
+       if(pSiS->ChipType >= SIS_660&&pSiS->ChipType <= SIS_761) {
+
+          /* 660, 760 */
 
 	  /* UMA - shared fb */
 	  pScrn->videoRam = 0;
-	  pciconfig = pciReadByte(0x00000000, 0x4c);
+	  pciconfig = sis_pci_read_host_bridge_u8(0x4c);
 	  if(pciconfig & 0xe0) {
 	     pScrn->videoRam = (1 << (((pciconfig & 0xe0) >> 5) - 2)) * 32768;
 	     pSiS->ChipFlags |= SiSCF_760UMA;
@@ -580,7 +765,8 @@ sis550Setup(ScrnInfoPtr pScrn)
 	  }
 
 	  /* LFB - local framebuffer: PCI reg hold total RAM (but configurable in BIOS) */
-	  pciconfig = pciReadByte(0x00000800, 0xcd);
+	  /* TODO */
+	  pciconfig = sis_pci_read_device_u8(1, 0xcd);
 	  pciconfig = (pciconfig >> 1) & 0x03;
 	  i = 0;
 	  if(pciconfig == 0x01)      i = 32768;
@@ -621,7 +807,44 @@ sis550Setup(ScrnInfoPtr pScrn)
 	     pSiS->IsPCIExpress = TRUE;
 	  }
 
-       } else {  /* 661, 741 */
+       } else if(pSiS->ChipType >= SIS_662){
+
+	  /* 662 */
+
+	  int dimmnum;
+
+	  if(pSiS->ChipType == SIS_662) {
+	     dimmnum = 2;
+	  }
+
+	  pciconfig = sis_pci_read_host_bridge_u8(0x64);
+	  if(pciconfig & 0x80) {
+	     pScrn->videoRam = (1 << (((pciconfig & 0x60) >> 5) )) * 32768;
+	     pSiS->UMAsize = pScrn->videoRam;
+	     if((pScrn->videoRam < 32768) || (pScrn->videoRam > (128 * 1024))) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+			"Illegal video RAM size (%dK) detected, using BIOS-provided info\n",
+			pScrn->videoRam);
+	     } else {
+		pSiS->BusWidth = 64;
+		for(i = 0; i <= (dimmnum - 1); i++) {
+		   if(pciconfig & (1 << i)) {
+		      temp = sis_pci_read_host_bridge_u8(0x60 + i);
+		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			  "DIMM%d is %s SDRAM\n",
+			  i, (temp & 0x40) ? "DDR2" : "non-DDR2");
+		   } else {
+		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+			  "DIMM%d is not installed\n", i);
+		   }
+		}
+		alldone = FALSE;
+	     }
+          }
+
+
+       }else{
+	  /* 661, 741 */
 
 	  int dimmnum;
 
@@ -631,9 +854,10 @@ sis550Setup(ScrnInfoPtr pScrn)
 	     dimmnum = 3;
 	  }
 
-	  pciconfig = pciReadByte(0x00000000, 0x64);
+	  pciconfig = sis_pci_read_host_bridge_u8(0x64);
 	  if(pciconfig & 0x80) {
 	     pScrn->videoRam = (1 << (((pciconfig & 0x70) >> 4) - 1)) * 32768;
+
 	     pSiS->UMAsize = pScrn->videoRam;
 	     if((pScrn->videoRam < 32768) || (pScrn->videoRam > (128 * 1024))) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
@@ -643,7 +867,7 @@ sis550Setup(ScrnInfoPtr pScrn)
 		pSiS->BusWidth = 64;
 		for(i = 0; i <= (dimmnum - 1); i++) {
 		   if(pciconfig & (1 << i)) {
-		      temp = pciReadByte(0x00000000, 0x60 + i);
+		      temp = sis_pci_read_host_bridge_u8(0x60 + i);
 		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 			  "DIMM%d is %s SDRAM\n",
 			  i, (temp & 0x40) ? "DDR" : "SDR");
@@ -652,7 +876,7 @@ sis550Setup(ScrnInfoPtr pScrn)
 			  "DIMM%d is not installed\n", i);
 		   }
 		}
-		pciconfig = pciReadByte(0x00000000, 0x7c);
+		pciconfig = sis_pci_read_host_bridge_u8(0x7c);
 		ramtype = (pciconfig & 0x02) ? 8 : 4;
 		alldone = TRUE;
 	     }
@@ -662,14 +886,16 @@ sis550Setup(ScrnInfoPtr pScrn)
 
     } else if(pSiS->Chipset == PCI_CHIP_SIS650) {
 
-       pciconfig = pciReadByte(0x00000000, 0x64);
+       /* 65x, 741 */
+
+       pciconfig = sis_pci_read_host_bridge_u8(0x64);
        if(pciconfig & 0x80) {
           pScrn->videoRam = (1 << (((pciconfig & 0x70) >> 4) + 22)) / 1024;
 	  pSiS->UMAsize = pScrn->videoRam;
 	  pSiS->BusWidth = 64;
 	  for(i=0; i<=3; i++) {
 	     if(pciconfig & (1 << i)) {
-		temp = pciReadByte(0x00000000, 0x60 + i);
+		temp = sis_pci_read_host_bridge_u8(0x60 + i);
 		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 		   "DIMM%d is %s SDRAM\n",
 		   i, (temp & 0x40) ? "DDR" : "SDR");
@@ -678,7 +904,7 @@ sis550Setup(ScrnInfoPtr pScrn)
 		   "DIMM%d is not installed\n", i);
 	     }
 	  }
-	  pciconfig = pciReadByte(0x00000000, 0x7c);
+	  pciconfig = sis_pci_read_host_bridge_u8(0x7c);
 	  if(pciconfig & 0x02) ramtype = 8;
 	  else                 ramtype = 4;
 	  alldone = TRUE;
@@ -686,12 +912,14 @@ sis550Setup(ScrnInfoPtr pScrn)
 
     } else {
 
-       pciconfig = pciReadByte(0x00000000, 0x63);
+       /* 550 */
+
+       pciconfig = sis_pci_read_host_bridge_u8(0x63);
        if(pciconfig & 0x80) {
 	  pScrn->videoRam = (1 << (((pciconfig & 0x70) >> 4) + 21)) / 1024;
 	  pSiS->UMAsize = pScrn->videoRam;
 	  pSiS->BusWidth = 64;
-	  ramtype = pciReadByte(0x00000000,0x65);
+          ramtype = sis_pci_read_host_bridge_u8(0x65);
 	  ramtype &= 0x01;
 	  xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 	   	"Shared Memory Area is on DIMM%d\n", ramtype);
@@ -708,14 +936,48 @@ sis550Setup(ScrnInfoPtr pScrn)
        pSiS->SiS76xLFBSize = pSiS->SiS76xUMASize = 0;
        pSiS->UMAsize = pSiS->LFBsize = 0;
 
-       if(pSiS->Chipset == PCI_CHIP_SIS660) {
+       if(pSiS->Chipset == PCI_CHIP_SIS670) {
+
+          pScrn->videoRam = 0;
+          inSISIDXREG(SISCR, 0x78, config);
+	  if(config & 0xf0) {
+	     pScrn->videoRam = (1 << ((config & 0xf0) >> 4)) * 1024;
+	     pSiS->UMAsize = pScrn->videoRam;
+	     pSiS->ChipFlags |= SiSCF_760UMA;
+	     pSiS->SiS76xUMASize = pScrn->videoRam * 1024;
+	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+				"%dK shared video RAM (UMA)\n",
+				pScrn->videoRam);
+	  }
+
+       } else if(pSiS->Chipset == PCI_CHIP_SIS660) {
+
 	  inSISIDXREG(SISCR, 0x79, config);
+	  
 	  pSiS->BusWidth = (config & 0x04) ? 128 : 64;
-	  ramtype = (config & 0x01) ? 8 : 4;
+          if(pSiS->ChipType == SIS_662){
+              switch (config&0x03){
+                  case 1:
+                  ramtype = 8;
+                  break;
+				  
+                  case 2:
+                  default: 
+                  ramtype = 0xa;
+
+                  break;
+              }
+          }else{
+              ramtype = (config & 0x01) ? 8 : 4;
+          }
+
 	  if(pSiS->ChipType >= SIS_660) {
-	     pScrn->videoRam = 0;
 	     if(config & 0xf0) {
-		pScrn->videoRam = (1 << ((config & 0xf0) >> 4)) * 1024;
+                if(pScrn->videoRam!=((1 << ((config & 0xf0) >> 4)) * 1024)){
+		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+				"The size we got from SBIOS is defferent than VBIOS.  And we take the value from VBIOS\n");
+                    pScrn->videoRam = (1 << ((config & 0xf0) >> 4)) * 1024;
+		}
 		pSiS->UMAsize = pScrn->videoRam;
 		pSiS->ChipFlags |= SiSCF_760UMA;
 		pSiS->SiS76xUMASize = pScrn->videoRam * 1024;
@@ -723,27 +985,31 @@ sis550Setup(ScrnInfoPtr pScrn)
 				"%dK shared video RAM (UMA)\n",
 				pScrn->videoRam);
 	     }
-	     inSISIDXREG(SISCR, 0x78, config);
-	     config &= 0x30;
-	     if(config) {
-	        i = 0;
-		if(config == 0x10)      i = 32768;
-		else if(config == 0x30) i = 65536;
-		if(i) {
-		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"%dK configured local video RAM (LFB)\n", i);
-		   pScrn->videoRam += i;
-		   pSiS->SiS76xLFBSize = i * 1024;
-		   pSiS->LFBsize = i;
-		   pSiS->ChipFlags |= SiSCF_760LFB;
 
-		}
-	     }
+             if(pSiS->ChipType < SIS_662){		 
+	         inSISIDXREG(SISCR, 0x78, config);
+                 config &= 0x30;
+                 if(config) {
+                    i = 0;
+                    if(config == 0x10)      i = 32768;
+                    else if(config == 0x30) i = 65536;
+                    if(i) {
+                       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                             "%dK configured local video RAM (LFB)\n", i);
+                       pScrn->videoRam += i;
+                       pSiS->SiS76xLFBSize = i * 1024;
+                       pSiS->LFBsize = i;
+                       pSiS->ChipFlags |= SiSCF_760LFB;
+                    }
+                 }
+             }
 	  } else {
 	     pScrn->videoRam = (1 << ((config & 0xf0) >> 4)) * 1024;
 	     pSiS->UMAsize = pScrn->videoRam;
 	  }
+
        } else {
+
 	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 	      "Shared Memory Area is disabled - awaiting doom\n");
 	  inSISIDXREG(SISSR, 0x14, config);
@@ -759,11 +1025,18 @@ sis550Setup(ScrnInfoPtr pScrn)
        }
     }
 
-    /* These need special attention: Memory controller in CPU, hence
+    /* These (might) need special attention: Memory controller in CPU, hence
      * - no DDR * 2 for bandwidth calculation,
      * - overlay magic (bandwidth dependent one/two overlay stuff)
      */
-    if((pSiS->ChipType >= SIS_760) && (pSiS->ChipType <= SIS_770)) {
+    switch(pSiS->ChipType) {
+    case SIS_760:
+#ifdef SIS761MEMFIX
+    case SIS_761:
+#endif
+#ifdef SIS770MEMFIX
+    case SIS_770:
+#endif
        if(!(pSiS->ChipFlags & SiSCF_760LFB)) {
 	  ddrtimes2 = FALSE;
 	  pSiS->SiS_SD2_Flags |= SiS_SD2_SUPPORT760OO;
@@ -773,6 +1046,7 @@ sis550Setup(ScrnInfoPtr pScrn)
     /* DDR -> Mclk * 2 - needed for bandwidth calculation */
     if(ddrtimes2) {
        if(ramtype == 8) pSiS->MemClock *= 2;
+       if(ramtype == 0xa) pSiS->MemClock *= 2;	   
     }
 
     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
@@ -798,7 +1072,7 @@ SiSSetup(ScrnInfoPtr pScrn)
     pSiS->SiS76xLFBSize = pSiS->SiS76xUMASize = 0;
     pSiS->UMAsize = pSiS->LFBsize = 0;
 
-    switch (SISPTR(pScrn)->Chipset) {
+    switch(pSiS->Chipset) {
     case PCI_CHIP_SIS300:
     case PCI_CHIP_SIS630:  /* +730 */
     case PCI_CHIP_SIS540:
@@ -814,8 +1088,10 @@ SiSSetup(ScrnInfoPtr pScrn)
     	sis315Setup(pScrn);
 	break;
     case PCI_CHIP_SIS550:
-    case PCI_CHIP_SIS650: /* + 740,M650,651 */
-    case PCI_CHIP_SIS660: /* + (M)661,(M)741,(M)760(GX), (M)761(GX), 770? */
+    case PCI_CHIP_SIS650: /* + 740, M650, 651 */
+    case PCI_CHIP_SIS660: /* + (M)661, (M)741, (M)760(GX), (M)761(GX) */
+    case PCI_CHIP_SIS670: /* 670, 770 */
+    case PCI_CHIP_SIS671: /* 671, 771 */
         sis550Setup(pScrn);
 	break;
     case PCI_CHIP_SIS5597:
diff --git a/src/sis_shadow.c b/src/sis_shadow.c
index 0648ee7..06c7671 100644
--- a/src/sis_shadow.c
+++ b/src/sis_shadow.c
@@ -25,8 +25,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  *
- * This module doesn't use CurrentLayout, because it is never
- * active when DGA is active and vice versa.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -37,7 +35,6 @@
 #include "servermd.h"
 
 void SISPointerMoved(int index, int x, int y);
-void SISPointerMovedReflect(int index, int x, int y);
 void SISRefreshArea(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
@@ -45,34 +42,51 @@ void SISRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void SISRefreshArea24(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 void SISRefreshArea32(ScrnInfoPtr pScrn, int num, BoxPtr pbox);
 
+
 void
 SISPointerMoved(int index, int x, int y)
 {
     ScrnInfoPtr pScrn = xf86Screens[index];
     SISPtr pSiS = SISPTR(pScrn);
+    Bool framechanged = FALSE;
+
+    /* Beware: This is executed asynchronously. */
+
+    if(pSiS->DGAactive)
+       return;
+
+    if(pSiS->Rotate) {
+       if(pScrn->frameX0 > x) {
+	  pScrn->frameX0 = x;
+	  pScrn->frameX1 = x + pScrn->currentMode->VDisplay - 1;
+	  framechanged = TRUE ;
+       }
+
+       if(pScrn->frameX1 < x) {
+	  pScrn->frameX1 = x + 1;
+	  pScrn->frameX0 = x - pScrn->currentMode->VDisplay + 1;
+	  framechanged = TRUE ;
+       }
+
+       if(pScrn->frameY0 > y) {
+	  pScrn->frameY0 = y;
+	  pScrn->frameY1 = y + pScrn->currentMode->HDisplay - 1;
+	  framechanged = TRUE;
+       }
+
+       if(pScrn->frameY1 < y) {
+	  pScrn->frameY1 = y;
+	  pScrn->frameY0 = y - pScrn->currentMode->HDisplay + 1;
+	  framechanged = TRUE;
+       }
+
+       if(framechanged && pScrn->AdjustFrame)
+	  pScrn->AdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
 
-    if(pSiS->Rotate == 1) {
-       (*pSiS->PointerMoved)(index, pScrn->pScreen->height - y - 1, x);
     } else {
-       (*pSiS->PointerMoved)(index, y, pScrn->pScreen->width - x - 1);
-    }
-}
 
-void
-SISPointerMovedReflect(int index, int x, int y)
-{
-    ScrnInfoPtr pScrn = xf86Screens[index];
-    SISPtr pSiS = SISPTR(pScrn);
+       (*pSiS->PointerMoved)(index, x, y);
 
-    switch(pSiS->Reflect) {
-    case 1: /* x */
-       (*pSiS->PointerMoved)(index, pScrn->pScreen->width - x - 1, y);
-       break;
-    case 2: /* y */
-       (*pSiS->PointerMoved)(index, x, pScrn->pScreen->height - y - 1);
-       break;
-    case 3: /* x + y */
-       (*pSiS->PointerMoved)(index, pScrn->pScreen->width - x - 1, pScrn->pScreen->height - y - 1);
     }
 }
 
@@ -85,8 +99,8 @@ SISRefreshArea(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
     int    width, height, Bpp, FBPitch;
     CARD8  *src, *dst;
 
-    Bpp = pScrn->bitsPerPixel >> 3;
-    FBPitch = BitmapBytePad(pScrn->displayWidth * pScrn->bitsPerPixel);
+    Bpp = pSiS->CurrentLayout.bytesPerPixel;
+    FBPitch = BitmapBytePad(pScrn->displayWidth * pSiS->CurrentLayout.bitsPerPixel);
 
     while(num--) {
 
@@ -107,8 +121,9 @@ SISRefreshArea(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 
 /* RefreshArea for reflection */
 
-void
-SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+static void
+SISRealRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox,
+			CARD8 *sourcePtr, CARD8 *destPtr, int srcPitch, int dstWidth)
 {
     SISPtr pSiS = SISPTR(pScrn);
     int    width, height, Bpp, FBPitch, twidth;
@@ -116,17 +131,17 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
     CARD16 *tdst16, *tsrc16;
     CARD32 *tdst32, *tsrc32;
 
-    Bpp = pScrn->bitsPerPixel >> 3;
-    FBPitch = BitmapBytePad(pScrn->displayWidth * pScrn->bitsPerPixel);
+    Bpp = pSiS->CurrentLayout.bytesPerPixel;
+    FBPitch = dstWidth * Bpp;
 
     while(num--) {
        width = (pbox->x2 - pbox->x1) * Bpp;
        height = pbox->y2 - pbox->y1;
-       src = pSiS->ShadowPtr + (pbox->y1 * pSiS->ShadowPitch) +  (pbox->x1 * Bpp);
-       dst = pSiS->FbBase;
+       src = sourcePtr + (pbox->y1 * srcPitch) + (pbox->x1 * Bpp);
+       dst = destPtr;
        switch(pSiS->Reflect) {
        case 1:	/* x */
-	  dst += (pbox->y1 * FBPitch) + ((pScrn->displayWidth - pbox->x1 - 1) * Bpp);
+	  dst += (pbox->y1 * FBPitch) + ((pScrn->virtualX - pbox->x1 - 1) * Bpp);
 	  switch(Bpp) {
 	     case 1:
 		while(height--) {
@@ -135,7 +150,7 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 		   twidth = width;
 		   while(twidth--) *tdst-- = *tsrc++;
 		   dst += FBPitch;
-		   src += pSiS->ShadowPitch;
+		   src += srcPitch;
 		}
 		break;
 	     case 2:
@@ -146,7 +161,7 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 		   twidth = width;
 		   while(twidth--) *tdst16-- = *tsrc16++;
 		   dst += FBPitch;
-		   src += pSiS->ShadowPitch;
+		   src += srcPitch;
 		}
 		break;
 	     case 4:
@@ -157,7 +172,7 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 		   twidth = width;
 		   while(twidth--) *tdst32-- = *tsrc32++;
 		   dst += FBPitch;
-		   src += pSiS->ShadowPitch;
+		   src += srcPitch;
 		}
 	  }
 	  break;
@@ -166,11 +181,11 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 	  while(height--) {
 	     SiSMemCopyToVideoRam(pSiS, dst, src, width);
 	     dst -= FBPitch;
-	     src += pSiS->ShadowPitch;
+	     src += srcPitch;
 	  }
 	  break;
        case 3:	/* x + y */
-	  dst += ((pScrn->virtualY - pbox->y1 - 1) * FBPitch) + ((pScrn->displayWidth - pbox->x1 - 1) * Bpp);
+	  dst += ((pScrn->virtualY - pbox->y1 - 1) * FBPitch) + ((pScrn->virtualX - pbox->x1 - 1) * Bpp);
 	  switch(Bpp) {
 	     case 1:
 		while(height--) {
@@ -179,7 +194,7 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 		   twidth = width;
 		   while(twidth--) *tdst-- = *tsrc++;
 		   dst -= FBPitch;
-		   src += pSiS->ShadowPitch;
+		   src += srcPitch;
 		}
 		break;
 	     case 2:
@@ -190,7 +205,7 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 		   twidth = width;
 		   while(twidth--) *tdst16-- = *tsrc16++;
 		   dst -= FBPitch;
-		   src += pSiS->ShadowPitch;
+		   src += srcPitch;
 		}
 		break;
 	     case 4:
@@ -201,7 +216,7 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 		   twidth = width;
 		   while(twidth--) *tdst32-- = *tsrc32++;
 		   dst -= FBPitch;
-		   src += pSiS->ShadowPitch;
+		   src += srcPitch;
 		}
 		break;
 	  }
@@ -210,18 +225,27 @@ SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
     }
 }
 
+void
+SISRefreshAreaReflect(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    SISRealRefreshAreaReflect(pScrn, num, pbox, (CARD8 *)pSiS->ShadowPtr,
+    		(CARD8 *)pSiS->FbBase, pSiS->ShadowPitch, pScrn->displayWidth);
+}
+
 /* RefreshArea()s for rotation */
 
-void
-SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+static void
+SISRealRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox,
+		CARD8 *sourcePtr, CARD8 *destPtr, int srcPitch, int dstWidth)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    int    count, width, height, y1, y2, dstPitch, srcPitch;
+    int    count, width, height, y1, y2;
     CARD8  *dstPtr, *srcPtr, *src;
     CARD32 *dst;
 
-    dstPitch = pScrn->displayWidth;
-    srcPitch = -pSiS->Rotate * pSiS->ShadowPitch;
+    srcPitch *= (-pSiS->Rotate);
 
     while(num--) {
        width = pbox->x2 - pbox->x1;
@@ -230,11 +254,11 @@ SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
        height = (y2 - y1) >> 2;  /* in dwords */
 
        if(pSiS->Rotate == 1) {
-	  dstPtr = pSiS->FbBase + (pbox->x1 * dstPitch) + pScrn->virtualX - y2;
-	  srcPtr = pSiS->ShadowPtr + ((1 - y2) * srcPitch) + pbox->x1;
+	  dstPtr = destPtr + (pbox->x1 * dstWidth) + pScrn->virtualX - y2;
+	  srcPtr = sourcePtr + ((1 - y2) * srcPitch) + pbox->x1;
        } else {
-	  dstPtr = pSiS->FbBase +  ((pScrn->virtualY - pbox->x2) * dstPitch) + y1;
-	  srcPtr = pSiS->ShadowPtr + (y1 * srcPitch) + pbox->x2 - 1;
+	  dstPtr = destPtr +  ((pScrn->virtualY - pbox->x2) * dstWidth) + y1;
+	  srcPtr = sourcePtr + (y1 * srcPitch) + pbox->x2 - 1;
        }
 
        while(width--) {
@@ -249,7 +273,7 @@ SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 	     src += (srcPitch * 4);
 	  }
 	  srcPtr += pSiS->Rotate;
-	  dstPtr += dstPitch;
+	  dstPtr += dstWidth;
        }
 
        pbox++;
@@ -257,15 +281,24 @@ SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 }
 
 void
-SISRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+SISRefreshArea8(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    SISRealRefreshArea8(pScrn, num, pbox, (CARD8 *)pSiS->ShadowPtr,
+	(CARD8 *)pSiS->FbBase, pSiS->ShadowPitch, pScrn->displayWidth);
+}
+
+static void
+SISRealRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox,
+		CARD16 *sourcePtr, CARD16 *destPtr, int srcPitch, int dstWidth)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    int count, width, height, y1, y2, dstPitch, srcPitch;
+    int count, width, height, y1, y2;
     CARD16 *dstPtr, *srcPtr, *src;
     CARD32 *dst;
 
-    dstPitch = pScrn->displayWidth;
-    srcPitch = -pSiS->Rotate * pSiS->ShadowPitch >> 1;
+    srcPitch = -pSiS->Rotate * srcPitch >> 1;
 
     while(num--) {
        width = pbox->x2 - pbox->x1;
@@ -274,11 +307,11 @@ SISRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
        height = (y2 - y1) >> 1;  /* in dwords */
 
        if(pSiS->Rotate == 1) {
-	  dstPtr = (CARD16 *)pSiS->FbBase + (pbox->x1 * dstPitch) + pScrn->virtualX - y2;
-	  srcPtr = (CARD16 *)pSiS->ShadowPtr + ((1 - y2) * srcPitch) + pbox->x1;
+	  dstPtr = destPtr + (pbox->x1 * dstWidth) + pScrn->virtualX - y2;
+	  srcPtr = sourcePtr + ((1 - y2) * srcPitch) + pbox->x1;
        } else {
-	  dstPtr = (CARD16 *)pSiS->FbBase + ((pScrn->virtualY - pbox->x2) * dstPitch) + y1;
-	  srcPtr = (CARD16 *)pSiS->ShadowPtr + (y1 * srcPitch) + pbox->x2 - 1;
+	  dstPtr = destPtr + ((pScrn->virtualY - pbox->x2) * dstWidth) + y1;
+	  srcPtr = sourcePtr + (y1 * srcPitch) + pbox->x2 - 1;
        }
 
        while(width--) {
@@ -290,13 +323,22 @@ SISRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 	     src += (srcPitch * 2);
 	  }
 	  srcPtr += pSiS->Rotate;
-	  dstPtr += dstPitch;
+	  dstPtr += dstWidth;
        }
 
        pbox++;
     }
 }
 
+void
+SISRefreshArea16(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    SISRealRefreshArea16(pScrn, num, pbox, (CARD16 *)pSiS->ShadowPtr,
+	(CARD16 *)pSiS->FbBase, pSiS->ShadowPitch, pScrn->displayWidth);
+}
+
 /* this one could be faster */
 void
 SISRefreshArea24(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
@@ -351,26 +393,26 @@ SISRefreshArea24(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
     }
 }
 
-void
-SISRefreshArea32(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+static void
+SISRealRefreshArea32(ScrnInfoPtr pScrn, int num, BoxPtr pbox,
+		CARD32 *sourcePtr, CARD32 *destPtr, int srcPitch, int dstWidth)
 {
     SISPtr pSiS = SISPTR(pScrn);
-    int    count, width, height, dstPitch, srcPitch;
+    int    count, width, height;
     CARD32 *dstPtr, *srcPtr, *src, *dst;
 
-    dstPitch = pScrn->displayWidth;
-    srcPitch = -pSiS->Rotate * pSiS->ShadowPitch >> 2;
+    srcPitch = -pSiS->Rotate * srcPitch >> 2;
 
     while(num--) {
        width = pbox->x2 - pbox->x1;
        height = pbox->y2 - pbox->y1;
 
        if(pSiS->Rotate == 1) {
-	  dstPtr = (CARD32 *)pSiS->FbBase + (pbox->x1 * dstPitch) + pScrn->virtualX - pbox->y2;
-	  srcPtr = (CARD32 *)pSiS->ShadowPtr + ((1 - pbox->y2) * srcPitch) + pbox->x1;
+	  dstPtr = destPtr + (pbox->x1 * dstWidth) + pScrn->virtualX - pbox->y2;
+	  srcPtr = sourcePtr + ((1 - pbox->y2) * srcPitch) + pbox->x1;
        } else {
-	  dstPtr = (CARD32 *)pSiS->FbBase + ((pScrn->virtualY - pbox->x2) * dstPitch) + pbox->y1;
-	  srcPtr = (CARD32 *)pSiS->ShadowPtr + (pbox->y1 * srcPitch) + pbox->x2 - 1;
+	  dstPtr = destPtr + ((pScrn->virtualY - pbox->x2) * dstWidth) + pbox->y1;
+	  srcPtr = sourcePtr + (pbox->y1 * srcPitch) + pbox->x2 - 1;
        }
 
        while(width--) {
@@ -382,9 +424,24 @@ SISRefreshArea32(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
 	     src += srcPitch;
 	  }
 	  srcPtr += pSiS->Rotate;
-	  dstPtr += dstPitch;
+	  dstPtr += dstWidth;
        }
 
        pbox++;
     }
 }
+
+void
+SISRefreshArea32(ScrnInfoPtr pScrn, int num, BoxPtr pbox)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    SISRealRefreshArea32(pScrn, num, pbox, (CARD32 *)pSiS->ShadowPtr,
+	(CARD32 *)pSiS->FbBase, pSiS->ShadowPitch, pScrn->displayWidth);
+}
+
+
+
+
+
+
diff --git a/src/sis_utility.c b/src/sis_utility.c
index 46f272b..76bf1bf 100644
--- a/src/sis_utility.c
+++ b/src/sis_utility.c
@@ -171,8 +171,13 @@
 #define SDC_CMD_SETCRT1SATGAIN		0x98980064
 #define SDC_CMD_GETCRT2SATGAIN		0x98980065
 #define SDC_CMD_SETCRT2SATGAIN		0x98980066
+#define SDC_CMD_REDETECTCRT1DEVICES	0x98980067
+#define SDC_CMD_RESETCRT1STATUS		0x98980068
+#define SDC_CMD_DEVICESWITCH            0x98980069/*Device Switch cmd from utility(Ivans Lee)*/
+#define SDC_CMD_GETALLREDETECTINFO      0x98980070/*query all device redetecting result(Ivans Lee)*/
+#define SDC_CMD_GETCURRENTSTATE         0x98980071/*query device current state(Ivans Lee)*/
 /* more to come, adapt MAXCOMMAND! */
-#define SDC_MAXCOMMAND			SDC_CMD_SETCRT2SATGAIN
+#define SDC_MAXCOMMAND			SDC_CMD_RESETCRT1STATUS
 
 /* in result_header */
 #define SDC_RESULT_OK  			0x66670000
@@ -263,18 +268,16 @@ int		SISHandleMessage(int scrnIndex, const char *msgtype, const char *msgval, ch
 void		SiSCtrlExtInit(ScrnInfoPtr pScrn);
 void		SiSCtrlExtUnregister(SISPtr pSiS, int index);
 
-#ifdef XV_SD_DEPRECATED
+#ifdef TWDEBUG
 int		SISSetPortUtilAttribute(ScrnInfoPtr pScrn, Atom attribute,
 					INT32 value, SISPortPrivPtr pPriv);
-int		SISGetPortUtilAttribute(ScrnInfoPtr pScrn,  Atom attribute,
-					INT32 *value, SISPortPrivPtr pPriv);
 #endif
 
-extern Bool 	SISRedetectCRT2Type(ScrnInfoPtr pScrn);
+extern Bool	SISRedetectCRT2Type(ScrnInfoPtr pScrn);
 extern UShort	SiS_CheckModeCRT1(ScrnInfoPtr pScrn, DisplayModePtr mode,
-				 unsigned int VBFlags, Bool hcm);
+				 unsigned int VBFlags, unsigned int VBFlags3, Bool hcm);
 extern UShort	SiS_CheckModeCRT2(ScrnInfoPtr pScrn, DisplayModePtr mode,
-				 unsigned int VBFlags, Bool hcm);
+				 unsigned int VBFlags, unsigned int VBFlags3, Bool hcm);
 extern void	SISAdjustFrame(int scrnIndex, int x, int y, int flags);
 extern float	SiSCalcVRate(DisplayModePtr mode);
 extern void	SiS_UpdateGammaCRT2(ScrnInfoPtr pScrn);
@@ -300,6 +303,8 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
     int crt1off;
 
     /* onoff: 0=OFF, 1=ON(VGA), 2=ON(LCDA) */
+    /* For future use: 3=CRT1_LCD (via CRT1-bridge) */
+    /* (LCDA is not the same as CRT1_LCD!) */
 
     /* Switching to LCDA will disable CRT2 if previously LCD or VGA,
      * unless on a dual-vb setup
@@ -321,17 +326,21 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
 
     /* Do NOT use this to switch from CRT1_LCDA to CRT2_LCD */
 
-    /* Only on 300 and 315/330/340 series */
-    if(pSiS->VGAEngine != SIS_300_VGA &&
-       pSiS->VGAEngine != SIS_315_VGA) return FALSE;
-
-    /* Off only if at least one CRT2 device is active */
-    if((!onoff) && (!(vbflags & CRT2_ENABLE))) return FALSE;
+    /* Only on 300+ series */
+    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
+       return FALSE;
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) return FALSE;
+    if(pSiS->DualHeadMode)
+       return FALSE;
 #endif
 
+    /* Off only if at least one CRT2 device is active */
+    if((!onoff) && (!(vbflags & CRT2_ENABLE)))
+       return FALSE;
+    
+    if(pSiS->ChipType==SIS_671 && onoff==2)
+    {onoff=1;} 
     /* Can't switch to LCDA if not supported (duh!) */
     if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
        if(onoff == 2) {
@@ -343,6 +352,16 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
        }
     }
 
+    if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
+       if(onoff == 3) {
+          if(!quiet) {
+             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+	        "CRT1_LCD not supported yet.\n");
+	  }
+          return FALSE;
+       }
+    }
+
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
        if(((SiSMergedDisplayModePtr)mode->Private)->CRT2Position != sisClone) {
@@ -353,15 +372,19 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
 	     }
              return FALSE;
           } else if(onoff == 2) {
-             if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
-                if(vbflags & (CRT2_LCD|CRT2_VGA)) {
-	           if(!quiet) {
-	              xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-	   	         "CRT1 type can only be VGA while CRT2 is LCD or VGA\n");
-	           }
-                   return FALSE;
-                }
+             if(vbflags & (CRT2_LCD|CRT2_VGA)) {
+	        if(!quiet) {
+	           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		       "CRT1 type can only be VGA while CRT2 is LCD or VGA\n");
+	        }
+                return FALSE;
+             }
+          } else if(onoff == 3) {
+             if(!quiet) {
+	        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		       "CRT1_LCD not supported yet.\n");
 	     }
+             return FALSE;
           }
        }
        if(mode->Private) {
@@ -378,10 +401,9 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
        crt1off = 0;
        if(onoff == 2) {
 	  vbflags |= CRT1_LCDA;
-	  vbflags3 |= VB3_CRT1_LCD;
-	  if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
-	     vbflags &= ~(CRT2_LCD|CRT2_VGA);
-	  }
+	  vbflags &= ~(CRT2_LCD | CRT2_VGA);
+       } else if(onoff == 3) {
+          vbflags3 |= VB3_CRT1_LCD;
        } else {
           vbflags3 |= VB3_CRT1_VGA;
        }
@@ -392,11 +414,11 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
        vbflags |= SINGLE_MODE;
     }
 
-    if(vbflags & CRT1_LCDA) {
-       if(SiS_CheckModeCRT1(pScrn, mode, vbflags, pSiS->HaveCustomModes) < 0x14) {
+    if((vbflags & CRT1_LCDA) || (vbflags3 & VB3_CRT1_LCD)) {
+       if(SiS_CheckModeCRT1(pScrn, mode, vbflags, vbflags3, pSiS->HaveCustomModes) < 0x14) {
           if(!quiet) {
              xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		"Current mode not suitable for LCD-via-CRT1\n");
+		"Current mode not suitable for LCD-via-CRT1 or CRT1_LCD\n");
 	  }
           return FALSE;
        }
@@ -410,26 +432,49 @@ SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff, Bool quiet)
     (*pSiS->SyncAccel)(pScrn);
 
     pSiS->skipswitchcheck = TRUE;
-    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) {
+    if(!((*pScrn->SwitchMode)(pScrn->scrnIndex, pScrn->currentMode, 0))) {
        pSiS->skipswitchcheck = FALSE;
        return FALSE;
     }
     pSiS->skipswitchcheck = FALSE;
+
+    /* No need to go through pScrn->AdjustFrame; the coords
+     * didn't change
+     */
     SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+
     return TRUE;
 }
 
 static Bool
+SISRedetectCRT1Devices(ScrnInfoPtr pScrn)
+{
+    return FALSE;
+}
+
+static void
+SISResetCRT1Status(ScrnInfoPtr pScrn)
+{
+}
+
+static Bool
 SISRedetectCRT2Devices(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
 
-    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA)) {
+    /* CRT2 redetection: Sense TV, LCD, VGA2 and re-read the
+     * DDC data.
+     * Redetection has no effect (except that the devices are
+     * reported in detectedcrt2devices) until a switch of
+     * output devices is performed.
+     */
+
+    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
        return FALSE;
-    }
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) return FALSE;
+    if(pSiS->DualHeadMode)
+       return FALSE;
 #endif
 
     /* Sync the accelerators */
@@ -440,18 +485,23 @@ SISRedetectCRT2Devices(ScrnInfoPtr pScrn)
        /* Sync the accelerators */
        (*pSiS->SyncAccel)(pScrn);
        pSiS->skipswitchcheck = TRUE;
-       if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) {
+       if(!((*pScrn->SwitchMode)(pScrn->scrnIndex, pScrn->currentMode, 0))) {
           pSiS->skipswitchcheck = FALSE;
           return FALSE;
        }
        pSiS->skipswitchcheck = FALSE;
+
+       /* No need to go through pScrn->AdjustFrame; the coords
+	* didn't change
+	*/
        SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
     }
+
     return TRUE;
 }
 
 static Bool
-SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
+SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, ULong newvbflags3, Bool quiet)
 {
     SISPtr pSiS = SISPTR(pScrn);
     Bool hcm = pSiS->HaveCustomModes;
@@ -460,7 +510,7 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
     /* Do NOT use this to switch from CRT2_LCD to CRT1_LCDA */
 
     /* Switching CRT2 to LCD or VGA will switch CRT1 to VGA if
-     * previously LCD-via-CRT1
+     * previously LCDA
      */
 
     /* For usability reasons, the user should not simply "lose" one
@@ -471,20 +521,22 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
      * would lose one output device since LCD-via-CRT1 is only
      * supported together with TV, not any other CRT2 type.)
      * In Non-MergedFB mode, losing one output device is not
-     * considered that harmful.
+     * considered that harmful if both CRT1 and CRT2 are there.
      * Update: We allow this if currently a "clone" display mode
      * is active.
      */
 
-    /* Only on 300 and 315/330/340 series */
-    if(pSiS->VGAEngine != SIS_300_VGA &&
-       pSiS->VGAEngine != SIS_315_VGA) return FALSE;
+    /* Only on 300+ series */
+    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
+       return FALSE;
 
     /* Only if there is a video bridge */
-    if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE)) return FALSE;
+    if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE))
+       return FALSE;
 
 #ifdef SISDUALHEAD
-    if(pSiS->DualHeadMode) return FALSE;
+    if(pSiS->DualHeadMode)
+       return FALSE;
 #endif
 
 #define SiS_NewVBMask (CRT2_ENABLE|CRT1_LCDA|TV_PAL|TV_NTSC|TV_PALM|TV_PALN|TV_NTSCJ| \
@@ -494,6 +546,9 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
     newvbflags &= SiS_NewVBMask;
     newvbflags |= pSiS->VBFlags & ~SiS_NewVBMask;
 
+    newvbflags3 &= (VB3_CRT1_TYPE | VB3_CRT1_TVPLUG | VB3_CRT1_TVSTD | VB3_CRT1_YPBPRTYPE);
+    newvbflags3 |= pSiS->VBFlags3 & ~(VB3_CRT1_TYPE | VB3_CRT1_TVPLUG | VB3_CRT1_TVSTD | VB3_CRT1_YPBPRTYPE);
+
     if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
        newvbflags &= ~CRT1_LCDA;
     }
@@ -504,6 +559,13 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
        newvbflags &= ~TV_YPBPR;
     }
 
+    if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
+       newvbflags3 &= ~VB3_CRT1_LCD;
+    }
+    if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALTV)) {
+       newvbflags3 &= ~(VB3_CRT1_TV | VB3_CRT1_TVPLUG | VB3_CRT1_TVSTD | VB3_CRT1_YPBPRTYPE);
+    }
+
 #ifdef SISMERGED
     if(pSiS->MergedFB) {
        if((mode->Private) &&
@@ -515,15 +577,13 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
 	     }
 	     return FALSE;
           }
-          if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
-             if((newvbflags & (CRT2_LCD|CRT2_VGA)) && (newvbflags & CRT1_LCDA)) {
-                if(!quiet) {
-	           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-	              "CRT2 type can only be TV while in LCD-via-CRT1 mode\n");
-	        }
-	        return FALSE;
-	     }
-          }
+       }
+       if((newvbflags & (CRT2_LCD|CRT2_VGA)) && (newvbflags & CRT1_LCDA)) {
+          if(!quiet) {
+	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+	           "CRT2 type can only be TV while in LCD-via-CRT1 mode\n");
+	  }
+	  return FALSE;
        }
        hcm = pSiS->HaveCustomModes2;
        if(mode->Private) {
@@ -541,14 +601,12 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
     }
 
     /* CRT2_LCD and CRT2_VGA overrule LCDA (in non-MergedFB mode) */
-    if(!(pSiS->SiS_SD3_Flags & SiS_SD3_SUPPORTDUALDVI)) {
-       if(newvbflags & (CRT2_LCD|CRT2_VGA)) {
-          newvbflags &= ~CRT1_LCDA;
-       }
+    if(newvbflags & (CRT2_LCD|CRT2_VGA)) {
+       newvbflags &= ~CRT1_LCDA;
     }
 
     /* Check if the current mode is suitable for desired output device (if any) */
-    if(SiS_CheckModeCRT2(pScrn, mode, newvbflags, hcm) < 0x14) {
+    if(SiS_CheckModeCRT2(pScrn, mode, newvbflags, 0 /*newvbflags3 in future*/, hcm) < 0x14) {
        if(!quiet) {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 	     "Current mode not suitable for desired CRT2 output device\n");
@@ -568,6 +626,7 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
     (*pSiS->SyncAccel)(pScrn);
 
     pSiS->VBFlags = pSiS->VBFlags_backup = newvbflags;
+    pSiS->VBFlags3 = pSiS->VBFlags_backup3 = newvbflags3;
 
     pSiS->skipswitchcheck = TRUE;
     if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) {
@@ -575,7 +634,12 @@ SISSwitchCRT2Type(ScrnInfoPtr pScrn, ULong newvbflags, Bool quiet)
        return FALSE;
     }
     pSiS->skipswitchcheck = FALSE;
+
+    /* No need to go through pScrn->AdjustFrame; the coords
+     * didn't change
+     */
     SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
+
     return TRUE;
 }
 
@@ -589,10 +653,12 @@ SISSwitchOutputType(ScrnInfoPtr pScrn, ULong newvbflags, ULong newvbflags3,
 }
 
 static ULong
-SiSCondToVBFlags(UShort cond, ULong GivenVBFlags)
+SiSCondToVBFlags(UShort cond, ULong GivenVBFlags, ULong GivenVBFlags3, ULong *vbflags3)
 {
     ULong vbflags = GivenVBFlags;
 
+    *vbflags3 = GivenVBFlags3; /* TODO */
+
     /* No special treatment for NTSC-J here; conditions equal NTSC */
     if(cond) {
        vbflags &= ~(CRT2_ENABLE | CRT1_LCDA | TV_STANDARD | TV_INTERFACE);
@@ -626,11 +692,13 @@ SiSCondToVBFlags(UShort cond, ULong GivenVBFlags)
 	  vbflags |= CRT1_LCDA;
        }
     }
-    return(vbflags);
+
+    return vbflags;
 }
 
 static int
-SISCheckModeForCRT2Type(ScrnInfoPtr pScrn, DisplayModePtr mode, ULong vbflags, UShort cond, Bool quiet)
+SISCheckModeForCRT2Type(ScrnInfoPtr pScrn, DisplayModePtr mode,
+			ULong vbflags, ULong vbflags3, UShort cond, Bool quiet)
 {
     SISPtr pSiS = SISPTR(pScrn);
     DisplayModePtr mastermode;
@@ -664,7 +732,7 @@ SISCheckModeForCRT2Type(ScrnInfoPtr pScrn, DisplayModePtr mode, ULong vbflags, U
           }
 
           /* Check if the desired mode is suitable for current CRT2 output device */
-          if(SiS_CheckModeCRT2(pScrn, mode, vbflags, hcm) < 0x14) {
+          if(SiS_CheckModeCRT2(pScrn, mode, vbflags, vbflags3, hcm) < 0x14) {
              if((!cond) && (!quiet)) {
                 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		    "Desired mode not suitable for current CRT2 output device\n");
@@ -705,7 +773,7 @@ SISCheckModeForCRT2Type(ScrnInfoPtr pScrn, DisplayModePtr mode, ULong vbflags, U
 	  }
 
 	  /* Check if the desired mode is suitable for current CRT1 output device */
-	  if(SiS_CheckModeCRT1(pScrn, mode, vbflags, hcm) < 0x14) {
+	  if(SiS_CheckModeCRT1(pScrn, mode, vbflags, vbflags3, hcm) < 0x14) {
 	     if((!cond) && (!quiet)) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		      "Desired mode not suitable for current CRT1 output device\n");
@@ -722,37 +790,6 @@ SISCheckModeForCRT2Type(ScrnInfoPtr pScrn, DisplayModePtr mode, ULong vbflags, U
     return result;
 }
 
-#ifdef XV_SD_DEPRECATED
-static int
-SISCheckModeIndexForCRT2Type(ScrnInfoPtr pScrn, UShort cond, UShort index, Bool quiet)
-{
-    SISPtr pSiS = SISPTR(pScrn);
-    DisplayModePtr mode = pScrn->modes;
-    ULong vbflags;
-    int i;
-
-    /* Not only CRT2, but also LCDA */
-
-    /* returns 0 if mode ok,
-     *         0x01 if mode not ok for CRT2 device,
-     *         0x02 if mode too large for current root window
-     *         or combinations thereof
-     */
-
-    vbflags = SiSCondToVBFlags(cond, pSiS->VBFlags);
-
-    /* Find mode of given index */
-    if(index) {
-       for(i = 0; i < index; i++) {
-          if(!mode) return 0x03;
-          mode = mode->next;
-       }
-    }
-
-    return(SISCheckModeForCRT2Type(pScrn, mode, vbflags, cond, quiet));
-}
-#endif
-
 static DisplayModePtr
 sisFindModeFromTiming(ScrnInfoPtr pScrn, UShort hdisplay,
 			      UShort vdisplay, UShort htotal, UShort vtotal,
@@ -790,7 +827,7 @@ SISCheckModeTimingForCRT2Type(ScrnInfoPtr pScrn, UShort cond, UShort hdisplay,
 {
     SISPtr pSiS = SISPTR(pScrn);
     DisplayModePtr mode;
-    ULong vbflags;
+    ULong vbflags, vbflags3;
 
     /* Not only CRT2, but also LCDA */
 
@@ -800,7 +837,7 @@ SISCheckModeTimingForCRT2Type(ScrnInfoPtr pScrn, UShort cond, UShort hdisplay,
      *         or combinations thereof
      */
 
-    vbflags = SiSCondToVBFlags(cond, pSiS->VBFlags);
+    vbflags = SiSCondToVBFlags(cond, pSiS->VBFlags, pSiS->VBFlags3, &vbflags3);
 
     /* Find mode with given timing */
     mode = sisFindModeFromTiming(pScrn, hdisplay, vdisplay, htotal, vtotal,
@@ -808,7 +845,7 @@ SISCheckModeTimingForCRT2Type(ScrnInfoPtr pScrn, UShort cond, UShort hdisplay,
 				clock);
     if(!mode) return 0x03;
 
-    return(SISCheckModeForCRT2Type(pScrn, mode, vbflags, cond, quiet));
+    return(SISCheckModeForCRT2Type(pScrn, mode, vbflags, vbflags3, cond, quiet));
 }
 
 #ifdef SISMERGED
@@ -817,11 +854,13 @@ SISGetMergedModeDetails(ScrnInfoPtr pScrn,
 	   int hd, int vd, int ht, int vt, int hss, int hse, int vss, int vse, int clk,
 	   unsigned int *pos, unsigned int *crt1x, unsigned int *crt1y,
 	   unsigned int *crt1clk, unsigned int *crt2x, unsigned int *crt2y,
-	   unsigned int *crt2clk)
+	   unsigned int *crt2clk, Bool *dynpos)
 {
     SISPtr pSiS = SISPTR(pScrn);
     DisplayModePtr mode, tmode;
 
+    *dynpos = FALSE;
+
     if(!pSiS->MergedFB) {
        *pos = SDC_MMODE_POS_ERROR;
        return;
@@ -846,13 +885,94 @@ SISGetMergedModeDetails(ScrnInfoPtr pScrn,
     *crt1x = tmode->HDisplay;
     *crt1y = tmode->VDisplay;
     *crt1clk = (unsigned int)SiSCalcVRate(tmode);
+    if(tmode->Flags & V_INTERLACE) *crt1clk /= 2;
+    /* OK to use the mode flag here, targets info on CRT device */
 
     tmode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
     *crt2x = tmode->HDisplay;
     *crt2y = tmode->VDisplay;
     *crt2clk = (unsigned int)SiSCalcVRate(tmode);
+
 }
 #endif
+/*Device Switch by Utility.(Ivans Lee)*/
+Bool SISUtilityDeviceSwitch(ScrnInfoPtr pScrn)
+{	
+	SISPtr  pSiS = SISPTR(pScrn);	
+
+	SISCRT1PreInit(pScrn); /*redetecting CRT1, pSiS->CRT1detected will update.*/							         	  
+	switch(pSiS->Hkey_Device_Switch_State) /*checking current stste for next state.*/
+	{ 
+		case LCD_only:			 															     {         	
+			if( pSiS->CRT1Detected )
+		        {
+				 SISSwitchCRT1Status(pScrn,1,1); /*open VGA to mirror mode.*/												      pSiS->Hkey_Device_Switch_State = LCD_VGA_mirror;
+		            	 /*xf86DrvMsg(0,X_INFO,"[Device Switch]LCD->Mirror.(current Mirror mode.)\n");*/	 		
+				 /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+			} 
+			else
+			{	
+				SISSwitchCRT2Type(pScrn,0x20080002,0x0,1); /*redetect LCD.*/
+				pSiS->Hkey_Device_Switch_State = LCD_only;
+			       	/*xf86DrvMsg(0,X_INFO,"[Device Switch]LCD->LCD.(current LCD ONLY.)\n");*/
+			        /*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+			}																		      }	      
+		 break;	
+																					      case LCD_VGA_mirror:
+		 {      
+			if( pSiS->CRT1Detected )
+		        { 
+																							     SISSwitchCRT2Type(pScrn,0x40080000,0x0,1); /*close LCD.*/
+				pSiS->Hkey_Device_Switch_State = VGA_only;
+				/*xf86DrvMsg(0,X_INFO,"[Device Switch]Mirror->VGA.(current VGA ONLY.)\n");*/
+				/*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+		         }
+			 else
+		         {
+				SISSwitchCRT1Status(pScrn,0,1); /*close VGA.*/
+				pSiS->Hkey_Device_Switch_State = LCD_only;
+				/*xf86DrvMsg(0,X_INFO,"[Device Switch]Mirror->LCD.(current LCD ONLY.)\n");*/
+				/*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+		         }
+		  }	      
+		  break;
+																					      case VGA_only:
+		 {              
+				SISSwitchCRT2Type(pScrn,0x20000002,0x0,1); /*open LCD*/
+				SISSwitchCRT1Status(pScrn,0,1); /*close VGA*/
+				pSiS->Hkey_Device_Switch_State = LCD_only;
+			        /*xf86DrvMsg(0,X_INFO,"[Device Switch]VGA->LCD.(current LCD ONLY.)\n");*/
+				/*xf86DrvMsg(0,X_INFO,"[Device Switch]:pSiS->CRT1Detected=%d,pSiS->CRT1off=%d\n",pSiS->CRT1Detected,pSiS->CRT1off);*/
+		 }
+		 break;
+																					      default:
+		 { 
+				xf86DrvMsg(0,X_INFO,"Unknow current hotkey DS state, Hkey do nothing.\n");
+				return 0;
+		 } 
+	}
+	return 1;
+}
+
+unsigned int SISDevicesCurrentState(ScrnInfoPtr pScrn)
+{
+	SISPtr  pSiS = SISPTR(pScrn);
+        unsigned int current_state = 0xffffffff;
+
+        current_state = ((pSiS->VBFlags & DISPTYPE_CRT1) | (pSiS->VBFlags & CRT2_LCD));
+
+	return current_state;    
+}
+
+unsigned int SISVGADetected(ScrnInfoPtr pScrn)
+{
+	/*SISPtr  pSiS = SISPTR(pScrn);*/
+        unsigned int detected = 0;
+
+	detected = SiS_DetectVGA1(pScrn);
+
+	return detected;
+}
 
 /***********************************
  *     MessageHandler interface    *
@@ -897,7 +1017,8 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
    int i;
    ULong j;
 
-   if(sdcbuf->sdc_id != SDC_ID) return BadMatch;
+   if(sdcbuf->sdc_id != SDC_ID)
+      return BadMatch;
 
    if(pSiS->adaptor) {
       pPriv = GET_PORT_PRIVATE(pScrn);
@@ -908,7 +1029,8 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
       j += sdcbuf->sdc_parm[i];
    }
 
-   if(j != sdcbuf->sdc_chksum) return BadMatch;
+   if(j != sdcbuf->sdc_chksum)
+      return BadMatch;
 
    sdcbuf->sdc_result_header = SDC_RESULT_OK;
 
@@ -1005,7 +1127,8 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
       if(!pSiS->DualHeadMode) {
 #endif
 	 if(pSiS->xv_sisdirectunlocked) {
-	    SISSwitchCRT2Type(pScrn, (ULong)sdcbuf->sdc_parm[0], pSiS->SCLogQuiet);
+	    SISSwitchCRT2Type(pScrn, (ULong)sdcbuf->sdc_parm[0],
+	    		(ULong)sdcbuf->sdc_parm[1], pSiS->SCLogQuiet);
 	    if(pPriv) SISUpdateVideoParms(pSiS, pPriv);
 	 } else sdcbuf->sdc_result_header = SDC_RESULT_NOPERM;
 #ifdef SISDUALHEAD
@@ -1031,6 +1154,18 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
       sdcbuf->sdc_result[0] = pSiS->detectedCRT2Devices;
       break;
 
+   case SDC_CMD_REDETECTCRT1DEVICES:
+#ifdef SISDUALHEAD
+      if(!pSiS->DualHeadMode) {
+#endif
+	 if(pSiS->xv_sisdirectunlocked) {
+	    SISRedetectCRT1Devices(pScrn);
+	 } else sdcbuf->sdc_result_header = SDC_RESULT_NOPERM;
+#ifdef SISDUALHEAD
+      } else sdcbuf->sdc_result_header = SDC_RESULT_NOPERM;
+#endif
+      break;
+
    case SDC_CMD_REDETECTCRT2DEVICES:
 #ifdef SISDUALHEAD
       if(!pSiS->DualHeadMode) {
@@ -1044,6 +1179,9 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
       break;
 
    case SDC_CMD_GETCRT1STATUS:
+      /* This returns only "off" or "on". For LCD(A),
+       * client has to look at the vbflags.
+       */
       sdcbuf->sdc_result[0] = pSiS->CRT1isoff ? 0 : 1;
       break;
 
@@ -1060,6 +1198,18 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 #endif
       break;
 
+   case SDC_CMD_RESETCRT1STATUS:
+#ifdef SISDUALHEAD
+      if(!pSiS->DualHeadMode) {
+#endif
+	 if(pSiS->xv_sisdirectunlocked) {
+	    SISResetCRT1Status(pScrn);
+	 } else sdcbuf->sdc_result_header = SDC_RESULT_NOPERM;
+#ifdef SISDUALHEAD
+      } else sdcbuf->sdc_result_header = SDC_RESULT_NOPERM;
+#endif
+      break;
+
    case SDC_CMD_GETSDFLAGS:
       sdcbuf->sdc_result[0] = pSiS->SiS_SD_Flags;
       break;
@@ -1522,7 +1672,7 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 	 pSiS->HideHWCursor = sdcbuf->sdc_parm[0] ? TRUE : FALSE;
 	 if(pSiS->CursorInfoPtr) {
 	    if(VisibleBackup) {
-	       if(sdcbuf->sdc_parm[0]) {
+	       if(pSiS->HideHWCursor) {
 	 	  (pSiS->CursorInfoPtr->HideCursor)(pScrn);
 	       } else {
 		  (pSiS->CursorInfoPtr->ShowCursor)(pScrn);
@@ -1572,7 +1722,8 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 #ifdef SISMERGED
       if(pSiS->MergedFB) {
          int clk, hd, hss, hse, ht, vd, vss, vse, vt;
-	 unsigned int pos, crt1x, crt1y, crt1clk, crt2x, crt2y, crt2clk;
+	 unsigned int pos=0, crt1x=0, crt1y=0, crt1clk=0, crt2x=0, crt2y=0, crt2clk=0;
+	 Bool dynpos = FALSE;
 
 	 clk   = sdcbuf->sdc_parm[0];
 	 hd    = sdcbuf->sdc_parm[1];
@@ -1586,7 +1737,7 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 
 	 SISGetMergedModeDetails(pScrn,
 		hd, vd, ht, vt, hss, hse, vss, vse, clk,
-		&pos, &crt1x, &crt1y, &crt1clk, &crt2x, &crt2y, &crt2clk);
+		&pos, &crt1x, &crt1y, &crt1clk, &crt2x, &crt2y, &crt2clk, &dynpos);
 
 	 sdcbuf->sdc_result[0] = pos;
 	 sdcbuf->sdc_result[1] = crt1x;
@@ -1604,6 +1755,8 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 	 default:         sdcbuf->sdc_result[7] = SDC_MMODE_POS_CLONE;
 	 }
 
+	 sdcbuf->sdc_result[8] = dynpos ? 1 : 0;
+
       } else
 #endif
          sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
@@ -1680,9 +1833,14 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
    case SDC_CMD_SETXVCONTRAST:
       if(pPriv) {
          int val = sdcbuf->sdc_parm[0] - 32768;
-         if(val >= 0 && val <= 7) pPriv->contrast = val;
-	 else sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
-      } else sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
+         if(val >= 0 && val <= 255) 
+	   { pPriv->contrast = val;
+	    /* xf86DrvMsg(0,X_INFO,"[ivans_xv_con_set]: val=%d, contrast=%d\n",val,pPriv->contrast);*/
+	   }
+	 else {sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
+	      /* xf86DrvMsg(0,X_INFO,"[ivans_xv_con_set]: contrast set not work");*/ }
+      } else {sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
+              /* xf86DrvMsg(0,X_INFO,"[ivans_xv_con_set]: saturation set not work");*/}
       break;
 
    case SDC_CMD_GETXVCONTRAST:
@@ -1709,7 +1867,7 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
       if((pPriv) && (pSiS->SiS_SD2_Flags & SiS_SD2_SUPPORTXVHUESAT)) {
          int val = sdcbuf->sdc_parm[0] - 32768;
          if(val >= -7 && val <= 7) pPriv->saturation = val;
-	 else sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
+	 else  sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
       } else sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
       break;
 
@@ -1855,6 +2013,8 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 
    case SDC_CMD_SETXVDEINT:
    case SDC_CMD_GETXVDEINT:
+   case SDC_CMD_GETCRT2SATGAIN:
+   case SDC_CMD_SETCRT2SATGAIN:
       sdcbuf->sdc_result_header = SDC_RESULT_INVAL;
       break;
 
@@ -1879,7 +2039,23 @@ SiSHandleSiSDirectCommand(xSiSCtrlCommandReply *sdcbuf)
 	 SiS_SetSISCRT1SaturationGain(pScrn, (int)sdcbuf->sdc_parm[0]);
       } else sdcbuf->sdc_result_header = SDC_RESULT_NOPERM;
       break;
-
+   /*Device Switch from Utility(Ivans Lee)*/ 
+   case SDC_CMD_DEVICESWITCH:
+      /*xf86DrvMsg(0,X_INFO,"[SiS_Utility()]:Got a DEVICE_SWITCH command from Utility.\n");*/
+      if(!SISUtilityDeviceSwitch(pScrn))
+      {
+	      xf86DrvMsg(0,X_INFO,"[ERROR]:Unknow Device Switch State.\n");
+      }	      
+   break;
+   /*Query All Device Redetecting Result(Ivans Lee)*/
+   case SDC_CMD_GETALLREDETECTINFO:
+      sdcbuf->sdc_result[0] = SISVGADetected(pScrn);
+   break;
+   /*Query Device Current State in driver(Ivans Lee)*/
+   case SDC_CMD_GETCURRENTSTATE:
+      sdcbuf->sdc_result[0] = SISDevicesCurrentState(pScrn);
+   break;
+   /*-----------------------------------------------*/
    default:
       sdcbuf->sdc_result_header = SDC_RESULT_UNDEFCMD;
    }
@@ -2125,296 +2301,18 @@ SiSCtrlExtUnregister(SISPtr pSiS, int index)
 
 /***********************************
  *     Xv attribute interface      *
+ *     This has been removed.      *
+ * The stub below is only for debug*
  ***********************************/
 
-#ifdef XV_SD_DEPRECATED
-
+#ifdef TWDEBUG
 int
 SISSetPortUtilAttribute(ScrnInfoPtr pScrn, Atom attribute,
 			INT32 value, SISPortPrivPtr pPriv)
 {
   SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-  SISEntPtr pSiSEnt = pSiS->entityPrivate;;
-#endif
 
-  if(attribute == pSiS->xv_USD) {
-     if(pSiS->enablesisctrl) {
-	 if(value == SIS_DIRECTKEY) {
-	   pSiS->xv_sisdirectunlocked++;
-	} else if(pSiS->xv_sisdirectunlocked) {
-	   pSiS->xv_sisdirectunlocked--;
-	}
-     } else {
-	pSiS->xv_sisdirectunlocked = 0;
-     }
-  } else if(attribute == pSiS->xv_SVF) {
-#ifdef SISDUALHEAD
-     if(!pPriv->dualHeadMode)
-#endif
-	if(pSiS->xv_sisdirectunlocked) {
-	   SISSwitchCRT2Type(pScrn, (ULong)value, FALSE);
-	   SISUpdateVideoParms(pSiS, pPriv);
-	}
-  } else if(attribute == pSiS->xv_CT1) {
-#ifdef SISDUALHEAD
-     if(!pPriv->dualHeadMode)
-#endif
-	if(pSiS->xv_sisdirectunlocked) {
-	   SISSwitchCRT1Status(pScrn, (ULong)value, FALSE);
-	   SISUpdateVideoParms(pSiS, pPriv);
-        }
-  } else if(attribute == pSiS->xv_RDT) {
-#ifdef SISDUALHEAD
-     if(!pPriv->dualHeadMode)
-#endif
-	if(pSiS->xv_sisdirectunlocked) {
-	   SISRedetectCRT2Devices(pScrn);
-	}
-  } else if(attribute == pSiS->xv_TAF) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVantiflicker(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_TSA) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVsaturation(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_TEE) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVedgeenhance(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_CFI) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVcfilter(pScrn, value ? 1 : 0);
-     }
-  } else if(attribute == pSiS->xv_YFI) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVyfilter(pScrn, value);
-     }
-  } else if(attribute == pSiS->xv_COC) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVcolcalib(pScrn, (int)value, TRUE);
-     }
-  } else if(attribute == pSiS->xv_COF) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetSISTVcolcalib(pScrn, (int)value, FALSE);
-     }
-  } else if(attribute == pSiS->xv_TCO) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetCHTVcontrast(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_TTE) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetCHTVtextenhance(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_TCF) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetCHTVchromaflickerfilter(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_TLF) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetCHTVlumaflickerfilter(pScrn, (int)value);
-     }
-  } else if(attribute == pSiS->xv_TCC) {
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetCHTVcvbscolor(pScrn, value ? 1 : 0);
-     }
-  } else if(attribute == pSiS->xv_OVR) {
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->UseCHOverScan = -1;
-	pSiS->OptTVSOver = FALSE;
-	if(value == 3) {
-	   if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTSOVER) {
-	      pSiS->OptTVSOver = TRUE;
-	   }
-	   pSiS->UseCHOverScan = 1;
-	} else if(value == 2) pSiS->UseCHOverScan = 1;
-	else if(value == 1)   pSiS->UseCHOverScan = 0;
-     }
-  } else if(attribute == pSiS->xv_CMD) {
-     if(pSiS->xv_sisdirectunlocked) {
-	int result = 0;
-	pSiS->xv_sd_result = (value & 0xffffff00);
-	result = SISCheckModeIndexForCRT2Type(pScrn, (UShort)(value & 0xff),
-					      (UShort)((value >> 8) & 0xff),
-					      FALSE);
-	pSiS->xv_sd_result |= (result & 0xff);
-     }
-  } else if(attribute == pSiS->xv_SGA) {
-     if(pSiS->xv_sisdirectunlocked) {
-	Bool backup = pSiS->XvGamma;
-	Bool backup2 = pSiS->CRT2SepGamma;
-	pSiS->CRT1gamma = (value & 0x01) ? TRUE : FALSE;
-	pSiS->CRT2gamma = (value & 0x02) ? TRUE : FALSE;
-#ifdef SISDUALHEAD
-	if(pPriv->dualHeadMode) {
-	   pSiSEnt->CRT1gamma = pSiS->CRT1gamma;
-	   pSiSEnt->CRT2gamma = pSiS->CRT2gamma;
-	}
-#endif
-	if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTSGRCRT2) {
-	   pSiS->CRT2SepGamma = (value & 0x08) ? TRUE : FALSE;
-	   if(pSiS->CRT2SepGamma != backup2) {
-	      if(pSiS->CRT2SepGamma) {
-		 SiS_UpdateGammaCRT2(pScrn);
-	      }
-#ifdef SISGAMMARAMP
-	      else {
-		 SISCalculateGammaRamp(pScrn->pScreen, pScrn);
-	      }
-#endif
-	      /* ATTN: When disabling CRT2 sep gamma,
-	       * as long as SISGAMMARAMP is not defined,
-	       * application needs to reset palette using
-	       * vidmodextension! (See SiS_SD_CANSETGAMMA)
-	       *
-	       * Note: Difference between setting gamma values
-	       * for CRT1 and CRT2: For CRT1, driver only
-	       * stores the values, but does nothing with them.
-	       * For CRT2, the driver will IMMEDIATELY recalc
-	       * the palette. App needs to calc gamma ramp
-	       * itself for CRT1, and set it using the
-	       * VidModExtention.
-	       */
-	   }
-	} else pSiS->CRT2SepGamma = FALSE;
-	pSiS->XvGamma = (value & 0x04) ? TRUE : FALSE;
-	if(pSiS->VGAEngine == SIS_315_VGA) {
-	   if(backup != pSiS->XvGamma) {
-	      SiSUpdateXvGamma(pSiS, pPriv);
-	   }
-	}
-     }
-  } else if(attribute == pSiS->xv_TXS) {
-     if((value < -16) || (value > 16)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetTVxscale(pScrn, value);
-     }
-  } else if(attribute == pSiS->xv_TYS) {
-     if((value < -4) || (value > 3)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	SiS_SetTVyscale(pScrn, value);
-     }
-  } else if(attribute == pSiS->xv_BRR) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaBriR = value;
-     }
-  } else if(attribute == pSiS->xv_BRG) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaBriG = value;
-     }
-  } else if(attribute == pSiS->xv_BRB) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaBriB = value;
-     }
-  } else if(attribute == pSiS->xv_PBR) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_PBG) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_PBB) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_BRR2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-#ifdef SISDUALHEAD
-	if(pPriv->dualHeadMode) pSiSEnt->GammaBriR = value;
-#endif
-     }
-  } else if(attribute == pSiS->xv_BRG2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-#ifdef SISDUALHEAD
-	if(pPriv->dualHeadMode) pSiSEnt->GammaBriG = value;
-#endif
-     }
-  } else if(attribute == pSiS->xv_BRB2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-#ifdef SISDUALHEAD
-	if(pPriv->dualHeadMode) pSiSEnt->GammaBriB = value;
-#endif
-     }
-  } else if(attribute == pSiS->xv_PBR2) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_PBG2) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_PBB2) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_GARC2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaR2 = (float)value / (float)1000;
-	SiS_UpdateGammaCRT2(pScrn);
-     }
-  } else if(attribute == pSiS->xv_GAGC2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaG2 = (float)value / (float)1000;
-	SiS_UpdateGammaCRT2(pScrn);
-     }
-  } else if(attribute == pSiS->xv_GABC2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaB2 = (float)value / (float)1000;
-	SiS_UpdateGammaCRT2(pScrn);
-     }
-  } else if(attribute == pSiS->xv_BRRC2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaBriR2 = value;
-	SiS_UpdateGammaCRT2(pScrn);
-     }
-  } else if(attribute == pSiS->xv_BRGC2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaBriG2 = value;
-	SiS_UpdateGammaCRT2(pScrn);
-     }
-  } else if(attribute == pSiS->xv_BRBC2) {
-     if((value < 100) || (value > 10000)) return BadValue;
-     if(pSiS->xv_sisdirectunlocked) {
-	pSiS->GammaBriB2 = value;
-	SiS_UpdateGammaCRT2(pScrn);
-     }
-  } else if(attribute == pSiS->xv_PBRC2) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_PBGC2) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_PBBC2) {
-     /* Nop */
-  } else if(attribute == pSiS->xv_SHC) {
-     if(pSiS->xv_sisdirectunlocked) {
-	Bool VisibleBackup = pSiS->HWCursorIsVisible;
-	pSiS->HideHWCursor = value ? TRUE : FALSE;
-	if(pSiS->CursorInfoPtr) {
-	   if(VisibleBackup) {
-	      if(value) {
-		 (pSiS->CursorInfoPtr->HideCursor)(pScrn);
-	      } else {
-		 (pSiS->CursorInfoPtr->ShowCursor)(pScrn);
-	      }
-	   }
-	   pSiS->HWCursorIsVisible = VisibleBackup;
-	}
-     }
-  } else if(attribute == pSiS->xv_PMD) {
-     if(pSiS->xv_sisdirectunlocked) {
-        if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTSCALE) {
-	   if(value & 0x01)      pSiS->SiS_Pr->UsePanelScaler = -1;
-	   else if(value & 0x02) pSiS->SiS_Pr->UsePanelScaler = 1;
-	   else			 pSiS->SiS_Pr->UsePanelScaler = 0;
-	   if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTCENTER) {
-	      if(value & 0x04)      pSiS->SiS_Pr->CenterScreen = -1;
-	      else if(value & 0x08) pSiS->SiS_Pr->CenterScreen = 1;
-	      else		    pSiS->SiS_Pr->CenterScreen = 0;
-	   }
-        }
-     }
-#ifdef TWDEBUG
-  } else if(attribute == pSiS->xv_STR) {
+  if(attribute == pSiS->xv_STR) {
      ULong port;
      CARD8 reg;
      switch((value & 0xff000000) >> 24) {
@@ -2430,172 +2328,11 @@ SISSetPortUtilAttribute(ScrnInfoPtr pScrn, Atom attribute,
      outSISIDXREG(port,((value & 0x00ff0000) >> 16), ((value & 0x0000ff00) >> 8));
      inSISIDXREG(port, ((value & 0x00ff0000) >> 16), reg);
      xf86DrvMsg(0, 0, "SetREG %x -> %x -> %x\n", ((value & 0x00ff0000) >> 16), ((value & 0x0000ff00) >> 8), reg);
-#endif
-  } else {
-     return BadMatch;
-  }
-
-  return Success;
-}
-
-int
-SISGetPortUtilAttribute(ScrnInfoPtr pScrn,  Atom attribute,
-			INT32 *value, SISPortPrivPtr pPriv)
-{
-  SISPtr pSiS = SISPTR(pScrn);
-#ifdef SISDUALHEAD
-  SISEntPtr pSiSEnt = pSiS->entityPrivate;;
-#endif
-
-  if(attribute == pSiS->xv_QVF) {
-     *value = pSiS->VBFlags;
-  } else if(attribute == pSiS->xv_GDV) {
-     *value = SISDRIVERIVERSION;
-  } else if(attribute == pSiS->xv_GHI) {
-     *value = (pSiS->ChipFlags & 0xffff) | (pSiS->ChipType << 16) | (pSiS->ChipRev << 24);
-  } else if(attribute == pSiS->xv_GBI) {
-     *value = (pSiS->PciBus << 16) | (pSiS->PciDevice << 8) | pSiS->PciFunc;
-  } else if(attribute == pSiS->xv_QVV) {
-     *value = SIS_VBFlagsVersion;
-  } else if(attribute == pSiS->xv_QDD) {
-     *value = pSiS->detectedCRT2Devices;
-  } else if(attribute == pSiS->xv_CT1) {
-     *value = pSiS->CRT1isoff ? 0 : 1;
-  } else if(attribute == pSiS->xv_GSF) {
-     *value = pSiS->SiS_SD_Flags;
-  } else if(attribute == pSiS->xv_GSF2) {
-     *value = pSiS->SiS_SD2_Flags;
-  } else if(attribute == pSiS->xv_USD) {
-     *value = pSiS->xv_sisdirectunlocked;
-  } else if(attribute == pSiS->xv_TAF) {
-     *value = SiS_GetSISTVantiflicker(pScrn);
-  } else if(attribute == pSiS->xv_TSA) {
-     *value = SiS_GetSISTVsaturation(pScrn);
-  } else if(attribute == pSiS->xv_TEE) {
-     *value = SiS_GetSISTVedgeenhance(pScrn);
-  } else if(attribute == pSiS->xv_CFI) {
-     *value = SiS_GetSISTVcfilter(pScrn);
-  } else if(attribute == pSiS->xv_YFI) {
-     *value = SiS_GetSISTVyfilter(pScrn);
-  } else if(attribute == pSiS->xv_COC) {
-     *value = SiS_GetSISTVcolcalib(pScrn, TRUE);
-  } else if(attribute == pSiS->xv_COF) {
-     *value = SiS_GetSISTVcolcalib(pScrn, FALSE);
-  } else if(attribute == pSiS->xv_TCO) {
-     *value = SiS_GetCHTVcontrast(pScrn);
-  } else if(attribute == pSiS->xv_TTE) {
-     *value = SiS_GetCHTVtextenhance(pScrn);
-  } else if(attribute == pSiS->xv_TCF) {
-     *value = SiS_GetCHTVchromaflickerfilter(pScrn);
-  } else if(attribute == pSiS->xv_TLF) {
-     *value = SiS_GetCHTVlumaflickerfilter(pScrn);
-  } else if(attribute == pSiS->xv_TCC) {
-     *value = SiS_GetCHTVcvbscolor(pScrn);
-  } else if(attribute == pSiS->xv_CMDR) {
-     *value = pSiS->xv_sd_result;
-  } else if(attribute == pSiS->xv_OVR) {
-     /* Changing of CRT2 settings not supported in DHM! */
-     *value = 0;
-     if(pSiS->OptTVSOver == 1)         *value = 3;
-     else if(pSiS->UseCHOverScan == 1) *value = 2;
-     else if(pSiS->UseCHOverScan == 0) *value = 1;
-  } else if(attribute == pSiS->xv_SGA) {
-     *value = 0;
-#ifdef SISDUALHEAD
-     if(pPriv->dualHeadMode) {
-        if(pSiSEnt->CRT1gamma) *value |= 0x01;
-	if(pSiSEnt->CRT2gamma) *value |= 0x02;
-     } else {
-#endif
-	if(pSiS->CRT1gamma)    *value |= 0x01;
-	if(pSiS->CRT2gamma)    *value |= 0x02;
-	if(pSiS->CRT2SepGamma) *value |= 0x08;
-#ifdef SISDUALHEAD
-     }
-#endif
-     if(pSiS->XvGamma) *value |= 0x04;
-  } else if(attribute == pSiS->xv_TXS) {
-     *value = SiS_GetTVxscale(pScrn);
-  } else if(attribute == pSiS->xv_TYS) {
-     *value = SiS_GetTVyscale(pScrn);
-  } else if(attribute == pSiS->xv_GSS) {
-     *value = (pScrn->virtualX << 16) | pScrn->virtualY;
-  } else if(attribute == pSiS->xv_BRR) {
-     *value = pSiS->GammaBriR;
-  } else if(attribute == pSiS->xv_BRG) {
-     *value = pSiS->GammaBriG;
-  } else if(attribute == pSiS->xv_BRB) {
-     *value = pSiS->GammaBriB;
-  } else if(attribute == pSiS->xv_PBR) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_PBG) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_PBB) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_BRR2) {
-#ifdef SISDUALHEAD
-     if(pPriv->dualHeadMode) *value = pSiSEnt->GammaBriR;
-     else
-#endif
-          *value = pSiS->GammaBriR;
-  } else if(attribute == pSiS->xv_BRG2) {
-#ifdef SISDUALHEAD
-     if(pPriv->dualHeadMode) *value = pSiSEnt->GammaBriG;
-     else
-#endif
-          *value = pSiS->GammaBriG;
-  } else if(attribute == pSiS->xv_BRB2) {
-#ifdef SISDUALHEAD
-     if(pPriv->dualHeadMode) *value = pSiSEnt->GammaBriB;
-     else
-#endif
-          *value = pSiS->GammaBriB;
-  } else if(attribute == pSiS->xv_PBR2) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_PBG2) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_PBB2) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_GARC2) {
-     *value = (int)(pSiS->GammaR2 * 1000);
-  } else if(attribute == pSiS->xv_GAGC2) {
-     *value = (int)(pSiS->GammaG2 * 1000);
-  } else if(attribute == pSiS->xv_GABC2) {
-     *value = (int)(pSiS->GammaB2 * 1000);
-  } else if(attribute == pSiS->xv_BRRC2) {
-     *value = pSiS->GammaBriR2;
-  } else if(attribute == pSiS->xv_BRGC2) {
-     *value = pSiS->GammaBriG2;
-  } else if(attribute == pSiS->xv_BRBC2) {
-     *value = pSiS->GammaBriB2;
-  } else if(attribute == pSiS->xv_PBRC2) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_PBGC2) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_PBBC2) {
-     *value = 1000;
-  } else if(attribute == pSiS->xv_SHC) {
-     *value = pSiS->HideHWCursor ? 1 : 0;
-  } else if(attribute == pSiS->xv_PMD) {
-     *value = 0;
-     if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTSCALE) {
-        switch(pSiS->SiS_Pr->UsePanelScaler) {
-           case -1: *value |= 0x01; break;
-           case 1:  *value |= 0x02; break;
-        }
-	if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTCENTER) {
-           switch(pSiS->SiS_Pr->CenterScreen) {
-              case -1: *value |= 0x04; break;
-              case 1:  *value |= 0x08; break;
-           }
-	}
-     }
   } else {
      return BadMatch;
   }
 
   return Success;
 }
-
-#endif /* XV_SD_DEPRECATED */
+#endif /* TWDEBUG */
 
diff --git a/src/sis_vb.c b/src/sis_vb.c
index aa345a4..9474fea 100644
--- a/src/sis_vb.c
+++ b/src/sis_vb.c
@@ -1,7 +1,7 @@
 /* $XFree86$ */
 /* $XdotOrg: driver/xf86-video-sis/src/sis_vb.c,v 1.28 2005/09/05 14:26:16 twini Exp $ */
 /*
- * Video bridge detection and configuration for 300, 315 and 330 series
+ * Video bridge detection and configuration for 300 series and later
  *
  * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria
  *
@@ -45,91 +45,7 @@
 #include "sis_regs.h"
 #include "sis_dac.h"
 
-void SISCRT1PreInit(ScrnInfoPtr pScrn);
-void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet);
-void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet);
-void SISCRT2PreInit(ScrnInfoPtr pScrn, Bool quiet);
-Bool SISRedetectCRT2Type(ScrnInfoPtr pScrn);
-void SISSense30x(ScrnInfoPtr pScrn, Bool quiet);
-void SISSenseChrontel(ScrnInfoPtr pScrn, Bool quiet);
-void SiSSetupPseudoPanel(ScrnInfoPtr pScrn);
-
-extern Bool   SISDetermineLCDACap(ScrnInfoPtr pScrn);
-extern void   SISSaveDetectedDevices(ScrnInfoPtr pScrn);
-extern void   SISWaitRetraceCRT1(ScrnInfoPtr pScrn);
-extern UChar  SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, UShort offset, UChar value);
-
-/* From init.c, init301.c ---- (use their data types) */
-extern BOOLEAN		SiS_GetPanelID(struct SiS_Private *SiS_Pr);
-extern unsigned short	SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS);
-extern unsigned short	SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS);
-
-typedef struct _SiS_LCD_StStruct
-{
-	ULong VBLCD_lcdflag;
-	UShort LCDwidth;
-	UShort LCDheight;
-} SiS_LCD_StStruct;
-
-static const SiS_LCD_StStruct SiS300_LCD_Type[]=
-{
-	{ VB_LCD_1024x768, 1024,  768 },  /* 0 - invalid */
-	{ VB_LCD_800x600,   800,  600 },  /* 1 */
-	{ VB_LCD_1024x768, 1024,  768 },  /* 2 */
-	{ VB_LCD_1280x1024,1280, 1024 },  /* 3 */
-	{ VB_LCD_1280x960, 1280,  960 },  /* 4 */
-	{ VB_LCD_640x480,   640,  480 },  /* 5 */
-	{ VB_LCD_1024x600, 1024,  600 },  /* 6 */
-	{ VB_LCD_1152x768, 1152,  768 },  /* 7 */
-	{ VB_LCD_1024x768, 1024,  768 },  /* 8 */
-	{ VB_LCD_1024x768, 1024,  768 },  /* 9 */
-	{ VB_LCD_1280x768, 1280,  768 },  /* a */
-	{ VB_LCD_1024x768, 1024,  768 },  /* b */
-	{ VB_LCD_1024x768, 1024,  768 },  /* c */
-	{ VB_LCD_1024x768, 1024,  768 },  /* d */
-	{ VB_LCD_320x480,   320,  480 },  /* e */
-	{ VB_LCD_CUSTOM,      0,    0 }   /* f */
-};
-
-static const SiS_LCD_StStruct SiS315_LCD_Type[]=
-{
-        { VB_LCD_1024x768, 1024,  768 },  /* 0 - invalid */
-	{ VB_LCD_800x600,   800,  600 },  /* 1 */
-	{ VB_LCD_1024x768, 1024,  768 },  /* 2 */
-	{ VB_LCD_1280x1024,1280, 1024 },  /* 3 */
-	{ VB_LCD_640x480,   640,  480 },  /* 4 */
-	{ VB_LCD_1024x600, 1024,  600 },  /* 5 */
-	{ VB_LCD_1152x864, 1152,  864 },  /* 6 */
-	{ VB_LCD_1280x960, 1280,  960 },  /* 7 */
-	{ VB_LCD_1152x768, 1152,  768 },  /* 8 */
-	{ VB_LCD_1400x1050,1400, 1050 },  /* 9 */
-	{ VB_LCD_1280x768, 1280,  768 },  /* a */
-	{ VB_LCD_1600x1200,1600, 1200 },  /* b */
-	{ VB_LCD_640x480_2, 640,  480 },  /* c FSTN */
-	{ VB_LCD_640x480_3, 640,  480 },  /* d FSTN */
-	{ VB_LCD_320x480,   320,  480 },  /* e */
-	{ VB_LCD_CUSTOM,      0,    0 }   /* f */
-};
-
-static const SiS_LCD_StStruct SiS661_LCD_Type[]=
-{
-        { VB_LCD_1024x768, 1024,  768 },  /* 0 - invalid */
-	{ VB_LCD_800x600,   800,  600 },  /* 1 */
-	{ VB_LCD_1024x768, 1024,  768 },  /* 2 */
-	{ VB_LCD_1280x1024,1280, 1024 },  /* 3 */
-	{ VB_LCD_640x480,   640,  480 },  /* 4 */
-	{ VB_LCD_1024x600, 1024,  600 },  /* 5 - temp */
-	{ VB_LCD_1152x864, 1152,  864 },  /* 6 - temp */
-	{ VB_LCD_1280x960, 1280,  960 },  /* 7 */
-	{ VB_LCD_1280x854, 1280,  854 },  /* 8 */
-	{ VB_LCD_1400x1050,1400, 1050 },  /* 9 */
-	{ VB_LCD_1280x768, 1280,  768 },  /* a */
-	{ VB_LCD_1600x1200,1600, 1200 },  /* b */
-	{ VB_LCD_1280x800, 1280,  800 },  /* c */
-	{ VB_LCD_1680x1050,1680, 1050 },  /* d */
-	{ VB_LCD_1280x720, 1280,  720 },  /* e */
-	{ VB_LCD_CUSTOM,      0,    0 }   /* f */
-};
+#include "sis_vb.h"
 
 static Bool
 TestDDC1(ScrnInfoPtr pScrn)
@@ -146,39 +62,47 @@ TestDDC1(ScrnInfoPtr pScrn)
 }
 
 static int
-SiS_SISDetectCRT1(ScrnInfoPtr pScrn)
+SiS_SISDetectCRT1(ScrnInfoPtr pScrn, unsigned char *buffer)
 {
     SISPtr pSiS = SISPTR(pScrn);
     UShort temp = 0xffff;
-    UChar  SR1F, CR63=0, CR17;
-    int    i, ret = 0;
-    Bool   mustwait = FALSE;
-
-    inSISIDXREG(SISSR,0x1F,SR1F);
-    setSISIDXREG(SISSR,0x1F,0x3f,0x04);
+    UChar  SR1F, CR63=0, CR17, SR1;
+    int    i, j, ret = 0;
+    Bool   mustwait = FALSE, longwait = FALSE;
+    
+    
+
+    inSISIDXREG(SISSR, 0x1F, SR1F);
+    setSISIDXREG(SISSR, 0x1F, 0x3f, 0x04);
     if(SR1F & 0xc0) mustwait = TRUE;
 
-    if(pSiS->VGAEngine == SIS_315_VGA) {
-       inSISIDXREG(SISCR,pSiS->myCR63,CR63);
-       CR63 &= 0x40;
-       andSISIDXREG(SISCR,pSiS->myCR63,0xbf);
-    }
+    inSISIDXREG(SISSR, 0x01, SR1);
 
-    inSISIDXREG(SISCR,0x17,CR17);
+    inSISIDXREG(SISCR, 0x17, CR17);
     CR17 &= 0x80;
     if(!CR17) {
-       orSISIDXREG(SISCR,0x17,0x80);
+       orSISIDXREG(SISCR, 0x17, 0x80);
        mustwait = TRUE;
-       outSISIDXREG(SISSR, 0x00, 0x01);
-       outSISIDXREG(SISSR, 0x00, 0x03);
+    }
+
+    if(pSiS->VGAEngine == SIS_315_VGA) {
+       inSISIDXREG(SISCR, pSiS->myCR63, CR63);
+       CR63 &= 0x40;
+       andSISIDXREG(SISCR, pSiS->myCR63, 0xbf);
     }
 
     if(mustwait) {
-       for(i=0; i < 10; i++) SISWaitRetraceCRT1(pScrn);
+       orSISIDXREG(SISSR, 0x01, 0x20);
+       outSISIDXREG(SISSR, 0x00, 0x01);
+       usleep(10000);
+       outSISIDXREG(SISSR, 0x00, 0x03);
+       for(i = 0; i < 10; i++) SISWaitRetraceCRT1(pScrn);
     }
 
     if(pSiS->ChipType >= SIS_330) {
-       int watchdog;
+       int watchdog, sr7;
+       inSISIDXREG(SISSR, 0x07, sr7);
+       orSISIDXREG(SISSR, 0x07, 0x10);
        if(pSiS->ChipType >= SIS_340) {
           outSISIDXREG(SISCR, 0x57, 0x4a);
        } else {
@@ -189,40 +113,75 @@ SiS_SISDetectCRT1(ScrnInfoPtr pScrn)
        while((!((inSISREG(SISINPSTAT)) & 0x01)) && --watchdog);
        watchdog = 655360;
        while(((inSISREG(SISINPSTAT)) & 0x01) && --watchdog);
-       if((inSISREG(SISMISCW)) & 0x10) temp = 1;
+       
+       #ifdef TWDEBUG
+        unsigned char uc=0;
+        uc = inSISREG(SISMISCR);
+       xf86DrvMsg(0,X_INFO,"[SiS_SISDetectCRT1()]:MISC REG Read Port context=%x\n.",uc);
+      
+        uc = inSISREG(SISMISCW);
+       xf86DrvMsg(0,X_INFO,"[SiS_SISDetectCRT1()]:MISC REG Write Port context=%x\n.",uc);
+       #endif
+       
+       //Eric
+       //if(pSiS->trace_VGA_MISCW)
+       //{if((inSISREG(SISMISCW)) & 0x10) {temp = 1;}}  /*blocked CRT DDC detect refer from VBIOS.*/
+       
        andSISIDXREG(SISCR, 0x53, 0xfd);
        outSISIDXREG(SISCR, 0x57, 0x00);
-#ifdef TWDEBUG
-       xf86DrvMsg(0, X_INFO, "330: Found CRT1: %s\n", (temp == 1) ? "yes" : "no");
-#endif
+       outSISIDXREG(SISSR, 0x07, sr7);
     }
 
     if((temp == 0xffff) && (!pSiS->SiS_Pr->DDCPortMixup)) {
-       i = 3;
+       i = 4;
        do {
           temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, 0, 0, NULL, pSiS->VBFlags2);
+          if(((temp == 0) || (temp == 0xffff)) && mustwait) {
+             for(j = 0; j < 10; j++) SISWaitRetraceCRT1(pScrn);
+	  }
        } while(((temp == 0) || (temp == 0xffff)) && i--);
 
        if((temp == 0) || (temp == 0xffff)) {
           if(TestDDC1(pScrn)) temp = 1;
        }
+
+       longwait = TRUE;
     }
 
     if((temp) && (temp != 0xffff)) {
-       orSISIDXREG(SISCR,0x32,0x20);
+       orSISIDXREG(SISCR, 0x32, 0x20);
        ret = 1;
+       if(buffer) {
+          i = 5;
+          do {
+             temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, 0, 0, NULL, pSiS->VBFlags2);
+             if(((temp == 0) || (temp == 0xffff)) && mustwait && !longwait) {
+                for(j = 0; j < 10; j++) SISWaitRetraceCRT1(pScrn);
+             }
+          } while(((temp == 0) || (temp == 0xffff)) && i--);
+          if((temp != 0xffff) && (temp & 0x02)) {
+             i = 3;
+	     do {
+	       temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine,
+				0, 1, buffer, pSiS->VBFlags2);
+	     } while((temp) && i--);
+	     if(!temp) ret = 2;
+          }
+       }
     } else if(pSiS->ChipType >= SIS_330) {
-       andSISIDXREG(SISCR,0x32,~0x20);
+       andSISIDXREG(SISCR, 0x32, ~0x20);
        ret = 0;
     }
 
+    outSISIDXREG(SISSR, 0x01, SR1);
+
     if(pSiS->VGAEngine == SIS_315_VGA) {
-       setSISIDXREG(SISCR,pSiS->myCR63,0xBF,CR63);
+       setSISIDXREG(SISCR, pSiS->myCR63, 0xBF, CR63);
     }
 
-    setSISIDXREG(SISCR,0x17,0x7F,CR17);
+    setSISIDXREG(SISCR, 0x17, 0x7F, CR17);
 
-    outSISIDXREG(SISSR,0x1F,SR1F);
+    outSISIDXREG(SISSR, 0x1F, SR1F);
 
     return ret;
 }
@@ -239,13 +198,21 @@ void SISCRT1PreInit(ScrnInfoPtr pScrn)
     if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE)) {
        pSiS->CRT1Detected = TRUE;
        pSiS->CRT1off = 0;
+       
+       #ifdef TWDEBUG
+        xf86DrvMsg(0,X_INFO,"E10[ SISCRT1PreInit() -> != VB2_VIDEOBRIDGE ]:CRT1=%d.\n",pSiS->CRT1Detected );
+       #endif
+
        return;
     }
-
 #ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        pSiS->CRT1Detected = TRUE;
        pSiS->CRT1off = 0;
+       #ifdef TWDEBUG
+        xf86DrvMsg(0,X_INFO,"E1[ SISCRT1PreInit() -> pSiS->DualHeadMode ]:CRT1=%d.\n",pSiS->CRT1Detected );
+       #endif
+
        return;
     }
 #endif
@@ -254,6 +221,10 @@ void SISCRT1PreInit(ScrnInfoPtr pScrn)
     if((pSiS->MergedFB) && (!(pSiS->MergedFBAuto))) {
        pSiS->CRT1Detected = TRUE;
        pSiS->CRT1off = 0;
+       #ifdef TWDEBUG
+        xf86DrvMsg(0,X_INFO,"E12[ SISCRT1PreInit() -> pSiS->DualHeadMode ]:CRT1=%d.\n",pSiS->CRT1Detected );
+       #endif
+
        return;
     }
 #endif
@@ -261,11 +232,26 @@ void SISCRT1PreInit(ScrnInfoPtr pScrn)
     inSISIDXREG(SISCR, 0x32, CR32);
 
     if(pSiS->ChipType >= SIS_330) {
-       /* Works reliably on 330 and later */
-       pSiS->CRT1Detected = SiS_SISDetectCRT1(pScrn);
+        pSiS->CRT1Detected = SiS_SISDetectCRT1(pScrn, NULL);
+        #ifdef TWDEBUG
+        xf86DrvMsg(0,X_INFO,"E13[ SISCRT1PreInit() -> >= SIS_330 ]:CRT1=%d.\n",pSiS->CRT1Detected);
+       #endif
+
     } else {
-       if(CR32 & 0x20) pSiS->CRT1Detected = TRUE;
-       else            pSiS->CRT1Detected = SiS_SISDetectCRT1(pScrn);
+        
+           if(CR32 & 0x20) 
+           {      pSiS->CRT1Detected = TRUE;
+                  #ifdef TWDEBUG
+                  xf86DrvMsg(0,X_INFO,"E14[ SISCRT1PreInit() -> < SIS_330 ]:CRT1=%d.\n",pSiS->CRT1Detected);
+                  #endif 
+           }
+
+           else { 
+                  pSiS->CRT1Detected = SiS_SISDetectCRT1(pScrn, NULL);
+                  #ifdef TWDEBUG
+                  xf86DrvMsg(0,X_INFO,"E15[ SISCRT1PreInit() -> CR32 & 0X20 = 0 ]:CRT1=%d.\n",pSiS->CRT1Detected);
+                  #endif
+                }
     }
 
     if(CR32 & 0x5F) OtherDevices = 1;
@@ -285,12 +271,45 @@ void SISCRT1PreInit(ScrnInfoPtr pScrn)
 
        }
     }
+    
+  	  pSiS->CRT1off = 1;
+      pSiS->CRT1Detected = FALSE;
+
+    
+    
 
     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 		"%sCRT1/VGA detected\n",
 		pSiS->CRT1Detected ? "" : "No ");
 }
-
+/*------------  only detect VGA1   ------------*/
+unsigned int SiS_DetectVGA1(ScrnInfoPtr pScrn)
+{
+	SISPtr  pSiS = SISPTR(pScrn);
+	unsigned int detected = 0;
+	unsigned short temp = 0xffff;
+        int            i,j;
+
+
+	i = 0;/*Ivans changed.*/
+        do {
+	           temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, 0, 0, NULL, pSiS->VBFlags2);
+		      
+		  /* if(((temp == 0) || (temp == 0xffff))) {
+		           for(j = 0; j < 2; j++) SISWaitRetraceCRT1(pScrn);
+		   }*/
+           } while(((temp == 0) || (temp == 0xffff)) && i--);
+
+        /*if((temp == 0) || (temp == 0xffff)) {
+	          if(TestDDC1(pScrn)) temp = 1;
+        }*/
+
+	
+	detected = temp;
+		
+	return detected;
+}
+/*---------------------------------------------*/
 /* Detect CRT2-LCD and LCD size */
 void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
 {
@@ -303,9 +322,9 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
     pSiS->LCDheight  = 0;
 
     if(!(pSiS->VBFlags2 & VB2_VIDEOBRIDGE)) return;
+    if(pSiS->forceLCDcrt1)	return;
 
     inSISIDXREG(SISCR, 0x32, CR32);
-
     if(CR32 & 0x08) pSiS->VBFlags |= CRT2_LCD;
 
     /* If no panel has been detected by the BIOS during booting,
@@ -313,7 +332,7 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
      * if forcecrt2redetection was given, too.
      * This is useful on machines with DVI connectors where the
      * panel was connected after booting. This is only supported
-     * on the 315/330 series and the 301/30xB/C bridge (because the
+     * on the 315+ series and the 301/30xB/C bridge (because the
      * 30xLV don't seem to have a DDC port and operate only LVDS
      * panels which mostly don't support DDC). We only do this if
      * there was no secondary VGA detected by the BIOS, because LCD
@@ -327,8 +346,8 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
      * By default, CRT2 redetection is forced since 12/09/2003, as
      * I encountered numerous panels which deliver more or less
      * bogus DDC data confusing the BIOS. Since our DDC detection
-     * is waaaay better, we prefer it instead of the primitive
-     * and buggy BIOS method.
+     * is waaaay better, we prefer it over the primitive and
+     * buggy BIOS method.
      *
      */
 #ifdef SISDUALHEAD
@@ -383,17 +402,35 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
 	  }
        }
        if(pSiS->PRGB != -1) {
-	  tmp = 0x37;
-	  if((pSiS->VGAEngine == SIS_315_VGA) &&
-	     (pSiS->ChipType < SIS_661)       &&
-	     (pSiS->ROM661New)                &&
-	     (!(pSiS->SiS_Pr->PanelSelfDetected))) {
-	     tmp = 0x35;
-	  }
-	  if(pSiS->PRGB == 18)      orSISIDXREG(SISCR, tmp, 0x01);
-	  else if(pSiS->PRGB == 24) andSISIDXREG(SISCR, tmp, 0xfe);
+          tmp = 0x37;
+          if((pSiS->VGAEngine == SIS_315_VGA) &&
+             (pSiS->ChipType < SIS_661)       &&
+             (pSiS->ROM661New)                &&
+             (!(pSiS->SiS_Pr->PanelSelfDetected))) {
+             tmp = 0x35;
+          }
+          if(pSiS->PRGB == 18)      orSISIDXREG(SISCR, tmp, 0x01);
+          else if(pSiS->PRGB == 24) andSISIDXREG(SISCR, tmp, 0xfe);
        }
-       inSISIDXREG(SISCR, 0x37, CR37);
+       else{/*if no Option force Panel RGB style,we set default 18bits(Ivans Lee)*/
+           if((pSiS->VBFlags2 & VB2_SISLVDSBRIDGE))/*default LVDS used 18bits*/
+            { pSiS->PRGB = 18;}
+          else /*default DVI used 24bits*/
+          {pSiS->PRGB = 24;}
+          tmp = 0x37;
+          if((pSiS->VGAEngine == SIS_315_VGA) &&
+             (pSiS->ChipType < SIS_661)       &&
+             (pSiS->ROM661New)                &&
+             (!(pSiS->SiS_Pr->PanelSelfDetected))) {
+             tmp = 0x35;
+          }
+           if(pSiS->PRGB == 18)      orSISIDXREG(SISCR, tmp, 0x01);
+          else if(pSiS->PRGB == 24) andSISIDXREG(SISCR, tmp, 0xfe);
+           #ifdef TWDEBUG
+           xf86DrvMsg(0,X_INFO,"No Options force Panel RGB,Default Panel RGB is %d bits.\n",pSiS->PRGB);
+           #endif
+       }     
+      inSISIDXREG(SISCR, 0x37, CR37);
        if(pSiS->ChipType < SIS_661) {
 	  inSISIDXREG(SISCR, 0x3C, CR7D);
        } else {
@@ -458,6 +495,11 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
 		inSISIDXREG(SISCR,0x37,CR37);
 	     }
 	  }
+	  /*1366x768x60Hz,jump out VB_LCD_CUSTOM, we must clean current CR36. Ivans@090109*/
+          if(pSiS->EnablePanel_1366x768 && ((CR36 & 0x0f == 0x0f))){
+	     CR36 &= 0xf0;
+	  }
+	  /*Ivans@090109*/
 	  if((CR36 & 0x0f) == 0x0f) {
 	     pSiS->VBLCDFlags |= VB_LCD_CUSTOM;
 	     pSiS->LCDheight = pSiS->SiS_Pr->CP_MaxY;
@@ -475,9 +517,18 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
 		pSiS->LCDwidth = SiS300_LCD_Type[(CR36 & 0x0f)].LCDwidth;
 		if(CR37 & 0x10) pSiS->VBLCDFlags |= VB_LCD_EXPANDING;
 	     } else if((pSiS->ChipType >= SIS_661) || (pSiS->ROM661New)) {
-		pSiS->VBLCDFlags |= SiS661_LCD_Type[(CR36 & 0x0f)].VBLCD_lcdflag;
-		pSiS->LCDheight = SiS661_LCD_Type[(CR36 & 0x0f)].LCDheight;
-		pSiS->LCDwidth = SiS661_LCD_Type[(CR36 & 0x0f)].LCDwidth;
+	     /*1366x768x60hz. can't refer from CR36. Ivans@090109*/
+		 if(pSiS->EnablePanel_1366x768){
+                    pSiS->VBLCDFlags |= SiS661_LCD_Type[(0x10)].VBLCD_lcdflag;
+		    pSiS->LCDheight = SiS661_LCD_Type[(0x10)].LCDheight;
+		    pSiS->LCDwidth = SiS661_LCD_Type[(0x10)].LCDwidth;
+		    CR36 |= 0x0f;/*restore original CR36 value.*/   
+		}/*Ivans@090109*/
+            else{
+		    pSiS->VBLCDFlags |= SiS661_LCD_Type[(CR36 & 0x0f)].VBLCD_lcdflag;
+		    pSiS->LCDheight = SiS661_LCD_Type[(CR36 & 0x0f)].LCDheight;
+		    pSiS->LCDwidth = SiS661_LCD_Type[(CR36 & 0x0f)].LCDwidth;
+            	}
 		if(CR37 & 0x10) pSiS->VBLCDFlags |= VB_LCD_EXPANDING;
 		if(pSiS->ChipType < SIS_661) {
 		   if(!(pSiS->SiS_Pr->PanelSelfDetected)) {
@@ -503,6 +554,10 @@ void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet)
 	  }
        }
     }
+#ifdef TWDEBUG
+	xf86DrvMsg(pScrn->scrnIndex,X_PROBED, "Detected CRT2 : %s\n",
+	(SiS_GetReg(SISCR, 0x7E) &0x01) ? "LVDS" : "TMDS");
+#endif 
 }
 
 void SiSSetupPseudoPanel(ScrnInfoPtr pScrn)
@@ -543,6 +598,7 @@ void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet)
     inSISIDXREG(SISCR, 0x35, CR35);
     inSISIDXREG(SISSR, 0x16, SR16);
     inSISIDXREG(SISSR, 0x38, SR38);
+
     switch(pSiS->VGAEngine) {
     case SIS_300_VGA:
        if(pSiS->Chipset == PCI_CHIP_SIS630) temp = 0x35;
@@ -561,8 +617,12 @@ void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet)
 	CR32, SR16, SR38, pSiS->VBFlags);
 #endif
 
-    if(CR32 & 0x47) pSiS->VBFlags |= CRT2_TV;
-
+    if(pSiS->ChipType>=SIS_761){
+        if(CR32 & 0x07) pSiS->VBFlags |= CRT2_TV;
+    }else{
+        if(CR32 & 0x47) pSiS->VBFlags |= CRT2_TV;
+    }
+	
     if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR) {
        if(CR32 & 0x80) pSiS->VBFlags |= CRT2_TV;
     } else {
@@ -587,7 +647,7 @@ void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet)
 	     case 0x60: pSiS->VBFlags |= TV_YPBPR1080I; break;
 	     default:   pSiS->VBFlags |= TV_YPBPR525I;
 	     }
-          } else        pSiS->VBFlags |= TV_YPBPR525I;
+          } else        pSiS->VBFlags |= TV_YPBPR525I;		  
           inSISIDXREG(SISCR,0x39,CR39);
 	  CR39 &= 0x03;
 	  if(CR39 == 0x00)      pSiS->VBFlags |= TV_YPBPR43LB;
@@ -644,13 +704,24 @@ void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet)
  	  } else
 	     pSiS->VBFlags |= TV_NTSC;
        } else if(pSiS->NewCRLayout) {
-          if(SR38 & 0x01) {
-	     pSiS->VBFlags |= TV_PAL;
-	     if(CR35 & 0x04)      pSiS->VBFlags |= TV_PALM;
-	     else if(CR35 & 0x08) pSiS->VBFlags |= TV_PALN;
-	  } else {
-	     pSiS->VBFlags |= TV_NTSC;
-	     if(CR35 & 0x02)      pSiS->VBFlags |= TV_NTSCJ;
+          if(pSiS->ChipType<SIS_661){
+              if(SR38 & 0x01) {
+	          pSiS->VBFlags |= TV_PAL;
+	      } else {
+	          pSiS->VBFlags |= TV_NTSC;
+	      }
+	  }else{
+              if(CR35 & 0x01) {
+	          pSiS->VBFlags |= TV_PAL;
+	      } else {
+	          pSiS->VBFlags |= TV_NTSC;
+	      }
+	  }
+	  if(pSiS->VBFlags & TV_PAL){
+	      if(CR35 & 0x04)      pSiS->VBFlags |= TV_PALM;
+	      else if(CR35 & 0x08) pSiS->VBFlags |= TV_PALN;
+ 	  }else if(pSiS->VBFlags & TV_NTSC){
+	      if(CR35 & 0x02)      pSiS->VBFlags |= TV_NTSCJ;
 	  }
        } else {	/* 315, 330 */
 	  if(SR38 & 0x01) {
@@ -690,6 +761,14 @@ void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet)
 	     ((pSiS->VBFlags & TV_YPBPR525P) ? "480p" :
 	        ((pSiS->VBFlags & TV_YPBPR750P) ? "720p" : "1080i")));
     }
+
+/* K.T disable vertical blank end bit 9 and bit 10*/
+	if((pSiS->VBFlags & (TV_AVIDEO|TV_SVIDEO)) && (pScrn->bitsPerPixel ==8 ))
+	{
+		inSISIDXREG(SISSR, 0x1C, temp);
+		temp &= ~0x40;
+		outSISIDXREG(SISSR, 0x1C, temp);
+	}
 }
 
 /* Detect CRT2-VGA */
@@ -757,7 +836,6 @@ SISDoSense(ScrnInfoPtr pScrn, UShort type, UShort test)
 {
     SISPtr pSiS = SISPTR(pScrn);
     int    temp, mytest, result, i, j;
-
 #ifdef TWDEBUG
     xf86DrvMsg(0, X_INFO, "Sense: %x %x\n", type, test);
 #endif
@@ -766,25 +844,25 @@ SISDoSense(ScrnInfoPtr pScrn, UShort type, UShort test)
        result = 0;
        for(i = 0; i < 3; i++) {
           mytest = test;
-          outSISIDXREG(SISPART4,0x11,(type & 0x00ff));
+          outSISIDXREG(SISPART4, 0x11, (type & 0x00ff));
           temp = (type >> 8) | (mytest & 0x00ff);
-          setSISIDXREG(SISPART4,0x10,0xe0,temp);
+          setSISIDXREG(SISPART4, 0x10, 0xe0,temp);
           SiS_DDC2Delay(pSiS->SiS_Pr, 0x1500);
           mytest >>= 8;
           mytest &= 0x7f;
-          inSISIDXREG(SISPART4,0x03,temp);
+          inSISIDXREG(SISPART4, 0x03, temp);
           temp ^= 0x0e;
           temp &= mytest;
           if(temp == mytest) result++;
 #if 1
-	  outSISIDXREG(SISPART4,0x11,0x00);
-	  andSISIDXREG(SISPART4,0x10,0xe0);
+	  outSISIDXREG(SISPART4, 0x11, 0x00);
+	  andSISIDXREG(SISPART4, 0x10, 0xe0);
 	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
 #endif
        }
        if((result == 0) || (result >= 2)) break;
     }
-    return(result);
+    return result;
 }
 
 #define GETROMWORD(w) (pSiS->BIOS[w] | (pSiS->BIOS[w+1] << 8))
@@ -799,18 +877,22 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
     UShort cvbs=0, cvbs_c=0;
     UShort vga2=0, vga2_c=0;
     int    myflag, result; /* , i; */
-
+    ULong  offset;
     if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return;
 
 #ifdef TWDEBUG
-    inSISIDXREG(SISCR,0x32,backupP2_4d);
+
+			//Eric
+	    andSISIDXREG(SISCR, 0x32, 0x08);
+	
+    inSISIDXREG(SISCR, 0x32, backupP2_4d);
     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     	"(vb.c: SISSense30c 1: CR32=%02x, VBFlags 0x%x)\n", backupP2_4d, pSiS->VBFlags);
 #endif
 
     if(pSiS->VBFlags2 & VB2_301) {
        svhs = 0x00b9; cvbs = 0x00b3; vga2 = 0x00d1;
-       inSISIDXREG(SISPART4,0x01,myflag);
+       inSISIDXREG(SISPART4, 0x01, myflag);
        if(myflag & 0x04) {
 	  svhs = 0x00dd; cvbs = 0x00ee; vga2 = 0x00fd;
        }
@@ -822,6 +904,7 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
        svhs = 0x016b; cvbs = 0x0110; vga2 = 0x0190;
     } else return;
 
+
     vga2_c = 0x0e08; svhs_c = 0x0404; cvbs_c = 0x0804;
     if(pSiS->VBFlags2 & (VB2_301LV|VB2_302LV|VB2_302ELV|VB2_307LV)) {
        svhs_c = 0x0408; cvbs_c = 0x0808;
@@ -829,28 +912,40 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
     biosflag = 2;
 
     if(pSiS->Chipset == PCI_CHIP_SIS300) {
-       inSISIDXREG(SISSR,0x3b,myflag);
+       inSISIDXREG(SISSR, 0x3b, myflag);
        if(!(myflag & 0x01)) vga2 = vga2_c = 0;
     }
 
+
     if(pSiS->SiS_Pr->UseROM) {
        if(pSiS->VGAEngine == SIS_300_VGA) {
 	  if(pSiS->VBFlags2 & VB2_301) {
-	     inSISIDXREG(SISPART4,0x01,myflag);
+	     inSISIDXREG(SISPART4, 0x01, myflag);
 	     if(!(myflag & 0x04)) {
 		vga2 = GETROMWORD(0xf8); svhs = GETROMWORD(0xfa); cvbs = GETROMWORD(0xfc);
 	     }
 	  }
 	  biosflag = pSiS->BIOS[0xfe];
        } else if((pSiS->Chipset == PCI_CHIP_SIS660) ||
-	         (pSiS->Chipset == PCI_CHIP_SIS340)) {
+	         (pSiS->Chipset == PCI_CHIP_SIS340) ||
+	         (pSiS->Chipset == PCI_CHIP_SIS670) ||
+	         (pSiS->Chipset == PCI_CHIP_SIS671)) {
 	  if(pSiS->ROM661New) {
 	     biosflag = 2;
-	     vga2 = GETROMWORD(0x63);
+             if(pSiS->ChipType>=SIS_761){
+                 offset = GETROMWORD(0x92);
+                 vga2 = GETROMWORD(offset);
+             }else{
+	         vga2 = GETROMWORD(0x63);
+             }
 	     if(pSiS->BIOS[0x6f] & 0x01) {
 	        if(pSiS->VBFlags2 & VB2_SISUMC) vga2 = GETROMWORD(0x4d);
 	     }
-	     svhs = cvbs = GETROMWORD(0x65);
+             if(pSiS->ChipType>=SIS_761){
+                 svhs = cvbs = GETROMWORD(offset);
+             }else{
+	         svhs = cvbs = GETROMWORD(0x65);
+             }
 	     if(pSiS->BIOS[0x5d] & 0x04) biosflag |= 0x01;
 	  }
        }
@@ -877,65 +972,68 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
        vga2 = vga2_c = 0;
     }
 
-    inSISIDXREG(SISSR,0x1e,backupSR_1e);
-    orSISIDXREG(SISSR,0x1e,0x20);
+    inSISIDXREG(SISSR, 0x1e, backupSR_1e);
+    orSISIDXREG(SISSR, 0x1e, 0x20);
 
-    inSISIDXREG(SISPART4,0x0d,backupP4_0d);
+    inSISIDXREG(SISPART4, 0x0d, backupP4_0d);
     if(pSiS->VBFlags2 & VB2_30xCLV) {
-       setSISIDXREG(SISPART4,0x0d,~0x07,0x01);
+       setSISIDXREG(SISPART4, 0x0d, ~0x07, 0x01);
+    } else if(pSiS->VBFlags2 & VB2_301) {
+       setSISIDXREG(SISPART4, 0x0d, ~0x07, 0x05);
     } else {
-       orSISIDXREG(SISPART4,0x0d,0x04);
+       orSISIDXREG(SISPART4, 0x0d, 0x04);
     }
     SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
 
-    inSISIDXREG(SISPART2,0x00,backupP2_00);
-    outSISIDXREG(SISPART2,0x00,((backupP2_00 | 0x1c) & 0xfc));
+    inSISIDXREG(SISPART2, 0x00, backupP2_00);
+    outSISIDXREG(SISPART2, 0x00, ((backupP2_00 | 0x3c) & 0xfc));
 
-    inSISIDXREG(SISPART2,0x4d,backupP2_4d);
+    inSISIDXREG(SISPART2, 0x4d, backupP2_4d);
     if(pSiS->VBFlags2 & VB2_SISYPBPRBRIDGE) {
-       outSISIDXREG(SISPART2,0x4d,(backupP2_4d & ~0x10));
+       outSISIDXREG(SISPART2, 0x4d, (backupP2_4d & ~0x10));
     }
 
     if(!(pSiS->VBFlags2 & VB2_30xCLV)) {
        SISDoSense(pScrn, 0, 0);
     }
-
-    andSISIDXREG(SISCR, 0x32, ~0x14);
-    pSiS->postVBCR32 &= ~0x14;
-
-    if(vga2_c || vga2) {
-       if(SISDoSense(pScrn, vga2, vga2_c)) {
-	  if(biosflag & 0x01) {
-	     if(!quiet) {
-	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		    "SiS30x: Detected TV connected to SCART output\n");
-	     }
-	     pSiS->VBFlags |= TV_SCART;
-	     orSISIDXREG(SISCR, 0x32, 0x04);
-	     pSiS->postVBCR32 |= 0x04;
-	  } else {
-	     if(!quiet) {
-	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		    "SiS30x: Detected secondary VGA connection\n");
+	
+    if(pSiS->VBFlags2 != VB2_307LV||pSiS->VBFlags2 != VB2_307T){
+        andSISIDXREG(SISCR, 0x32, ~0x14);
+        pSiS->postVBCR32 &= ~0x14;
+        if(vga2_c || vga2) {
+            if(SISDoSense(pScrn, vga2, vga2_c)) {
+                if(biosflag & 0x01) {
+                    if(!quiet) {
+	                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		        "SiS30x: Detected TV connected to SCART output\n");
+	            }
+	            pSiS->VBFlags |= TV_SCART;
+	            orSISIDXREG(SISCR, 0x32, 0x04);
+	            pSiS->postVBCR32 |= 0x04;
+	        } else {
+	            if(!quiet) {
+	                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+		        "SiS30x: Detected secondary VGA connection\n");
+	            }
+	            pSiS->VBFlags |= VGA2_CONNECTED;
+	            orSISIDXREG(SISCR, 0x32, 0x10);
+	            pSiS->postVBCR32 |= 0x10;
+	        }
 	     }
-	     pSiS->VBFlags |= VGA2_CONNECTED;
-	     orSISIDXREG(SISCR, 0x32, 0x10);
-	     pSiS->postVBCR32 |= 0x10;
-	  }
-       }
-       if(biosflag & 0x01) pSiS->SiS_SD_Flags |= SiS_SD_VBHASSCART;
+        if(biosflag & 0x01) pSiS->SiS_SD_Flags |= SiS_SD_VBHASSCART;
+        }
     }
-
     andSISIDXREG(SISCR, 0x32, 0x3f);
     pSiS->postVBCR32 &= 0x3f;
 
     if(pSiS->VBFlags2 & VB2_30xCLV) {
-       orSISIDXREG(SISPART4,0x0d,0x04);
+       orSISIDXREG(SISPART4, 0x0d, 0x04);
     }
+	
 
     if((pSiS->VGAEngine == SIS_315_VGA) && (pSiS->VBFlags2 & VB2_SISYPBPRBRIDGE)) {
        if(pSiS->SenseYPbPr) {
-	  outSISIDXREG(SISPART2,0x4d,(backupP2_4d | 0x10));
+	  outSISIDXREG(SISPART2, 0x4d, (backupP2_4d | 0x10));
 	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
 	  /* New BIOS (2.x) uses vga2 sensing here for all bridges >301LV */
 	  if((result = SISDoSense(pScrn, svhs, 0x0604))) {
@@ -944,12 +1042,12 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
 		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
 			"SiS30x: Detected TV connected to YPbPr component output\n");
 		}
-		orSISIDXREG(SISCR,0x32,0x80);
+		orSISIDXREG(SISCR, 0x32, 0x80);
 		pSiS->VBFlags |= TV_YPBPR;
 		pSiS->postVBCR32 |= 0x80;
 	     }
 	  }
-	  outSISIDXREG(SISPART2,0x4d,backupP2_4d);
+	  outSISIDXREG(SISPART2, 0x4d, backupP2_4d);
        }
     }
 
@@ -957,7 +1055,6 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
     pSiS->postVBCR32 &= ~0x03;
 
     if(!(pSiS->VBFlags & TV_YPBPR)) {
-
        if((result = SISDoSense(pScrn, svhs, svhs_c))) {
 	  if(!quiet) {
 	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
@@ -979,29 +1076,27 @@ SISSense30x(ScrnInfoPtr pScrn, Bool quiet)
 	     pSiS->postVBCR32 |= 0x01;
 	  }
        }
-
     }
-
     SISDoSense(pScrn, 0, 0);
 
-    outSISIDXREG(SISPART2,0x00,backupP2_00);
-    outSISIDXREG(SISPART4,0x0d,backupP4_0d);
-    outSISIDXREG(SISSR,0x1e,backupSR_1e);
+    outSISIDXREG(SISPART2, 0x00, backupP2_00);
+    outSISIDXREG(SISPART4, 0x0d, backupP4_0d);
+    outSISIDXREG(SISSR, 0x1e, backupSR_1e);
 
     if(pSiS->VBFlags2 & VB2_30xCLV) {
-       inSISIDXREG(SISPART2,0x00,biosflag);
+       inSISIDXREG(SISPART2, 0x00, biosflag);
        if(biosflag & 0x20) {
           for(myflag = 2; myflag > 0; myflag--) {
 	     biosflag ^= 0x20;
-	     outSISIDXREG(SISPART2,0x00,biosflag);
+	     outSISIDXREG(SISPART2, 0x00, biosflag);
 	  }
        }
     }
 
-    outSISIDXREG(SISPART2,0x00,backupP2_00);
+    outSISIDXREG(SISPART2, 0x00, backupP2_00);
 
 #ifdef TWDEBUG
-    inSISIDXREG(SISCR,0x32,backupP2_4d);
+    inSISIDXREG(SISCR, 0x32, backupP2_4d);
     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     	"(vb.c: SISSense30c 2: CR32=0x%02x, VBFlags 0x%x)\n", backupP2_4d, pSiS->VBFlags);
 #endif
@@ -1216,11 +1311,2215 @@ Bool SISRedetectCRT2Type(ScrnInfoPtr pScrn)
     pSiS->VBFlagsInit = pSiS->VBFlags;
 
     /* Save new detection result registers to write them back in EnterVT() */
-    inSISIDXREG(SISCR,0x32,pSiS->myCR32);
-    inSISIDXREG(SISCR,0x36,pSiS->myCR36);
-    inSISIDXREG(SISCR,0x37,pSiS->myCR37);
+    inSISIDXREG(SISCR, 0x32, pSiS->myCR32);
+    inSISIDXREG(SISCR, 0x36, pSiS->myCR36);
+    inSISIDXREG(SISCR, 0x37, pSiS->myCR37);
 
     return TRUE;
 }
 
 
+/* Functions for adjusting various TV settings */
+
+/* These are used by the PostSetMode() functions as well as
+ * the display properties tool SiSCtrl.
+ *
+ * There is each a Set and a Get routine. The Set functions
+ * take a value of the same range as the corresponding option.
+ * The Get routines return a value of the same range (although
+ * not necessarily the same value as previously set because
+ * of the lower resolution of the respective setting compared
+ * to the valid range).
+ * The Get routines return -2 on error (eg. hardware does not
+ * support this setting).
+ * Note: The x and y positioning routines accept a position
+ * RELATIVE to the default position. All other routines
+ * take ABSOLUTE values.
+ *
+ * The Set functions will store the property regardless if TV is
+ * currently used or not and if the hardware supports the property
+ * or not. The Get routines will return this stored
+ * value if TV is not currently used (because the register does
+ * not contain the correct value then) or if the hardware supports
+ * the respective property. This should make it easier for the
+ * display property tool because it does not have to know the
+ * hardware features.
+ *
+ * All the routines are dual head aware. It does not matter
+ * if the function is called from the CRT1 or CRT2 session.
+ * The values will be in pSiSEnt anyway, and read from there
+ * if we're running dual head.
+ */
+
+void SiS_SetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvlumabandwidthcvbs = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvlumabandwidthcvbs = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           val /= 8;
+           if((val == 0) || (val == 1)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, val, 0xFE);
+           }
+	   break;
+       case CHRONTEL_701x:
+           val /= 4;
+	   if((val >= 0) && (val <= 3)) {
+	       SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, val, 0xFC);
+	   }
+           break;
+   }
+}
+
+int SiS_GetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvlumabandwidthcvbs;
+      else
+#endif
+           return (int)pSiS->chtvlumabandwidthcvbs;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x01) * 8);
+      case CHRONTEL_701x:
+	   return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x03) * 4);
+      default:
+           return (int)pSiS->chtvlumabandwidthcvbs;
+      }
+   }
+}
+
+void SiS_SetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvlumabandwidthsvideo = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvlumabandwidthsvideo = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           val /= 6;
+           if((val >= 0) && (val <= 2)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, (val << 1), 0xF9);
+           }
+	   break;
+       case CHRONTEL_701x:
+           val /= 4;
+	   if((val >= 0) && (val <= 3)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, (val << 2), 0xF3);
+	   }
+           break;
+   }
+}
+
+int SiS_GetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvlumabandwidthsvideo;
+      else
+#endif
+           return (int)pSiS->chtvlumabandwidthsvideo;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x06) >> 1) * 6);
+      case CHRONTEL_701x:
+	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x0c) >> 2) * 4);
+      default:
+           return (int)pSiS->chtvlumabandwidthsvideo;
+      }
+   }
+}
+
+void SiS_SetCHTVlumaflickerfilter(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvlumaflickerfilter = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvlumaflickerfilter = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           val /= 6;
+           if((val >= 0) && (val <= 2)) {
+	      UShort reg = 0;
+	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
+	      reg = (reg & 0xf0) | ((reg & 0x0c) >> 2) | (val << 2);
+              SiS_SetCH70xx(pSiS->SiS_Pr, 0x01, reg);
+           }
+	   break;
+       case CHRONTEL_701x:
+           val /= 4;
+	   if((val >= 0) && (val <= 3)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x01, (val << 2), 0xF3);
+	   }
+           break;
+   }
+}
+
+int SiS_GetCHTVlumaflickerfilter(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+          return (int)pSiSEnt->chtvlumaflickerfilter;
+      else
+#endif
+          return (int)pSiS->chtvlumaflickerfilter;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x03) * 6);
+      case CHRONTEL_701x:
+	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 4);
+      default:
+           return (int)pSiS->chtvlumaflickerfilter;
+      }
+   }
+}
+
+void SiS_SetCHTVchromabandwidth(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvchromabandwidth = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvchromabandwidth = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           val /= 4;
+           if((val >= 0) && (val <= 3)) {
+              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, (val << 4), 0xCF);
+           }
+	   break;
+       case CHRONTEL_701x:
+           val /= 8;
+	   if((val >= 0) && (val <= 1)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, (val << 4), 0xEF);
+	   }
+           break;
+   }
+}
+
+int SiS_GetCHTVchromabandwidth(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvchromabandwidth;
+      else
+#endif
+           return (int)pSiS->chtvchromabandwidth;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x30) >> 4) * 4);
+      case CHRONTEL_701x:
+	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x10) >> 4) * 8);
+      default:
+           return (int)pSiS->chtvchromabandwidth;
+      }
+   }
+}
+
+void SiS_SetCHTVchromaflickerfilter(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvchromaflickerfilter = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvchromaflickerfilter = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           val /= 6;
+           if((val >= 0) && (val <= 2)) {
+	      UShort reg = 0;
+	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
+	      reg = (reg & 0xc0) | ((reg & 0x0c) >> 2) | ((reg & 0x03) << 2) | (val << 4);
+              SiS_SetCH70xx(pSiS->SiS_Pr, 0x01, reg);
+           }
+	   break;
+       case CHRONTEL_701x:
+           val /= 4;
+	   if((val >= 0) && (val <= 3)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x01, (val << 4), 0xCF);
+	   }
+           break;
+   }
+}
+
+int SiS_GetCHTVchromaflickerfilter(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvchromaflickerfilter;
+      else
+#endif
+           return (int)pSiS->chtvchromaflickerfilter;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 6);
+      case CHRONTEL_701x:
+	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 4);
+      default:
+           return (int)pSiS->chtvchromaflickerfilter;
+      }
+   }
+}
+
+void SiS_SetCHTVcvbscolor(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvcvbscolor = val ? 1 : 0;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, 0x40, 0x00);
+           else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, 0x00, ~0x40);
+	   break;
+       case CHRONTEL_701x:
+           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, 0x00, ~0x20);
+	   else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x02, 0x20, 0x00);
+           break;
+   }
+}
+
+int SiS_GetCHTVcvbscolor(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvcvbscolor;
+      else
+#endif
+           return (int)pSiS->chtvcvbscolor;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x40) >> 6) ^ 0x01);
+      case CHRONTEL_701x:
+	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x20) >> 5) ^ 0x01);
+      default:
+           return (int)pSiS->chtvcvbscolor;
+      }
+   }
+}
+
+void SiS_SetCHTVtextenhance(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvtextenhance = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvtextenhance = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+           val /= 6;
+           if((val >= 0) && (val <= 2)) {
+	      UShort reg = 0;
+	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
+	      reg = (reg & 0xf0) | ((reg & 0x03) << 2) | val;
+              SiS_SetCH70xx(pSiS->SiS_Pr, 0x01, reg);
+           }
+	   break;
+       case CHRONTEL_701x:
+           val /= 2;
+	   if((val >= 0) && (val <= 7)) {
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x03, val, 0xF8);
+	   }
+           break;
+   }
+}
+
+int SiS_GetCHTVtextenhance(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvtextenhance;
+      else
+#endif
+           return (int)pSiS->chtvtextenhance;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+	   return (int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 6);
+      case CHRONTEL_701x:
+	   return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x07) * 2);
+      default:
+           return (int)pSiS->chtvtextenhance;
+      }
+   }
+}
+
+void SiS_SetCHTVcontrast(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->chtvcontrast = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->chtvcontrast = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_CHRONTEL)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   val /= 2;
+   if((val >= 0) && (val <= 7)) {
+       switch(pSiS->ChrontelType) {
+       case CHRONTEL_700x:
+              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x11, val, 0xF8);
+	      break;
+       case CHRONTEL_701x:
+	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x08, val, 0xF8);
+              break;
+       }
+       SiS_DDC2Delay(pSiS->SiS_Pr, 1000);
+   }
+}
+
+int SiS_GetCHTVcontrast(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   if(!((pSiS->VBFlags2 & VB2_CHRONTEL) && (pSiS->VBFlags & CRT2_TV))) {
+#ifdef SISDUALHEAD
+      if(pSiSEnt && pSiS->DualHeadMode)
+           return (int)pSiSEnt->chtvcontrast;
+      else
+#endif
+           return (int)pSiS->chtvcontrast;
+   } else {
+#ifdef UNLOCK_ALWAYS
+      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+      switch(pSiS->ChrontelType) {
+      case CHRONTEL_700x:
+           return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x11) & 0x07) * 2);
+      case CHRONTEL_701x:
+	   return (int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x08) & 0x07) * 2);
+      default:
+           return (int)pSiS->chtvcontrast;
+      }
+   }
+}
+
+void SiS_SetSISTVedgeenhance(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->sistvedgeenhance = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->sistvedgeenhance = val;
+#endif
+
+   if(!(pSiS->VBFlags2 & VB2_301))  return;
+   if(!(pSiS->VBFlags & CRT2_TV))   return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   val /= 2;
+   if((val >= 0) && (val <= 7)) {
+      setSISIDXREG(SISPART2,0x3A, 0x1F, (val << 5));
+   }
+}
+
+int SiS_GetSISTVedgeenhance(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int result = pSiS->sistvedgeenhance;
+   UChar temp;
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvedgeenhance;
+#endif
+
+   if(!(pSiS->VBFlags2 & VB2_301))  return result;
+   if(!(pSiS->VBFlags & CRT2_TV))   return result;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+   inSISIDXREG(SISPART2, 0x3a, temp);
+   return(int)(((temp & 0xe0) >> 5) * 2);
+}
+
+void SiS_SetSISTVantiflicker(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->sistvantiflicker = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->sistvantiflicker = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV))      return;
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return;
+   if(pSiS->VBFlags & TV_HIVISION)     return;
+   if((pSiS->VBFlags & TV_YPBPR) &&
+      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR625P | TV_YPBPR750P | TV_YPBPR1080I))) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
+   if((val >= 0) && (val <= 4)) {
+      setSISIDXREG(SISPART2,0x0A,0x8F, (val << 4));
+   }
+}
+
+int SiS_GetSISTVantiflicker(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int result = pSiS->sistvantiflicker;
+   UChar temp;
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvantiflicker;
+#endif
+
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return result;
+   if(!(pSiS->VBFlags & CRT2_TV))        return result;
+   if(pSiS->VBFlags & TV_HIVISION)       return result;
+   if((pSiS->VBFlags & TV_YPBPR) &&
+      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR625P | TV_YPBPR750P | TV_YPBPR1080I))) return result;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+   inSISIDXREG(SISPART2, 0x0a, temp);
+   return(int)((temp & 0x70) >> 4);
+}
+
+void SiS_SetSISTVsaturation(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->sistvsaturation = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->sistvsaturation = val;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV)) return;
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return;
+   if(pSiS->VBFlags2 & VB2_301) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   val /= 2;
+   if((val >= 0) && (val <= 7)) {
+      setSISIDXREG(SISPART4,0x21,0xF8, val);
+   }
+}
+
+int SiS_GetSISTVsaturation(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int result = pSiS->sistvsaturation;
+   UChar temp;
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->sistvsaturation;
+#endif
+
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE)) return result;
+   if(pSiS->VBFlags2 & VB2_301)          return result;
+   if(!(pSiS->VBFlags & CRT2_TV))        return result;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+   inSISIDXREG(SISPART4, 0x21, temp);
+   return(int)((temp & 0x07) * 2);
+}
+
+void SiS_SetSISTVcolcalib(ScrnInfoPtr pScrn, int val, Bool coarse)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+   int ccoarse, cfine, cbase = pSiS->sistvccbase;
+   /* UChar temp; */
+
+#ifdef SISDUALHEAD
+   if(pSiSEnt && pSiS->DualHeadMode) cbase = pSiSEnt->sistvccbase;
+#endif
+
+   if(coarse) {
+      pSiS->sistvcolcalibc = ccoarse = val;
+      cfine = pSiS->sistvcolcalibf;
+#ifdef SISDUALHEAD
+      if(pSiSEnt) {
+         pSiSEnt->sistvcolcalibc = val;
+	 if(pSiS->DualHeadMode) cfine = pSiSEnt->sistvcolcalibf;
+      }
+#endif
+   } else {
+      pSiS->sistvcolcalibf = cfine = val;
+      ccoarse = pSiS->sistvcolcalibc;
+#ifdef SISDUALHEAD
+      if(pSiSEnt) {
+         pSiSEnt->sistvcolcalibf = val;
+         if(pSiS->DualHeadMode) ccoarse = pSiSEnt->sistvcolcalibc;
+      }
+#endif
+   }
+
+   if(!(pSiS->VBFlags & CRT2_TV))               return;
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return;
+   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   if((cfine >= -128) && (cfine <= 127) && (ccoarse >= -120) && (ccoarse <= 120)) {
+      long finalcc = cbase + (((ccoarse * 256) + cfine) * 256);
+
+#if 0
+      inSISIDXREG(SISPART4,0x1f,temp);
+      if(!(temp & 0x01)) {
+         if(pSiS->VBFlags & TV_NTSC) finalcc += 0x21ed8620;
+	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
+	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
+	 else finalcc += 0x2a05d300;
+      }
+#endif
+      setSISIDXREG(SISPART2,0x31,0x80,((finalcc >> 24) & 0x7f));
+      outSISIDXREG(SISPART2,0x32,((finalcc >> 16) & 0xff));
+      outSISIDXREG(SISPART2,0x33,((finalcc >> 8) & 0xff));
+      outSISIDXREG(SISPART2,0x34,(finalcc & 0xff));
+   }
+}
+
+int SiS_GetSISTVcolcalib(ScrnInfoPtr pScrn, Bool coarse)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)
+      if(coarse)  return (int)pSiSEnt->sistvcolcalibc;
+      else        return (int)pSiSEnt->sistvcolcalibf;
+   else
+#endif
+   if(coarse)     return (int)pSiS->sistvcolcalibc;
+   else           return (int)pSiS->sistvcolcalibf;
+}
+
+void SiS_SetSISTVcfilter(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->sistvcfilter = val ? 1 : 0;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV))               return;
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return;
+   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   setSISIDXREG(SISPART2,0x30,~0x10,((pSiS->sistvcfilter << 4) & 0x10));
+}
+
+int SiS_GetSISTVcfilter(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int result = pSiS->sistvcfilter;
+   UChar temp;
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvcfilter;
+#endif
+
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return result;
+   if(!(pSiS->VBFlags & CRT2_TV))               return result;
+   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return result;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+   inSISIDXREG(SISPART2, 0x30, temp);
+   return (int)((temp & 0x10) ? 1 : 0);
+}
+
+void SiS_SetSISTVyfilter(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+   UChar p35,p36,p37,p38,p48,p49,p4a,p30;
+   int i,j;
+
+   pSiS->sistvyfilter = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
+#endif
+
+   if(!(pSiS->VBFlags & CRT2_TV))               return;
+   if(!(pSiS->VBFlags2 & VB2_SISBRIDGE))        return;
+   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
+
+   p35 = pSiS->p2_35; p36 = pSiS->p2_36;
+   p37 = pSiS->p2_37; p38 = pSiS->p2_38;
+   p48 = pSiS->p2_48; p49 = pSiS->p2_49;
+   p4a = pSiS->p2_4a; p30 = pSiS->p2_30;
+#ifdef SISDUALHEAD
+   if(pSiSEnt && pSiS->DualHeadMode) {
+      p35 = pSiSEnt->p2_35; p36 = pSiSEnt->p2_36;
+      p37 = pSiSEnt->p2_37; p38 = pSiSEnt->p2_38;
+      p48 = pSiSEnt->p2_48; p49 = pSiSEnt->p2_49;
+      p4a = pSiSEnt->p2_4a; p30 = pSiSEnt->p2_30;
+   }
+#endif
+   p30 &= 0x20;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   switch(pSiS->sistvyfilter) {
+   case 0:
+      andSISIDXREG(SISPART2,0x30,0xdf);
+      break;
+   case 1:
+      outSISIDXREG(SISPART2,0x35,p35);
+      outSISIDXREG(SISPART2,0x36,p36);
+      outSISIDXREG(SISPART2,0x37,p37);
+      outSISIDXREG(SISPART2,0x38,p38);
+      if(!(pSiS->VBFlags2 & VB2_301)) {
+         outSISIDXREG(SISPART2,0x48,p48);
+         outSISIDXREG(SISPART2,0x49,p49);
+         outSISIDXREG(SISPART2,0x4a,p4a);
+      }
+      setSISIDXREG(SISPART2,0x30,0xdf,p30);
+      break;
+   case 2:
+   case 3:
+   case 4:
+   case 5:
+   case 6:
+   case 7:
+   case 8:
+      if(!(pSiS->VBFlags & (TV_PALM | TV_PALN | TV_NTSCJ))) {
+         int yindex301 = -1, yindex301B = -1;
+	 UChar p3d4_34;
+
+	 inSISIDXREG(SISCR,0x34,p3d4_34);
+
+	 switch((p3d4_34 & 0x7f)) {
+	 case 0x59:  /* 320x200 */
+	 case 0x41:
+	 case 0x4f:
+	 case 0x50:  /* 320x240 */
+	 case 0x56:
+	 case 0x53:
+	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
+	    break;
+	 case 0x2f:  /* 640x400 */
+	 case 0x5d:
+	 case 0x5e:
+	 case 0x2e:  /* 640x480 */
+	 case 0x44:
+	 case 0x62:
+	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
+	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
+	    break;
+	 case 0x31:   /* 720x480 */
+	 case 0x33:
+	 case 0x35:
+	 case 0x32:   /* 720x576 */
+	 case 0x34:
+	 case 0x36:
+	 case 0x5f:   /* 768x576 */
+	 case 0x60:
+	 case 0x61:
+	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
+	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
+	    break;
+	 case 0x51:   /* 400x300 */
+	 case 0x57:
+	 case 0x54:
+	 case 0x30:   /* 800x600 */
+	 case 0x47:
+	 case 0x63:
+	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
+	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
+	    break;
+	 case 0x52:   /* 512x384 */
+	 case 0x58:
+	 case 0x5c:
+	 case 0x38:   /* 1024x768 */
+	 case 0x4a:
+	 case 0x64:
+	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
+	    break;
+	 }
+         if(pSiS->VBFlags2 & VB2_301) {
+            if(yindex301 >= 0) {
+	       for(i=0, j=0x35; i<=3; i++, j++) {
+	          outSISIDXREG(SISPART2,j,(SiSTVFilter301[yindex301].filter[pSiS->sistvyfilter-2][i]));
+	       }
+	    }
+         } else {
+            if(yindex301B >= 0) {
+	       for(i=0, j=0x35; i<=3; i++, j++) {
+	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
+	       }
+	       for(i=4, j=0x48; i<=6; i++, j++) {
+	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
+	       }
+	    }
+         }
+         orSISIDXREG(SISPART2,0x30,0x20);
+      }
+   }
+}
+
+int SiS_GetSISTVyfilter(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)
+      return (int)pSiSEnt->sistvyfilter;
+   else
+#endif
+      return (int)pSiS->sistvyfilter;
+}
+
+void SiS_SetSIS6326TVantiflicker(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UChar tmp;
+
+   pSiS->sistvantiflicker = val;
+
+   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   tmp = SiS6326GetTVReg(pScrn,0x00);
+   if(!(tmp & 0x04)) return;
+
+   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
+   if(val >= 0 && val <= 4) {
+      tmp &= 0x1f;
+      tmp |= (val << 5);
+      SiS6326SetTVReg(pScrn,0x00,tmp);
+   }
+}
+
+int SiS_GetSIS6326TVantiflicker(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UChar tmp;
+
+   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
+      return (int)pSiS->sistvantiflicker;
+   }
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   tmp = SiS6326GetTVReg(pScrn,0x00);
+   if(!(tmp & 0x04)) {
+      return (int)pSiS->sistvantiflicker;
+   } else {
+      return (int)((tmp >> 5) & 0x07);
+   }
+}
+
+void SiS_SetSIS6326TVenableyfilter(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UChar tmp;
+
+   if(val) val = 1;
+   pSiS->sis6326enableyfilter = val;
+
+   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   tmp = SiS6326GetTVReg(pScrn,0x00);
+   if(!(tmp & 0x04)) return;
+
+   tmp = SiS6326GetTVReg(pScrn,0x43);
+   tmp &= ~0x10;
+   tmp |= ((val & 0x01) << 4);
+   SiS6326SetTVReg(pScrn,0x43,tmp);
+}
+
+int SiS_GetSIS6326TVenableyfilter(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UChar tmp;
+
+   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
+      return (int)pSiS->sis6326enableyfilter;
+   }
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   tmp = SiS6326GetTVReg(pScrn,0x00);
+   if(!(tmp & 0x04)) {
+      return (int)pSiS->sis6326enableyfilter;
+   } else {
+      tmp = SiS6326GetTVReg(pScrn,0x43);
+      return (int)((tmp >> 4) & 0x01);
+   }
+}
+
+void SiS_SetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UChar tmp;
+
+   if(val) val = 1;
+   pSiS->sis6326yfilterstrong = val;
+
+   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   tmp = SiS6326GetTVReg(pScrn,0x00);
+   if(!(tmp & 0x04)) return;
+
+   tmp = SiS6326GetTVReg(pScrn,0x43);
+   if(tmp & 0x10) {
+      tmp &= ~0x40;
+      tmp |= ((val & 0x01) << 6);
+      SiS6326SetTVReg(pScrn,0x43,tmp);
+   }
+}
+
+int SiS_GetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   UChar tmp;
+
+   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
+      return (int)pSiS->sis6326yfilterstrong;
+   }
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   tmp = SiS6326GetTVReg(pScrn,0x00);
+   if(!(tmp & 0x04)) {
+      return (int)pSiS->sis6326yfilterstrong;
+   } else {
+      tmp = SiS6326GetTVReg(pScrn,0x43);
+      if(!(tmp & 0x10)) {
+         return (int)pSiS->sis6326yfilterstrong;
+      } else {
+         return (int)((tmp >> 6) & 0x01);
+      }
+   }
+}
+
+void SiS_SetTVxposoffset(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   pSiS->tvxpos = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->tvxpos = val;
+#endif
+
+   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+
+      if(pSiS->VBFlags & CRT2_TV) {
+
+         if(pSiS->VBFlags2 & VB2_CHRONTEL) {
+
+	    int x = pSiS->tvx;
+#ifdef SISDUALHEAD
+	    if(pSiSEnt && pSiS->DualHeadMode) x = pSiSEnt->tvx;
+#endif
+	    switch(pSiS->ChrontelType) {
+	    case CHRONTEL_700x:
+	       if((val >= -32) && (val <= 32)) {
+		   x += val;
+		   if(x < 0) x = 0;
+		   SiS_SetCH700x(pSiS->SiS_Pr, 0x0a, (x & 0xff));
+		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x08, ((x & 0x0100) >> 7), 0xFD);
+	       }
+	       break;
+	    case CHRONTEL_701x:
+	       /* Not supported by hardware */
+	       break;
+	    }
+
+	 } else if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
+
+	    if((val >= -32) && (val <= 32)) {
+
+	        UChar p2_1f,p2_20,p2_2b,p2_42,p2_43;
+		UShort temp;
+		int mult;
+
+		p2_1f = pSiS->p2_1f;
+		p2_20 = pSiS->p2_20;
+		p2_2b = pSiS->p2_2b;
+		p2_42 = pSiS->p2_42;
+		p2_43 = pSiS->p2_43;
+#ifdef SISDUALHEAD
+	        if(pSiSEnt && pSiS->DualHeadMode) {
+		   p2_1f = pSiSEnt->p2_1f;
+		   p2_20 = pSiSEnt->p2_20;
+		   p2_2b = pSiSEnt->p2_2b;
+		   p2_42 = pSiSEnt->p2_42;
+		   p2_43 = pSiSEnt->p2_43;
+		}
+#endif
+		mult = 2;
+		if(pSiS->VBFlags & TV_YPBPR) {
+		   if(pSiS->VBFlags & (TV_YPBPR1080I | TV_YPBPR750P)) {
+		      unsigned char CR34;
+		      mult = 4;
+		      inSISIDXREG(SISCR, 0x34, CR34);
+		      if(pSiS->VGAEngine == SIS_315_VGA && (pSiS->VBFlags & TV_YPBPR1080I)) {
+		         if(CR34 == 0x1d || CR34 == 0x1e || CR34 == 0x1f) {
+		            if(val < -26) val = -26;
+		         }
+		      } else if(pSiS->VBFlags & TV_YPBPR750P) {
+#ifndef OLD1280720P
+			 if(CR34 == 0x79 || CR34 == 0x75 || CR34 == 0x78) {
+			    if(val < -17) val = -17;
+			 }
+#endif
+		      }
+		   }
+		}
+
+		temp = p2_1f | ((p2_20 & 0xf0) << 4);
+		temp += (val * mult);
+		p2_1f = temp & 0xff;
+		p2_20 = (temp & 0xf00) >> 4;
+		p2_2b = ((p2_2b & 0x0f) + (val * mult)) & 0x0f;
+		temp = p2_43 | ((p2_42 & 0xf0) << 4);
+		temp += (val * mult);
+		p2_43 = temp & 0xff;
+		p2_42 = (temp & 0xf00) >> 4;
+		SISWaitRetraceCRT2(pScrn);
+	        outSISIDXREG(SISPART2,0x1f,p2_1f);
+		setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
+		setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
+		setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
+		outSISIDXREG(SISPART2,0x43,p2_43);
+	     }
+	 }
+      }
+
+   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
+
+      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
+
+         UChar tmp;
+	 UShort temp1, temp2, temp3;
+
+         tmp = SiS6326GetTVReg(pScrn,0x00);
+         if(tmp & 0x04) {
+
+	    temp1 = pSiS->tvx1;
+            temp2 = pSiS->tvx2;
+            temp3 = pSiS->tvx3;
+            if((val >= -16) && (val <= 16)) {
+	       if(val > 0) {
+	          temp1 += (val * 4);
+	          temp2 += (val * 4);
+	          while((temp1 > 0x0fff) || (temp2 > 0x0fff)) {
+	             temp1 -= 4;
+		     temp2 -= 4;
+	          }
+	       } else {
+	          val = -val;
+	          temp3 += (val * 4);
+	          while(temp3 > 0x03ff) {
+	     	     temp3 -= 4;
+	          }
+	       }
+            }
+            SiS6326SetTVReg(pScrn,0x3a,(temp1 & 0xff));
+            tmp = SiS6326GetTVReg(pScrn,0x3c);
+            tmp &= 0xf0;
+            tmp |= ((temp1 & 0x0f00) >> 8);
+            SiS6326SetTVReg(pScrn,0x3c,tmp);
+            SiS6326SetTVReg(pScrn,0x26,(temp2 & 0xff));
+            tmp = SiS6326GetTVReg(pScrn,0x27);
+            tmp &= 0x0f;
+            tmp |= ((temp2 & 0x0f00) >> 4);
+            SiS6326SetTVReg(pScrn,0x27,tmp);
+            SiS6326SetTVReg(pScrn,0x12,(temp3 & 0xff));
+            tmp = SiS6326GetTVReg(pScrn,0x13);
+            tmp &= ~0xC0;
+            tmp |= ((temp3 & 0x0300) >> 2);
+            SiS6326SetTVReg(pScrn,0x13,tmp);
+	 }
+      }
+   }
+}
+
+int SiS_GetTVxposoffset(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)
+        return (int)pSiSEnt->tvxpos;
+   else
+#endif
+        return (int)pSiS->tvxpos;
+}
+
+void SiS_SetTVyposoffset(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   pSiS->tvypos = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->tvypos = val;
+#endif
+
+   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+
+      if(pSiS->VBFlags & CRT2_TV) {
+
+         if(pSiS->VBFlags2 & VB2_CHRONTEL) {
+
+	    int y = pSiS->tvy;
+#ifdef SISDUALHEAD
+	    if(pSiSEnt && pSiS->DualHeadMode) y = pSiSEnt->tvy;
+#endif
+	    switch(pSiS->ChrontelType) {
+	    case CHRONTEL_700x:
+	       if((val >= -32) && (val <= 32)) {
+		   y -= val;
+		   if(y < 0) y = 0;
+		   SiS_SetCH700x(pSiS->SiS_Pr, 0x0b, (y & 0xff));
+		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x08, ((y & 0x0100) >> 8), 0xFE);
+	       }
+	       break;
+	    case CHRONTEL_701x:
+	       /* Not supported by hardware */
+	       break;
+	    }
+
+	 } else if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
+
+	    if((val >= -32) && (val <= 32)) {
+		char p2_01, p2_02;
+
+		if( (pSiS->VBFlags & TV_HIVISION) ||
+		    ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & (TV_YPBPR1080I|TV_YPBPR750P))) ) {
+		   val *= 2;
+		} else {
+		   val /= 2;  /* 4 */
+		}
+
+		p2_01 = pSiS->p2_01;
+		p2_02 = pSiS->p2_02;
+#ifdef SISDUALHEAD
+	        if(pSiSEnt && pSiS->DualHeadMode) {
+		   p2_01 = pSiSEnt->p2_01;
+		   p2_02 = pSiSEnt->p2_02;
+		}
+#endif
+		p2_01 += val; /* val * 2 */
+		p2_02 += val; /* val * 2 */
+		if(!(pSiS->VBFlags & (TV_YPBPR | TV_HIVISION))) {
+		   while((p2_01 <= 0) || (p2_02 <= 0)) {
+		      p2_01 += 2;
+		      p2_02 += 2;
+		   }
+		} else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR1080I)) {
+		   while(p2_01 <= 8) {
+		      p2_01 += 2;
+		      p2_02 += 2;
+		   }
+		} else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR750P)) {
+		   while(p2_01 <= 10) {
+		      p2_01 += 2;
+		      p2_02 += 2;
+		   }
+		}
+
+		SISWaitRetraceCRT2(pScrn);
+		outSISIDXREG(SISPART2,0x01,p2_01);
+		outSISIDXREG(SISPART2,0x02,p2_02);
+	     }
+	 }
+
+      }
+
+   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
+
+      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
+
+         UChar tmp;
+	 int temp1, limit;
+
+         tmp = SiS6326GetTVReg(pScrn,0x00);
+         if(tmp & 0x04) {
+
+	    if((val >= -16) && (val <= 16)) {
+	      temp1 = (UShort)pSiS->tvy1;
+	      limit = (pSiS->SiS6326Flags & SIS6326_TVPAL) ? 625 : 525;
+	      if(val > 0) {
+                temp1 += (val * 4);
+	        if(temp1 > limit) temp1 -= limit;
+	      } else {
+	        val = -val;
+	        temp1 -= (val * 2);
+	        if(temp1 <= 0) temp1 += (limit -1);
+	      }
+	      SiS6326SetTVReg(pScrn,0x11,(temp1 & 0xff));
+	      tmp = SiS6326GetTVReg(pScrn,0x13);
+	      tmp &= ~0x30;
+	      tmp |= ((temp1 & 0x300) >> 4);
+	      SiS6326SetTVReg(pScrn,0x13,tmp);
+	      if(temp1 == 1)                                 tmp = 0x10;
+	      else {
+	       if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
+	         if((temp1 <= 3) || (temp1 >= (limit - 2)))  tmp = 0x08;
+	         else if(temp1 < 22)		 	     tmp = 0x02;
+	         else 					     tmp = 0x04;
+	       } else {
+	         if((temp1 <= 5) || (temp1 >= (limit - 4)))  tmp = 0x08;
+	         else if(temp1 < 19)			     tmp = 0x02;
+	         else 					     tmp = 0x04;
+	       }
+	     }
+	     SiS6326SetTVReg(pScrn,0x21,tmp);
+           }
+	 }
+      }
+   }
+}
+
+int SiS_GetTVyposoffset(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)
+        return (int)pSiSEnt->tvypos;
+   else
+#endif
+        return (int)pSiS->tvypos;
+}
+
+void SiS_SetTVxscale(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   pSiS->tvxscale = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->tvxscale = val;
+#endif
+
+   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+
+      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags2 & VB2_SISBRIDGE)) {
+
+	 if((val >= -16) && (val <= 16)) {
+
+	    UChar p2_44,p2_45,p2_46;
+	    int scalingfactor, mult;
+
+	    p2_44 = pSiS->p2_44;
+	    p2_45 = pSiS->p2_45 & 0x3f;
+	    p2_46 = pSiS->p2_46 & 0x07;
+#ifdef SISDUALHEAD
+	    if(pSiSEnt && pSiS->DualHeadMode) {
+	       p2_44 = pSiSEnt->p2_44;
+	       p2_45 = pSiSEnt->p2_45 & 0x3f;
+	       p2_46 = pSiSEnt->p2_46 & 0x07;
+	    }
+#endif
+	    scalingfactor = (p2_46 << 13) | ((p2_45 & 0x1f) << 8) | p2_44;
+
+	    mult = 64;
+	    if(pSiS->VBFlags & TV_YPBPR) {
+	       if(pSiS->VBFlags & TV_YPBPR1080I) {
+	          mult = 190;
+	       } else if(pSiS->VBFlags & TV_YPBPR750P) {
+	          mult = 360;
+	       }
+	    } else if(pSiS->VBFlags & TV_HIVISION) {
+	       mult = 190;
+	    }
+
+	    if(val < 0) {
+	       p2_45 &= 0xdf;
+	       scalingfactor += ((-val) * mult);
+	       if(scalingfactor > 0xffff) scalingfactor = 0xffff;
+	    } else if(val > 0) {
+	       p2_45 &= 0xdf;
+	       scalingfactor -= (val * mult);
+	       if(scalingfactor < 1) scalingfactor = 1;
+	    }
+
+	    p2_44 = scalingfactor & 0xff;
+	    p2_45 &= 0xe0;
+	    p2_45 |= ((scalingfactor >> 8) & 0x1f);
+	    p2_46 = ((scalingfactor >> 13) & 0x07);
+
+	    SISWaitRetraceCRT2(pScrn);
+	    outSISIDXREG(SISPART2,0x44,p2_44);
+	    setSISIDXREG(SISPART2,0x45,0xC0,p2_45);
+	    if(!(pSiS->VBFlags2 & VB2_301)) {
+	       setSISIDXREG(SISPART2,0x46,0xF8,p2_46);
+	    }
+
+	 }
+
+      }
+
+   }
+}
+
+int SiS_GetTVxscale(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)
+        return (int)pSiSEnt->tvxscale;
+   else
+#endif
+        return (int)pSiS->tvxscale;
+}
+
+void SiS_SetTVyscale(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   if(val < -4) val = -4;
+   if(val > 3)  val = 3;
+
+   pSiS->tvyscale = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->tvyscale = val;
+#endif
+
+   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
+
+      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags2 & VB2_SISBRIDGE)) {
+
+	 int srindex = -1, newvde, i = 0, j, vlimit, temp, vdediv;
+	 int hdclk = 0;
+	 UChar p3d4_34;
+	 Bool found = FALSE;
+	 Bool usentsc = FALSE;
+	 Bool is750p = FALSE;
+	 Bool is1080i = FALSE;
+	 Bool skipmoveup = FALSE;
+
+	 SiS_UnLockCRT2(pSiS->SiS_Pr);
+
+	 if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525P)) {
+	    vlimit = 525 - 7;
+	    vdediv = 1;
+	    usentsc = TRUE;
+	 } else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR625P)) {
+	    vlimit = 625 - 7;
+	    vdediv = 1;
+	 } else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR750P)) {
+	    vlimit = 750 - 7;
+	    vdediv = 1;
+	    is750p = TRUE;
+	 } else if(((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR1080I)) ||
+	           (pSiS->VBFlags & TV_HIVISION)) {
+	    vlimit = (1125 - 7) / 2;
+	    vdediv = 2;
+	    is1080i = TRUE;
+	 } else {
+	    if( ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) ||
+	        ((!(pSiS->VBFlags & TV_YPBPR)) && (pSiS->VBFlags & (TV_NTSC | TV_PALM))) ) {
+	       usentsc = TRUE;
+	    }
+	    vlimit = usentsc ? 259 : 309;
+	    vdediv = 2;
+	 }
+
+	 inSISIDXREG(SISCR,0x34,p3d4_34);
+
+	 switch((p3d4_34 & 0x7f)) {
+	 case 0x50:   /* 320x240 */
+	 case 0x56:
+	 case 0x53:
+	    hdclk = 1;
+	    /* fall through */
+	 case 0x2e:   /* 640x480 */
+	 case 0x44:
+	 case 0x62:
+	    if(is1080i) {
+	       srindex = 98;
+	    } else if(is750p) {
+	       srindex = 42;
+	    } else {
+	       srindex  = usentsc ? 0 : 21;
+	    }
+	    break;
+	 case 0x31:   /* 720x480 */
+	 case 0x33:
+	 case 0x35:
+	    if(is1080i) {
+	       /* n/a */
+	    } else if(is750p) {
+	       srindex = 49;
+	    } else {
+	       srindex = usentsc ? 7 : 21;
+	    }
+	    break;
+	 case 0x32:   /* 720x576 */
+	 case 0x34:
+	 case 0x36:
+	 case 0x5f:   /* 768x576 */
+	 case 0x60:
+	 case 0x61:
+	    if(is1080i) {
+	       /* n/a */
+	    } else if(is750p) {
+	       srindex = 56;
+	    } else {
+	       srindex  = usentsc ? 147 : 28;
+	    }
+	    break;
+	 case 0x70:   /* 800x480 */
+	 case 0x7a:
+	 case 0x76:
+	    if(is1080i) {
+	       srindex = 105;
+	    } else if(is750p) {
+	       srindex = 63;
+	    } else {
+	       srindex = usentsc ? 175 : 21;
+	    }
+	    break;
+	 case 0x39:   /* 848x480 */
+	 case 0x3b:
+	 case 0x3e:
+	 case 0x3f:   /* 856x480 */
+	 case 0x42:
+	 case 0x45:
+	    if(is1080i) {
+	       srindex = 105;
+	    } else if(is750p) {
+	       srindex = 63;
+	    } else {
+	       srindex = usentsc ? 217 : 210;
+	    }
+	    break;
+	 case 0x51:   /* 400x300 - hdclk mode */
+	 case 0x57:
+	 case 0x54:
+	    hdclk = 1;
+	    /* fall through */
+	 case 0x30:   /* 800x600 */
+	 case 0x47:
+	 case 0x63:
+	    if(is1080i) {
+	       srindex = 112;
+	    } else if(is750p) {
+	       srindex = 70;
+	    } else {
+	       srindex = usentsc ? 14 : 35;
+	    }
+	    break;
+	 case 0x1d:	/* 960x540 */
+	 case 0x1e:
+	 case 0x1f:
+	    if(is1080i) {
+	       srindex = 196;
+	       skipmoveup = TRUE;
+	    }
+	    break;
+	 case 0x20:	/* 960x600 */
+	 case 0x21:
+	 case 0x22:
+	    if(pSiS->VGAEngine == SIS_315_VGA && is1080i) {
+	       srindex = 203;
+	    }
+	    break;
+	 case 0x71:	/* 1024x576 */
+	 case 0x74:
+	 case 0x77:
+	    if(is1080i) {
+	       srindex = 119;
+	    } else if(is750p) {
+	       srindex = 77;
+	    } else {
+	       srindex  = usentsc ? 182 : 189;
+	    }
+	    break;
+	 case 0x52:	/* 512x384 */
+	 case 0x58:
+	 case 0x5c:
+	    hdclk = 1;
+	    /* fall through */
+	 case 0x38:	/* 1024x768 */
+	 case 0x4a:
+	 case 0x64:
+	    if(is1080i) {
+	       srindex = 126;
+	    } else if(is750p) {
+	       srindex = 84;
+	    } else if(!usentsc) {
+	       srindex = 154;
+	    } else if(vdediv == 1) {
+	       if(!hdclk) srindex = 168;
+	    } else {
+	       if(!hdclk) srindex = 161;
+	    }
+	    break;
+	 case 0x79:	/* 1280x720 */
+	 case 0x75:
+	 case 0x78:
+	    if(is1080i) {
+	       srindex = 133;
+	    } else if(is750p) {
+	       srindex = 91;
+	    }
+	    break;
+	 case 0x3a:	/* 1280x1024 */
+	 case 0x4d:
+	 case 0x65:
+	    if(is1080i) {
+	       srindex = 140;
+	    }
+	    break;
+	 }
+
+	 if(srindex < 0) return;
+
+	 if(pSiS->tvyscale != 0) {
+	    for(j = 0; j <= 1; j++) {
+	       for(i = 0; i <= 6; i++) {
+		  if(SiSTVVScale[srindex+i].sindex == pSiS->tvyscale) {
+		     found = TRUE;
+		     break;
+		  }
+	       }
+	       if(found) break;
+	       if(pSiS->tvyscale > 0) pSiS->tvyscale--;
+	       else pSiS->tvyscale++;
+	    }
+	 }
+
+#ifdef SISDUALHEAD
+	 if(pSiSEnt) pSiSEnt->tvyscale = pSiS->tvyscale;
+#endif
+
+	 if(pSiS->tvyscale == 0) {
+	    UChar p2_0a = pSiS->p2_0a;
+	    UChar p2_2f = pSiS->p2_2f;
+	    UChar p2_30 = pSiS->p2_30;
+	    UChar p2_46 = pSiS->p2_46;
+	    UChar p2_47 = pSiS->p2_47;
+	    UChar p1scaling[9], p4scaling[9];
+	    UChar *p2scaling;
+
+	    for(i = 0; i < 9; i++) {
+	        p1scaling[i] = pSiS->scalingp1[i];
+		p4scaling[i] = pSiS->scalingp4[i];
+	    }
+	    p2scaling = &pSiS->scalingp2[0];
+
+#ifdef SISDUALHEAD
+	    if(pSiSEnt && pSiS->DualHeadMode) {
+	       p2_0a = pSiSEnt->p2_0a;
+	       p2_2f = pSiSEnt->p2_2f;
+	       p2_30 = pSiSEnt->p2_30;
+	       p2_46 = pSiSEnt->p2_46;
+	       p2_47 = pSiSEnt->p2_47;
+	       for(i = 0; i < 9; i++) {
+		  p1scaling[i] = pSiSEnt->scalingp1[i];
+		  p4scaling[i] = pSiSEnt->scalingp4[i];
+	       }
+	       p2scaling = &pSiSEnt->scalingp2[0];
+	    }
+#endif
+            SISWaitRetraceCRT2(pScrn);
+	    if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
+	       for(i = 0; i < 64; i++) {
+	          outSISIDXREG(SISPART2,(0xc0 + i),p2scaling[i]);
+	       }
+	    }
+	    for(i = 0; i < 9; i++) {
+	       outSISIDXREG(SISPART1,SiSScalingP1Regs[i],p1scaling[i]);
+	    }
+	    for(i = 0; i < 9; i++) {
+	       outSISIDXREG(SISPART4,SiSScalingP4Regs[i],p4scaling[i]);
+	    }
+
+	    setSISIDXREG(SISPART2,0x0a,0x7f,(p2_0a & 0x80));
+	    outSISIDXREG(SISPART2,0x2f,p2_2f);
+	    setSISIDXREG(SISPART2,0x30,0x3f,(p2_30 & 0xc0));
+	    if(!(pSiS->VBFlags2 & VB2_301)) {
+	       setSISIDXREG(SISPART2,0x46,0x9f,(p2_46 & 0x60));
+	       outSISIDXREG(SISPART2,0x47,p2_47);
+	    }
+
+	 } else {
+
+	    int realvde, myypos, watchdog = 32;
+	    unsigned short temp1, temp2, vgahde, vgaht, vgavt;
+	    int p1div = 1;
+	    ULong calctemp;
+
+	    srindex += i;
+	    newvde = SiSTVVScale[srindex].ScaleVDE;
+	    realvde = SiSTVVScale[srindex].RealVDE;
+
+	    if(vdediv == 1) p1div = 2;
+
+	    if(!skipmoveup) {
+	       do {
+	          inSISIDXREG(SISPART2,0x01,temp);
+	          temp = vlimit - ((temp & 0x7f) / p1div);
+	          if((temp - (((newvde / vdediv) - 2) + 9)) > 0) break;
+	          myypos = pSiS->tvypos - 1;
+#ifdef SISDUALHEAD
+	          if(pSiSEnt && pSiS->DualHeadMode) myypos = pSiSEnt->tvypos - 1;
+#endif
+	          SiS_SetTVyposoffset(pScrn, myypos);
+	       } while(watchdog--);
+	    }
+
+	    SISWaitRetraceCRT2(pScrn);
+
+	    if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
+	       SiS_CalcXTapScaler(pSiS->SiS_Pr, realvde, newvde, 4, FALSE);
+	    }
+
+	    if(!(pSiS->VBFlags2 & VB2_301)) {
+	       temp = (newvde / vdediv) - 3;
+	       setSISIDXREG(SISPART2,0x46,0x9f,((temp & 0x0300) >> 3));
+	       outSISIDXREG(SISPART2,0x47,(temp & 0xff));
+	    }
+
+	    inSISIDXREG(SISPART1,0x0a,temp1);
+	    inSISIDXREG(SISPART1,0x0c,temp2);
+	    vgahde = ((temp2 & 0xf0) << 4) | temp1;
+	    if(pSiS->VGAEngine == SIS_300_VGA) {
+	       vgahde -= 12;
+	    } else {
+	       vgahde -= 16;
+	       if(hdclk) vgahde <<= 1;
+	    }
+
+	    vgaht = SiSTVVScale[srindex].reg[0];
+	    temp1 = vgaht;
+	    if((pSiS->VGAEngine == SIS_315_VGA) && hdclk) temp1 >>= 1;
+	    temp1--;
+	    outSISIDXREG(SISPART1,0x08,(temp1 & 0xff));
+	    setSISIDXREG(SISPART1,0x09,0x0f,((temp1 >> 4) & 0xf0));
+
+	    temp2 = (vgaht - vgahde) >> 2;
+	    if(pSiS->VGAEngine == SIS_300_VGA) {
+	       temp1 = vgahde + 12 + temp2;
+	       temp2 = temp1 + (temp2 << 1);
+	    } else {
+	       temp1 = vgahde;
+	       if(hdclk) {
+		  temp1 >>= 1;
+		  temp2 >>= 1;
+	       }
+	       temp2 >>= 1;
+	       temp1 = temp1 + 16 + temp2;
+	       temp2 = temp1 + temp2;
+	    }
+	    outSISIDXREG(SISPART1,0x0b,(temp1 & 0xff));
+	    setSISIDXREG(SISPART1,0x0c,0xf0,((temp1 >> 8) & 0x0f));
+	    outSISIDXREG(SISPART1,0x0d,(temp2 & 0xff));
+
+	    vgavt = SiSTVVScale[srindex].reg[1];
+	    temp1 = vgavt - 1;
+	    if(pSiS->VGAEngine == SIS_315_VGA) temp1--;
+	    outSISIDXREG(SISPART1,0x0e,(temp1 & 0xff));
+	    setSISIDXREG(SISPART1,0x12,0xf8,((temp1 >> 8 ) & 0x07));
+	    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->ChipType >= SIS_661)) {
+	       temp1 = (vgavt + SiSTVVScale[srindex].RealVDE) >> 1;
+	       temp2 = ((vgavt - SiSTVVScale[srindex].RealVDE) >> 4) + temp1 + 1;
+	    } else {
+	       temp1 = (vgavt - SiSTVVScale[srindex].RealVDE) >> 2;
+	       temp2 = (temp1 < 4) ? 4 : temp1;
+	       temp1 += SiSTVVScale[srindex].RealVDE;
+	       temp2 = (temp2 >> 2) + temp1 + 1;
+	    }
+	    outSISIDXREG(SISPART1,0x10,(temp1 & 0xff));
+	    setSISIDXREG(SISPART1,0x11,0x8f,((temp1 >> 4) & 0x70));
+	    setSISIDXREG(SISPART1,0x11,0xf0,(temp2 & 0x0f));
+
+	    setSISIDXREG(SISPART2,0x0a,0x7f,((SiSTVVScale[srindex].reg[2] >> 8) & 0x80));
+	    outSISIDXREG(SISPART2,0x2f,((newvde / vdediv) - 2));
+	    setSISIDXREG(SISPART2,0x30,0x3f,((((newvde / vdediv) - 2) >> 2) & 0xc0));
+
+	    outSISIDXREG(SISPART4,0x13,(SiSTVVScale[srindex].reg[2] & 0xff));
+	    outSISIDXREG(SISPART4,0x14,(SiSTVVScale[srindex].reg[3] & 0xff));
+	    setSISIDXREG(SISPART4,0x15,0x7f,((SiSTVVScale[srindex].reg[3] >> 1) & 0x80));
+
+	    temp1 = vgaht - 1;
+	    outSISIDXREG(SISPART4,0x16,(temp1 & 0xff));
+	    setSISIDXREG(SISPART4,0x15,0x87,((temp1 >> 5) & 0x78));
+
+	    temp1 = vgavt - 1;
+	    outSISIDXREG(SISPART4,0x17,(temp1 & 0xff));
+	    setSISIDXREG(SISPART4,0x15,0xf8,((temp1 >> 8) & 0x07));
+
+	    outSISIDXREG(SISPART4,0x18,0x00);
+	    setSISIDXREG(SISPART4,0x19,0xf0,0x00);
+
+	    inSISIDXREG(SISPART4,0x0e,temp1);
+	    if(is1080i) {
+	       if(!(temp1 & 0xe0)) newvde >>= 1;
+	    }
+
+	    temp = 0x40;
+	    if(realvde <= newvde) temp = 0;
+	    else realvde -= newvde;
+
+	    calctemp = (realvde * 256 * 1024) / newvde;
+	    if((realvde * 256 * 1024) % newvde) calctemp++;
+	    outSISIDXREG(SISPART4,0x1b,(calctemp & 0xff));
+	    outSISIDXREG(SISPART4,0x1a,((calctemp >> 8) & 0xff));
+	    setSISIDXREG(SISPART4,0x19,0x8f,(((calctemp >> 12) & 0x70) | temp));
+	 }
+
+      }
+
+   }
+}
+
+int SiS_GetTVyscale(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)
+        return (int)pSiSEnt->tvyscale;
+   else
+#endif
+        return (int)pSiS->tvyscale;
+}
+
+void SiS_SetSISCRT1SaturationGain(ScrnInfoPtr pScrn, int val)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+   pSiS->siscrt1satgain = val;
+#ifdef SISDUALHEAD
+   if(pSiSEnt) pSiSEnt->siscrt1satgain = val;
+#endif
+
+   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_CRT1SATGAIN)) return;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+
+   if((val >= 0) && (val <= 7)) {
+      setSISIDXREG(SISCR,0x53,0xE3, (val << 2));
+   }
+}
+
+int SiS_GetSISCRT1SaturationGain(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   int result = pSiS->siscrt1satgain;
+   UChar temp;
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+
+   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->siscrt1satgain;
+#endif
+
+   if(!(pSiS->SiS_SD3_Flags & SiS_SD3_CRT1SATGAIN)) return result;
+
+#ifdef UNLOCK_ALWAYS
+   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
+#endif
+   inSISIDXREG(SISCR, 0x53, temp);
+   return (int)((temp >> 2) & 0x07);
+}
+
+void
+SiSPostSetModeTVParms(ScrnInfoPtr pScrn)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SISDUALHEAD
+   SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+    /*  Apply TV settings given by options
+           Do this even in DualHeadMode:
+	   - if this is called by SetModeCRT1, CRT2 mode has been reset by SetModeCRT1
+	   - if this is called by SetModeCRT2, CRT2 mode has changed (duh!)
+	   -> Hence, in both cases, the settings must be re-applied.
+     */
+
+    if(pSiS->VBFlags & CRT2_TV) {
+       int val;
+       if(pSiS->VBFlags2 & VB2_CHRONTEL) {
+	  int mychtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
+	  int mychtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
+	  int mychtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
+	  int mychtvchromabandwidth = pSiS->chtvchromabandwidth;
+	  int mychtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
+	  int mychtvcvbscolor = pSiS->chtvcvbscolor;
+	  int mychtvtextenhance = pSiS->chtvtextenhance;
+	  int mychtvcontrast = pSiS->chtvcontrast;
+	  int mytvxpos = pSiS->tvxpos;
+	  int mytvypos = pSiS->tvypos;
+#ifdef SISDUALHEAD
+	  if(pSiSEnt && pSiS->DualHeadMode) {
+	     mychtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
+	     mychtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
+	     mychtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
+	     mychtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
+	     mychtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
+	     mychtvcvbscolor = pSiSEnt->chtvcvbscolor;
+	     mychtvtextenhance = pSiSEnt->chtvtextenhance;
+	     mychtvcontrast = pSiSEnt->chtvcontrast;
+	     mytvxpos = pSiSEnt->tvxpos;
+	     mytvypos = pSiSEnt->tvypos;
+	  }
+#endif
+	  if((val = mychtvlumabandwidthcvbs) != -1) {
+	     SiS_SetCHTVlumabandwidthcvbs(pScrn, val);
+	  }
+	  if((val = mychtvlumabandwidthsvideo) != -1) {
+	     SiS_SetCHTVlumabandwidthsvideo(pScrn, val);
+	  }
+	  if((val = mychtvlumaflickerfilter) != -1) {
+	     SiS_SetCHTVlumaflickerfilter(pScrn, val);
+	  }
+	  if((val = mychtvchromabandwidth) != -1) {
+	     SiS_SetCHTVchromabandwidth(pScrn, val);
+	  }
+	  if((val = mychtvchromaflickerfilter) != -1) {
+	     SiS_SetCHTVchromaflickerfilter(pScrn, val);
+	  }
+	  if((val = mychtvcvbscolor) != -1) {
+	     SiS_SetCHTVcvbscolor(pScrn, val);
+	  }
+	  if((val = mychtvtextenhance) != -1) {
+	     SiS_SetCHTVtextenhance(pScrn, val);
+	  }
+	  if((val = mychtvcontrast) != -1) {
+	     SiS_SetCHTVcontrast(pScrn, val);
+	  }
+	  /* Backup default TV position registers */
+	  switch(pSiS->ChrontelType) {
+	  case CHRONTEL_700x:
+	     pSiS->tvx = SiS_GetCH700x(pSiS->SiS_Pr, 0x0a);
+	     pSiS->tvx |= (((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
+	     pSiS->tvy = SiS_GetCH700x(pSiS->SiS_Pr, 0x0b);
+	     pSiS->tvy |= ((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x01) << 8);
+#ifdef SISDUALHEAD
+	     if(pSiSEnt) {
+		pSiSEnt->tvx = pSiS->tvx;
+		pSiSEnt->tvy = pSiS->tvy;
+	     }
+#endif
+	     break;
+	  case CHRONTEL_701x:
+	     /* Not supported by hardware */
+	     break;
+	  }
+	  if((val = mytvxpos) != 0) {
+	     SiS_SetTVxposoffset(pScrn, val);
+	  }
+	  if((val = mytvypos) != 0) {
+	     SiS_SetTVyposoffset(pScrn, val);
+	  }
+       }
+       if(pSiS->VBFlags2 & VB2_301) {
+          int mysistvedgeenhance = pSiS->sistvedgeenhance;
+#ifdef SISDUALHEAD
+          if(pSiSEnt && pSiS->DualHeadMode) {
+	     mysistvedgeenhance = pSiSEnt->sistvedgeenhance;
+	  }
+#endif
+          if((val = mysistvedgeenhance) != -1) {
+	     SiS_SetSISTVedgeenhance(pScrn, val);
+	  }
+       }
+       if(pSiS->VBFlags2 & VB2_SISBRIDGE) {
+          int mysistvantiflicker = pSiS->sistvantiflicker;
+	  int mysistvsaturation = pSiS->sistvsaturation;
+	  int mysistvcolcalibf = pSiS->sistvcolcalibf;
+	  int mysistvcolcalibc = pSiS->sistvcolcalibc;
+	  int mysistvcfilter = pSiS->sistvcfilter;
+	  int mysistvyfilter = pSiS->sistvyfilter;
+	  int mytvxpos = pSiS->tvxpos;
+	  int mytvypos = pSiS->tvypos;
+	  int mytvxscale = pSiS->tvxscale;
+	  int mytvyscale = pSiS->tvyscale;
+	  int i;
+	  ULong cbase;
+	  UChar ctemp;
+#ifdef SISDUALHEAD
+          if(pSiSEnt && pSiS->DualHeadMode) {
+	     mysistvantiflicker = pSiSEnt->sistvantiflicker;
+	     mysistvsaturation = pSiSEnt->sistvsaturation;
+	     mysistvcolcalibf = pSiSEnt->sistvcolcalibf;
+	     mysistvcolcalibc = pSiSEnt->sistvcolcalibc;
+	     mysistvcfilter = pSiSEnt->sistvcfilter;
+	     mysistvyfilter = pSiSEnt->sistvyfilter;
+	     mytvxpos = pSiSEnt->tvxpos;
+	     mytvypos = pSiSEnt->tvypos;
+	     mytvxscale = pSiSEnt->tvxscale;
+	     mytvyscale = pSiSEnt->tvyscale;
+	  }
+#endif
+          /* Backup default TV position, scale and colcalib registers */
+	  inSISIDXREG(SISPART2,0x1f,pSiS->p2_1f);
+	  inSISIDXREG(SISPART2,0x20,pSiS->p2_20);
+	  inSISIDXREG(SISPART2,0x2b,pSiS->p2_2b);
+	  inSISIDXREG(SISPART2,0x42,pSiS->p2_42);
+	  inSISIDXREG(SISPART2,0x43,pSiS->p2_43);
+	  inSISIDXREG(SISPART2,0x01,pSiS->p2_01);
+	  inSISIDXREG(SISPART2,0x02,pSiS->p2_02);
+	  inSISIDXREG(SISPART2,0x44,pSiS->p2_44);
+	  inSISIDXREG(SISPART2,0x45,pSiS->p2_45);
+	  if(!(pSiS->VBFlags2 & VB2_301)) {
+	     inSISIDXREG(SISPART2,0x46,pSiS->p2_46);
+	  } else {
+	     pSiS->p2_46 = 0;
+	  }
+	  inSISIDXREG(SISPART2,0x0a,pSiS->p2_0a);
+	  inSISIDXREG(SISPART2,0x31,cbase);
+	  cbase = (cbase & 0x7f) << 8;
+	  inSISIDXREG(SISPART2,0x32,ctemp);
+	  cbase = (cbase | ctemp) << 8;
+	  inSISIDXREG(SISPART2,0x33,ctemp);
+	  cbase = (cbase | ctemp) << 8;
+	  inSISIDXREG(SISPART2,0x34,ctemp);
+	  pSiS->sistvccbase = (cbase | ctemp);
+	  inSISIDXREG(SISPART2,0x35,pSiS->p2_35);
+	  inSISIDXREG(SISPART2,0x36,pSiS->p2_36);
+	  inSISIDXREG(SISPART2,0x37,pSiS->p2_37);
+	  inSISIDXREG(SISPART2,0x38,pSiS->p2_38);
+	  if(!(pSiS->VBFlags2 & VB2_301)) {
+	     inSISIDXREG(SISPART2,0x47,pSiS->p2_47);
+	     inSISIDXREG(SISPART2,0x48,pSiS->p2_48);
+	     inSISIDXREG(SISPART2,0x49,pSiS->p2_49);
+	     inSISIDXREG(SISPART2,0x4a,pSiS->p2_4a);
+	  }
+	  inSISIDXREG(SISPART2,0x2f,pSiS->p2_2f);
+	  inSISIDXREG(SISPART2,0x30,pSiS->p2_30);
+	  for(i=0; i<9; i++) {
+	     inSISIDXREG(SISPART1,SiSScalingP1Regs[i],pSiS->scalingp1[i]);
+	  }
+	  for(i=0; i<9; i++) {
+	     inSISIDXREG(SISPART4,SiSScalingP4Regs[i],pSiS->scalingp4[i]);
+	  }
+	  if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
+	     for(i=0; i<64; i++) {
+	        inSISIDXREG(SISPART2,(0xc0 + i),pSiS->scalingp2[i]);
+  	     }
+	  }
+#ifdef SISDUALHEAD
+	  if(pSiSEnt) {
+	     pSiSEnt->p2_1f = pSiS->p2_1f; pSiSEnt->p2_20 = pSiS->p2_20;
+	     pSiSEnt->p2_42 = pSiS->p2_42; pSiSEnt->p2_43 = pSiS->p2_43;
+	     pSiSEnt->p2_2b = pSiS->p2_2b;
+	     pSiSEnt->p2_01 = pSiS->p2_01; pSiSEnt->p2_02 = pSiS->p2_02;
+	     pSiSEnt->p2_44 = pSiS->p2_44; pSiSEnt->p2_45 = pSiS->p2_45;
+	     pSiSEnt->p2_46 = pSiS->p2_46; pSiSEnt->p2_0a = pSiS->p2_0a;
+	     pSiSEnt->sistvccbase = pSiS->sistvccbase;
+	     pSiSEnt->p2_35 = pSiS->p2_35; pSiSEnt->p2_36 = pSiS->p2_36;
+	     pSiSEnt->p2_37 = pSiS->p2_37; pSiSEnt->p2_38 = pSiS->p2_38;
+	     pSiSEnt->p2_48 = pSiS->p2_48; pSiSEnt->p2_49 = pSiS->p2_49;
+	     pSiSEnt->p2_4a = pSiS->p2_4a; pSiSEnt->p2_2f = pSiS->p2_2f;
+	     pSiSEnt->p2_30 = pSiS->p2_30; pSiSEnt->p2_47 = pSiS->p2_47;
+	     for(i=0; i<9; i++) {
+	        pSiSEnt->scalingp1[i] = pSiS->scalingp1[i];
+	     }
+	     for(i=0; i<9; i++) {
+	        pSiSEnt->scalingp4[i] = pSiS->scalingp4[i];
+	     }
+	     if(pSiS->VBFlags2 & VB2_SISTAP4SCALER) {
+	        for(i=0; i<64; i++) {
+	           pSiSEnt->scalingp2[i] = pSiS->scalingp2[i];
+  	        }
+	     }
+	  }
+#endif
+          if((val = mysistvantiflicker) != -1) {
+	     SiS_SetSISTVantiflicker(pScrn, val);
+	  }
+	  if((val = mysistvsaturation) != -1) {
+	     SiS_SetSISTVsaturation(pScrn, val);
+	  }
+	  if((val = mysistvcfilter) != -1) {
+	     SiS_SetSISTVcfilter(pScrn, val);
+	  }
+	  if((val = mysistvyfilter) != 1) {
+	     SiS_SetSISTVyfilter(pScrn, val);
+	  }
+	  if((val = mysistvcolcalibc) != 0) {
+	     SiS_SetSISTVcolcalib(pScrn, val, TRUE);
+	  }
+	  if((val = mysistvcolcalibf) != 0) {
+	     SiS_SetSISTVcolcalib(pScrn, val, FALSE);
+	  }
+	  if((val = mytvxpos) != 0) {
+	     SiS_SetTVxposoffset(pScrn, val);
+	  }
+	  if((val = mytvypos) != 0) {
+	     SiS_SetTVyposoffset(pScrn, val);
+	  }
+	  if((val = mytvxscale) != 0) {
+	     SiS_SetTVxscale(pScrn, val);
+	  }
+	  if((val = mytvyscale) != 0) {
+	     SiS_SetTVyscale(pScrn, val);
+	  }
+       }
+    }
+}
+
+
+
diff --git a/src/sis_vb.h b/src/sis_vb.h
new file mode 100644
index 0000000..097a141
--- /dev/null
+++ b/src/sis_vb.h
@@ -0,0 +1,980 @@
+/* $XFree86$ */
+/* $XdotOrg$ */
+/*
+ * sis_vb data and definitions
+ *
+ * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2) Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3) The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author:     	Thomas Winischhofer <thomas@winischhofer.net>
+ *
+ */
+
+void SISCRT1PreInit(ScrnInfoPtr pScrn);
+void SISLCDPreInit(ScrnInfoPtr pScrn, Bool quiet);
+void SISTVPreInit(ScrnInfoPtr pScrn, Bool quiet);
+void SISCRT2PreInit(ScrnInfoPtr pScrn, Bool quiet);
+Bool SISRedetectCRT2Type(ScrnInfoPtr pScrn);
+void SISSense30x(ScrnInfoPtr pScrn, Bool quiet);
+void SISSenseChrontel(ScrnInfoPtr pScrn, Bool quiet);
+void SiSSetupPseudoPanel(ScrnInfoPtr pScrn);
+void SiSPostSetModeTVParms(ScrnInfoPtr pScrn);
+
+extern Bool   SISDetermineLCDACap(ScrnInfoPtr pScrn);
+extern void   SISSaveDetectedDevices(ScrnInfoPtr pScrn);
+extern UChar  SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, UShort offset, UChar value);
+
+/* From init.c, init301.c ---- (use their data types) */
+extern BOOLEAN		SiS_GetPanelID(struct SiS_Private *SiS_Pr);
+extern unsigned short	SiS_SenseLCDDDC(struct SiS_Private *SiS_Pr, SISPtr pSiS);
+extern unsigned short	SiS_SenseVGA2DDC(struct SiS_Private *SiS_Pr, SISPtr pSiS);
+
+extern void		SiS_CalcXTapScaler(struct SiS_Private *SiS_Pr, int srcsize,
+					int destsize, int taps, Bool ishoriz);
+
+typedef struct _SiS_LCD_StStruct
+{
+	ULong VBLCD_lcdflag;
+	UShort LCDwidth;
+	UShort LCDheight;
+} SiS_LCD_StStruct;
+
+static const SiS_LCD_StStruct SiS300_LCD_Type[]=
+{
+	{ VB_LCD_1024x768, 1024,  768 },  /* 0 - invalid */
+	{ VB_LCD_800x600,   800,  600 },  /* 1 */
+	{ VB_LCD_1024x768, 1024,  768 },  /* 2 */
+	{ VB_LCD_1280x1024,1280, 1024 },  /* 3 */
+	{ VB_LCD_1280x960, 1280,  960 },  /* 4 */
+	{ VB_LCD_640x480,   640,  480 },  /* 5 */
+	{ VB_LCD_1024x600, 1024,  600 },  /* 6 */
+	{ VB_LCD_1152x768, 1152,  768 },  /* 7 */
+	{ VB_LCD_1024x768, 1024,  768 },  /* 8 */
+	{ VB_LCD_1024x768, 1024,  768 },  /* 9 */
+	{ VB_LCD_1280x768, 1280,  768 },  /* a */
+	{ VB_LCD_1024x768, 1024,  768 },  /* b */
+	{ VB_LCD_1024x768, 1024,  768 },  /* c */
+	{ VB_LCD_1024x768, 1024,  768 },  /* d */
+	{ VB_LCD_320x480,   320,  480 },  /* e */
+	{ VB_LCD_CUSTOM,      0,    0 }   /* f */
+};
+
+static const SiS_LCD_StStruct SiS315_LCD_Type[]=
+{
+        { VB_LCD_1024x768, 1024,  768 },  /* 0 - invalid */
+	{ VB_LCD_800x600,   800,  600 },  /* 1 */
+	{ VB_LCD_1024x768, 1024,  768 },  /* 2 */
+	{ VB_LCD_1280x1024,1280, 1024 },  /* 3 */
+	{ VB_LCD_640x480,   640,  480 },  /* 4 */
+	{ VB_LCD_1024x600, 1024,  600 },  /* 5 */
+	{ VB_LCD_1152x864, 1152,  864 },  /* 6 */
+	{ VB_LCD_1280x960, 1280,  960 },  /* 7 */
+	{ VB_LCD_1152x768, 1152,  768 },  /* 8 */
+	{ VB_LCD_1400x1050,1400, 1050 },  /* 9 */
+	{ VB_LCD_1280x768, 1280,  768 },  /* a */
+	{ VB_LCD_1600x1200,1600, 1200 },  /* b */
+	{ VB_LCD_640x480_2, 640,  480 },  /* c FSTN */
+	{ VB_LCD_640x480_3, 640,  480 },  /* d FSTN */
+	{ VB_LCD_320x480,   320,  480 },  /* e */
+	{ VB_LCD_CUSTOM,      0,    0 }   /* f */
+};
+
+static const SiS_LCD_StStruct SiS661_LCD_Type[]=
+{
+        { VB_LCD_1024x768, 1024,  768 },  /* 0 - invalid */
+	{ VB_LCD_800x600,   800,  600 },  /* 1 */
+	{ VB_LCD_1024x768, 1024,  768 },  /* 2 */
+	{ VB_LCD_1280x1024,1280, 1024 },  /* 3 */
+        { VB_LCD_1440x900, 1440,  900 },  /*{ VB_LCD_640x480,   640,  480 },*/  /* 4 */
+	{ VB_LCD_1024x600, 1024,  600 },  /* 5 - temp */
+	{ VB_LCD_1152x864, 1152,  864 },  /* 6 - temp */
+	{ VB_LCD_1280x960, 1280,  960 },  /* 7 */
+	{ VB_LCD_1280x854, 1280,  854 },  /* 8 */
+	{ VB_LCD_1400x1050,1400, 1050 },  /* 9 */
+	{ VB_LCD_1280x768, 1280,  768 },  /* a */
+	{ VB_LCD_1600x1200,1600, 1200 },  /* b */
+	{ VB_LCD_1280x800, 1280,  800 },  /* c */
+	{ VB_LCD_1680x1050,1680, 1050 },  /* d */
+	{ VB_LCD_1280x720, 1280,  720 },  /* e */
+	{ VB_LCD_CUSTOM,      0,    0 },   /* f */
+	{ VB_LCD_1366x768, 1366,768 }  /*0x10*/ /*Ivans@090109*/ 
+                                                     /*don't follow VBIOS CR36 record, make a new Index for*/
+		                                       /* 1366x768x60Hz mode on LVDS panel*/	
+	/* TODO: 1440x900, 1920x1200 */
+};
+
+/*     TV scaling data for SiS video bridges
+ */
+typedef struct _SiSTVVScale {
+        UShort ScaleVDE;
+	int sindex;
+	UShort RealVDE;
+	UShort reg[4];
+} MySiSTVVScale, *MySiSTVVScalePtr;
+
+static const MySiSTVVScale SiSTVVScale[] = {
+	{ 470, 3, 480,			/* NTSC 640x480 */
+	  { 893, 508, 0x004c, 0x008f }
+	},
+	{ 460, 2, 480,
+	  { 874, 513, 0x004c, 0x008f }
+	},
+	{ 450, 1, 480,
+	  { 855, 518, 0x004c, 0x008f }
+	},
+	{ 440, 0, 480,	/* default */
+	  { 836, 523, 0x004c, 0x008f }
+	},
+	{ 430, -1, 480,
+	  { 860, 528, 0x0050, 0x008f }
+	},
+	{ 420, -2, 480,
+	  { 840, 533, 0x0050, 0x008f }
+	},
+	{ 410, -3, 480,
+	  { 820, 538, 0x0050, 0x008f }
+	},
+	{ 470, 3, 480,			/* NTSC 720x480 */
+	  { 893, 509, 0x004c, 0x008f }
+	},
+	{ 460, 2, 480,
+	  { 874, 514, 0x004c, 0x008f }
+	},
+	{ 450, 1, 480,
+	  { 855, 519, 0x004c, 0x008f }
+	},
+	{ 440, 0, 480,	/* default */
+	  { 836, 524, 0x004c, 0x008f }
+	},
+	{ 430, -1, 480,
+	  { 860, 529, 0x0050, 0x008f }
+	},
+	{ 420, -2, 480,
+	  { 840, 534, 0x0050, 0x008f }
+	},
+	{ 410, -3, 480,
+	  { 820, 539, 0x0050, 0x008f }
+	},
+	{ 470, 3, 600,			/* NTSC 800x600 */
+	  { 1081, 628, 0x0073, 0x008f }
+	},
+	{ 460, 2, 600,
+	  { 1058, 633, 0x0073, 0x008f }
+	},
+	{ 450, 1, 600,
+	  { 1044, 638, 0x0074, 0x008f }
+	},
+	{ 440, 0, 600,	/* default */
+	  { 1056, 643, 0x0078, 0x008f }
+	},
+	{ 430, -1, 600,
+	  { 1032, 648, 0x0078, 0x008f }
+	},
+	{ 420, -2, 600,
+	  { 1008, 653, 0x0078, 0x008f }
+	},
+	{ 410, -3, 600,
+	  { 1066, 658, 0x0082, 0x008f }
+	},
+	{ 560, 3, 480,			/* PAL 640x480 */
+	  { 882, 513, 0x0007, 0x0010 }
+	},
+	{ 550, 2, 480,
+	  { 900, 518, 0x0005, 0x000b }
+	},
+	{ 540, 1, 480,
+	  { 864, 523, 0x0004, 0x0009 }
+	},
+	{ 530, 0, 480,	/* default */
+	  { 848, 528, 0x0004, 0x0009 }
+	},
+	{ 520, -1, 480,
+	  { 832, 533, 0x0004, 0x0009 }
+	},
+	{ 510, -2, 480,
+	  { 918, 538, 0x0001, 0x0002 }
+	},
+	{ 500, -3, 480,
+	  { 900, 543, 0x0001, 0x0002 }
+	},
+	{ 560, 2, 576,			/* PAL 720x576 */
+	  { 960, 610, 0x0004, 0x0007 }
+	},
+	{ 550, 1, 576,
+	  { 990, 614, 0x0003, 0x0005 }
+	},
+	{ 540, 0, 576,	/* default */
+	  { 1080, 620, 0x0002, 0x0003 }
+	},
+	{ 530, -1, 576,
+	  { 1060, 625, 0x8002, 0x0003 }
+	},
+	{ 520, -2, 576,
+	  { 1040, 630, 0x0002, 0x0003 }
+	},
+	{ 510, -3, 576,
+	  { 1020, 635, 0x0002, 0x0003 }
+	},
+	{ 500, -4, 576,
+	  { 1000, 640, 0x0002, 0x0003 }
+	},
+	{ 560, 3, 600,			/* PAL 800x600 */
+	  { 1152, 633, 0x0005, 0x0007 }
+	},
+	{ 550, 2, 600,
+	  { 1100, 638, 0x0019, 0x0024 }
+	},
+	{ 540, 1, 600,
+	  { 1080, 643, 0x0019, 0x0024 }
+	},
+	{ 530, 0, 600,	/* default */
+	  { 1060, 648, 0x0019, 0x0024 }
+	},
+	{ 520, -1, 600,
+	  { 1040, 653, 0x0019, 0x0024 }
+	},
+	{ 510, -2, 600,
+	  { 1020, 658, 0x0019, 0x0024 }
+	},
+	{ 500, -3, 600,
+	  { 1080, 663, 0x0003, 0x0004 }
+	},
+	{ 720, 3, 480,			/* 750p 640x480 (42) */
+          { 1238, 500, 0x0001, 0x0002 }
+        },
+        { 693, 2, 480,
+          { 1191, 519, 0x0001, 0x0002 }
+        },
+        { 667, 1, 480,
+          { 1146, 540, 0x0001, 0x0002 }
+        },
+        { 640, 0, 480,
+          { 1100, 563, 0x0001, 0x0002 }
+        },
+        { 613, -1, 480,
+          { 1054, 587, 0x0001, 0x0002 }
+        },
+        { 587, -2, 480,
+          { 1009, 613, 0x0001, 0x0002 }
+        },
+        { 560, -3, 480,
+          { 963, 643, 0x0001, 0x0002 }
+        },
+	{ 720, 3, 480,			/* 750p 720x480 (49) */
+          { 1238, 500, 0x0001, 0x0002 }
+        },
+        { 693, 2, 480,
+          { 1191, 519, 0x0001, 0x0002 }
+        },
+        { 667, 1, 480,
+          { 1146, 540, 0x0001, 0x0002 }
+        },
+        { 640, 0, 480,
+          { 1100, 563, 0x0001, 0x0002 }
+        },
+        { 613, -1, 480,
+          { 1054, 587, 0x0001, 0x0002 }
+        },
+        { 587, -2, 480,
+          { 1009, 613, 0x0001, 0x0002 }
+        },
+        { 560, -3, 480,
+          { 963, 643, 0x0001, 0x0002 }
+        },
+	{ 720, 3, 576,			/* 750p 720/768x576 (56) */
+          { 1238, 600, 0x0003, 0x0005 }
+        },
+        { 693, 2, 576,
+          { 1191, 623, 0x0003, 0x0005 }
+        },
+        { 667, 1, 576,
+          { 1146, 648, 0x0003, 0x0005 }
+        },
+        { 640, 0, 576,
+          { 1100, 675, 0x0003, 0x0005 }
+        },
+        { 613, -1, 576,
+          { 1054, 705, 0x0003, 0x0005 }
+        },
+        { 587, -2, 576,
+          { 1009, 736, 0x0003, 0x0005 }
+        },
+        { 560, -3, 576,
+          { 963, 771, 0x0003, 0x0005 }
+        },
+	{ 720, 3, 480,			/* 750p 800x480 (63) */
+          { 1238, 500, 0x0001, 0x0002 }
+        },
+        { 693, 2, 480,
+          { 1191, 519, 0x0001, 0x0002 }
+        },
+        { 667, 1, 480,
+          { 1146, 540, 0x0001, 0x0002 }
+        },
+        { 640, 0, 480,
+          { 1100, 563, 0x0001, 0x0002 }
+        },
+        { 613, -1, 480,
+          { 1054, 587, 0x0001, 0x0002 }
+        },
+        { 587, -2, 480,
+          { 1009, 613, 0x0001, 0x0002 }
+        },
+        { 560, -3, 480,
+          { 963, 643, 0x0001, 0x0002 }
+        },
+	{ 720, 3, 600,			/* 750p 800x600 (70) */
+          { 1320, 625, 0x0002, 0x0003 }
+        },
+        { 700, 2, 600,
+          { 1283, 643, 0x0002, 0x0003 }
+        },
+        { 680, 1, 600,
+          { 1247, 662, 0x0002, 0x0003 }
+        },
+        { 660, 0, 600,
+          { 1210, 682, 0x0002, 0x0003 }
+        },
+        { 640, -1, 600,
+          { 1173, 703, 0x0002, 0x0003 }
+        },
+        { 620, -2, 600,
+          { 1137, 726, 0x0002, 0x0003 }
+        },
+        { 600, -3, 600,
+          { 1100, 750, 0x0002, 0x0003 }
+        },
+	{ 720, 3, 576,			/* 750p 1024x576 (77) */
+          { 1238, 600, 0x0003, 0x0005 }
+        },
+        { 693, 2, 576,
+          { 1191, 623, 0x0003, 0x0005 }
+        },
+        { 667, 1, 576,
+          { 1146, 648, 0x0003, 0x0005 }
+        },
+        { 640, 0, 576,
+          { 1100, 675, 0x0003, 0x0005 }
+        },
+	{ 630, -1, 576,
+          { 1083, 686, 0x0003, 0x0005 }
+	},
+	{ 620, -2, 576,
+          { 1066, 697, 0x0003, 0x0005 }
+        },
+	{ 616, -3, 576,
+          { 1059, 701, 0x0003, 0x0005 }
+        },
+	{ 720, 3, 768,			/* 750p 1024x768 (84) */
+          { 1547, 800, 0x0001, 0x0001 }
+        },
+        { 693, 2, 768,
+          { 1489, 831, 0x0001, 0x0001 }
+        },
+        { 667, 1, 768,
+          { 1433, 864, 0x0001, 0x0001 }
+        },
+        { 640, 0, 768,
+          { 1375, 900, 0x0001, 0x0001 }
+        },
+        { 613, -1, 768,
+          { 1317, 940, 0x0001, 0x0001 }
+        },
+        { 587, -2, 768,
+          { 1261, 981, 0x0001, 0x0001 }
+        },
+        { 560, -3, 768,
+          { 1203, 1029, 0x0001, 0x0001 }
+        },
+#ifdef OLD1280720P
+	{ 720, 3, 720,			/* 750p 1280x720-old (91) */
+          { 1584, 750, 0x0018, 0x0019 }
+        },
+        { 707, 2, 720,
+          { 1555, 764, 0x0018, 0x0019 }
+        },
+        { 693, 1, 720,
+          { 1525, 779, 0x0018, 0x0019 }
+        },
+        { 680, 0, 720,
+          { 1496, 794, 0x0018, 0x0019 }
+        },
+        { 667, -1, 720,
+          { 1467, 810, 0x0018, 0x0019 }
+        },
+        { 653, -2, 720,
+          { 1437, 827, 0x0018, 0x0019 }
+        },
+        { 640, -3, 720,
+          { 1408, 844, 0x0018, 0x0019 }
+        },
+#endif
+#ifndef OLD1280720P
+	{ 720, 3, 720,			/* 750p 1280x720-new (91) */
+	  { 1650, 750, 0x0001, 0x0001 }
+	},
+	{ 720, 2, 720,
+	  { 1650, 750, 0x0001, 0x0001 }
+	},
+	{ 720, 1, 720,
+	  { 1650, 750, 0x0001, 0x0001 }
+	},
+	{ 720, 0, 720,
+	  { 1650, 750, 0x0001, 0x0001 }
+	},
+	{ 704, -1, 720,
+          { 1613, 767, 0x0001, 0x0001 }
+        },
+        { 688, -2, 720,
+          { 1577, 785, 0x0001, 0x0001 }
+        },
+        { 672, -3, 720,
+          { 1540, 804, 0x0001, 0x0001 }
+        },
+#endif
+	{ 1080, 3, 480,			/* 1080i 640x480 (98) */
+          { 945, 500, 0x8001, 0x0005 }
+        },
+        { 1040, 2, 480,
+          { 910, 519, 0x8001, 0x0005 }
+        },
+        { 1000, 1, 480,
+          { 875, 540, 0x8001, 0x0005 }
+        },
+        { 960, 0, 480,
+          { 840, 563, 0x8001, 0x0005 }
+        },
+        { 920, -1, 480,
+          { 805, 587, 0x8001, 0x0005 }
+        },
+        { 880, -2, 480,
+          { 770, 614, 0x8001, 0x0005 }
+        },
+        { 840, -3, 480,
+          { 735, 643, 0x8001, 0x0005 }
+        },
+	{ 1080, 3, 480,			/* 1080i 800x480 (105) */
+          { 1181, 500, 0x8001, 0x0004 }
+        },
+        { 1040, 2, 480,
+          { 1138, 519, 0x8001, 0x0004 }
+        },
+        { 1000, 1, 480,
+          { 1094, 540, 0x8001, 0x0004 }
+        },
+        { 960, 0, 480,
+          { 1050, 563, 0x8001, 0x0004 }
+        },
+        { 920, -1, 480,
+          { 1006, 587, 0x8001, 0x0004 }
+        },
+        { 880, -2, 480,
+          { 963, 614, 0x8001, 0x0004 }
+        },
+        { 840, -3, 480,
+          { 919, 643, 0x8001, 0x0004 }
+        },
+	{ 1080, 3, 600,			/* 1080i 800x600 (112) */
+          { 1181, 625, 0x8005, 0x0010 }
+        },
+        { 1040, 2, 600,
+          { 1138, 649, 0x8005, 0x0010 }
+        },
+        { 1000, 1, 600,
+          { 1094, 675, 0x8005, 0x0010 }
+        },
+        { 960, 0, 600,
+          { 1050, 703, 0x8005, 0x0010 }
+        },
+        { 920, -1, 600,
+          { 1006, 734, 0x8005, 0x0010 }
+        },
+        { 880, -2, 600,
+          { 963, 767, 0x8005, 0x0010 }
+        },
+        { 840, -3, 600,
+          { 919, 804, 0x8005, 0x0010 }
+        },
+	{ 1080, 3, 576,			/* 1080i 1024x576 (119) */
+          { 1575, 600, 0x0002, 0x0005 }
+        },
+        { 1040, 2, 576,
+          { 1517, 623, 0x0002, 0x0005 }
+        },
+        { 1000, 1, 576,
+          { 1458, 648, 0x0002, 0x0005 }
+        },
+        { 960, 0, 576,
+          { 1400, 675, 0x0002, 0x0005 }
+        },
+        { 920, -1, 576,
+          { 1342, 704, 0x0002, 0x0005 }
+        },
+        { 880, -2, 576,
+          { 1283, 736, 0x0002, 0x0005 }
+        },
+        { 840, -3, 576,
+          { 1225, 771, 0x0002, 0x0005 }
+        },
+	{ 1080, 3, 768,			/* 1080i 1024x768 (126) */
+          { 1418, 800, 0x000c, 0x0019 }
+        },
+        { 1040, 2, 768,
+          { 1365, 831, 0x000c, 0x0019 }
+        },
+        { 1000, 1, 768,
+          { 1313, 864, 0x000c, 0x0019 }
+        },
+        { 960, 0, 768,
+          { 1260, 900, 0x000c, 0x0019 }
+        },
+        { 920, -1, 768,
+          { 1208, 939, 0x000c, 0x0019 }
+        },
+        { 880, -2, 768,
+          { 1155, 982, 0x000c, 0x0019 }
+        },
+        { 840, -3, 768,
+          { 1103, 1029, 0x000c, 0x0019 }
+        },
+	{ 1080, 3, 720,			/* 1080i 1280x720 (133) */
+          { 1969, 750, 0x0005, 0x0008 }
+        },
+        { 1040, 2, 720,
+          { 1896, 779, 0x0005, 0x0008 }
+        },
+        { 1000, 1, 720,
+          { 1823, 810, 0x0005, 0x0008 }
+        },
+        { 960, 0, 720,
+          { 1750, 844, 0x0005, 0x0008 }
+        },
+        { 920, -1, 720,
+          { 1677, 880, 0x0005, 0x0008 }
+        },
+        { 880, -2, 720,
+          { 1604, 920, 0x0005, 0x0008 }
+        },
+        { 840, -3, 720,
+          { 1531, 964, 0x0005, 0x0008 }
+        },
+	{ 1080, 3, 1024,		/* 1080i 1280x1024 (140) */
+          { 1772, 1067, 0x0004, 0x0005 }
+        },
+        { 1040, 2, 1024,
+          { 1706, 1108, 0x0004, 0x0005 }
+        },
+        { 1000, 1, 1024,
+          { 1641, 1152, 0x0004, 0x0005 }
+        },
+        { 960, 0, 1024,
+          { 1575, 1200, 0x0004, 0x0005 }
+        },
+        { 920, -1, 1024,
+          { 1509, 1252, 0x0004, 0x0005 }
+        },
+        { 880, -2, 1024,
+          { 1444, 1309, 0x0004, 0x0005 }
+        },
+        { 840, -3, 1024,
+          { 1378, 1371, 0x0004, 0x0005 }
+        },
+	{ 470, 3, 576,			/* NTSC 720x576 (147) */
+          { 1175, 602, 0x8078, 0x008f }
+        },
+        { 460, 2, 576,
+          { 1150, 614, 0x8078, 0x008f }
+        },
+        { 450, 1, 576,
+          { 1125, 628, 0x8078, 0x008f }
+        },
+        { 440, 0, 576,
+          { 1100, 643, 0x8078, 0x008f }
+        },
+        { 430, -1, 576,
+          { 1075, 658, 0x8078, 0x008f }
+        },
+        { 420, -2, 576,
+          { 1050, 673, 0x8078, 0x008f }
+        },
+        { 410, -3, 576,
+          { 1025, 680, 0x8078, 0x008f }
+        },
+	{ 550, 3, 768,			/* PAL 1024x768 (154) */
+          { 1238, 776, 0x0001, 0x0001 }
+        },
+        { 540, 2, 768,
+          { 1215, 790, 0x0001, 0x0001 }
+        },
+        { 530, 1, 768,
+          { 1193, 805, 0x0001, 0x0001 }
+        },
+        { 520, 0, 768,
+          { 1170, 821, 0x0001, 0x0001 }
+        },
+        { 510, -1, 768,
+          { 1148, 837, 0x0001, 0x0001 }
+        },
+        { 500, -2, 768,
+          { 1125, 853, 0x0001, 0x0001 }
+        },
+        { 490, -3, 768,
+          { 1103, 871, 0x0001, 0x0001 }
+        },
+	{ 470, 3, 768,			/* NTSC 1024 i (161) */
+          { 1175, 759, 0x8001, 0x0001 }
+        },
+        { 460, 2, 768,
+          { 1150, 775, 0x8001, 0x0001 }
+        },
+        { 450, 1, 768,
+          { 1125, 792, 0x8001, 0x0001 }
+        },
+        { 440, 0, 768,
+          { 1100, 811, 0x8001, 0x0001 }
+        },
+        { 430, -1, 768,
+          { 1075, 829, 0x8001, 0x0001 }
+        },
+        { 430, -2, 768,
+          { 1075, 829, 0x8001, 0x0001 }
+        },
+        { 430, -3, 768,
+          { 1075, 829, 0x8001, 0x0001 }
+        },
+	{ 470, 3, 768,			/* NTSC 1024 p (168) */
+          { 1175, 792, 0x0001, 0x0001 }
+        },
+        { 460, 2, 768,
+          { 1150, 809, 0x0001, 0x0001 }
+        },
+        { 450, 1, 768,
+          { 1125, 827, 0x0001, 0x0001 }
+        },
+        { 440, 0, 768,
+          { 1100, 846, 0x0001, 0x0001 }
+        },
+        { 430, -1, 768,
+          { 1075, 865, 0x0001, 0x0001 }
+        },
+        { 430, -2, 768,
+          { 1075, 865, 0x0001, 0x0001 }
+        },
+        { 430, -3, 768,
+          { 1075, 865, 0x0001, 0x0001 }
+        },
+	{ 470, 3, 480,			/* NTSC 800x480 (175) */
+	  { 893, 509, 0x004c, 0x008f }
+	},
+	{ 460, 2, 480,
+	  { 874, 514, 0x004c, 0x008f }
+	},
+	{ 450, 1, 480,
+	  { 855, 519, 0x004c, 0x008f }
+	},
+	{ 440, 0, 480,	/* default */
+	  { 836, 524, 0x004c, 0x008f }
+	},
+	{ 430, -1, 480,
+	  { 860, 529, 0x0050, 0x008f }
+	},
+	{ 420, -2, 480,
+	  { 840, 534, 0x0050, 0x008f }
+	},
+	{ 420, -3, 480,
+	  { 840, 534, 0x0050, 0x008f }
+	},
+	{ 470, 3, 576,			/* NTSC 1024x576 (182) */
+          { 1175, 602, 0x8078, 0x008f }
+        },
+        { 460, 2, 576,
+          { 1150, 614, 0x8078, 0x008f }
+        },
+        { 450, 1, 576,
+          { 1125, 628, 0x8078, 0x008f }
+        },
+        { 440, 0, 576,
+          { 1100, 643, 0x8078, 0x008f }
+        },
+        { 430, -1, 576,
+          { 1075, 658, 0x8078, 0x008f }
+        },
+        { 430, -2, 576,
+          { 1075, 658, 0x8078, 0x008f }
+        },
+        { 430, -3, 576,
+          { 1075, 658, 0x8078, 0x008f }
+        },
+	{ 564, 3, 576,			/* PAL 1024x576 (189) */
+          { 1128, 592, 0x0002, 0x0003 }
+        },
+        { 556, 2, 576,
+          { 1112, 601, 0x0002, 0x0003 }
+        },
+        { 548, 1, 576,
+          { 1096, 610, 0x0002, 0x0003 }
+        },
+        { 540, 0, 576,
+          { 1080, 619, 0x0002, 0x0003 }
+        },
+        { 532, -1, 576,
+          { 1064, 628, 0x0002, 0x0003 }
+        },
+        { 532, -2, 576,
+          { 1064, 628, 0x0002, 0x0003 }
+        },
+        { 532, -3, 576,
+          { 1064, 628, 0x0002, 0x0003 }
+        },
+	{ 1080, 3, 540,			/* 1080i 960x540 (196) */
+          { 1050, 600, 0x0001, 0x0004 }
+        },
+        { 1080, 2, 540,
+          { 1050, 600, 0x0001, 0x0004 }
+        },
+        { 1080, 1, 540,
+          { 1050, 600, 0x0001, 0x0004 }
+        },
+        { 1080, 0, 540,
+          { 1050, 600, 0x0001, 0x0004 }
+        },
+        { 1040, -1, 540,
+          { 1011, 623, 0x0001, 0x0004 }
+        },
+        { 1000, -2, 540,
+          { 1944, 648, 0x0001, 0x0002 }
+        },
+        { 960, -3, 540,
+          { 1866, 675, 0x0001, 0x0002 }
+        },
+	{ 1080, 3, 600,			/* 1080i 960x600 (203) */
+          { 1418, 670, 0x0003, 0x0008 }
+        },
+        { 1040, 2, 600,
+          { 1365, 700, 0x0003, 0x0008 }
+        },
+        { 1000, 1, 600,
+          { 1313, 816, 0x0003, 0x0008 }
+        },
+        { 960, 0, 600,
+          { 1260, 851, 0x0003, 0x0008 }
+        },
+        { 920, -1, 600,
+          { 1208, 887, 0x0003, 0x0008 }
+        },
+        { 880, -2, 600,
+          { 1155, 928, 0x0003, 0x0008 }
+        },
+        { 840, -3, 600,
+          { 1103, 972, 0x0003, 0x0008 }
+        },
+        { 554, 3, 480,			/* PAL 848x480 (210) */
+          { 1330, 542, 0x8002, 0x0003 }
+        },
+        { 546, 2, 480,
+          { 1310, 549, 0x8002, 0x0003 }
+        },
+        { 538, 1, 480,
+          { 1291, 558, 0x8002, 0x0003 }
+        },
+        { 530, 0, 480,
+          { 1272, 566, 0x8002, 0x0003 }
+        },
+        { 522, -1, 480,
+          { 1253, 575, 0x8002, 0x0003 }
+        },
+        { 514, -2, 480,
+          { 1234, 584, 0x8002, 0x0003 }
+        },
+        { 506, -3, 480,
+          { 1214, 593, 0x8002, 0x0003 }
+        },
+        { 464, 3, 480,			/* NTSC 848x480 (217) */
+          { 1392, 530, 0x8078, 0x008f }
+        },
+        { 456, 2, 480,
+          { 1368, 540, 0x8078, 0x008f }
+        },
+        { 448, 1, 480,
+          { 1344, 550, 0x8078, 0x008f }
+        },
+        { 440, 0, 480,
+          { 1320, 560, 0x8078, 0x008f }
+        },
+        { 432, -1, 480,
+          { 1296, 570, 0x8078, 0x008f }
+        },
+        { 424, -2, 480,
+          { 1272, 575, 0x8078, 0x008f }
+        },
+        { 416, -3, 480,
+          { 1248, 583, 0x8078, 0x008f }
+        }
+};
+
+static unsigned const char SiSScalingP1Regs[] = {
+	0x08,0x09,0x0b,0x0c,0x0d,0x0e,0x10,0x11,0x12
+};
+static unsigned const char SiSScalingP4Regs[] = {
+	0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b
+};
+
+/*     TV filters for SiS video bridges
+ */
+static const struct _SiSTVFilter301 {
+	UChar filter[7][4];
+} SiSTVFilter301[] = {
+	{{ {0x00,0xE0,0x10,0x60},   /* NTSCFilter - 320 */
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18} }},
+	{{ {0xF5,0xEE,0x1B,0x44},   /* NTSCFilter - 640 */
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xEB,0x04,0x25,0x18},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xF6,0x06,0x1A,0x14},
+	   {0xFA,0x06,0x16,0x14},
+	   {0x00,0x04,0x10,0x18} }},
+	{{ {0xEB,0x04,0x25,0x18},   /* NTSCFilter - 720 */
+	   {0xE7,0x0E,0x29,0x04},
+	   {0xEE,0x0C,0x22,0x08},
+	   {0xF6,0x0B,0x1A,0x0A},
+	   {0xF9,0x0A,0x17,0x0C},
+	   {0xFC,0x0A,0x14,0x0C},
+	   {0x00,0x08,0x10,0x10} }},
+	{{ {0xEC,0x02,0x24,0x1C},   /* NTSCFilter - 800/400 */
+	   {0xF2,0x04,0x1E,0x18},
+	   {0xEB,0x15,0x25,0xF6},
+	   {0xF4,0x10,0x1C,0x00},
+	   {0xF8,0x0F,0x18,0x02},
+	   {0x00,0x04,0x10,0x18},
+	   {0x01,0x06,0x0F,0x14} }},
+	{{ {0x00,0xE0,0x10,0x60},   /* PALFilter - 320 */
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18} }},
+	{{ {0xF5,0xEE,0x1B,0x44},   /* PALFilter - 640 */
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xF1,0xF7,0x1F,0x32},
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xF9,0xFF,0x17,0x22},
+	   {0xFB,0x01,0x15,0x1E},
+	   {0x00,0x04,0x10,0x18} }},
+	{{ {0xF5,0xEE,0x1B,0x2A},   /* PALFilter - 720 */
+	   {0xEE,0xFE,0x22,0x24},
+	   {0xF3,0x00,0x1D,0x20},
+	   {0xF9,0x03,0x17,0x1A},
+	   {0xFB,0x02,0x14,0x1E},
+	   {0xFB,0x04,0x15,0x18},
+	   {0x00,0x06,0x10,0x14} }},
+	{{ {0xF5,0xEE,0x1B,0x44},   /* PALFilter - 800/400 */
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0xEB,0x05,0x25,0x16},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xFA,0x07,0x16,0x12},
+	   {0x00,0x07,0x10,0x12} }}
+};
+
+static const struct _SiSTVFilter301B {
+	UChar filter[7][7];
+} SiSTVFilter301B[] = {
+	{{ {0x01,0x02,0xfb,0xf8,0x06,0x27,0x3a},   /* NTSC - 640 */
+	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
+	   {0x01,0x01,0x00,0xf6,0x00,0x28,0x40},
+	   {0xff,0x03,0x02,0xf6,0xfc,0x27,0x46},
+	   {0xff,0x01,0x04,0xf8,0xfa,0x27,0x46},
+	   {0xff,0x01,0x05,0xf9,0xf7,0x26,0x4a},
+	   {0xff,0xff,0x05,0xfc,0xf4,0x24,0x52} }},
+	{{ {0x01,0x00,0xfb,0xfb,0x0b,0x25,0x32},   /* NTSC - 720 (?) */
+	   {0x01,0x01,0xfb,0xf9,0x09,0x26,0x36},
+	   {0x01,0x02,0xfc,0xf8,0x06,0x27,0x38},
+	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
+	   {0x01,0x03,0xff,0xf6,0x00,0x27,0x40},
+	   {0xff,0x03,0x02,0xf6,0xfe,0x27,0x42},
+	   {0xff,0x02,0x03,0xf7,0xfb,0x27,0x46} }},
+	{{ {0x01,0xfe,0xfb,0xfe,0x0e,0x23,0x2e},   /* NTSC - 800 */
+	   {0x01,0xff,0xfb,0xfc,0x0c,0x25,0x30},
+	   {0x01,0x00,0xfb,0xfa,0x0a,0x26,0x34},
+	   {0x01,0x01,0xfc,0xf8,0x08,0x26,0x38},
+	   {0x01,0x02,0xfd,0xf7,0x06,0x27,0x38},
+	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
+	   {0xff,0x03,0x00,0xf6,0x00,0x27,0x42} }},
+	{{ {0xff,0xfd,0xfe,0x05,0x11,0x1e,0x24},   /* NTSC - 1024 */
+	   {0xff,0xfd,0xfd,0x04,0x11,0x1f,0x26},
+	   {0xff,0xfd,0xfc,0x02,0x10,0x22,0x28},
+	   {0xff,0xff,0xfc,0x00,0x0f,0x22,0x28},
+	   {0x01,0xfe,0xfb,0xff,0x0e,0x23,0x2c},
+	   {0x01,0xff,0xfb,0xfd,0x0d,0x24,0x2e},
+	   {0x01,0xff,0xfb,0xfb,0x0c,0x25,0x32} }},
+	{{ {0x01,0x02,0xfb,0xf8,0x06,0x27,0x3a},   /* PAL - 640 */
+	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
+	   {0x01,0x01,0x00,0xf6,0x00,0x28,0x40},
+	   {0xff,0x03,0x02,0xf6,0xfc,0x27,0x46},
+	   {0xff,0x01,0x04,0xf8,0xfa,0x27,0x46},
+	   {0xff,0x01,0x05,0xf9,0xf7,0x26,0x4a},
+	   {0xff,0xff,0x05,0xfc,0xf4,0x24,0x52} }},
+	{{ {0x01,0x00,0xfb,0xfb,0x0b,0x25,0x32},   /* PAL - 720/768 */
+	   {0x01,0x01,0xfb,0xf9,0x09,0x26,0x36},
+	   {0x01,0x02,0xfc,0xf8,0x06,0x27,0x38},
+	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
+	   {0x01,0x03,0xff,0xf6,0x00,0x27,0x40},
+	   {0xff,0x03,0x02,0xf6,0xfe,0x27,0x42},
+	   {0xff,0x02,0x03,0xf7,0xfb,0x27,0x46} }},
+	{{ {0x01,0xfe,0xfb,0xfe,0x0e,0x23,0x2e},   /* PAL - 800 */
+	   {0x01,0xff,0xfb,0xfc,0x0c,0x25,0x30},
+	   {0x01,0x00,0xfb,0xfa,0x0a,0x26,0x34},
+	   {0x01,0x01,0xfc,0xf8,0x08,0x26,0x38},
+	   {0x01,0x02,0xfd,0xf7,0x06,0x27,0x38},
+	   {0x01,0x02,0xfe,0xf7,0x03,0x27,0x3c},
+	   {0xff,0x03,0x00,0xf6,0x00,0x27,0x42} }},
+	{{ {0xff,0xfd,0xfe,0x05,0x11,0x1e,0x24},   /* PAL - 1024 */
+	   {0xff,0xfd,0xfd,0x04,0x11,0x1f,0x26},
+	   {0xff,0xfd,0xfc,0x02,0x10,0x22,0x28},
+	   {0xff,0xff,0xfc,0x00,0x0f,0x22,0x28},
+	   {0x01,0xfe,0xfb,0xff,0x0e,0x23,0x2c},
+	   {0x01,0xff,0xfb,0xfd,0x0d,0x24,0x2e},
+	   {0x01,0xff,0xfb,0xfb,0x0c,0x25,0x32} }},
+	{{ {0x54,0x69,0x6c,0x6c,0x20,0x53,0x6f},   /* PAL-M - 1024 */
+	   {0x66,0x69,0x61,0x20,0x42,0x65,0x72},
+	   {0x6e,0x74,0x73,0x73,0x6f,0x6e,0x20},
+	   {0x2d,0x20,0x42,0x72,0x6f,0x75,0x67},
+	   {0x68,0x74,0x20,0x74,0x6f,0x20,0x79},
+	   {0x6f,0x75,0x20,0x62,0x79,0x20,0x6e},
+	   {0x6f,0x74,0x20,0x61,0x20,0x6d,0x65,} }},
+	{{ {0x72,0x65,0x20,0x57,0x69,0x7a,0x61},   /* PAL-N - 1024 */
+	   {0x72,0x64,0x20,0x62,0x75,0x74,0x20},
+	   {0x74,0x68,0x65,0x20,0x57,0x69,0x7a},
+	   {0x61,0x72,0x64,0x20,0x45,0x78,0x74},
+	   {0x72,0x61,0x6f,0x72,0x64,0x69,0x6e},
+	   {0x61,0x69,0x72,0x65,0x21,0x20,0x48},
+	   {0x69,0x20,0x44,0x61,0x6c,0x65,0x21} }}
+};
+
diff --git a/src/sis_vga.c b/src/sis_vga.c
index f04a245..31d030c 100644
--- a/src/sis_vga.c
+++ b/src/sis_vga.c
@@ -50,14 +50,11 @@
 #include "sis_regs.h"
 #include "sis_dac.h"
 
-static Bool  SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
-static Bool  SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode);
-static int   SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl);
-static void  SISSense6326(ScrnInfoPtr pScrn);
-static void  SiS6326TVDelay(ScrnInfoPtr pScrn, int delay);
 extern void  SISSense30x(ScrnInfoPtr pScrn, Bool quiet);
 extern void  SISSenseChrontel(ScrnInfoPtr pScrn, Bool quiet);
 
+void RecalcScreenPitch(ScrnInfoPtr pScrn);
+
 /* Our very own vgaHW functions */
 void SiSVGASave(ScrnInfoPtr pScrn, SISRegPtr save, int flags);
 void SiSVGARestore(ScrnInfoPtr pScrn, SISRegPtr restore, int flags);
@@ -73,11 +70,11 @@ void SiSVGAUnmapMem(ScrnInfoPtr pScrn);
 Bool SiSVGASaveScreen(ScreenPtr pScreen, int mode);
 static Bool SiSVGAInit(ScrnInfoPtr pScrn, DisplayModePtr mode, int fixsync);
 
-const CARD8 SiS6326TVRegs1[14] = {
+static const CARD8 SiS6326TVRegs1[14] = {
      0x00,0x01,0x02,0x03,0x04,0x11,0x12,0x13,0x21,0x26,0x27,0x3a,0x3c,0x43
 };
 
-const CARD8 SiS6326TVRegs1_NTSC[6][14] = {
+static const CARD8 SiS6326TVRegs1_NTSC[6][14] = {
     {0x81,0x3f,0x49,0x1b,0xa9,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
     {0x81,0x3f,0x49,0x1d,0xa0,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
     {0x81,0x45,0x24,0x8e,0x26,0x0b,0x00,0x09,0x02,0xfe,0x00,0x09,0x51,0x60},
@@ -86,7 +83,7 @@ const CARD8 SiS6326TVRegs1_NTSC[6][14] = {
     {0x83,0x5d,0x21,0xbe,0x75,0x03,0x00,0x09,0x08,0x42,0x10,0x4d,0x61,0x79}   /* 640x480u */
 };
 
-const CARD8 SiS6326TVRegs2_NTSC[6][54] = {
+static const CARD8 SiS6326TVRegs2_NTSC[6][54] = {
     {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
      0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
      0xFC, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
@@ -119,7 +116,7 @@ const CARD8 SiS6326TVRegs2_NTSC[6][54] = {
      0xEB, 0x43, 0x62, 0x48, 0x34, 0x3D, 0x63, 0x29, 0x03, 0xA0}
 };
 
-const CARD8 SiS6326TVRegs1_PAL[6][14] = {
+static const CARD8 SiS6326TVRegs1_PAL[6][14] = {
     {0x81,0x2d,0xc8,0x07,0xb2,0x0b,0x00,0x09,0x02,0xed,0x00,0xf8,0x30,0x40},
     {0x80,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},
     {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},  /* 640x480 */
@@ -128,7 +125,7 @@ const CARD8 SiS6326TVRegs1_PAL[6][14] = {
     {0x81,0x63,0xa4,0x03,0xd9,0x01,0x00,0x09,0x10,0x9f,0x10,0xaa,0x71,0x59}   /* 720x540  */
 };
 
-const CARD8 SiS6326TVRegs2_PAL[6][54] = {
+static const CARD8 SiS6326TVRegs2_PAL[6][54] = {
     {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
      0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
      0xE5, 0xDF, 0x94, 0xEF, 0x5A, 0x03, 0x7F, 0x07, 0xFF, 0x10, 0x4E,
@@ -161,7 +158,7 @@ const CARD8 SiS6326TVRegs2_PAL[6][54] = {
      0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0}
 };
 
-const CARD8 SiS6326CR[9][15] = {
+static const CARD8 SiS6326CR[9][15] = {
      {0x79,0x63,0x64,0x1d,0x6a,0x93,0x00,0x6f,0xf0,0x58,0x8a,0x57,0x57,0x70,0x20},  /* PAL 800x600   */
      {0x79,0x4f,0x50,0x95,0x60,0x93,0x00,0x6f,0xba,0x14,0x86,0xdf,0xe0,0x30,0x00},  /* PAL 640x480   */
      {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xe9,0x8b,0xdf,0xe7,0x04,0x00},  /* NTSC 640x480  */
@@ -175,7 +172,7 @@ const CARD8 SiS6326CR[9][15] = {
 
 /* Initialize a display mode on 5597/5598, 6326 and 530/620 */
 static Bool
-SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
+SISOldInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 {
     SISPtr       pSiS = SISPTR(pScrn);
     SISRegPtr    pReg = &pSiS->ModeReg;
@@ -193,6 +190,10 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
     int          num, denum, div, sbit, scale;
     Bool	 sis6326tvmode, sis6326himode;
 
+    /* Obs: Write values to pSiS only after this
+     * function can no longer fail!
+     */
+
     /* Save the registers for further processing */
     (*pSiS->SiSSave)(pScrn, pReg);
 
@@ -239,13 +240,11 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
     }
 
     /* set interlace */
+    offset = pSiS->CurrentLayout.displayWidth >> 2;
     if(!(mode->Flags & V_INTERLACE)) {
-       offset = pSiS->CurrentLayout.displayWidth >> 3;
-    } else {
-       offset = pSiS->CurrentLayout.displayWidth >> 2;
-       if(!pSiS->UseVESA) {
-	  pReg->sisRegs3C4[0x06] |= 0x20;
-       }
+       offset >>= 1;
+    } else if(!pSiS->UseVESA) {
+       pReg->sisRegs3C4[0x06] |= 0x20;
     }
 
     /* Enable Linear and Enhanced Gfx Mode */
@@ -319,13 +318,19 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
        }
     }
 
+    /* From here, this function won't fail, so
+     * we can start writing things to pSiS.
+     */
+
     /* save screen pitch for acceleration functions */
     pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
-			((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);
+			(pSiS->CurrentLayout.bitsPerPixel >> 3);
 
     /* Set accelerator dest color depth to 0 - not supported on 530/620 */
     pSiS->DstColor = 0;
 
+    pSiS->sis6326tvumode = FALSE;
+
     if(!pSiS->UseVESA) {
 
        /* set linear framebuffer addresses */
@@ -346,19 +351,22 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
        /* Set CR registers for our built-in TV and hi-res modes */
        if((sis6326tvmode) || (sis6326himode)) {
 
-	  int index,i;
+	  int index, i;
 
 	  /* We need our very private data for hi-res and TV modes */
 	  if(sis6326himode) {
-	     if(strcmp(mode->name, "SIS1280x1024-75") == 0)  index = 7;
-	     else index = 8;
+	     if(strcmp(mode->name, "SIS1280x1024-75") == 0)
+	        index = 7;
+	     else
+	        index = 8;
 	  } else {
 	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
 		switch(width) {
 		case 800:
-		   if((strcmp(mode->name, "PAL800x600U") == 0))
+		   if((strcmp(mode->name, "PAL800x600U") == 0)) {
 		      index = 4;
-		   else
+		      pSiS->sis6326tvumode = TRUE;
+		   } else
 		      index = 0;
 		   break;
 		case 720:
@@ -375,14 +383,15 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 		   break;
 		case 480:
 		default:
-		   if((strcmp(mode->name, "NTSC640x480U") == 0))
+		   if((strcmp(mode->name, "NTSC640x480U") == 0)) {
 		      index = 6;
-		   else
+		      pSiS->sis6326tvumode = TRUE;
+		   } else
 		      index = 2;
 		}
 	     }
 	  }
-	  for(i=0; i<=5; i++) {
+	  for(i = 0; i <= 5; i++) {
 	     pReg->sisRegs3D4[i] = SiS6326CR[index][i];
 	  }
 	  pReg->sisRegs3C4[0x12] = SiS6326CR[index][6];
@@ -511,25 +520,19 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	  /* if SiS_compute_vclk cannot handle the requested clock, try sisCalcClock */
 	  SiSCalcClock(pScrn, clock, 2, vclk);
 
-#define Midx    0
-#define Nidx    1
-#define VLDidx  2
-#define Pidx    3
-#define PSNidx  4
-
-	  pReg->sisRegs3C4[0x2A] = (vclk[Midx] - 1) & 0x7f;
-	  pReg->sisRegs3C4[0x2A] |= ((vclk[VLDidx] == 2) ? 1 : 0) << 7;
+	  pReg->sisRegs3C4[0x2A] = (vclk[SIS_VCLK_Midx] - 1) & 0x7f;
+	  pReg->sisRegs3C4[0x2A] |= ((vclk[SIS_VCLK_VLDidx] == 2) ? 1 : 0) << 7;
 
 	  /* D[4:0]: denumerator */
-	  pReg->sisRegs3C4[0x2B] = (vclk[Nidx] - 1) & 0x1f;
+	  pReg->sisRegs3C4[0x2B] = (vclk[SIS_VCLK_Nidx] - 1) & 0x1f;
 
-	  if(vclk[Pidx] <= 4){
+	  if(vclk[SIS_VCLK_Pidx] <= 4){
 	     /* postscale 1,2,3,4 */
-	     pReg->sisRegs3C4[0x2B] |= (vclk[Pidx] - 1) << 5;
+	     pReg->sisRegs3C4[0x2B] |= (vclk[SIS_VCLK_Pidx] - 1) << 5;
 	     pReg->sisRegs3C4[0x13] &= 0xBF;
 	  } else {
 	     /* postscale 6,8 */
-	     pReg->sisRegs3C4[0x2B] |= ((vclk[Pidx] / 2) - 1) << 5;
+	     pReg->sisRegs3C4[0x2B] |= ((vclk[SIS_VCLK_Pidx] / 2) - 1) << 5;
 	     pReg->sisRegs3C4[0x13] |= 0x40;
 	  }
 	  pReg->sisRegs3C4[0x2B] |= 0x80 ;   /* gain for high frequency */
@@ -577,20 +580,20 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
        pSiS->ValidWidth = FALSE;
     } else {
        switch(pScrn->virtualX * (pSiS->CurrentLayout.bitsPerPixel >> 3)) {
-	 case 1024:
-		pReg->sisRegs3C4[0x27] |= 0x00;
-		break;
-	 case 2048:
-		pReg->sisRegs3C4[0x27] |= 0x10;
-		break;
-	 case 4096:
-		pReg->sisRegs3C4[0x27] |= 0x20;
-		break;
-	 default:
-		/* Invalid logical width */
-		pReg->sisRegs3C4[0x27] |= 0x30;
-		pSiS->ValidWidth = FALSE;
-		break;
+	  case 1024:
+	     pReg->sisRegs3C4[0x27] |= 0x00;
+	     break;
+	  case 2048:
+	     pReg->sisRegs3C4[0x27] |= 0x10;
+	     break;
+	  case 4096:
+	     pReg->sisRegs3C4[0x27] |= 0x20;
+	     break;
+	  default:
+	     /* Invalid logical width */
+	     pReg->sisRegs3C4[0x27] |= 0x30;
+	     pSiS->ValidWidth = FALSE;
+	     break;
        }
     }
 
@@ -601,7 +604,7 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	   (pSiS->oldChipset > OC_SIS6225) &&
 	   ( (pSiS->Chipset != PCI_CHIP_SIS530) ||
 	     (pSiS->CurrentLayout.bitsPerPixel != 24) ) ) {
-	  pReg->sisRegs3C4[0x27] |= 0x80;        /* Enable TQ */
+	  pReg->sisRegs3C4[0x27] |= 0x80;		/* Enable TQ */
 	  if((pSiS->Chipset == PCI_CHIP_SIS530) ||
 	     ((pSiS->Chipset == PCI_CHIP_SIS6326 &&
 	      (pSiS->ChipRev == 0xd0 || pSiS->ChipRev == 0xd1 ||
@@ -609,8 +612,8 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	       pSiS->ChipRev == 0x0a || pSiS->ChipRev == 0x1a ||
 	       pSiS->ChipRev == 0x2a || pSiS->ChipRev == 0x0b ||
 	       pSiS->ChipRev == 0x1b || pSiS->ChipRev == 0x2b) ) ) ) {
-	     /* pReg->sisRegs3C4[0x3D] |= 0x80;  */     /* Queue is 62K (530/620 specs) */
-	     pReg->sisRegs3C4[0x3D] &= 0x7F;         /* Queue is 30K (530/620 specs) */
+	     /* pReg->sisRegs3C4[0x3D] |= 0x80;  */	/* Queue is 62K (530/620 specs) */
+	     pReg->sisRegs3C4[0x3D] &= 0x7F;		/* Queue is 30K (530/620 specs) */
 	  }
 	  /* Locate the TQ at the beginning of the last 64K block of
 	   * video RAM. The address is to be specified in 32K steps.
@@ -619,6 +622,12 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	  if(pSiS->Chipset != PCI_CHIP_SIS530) {	/* 530/620: Reserved (don't touch) */
 	     pReg->sisRegs3C4[0x3C] &= 0xFC; 		/* 6326: Queue is all for 2D */
 	  }						/* 5597: Must be 0           */
+#if 0	  /* if(DRI) */
+	  if(pSiS->Chipset == PCI_CHIP_SIS6326) {
+	     pReg->sisRegs3C4[0x3C] |= 0x10;		/* TQ: 8K for 2D, 24K for 3D */
+	     pReg->sisRegs3C4[0x39] |= 0x04;		/* Enable 3D engine */
+	  }
+#endif
        } else {
 	  pReg->sisRegs3C4[0x27] &= 0x7F;
        }
@@ -647,14 +656,14 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
           if(pSiS->MemClock > 66000) {
              SiSCalcClock(pScrn, pSiS->MemClock, 1, vclk);
 
-             pReg->sisRegs3C4[0x28] = (vclk[Midx] - 1) & 0x7f ;
-             pReg->sisRegs3C4[0x28] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;
-             pReg->sisRegs3C4[0x29] = (vclk[Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
-             if(vclk[Pidx] <= 4) {
-                pReg->sisRegs3C4[0x29] |= (vclk[Pidx] - 1) << 5 ; /* postscale 1,2,3,4 */
+             pReg->sisRegs3C4[0x28] = (vclk[SIS_VCLK_Midx] - 1) & 0x7f ;
+             pReg->sisRegs3C4[0x28] |= ((vclk[SIS_VCLK_VLDidx] == 2 ) ? 1 : 0 ) << 7;
+             pReg->sisRegs3C4[0x29] = (vclk[SIS_VCLK_Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
+             if(vclk[SIS_VCLK_Pidx] <= 4) {
+                pReg->sisRegs3C4[0x29] |= (vclk[SIS_VCLK_Pidx] - 1) << 5; /* postscale 1,2,3,4 */
                 pReg->sisRegs3C4[0x13] &= 0x7F;
              } else {
-                pReg->sisRegs3C4[0x29] |= ((vclk[Pidx] / 2) - 1) << 5 ;  /* postscale 6,8 */
+                pReg->sisRegs3C4[0x29] |= ((vclk[SIS_VCLK_Pidx] / 2) - 1) << 5;  /* postscale 6,8 */
                 pReg->sisRegs3C4[0x13] |= 0x80;
              }
              /* Check programmed memory clock. Enable only to check the above code */
@@ -738,8 +747,6 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	  if(CRT_CPUthresholdLow > 0x1f)  CRT_CPUthresholdLow = 0x1f;
 	  CRT_CPUthresholdHigh = 0x1f;
 	  break;
-       case PCI_CHIP_SIS5597:
-       case PCI_CHIP_SIS6326:
        default:
 	  if(CRT_CPUthresholdLow > 0x0f)  CRT_CPUthresholdLow  = 0x0f;
 	  if(CRT_CPUthresholdHigh > 0x0f) CRT_CPUthresholdHigh = 0x0f;
@@ -770,14 +777,17 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	     pReg->sisRegs3C4[0x0D] |= 0x04;
 	     switch(width) {
 	     case 800:
-	        if((strcmp(mode->name, "PAL800x600U") == 0))  index = 4;
-	        else	        			      index = 3;
+	        if((strcmp(mode->name, "PAL800x600U") == 0)) index = 4;
+	        else	        			     index = 3;
+	        break;
+	     case 720:
+	        index = 5;
 	        break;
-	     case 720: index = 5;  break;
 	     case 640:
-	     default:  index = 2;
+	     default:
+	        index = 2;
 	     }
-	     for(i=0; i<14; i++) {
+	     for(i = 0; i < 14; i++) {
 	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_PAL[index][i];
 	     }
 	     fsc = (SiS6326TVRegs1_PAL[index][2] << 16) |
@@ -785,9 +795,9 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 		   (SiS6326TVRegs1_PAL[index][4]);
 	  } else {
 	     pReg->sisRegs3C4[0x0D] &= ~0x04;
-	     if((strcmp(mode->name, "NTSC640x480U") == 0))  index = 5;
-	     else 					    index = 4;
-	     for(i=0; i<14; i++) {
+	     if((strcmp(mode->name, "NTSC640x480U") == 0)) index = 5;
+	     else 					   index = 4;
+	     for(i = 0; i < 14; i++) {
 	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_NTSC[index][i];
 	     }
 	     fsc = (SiS6326TVRegs1_NTSC[index][2] << 16) |
@@ -805,7 +815,7 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	  tmp |= 0x08;
 	  pReg->sis6326tv[0x43] = tmp;
 	  j = 0; k = 0;
-	  for(i=0; i<=0x44; i++) {
+	  for(i = 0; i <= 0x44; i++) {
 	     if(SiS6326TVRegs1[j] == i) {
 		j++;
 		continue;
@@ -836,66 +846,62 @@ SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
     return TRUE;
 }
 
-/* Init a mode for SiS 300, 315, 330, 340 series
- * This function is now only used for setting up some
- * variables (eg. scrnOffset).
+/* Reset screen pitch (for display hardware, not
+ * for accelerator engines)
+ * pSiS->scrnOffset is constant throughout
+ * server runtime (except for when DGA is active)
  */
-Bool
-SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode)
+
+void
+RecalcScreenPitch(ScrnInfoPtr pScrn)
+{
+    SISPtr pSiS = SISPTR(pScrn);
+
+    pSiS->scrnPitch = pSiS->scrnOffset;
+}
+
+/* Init a mode for SiS 300 series and later.
+ * This function is only used for setting up some
+ * variables.
+ */
+static Bool
+SISNewInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 {
     SISPtr    pSiS = SISPTR(pScrn);
     SISRegPtr pReg = &pSiS->ModeReg;
     UShort    temp;
-    DisplayModePtr realmode = mode;
-
-    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SIS300Init()\n"));
-
-    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
-	"virtualX = %d depth = %d Logical width = %d\n",
-	pScrn->virtualX, pSiS->CurrentLayout.bitsPerPixel,
-	pScrn->virtualX * pSiS->CurrentLayout.bitsPerPixel/8);
-
-#ifdef SISMERGED
-    if(pSiS->MergedFB) {
-       realmode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
-    }
-#endif
 
     /* Copy current register settings to structure */
     (*pSiS->SiSSave)(pScrn, pReg);
 
-    /* Calculate Offset/Display Pitch */
-    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
-                          ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);
-
-    pSiS->scrnPitch = pSiS->scrnPitch2 = pSiS->scrnOffset;
-    if(!(pSiS->VBFlags & CRT1_LCDA)) {
-       if(realmode->Flags & V_INTERLACE) pSiS->scrnPitch <<= 1;
+    /* accelerator framebuffer depth */
+    switch(pSiS->CurrentLayout.bitsPerPixel) {
+    case 8:
+       pSiS->DstColor = 0x0000;
+       pSiS->SiS310_AccelDepth = 0x00000000;
+       break;
+    case 16:
+       pSiS->DstColor = (short) 0x8000;
+       pSiS->SiS310_AccelDepth = 0x00010000;
+       break;
+    case 32:
+       pSiS->DstColor = (short) 0xC000;
+       pSiS->SiS310_AccelDepth = 0x00020000;
+       break;
+    default:
+       return FALSE;
     }
-    /* CRT2 mode can never be interlaced */
+
+    /* scrnOffset is for the accelerator */
+    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth * (pSiS->CurrentLayout.bitsPerPixel >> 3);
+
+    /* display pitch (used by init.c only) */
+    RecalcScreenPitch(pScrn);
 
 #ifdef UNLOCK_ALWAYS
     outSISIDXREG(SISSR, 0x05, 0x86);
 #endif
 
-    switch(pSiS->CurrentLayout.bitsPerPixel) {
-	case 8:
-	    pSiS->DstColor = 0x0000;
-	    pSiS->SiS310_AccelDepth = 0x00000000;
-	    break;
-	case 16:
-	    if(pSiS->CurrentLayout.depth == 15)
-	        pSiS->DstColor = (short) 0x4000;
-	    else
-	        pSiS->DstColor = (short) 0x8000;
-	    pSiS->SiS310_AccelDepth = 0x00010000;
-	    break;
-	case 32:
-	    pSiS->DstColor = (short) 0xC000;
-	    pSiS->SiS310_AccelDepth = 0x00020000;
-	    break;
-    }
-
     /* Enable PCI LINEAR ADDRESSING (0x80), MMIO (0x01), PCI_IO (0x20) */
     pReg->sisRegs3C4[0x20] = 0xA1;
 
@@ -936,7 +942,7 @@ SiS6326TVDelay(ScrnInfoPtr pScrn, int delay)
     int i;
     UChar temp;
 
-    for(i=0; i<delay; i++) {
+    for(i = 0; i < delay; i++) {
        inSISIDXREG(SISSR, 0x05, temp);
     }
     (void)temp;
@@ -983,7 +989,7 @@ SISSense6326(ScrnInfoPtr pScrn)
     if(pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) {
        pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-	    "SiS6326: Detected TV connected to %s output\n",
+	    "Detected TV connected to %s output\n",
 		(((pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ==
 		   (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ?
 			"both SVIDEO and COMPOSITE" :
@@ -991,7 +997,7 @@ SISSense6326(ScrnInfoPtr pScrn)
 				"SVIDEO" : "COMPOSITE")));
     } else {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-	    "SiS6326: No TV detected\n");
+	    "No TV detected\n");
     }
 }
 
@@ -1044,27 +1050,18 @@ void SISVGAPreInit(ScrnInfoPtr pScrn)
 	"302LV",	/* 4 */
 	"301C",		/* 5 */
 	"302ELV",	/* 6 */
-	"302B"		/* 7 */
+	"302B",		/* 7 */
+	"307T",		/* 8 */
+	"307LV"		/* 9 */
     };
 
-    switch(pSiS->Chipset) {
-       case PCI_CHIP_SIS300:
-       case PCI_CHIP_SIS540:
-       case PCI_CHIP_SIS630:
-       case PCI_CHIP_SIS550:
-       case PCI_CHIP_SIS315:
-       case PCI_CHIP_SIS315H:
-       case PCI_CHIP_SIS315PRO:
-       case PCI_CHIP_SIS650:
-       case PCI_CHIP_SIS330:
-       case PCI_CHIP_SIS660:
-       case PCI_CHIP_SIS340:
-       case PCI_CHIP_XGIXG20:
-       case PCI_CHIP_XGIXG40:
-          pSiS->ModeInit = SIS300Init;
-          break;
-       default:
-          pSiS->ModeInit = SISInit;
+    switch(pSiS->VGAEngine) {
+    case SIS_300_VGA:
+    case SIS_315_VGA:
+       pSiS->ModeInit = SISNewInit;
+       break;
+    default:
+       pSiS->ModeInit = SISOldInit;
     }
 
     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
@@ -1076,11 +1073,10 @@ void SISVGAPreInit(ScrnInfoPtr pScrn)
        SISSense6326(pScrn);
     }
 
-    pSiS->VBFlags = pSiS->VBFlags2 = 0; /* reset VBFlags */
+    pSiS->VBFlags = pSiS->VBFlags2 = pSiS->VBFlags3 = pSiS->VBFlags4 = 0;
     pSiS->SiS_Pr->SiS_UseLCDA = FALSE;
     pSiS->SiS_Pr->Backup = FALSE;
 
-    /* Videobridges only available for 300/315/330/340 series */
     if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
        return;
 
@@ -1157,10 +1153,36 @@ void SISVGAPreInit(ScrnInfoPtr pScrn)
 
 	SISSense30x(pScrn, FALSE);
 
-    } else if (temp == 3) {
+    } else if(temp == 3) {
 
 	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "303", "unsupported, unknown", temp, 0);
 
+    } else if(temp == 7) {
+
+	inSISIDXREG(SISPART4, 0x01, temp1);
+	temp1 &= 0xff;
+        inSISIDXREG(SISPART4, 0x39, temp2);
+        if(temp1!=0xE0&&temp1!=0xE1)
+        {
+       	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "307", "unsupported, unknown", 7, temp1);
+        }
+        else
+        {
+            switch(temp2)
+            {
+                case 0xE0:
+      	                pSiS->VBFlags2 |= VB2_307T;
+		        sistypeidx=8;
+		    break;
+	    	case 0xFF:
+      	                pSiS->VBFlags2 |= VB2_307LV;
+		        sistypeidx=9;
+		    break;
+            }
+            xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, SiSVBTypeStr[sistypeidx],
+			(pSiS->VBFlags2 & VB2_SISUMC) ? "UMC-0" : "Charter/UMC-1", 7, temp1);
+	    SISSense30x(pScrn, FALSE);
+        }
     } else {
 
 	if(pSiS->NewCRLayout) {
@@ -1316,7 +1338,7 @@ void SISVGAPreInit(ScrnInfoPtr pScrn)
     }
 #endif
 
-    /* Try to find out if the bridge uses LCDA for low resolution and
+    /* Try to find out if the BIOS uses LCDA for low resolution and
      * text modes. If sisfb saved this for us, use it. Otherwise,
      * check if we are running on a low mode on LCD and read the
      * relevant registers ourselves.
@@ -1327,7 +1349,6 @@ void SISVGAPreInit(ScrnInfoPtr pScrn)
           if(pSiS->sisfblcda != 0xff) {
 	     if((pSiS->sisfblcda & 0x03) == 0x03) {
 		pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
-		pSiS->ChipFlags |= SiSCF_UseLCDA;
 	     }
 	  } else {
              inSISIDXREG(SISCR,0x34,temp);
@@ -1335,21 +1356,19 @@ void SISVGAPreInit(ScrnInfoPtr pScrn)
 		inSISIDXREG(SISCR,0x38,temp);
 		if((temp & 0x03) == 0x03) {
 		   pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
-		   pSiS->ChipFlags |= SiSCF_UseLCDA;
 		   pSiS->SiS_Pr->Backup = TRUE;
 		} else {
 		   orSISIDXREG(SISPART1,0x2f,0x01);  /* Unlock CRT2 */
 		   inSISIDXREG(SISPART1,0x13,temp);
 		   if(temp & 0x04) {
 		      pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
-		      pSiS->ChipFlags |= SiSCF_UseLCDA;
 		      pSiS->SiS_Pr->Backup = TRUE;
 		   }
 		}
 	     }
 	  }
-	  if(pSiS->ChipFlags & SiSCF_UseLCDA) {
-	     xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 3,
+	  if(pSiS->SiS_Pr->SiS_UseLCDA) {
+	     xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
 		"BIOS uses LCDA for low resolution and text modes\n");
 	     if(pSiS->SiS_Pr->Backup == TRUE) {
 		inSISIDXREG(SISCR,0x34,pSiS->SiS_Pr->Backup_Mode);
@@ -1498,6 +1517,7 @@ SiSVGASaveMode(ScrnInfoPtr pScrn, SISRegPtr save)
     for(i = 0; i < 25; i++) {
        inSISIDXREG(SISCR, i, save->sisRegs3D4[i]);
     }
+    inSISIDXREG(SISCR, 0x7d, save->sisRegs3D4[0x7d]);
 
     SiS_EnablePalette(pSiS);
     for(i = 0; i < 21; i++) {
@@ -1631,6 +1651,8 @@ SiSVGARestoreMode(ScrnInfoPtr pScrn, SISRegPtr restore)
     for(i = 0; i < 25; i++) {
        outSISIDXREG(SISCR, i, restore->sisRegs3D4[i]);
     }
+    outSISIDXREG(SISCR, 0x7d, restore->sisRegs3D4[0x7d]);
+
 
     for(i = 0; i < 9; i++) {
        outSISIDXREG(SISGR, i, restore->sisRegsGR[i]);
@@ -1717,8 +1739,13 @@ SiSVGAMapMem(ScrnInfoPtr pScrn)
     if(pSiS->VGAMapPhys == 0) pSiS->VGAMapPhys = 0xA0000;
 
 #if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
+#if XSERVER_LIBPCIACCESS
+    pSiS->VGAMemBase = xf86MapDomainMemory(pScrn->scrnIndex, VIDMEM_MMIO_32BIT,
+			pSiS->PciInfo, pSiS->VGAMapPhys, pSiS->VGAMapSize);
+#else
     pSiS->VGAMemBase = xf86MapDomainMemory(pScrn->scrnIndex, VIDMEM_MMIO_32BIT,
 			pSiS->PciTag, pSiS->VGAMapPhys, pSiS->VGAMapSize);
+#endif
 #else
     pSiS->VGAMemBase = xf86MapVidMem(pScrn->scrnIndex, VIDMEM_MMIO_32BIT,
 			pSiS->VGAMapPhys, pSiS->VGAMapSize);
@@ -1801,7 +1828,7 @@ SiS_VBlankKGA(DisplayModePtr mode, SISRegPtr regp, int nBits, unsigned int Flags
     return (ExtBits >> 8);
 }
 
-Bool
+static Bool
 SiSVGAInit(ScrnInfoPtr pScrn, DisplayModePtr mode, int fixsync)
 {
     SISPtr pSiS = SISPTR(pScrn);
diff --git a/src/sis_video.c b/src/sis_video.c
index 19a393b..a399c0b 100644
--- a/src/sis_video.c
+++ b/src/sis_video.c
@@ -47,13 +47,14 @@
  *  SiSM650/651: Full register range, two overlays (one used for CRT1, one for CRT2)
  *  SiS330: Full register range, one overlay (used for both CRT1 and CRT2 alt.)
  *  SiS661/741/760: Full register range, two overlays (one used for CRT1, one for CRT2)
- *  SiS340: - ? overlays. Extended registers for DDA.
- *  SiS761: - ? overlays. Extended registers for DDA.
- *  XGI Volari V3XT/V5/V8: 1 Overlay. Extended registers for DDA.
+ *  SiS340: One overlay. Extended registers for 4-tap scaler.
+ *  SiS761: One overlay. Extended registers for 4-tap scaler.
+ *  SiS670/770: Two overlays. Extended registers for 4-tap scaler.
+ *  XGI Volari V3XT/V5/V8: One overlay. Extended registers for 4-tap scaler.
  *
  * Help for reading the code:
- * 315/550/650/740/M650/651/330/661/741/76x/340/XGI = SIS_315_VGA
- * 300/630/730                                      = SIS_300_VGA
+ * >=315           = SIS_315_VGA
+ * 300/540/630/730 = SIS_300_VGA
  * For chipsets with 2 overlays, hasTwoOverlays will be true
  *
  * Notes on display modes:
@@ -86,18 +87,23 @@
  *
  * About the video blitter:
  * The video blitter adaptor supports 16 ports. By default, adaptor 0 will
- * be the overlay adaptor, adaptor 1 the video blitter. The option XvDefaultAdaptor
- * allows reversing this.
- * Since SiS does not provide information on the 3D engine, I could not
- * implement scaling. Instead, the driver paints a black border around the unscaled
- * video if the destination area is bigger than the video.
- *
+ * be the overlay adaptor, adaptor 1 the video blitter.
+ * The option XvDefaultAdaptor allows reversing this.
+ * The video blitter will automatically kick in when the overlay is not
+ * available (such as in display modes with too high dotclocks) or not useful
+ * (such as if the display mode is interlaced) or if the overlay is not
+ * suitable for the video material (such as if the source width is beyond
+ * hardware limits).
+ * The video blitter supports scaling the video since 2005/09/25.
+ * Naturally, it does not support the Xv properties.
  */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-
+/*
+#define XVDEBUG
+*/
 #include "sis.h"
 #ifdef SIS_USE_XAA
 #include "xf86fbman.h"
@@ -123,21 +129,23 @@
 
 #include "sis_video.h"
 
+void SiSInitMC(ScreenPtr pScreen);
+
 /*********************************
  *       Raw register access     *
  *********************************/
 
-#if 0
+
 static CARD32 _sisread(SISPtr pSiS, CARD32 reg)
 {
-    return *(pSiS->IOBase + reg);
+    SIS_MMIO_IN32(pSiS->IOBase, reg);
 }
 
 static void _siswrite(SISPtr pSiS, CARD32 reg, CARD32 data)
 {
-    *(pSiS->IOBase + reg) = data;
+    SIS_MMIO_OUT32(pSiS->IOBase, reg, data);
 }
-#endif
+
 
 static CARD8 getsrreg(SISPtr pSiS, CARD8 reg)
 {
@@ -188,8 +196,7 @@ static CARD8 vblank_active_CRT2(SISPtr pSiS, SISPortPrivPtr pPriv)
     return(ret & 0x02);  /* Verified */
 }
 
-/* Scanline - unused */
-#if 0
+
 static CARD16 get_scanline_CRT1(SISPtr pSiS)
 {
     CARD32 line;
@@ -199,7 +206,6 @@ static CARD16 get_scanline_CRT1(SISPtr pSiS)
 
     return((CARD16)((line >> 16) & 0x07FF));
 }
-#endif
 
 static CARD16 get_scanline_CRT2(SISPtr pSiS, SISPortPrivPtr pPriv)
 {
@@ -235,9 +241,9 @@ static void
 SiSComputeXvGamma(SISPtr pSiS)
 {
     int num = 255, i;
-    double red = 1.0 / (double)((double)pSiS->XvGammaRed / 1000);
-    double green = 1.0 / (double)((double)pSiS->XvGammaGreen / 1000);
-    double blue = 1.0 / (double)((double)pSiS->XvGammaBlue / 1000);
+    double red = 1.0 / (double)((double)pSiS->XvGammaRed / 1000.0);
+    double green = 1.0 / (double)((double)pSiS->XvGammaGreen / 1000.0);
+    double blue = 1.0 / (double)((double)pSiS->XvGammaBlue / 1000.0);
 
     for(i = 0; i <= num; i++) {
         pSiS->XvGammaRampRed[i] =
@@ -312,14 +318,27 @@ SISInitVideo(ScreenPtr pScreen)
        SISInitOffscreenImages(pScreen);
     }
 
+    pSiS->HaveBlitAdaptor = FALSE;
+
 #ifdef INCL_YUV_BLIT_ADAPTOR
     if( ( (pSiS->ChipFlags & SiSCF_Is65x) ||
-          (pSiS->ChipType >= SIS_330) ) &&
+          (pSiS->ChipType >= SIS_330) )		&&
+        (pSiS->ChipType != XGI_20)		&&
         (pScrn->bitsPerPixel != 8) ) {
-       newBlitAdaptor = SISSetupBlitVideo(pScreen);
+       if((newBlitAdaptor = SISSetupBlitVideo(pScreen))) {
+          pSiS->HaveBlitAdaptor = TRUE;
+       }
     }
 #endif
 
+     /* There is a bug with the overlay on the TV of NTSC.
+       * We suppose it is a HW issue.
+       * Therefor we avoid it */
+    if(pSiS->ChipType == SIS_662 && (pSiS->VBFlags & TV_NTSC) &&
+		(pSiS->XvOnCRT2 || pSiS->MergedFB))
+        pSiS->XvDefAdaptorBlit = TRUE;
+		
+
     num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
 
     if(newAdaptor || newBlitAdaptor) {
@@ -360,6 +379,10 @@ SISInitVideo(ScreenPtr pScreen)
     if(newAdaptors) {
        xfree(newAdaptors);
     }
+
+#ifdef ENABLEXvMC
+    SiSInitMC(pScreen);
+#endif 
 }
 
 /*********************************
@@ -403,9 +426,6 @@ SISSetPortDefaults(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
        pPriv->updatetvxpos = TRUE;
        pPriv->updatetvypos = TRUE;
     }
-#ifdef SIS_CP
-    SIS_CP_VIDEO_DEF
-#endif
     if(pPriv->dualHeadMode) {
 #ifdef SISDUALHEAD
        pPriv->crtnum =
@@ -430,6 +450,7 @@ SISResetVideo(ScrnInfoPtr pScrn)
 {
     SISPtr pSiS = SISPTR(pScrn);
     SISPortPrivPtr pPriv = GET_PORT_PRIVATE(pScrn);
+    int i;
 
     /* Unlock registers */
 #ifdef UNLOCK_ALWAYS
@@ -439,9 +460,10 @@ SISResetVideo(ScrnInfoPtr pScrn)
        setvideoreg (pSiS, Index_VI_Passwd, 0x86);
        if(getvideoreg (pSiS, Index_VI_Passwd) != 0xa1)
 	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		 "Xv: Video password could not unlock registers\n");
+		 "Xv: Failed to unlock video registers\n");
     }
 
+
     /* Initialize first overlay (CRT1) ------------------------------- */
 
     /* This bit has obviously a different meaning on 315 series (linebuffer-related) */
@@ -476,19 +498,32 @@ SISResetVideo(ScrnInfoPtr pScrn)
     setvideoreg(pSiS, Index_VI_Disp_Y_UV_Buf_Preset_High, 0x00);
     setvideoreg(pSiS, Index_VI_Play_Threshold_Low,        0x00);
     setvideoreg(pSiS, Index_VI_Play_Threshold_High,       0x00);
+
+    /* Clear multi-purpose bits in Overlay_OP */
+    /* (On 550, this selects transparency, for others see below) */
+    setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0xF0);
+
     if(pSiS->Chipset == PCI_CHIP_SIS330) {
-       /* Disable contrast enhancement (?) */
+
+       /* Disable contrast enhancement */
        setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0x10);
+
     } else if(pPriv->is661741760) {
+
+       /* Disable contrast enhancement */
+       setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0x10);
+
+       /* Clear extended threshold and linebuffer size bits */
        setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0xE0);
        if(pPriv->is760) {
           setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, 0x3c, 0x3c);
        } else { /* 661, 741 */
           setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, 0x2c, 0x3c);
        }
+
     } else if((pSiS->Chipset == PCI_CHIP_SIS340) ||
-	      (pSiS->Chipset == PCI_CHIP_XGIXG20) ||
 	      (pSiS->Chipset == PCI_CHIP_XGIXG40)) {
+
        /* Disable contrast enhancement (?) */
        setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0x10);
        /* Threshold high */
@@ -501,21 +536,80 @@ SISResetVideo(ScrnInfoPtr pScrn)
        setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x20, 0x20);
        /* "Disable video processor" */
        setsrregmask(pSiS, 0x3f, 0x00, 0x02);
+
     } else if(pPriv->is761) {
+
        /* Disable contrast enhancement (?) */
        setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0x10);
        /* Threshold high */
        setvideoregmask(pSiS, 0xb5, 0x00, 0x01);
        setvideoregmask(pSiS, 0xb6, 0x00, 0x01);
+       /* TODO: "bug of flash line and right side garbage in 761GX A1" */
+       /* 761GX A0: VRB6[3] = 1, 761GX A1: ? */
+       setvideoregmask(pSiS, 0xb5, 0x00, 0x06); /* = default */
+       if(pSiS->ChipFlags & SiSCF_761A0) {
+          setvideoregmask(pSiS, 0xb6, 0x08, 0x08); /* ? */
+       } else {
+          setvideoregmask(pSiS, 0xb6, 0x00, 0x08); /* ? */
+       }
+       /* ? */
+       /* setvideoregmask(pSiS, 0xb6, 0x02, 0x02); */
+       /* Enable horizontal, disable vertical 4-tap DDA scaler */
+       setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x40, 0xC0);
+       set_dda_regs(pSiS, 1.0);
+       /* Enable software-flip - FIXME */
+       setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x20, 0x20);
+       /* Disable 661/741/760 workaround */
+       setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, 0x00, 0x3c);
+       /* "Disable video processor" */
+       setsrregmask(pSiS, 0x3f, 0x00, 0x02);
+
+	/* 	chaoyu add: fix error due to default values (from VBIOS?)  */
+	if(pSiS->ChipType == SIS_662){
+		setvideoreg(pSiS, Index_VI_Threshold_Ext_Low, 0x00);
+		setvideoreg(pSiS, Index_VI_Threshold_Ext_High, 0x00);
+		setvideoreg(pSiS, Index_VI_Line_Buffer_Size_High, 0x00);
+		setvideoreg(pSiS, Index_VI_SubPict_Threshold_Ext, 0x08);		
+	}
+
+    } else if(pPriv->is670) {
+    
+       /* Disable contrast enhancement (?) */
+       setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0x10);
+       /* Threshold high */
+       setvideoregmask(pSiS, 0xb5, 0x00, 0x01);
+       setvideoregmask(pSiS, 0xb6, 0x00, 0x07);
        /* Enable horizontal, disable vertical 4-tap DDA scaler */
        setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x40, 0xC0);
        /* ? */
-       setvideoregmask(pSiS, 0xb6, 0x02, 0x02);
+       /* setvideoregmask(pSiS, 0xb6, 0x02, 0x02); */
        set_dda_regs(pSiS, 1.0);
        setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, 0x00, 0x3c);
+
+	/* chaoyu add: patch some errors */
+	setvideoregmask(pSiS, Index_VI_Control_Misc4, 0x00, 0x01);/* Disable 4-taps DDA scaler */
+	setvideoregmask(pSiS, Index_VI_MCE_Control_Misc1, 0x00, 0x01);/* fix the green screen error */
+	setvideoreg(pSiS, Index_VI_FIFO_Max, 0x00);/* fix hanging error */
+	
+	setvideoreg(pSiS, Index_VI_Threshold_Ext_Low, 0x00);
+	setvideoreg(pSiS, Index_VI_Threshold_Ext_High, 0x00);
+	setvideoreg(pSiS, Index_VI_Line_Buffer_Size_High, 0x02);
+	setvideoreg(pSiS, Index_VI_SubPict_Threshold_Ext, 0x00);/* fix the sawtooth error */	
+	
+	/* TODO: we set VRb9 & VRba fixed values, but we should not do so. */
+	setvideoreg(pSiS, Source_VertLine_Number_Low, 0x28);
+	setvideoreg(pSiS, Source_VertLine_Number_High, 0xf4);
+
+	/* Disable MCE Subpicture*/
+	setvideoreg(pSiS, Index_VI_MCE_Control_Misc3, 0x00);
+	
     }
 
-    if((pSiS->ChipFlags & SiSCF_Is65x) || (pPriv->is661741760)) {
+    /* Disable "video only" */
+    if((pSiS->ChipFlags & SiSCF_Is65x)	||
+       pPriv->is661741760		||
+       pPriv->is761			||
+       pPriv->is670) {
        setvideoregmask(pSiS, Index_VI_Control_Misc2,  0x00, 0x04);
     }
 
@@ -523,7 +617,7 @@ SISResetVideo(ScrnInfoPtr pScrn)
     setvideoreg(pSiS, Index_VI_Win_Ver_Disp_Start_Low, 0x00);
     setvideoreg(pSiS, Index_VI_Win_Ver_Over, 0x00);
 
-    /* Initialize second overlay (CRT2) - only for 300, 630/730, 550, M650/651, 661/741/660/760 */
+    /* Initialize second overlay (CRT2) */
     if(pSiS->hasTwoOverlays) {
 
 	if(pSiS->VGAEngine == SIS_300_VGA) {
@@ -558,7 +652,12 @@ SISResetVideo(ScrnInfoPtr pScrn)
 	setvideoreg(pSiS, Index_VI_Play_Threshold_Low,        0x00);
 	setvideoreg(pSiS, Index_VI_Play_Threshold_High,       0x00);
 
+	/* Clear multi-purpose bits in Overlay_OP */
+	/* (On 550, this selects transparency, for others see below) */
+	setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0xF0);
+
 	if(pPriv->is661741760) {
+
 	   CARD8 temp;
 	   setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0xE0);
 	   switch(pSiS->ChipType) {
@@ -567,15 +666,16 @@ SISResetVideo(ScrnInfoPtr pScrn)
 	   default: 	 temp = 0x3c;
 	   }
 	   setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, temp, 0x3c);
-	} else if(pPriv->is761) {
+
+	} else if(pPriv->is761) {	/* Perhaps only one overlay */
+
 	   setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, 0x00, 0x3c);
-	} else if(pSiS->Chipset == PCI_CHIP_SIS340) {  /* 2 overlays? */
-	   setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x00, 0x10);
-	   setvideoregmask(pSiS, 0xb5, 0x00, 0x01);
-	   setvideoregmask(pSiS, 0xb6, 0x00, 0x01);
-	   setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x40, 0xC0);
-	   set_dda_regs(pSiS, 1.0);
-           setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, 0x20, 0x20);
+
+	} else if(pPriv->is670) {
+
+	   /* FIXME */
+	   setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, 0x00, 0x3c);
+
 	}
 
 	setvideoreg(pSiS, Index_VI_Win_Ver_Disp_Start_Low, 0x00);
@@ -614,6 +714,8 @@ SISResetVideo(ScrnInfoPtr pScrn)
 #endif
 }
 
+
+
 /*********************************
  *       Set displaymode         *
  *********************************/
@@ -622,8 +724,8 @@ SISResetVideo(ScrnInfoPtr pScrn)
  * MIRROR mode is only available on chipsets with two overlays.
  * On the other chipsets, if only CRT1 or only CRT2 are used,
  * the correct display CRT is chosen automatically. If both
- * CRT1 and CRT2 are connected, the user can choose between CRT1 and
- * CRT2 by using the option XvOnCRT2.
+ * CRT1 and CRT2 are connected, the user can choose between
+ * CRT1 and CRT2 by using the option XvOnCRT2.
  */
 
 static void
@@ -640,7 +742,7 @@ set_dispmode(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
     if( (pSiS->VBFlags & VB_DISPMODE_MIRROR) ||
         ((pPriv->bridgeIsSlave) && (pSiS->VBFlags & DISPTYPE_DISP2)) )  {
        if(pPriv->hasTwoOverlays)
-	   pPriv->displayMode = DISPMODE_MIRROR;     /* CRT1+CRT2 (2 overlays) */
+	   pPriv->displayMode = DISPMODE_MIRROR;    /* CRT1+CRT2 (2 overlays) */
        else if(pPriv->crtnum)
 	  pPriv->displayMode = DISPMODE_SINGLE2;    /* CRT2 only */
        else
@@ -664,7 +766,7 @@ set_dispmode(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
 }
 
 static void
-set_disptype_regs(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
+set_disptype_regs(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv, Bool useoverlay1, Bool useoverlay2)
 {
     SISPtr pSiS = SISPTR(pScrn);
 #ifdef SISDUALHEAD
@@ -693,6 +795,10 @@ set_disptype_regs(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
      * SR06/32 to 0xc0 DOES NOT WORK. THAT'S CONFIRMED.
      * Therefore, we use overlay 0 on CRT2 if in SINGLE2 mode.
      *
+     * Addendum: Since we can scale better if using dual line buffer
+     * merge on 315 series, we use overlay 0 in MergedFB mode if
+     * only one overlay is needed currently.
+     *
      * For chipsets with only one overlay, user must choose whether
      * to display the overlay on CRT1 or CRT2 by setting XvOnCRT2
      * to TRUE (CRT2) or FALSE (CRT1). The driver does this auto-
@@ -702,8 +808,8 @@ set_disptype_regs(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
     sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
 #endif
 
-    switch (pPriv->displayMode)
-    {
+    switch(pPriv->displayMode) {
+
        case DISPMODE_SINGLE1:				/* CRT1-only mode: */
 	  if(pPriv->hasTwoOverlays) {
 	      if(pPriv->dualHeadMode) {
@@ -753,31 +859,92 @@ set_disptype_regs(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
 
        case DISPMODE_MIRROR:				/* CRT1+CRT2-mode: (only on chips with 2 overlays) */
        default:
-	  setsrregmask(pSiS, 0x06, 0x80, 0xc0);         /* overlay 0 -> CRT1, overlay 1 -> CRT2 */
-	  setsrregmask(pSiS, 0x32, 0x80, 0xc0);
+#ifdef SISMERGED
+	  if(!pSiS->MergedFB			||
+	     pSiS->VGAEngine == SIS_300_VGA	||
+	     (useoverlay1 && useoverlay2)) {
+#endif
+	     setsrregmask(pSiS, 0x06, 0x80, 0xc0);      /* overlay 0 -> CRT1, overlay 1 -> CRT2 */
+	     setsrregmask(pSiS, 0x32, 0x80, 0xc0);
+#ifdef SISMERGED
+	  } else if(useoverlay1) {			/* (unless we only use one, make this 0 in any case) */
+	     setsrregmask(pSiS, 0x06, 0x00, 0xc0);
+	     setsrregmask(pSiS, 0x32, 0x00, 0xc0);
+	  } else {
+	     setsrregmask(pSiS, 0x06, 0x40, 0xc0);
+	     setsrregmask(pSiS, 0x32, 0xc0, 0xc0);
+	  }
+#endif
 	  break;
     }
 }
 
+
+
+/* interface for XvMC to reset overlay */
+void
+SISXvMCResetVideo(ScrnInfoPtr pScrn){
+
+   SISPortPrivPtr pPriv = GET_PORT_PRIVATE(pScrn);
+
+   pPriv->overlayStatus = TRUE;
+
+
+   /* Choosing the overlay. */ 
+   set_dispmode(pScrn, pPriv);
+   set_disptype_regs(pScrn, pPriv, TRUE, TRUE);
+
+   SISResetVideo(pScrn);
+}
+
+
 static void
-set_hastwooverlays(SISPtr pSiS, SISPortPrivPtr pPriv)
+disableoverlay(SISPtr pSiS, SISPortPrivPtr pPriv, int ovnum)
 {
-    int temp, watchdog;
+   int i;
+   int ovcheck = ovnum ? 0x80 : 0x40;
+   unsigned int watchdog;
+   unsigned char temp = getvideoreg(pSiS, Index_VI_Control_Misc0);
+
+  if(temp & 0x02) {
+      temp = getsrreg(pSiS, 0x06);
+      watchdog = WATCHDOG_DELAY;
+      if(!(temp & ovcheck)) {
+	 while((!vblank_active_CRT1(pSiS, pPriv)) && --watchdog);
+	 watchdog = WATCHDOG_DELAY;
+	 while(vblank_active_CRT1(pSiS, pPriv) && --watchdog);
+      } else {
+         while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
+	 watchdog = WATCHDOG_DELAY;
+	 while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
+      }
+      
+      setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
+      /********************************************************
+        Reset the poistion of overlay:
+        On 662 (and later?), the position of overaly can't not be beyond the 
+        screen, or the overlay crashes. However switching mode of lower 
+        resolution may cause these situations. For safty, we shall trun off 
+        the overlay by setting VR30[1] as 0. This value will be loaded actually 
+        ONLY after VR74[0] is set as 1.
+      *********************************************************/
+      if(pSiS->ChipType == SIS_662){
+         setvideoreg(pSiS, Index_VI_Control_Misc3, 0x01);
+         setvideoreg(pSiS, Index_VI_Control_Misc3, 0x00);/* reset */
+       }
+   }
+}
 
+static void
+set_hastwooverlays(SISPtr pSiS, SISPortPrivPtr pPriv)
+{
     if(pSiS->hasTwoOverlays) {
        if(pSiS->MiscFlags & MISC_SIS760ONEOVERLAY) {
           if(pPriv->hasTwoOverlays) {
 	     /* Disable overlay 1 on change */
 	     setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x01, 0x01);
 	     setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
-	     temp = getvideoreg(pSiS,Index_VI_Control_Misc0);
-	     if(temp & 0x02) {
-	        watchdog = WATCHDOG_DELAY;
-	        while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
-	        watchdog = WATCHDOG_DELAY;
-	        while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
-	        setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-	     }
+	     disableoverlay(pSiS, pPriv, 1);
 	  }
           pPriv->hasTwoOverlays = FALSE;
        } else {
@@ -818,8 +985,7 @@ set_maxencoding(SISPtr pSiS, SISPortPrivPtr pPriv)
           half = 768 * 2;
        } else if(pPriv->is340) { /* 2 overlays? */
           DummyEncoding.width = IMAGE_MAX_WIDTH_340;
-	  half = 1280; /* ? */
-       } else if(pPriv->is761) {
+       } else if(pPriv->is761 || pPriv->is670) {
           DummyEncoding.width = IMAGE_MAX_WIDTH_761;
           half = 1920; /* ? */
        }
@@ -904,22 +1070,28 @@ SISSetupImageVideo(ScreenPtr pScreen)
     pPriv->grabbedByV4L= FALSE;
     pPriv->NoOverlay   = FALSE;
     pPriv->PrevOverlay = FALSE;
-    pPriv->is661741760 = ((pSiS->ChipType >= SIS_661) &&
+    pPriv->is661741760 = ((pSiS->ChipType >= SIS_661)  &&
 			  (pSiS->ChipType <= SIS_760)) ? TRUE : FALSE;
     pPriv->is760       = (pSiS->ChipType == SIS_760)   ? TRUE : FALSE;
-    pPriv->is761       = (pSiS->ChipType == SIS_761)   ? TRUE : FALSE;
-    pPriv->is340       = (pSiS->Chipset == PCI_CHIP_SIS340) ? TRUE : FALSE;
-    pPriv->isXGI       = (pSiS->Chipset == PCI_CHIP_XGIXG20 ||
-			  pSiS->Chipset == PCI_CHIP_XGIXG40) ? TRUE : FALSE;
+    pPriv->is340       = ((pSiS->ChipType >= SIS_340)  &&
+			  (pSiS->ChipType <= SIS_342)) ? TRUE : FALSE;
+    pPriv->is761       = ((pSiS->ChipType >= SIS_761) &&
+			  (pSiS->ChipType <= SIS_662)) ? TRUE : FALSE;
+    pPriv->is670       = ((pSiS->ChipType >= SIS_670) && 
+			  (pSiS->ChipType <= SIS_671)) ? TRUE : FALSE;
+    pPriv->isXGI       = (pSiS->ChipType >= XGI_40)    ? TRUE : FALSE;
 
     /* Setup chipset type helpers */
     set_hastwooverlays(pSiS, pPriv);
     set_allowswitchcrt(pSiS, pPriv);
 
     pPriv->havetapscaler = FALSE;
-    if(pPriv->is340 || pPriv->is761 || pPriv->isXGI) {
+    if(pPriv->is340 || pPriv->is761 || pPriv->is670 ||pPriv->isXGI) {
        pPriv->havetapscaler = TRUE;
     }
+    if( pPriv->is761 || pPriv->is670)	pPriv->PitchAlignmentMask = 63; /* 256 alignment */	
+    else /* old chips */  pPriv->PitchAlignmentMask = 7;
+		
 
     adapt->pPortPrivates[0].ptr = (pointer)(pPriv);
     if(pSiS->VGAEngine == SIS_300_VGA) {
@@ -928,7 +1100,7 @@ SISSetupImageVideo(ScreenPtr pScreen)
        adapt->nAttributes = SiSCountAttributes(&SISAttributes_300[0]);
     } else {
        if(pSiS->ChipType >= SIS_330) {
-          adapt->nImages = NUM_IMAGES_330;
+	   	adapt->nImages = NUM_IMAGES_330;
        } else {
           adapt->nImages = NUM_IMAGES_315;
        }
@@ -949,6 +1121,7 @@ SISSetupImageVideo(ScreenPtr pScreen)
     adapt->GetPortAttribute = SISGetPortAttribute;
     adapt->QueryBestSize = SISQueryBestSize;
     adapt->PutImage = SISPutImage;
+    adapt->ReputImage = SISReputImage;
     adapt->QueryImageAttributes = SISQueryImageAttributes;
 
     /* gotta uninit this someplace */
@@ -981,83 +1154,20 @@ SISSetupImageVideo(ScreenPtr pScreen)
     pSiS->xvYUVChromakey      = MAKE_ATOM(sisxvyuvchromakey);
     pSiS->xvChromaMin	      = MAKE_ATOM(sisxvchromamin);
     pSiS->xvChromaMax         = MAKE_ATOM(sisxvchromamax);
-#ifdef SISDEINT
-    pSiS->xvdeintmeth	      = MAKE_ATOM(sisxvdeinterlace);
-#endif
-#ifdef XV_SD_DEPRECATED
-    pSiS->xv_QVF              = MAKE_ATOM(sisxvqueryvbflags);
-    pSiS->xv_GDV	      = MAKE_ATOM(sisxvsdgetdriverversion);
-    pSiS->xv_GHI	      = MAKE_ATOM(sisxvsdgethardwareinfo);
-    pSiS->xv_GBI	      = MAKE_ATOM(sisxvsdgetbusid);
-    pSiS->xv_QVV              = MAKE_ATOM(sisxvsdqueryvbflagsversion);
-    pSiS->xv_GSF              = MAKE_ATOM(sisxvsdgetsdflags);
-    pSiS->xv_GSF2             = MAKE_ATOM(sisxvsdgetsdflags2);
-    pSiS->xv_USD              = MAKE_ATOM(sisxvsdunlocksisdirect);
-    pSiS->xv_SVF              = MAKE_ATOM(sisxvsdsetvbflags);
-    pSiS->xv_QDD	      = MAKE_ATOM(sisxvsdquerydetecteddevices);
-    pSiS->xv_CT1	      = MAKE_ATOM(sisxvsdcrt1status);
-    pSiS->xv_CMD	      = MAKE_ATOM(sisxvsdcheckmodeindexforcrt2);
-    pSiS->xv_CMDR	      = MAKE_ATOM(sisxvsdresultcheckmodeindexforcrt2);
-    pSiS->xv_RDT	      = MAKE_ATOM(sisxvsdredetectcrt2);
-    pSiS->xv_TAF	      = MAKE_ATOM(sisxvsdsisantiflicker);
-    pSiS->xv_TSA	      = MAKE_ATOM(sisxvsdsissaturation);
-    pSiS->xv_TEE	      = MAKE_ATOM(sisxvsdsisedgeenhance);
-    pSiS->xv_COC	      = MAKE_ATOM(sisxvsdsiscolcalibc);
-    pSiS->xv_COF	      = MAKE_ATOM(sisxvsdsiscolcalibf);
-    pSiS->xv_CFI	      = MAKE_ATOM(sisxvsdsiscfilter);
-    pSiS->xv_YFI	      = MAKE_ATOM(sisxvsdsisyfilter);
-    pSiS->xv_TCO	      = MAKE_ATOM(sisxvsdchcontrast);
-    pSiS->xv_TTE	      = MAKE_ATOM(sisxvsdchtextenhance);
-    pSiS->xv_TCF	      = MAKE_ATOM(sisxvsdchchromaflickerfilter);
-    pSiS->xv_TLF	      = MAKE_ATOM(sisxvsdchlumaflickerfilter);
-    pSiS->xv_TCC	      = MAKE_ATOM(sisxvsdchcvbscolor);
-    pSiS->xv_OVR	      = MAKE_ATOM(sisxvsdchoverscan);
-    pSiS->xv_SGA	      = MAKE_ATOM(sisxvsdenablegamma);
-    pSiS->xv_TXS	      = MAKE_ATOM(sisxvsdtvxscale);
-    pSiS->xv_TYS	      = MAKE_ATOM(sisxvsdtvyscale);
-    pSiS->xv_GSS	      = MAKE_ATOM(sisxvsdgetscreensize);
-    pSiS->xv_BRR	      = MAKE_ATOM(sisxvsdstorebrir);
-    pSiS->xv_BRG	      = MAKE_ATOM(sisxvsdstorebrig);
-    pSiS->xv_BRB	      = MAKE_ATOM(sisxvsdstorebrib);
-    pSiS->xv_PBR	      = MAKE_ATOM(sisxvsdstorepbrir);
-    pSiS->xv_PBG	      = MAKE_ATOM(sisxvsdstorepbrig);
-    pSiS->xv_PBB	      = MAKE_ATOM(sisxvsdstorepbrib);
-    pSiS->xv_BRR2	      = MAKE_ATOM(sisxvsdstorebrir2);
-    pSiS->xv_BRG2	      = MAKE_ATOM(sisxvsdstorebrig2);
-    pSiS->xv_BRB2	      = MAKE_ATOM(sisxvsdstorebrib2);
-    pSiS->xv_PBR2	      = MAKE_ATOM(sisxvsdstorepbrir2);
-    pSiS->xv_PBG2	      = MAKE_ATOM(sisxvsdstorepbrig2);
-    pSiS->xv_PBB2	      = MAKE_ATOM(sisxvsdstorepbrib2);
-    pSiS->xv_GARC2	      = MAKE_ATOM(sisxvsdstoregarc2);
-    pSiS->xv_GAGC2	      = MAKE_ATOM(sisxvsdstoregagc2);
-    pSiS->xv_GABC2	      = MAKE_ATOM(sisxvsdstoregabc2);
-    pSiS->xv_BRRC2	      = MAKE_ATOM(sisxvsdstorebrirc2);
-    pSiS->xv_BRGC2	      = MAKE_ATOM(sisxvsdstorebrigc2);
-    pSiS->xv_BRBC2	      = MAKE_ATOM(sisxvsdstorebribc2);
-    pSiS->xv_PBRC2	      = MAKE_ATOM(sisxvsdstorepbrirc2);
-    pSiS->xv_PBGC2	      = MAKE_ATOM(sisxvsdstorepbrigc2);
-    pSiS->xv_PBBC2	      = MAKE_ATOM(sisxvsdstorepbribc2);
-    pSiS->xv_SHC	      = MAKE_ATOM(sisxvsdhidehwcursor);
-    pSiS->xv_PMD	      = MAKE_ATOM(sisxvsdpanelmode);
 #ifdef TWDEBUG
     pSiS->xv_STR	      = MAKE_ATOM(sisxvsetreg);
 #endif
-#endif /* XV_SD_DEPRECATED */
-#ifdef SIS_CP
-    SIS_CP_VIDEO_ATOMS
-#endif
 
     pSiS->xv_sisdirectunlocked = 0;
-#ifdef XV_SD_DEPRECATED
-    pSiS->xv_sd_result = 0;
-#endif
 
     /* 300 series require double words for addresses and pitches,
      * 315/330 series require word.
+     * Start address and  pitch of Y,U,V of 770 and 670 is represented in 32 bytes unit.
      */
     switch (pSiS->VGAEngine) {
     case SIS_315_VGA:
-	pPriv->shiftValue = 1;
+	if (pPriv->is670) 	pPriv->shiftValue = 5;
+	else 	pPriv->shiftValue = 1;
 	break;
     case SIS_300_VGA:
     default:
@@ -1111,12 +1221,13 @@ SISSetupImageVideo(ScreenPtr pScreen)
           pPriv->linebufMergeLimit = 1280;		/* should be 1280 */
        } else if(pPriv->is761) {
           pPriv->linebufMergeLimit = 1280;		/* should be 1536 */
+       } else if(pPriv->is670) {
+          pPriv->linebufMergeLimit = 1920;		/* FIXME */
        } else if(pPriv->isXGI) {
           pPriv->linebufMergeLimit = 1280;		/* FIXME */
        } else if(!(pPriv->hasTwoOverlays)) {
           pPriv->linebufMergeLimit = 720;		/* should be 960 */
        }
-       /* No special treatment for 760/761 required */
     }
 
     set_maxencoding(pSiS, pPriv);
@@ -1125,7 +1236,7 @@ SISSetupImageVideo(ScreenPtr pScreen)
     SISSetPortDefaults(pScrn, pPriv);
 
     /* Set SR(06, 32) registers according to DISPMODE */
-    set_disptype_regs(pScrn, pPriv);
+    set_disptype_regs(pScrn, pPriv, TRUE, TRUE);
 
     SISResetVideo(pScrn);
     pSiS->ResetXv = SISResetVideo;
@@ -1191,6 +1302,11 @@ SISSetPortAttribute(ScrnInfoPtr pScrn, Atom attribute,
   SISEntPtr pSiSEnt = pSiS->entityPrivate;;
 #endif
 
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] SetPortAttribute is called: attribute=%d, value=%d\n",
+				attribute, value);
+#endif
+
   if(attribute == pSiS->xvBrightness) {
      if((value < -128) || (value > 127))
         return BadValue;
@@ -1259,15 +1375,6 @@ SISSetPortAttribute(ScrnInfoPtr pScrn, Atom attribute,
      pPriv->chromamin = value;
   } else if(attribute == pSiS->xvChromaMax) {
      pPriv->chromamax = value;
-#ifdef SISDEINT
-  } else if(attribute == pSiS->xvdeintmeth) {
-     if(value < 0) value = 0;
-     if(value > 4) value = 4;
-     pPriv->deinterlacemethod = value;
-#endif
-#ifdef SIS_CP
-  SIS_CP_VIDEO_SETATTRIBUTE
-#endif
   } else if(attribute == pSiS->xvHue) {
      if(pSiS->VGAEngine == SIS_315_VGA) {
         if((value < -8) || (value > 7)) return BadValue;
@@ -1308,7 +1415,7 @@ SISSetPortAttribute(ScrnInfoPtr pScrn, Atom attribute,
         }
      } else return BadMatch;
   } else {
-#ifdef XV_SD_DEPRECATED
+#ifdef TWDEBUG
      return(SISSetPortUtilAttribute(pScrn, attribute, value, pPriv));
 #else
      return BadMatch;
@@ -1328,9 +1435,14 @@ SISGetPortAttribute(ScrnInfoPtr pScrn, Atom attribute,
   SISPortPrivPtr pPriv = (SISPortPrivPtr)data;
   SISPtr pSiS = SISPTR(pScrn);
 #ifdef SISDUALHEAD
-  SISEntPtr pSiSEnt = pSiS->entityPrivate;;
+  SISEntPtr pSiSEnt = pSiS->entityPrivate;
+#endif
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] GetPortAttribute is called: attribute=%d\n",attribute);
 #endif
 
+
   if(attribute == pSiS->xvBrightness) {
      *value = pPriv->brightness;
   } else if(attribute == pSiS->xvContrast) {
@@ -1359,13 +1471,6 @@ SISGetPortAttribute(ScrnInfoPtr pScrn, Atom attribute,
      *value = pPriv->chromamin;
   } else if(attribute == pSiS->xvChromaMax) {
      *value = pPriv->chromamax;
-#ifdef SISDEINT
-  } else if(attribute == pSiS->xvdeintmeth) {
-     *value = pPriv->deinterlacemethod;
-#endif
-#ifdef SIS_CP
-  SIS_CP_VIDEO_GETATTRIBUTE
-#endif
   } else if(attribute == pSiS->xvHue) {
      if(pSiS->VGAEngine == SIS_315_VGA) {
         *value = pPriv->hue;
@@ -1396,12 +1501,12 @@ SISGetPortAttribute(ScrnInfoPtr pScrn, Atom attribute,
            *value = pPriv->crtnum;
      } else return BadMatch;
   } else {
-#ifdef XV_SD_DEPRECATED
-     return(SISGetPortUtilAttribute(pScrn, attribute, value, pPriv));
-#else
      return BadMatch;
-#endif
   }
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] GetPortAttribute is called: value=%d\n",value);
+#endif
   return Success;
 }
 
@@ -1420,6 +1525,11 @@ SISQueryBestSize(
 ){
   *p_w = drw_w;
   *p_h = drw_h;
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] QueryBestSize is called: p_w=%d, p_h=%d\n",
+				*p_w, *p_h);
+#endif
 }
 
 /*********************************
@@ -1428,11 +1538,11 @@ SISQueryBestSize(
 
 static void
 calc_scale_factor(SISOverlayPtr pOverlay, ScrnInfoPtr pScrn,
-                 SISPortPrivPtr pPriv, int index, int iscrt2)
+                 SISPortPrivPtr pPriv, int iscrt2)
 {
   SISPtr pSiS = SISPTR(pScrn);
-  CARD32 I=0,mult=0;
-  int flag=0, flag2=0;
+  CARD32 I = 0, mult = 0;
+  int flag = 0, flag2 = 0;
 
   int dstW = pOverlay->dstBox.x2 - pOverlay->dstBox.x1;
   int dstH = pOverlay->dstBox.y2 - pOverlay->dstBox.y1;
@@ -1477,11 +1587,12 @@ calc_scale_factor(SISOverlayPtr pOverlay, ScrnInfoPtr pScrn,
 	(pSiS->ChipType <= SIS_550)) {
 	dstW <<= 1;
      }
-  } else if(modeflags & V_INTERLACE) {
+  } else if((pSiS->MiscFlags & MISC_INTERLACE) && !iscrt2) {
      dstH = origdstH >> 1;
      flag = 0;
   }
 
+
   pOverlay->tap_scale = 1.0;
 
   if(dstW < OVERLAY_MIN_WIDTH) dstW = OVERLAY_MIN_WIDTH;
@@ -1598,7 +1709,7 @@ calc_scale_factor(SISOverlayPtr pOverlay, ScrnInfoPtr pScrn,
 #ifdef SISMERGED
 static void
 calc_scale_factor_2(SISOverlayPtr pOverlay, ScrnInfoPtr pScrn,
-                 SISPortPrivPtr pPriv, int index, int iscrt2)
+					SISPortPrivPtr pPriv)
 {
   SISPtr pSiS = SISPTR(pScrn);
   CARD32 I=0,mult=0;
@@ -1635,10 +1746,7 @@ calc_scale_factor_2(SISOverlayPtr pOverlay, ScrnInfoPtr pScrn,
 	dstW <<= 1;
      }
   }
-  if(modeflags & V_INTERLACE) {
-     dstH = origdstH >> 1;
-     flag = 0;
-  }
+  /* CRT2 is never interlace */
 
   pOverlay->tap_scale2 = 1.0;
 
@@ -1778,6 +1886,207 @@ tap_dda_func(float x)
     return y;
 }
 
+
+void 
+set_dda_regs_6tap(SISPtr pSiS, float scale)
+{
+	float WW, W[6], tempW[6];
+	int i, j, w, k, m, *temp[6], *wtemp[6], WeightMat[16][6], idxw;
+	int *wm1, *wm2, *wm3, *wm4, *wm5, *wm6, *tempadd;
+	long top, bot;
+	unsigned long dwScanLine, dwTopLine, dwBottomLine;
+	
+
+	for (i=0; i<16; i++)
+	{
+		/*The order of weights are inversed for convolution*/
+		W[0] = tap_dda_func((float)((2.0+(i/16.0))/scale));
+		W[1] = tap_dda_func((float)((1.0+(i/16.0))/scale));
+		W[2] = tap_dda_func((float)((0.0+(i/16.0))/scale));
+		W[3] = tap_dda_func((float)((-1.0+(i/16.0))/scale));
+		W[4] = tap_dda_func((float)((-2.0+(i/16.0))/scale));
+		W[5] = tap_dda_func((float)((-3.0+(i/16.0))/scale));
+
+		/*Normalize the weights*/
+		WW = W[0]+W[1]+W[2]+W[3]+W[4]+W[5];
+
+		/*for rouding*/
+		for(j=0; j<6; j++)
+			tempW[j] = (float)((W[j]/WW*16)+0.5);
+
+		WeightMat[i][0] = (int) tempW[0];
+		WeightMat[i][1] = (int) tempW[1];
+		WeightMat[i][2] = (int) tempW[2];
+		WeightMat[i][3] = (int) tempW[3];
+		WeightMat[i][4] = (int) tempW[4];
+		WeightMat[i][5] = (int) tempW[5];
+
+		/*check for display abnormal caused by rounding*/
+		w = WeightMat[i][0] + WeightMat[i][1] + WeightMat[i][2] + WeightMat[i][3]+ WeightMat[i][4]+ WeightMat[i][5];
+		/*initialize temp[] value*/
+		temp[0] = &WeightMat[i][0];
+		temp[1] = &WeightMat[i][1];
+		temp[2] = &WeightMat[i][2];
+		temp[3] = &WeightMat[i][3];
+		temp[4] = &WeightMat[i][4];
+		temp[5] = &WeightMat[i][5];
+		if( w != 16 )
+		{
+			/*
+			//6_tap sort
+			//tempadd save temp[k], idxw save maximum value index
+			//temp[0] -> temp[5] maximum to minimum
+			*/
+			for (k=0; k<5; k++)
+			{
+				idxw=k;
+				for (m=k+1; m<6; m++)
+				{
+					if (*temp[k] < *temp[m])
+						idxw=m;
+				}
+				tempadd=temp[k];
+				temp[k]=temp[idxw];
+				temp[idxw]=tempadd;
+			}
+			wm1=temp[0];
+			wm2=temp[1];
+			wm3=temp[2];
+			wm4=temp[3];
+			wm5=temp[4];
+			wm6=temp[5];
+
+			switch(w)
+			{
+		    		case 10:
+					WeightMat[i][0]++;
+					WeightMat[i][1]++;
+					WeightMat[i][2]++;
+					WeightMat[i][3]++;
+					WeightMat[i][4]++;
+					WeightMat[i][5]++;				
+					break;
+				
+				case 11:
+					(*wm1)++;
+					(*wm2)++;
+					(*wm3)++;
+					(*wm5)++;
+					(*wm6)++;
+					break;
+				
+	                   	case 12:
+					(*wm1)++;
+					(*wm2)++;
+					(*wm5)++;
+					(*wm6)++;
+	                            break;
+
+       	              case 13:
+					(*wm1)++;
+					(*wm2)++;
+					(*wm6)++;
+					break;
+
+			       case 14:
+					(*wm1)++;
+					(*wm6)++;
+		    		    break;
+
+			       case 15:
+					(*wm1)++;
+			    	    break;
+
+			       case 17:
+			        	(*wm6)--;
+			        	break;
+
+			       case 18:
+					(*wm1)--;
+					(*wm6)--;
+		       	     break;
+
+			       case 19:
+					(*wm1)--;
+					(*wm5)--;
+					(*wm6)--;
+                            	break;
+	                     case 20:
+					(*wm1)--;
+					(*wm2)--;
+					(*wm5)--;
+					(*wm6)--;
+	                            break;
+
+				case 21:
+					(*wm1)--;
+					(*wm2)--;
+					(*wm4)--;
+					(*wm5)--;
+					(*wm6)--;
+					break;
+				
+				case 22:
+					WeightMat[i][0]--;
+					WeightMat[i][1]--;
+					WeightMat[i][2]--;
+					WeightMat[i][3]--;
+					WeightMat[i][4]--;
+					WeightMat[i][5]--;				
+					break;
+
+				default:
+	                            break;
+			}
+		}
+	}
+
+
+	/* In 770/771/671, setting VR75/76/77/78 would update overlay HW immediately without setting VR74, 
+	  * it cause garbage points/lines appear in Video. Add the waiting function to make sure driver would set VR75/76/77/78 in
+	  * video blank to avoid this problem.
+	  
+	if( (ppdev->ulChipID == SIS_770) || (ppdev->ulChipID >= SIS_771) )
+	{
+
+			top  = pDD->OverlayStatus[pDD->bSetTimes].rectl.bottom;
+			if ((top == 0xFFF0) || (top < 0) || (top > (long)*ppdev->DD.gDisp_VRes[pDD->bSetTimes]))
+				top = (long)(*pDD->gDisp_VRes[pDD->bSetTimes]);
+			bot  = *pDD->gDisp_VRes[pDD->bSetTimes];
+			if (ppdev->bInterlaced)
+				bot >>= 1;
+
+			dwBottomLine = bot;        
+			dwTopLine = top;
+
+			if (dwTopLine >(dwBottomLine - 30))
+			{
+				do
+				{
+					dwScanLine = ppdev->DD.GET_SCAN_LINE(ppdev);
+				}while (dwScanLine <= dwTopLine);
+			}
+			else
+			{
+				do
+				{
+					dwScanLine = ppdev->DD.GET_SCAN_LINE(ppdev);
+				}while ((dwScanLine <= dwTopLine) || (dwScanLine >dwBottomLine - 20));
+			}
+	}
+	*/
+
+	/*set DDA registers*/
+	for(i=0;i<16;i++)
+		for(j=0;j<6;j++)
+		{
+			setvideoregmask(pSiS, Horizontal_6Tap_DDA_WeightingMatrix_Index, (6*i + j), 0x7F);
+			setvideoregmask(pSiS, Horizontal_6Tap_DDA_WeightingMatrix_Value, WeightMat[i][j], 0x3F);
+		}	
+}
+
+
+
 static void
 set_dda_regs(SISPtr pSiS, float scale)
 {
@@ -1864,13 +2173,24 @@ set_dda_regs(SISPtr pSiS, float scale)
        }
     }
 
-    /* Set 4-tap scaler video regs 0x75-0xb4 */
-    w = 0x75;
-    for(i = 0; i < 16; i++) {
-       for(j = 0; j < 4; j++, w++) {
-          setvideoregmask(pSiS, w, weightmatrix[i][j], 0x3f);
-       }
-    }
+	if((pSiS->ChipType >= SIS_670) && (pSiS->ChipType <= SIS_671)){
+		
+		 for(i=0;i<16;i++){
+		 	for(j=0;j<4;j++){
+				setvideoregmask(pSiS, Vertical_4Tap_DDA_WeightingMatrix_Index, (4*i + j), 0x3F);
+                		setvideoregmask(pSiS, Vertical_4Tap_DDA_WeightingMatrix_Value, weightmatrix[i][j], 0x3F);
+            	}}
+		set_dda_regs_6tap(pSiS, scale);
+
+	}
+
+	else{
+		/* Set 4-tap scaler video regs 0x75-0xb4 */
+		w = 0x75;
+		for(i = 0; i < 16; i++) {
+			for(j = 0; j < 4; j++, w++) {
+				setvideoregmask(pSiS, w, weightmatrix[i][j], 0x3f);
+	}}}
 }
 
 /*********************************
@@ -1880,7 +2200,15 @@ set_dda_regs(SISPtr pSiS, float scale)
 static CARD16
 calc_line_buf_size(CARD32 srcW, CARD8 wHPre, CARD8 planar, SISPortPrivPtr pPriv)
 {
-    CARD32 I, mask = 0xffffffff, shift = pPriv->is761 ? 1 : 0;
+    CARD32 I, mask = 0xffffffff;
+    CARD32 shift = (pPriv->is761 || pPriv->is670) ? 1 : 0;
+
+    /* FIXME: Need to calc line buffer length not according
+     * to total source width but width of source actually
+     * visible on screen. Fixes flicker bug if overlay 1
+     * (much) bigger than screen and being moved outside
+     * screen.
+     */
 
     if(planar) {
 
@@ -1907,7 +2235,7 @@ calc_line_buf_size(CARD32 srcW, CARD8 wHPre, CARD8 planar, SISPortPrivPtr pPriv)
 		I <<= 7;
 		break;
 	    case 6:
-		if(pPriv->is340 || pPriv->isXGI || pPriv->is761) {
+		if(pPriv->is661741760 || pPriv->is340 || pPriv->is761 || pPriv->is670 || pPriv->isXGI) {
 		   shift += 11;
 		   mask <<= shift;
 		   I = srcW >> shift;
@@ -1961,25 +2289,32 @@ calc_line_buf_size_2(SISOverlayPtr pOverlay, SISPortPrivPtr pPriv)
 
 static void
 merge_line_buf_mfb(SISPtr pSiS, SISPortPrivPtr pPriv, Bool enable1, Bool enable2,
-                   short width1, short width2, short limit)
+			Bool useoverlay1, Bool useoverlay2,
+			short width1, short width2, short limit)
 {
     UChar misc1, misc2, mask = pPriv->linebufmask;
 
-    if(pPriv->hasTwoOverlays) {     /* This means we are in MIRROR mode */
+    if(pPriv->hasTwoOverlays) {
+
+       /* Note: misc2 is shared! Hence, set it once only */
 
-       misc2 = 0x00;
-       if(enable1) misc1 = 0x04;
-       else 	   misc1 = 0x00;
-       setvideoregmask(pSiS, Index_VI_Control_Misc2, misc2, mask);
+       misc1 = 0x00; misc2 = 0x00;
+       if(enable1) {
+	  if(useoverlay2 || pSiS->VGAEngine == SIS_300_VGA) misc1 = 0x04;
+	  else						    misc2 = 0x10;
+       }
+       setvideoregmask(pSiS, Index_VI_Control_Misc2, misc2, 0x01);
        setvideoregmask(pSiS, Index_VI_Control_Misc1, misc1, 0x04);
 
-       misc2 = 0x01;
-       if(enable2) misc1 = 0x04;
-       else        misc1 = 0x00;
+       misc1 = 0x00; misc2 |= 0x01;
+       if(enable2) {
+	  if(useoverlay1 || pSiS->VGAEngine == SIS_300_VGA) misc1 = 0x04;
+	  else						    misc2 |= 0x10;
+       }
        setvideoregmask(pSiS, Index_VI_Control_Misc2, misc2, mask);
        setvideoregmask(pSiS, Index_VI_Control_Misc1, misc1, 0x04);
 
-    } else {			/* This means we are either in SINGLE1 or SINGLE2 mode */
+    } else {
 
        misc2 = 0x00;
        if(enable1 || enable2) {
@@ -2255,7 +2590,35 @@ set_brightness(SISPtr pSiS, CARD8 brightness)
 static __inline void
 set_contrast(SISPtr pSiS, CARD8 contrast)
 {
-    setvideoregmask(pSiS, Index_VI_Contrast_Enh_Ctrl, contrast, 0x07);
+   
+   /* xf86DrvMsg(0,X_INFO,"[I_XvImage_con_val_entry]:chip==%d,con_val=%d \n",pSiS->ChipType,contrast);*/
+    if((pSiS->ChipType == SIS_662)||(pSiS->ChipType == SIS_671))
+    {
+     CARD8  tmp;
+     CARD8 reg_vrB7=0x02;
+     CARD8 reg_vr2E=0;
+     tmp = contrast;	    
+     reg_vr2E  = tmp & 0x07;
+     reg_vrB7 |= (tmp >> 1) & 0x7c;     
+    /* xf86DrvMsg(0,X_INFO,"[I_XvImage_con_is_662]:con_val=%d,vr2E=%x, vrB7=%x \n",contrast,reg_vr2E,reg_vrB7);*/
+     
+     setvideoregmask(pSiS,Index_VI_Contrast_Enh_Ctrl,reg_vr2E,0x07);
+    /* xf86DrvMsg(0,X_INFO,"[I_XvImage_con_LOW_3BITS]:set_con=%d \n",contrast);*/
+      /*data = contrast >> 1;*/
+    
+     setvideoregmask(pSiS,0xB7,reg_vrB7,0x7E);
+    /* xf86DrvMsg(0,X_INFO,"[I_XvImage_con_HI_5BITS]:set_con=%d, reg=%x \n",contrast,Index_VI_Line_Buffer_Size_High);*/
+
+
+   /* var = getvideoreg(pSiS,0x2E); 
+    xf86DrvMsg(0,X_INFO,"[I_XvImage_con_get_LOW_3BITS]:reg2E=%x \n",var);
+    
+    var1 = getvideoreg(pSiS,0xB7);
+    xf86DrvMsg(0,X_INFO,"[I_XvImage_con_get_HI_5BITS]:regB7=%x \n",var1);*/
+    }
+    else
+    { /* xf86DrvMsg(0,X_INFO,"[I_XvImage_con_NOT_662]:con_val=%d \n",contrast);*/	              setvideoregmask(pSiS,Index_VI_Contrast_Enh_Ctrl,contrast,0x07);
+    }
 }
 
 /* 315 series and later only */
@@ -2289,6 +2652,7 @@ set_disablegfx(SISPtr pSiS, Bool mybool, SISOverlayPtr pOverlay)
     if((!(pSiS->ChipFlags & SiSCF_Is65x)) &&
        (pSiS->Chipset != PCI_CHIP_SIS660) &&
        (pSiS->Chipset != PCI_CHIP_SIS340) &&
+       (pSiS->Chipset != PCI_CHIP_SIS670) &&
        (pSiS->Chipset != PCI_CHIP_XGIXG20) &&
        (pSiS->Chipset != PCI_CHIP_XGIXG40)) {
        setvideoregmask(pSiS, Index_VI_Control_Misc2, mybool ? 0x04 : 0x00, 0x04);
@@ -2303,9 +2667,6 @@ set_disablegfxlr(SISPtr pSiS, Bool mybool, SISOverlayPtr pOverlay)
     if(mybool) pOverlay->keyOP = VI_ROP_Always;
 }
 
-#ifdef SIS_CP
-    SIS_CP_VIDEO_SUBS
-#endif
 
 /*********************************
  *   Set main overlay registers  *
@@ -2319,6 +2680,7 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
     CARD16 screenX, screenY;
     CARD32 PSY;
     int    modeflags, totalPixels, confactor, sample, watchdog = 0;
+    CARD8 alignMask;
 
 #ifdef SISMERGED
     if(pSiS->MergedFB && iscrt2) {
@@ -2366,7 +2728,7 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
        /* DoubleScan modes require Y coordinates * 2 */
        top <<= 1;
        bottom <<= 1;
-    } else if(modeflags & V_INTERLACE) {
+    } else if(!iscrt2 && (pSiS->MiscFlags & MISC_INTERLACE)) {
        /* Interlace modes require Y coordinates / 2 */
        top >>= 1;
        bottom >>= 1;
@@ -2375,17 +2737,27 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
     h_over = (((left >> 8) & 0x0f) | ((right >> 4) & 0xf0));
     v_over = (((top >> 8) & 0x0f) | ((bottom >> 4) & 0xf0));
 
+    /* set line number ---- we only examined 662*/
+    if(pSiS->ChipType == SIS_662 ){
+	setvideoreg(pSiS, Source_VertLine_Number_Low, (CARD8)pOverlay->srcH);
+	setvideoreg(pSiS, Source_VertLine_Number_High, pOverlay->srcH >> 8);
+     }
+
     /* set line buffer size */
 #ifdef SISMERGED
     if(pSiS->MergedFB && iscrt2) {
        setvideoreg(pSiS, Index_VI_Line_Buffer_Size, (CARD8)pOverlay->lineBufSize2);
-       if(pPriv->is340 || pPriv->is761 || pPriv->isXGI) {
+       if(pPriv->is661741760) {
+          setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, (pOverlay->lineBufSize2 >> 1) & 0x80, 0x80);
+       } else if(pPriv->is340 || pPriv->is761 || pPriv->is670 || pPriv->isXGI) {
           setvideoreg(pSiS, Index_VI_Line_Buffer_Size_High, (CARD8)(pOverlay->lineBufSize2 >> 8));
        }
     } else {
 #endif
        setvideoreg(pSiS, Index_VI_Line_Buffer_Size, (CARD8)pOverlay->lineBufSize);
-       if(pPriv->is340 || pPriv->is761 || pPriv->isXGI) {
+       if(pPriv->is661741760) {
+          setvideoregmask(pSiS, Index_VI_Key_Overlay_OP, (pOverlay->lineBufSize >> 1) & 0x80, 0x80);
+       } else if(pPriv->is340 || pPriv->isXGI) {
           setvideoreg(pSiS, Index_VI_Line_Buffer_Size_High, (CARD8)(pOverlay->lineBufSize >> 8));
        }
 #ifdef SISMERGED
@@ -2456,8 +2828,12 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
 
     /* Set 315 series overflow bits for Y plane */
     if(pSiS->VGAEngine == SIS_315_VGA) {
+
+	if(pPriv->is670)	alignMask = 0x07;
+	else 	alignMask = 0x03;
+	
        setvideoreg(pSiS, Index_VI_Disp_Y_Buf_Pitch_High, (CARD8)(pitch >> 12));
-       setvideoreg(pSiS, Index_VI_Y_Buf_Start_Over, ((CARD8)(PSY >> 24) & 0x03));
+       setvideoreg(pSiS, Index_VI_Y_Buf_Start_Over, ((CARD8)(PSY >> 24) & alignMask));
     }
 
     /* Set U/V data if using planar formats */
@@ -2491,11 +2867,11 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
 	/* 315 series overflow bits */
 	if(pSiS->VGAEngine == SIS_315_VGA) {
 	   setvideoreg(pSiS, Index_VI_Disp_UV_Buf_Pitch_High, (CARD8)(pitch >> 12));
-	   setvideoreg(pSiS, Index_VI_U_Buf_Start_Over, ((CARD8)(PSU >> 24) & 0x03));
+	   setvideoreg(pSiS, Index_VI_U_Buf_Start_Over, ((CARD8)(PSU >> 24) & alignMask));
 	   if(pPriv->is661741760) {
 	      setvideoregmask(pSiS, Index_VI_V_Buf_Start_Over, ((CARD8)(PSV >> 24) & 0x03), 0xc3);
 	   } else {
-	      setvideoreg(pSiS, Index_VI_V_Buf_Start_Over, ((CARD8)(PSV >> 24) & 0x03));
+	      setvideoreg(pSiS, Index_VI_V_Buf_Start_Over, ((CARD8)(PSV >> 24) & alignMask));
 	   }
 	}
     }
@@ -2539,6 +2915,15 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
 	     pPriv->mustresettap = FALSE;
 	  }
        }
+	   
+	/*  if vertically downscale, remember to set VR31[6] 1 
+  	     Howerver so far, we only exam 662 & 671 */
+	if(pSiS->ChipType >= SIS_662 && pSiS->ChipType < XGI_20){
+		if(pOverlay->IntBit & 0x2)		setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x40, 0x40);
+		else		setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x40);
+	}
+
+	
 #ifdef SISMERGED
     }
 #endif
@@ -2553,7 +2938,7 @@ set_overlay(SISPtr pSiS, SISOverlayPtr pOverlay, SISPortPrivPtr pPriv, int index
 static void
 close_overlay(SISPtr pSiS, SISPortPrivPtr pPriv)
 {
-  int watchdog;
+  int ovnum = 0;
 
   if(!pPriv->overlayStatus) return;
 
@@ -2570,12 +2955,20 @@ close_overlay(SISPtr pSiS, SISPortPrivPtr pPriv)
       * 1 overlay:  Uses overlay 0
       * 2 overlays: Uses Overlay 1 if MIRROR or DUAL HEAD
       *             Uses Overlay 0 if SINGLE2 and not DUAL HEAD
+      *
+      * (No special treatment needed for MergedFB where CRT2
+      * might be using overlay 0; it's switched off below anyway.
+      * The only problem that might cause trouble is that it checks
+      * the scanlines of CRT1. But since the chipsets where we use
+      * this aren't sensible to disabling the overlay during display,
+      * we keep it simple.)
       */
 
      if(pPriv->hasTwoOverlays) {
 
 	if((pPriv->dualHeadMode) || (pPriv->displayMode == DISPMODE_MIRROR)) {
 	   setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x01, 0x01);
+	   ovnum = 1;
 	} else {
 	   setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x00, 0x01);
 	}
@@ -2594,19 +2987,8 @@ close_overlay(SISPtr pSiS, SISPortPrivPtr pPriv)
 
      setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
 
-     watchdog = WATCHDOG_DELAY;
-     while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
-     watchdog = WATCHDOG_DELAY;
-     while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
-     setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-     watchdog = WATCHDOG_DELAY;
-     while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
-     watchdog = WATCHDOG_DELAY;
-     while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
-
-#ifdef SIS_CP
-     SIS_CP_RESET_CP
-#endif
+     disableoverlay(pSiS, pPriv, ovnum);
+
 
   }
 
@@ -2627,44 +3009,45 @@ close_overlay(SISPtr pSiS, SISPortPrivPtr pPriv)
      setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x00, 0x05);
      setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
 
-     watchdog = WATCHDOG_DELAY;
-     while((!vblank_active_CRT1(pSiS, pPriv)) && --watchdog);
-     watchdog = WATCHDOG_DELAY;
-     while(vblank_active_CRT1(pSiS, pPriv) && --watchdog);
-     setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-     watchdog = WATCHDOG_DELAY;
-     while((!vblank_active_CRT1(pSiS, pPriv)) && --watchdog);
-     watchdog = WATCHDOG_DELAY;
-     while(vblank_active_CRT1(pSiS, pPriv) && --watchdog);
-
+     disableoverlay(pSiS, pPriv, 0);
   }
 }
 
+
+/* interface for XvMC to close overlay */
+void 
+SISXvMCCloseOverlay(ScrnInfoPtr pScrn){
+
+   SISPortPrivPtr pPriv = GET_PORT_PRIVATE(pScrn);
+   SISPtr pSiS = SISPTR(pScrn);
+   
+   /* disable subpicture*/ 
+   setvideoregmask(pSiS, Index_VI_SubPict_Scale_Control, 0x00, 0x40);
+   setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x00, 0x04);
+   
+   close_overlay(pSiS, pPriv);
+}
+
 /*********************************
- *         DisplayVideo()        *
+ *         CheckOverlay()        *
  *********************************/
 
-static void
-SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
-{
+ static int
+ SISCheckOverlay(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv, SISOverlayPtr overlay)
+ {
    SISPtr pSiS = SISPTR(pScrn);
 #ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
 #endif
-   short  srcPitch = pPriv->srcPitch;
-   short  height = pPriv->height;
+   int result = 1;
    UShort screenwidth;
-   SISOverlayRec overlay;
-   int    srcOffsetX = 0, srcOffsetY = 0;
-   int    sx = 0, sy = 0, watchdog;
-   int    index = 0, iscrt2 = 0;
 #ifdef SISMERGED
-   UChar  temp;
+   int notavail1 = 0, notavail2 = 0;
    UShort screen2width = 0;
-   int    srcOffsetX2 = 0, srcOffsetY2 = 0;
-   int    sx2 = 0, sy2 = 0;
 #endif
 
+   overlay->srcOffsetX = overlay->srcOffsetY = 0;
+
    /* Determine whether we have two overlays or only one */
    set_hastwooverlays(pSiS, pPriv);
 
@@ -2674,29 +3057,21 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
       if(!pPriv->hasTwoOverlays) {
 	 if(pSiS->SecondHead) {
 	    if(pSiSEnt->curxvcrtnum != 0) {
-	       if(pPriv->overlayStatus) {
-		  close_overlay(pSiS, pPriv);
-	       }
-	       pPriv->NoOverlay = TRUE;
-	       return;
+	       return 0;
 	    }
 	 } else {
 	    if(pSiSEnt->curxvcrtnum != 1) {
-	       if(pPriv->overlayStatus) {
-		  close_overlay(pSiS, pPriv);
-	       }
-	       pPriv->NoOverlay = TRUE;
-	       return;
+	       return 0;
 	    }
 	 }
       }
    }
 #endif
 
-   /* setup dispmode (MIRROR, SINGLEx) */
+   /* Determine dispmode (MIRROR, SINGLEx) */
    set_dispmode(pScrn, pPriv);
 
-   /* Check if overlay is supported with current mode */
+   /* Check if overlay is supported with current display mode */
 #ifdef SISMERGED
    if(!pSiS->MergedFB) {
 #endif
@@ -2706,309 +3081,293 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
 	   (!(pSiS->MiscFlags & MISC_CRT1OVERLAY))) ||
 	  ((pPriv->displayMode & DISPMODE_SINGLE2) &&
 	   (!(pSiS->MiscFlags & MISC_CRT2OVERLAY))) ) {
-	 if(pPriv->overlayStatus) {
-	    close_overlay(pSiS, pPriv);
-	 }
-	 pPriv->NoOverlay = TRUE;
-	 return;
+	 return 0;
       }
 #ifdef SISMERGED
    }
 #endif
 
-   memset(&overlay, 0, sizeof(overlay));
 
-   overlay.pixelFormat = pPriv->id;
-   overlay.pitch = overlay.origPitch = srcPitch;
-   if(pPriv->usechromakey) {
-      overlay.keyOP = (pPriv->insidechromakey) ? VI_ROP_ChromaKey : VI_ROP_NotChromaKey;
-   } else {
-      overlay.keyOP = VI_ROP_DestKey;
-   }
-
-#ifdef SISDEINT
-   switch(pPriv->deinterlacemethod) {
-   case 1:
-      overlay.bobEnable = 0x02;
-      /* overlay.bobEnable |= (pPriv->currentBuf) ? 0x00 : 0x10; */
-      break;
-   case 2:
-      overlay.bobEnable = 0x08;
-      /* overlay.bobEnable |= (pPriv->currentBuf) ? 0x00 : 0x10; */
-      break;
-   case 3:
-      overlay.bobEnable = 0x0a;
-      /* overlay.bobEnable |= (pPriv->currentBuf) ? 0x00 : 0x10; */
-      break;
-   default:
-#endif
-      overlay.bobEnable = 0x00;    /* Disable BOB de-interlacer */
-#ifdef SISDEINT
-   }
-#endif
+   overlay->pitch = overlay->origPitch = pPriv->srcPitch;
 
 #ifdef SISMERGED
    if(pSiS->MergedFB) {
-      overlay.DoFirst = TRUE;
-      overlay.DoSecond = TRUE;
-      overlay.pitch2 = overlay.origPitch;
-      overlay.currentmode = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT1;
-      overlay.currentmode2 = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2;
-      overlay.SCREENheight  = overlay.currentmode->VDisplay;
-      overlay.SCREENheight2 = overlay.currentmode2->VDisplay;
-      screenwidth = overlay.currentmode->HDisplay;
-      screen2width = overlay.currentmode2->HDisplay;
-      overlay.dstBox.x1  = pPriv->drw_x - pSiS->CRT1frameX0;
-      overlay.dstBox.x2  = overlay.dstBox.x1 + pPriv->drw_w;
-      overlay.dstBox.y1  = pPriv->drw_y - pSiS->CRT1frameY0;
-      overlay.dstBox.y2  = overlay.dstBox.y1 + pPriv->drw_h;
-      overlay.dstBox2.x1 = pPriv->drw_x - pSiS->CRT2pScrn->frameX0;
-      overlay.dstBox2.x2 = overlay.dstBox2.x1 + pPriv->drw_w;
-      overlay.dstBox2.y1 = pPriv->drw_y - pSiS->CRT2pScrn->frameY0;
-      overlay.dstBox2.y2 = overlay.dstBox2.y1 + pPriv->drw_h;
+      overlay->srcOffsetX2 = overlay->srcOffsetY2 = 0;
+      overlay->DoFirst = TRUE;
+      overlay->DoSecond = TRUE;
+      overlay->pitch2 = overlay->origPitch;
+      overlay->currentmode = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT1;
+      overlay->currentmode2 = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2;
+      overlay->SCREENheight  = overlay->currentmode->VDisplay;
+      overlay->SCREENheight2 = overlay->currentmode2->VDisplay;
+      screenwidth = overlay->currentmode->HDisplay;
+      screen2width = overlay->currentmode2->HDisplay;
+      overlay->dstBox.x1  = pPriv->drw_x - pSiS->CRT1frameX0;
+      overlay->dstBox.x2  = overlay->dstBox.x1 + pPriv->drw_w;
+      overlay->dstBox.y1  = pPriv->drw_y - pSiS->CRT1frameY0;
+      overlay->dstBox.y2  = overlay->dstBox.y1 + pPriv->drw_h;
+      overlay->dstBox2.x1 = pPriv->drw_x - pSiS->CRT2pScrn->frameX0;
+      overlay->dstBox2.x2 = overlay->dstBox2.x1 + pPriv->drw_w;
+      overlay->dstBox2.y1 = pPriv->drw_y - pSiS->CRT2pScrn->frameY0;
+      overlay->dstBox2.y2 = overlay->dstBox2.y1 + pPriv->drw_h;
    } else {
 #endif
-      overlay.currentmode = pSiS->CurrentLayout.mode;
-      overlay.SCREENheight = overlay.currentmode->VDisplay;
-      screenwidth = overlay.currentmode->HDisplay;
-      overlay.dstBox.x1 = pPriv->drw_x - pScrn->frameX0;
-      overlay.dstBox.x2 = pPriv->drw_x + pPriv->drw_w - pScrn->frameX0;
-      overlay.dstBox.y1 = pPriv->drw_y - pScrn->frameY0;
-      overlay.dstBox.y2 = pPriv->drw_y + pPriv->drw_h - pScrn->frameY0;
+      overlay->currentmode = pSiS->CurrentLayout.mode;
+      overlay->SCREENheight = overlay->currentmode->VDisplay;
+      screenwidth = overlay->currentmode->HDisplay;
+      overlay->dstBox.x1 = pPriv->drw_x - pScrn->frameX0;
+      overlay->dstBox.x2 = pPriv->drw_x + pPriv->drw_w - pScrn->frameX0;
+      overlay->dstBox.y1 = pPriv->drw_y - pScrn->frameY0;
+      overlay->dstBox.y2 = pPriv->drw_y + pPriv->drw_h - pScrn->frameY0;
 #ifdef SISMERGED
    }
 #endif
 
    /* Note: x2/y2 is actually real coordinate + 1 */
 
-   if((overlay.dstBox.x1 >= overlay.dstBox.x2) ||
-      (overlay.dstBox.y1 >= overlay.dstBox.y2)) {
+   if((overlay->dstBox.x1 >= overlay->dstBox.x2) ||
+      (overlay->dstBox.y1 >= overlay->dstBox.y2)) {
 #ifdef SISMERGED
-      if(pSiS->MergedFB) overlay.DoFirst = FALSE;
+      if(pSiS->MergedFB) overlay->DoFirst = FALSE;
       else
 #endif
-           return;
+           return 2;
    }
 
-   if((overlay.dstBox.x2 <= 0) || (overlay.dstBox.y2 <= 0)) {
+   if((overlay->dstBox.x2 <= 0) || (overlay->dstBox.y2 <= 0)) {
 #ifdef SISMERGED
-      if(pSiS->MergedFB) overlay.DoFirst = FALSE;
+      if(pSiS->MergedFB) overlay->DoFirst = FALSE;
       else
 #endif
-           return;
+           return 2;
    }
 
-   if((overlay.dstBox.x1 >= screenwidth) || (overlay.dstBox.y1 >= overlay.SCREENheight)) {
+   if((overlay->dstBox.x1 >= screenwidth) || (overlay->dstBox.y1 >= overlay->SCREENheight)) {
 #ifdef SISMERGED
-      if(pSiS->MergedFB) overlay.DoFirst = FALSE;
+      if(pSiS->MergedFB) overlay->DoFirst = FALSE;
       else
 #endif
-           return;
+           return 2;
    }
 
-#ifdef SISMERGED
-   if(pSiS->MergedFB) {
-      /* Check if dotclock is within limits for CRT1 */
-      if(pPriv->displayMode & (DISPMODE_SINGLE1 | DISPMODE_MIRROR)) {
-         if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
-            overlay.DoFirst = FALSE;
-         }
-      }
+   if(overlay->dstBox.x1 < 0) {
+      overlay->srcOffsetX = pPriv->src_w * (-overlay->dstBox.x1) / pPriv->drw_w;
+      overlay->dstBox.x1 = 0;
    }
-#endif
 
-   if(overlay.dstBox.x1 < 0) {
-      srcOffsetX = pPriv->src_w * (-overlay.dstBox.x1) / pPriv->drw_w;
-      overlay.dstBox.x1 = 0;
-   }
-   if(overlay.dstBox.y1 < 0) {
-      srcOffsetY = pPriv->src_h * (-overlay.dstBox.y1) / pPriv->drw_h;
-      overlay.dstBox.y1 = 0;
+   if(overlay->dstBox.y1 < 0) {
+      overlay->srcOffsetY = pPriv->src_h * (-overlay->dstBox.y1) / pPriv->drw_h;
+      overlay->dstBox.y1 = 0;
    }
 
-   if((overlay.dstBox.x1 >= overlay.dstBox.x2 - 2) ||
-      (overlay.dstBox.x1 >= screenwidth - 2)       ||
-      (overlay.dstBox.y1 >= overlay.dstBox.y2)) {
+   if((overlay->dstBox.x1 >= overlay->dstBox.x2 - 2) ||
+      (overlay->dstBox.x1 >= screenwidth - 2)        ||
+      (overlay->dstBox.y1 >= overlay->dstBox.y2)) {
 #ifdef SISMERGED
-      if(pSiS->MergedFB) overlay.DoFirst = FALSE;
+      if(pSiS->MergedFB) overlay->DoFirst = FALSE;
       else
 #endif
-           return;
+           return 2;
    }
 
 #ifdef SISMERGED
    if(pSiS->MergedFB) {
-      if((overlay.dstBox2.x2 <= 0) || (overlay.dstBox2.y2 <= 0))
-	 overlay.DoSecond = FALSE;
 
-      if((overlay.dstBox2.x1 >= screen2width) || (overlay.dstBox2.y1 >= overlay.SCREENheight2))
-	 overlay.DoSecond = FALSE;
+      /* Check if dotclock is within limits for CRT1 */
+      if(overlay->DoFirst) {
+         if(pPriv->displayMode & (DISPMODE_SINGLE1 | DISPMODE_MIRROR)) {
+            if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
+               notavail1 = 1;
+            }
+         }
+      }
 
-      if(overlay.dstBox2.x1 < 0) {
-	 srcOffsetX2 = pPriv->src_w * (-overlay.dstBox2.x1) / pPriv->drw_w;
-	 overlay.dstBox2.x1 = 0;
+      /* Now for CRT2 */
+
+      if((overlay->dstBox2.x2 <= 0) || (overlay->dstBox2.y2 <= 0))
+	 overlay->DoSecond = FALSE;
+
+      if((overlay->dstBox2.x1 >= screen2width) || (overlay->dstBox2.y1 >= overlay->SCREENheight2))
+	 overlay->DoSecond = FALSE;
+
+      if(overlay->dstBox2.x1 < 0) {
+	 overlay->srcOffsetX2 = pPriv->src_w * (-overlay->dstBox2.x1) / pPriv->drw_w;
+	 overlay->dstBox2.x1 = 0;
       }
 
-      if(overlay.dstBox2.y1 < 0) {
-	 srcOffsetY2 = pPriv->src_h * (-overlay.dstBox2.y1) / pPriv->drw_h;
-	 overlay.dstBox2.y1 = 0;
+      if(overlay->dstBox2.y1 < 0) {
+	 overlay->srcOffsetY2 = pPriv->src_h * (-overlay->dstBox2.y1) / pPriv->drw_h;
+	 overlay->dstBox2.y1 = 0;
       }
 
-      if((overlay.dstBox2.x1 >= overlay.dstBox2.x2 - 2) ||
-	 (overlay.dstBox2.x1 >= screen2width - 2)       ||
-	 (overlay.dstBox2.y1 >= overlay.dstBox2.y2))
-	 overlay.DoSecond = FALSE;
+      if((overlay->dstBox2.x1 >= overlay->dstBox2.x2 - 2) ||
+	 (overlay->dstBox2.x1 >= screen2width - 2)        ||
+	 (overlay->dstBox2.y1 >= overlay->dstBox2.y2))
+	 overlay->DoSecond = FALSE;
 
       /* Check if dotclock is within limits for CRT2 */
-      if(pPriv->displayMode & (DISPMODE_SINGLE2 | DISPMODE_MIRROR)) {
-	 if(!(pSiS->MiscFlags & MISC_CRT2OVERLAY)) {
-	    overlay.DoSecond = FALSE;
-	 }
+      if(overlay->DoSecond) {
+         if(pPriv->displayMode & (DISPMODE_SINGLE2 | DISPMODE_MIRROR)) {
+	    if(!(pSiS->MiscFlags & MISC_CRT2OVERLAY)) {
+	       notavail2 = 1;
+	    }
+	    /* CRT2 is never interlace */
+         }
+      }
+
+      if((!overlay->DoFirst) && (!overlay->DoSecond)) {
+         result = 2;
+      } else if((overlay->DoFirst  && notavail1) ||
+                (overlay->DoSecond && notavail2)) {
+         overlay->DoFirst = overlay->DoSecond = FALSE;
+         result = 0;
       }
 
       /* If neither overlay is to be displayed, disable them if they are currently enabled */
-      if((!overlay.DoFirst) && (!overlay.DoSecond)) {
+      if((!overlay->DoFirst) && (!overlay->DoSecond)) {
 	 setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x00, 0x05);
 	 setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
-	 temp = getvideoreg(pSiS,Index_VI_Control_Misc0);
-	 if(temp & 0x02) {
-	    watchdog = WATCHDOG_DELAY;
-	    if(pPriv->hasTwoOverlays) {
-	       while((!vblank_active_CRT1(pSiS, pPriv)) && --watchdog);
-	       watchdog = WATCHDOG_DELAY;
-	       while(vblank_active_CRT1(pSiS, pPriv) && --watchdog);
-	    } else {
-	       temp = getsrreg(pSiS, 0x06);
-	       if(!(temp & 0x40)) {
-		  while((!vblank_active_CRT1(pSiS, pPriv)) && --watchdog);
-		  watchdog = WATCHDOG_DELAY;
-		  while(vblank_active_CRT1(pSiS, pPriv) && --watchdog);
-	       } else {
-		  while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
-		  watchdog = WATCHDOG_DELAY;
-		  while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
-	       }
-	    }
-	    setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-	 }
+	 disableoverlay(pSiS, pPriv, 0);
 	 if(pPriv->hasTwoOverlays) {
 	    setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x01, 0x01);
 	    setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
-	    temp = getvideoreg(pSiS,Index_VI_Control_Misc0);
-	    if(temp & 0x02) {
-	       watchdog = WATCHDOG_DELAY;
-	       while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
-	       watchdog = WATCHDOG_DELAY;
-	       while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
-	       setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-	    }
+	    disableoverlay(pSiS, pPriv, 1);
 	 }
 	 pPriv->overlayStatus = FALSE;
-         return;
       }
    }
 #endif
 
+   return result;
+
+ }
+
+/*********************************
+ *         DisplayVideo()        *
+ *********************************/
+
+static void
+SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv, SISOverlayPtr overlay)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+   short  srcPitch = pPriv->srcPitch;
+   short  height = pPriv->height;
+   int    sx = 0, sy = 0, watchdog;
+   int    index = 0, iscrt2 = 0;
+#ifdef SISMERGED
+   int    sx2 = 0, sy2 = 0;
+#endif
+
+   overlay->pixelFormat = pPriv->id;
+
+   if(pPriv->usechromakey) {
+      overlay->keyOP = (pPriv->insidechromakey) ? VI_ROP_ChromaKey : VI_ROP_NotChromaKey;
+   } else {
+      overlay->keyOP = VI_ROP_DestKey;
+   }
+
+      overlay->bobEnable = 0x00;    /* Disable BOB de-interlacer */
+
    switch(pPriv->id) {
 
      case PIXEL_FMT_YV12:
-       overlay.planar = 1;
-       overlay.planar_shiftpitch = 1;
+       overlay->planar = 1;
+       overlay->planar_shiftpitch = 1;
 #ifdef SISMERGED
-       if((!pSiS->MergedFB) || (overlay.DoFirst)) {
-#endif
-          sx = (pPriv->src_x + srcOffsetX) & ~7;
-          sy = (pPriv->src_y + srcOffsetY) & ~1;
-          overlay.PSY = pPriv->bufAddr[pPriv->currentBuf] + sx + sy*srcPitch;
-          overlay.PSV = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx + sy*srcPitch/2) >> 1);
-          overlay.PSU = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx + sy*srcPitch/2) >> 1);
-          overlay.PSY += FBOFFSET;
-          overlay.PSV += FBOFFSET;
-          overlay.PSU += FBOFFSET;
-          overlay.PSY >>= pPriv->shiftValue;
-          overlay.PSV >>= pPriv->shiftValue;
-          overlay.PSU >>= pPriv->shiftValue;
+       if((!pSiS->MergedFB) || (overlay->DoFirst)) {
+#endif
+          sx = (pPriv->src_x + overlay->srcOffsetX) & ~7;
+          sy = (pPriv->src_y + overlay->srcOffsetY) & ~1;
+          overlay->PSY = pPriv->bufAddr[pPriv->currentBuf] + sx + sy*srcPitch;
+          overlay->PSV = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx + sy*srcPitch/2) >> 1);
+          overlay->PSU = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx + sy*srcPitch/2) >> 1);
+          overlay->PSY += FBOFFSET;
+          overlay->PSV += FBOFFSET;
+          overlay->PSU += FBOFFSET;
+          overlay->PSY >>= pPriv->shiftValue;
+          overlay->PSV >>= pPriv->shiftValue;
+          overlay->PSU >>= pPriv->shiftValue;
 #ifdef SISMERGED
        }
-       if((pSiS->MergedFB) && (overlay.DoSecond)) {
-          sx2 = (pPriv->src_x + srcOffsetX2) & ~7;
-          sy2 = (pPriv->src_y + srcOffsetY2) & ~1;
-          overlay.PSY2 = pPriv->bufAddr[pPriv->currentBuf] + sx2 + sy2*srcPitch;
-          overlay.PSV2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx2 + sy2*srcPitch/2) >> 1);
-          overlay.PSU2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx2 + sy2*srcPitch/2) >> 1);
-          overlay.PSY2 += FBOFFSET;
-          overlay.PSV2 += FBOFFSET;
-          overlay.PSU2 += FBOFFSET;
-          overlay.PSY2 >>= pPriv->shiftValue;
-          overlay.PSV2 >>= pPriv->shiftValue;
-          overlay.PSU2 >>= pPriv->shiftValue;
+       if((pSiS->MergedFB) && (overlay->DoSecond)) {
+          sx2 = (pPriv->src_x + overlay->srcOffsetX2) & ~7;
+          sy2 = (pPriv->src_y + overlay->srcOffsetY2) & ~1;
+          overlay->PSY2 = pPriv->bufAddr[pPriv->currentBuf] + sx2 + sy2*srcPitch;
+          overlay->PSV2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx2 + sy2*srcPitch/2) >> 1);
+          overlay->PSU2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx2 + sy2*srcPitch/2) >> 1);
+          overlay->PSY2 += FBOFFSET;
+          overlay->PSV2 += FBOFFSET;
+          overlay->PSU2 += FBOFFSET;
+          overlay->PSY2 >>= pPriv->shiftValue;
+          overlay->PSV2 >>= pPriv->shiftValue;
+          overlay->PSU2 >>= pPriv->shiftValue;
        }
 #endif
        break;
 
      case PIXEL_FMT_I420:
-       overlay.planar = 1;
-       overlay.planar_shiftpitch = 1;
+       overlay->planar = 1;
+       overlay->planar_shiftpitch = 1;
 #ifdef SISMERGED
-       if((!pSiS->MergedFB) || (overlay.DoFirst)) {
-#endif
-          sx = (pPriv->src_x + srcOffsetX) & ~7;
-          sy = (pPriv->src_y + srcOffsetY) & ~1;
-          overlay.PSY = pPriv->bufAddr[pPriv->currentBuf] + sx + sy*srcPitch;
-          overlay.PSV = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx + sy*srcPitch/2) >> 1);
-          overlay.PSU = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx + sy*srcPitch/2) >> 1);
-          overlay.PSY += FBOFFSET;
-          overlay.PSV += FBOFFSET;
-          overlay.PSU += FBOFFSET;
-          overlay.PSY >>= pPriv->shiftValue;
-          overlay.PSV >>= pPriv->shiftValue;
-          overlay.PSU >>= pPriv->shiftValue;
+       if((!pSiS->MergedFB) || (overlay->DoFirst)) {
+#endif
+          sx = (pPriv->src_x + overlay->srcOffsetX) & ~7;
+          sy = (pPriv->src_y + overlay->srcOffsetY) & ~1;
+          overlay->PSY = pPriv->bufAddr[pPriv->currentBuf] + sx + sy*srcPitch;
+          overlay->PSV = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx + sy*srcPitch/2) >> 1);
+          overlay->PSU = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx + sy*srcPitch/2) >> 1);
+          overlay->PSY += FBOFFSET;
+          overlay->PSV += FBOFFSET;
+          overlay->PSU += FBOFFSET;
+          overlay->PSY >>= pPriv->shiftValue;
+          overlay->PSV >>= pPriv->shiftValue;
+          overlay->PSU >>= pPriv->shiftValue;
 #ifdef SISMERGED
        }
-       if((pSiS->MergedFB) && (overlay.DoSecond)) {
-          sx2 = (pPriv->src_x + srcOffsetX2) & ~7;
-          sy2 = (pPriv->src_y + srcOffsetY2) & ~1;
-          overlay.PSY2 = pPriv->bufAddr[pPriv->currentBuf] + sx2 + sy2*srcPitch;
-          overlay.PSV2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx2 + sy2*srcPitch/2) >> 1);
-          overlay.PSU2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx2 + sy2*srcPitch/2) >> 1);
-          overlay.PSY2 += FBOFFSET;
-          overlay.PSV2 += FBOFFSET;
-          overlay.PSU2 += FBOFFSET;
-          overlay.PSY2 >>= pPriv->shiftValue;
-          overlay.PSV2 >>= pPriv->shiftValue;
-          overlay.PSU2 >>= pPriv->shiftValue;
+       if((pSiS->MergedFB) && (overlay->DoSecond)) {
+          sx2 = (pPriv->src_x + overlay->srcOffsetX2) & ~7;
+          sy2 = (pPriv->src_y + overlay->srcOffsetY2) & ~1;
+          overlay->PSY2 = pPriv->bufAddr[pPriv->currentBuf] + sx2 + sy2*srcPitch;
+          overlay->PSV2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch*5/4 + ((sx2 + sy2*srcPitch/2) >> 1);
+          overlay->PSU2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx2 + sy2*srcPitch/2) >> 1);
+          overlay->PSY2 += FBOFFSET;
+          overlay->PSV2 += FBOFFSET;
+          overlay->PSU2 += FBOFFSET;
+          overlay->PSY2 >>= pPriv->shiftValue;
+          overlay->PSV2 >>= pPriv->shiftValue;
+          overlay->PSU2 >>= pPriv->shiftValue;
        }
 #endif
        break;
 
      case PIXEL_FMT_NV12:
      case PIXEL_FMT_NV21:
-       overlay.planar = 1;
-       overlay.planar_shiftpitch = 0;
+       overlay->planar = 1;
+       overlay->planar_shiftpitch = 0;
 #ifdef SISMERGED
-       if((!pSiS->MergedFB) || (overlay.DoFirst)) {
-#endif
-          sx = (pPriv->src_x + srcOffsetX) & ~7;
-          sy = (pPriv->src_y + srcOffsetY) & ~1;
-          overlay.PSY = pPriv->bufAddr[pPriv->currentBuf] + sx + sy*srcPitch;
-          overlay.PSV =	pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx + sy*srcPitch/2) >> 1);
-          overlay.PSY += FBOFFSET;
-          overlay.PSV += FBOFFSET;
-          overlay.PSY >>= pPriv->shiftValue;
-          overlay.PSV >>= pPriv->shiftValue;
-          overlay.PSU = overlay.PSV;
+       if((!pSiS->MergedFB) || (overlay->DoFirst)) {
+#endif
+          sx = (pPriv->src_x + overlay->srcOffsetX) & ~7;
+          sy = (pPriv->src_y + overlay->srcOffsetY) & ~1;
+          overlay->PSY = pPriv->bufAddr[pPriv->currentBuf] + sx + sy*srcPitch;
+          overlay->PSV =	pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx + sy*srcPitch/2) >> 1);
+          overlay->PSY += FBOFFSET;
+          overlay->PSV += FBOFFSET;
+          overlay->PSY >>= pPriv->shiftValue;
+          overlay->PSV >>= pPriv->shiftValue;
+          overlay->PSU = overlay->PSV;
 #ifdef SISMERGED
        }
-       if((pSiS->MergedFB) && (overlay.DoSecond)) {
-          sx2 = (pPriv->src_x + srcOffsetX2) & ~7;
-          sy2 = (pPriv->src_y + srcOffsetY2) & ~1;
-          overlay.PSY2 = pPriv->bufAddr[pPriv->currentBuf] + sx2 + sy2*srcPitch;
-          overlay.PSV2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx2 + sy2*srcPitch/2) >> 1);
-          overlay.PSY2 += FBOFFSET;
-          overlay.PSV2 += FBOFFSET;
-          overlay.PSY2 >>= pPriv->shiftValue;
-          overlay.PSV2 >>= pPriv->shiftValue;
-          overlay.PSU2 = overlay.PSV2;
+       if((pSiS->MergedFB) && (overlay->DoSecond)) {
+          sx2 = (pPriv->src_x + overlay->srcOffsetX2) & ~7;
+          sy2 = (pPriv->src_y + overlay->srcOffsetY2) & ~1;
+          overlay->PSY2 = pPriv->bufAddr[pPriv->currentBuf] + sx2 + sy2*srcPitch;
+          overlay->PSV2 = pPriv->bufAddr[pPriv->currentBuf] + height*srcPitch + ((sx2 + sy2*srcPitch/2) >> 1);
+          overlay->PSY2 += FBOFFSET;
+          overlay->PSV2 += FBOFFSET;
+          overlay->PSY2 >>= pPriv->shiftValue;
+          overlay->PSV2 >>= pPriv->shiftValue;
+          overlay->PSU2 = overlay->PSV2;
        }
 #endif
        break;
@@ -3019,23 +3378,23 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
      case PIXEL_FMT_RGB6:
      case PIXEL_FMT_RGB5:
      default:
-       overlay.planar = 0;
+       overlay->planar = 0;
 #ifdef SISMERGED
-       if((!pSiS->MergedFB) || (overlay.DoFirst)) {
+       if((!pSiS->MergedFB) || (overlay->DoFirst)) {
 #endif
-          sx = (pPriv->src_x + srcOffsetX) & ~1;
-          sy = (pPriv->src_y + srcOffsetY);
-          overlay.PSY = (pPriv->bufAddr[pPriv->currentBuf] + sx*2 + sy*srcPitch);
-          overlay.PSY += FBOFFSET;
-          overlay.PSY >>= pPriv->shiftValue;
+          sx = (pPriv->src_x + overlay->srcOffsetX) & ~1;
+          sy = (pPriv->src_y + overlay->srcOffsetY);
+          overlay->PSY = (pPriv->bufAddr[pPriv->currentBuf] + sx*2 + sy*srcPitch);
+          overlay->PSY += FBOFFSET;
+          overlay->PSY >>= pPriv->shiftValue;
 #ifdef SISMERGED
        }
-       if((pSiS->MergedFB) && (overlay.DoSecond)) {
-          sx2 = (pPriv->src_x + srcOffsetX2) & ~1;
-          sy2 = (pPriv->src_y + srcOffsetY2);
-          overlay.PSY2 = (pPriv->bufAddr[pPriv->currentBuf] + sx2*2 + sy2*srcPitch);
-          overlay.PSY2 += FBOFFSET;
-          overlay.PSY2 >>= pPriv->shiftValue;
+       if((pSiS->MergedFB) && (overlay->DoSecond)) {
+          sx2 = (pPriv->src_x + overlay->srcOffsetX2) & ~1;
+          sy2 = (pPriv->src_y + overlay->srcOffsetY2);
+          overlay->PSY2 = (pPriv->bufAddr[pPriv->currentBuf] + sx2*2 + sy2*srcPitch);
+          overlay->PSY2 += FBOFFSET;
+          overlay->PSY2 >>= pPriv->shiftValue;
        }
 #endif
        break;
@@ -3043,30 +3402,30 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
 
    /* Some clipping checks */
 #ifdef SISMERGED
-   if((!pSiS->MergedFB) || (overlay.DoFirst)) {
-#endif
-      overlay.srcW = pPriv->src_w - (sx - pPriv->src_x);
-      overlay.srcH = pPriv->src_h - (sy - pPriv->src_y);
-      if( (pPriv->oldx1 != overlay.dstBox.x1) ||
-	  (pPriv->oldx2 != overlay.dstBox.x2) ||
-	  (pPriv->oldy1 != overlay.dstBox.y1) ||
-	  (pPriv->oldy2 != overlay.dstBox.y2) ) {
+   if((!pSiS->MergedFB) || (overlay->DoFirst)) {
+#endif
+      overlay->srcW = pPriv->src_w - (sx - pPriv->src_x);
+      overlay->srcH = pPriv->src_h - (sy - pPriv->src_y);
+      if( (pPriv->oldx1 != overlay->dstBox.x1) ||
+	  (pPriv->oldx2 != overlay->dstBox.x2) ||
+	  (pPriv->oldy1 != overlay->dstBox.y1) ||
+	  (pPriv->oldy2 != overlay->dstBox.y2) ) {
 	 pPriv->mustwait = 1;
-	 pPriv->oldx1 = overlay.dstBox.x1; pPriv->oldx2 = overlay.dstBox.x2;
-	 pPriv->oldy1 = overlay.dstBox.y1; pPriv->oldy2 = overlay.dstBox.y2;
+	 pPriv->oldx1 = overlay->dstBox.x1; pPriv->oldx2 = overlay->dstBox.x2;
+	 pPriv->oldy1 = overlay->dstBox.y1; pPriv->oldy2 = overlay->dstBox.y2;
       }
 #ifdef SISMERGED
    }
-   if((pSiS->MergedFB) && (overlay.DoSecond)) {
-      overlay.srcW2 = pPriv->src_w - (sx2 - pPriv->src_x);
-      overlay.srcH2 = pPriv->src_h - (sy2 - pPriv->src_y);
-      if( (pPriv->oldx1_2 != overlay.dstBox2.x1) ||
-	  (pPriv->oldx2_2 != overlay.dstBox2.x2) ||
-	  (pPriv->oldy1_2 != overlay.dstBox2.y1) ||
-	  (pPriv->oldy2_2 != overlay.dstBox2.y2) ) {
+   if((pSiS->MergedFB) && (overlay->DoSecond)) {
+      overlay->srcW2 = pPriv->src_w - (sx2 - pPriv->src_x);
+      overlay->srcH2 = pPriv->src_h - (sy2 - pPriv->src_y);
+      if( (pPriv->oldx1_2 != overlay->dstBox2.x1) ||
+	  (pPriv->oldx2_2 != overlay->dstBox2.x2) ||
+	  (pPriv->oldy1_2 != overlay->dstBox2.y1) ||
+	  (pPriv->oldy2_2 != overlay->dstBox2.y2) ) {
 	 pPriv->mustwait = 1;
-	 pPriv->oldx1_2 = overlay.dstBox2.x1; pPriv->oldx2_2 = overlay.dstBox2.x2;
-	 pPriv->oldy1_2 = overlay.dstBox2.y1; pPriv->oldy2_2 = overlay.dstBox2.y2;
+	 pPriv->oldx1_2 = overlay->dstBox2.x1; pPriv->oldx2_2 = overlay->dstBox2.x2;
+	 pPriv->oldy1_2 = overlay->dstBox2.y1; pPriv->oldy2_2 = overlay->dstBox2.y2;
       }
    }
 #endif
@@ -3074,67 +3433,67 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
 #ifdef SISMERGED
    /* Disable an overlay if it is not to be displayed (but enabled currently) */
    if((pSiS->MergedFB) && (pPriv->hasTwoOverlays)) {
-      if(!overlay.DoFirst) {
+      /* Disable overlay 0 only on 300 series; on 315 series ov 0
+       * is used for CRT2. (If it's not, both overlays have been
+       * already been disabled in CheckOverlay.)
+       */
+      if(!overlay->DoFirst && (pSiS->VGAEngine == SIS_300_VGA)) {
 	 setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x00, 0x05);
 	 setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
-	 temp = getvideoreg(pSiS,Index_VI_Control_Misc0);
-	 if(temp & 0x02) {
-	    watchdog = WATCHDOG_DELAY;
-	    while((!vblank_active_CRT1(pSiS, pPriv)) && --watchdog);
-	    watchdog = WATCHDOG_DELAY;
-	    while(vblank_active_CRT1(pSiS, pPriv) && --watchdog);
-	    setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-	 }
-      } else if(!overlay.DoSecond) {
+	 disableoverlay(pSiS, pPriv, 0);
+      }
+      /* Disable overlay 1 if it's unused. This is the case on 300
+       * series if it's really unused, or on 315 series, if overlay
+       * 0 takes over (because we only need one).
+       */
+      if(!overlay->DoSecond ||
+	 ((pSiS->VGAEngine == SIS_315_VGA) && !overlay->DoFirst)) {
 	 setvideoregmask(pSiS, Index_VI_Control_Misc2, 0x01, 0x01);
 	 setvideoregmask(pSiS, Index_VI_Control_Misc1, 0x00, 0x01);
-	 temp = getvideoreg(pSiS,Index_VI_Control_Misc0);
-	 if(temp & 0x02) {
-	    watchdog = WATCHDOG_DELAY;
-	    while((!vblank_active_CRT2(pSiS, pPriv)) && --watchdog);
-	    watchdog = WATCHDOG_DELAY;
-	    while(vblank_active_CRT2(pSiS, pPriv) && --watchdog);
-	    setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x00, 0x02);
-	 }
+	 disableoverlay(pSiS, pPriv, 1);
       }
    }
 #endif
 
-   /* Loop head */
+   /* ********* Loop head ********* */
    /* Note: index can only be 1 for CRT2, ie overlay 1
     * is only used for CRT2.
     */
    if(pPriv->displayMode & DISPMODE_SINGLE2) {
       if(pPriv->hasTwoOverlays) {			/* We have 2 overlays: */
 	 if(pPriv->dualHeadMode) {
-	    /* Dual head: We use overlay 2 for CRT2 */
+	    /* Dual head: Use overlay 1 for CRT2 */
 	    index = 1; iscrt2 = 1;
 	 } else {
-	    /* Single head: We use overlay 1 for CRT2 */
+	    /* Single head: Use overlay 0 for CRT2 */
 	    index = 0; iscrt2 = 1;
 	 }
       } else {						/* We have 1 overlay */
-	 /* We use that only overlay for CRT2 */
+	 /* Use that only overlay for CRT2 */
 	 index = 0; iscrt2 = 1;
       }
-      overlay.VBlankActiveFunc = vblank_active_CRT2;
+      overlay->VBlankActiveFunc = vblank_active_CRT2;
 #ifdef SISMERGED
       if(!pPriv->hasTwoOverlays) {
-	 if((pSiS->MergedFB) && (!overlay.DoSecond)) {
+	 if((pSiS->MergedFB) && (!overlay->DoSecond)) {
 	    index = 0; iscrt2 = 0;
-	    overlay.VBlankActiveFunc = vblank_active_CRT1;
+	    overlay->VBlankActiveFunc = vblank_active_CRT1;
 	    pPriv->displayMode = DISPMODE_SINGLE1;
 	 }
       }
 #endif
    } else {
       index = 0; iscrt2 = 0;
-      overlay.VBlankActiveFunc = vblank_active_CRT1;
+      overlay->VBlankActiveFunc = vblank_active_CRT1;
 #ifdef SISMERGED
-      if((pSiS->MergedFB) && (!overlay.DoFirst)) {
-	 if(pPriv->hasTwoOverlays) index = 1;
+      if((pSiS->MergedFB) && (!overlay->DoFirst)) {
+         /* 300 series all have 2 overlays, so we use ov 1 for CRT2.
+          * On 315, we use ov 0 even on dual-overlay-chips for
+          * better scaling if ov 0 is available.
+          */
+	 if(pSiS->VGAEngine == SIS_300_VGA) index = 1;
 	 iscrt2 = 1;
-	 overlay.VBlankActiveFunc = vblank_active_CRT2;
+	 overlay->VBlankActiveFunc = vblank_active_CRT2;
 	 if(!pPriv->hasTwoOverlays) {
 	    pPriv->displayMode = DISPMODE_SINGLE2;
 	 }
@@ -3143,36 +3502,45 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
    }
 
    /* set display mode SR06,32 (CRT1, CRT2 or mirror) */
-   set_disptype_regs(pScrn, pPriv);
+   set_disptype_regs(pScrn, pPriv,
+#ifdef SISMERGED
+		overlay->DoFirst, overlay->DoSecond
+#else
+		TRUE, TRUE
+#endif
+		);
 
    /* set (not only calc) merge line buffer */
 #ifdef SISMERGED
    if(!pSiS->MergedFB) {
 #endif
-      merge_line_buf(pSiS, pPriv, (overlay.srcW > pPriv->linebufMergeLimit), overlay.srcW,
+      merge_line_buf(pSiS, pPriv, (overlay->srcW > pPriv->linebufMergeLimit), overlay->srcW,
       		     pPriv->linebufMergeLimit);
 #ifdef SISMERGED
    } else {
       Bool temp1 = FALSE, temp2 = FALSE;
-      if(overlay.DoFirst) {
-         if(overlay.srcW > pPriv->linebufMergeLimit)  temp1 = TRUE;
+      if(overlay->DoFirst) {
+         if(overlay->srcW > pPriv->linebufMergeLimit)  temp1 = TRUE;
       }
-      if(overlay.DoSecond) {
-         if(overlay.srcW2 > pPriv->linebufMergeLimit) temp2 = TRUE;
+      if(overlay->DoSecond) {
+         if(overlay->srcW2 > pPriv->linebufMergeLimit) temp2 = TRUE;
       }
-      merge_line_buf_mfb(pSiS, pPriv, temp1, temp2, overlay.srcW, overlay.srcW2,
+      merge_line_buf_mfb(pSiS, pPriv, temp1, temp2,
+			 overlay->DoFirst, overlay->DoSecond,
+			 overlay->srcW, overlay->srcW2,
 			 pPriv->linebufMergeLimit);
    }
 #endif
 
    /* calculate (not set!) line buffer length */
 #ifdef SISMERGED
-   if((!pSiS->MergedFB) || (overlay.DoFirst))
+   if((!pSiS->MergedFB) || (overlay->DoFirst))
 #endif
-      calc_line_buf_size_1(&overlay, pPriv);
+      calc_line_buf_size_1(overlay, pPriv);
+
 #ifdef SISMERGED
-   if((pSiS->MergedFB) && (overlay.DoSecond))
-      calc_line_buf_size_2(&overlay, pPriv);
+   if((pSiS->MergedFB) && (overlay->DoSecond))
+      calc_line_buf_size_2(overlay, pPriv);
 #endif
 
    if(pPriv->dualHeadMode) {
@@ -3203,11 +3571,12 @@ SISDisplayVideo(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv)
       /* and might even be dangerous. */
    if(pSiS->VGAEngine == SIS_315_VGA) {
       watchdog = WATCHDOG_DELAY;
-      while(overlay.VBlankActiveFunc(pSiS, pPriv) && --watchdog);
+      while(overlay->VBlankActiveFunc(pSiS, pPriv) && --watchdog);
       setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x00, 0x03);
    }
 #endif
-   setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x03, 0x03);
+	if(pPriv->is670)		setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x00, 0x01);
+	else		setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x03, 0x03);
 
    /* Do the following in a loop for CRT1 and CRT2 ----------------- */
 MIRROR:
@@ -3215,16 +3584,16 @@ MIRROR:
    /* calculate scale factor */
 #ifdef SISMERGED
    if(pSiS->MergedFB && iscrt2)
-      calc_scale_factor_2(&overlay, pScrn, pPriv, index, iscrt2);
+      calc_scale_factor_2(overlay, pScrn, pPriv);
    else
 #endif
-      calc_scale_factor(&overlay, pScrn, pPriv, index, iscrt2);
+      calc_scale_factor(overlay, pScrn, pPriv, iscrt2);
 
-   /* Select overlay 0 (used for CRT1/or CRT2) or overlay 1 (used for CRT2 only) */
+   /* Select overlay 0 (used for CRT1 or CRT2) or overlay 1 (used for CRT2 only) */
    setvideoregmask(pSiS, Index_VI_Control_Misc2, index, 0x01);
 
    /* set format (before color and chroma keys) */
-   set_format(pSiS, &overlay);
+   set_format(pSiS, overlay);
 
    /* set color key */
    set_colorkey(pSiS, pPriv->colorKey);
@@ -3251,31 +3620,28 @@ MIRROR:
     * loop, we omit respective checks here)
     */
    if(!iscrt2) {
-     set_disablegfx(pSiS, pPriv->disablegfx, &overlay);
+     set_disablegfx(pSiS, pPriv->disablegfx, overlay);
    } else if(!pSiS->hasTwoOverlays) {
-     set_disablegfx(pSiS, FALSE, &overlay);
+     set_disablegfx(pSiS, FALSE, overlay);
    }
-   set_disablegfxlr(pSiS, pPriv->disablegfxlr, &overlay);
+   set_disablegfxlr(pSiS, pPriv->disablegfxlr, overlay);
 
-#ifdef SIS_CP
-   SIS_CP_VIDEO_SET_CP
-#endif
 
    /* set remaining overlay parameters */
-   set_overlay(pSiS, &overlay, pPriv, index, iscrt2);
+   set_overlay(pSiS, overlay, pPriv, index, iscrt2);
 
    /* enable overlay */
-   setvideoregmask (pSiS, Index_VI_Control_Misc0, 0x02, 0x02);
+   setvideoregmask(pSiS, Index_VI_Control_Misc0, 0x02, 0x02);
 
    /* loop foot */
-   if(pPriv->displayMode & DISPMODE_MIRROR &&
-      index == 0			   &&
+   if((pPriv->displayMode & DISPMODE_MIRROR) &&
+      (index == 0)			     &&
       pPriv->hasTwoOverlays) {
 #ifdef SISMERGED
-      if((!pSiS->MergedFB) || overlay.DoSecond) {
+      if((!pSiS->MergedFB) || (overlay->DoSecond && overlay->DoFirst)) {
 #endif
 	 index = 1; iscrt2 = 1;
-	 overlay.VBlankActiveFunc = vblank_active_CRT2;
+	 overlay->VBlankActiveFunc = vblank_active_CRT2;
 	 goto MIRROR;
 #ifdef SISMERGED
       }
@@ -3319,12 +3685,12 @@ MIRROR:
    if(pSiS->VGAEngine == SIS_315_VGA) {
       if((pPriv->mustwait) && index) {
 	 watchdog = get_scanline_CRT2(pSiS, pPriv);
-	 if(watchdog <= overlay.oldLine) {
-	    int i, mytop = overlay.oldtop;
-	    int screenHeight = overlay.SCREENheight;
+	 if(watchdog <= overlay->oldLine) {
+	    int i, mytop = overlay->oldtop;
+	    int screenHeight = overlay->SCREENheight;
 #ifdef SISMERGED
 	    if(pSiS->MergedFB) {
-	       screenHeight = overlay.SCREENheight2;
+	       screenHeight = overlay->SCREENheight2;
 	    }
 #endif
 	    if(mytop < screenHeight - 2) {
@@ -3347,7 +3713,8 @@ MIRROR:
 	 }
       }
       /* Trigger register copy for 315/330 series */
-      setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x03, 0x03);
+	  if(pPriv->is670)		setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x01, 0x01);
+	  else	setvideoregmask(pSiS, Index_VI_Control_Misc3, 0x03, 0x03);
    }
 
    pPriv->mustwait = 0;
@@ -3372,7 +3739,7 @@ SISAllocateFBMemory(
   ScrnInfoPtr pScrn,
   void **handle,
   int bytesize
-){
+  ){
    SISPtr pSiS = SISPTR(pScrn);
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
 
@@ -3403,15 +3770,18 @@ SISAllocateFBMemory(
 
          xf86QueryLargestOffscreenLinear(pScreen, &max_size, 8, PRIORITY_EXTREME);
 
-         if(max_size < size)
+         if(max_size < size) {
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	           "Failed to allocate %d pixels of linear video memory\n", size);
 	    return 0;
+	 }
 
          xf86PurgeUnlockedOffscreenAreas(pScreen);
          new_linear = xf86AllocateOffscreenLinear(pScreen, size, 8, NULL, NULL, NULL);
       }
       if(!new_linear) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	           "Xv: Failed to allocate %d pixels of linear video memory\n", size);
+	           "Failed to allocate %d pixels of linear video memory\n", size);
 	 return 0;
       } else {
          *handle = (void *)new_linear;
@@ -3424,7 +3794,8 @@ SISAllocateFBMemory(
       ExaOffscreenArea *area = (ExaOffscreenArea *)(*handle);
 
       if(area) {
-	 if(area->size >= bytesize) return (unsigned int)(area->offset);
+	 if(area->size >= bytesize)
+	    return (unsigned int)(area->offset);
 
 	 exaOffscreenFree(pScreen, area);
 	 *handle = NULL;
@@ -3432,7 +3803,7 @@ SISAllocateFBMemory(
 
       if(!(area = exaOffscreenAlloc(pScreen, bytesize, 8, TRUE, SiSDestroyArea, (pointer)handle))) {
 	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	           "Xv: Failed to allocate %d bytes of video memory\n", bytesize);
+	           "Failed to allocate %d bytes of video memory\n", bytesize);
 	 return 0;
       } else {
 	 *handle = (void *)area;
@@ -3479,8 +3850,14 @@ SISStopVideo(ScrnInfoPtr pScrn, pointer data, Bool shutdown)
   SISPortPrivPtr pPriv = (SISPortPrivPtr)data;
   SISPtr pSiS = SISPTR(pScrn);
 
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] StopVideo is called.\n");
+#endif
+
   if(pPriv->grabbedByV4L) return;
 
+  SISSetPortDefaults(pScrn, pPriv);
+
   REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
 
   if(shutdown) {
@@ -3494,16 +3871,69 @@ SISStopVideo(ScrnInfoPtr pScrn, pointer data, Bool shutdown)
      if(pPriv->videoStatus & CLIENT_VIDEO_ON) {
         UpdateCurrentTime();
         pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
-        pPriv->videoStatus = OFF_TIMER | CLIENT_VIDEO_ON;
+        pPriv->videoStatus |= OFF_TIMER;
         pSiS->VideoTimerCallback = SISVideoTimerCallback;
      }
   }
 }
 
 /*********************************
- *          PutImage()           *
+ *        PutImage() etc         *
  *********************************/
 
+static void
+SiSHandleClipListColorkey(ScrnInfoPtr pScrn, SISPortPrivPtr pPriv, RegionPtr clipBoxes)
+{
+   SISPtr pSiS = SISPTR(pScrn);
+#ifdef SIS_USE_XAA
+   XAAInfoRecPtr pXAA = pSiS->AccelInfoPtr;
+   int depth = pSiS->CurrentLayout.bitsPerPixel >> 3;
+   int myreds[] = { 0x000000ff, 0x0000f800, 0, 0x00ff0000 };
+#endif
+
+   if( pPriv->forceColorkey ||
+       (pPriv->autopaintColorKey &&
+         ( pPriv->grabbedByV4L ||
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,3,0)
+           (!RegionsEqual(&pPriv->clip, clipBoxes)) ||
+#else
+           (!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes)) ||
+#endif
+           (pPriv->PrevOverlay != pPriv->NoOverlay))) ) {
+
+      /* We always paint the colorkey for V4L */
+      if(!pPriv->grabbedByV4L) {
+	 REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
+      }
+
+      /* draw these */
+      pPriv->PrevOverlay = pPriv->NoOverlay;
+      pPriv->forceColorkey = 0;
+#ifdef SIS_USE_XAA
+      if((pPriv->NoOverlay) && pXAA && pXAA->FillMono8x8PatternRects) {
+         (*pXAA->FillMono8x8PatternRects)(pScrn, myreds[depth-1],
+			0x000000, GXcopy, ~0,
+			REGION_NUM_RECTS(clipBoxes),
+			REGION_RECTS(clipBoxes),
+			0x00422418, 0x18244200, 0, 0);
+      } else {
+#endif
+         if(!pSiS->disablecolorkeycurrent) {
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,1,99,1,0)
+            (*pXAA->FillSolidRects)(pScrn, pPriv->colorKey, GXcopy, ~0,
+                           REGION_NUM_RECTS(clipBoxes),
+                           REGION_RECTS(clipBoxes));
+#else
+	    xf86XVFillKeyHelper(pScrn->pScreen, (pPriv->NoOverlay) ? 0x00ff0000 : pPriv->colorKey, clipBoxes);
+#endif
+	 }
+#ifdef SIS_USE_XAA
+      }
+#endif
+
+   }
+}
+
 static int
 SISPutImage(
   ScrnInfoPtr pScrn,
@@ -3514,28 +3944,18 @@ SISPutImage(
   int id, UChar *buf,
   short width, short height,
   Bool sync,
-  RegionPtr clipBoxes, pointer data,
-  DrawablePtr pDraw
+  RegionPtr clipBoxes, pointer data
 ){
    SISPtr pSiS = SISPTR(pScrn);
    SISPortPrivPtr pPriv = (SISPortPrivPtr)data;
-#ifdef SIS_USE_XAA
-   XAAInfoRecPtr pXAA = pSiS->AccelInfoPtr;
-   int depth = pSiS->CurrentLayout.bitsPerPixel >> 3;
-   int myreds[] = { 0x000000ff, 0x0000f800, 0, 0x00ff0000 };
-#endif
-   int totalSize = 0;
-#ifdef SISDEINT
-   Bool	deintfm = (pPriv->deinterlacemethod > 1) ? TRUE : FALSE;
-#endif
-
-#if 0
-   xf86DrvMsg(0, X_INFO, "PutImage: src %dx%d-%dx%d, drw %dx%d-%dx%d, id %x, w %d h %d, buf %p\n",
-	src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w, drw_h, id, width, height, buf);
-#endif
+   SISOverlayRec overlay;
+   int totalSize = 0, result;
+   Bool dorest = TRUE;
 
    if(pPriv->grabbedByV4L) return Success;
 
+   memset(&overlay, 0, sizeof(overlay));
+
    pPriv->drw_x = drw_x;
    pPriv->drw_y = drw_y;
    pPriv->drw_w = drw_w;
@@ -3547,6 +3967,16 @@ SISPutImage(
    pPriv->id = id;
    pPriv->height = height;
 
+   pPriv->isRGB = FALSE;
+
+   pPriv->currentBuf = pPriv->nextBuf;
+
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] PutImage is called: id = %d\n", id);
+#endif
+ 
+
    /* Pixel formats:
       1. YU12:  3 planes:       H    V
                Y sample period  1    1   (8 bit per pixel)
@@ -3581,113 +4011,69 @@ SISPutImage(
 	 as all other planar formats.
    */
 
-   switch(id){
+   switch(id) {
      case PIXEL_FMT_YV12:
      case PIXEL_FMT_I420:
      case PIXEL_FMT_NV12:
      case PIXEL_FMT_NV21:
-       pPriv->srcPitch = (width + 7) & ~7;
+       pPriv->srcPitch = (width + pPriv->PitchAlignmentMask) & ~(pPriv->PitchAlignmentMask);
        /* Size = width * height * 3 / 2 */
        totalSize = (pPriv->srcPitch * height * 3) >> 1; /* Verified */
        break;
+     case PIXEL_FMT_RGB6:
+     case PIXEL_FMT_RGB5:
+       pPriv->isRGB = TRUE;
+       /* fall through */
      case PIXEL_FMT_YUY2:
      case PIXEL_FMT_UYVY:
      case PIXEL_FMT_YVYU:
-     case PIXEL_FMT_RGB6:
-     case PIXEL_FMT_RGB5:
      default:
-       pPriv->srcPitch = ((width << 1) + 3) & ~3;	/* Verified */
+       pPriv->srcPitch = ((width << 1) + 15) & ~15;	/* Verified */
        /* Size = width * 2 * height */
        totalSize = pPriv->srcPitch * height;
    }
 
-   /* make it a multiple of 16 to simplify to copy loop */
-   totalSize += 15;
-   totalSize &= ~15; /* in bytes */
+   result = SISCheckOverlay(pScrn, pPriv, &overlay);
 
-   /* allocate memory (we do doublebuffering) - size is in bytes */
-   if(!(pPriv->bufAddr[0] = SISAllocateFBMemory(pScrn, &pPriv->handle, totalSize << 1)))
-      return BadAlloc;
+   /* returns: 0 = overlay not available, 1 = ok,
+    *          2 = overlay wouldn't be drawn (outside visible screen)
+    */
 
-#ifdef SISDEINT
-   if(deintfm) {
-      pPriv->bufAddr[1] = pPriv->bufAddr[0] + pPriv->srcPitch;
-
-      {
-         CARD8 *src = (CARD8 *)buf;
-         CARD8 *dest = (CARD8 *)(pSiS->FbBase + pPriv->bufAddr[pPriv->currentBuf]);
-         int i = height;
-         while(i--) {
-	    SiSMemCopyToVideoRam(pSiS, dest, src, pPriv->srcPitch);
-	    src += pPriv->srcPitch;
-	    dest += (pPriv->srcPitch << 1);
-         }
+   if(result != 1) {
+      if(pPriv->overlayStatus) {
+	 close_overlay(pSiS, pPriv);
       }
+      pPriv->NoOverlay = TRUE;
+      dorest = FALSE;
+   }
 
-   } else {
-#endif
-      pPriv->bufAddr[1] = pPriv->bufAddr[0] + totalSize;
 
-      /* copy data */
-      if((pSiS->XvUseMemcpy) || (totalSize < 16)) {
+   pSiS->nocolorkey = FALSE;
+
+   if(dorest) {
+
+      /* make it a multiple of 16 to simplify to copy loop */
+      totalSize += 15;
+      totalSize &= ~15; /* in bytes */
+
+      /* allocate memory (we do doublebuffering) - size is in bytes */
+      if(!(pPriv->bufAddr[0] = SISAllocateFBMemory(pScrn, &pPriv->handle, totalSize << 1)))
+         return BadAlloc;
+
+         pPriv->bufAddr[1] = pPriv->bufAddr[0] + totalSize;
+
+         /* copy data */
          SiSMemCopyToVideoRam(pSiS, pSiS->FbBase + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
-      } else {
-         ULong i;
-         CARD32 *src = (CARD32 *)buf;
-         CARD32 *dest = (CARD32 *)(pSiS->FbBase + pPriv->bufAddr[pPriv->currentBuf]);
-         for(i = 0; i < (totalSize/16); i++) {
-            *dest++ = *src++;
-	    *dest++ = *src++;
-	    *dest++ = *src++;
-	    *dest++ = *src++;
-         }
-      }
-#ifdef SISDEINT
-   }
-#endif
 
-   SISDisplayVideo(pScrn, pPriv);
 
-   /* update cliplist */
-   if(pPriv->autopaintColorKey &&
-      (pPriv->grabbedByV4L ||
-#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,3,0)
-       (!RegionsEqual(&pPriv->clip, clipBoxes)) ||
-#else
-       (!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes)) ||
-#endif
-       (pPriv->PrevOverlay != pPriv->NoOverlay))) {
-     /* We always paint the colorkey for V4L */
-     if(!pPriv->grabbedByV4L) {
-     	REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
-     }
-     /* draw these */
-     pPriv->PrevOverlay = pPriv->NoOverlay;
-#ifdef SIS_USE_XAA
-     if((pPriv->NoOverlay) && pXAA && pXAA->FillMono8x8PatternRects) {
-        (*pXAA->FillMono8x8PatternRects)(pScrn, myreds[depth-1],
-			0x000000, GXcopy, ~0,
-			REGION_NUM_RECTS(clipBoxes),
-			REGION_RECTS(clipBoxes),
-			0x00422418, 0x18244200, 0, 0);
-     } else {
-#endif
-        if(!pSiS->disablecolorkeycurrent) {
-#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,1,99,1,0)
-           (*pXAA->FillSolidRects)(pScrn, pPriv->colorKey, GXcopy, ~0,
-                           REGION_NUM_RECTS(clipBoxes),
-                           REGION_RECTS(clipBoxes));
-#else
-	   xf86XVFillKeyHelper(pScrn->pScreen, (pPriv->NoOverlay) ? 0x00ff0000 : pPriv->colorKey, clipBoxes);
-#endif
-	}
-#ifdef SIS_USE_XAA
-     }
-#endif
+      SISDisplayVideo(pScrn, pPriv, &overlay);
 
    }
 
-   pPriv->currentBuf ^= 1;
+   /* update cliplist */
+   SiSHandleClipListColorkey(pScrn, pPriv, clipBoxes);
+
+   if(dorest) pPriv->nextBuf ^= 1;
 
    pPriv->videoStatus = CLIENT_VIDEO_ON;
 
@@ -3696,6 +4082,58 @@ SISPutImage(
    return Success;
 }
 
+static int
+SISReputImage(
+  ScrnInfoPtr pScrn,
+  short drw_x, short drw_y,
+  RegionPtr clipBoxes, pointer data
+){
+   SISPtr pSiS = SISPTR(pScrn);
+   SISPortPrivPtr pPriv = (SISPortPrivPtr)data;
+   SISOverlayRec overlay;
+   int result;
+
+   /* ? */
+   if(pPriv->grabbedByV4L)
+      return Success;
+
+   if(!(pPriv->videoStatus & CLIENT_VIDEO_ON))
+      return BadValue;
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] ReputImage is called\n");
+#endif
+
+   memset(&overlay, 0, sizeof(overlay));
+
+   pPriv->drw_x = drw_x;
+   pPriv->drw_y = drw_y;
+
+   result = SISCheckOverlay(pScrn, pPriv, &overlay);
+
+   /* returns: 0 = overlay not available, 1 = ok,
+    *          2 = overlay wouldn't be drawn (outside visible screen)
+    */
+
+   if(result != 1) {
+
+      if(pPriv->overlayStatus) {
+	 close_overlay(pSiS, pPriv);
+      }
+      pPriv->NoOverlay = TRUE;
+
+   } else {
+
+      SISDisplayVideo(pScrn, pPriv, &overlay);
+
+      /* update cliplist */
+      SiSHandleClipListColorkey(pScrn, pPriv, clipBoxes);
+
+   }
+
+   return Success;
+}
+
 /*********************************
  *     QueryImageAttributes()    *
  *********************************/
@@ -3707,19 +4145,29 @@ SISQueryImageAttributes(
   UShort *w, UShort *h,
   int *pitches, int *offsets
 ){
+    SISPtr pSiS = SISPTR(pScrn);
+    SISPortPrivPtr pPriv = GET_PORT_PRIVATE(pScrn);
     int    pitchY, pitchUV;
     int    size, sizeY, sizeUV;
 
     if(*w < IMAGE_MIN_WIDTH) *w = IMAGE_MIN_WIDTH;
     if(*h < IMAGE_MIN_HEIGHT) *h = IMAGE_MIN_HEIGHT;
 
-    if(*w > DummyEncoding.width) *w = DummyEncoding.width;
-    if(*h > DummyEncoding.height) *h = DummyEncoding.height;
+    if(!pSiS->HaveBlitAdaptor) {
+       if(*w > DummyEncoding.width) *w = DummyEncoding.width;
+       if(*h > DummyEncoding.height) *h = DummyEncoding.height;
+    }
 
     switch(id) {
+    case PIXEL_FMT_IA44:/* subpicture */
+	pitchY = (*w);
+	pitches[0] = pitchY;
+	size = pitchY * (*h);
+	offsets[0] = 0;
+	break;
     case PIXEL_FMT_YV12:
     case PIXEL_FMT_I420:
-        *w = (*w + 7) & ~7;
+        *w = (*w + pPriv->PitchAlignmentMask) & ~(pPriv->PitchAlignmentMask);
         *h = (*h + 1) & ~1;
         pitchY = *w;
     	pitchUV = *w >> 1;
@@ -3760,14 +4208,21 @@ SISQueryImageAttributes(
     case PIXEL_FMT_RGB6:
     case PIXEL_FMT_RGB5:
     default:
-        *w = (*w + 1) & ~1;
-        pitchY = *w << 1;
+        *w = (*w + 15) & ~15;
+        pitchY = (*w << 1);
     	if(pitches) pitches[0] = pitchY;
     	if(offsets) offsets[0] = 0;
     	size = pitchY * (*h);
     	break;
     }
 
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] QueryImageAttributes is called: w=%d, h=%d,  pitchY=%d,  pitchUV=%d\n",
+				*w, *h, pitchY,pitchUV);
+#endif
+
+
     return size;
 }
 
@@ -3815,13 +4270,12 @@ SISAllocSurface (
     close_overlay(pSiS, pPriv);
     pPriv->videoStatus = 0;
     REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
-    pSiS->VideoTimerCallback = NULL;
     pPriv->grabbedByV4L = TRUE;
     return Success;
 }
 
 static int
-SISStopSurface (XF86SurfacePtr surface)
+SISStopSurface(XF86SurfacePtr surface)
 {
     SISPortPrivPtr pPriv = (SISPortPrivPtr)(surface->devPrivate.ptr);
     SISPtr pSiS = SISPTR(surface->pScrn);
@@ -3835,7 +4289,7 @@ SISStopSurface (XF86SurfacePtr surface)
 }
 
 static int
-SISFreeSurface (XF86SurfacePtr surface)
+SISFreeSurface(XF86SurfacePtr surface)
 {
     SISPortPrivPtr pPriv = (SISPortPrivPtr)(surface->devPrivate.ptr);
 
@@ -3860,7 +4314,7 @@ SISGetSurfaceAttribute (
 }
 
 static int
-SISSetSurfaceAttribute(
+SISSetSurfaceAttribute (
     ScrnInfoPtr pScrn,
     Atom attribute,
     INT32 value
@@ -3883,12 +4337,17 @@ SISDisplaySurface (
 {
    ScrnInfoPtr pScrn = surface->pScrn;
    SISPortPrivPtr pPriv = (SISPortPrivPtr)(surface->devPrivate.ptr);
+   SISOverlayRec overlay;
+   int result;
 #ifdef SIS_USE_XAA
    SISPtr pSiS = SISPTR(pScrn);
    int myreds[] = { 0x000000ff, 0x0000f800, 0, 0x00ff0000 };
 #endif
 
-   if(!pPriv->grabbedByV4L) return Success;
+   if(!pPriv->grabbedByV4L)
+      return Success;
+
+   memset(&overlay, 0, sizeof(overlay));
 
    pPriv->drw_x = drw_x;
    pPriv->drw_y = drw_y;
@@ -3904,7 +4363,17 @@ SISDisplaySurface (
    pPriv->currentBuf = 0;
    pPriv->srcPitch = surface->pitches[0];
 
-   SISDisplayVideo(pScrn, pPriv);
+   result = SISCheckOverlay(pScrn, pPriv, &overlay);
+
+   /* returns: 0 = overlay not available, 1 = ok,
+    *          2 = overlay wouldn't be drawn (outside visible screen)
+    */
+
+   if(result == 1) {
+
+      SISDisplayVideo(pScrn, pPriv, &overlay);
+
+   }
 
    if(pPriv->autopaintColorKey) {
 #ifdef SIS_USE_XAA
@@ -3940,6 +4409,7 @@ SISDisplaySurface (
 #define NUMOFFSCRIMAGES_300 4
 #define NUMOFFSCRIMAGES_315 5
 
+
 static XF86OffscreenImageRec SISOffscreenImages[NUMOFFSCRIMAGES_315] =
 {
  {
@@ -4077,7 +4547,7 @@ SISSetupBlitVideo(ScreenPtr pScreen)
 
    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = 0;
-   adapt->name = "SIS 315/330 series Video Blitter";
+   adapt->name = "SIS 315/330/340/350 series Video Blitter";
    adapt->nEncodings = 1;
    adapt->pEncodings = &DummyEncodingBlit;
    adapt->nFormats = NUM_FORMATS;
@@ -4121,12 +4591,16 @@ SISSetupBlitVideo(ScreenPtr pScreen)
    adapt->SetPortAttribute = (SetPortAttributeFuncPtr)SISSetPortAttributeBlit;
    adapt->GetPortAttribute = (GetPortAttributeFuncPtr)SISGetPortAttributeBlit;
    adapt->QueryBestSize = (QueryBestSizeFuncPtr)SISQueryBestSizeBlit;
-   adapt->PutImage = (PutImageFuncPtr)SISPutImageBlit;
+   /* because SIS671 has no sctretch engine, we use old bliter function */ 
+   adapt->PutImage = (pSiS->ChipType == SIS_671) ? (PutImageFuncPtr)SISPutImageBlit_671 : 
+   	(PutImageFuncPtr)SISPutImageBlit; 
    adapt->QueryImageAttributes = SISQueryImageAttributesBlit;
 
    pSiS->blitadaptor = adapt;
 
+#if 0
    pSiS->xvVSync = MAKE_ATOM(sisxvvsync);
+#endif
    pSiS->xvSetDefaults = MAKE_ATOM(sisxvsetdefaults);
 
    SISResetVideoBlit(pScrn);
@@ -4141,13 +4615,16 @@ static int
 SISGetPortAttributeBlit(ScrnInfoPtr pScrn, Atom attribute,
   			INT32 *value, ULong index)
 {
+#if 0
    SISPtr pSiS = SISPTR(pScrn);
    SISBPortPrivPtr pPriv = (SISBPortPrivPtr)(pSiS->blitPriv);
 
    if(attribute == pSiS->xvVSync) {
       *value = pPriv->vsync;
-   } else return BadMatch;
-   return Success;
+      return Success;
+   } else
+#endif
+      return BadMatch;
 }
 
 static int
@@ -4157,10 +4634,13 @@ SISSetPortAttributeBlit(ScrnInfoPtr pScrn, Atom attribute,
    SISPtr pSiS = SISPTR(pScrn);
    SISBPortPrivPtr pPriv = (SISBPortPrivPtr)(pSiS->blitPriv);
 
+#if 0
    if(attribute == pSiS->xvVSync) {
       if((value < 0) || (value > 1)) return BadValue;
       pPriv->vsync = value;
-   } else if(attribute == pSiS->xvSetDefaults) {
+   } else
+#endif
+          if(attribute == pSiS->xvSetDefaults) {
       SISSetPortDefaultsBlit(pScrn, pPriv);
    } else return BadMatch;
    return Success;
@@ -4184,11 +4664,13 @@ SISStopVideoBlit(ScrnInfoPtr pScrn, ULong index, Bool shutdown)
       (*pSiS->SyncAccel)(pScrn);
       pPriv->videoStatus[index] = 0;
       SISFreeFBMemory(pScrn, &pPriv->handle[(int)index]);
+      SISFreeFBMemory(pScrn, &pPriv->ScaleBufHandle[(int)index]);
    }
 }
 
+
 static int
-SISPutImageBlit(
+SISPutImageBlit_671(
   ScrnInfoPtr pScrn,
   short src_x, short src_y,
   short drw_x, short drw_y,
@@ -4197,50 +4679,56 @@ SISPutImageBlit(
   int id, UChar *buf,
   short width, short height,
   Bool sync,
-  RegionPtr clipBoxes, ULong index,
-  DrawablePtr pDraw
+  RegionPtr clipBoxes, ULong index
 ){
    SISPtr pSiS = SISPTR(pScrn);
    SISBPortPrivPtr pPriv = (SISBPortPrivPtr)(pSiS->blitPriv);
-#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,1,99,1,0)
-   XAAInfoRecPtr pXAA = pSiS->AccelInfoPtr;
-#endif
    BoxPtr pbox = REGION_RECTS(clipBoxes);
    int    nbox = REGION_NUM_RECTS(clipBoxes);
-   CARD32 dstbase = 0, offsety, offsetuv, temp;
-   int    totalSize, bytesize=0, h, w, wb, srcPitch;
-   int 	  xoffset = 0, yoffset = 0, left, right, top, bottom;
+   CARD32 bufInFbOffs, dstbase = 0, offsety, offsetuv, temp;
+   int    totalSize, yuvSize, bytesize=0, h, w, wb, srcPitch;
+   int 	  left, right, top, bottom;
    UChar  *ybases, *ubases = NULL, *vbases = NULL, *myubases, *myvbases;
    UChar  *ybased, *uvbased, packed;
    CARD16 *myuvbased;
    SiS_Packet12_YUV MyPacket;
-   Bool first;
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,1,99,1,0)
+   XAAInfoRecPtr pXAA = pSiS->AccelInfoPtr;
+#endif
+   int	  xoffset = 0, yoffset = 0;
+   Bool   first;
+
+   if(index > NUM_BLIT_PORTS)
+      return BadMatch;
 
-   if(index > NUM_BLIT_PORTS) return BadMatch;
+   if(!height || !width)
+      return Success;
 
-   if(!height || !width) return Success;
+   if(width > IMAGE_MAX_WIDTH_BLIT || height > IMAGE_MAX_HEIGHT_BLIT)
+      return BadMatch;
 
    switch(id) {
      case PIXEL_FMT_YV12:
      case PIXEL_FMT_I420:
      case PIXEL_FMT_NV12:
      case PIXEL_FMT_NV21:
-       srcPitch = (width + 7) & ~7;  /* Should come this way anyway */
+       srcPitch = (width + 7) & ~7;		/* Should come this way anyway */
        bytesize = srcPitch * height;
-       totalSize = (bytesize * 3) >> 1;
+       yuvSize = (bytesize * 3) >> 1;
        break;
      case PIXEL_FMT_YUY2:
      case PIXEL_FMT_UYVY:
      case PIXEL_FMT_YVYU:
        srcPitch = ((width << 1) + 3) & ~3;
-       /* Size = width * 2 * height */
-       totalSize = srcPitch * height;
+       yuvSize = srcPitch * height;		/* Size = width * 2 * height */
        bytesize = 0;
        break;
      default:
        return BadMatch;
    }
 
+   totalSize = yuvSize;
+
    /* allocate memory (we do doublebuffering) */
    if(!(pPriv->bufAddr[index][0] = SISAllocateFBMemory(pScrn, &pPriv->handle[index], totalSize << 1)))
       return BadAlloc;
@@ -4271,10 +4759,13 @@ SISPutImageBlit(
       }
    }
 
+   bufInFbOffs = pPriv->bufAddr[index][pPriv->currentBuf[index]];
+
    memset(&MyPacket, 0, sizeof(MyPacket));
 
-   ybased = pSiS->FbBase + pPriv->bufAddr[index][pPriv->currentBuf[index]];
-   uvbased = pSiS->FbBase + pPriv->bufAddr[index][pPriv->currentBuf[index]] + bytesize;
+   ybased =  pSiS->FbBase + bufInFbOffs;
+   uvbased = ybased + bytesize;
+
 
    ybases = buf;
    packed = 0;
@@ -4320,7 +4811,7 @@ SISPutImageBlit(
       wb = srcPitch >> 1;
       h = height >> 1;
       while(h--) {
-         myuvbased = (CARD16*)uvbased;
+         myuvbased = (CARD16 *)uvbased;
          myubases = ubases;
          myvbases = vbases;
 	 w = wb;
@@ -4340,20 +4831,20 @@ SISPutImageBlit(
       }
       break;
    default:
-      SiSMemCopyToVideoRam(pSiS, ybased, ybases, totalSize);
+      SiSMemCopyToVideoRam(pSiS, ybased, ybases, yuvSize);
    }
 
-   dstbase += FBOFFSET;
-
    MyPacket.P12_Header0 = SIS_PACKET12_HEADER0;
    MyPacket.P12_Header1 = SIS_PACKET12_HEADER1;
    MyPacket.P12_Null1 = SIS_NIL_CMD;
    MyPacket.P12_Null2 = SIS_NIL_CMD;
+
    MyPacket.P12_YPitch = MyPacket.P12_UVPitch = srcPitch;
-   MyPacket.P12_DstAddr = dstbase;
-   MyPacket.P12_DstPitch = pSiS->scrnOffset;
    MyPacket.P12_DstHeight = 0x0fff;
 
+   MyPacket.P12_DstAddr = dstbase + FBOFFSET;
+   MyPacket.P12_DstPitch = pSiS->scrnOffset;
+
    MyPacket.P12_Command |= pPriv->AccelCmd		|
 			   SRCVIDEO			|
 			   PATFG			|
@@ -4362,34 +4853,6 @@ SISPutImageBlit(
 			   DSTVIDEO;
 
 
-#if 0 /* Not implemented by hardware! */
-   if(pPriv->vsync) {
-#ifdef SISMERGED
-      if(!pSiS->MergedFB) {
-#endif
-#ifdef SISDUALHEAD
-         if(pSiS->DualHeadMode) {
-	    if(pSiS->SecondHead) {
-	       MyPacket.P12_Command |= pPriv->VBlankTriggerCRT1;
-	    } else {
-	       MyPacket.P12_Command |= pPriv->VBlankTriggerCRT2;
-	    }
-	 } else {
-#endif
-            Bool IsSlaveMode = SiSBridgeIsInSlaveMode(pScrn);
-            if((pSiS->VBFlags & DISPTYPE_DISP2) && !IsSlaveMode)
-	       MyPacket.P12_Command |= pPriv->VBlankTriggerCRT2;
-	    else if((pSiS->VBFlags & DISPTYPE_DISP1) || IsSlaveMode)
-	       MyPacket.P12_Command |= pPriv->VBlankTriggerCRT1;
-#ifdef SISDUALHEAD
-         }
-#endif
-#ifdef SISMERGED
-      }
-#endif
-   }
-#endif
-
    first = TRUE;
    while(nbox--) {
       left = pbox->x1;
@@ -4414,22 +4877,6 @@ SISPutImageBlit(
       MyPacket.P12_RectWidth = right - left;
       MyPacket.P12_RectHeight = bottom - top;
 
-#if 0
-#ifdef SISMERGED
-      if((first) && (pSiS->MergedFB)) {
-         int scrwidth = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2->HDisplay;
-	 int scrheight = ((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2->VDisplay;
-	 if( (right < pSiS->CRT2pScrn->frameX0) ||
-	     (left >= pSiS->CRT2pScrn->frameX0 + scrwidth) ||
-	     (bottom < pSiS->CRT2pScrn->frameY0) ||
-	     (top >= pSiS->CRT2pScrn->frameY0 + scrheight) ) {
-	    MyPacket.P12_Command |= pPriv->VBlankTriggerCRT1;
-	 } else {
-	    MyPacket.P12_Command |= pPriv->VBlankTriggerCRT2;
-	 }
-      }
-#endif
-#endif
 
       offsety = offsetuv = 0;
       if(packed) {
@@ -4439,19 +4886,9 @@ SISPutImageBlit(
          if(pbox->x1 > drw_x + xoffset) {
             offsetuv += ((pbox->x1 - drw_x - xoffset) << 1);
 	    if(offsetuv & 3) {
-#if 0	       /* Paint over covering object - no */
-	       if(MyPacket.P12_DstX > 0) {
-	          offsetuv &= ~3;
-	          MyPacket.P12_DstX--;
-	          MyPacket.P12_RectWidth++;
-	       } else {
-#endif
-	          offsetuv = (offsetuv + 3) & ~3;
-	          MyPacket.P12_DstX++;
-	          MyPacket.P12_RectWidth--;
-#if 0
-	       }
-#endif
+	       offsetuv = (offsetuv + 3) & ~3;
+	       MyPacket.P12_DstX++;
+	       MyPacket.P12_RectWidth--;
 	    }
          }
       } else {
@@ -4476,22 +4913,301 @@ SISPutImageBlit(
       MyPacket.P12_YSrcAddr  = pPriv->bufAddr[index][pPriv->currentBuf[index]] + offsety + FBOFFSET;
       MyPacket.P12_UVSrcAddr = pPriv->bufAddr[index][pPriv->currentBuf[index]] + bytesize + offsetuv + FBOFFSET;
       SISWriteBlitPacket(pSiS, (CARD32*)&MyPacket);
-#if 0
-      MyPacket.P12_Command &= ~(pPriv->VBlankTriggerCRT1 | pPriv->VBlankTriggerCRT2);
-#endif
+
       first = FALSE;
 mycont:
-      pbox++;
+	 pbox++;
    }
 
-#if 0
-   {
-   int debug = 0;
-   while( (SIS_MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000) { debug++; };
-   while( (SIS_MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000) { debug++; };
-   xf86DrvMsg(0, X_INFO, "vsync %d, debug %d\n", pPriv->vsync, debug);
+
+   pPriv->currentBuf[index] ^= 1;
+
+   UpdateCurrentTime();
+   pPriv->freeTime[index] = currentTime.milliseconds + FREE_DELAY;
+   pPriv->videoStatus[index] = FREE_TIMER;
+
+   pSiS->VideoTimerCallback = SISVideoTimerCallback;
+
+   return Success;
+}
+
+
+static int
+SISPutImageBlit(
+  ScrnInfoPtr pScrn,
+  short src_x, short src_y,
+  short drw_x, short drw_y,
+  short src_w, short src_h,
+  short drw_w, short drw_h,
+  int id, UChar *buf,
+  short width, short height,
+  Bool sync,
+  RegionPtr clipBoxes, ULong index
+){
+   SISPtr pSiS = SISPTR(pScrn);
+   SISBPortPrivPtr pPriv = (SISBPortPrivPtr)(pSiS->blitPriv);
+   BoxPtr pbox = REGION_RECTS(clipBoxes);
+   int    nbox = REGION_NUM_RECTS(clipBoxes);
+   CARD32 bufInFbOffs, dstbase = 0, offsety, offsetuv, temp;
+   int    totalSize, yuvSize, bytesize=0, h, w, wb, srcPitch;
+   int 	  left, right, top, bottom;
+   UChar  *ybases, *ubases = NULL, *vbases = NULL, *myubases, *myvbases;
+   UChar  *ybased, *uvbased, packed;
+   CARD16 *myuvbased;
+   SiS_Packet12_YUV MyPacket;
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,1,99,1,0)
+   XAAInfoRecPtr pXAA = pSiS->AccelInfoPtr;
+#endif
+   int	  xoffset = 0, yoffset = 0;
+   Bool   first;
+
+   /* for scaling */
+   int ScaleBufSize;
+   SiS_Packet12_Stretch ScalePacket;
+   short MM_x, mm_x, stretch_x;
+   short MM_y, mm_y, stretch_y;
+   short diff_x, diff_y;
+
+#ifdef XVDEBUG
+	xf86DrvMsg(0, X_INFO, "[Xv] PutImageBlit is called: id = %d\n", id);
+	xf86DrvMsg(0, X_INFO, "[Xv] src_x = %d, src_y = %d, src_w = %d, src_h = %d,\
+		drw_x = %d, drw_y = %d, drw_w = %d, drw_h = %d, width = %d, height = %d\n", 
+		src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w, drw_h, width, height);
+#endif
+
+   if(index > NUM_BLIT_PORTS)
+      return BadMatch;
+
+   if(!height || !width)
+      return Success;
+
+   if(width > IMAGE_MAX_WIDTH_BLIT || height > IMAGE_MAX_HEIGHT_BLIT)
+      return BadMatch;
+
+   switch(id) {
+     case PIXEL_FMT_YV12:
+     case PIXEL_FMT_I420:
+     case PIXEL_FMT_NV12:
+     case PIXEL_FMT_NV21:
+       srcPitch = (width + 7) & ~7;		/* Should come this way anyway */
+       bytesize = srcPitch * height;
+       yuvSize = (bytesize * 3) >> 1;
+       break;
+     case PIXEL_FMT_YUY2:
+     case PIXEL_FMT_UYVY:
+     case PIXEL_FMT_YVYU:
+       srcPitch = ((width << 1) + 3) & ~3;
+       yuvSize = srcPitch * height;		/* Size = width * 2 * height */
+       bytesize = 0;
+       break;
+     default:
+       return BadMatch;
+   }
+
+   totalSize = yuvSize;
+   ScaleBufSize =  srcPitch * height * 4;
+   
+   /* allocate memory (we do doublebuffering) */
+   if(!(pPriv->bufAddr[index][0] = SISAllocateFBMemory(pScrn, &pPriv->handle[index], totalSize << 1)))
+      return BadAlloc;
+   
+   if(!(pPriv->ScaleBufAddr[index][0] = SISAllocateFBMemory(pScrn, &pPriv->ScaleBufHandle[index], ScaleBufSize << 1)))
+      return BadAlloc;
+
+   pPriv->bufAddr[index][1] = pPriv->bufAddr[index][0] + totalSize;
+   pPriv->ScaleBufAddr[index][1] = pPriv->ScaleBufAddr[index][0] + ScaleBufSize;
+
+
+   bufInFbOffs = pPriv->bufAddr[index][pPriv->currentBuf[index]];
+
+   memset(&MyPacket, 0, sizeof(MyPacket));
+
+   ybased =  pSiS->FbBase + bufInFbOffs;
+   uvbased = ybased + bytesize;
+
+
+   ybases = buf;
+   packed = 0;
+
+   switch(id) {
+     case PIXEL_FMT_YV12:
+	vbases = buf + bytesize;
+	ubases = buf + bytesize*5/4;
+	break;
+     case PIXEL_FMT_I420:
+	ubases = buf + bytesize;
+	vbases = buf + bytesize*5/4;
+	break;
+     case PIXEL_FMT_NV12:
+        MyPacket.P12_Command = YUV_FORMAT_NV12;
+        break;
+     case PIXEL_FMT_NV21:
+        MyPacket.P12_Command = YUV_FORMAT_NV21;
+        break;
+     case PIXEL_FMT_YUY2:
+        MyPacket.P12_Command = YUV_FORMAT_YUY2;
+	packed = 1;
+        break;
+     case PIXEL_FMT_UYVY:
+        MyPacket.P12_Command = YUV_FORMAT_UYVY;
+	packed = 1;
+        break;
+     case PIXEL_FMT_YVYU:
+        MyPacket.P12_Command = YUV_FORMAT_YVYU;
+	packed = 1;
+        break;
+     default:
+        return BadMatch;
    }
+
+   switch(id) {
+   case PIXEL_FMT_YV12:
+   case PIXEL_FMT_I420:
+      MyPacket.P12_Command = YUV_FORMAT_NV12;
+      /* Copy y plane */
+      SiSMemCopyToVideoRam(pSiS, ybased, ybases, bytesize);
+      /* Copy u/v planes */
+      wb = srcPitch >> 1;
+      h = height >> 1;
+      while(h--) {
+         myuvbased = (CARD16 *)uvbased;
+         myubases = ubases;
+         myvbases = vbases;
+	 w = wb;
+	 while(w--) {
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+ 	    temp =  (*myubases++) << 8;
+	    temp |= (*myvbases++);
+#else
+	    temp =  (*myvbases++) << 8;
+	    temp |= (*myubases++);
 #endif
+	    *myuvbased++ = temp;
+	 }
+	 uvbased += srcPitch;
+	 ubases += wb;
+	 vbases += wb;
+      }
+      break;
+   default:
+      SiSMemCopyToVideoRam(pSiS, ybased, ybases, yuvSize);
+   }
+
+   MyPacket.P12_Header0 = SIS_PACKET12_HEADER0;
+   MyPacket.P12_Header1 = SIS_PACKET12_HEADER1;
+   MyPacket.P12_Null1 = SIS_NIL_CMD;
+   MyPacket.P12_Null2 = SIS_NIL_CMD;
+
+   MyPacket.P12_YPitch = MyPacket.P12_UVPitch = srcPitch;
+   MyPacket.P12_DstHeight = src_h;
+
+   MyPacket.P12_DstAddr = pPriv->ScaleBufAddr[index][pPriv->currentBuf[index]] + FBOFFSET;/*dstbase + FBOFFSET;*/
+   MyPacket.P12_DstPitch = srcPitch * 4;
+   
+   MyPacket.P12_Command |= pPriv->AccelCmd		|
+			   SRCVIDEO			|
+			   PATFG			|
+			   pSiS->SiS310_AccelDepth	|
+			   YUV_CMD_YUV			|
+			   DSTVIDEO;
+
+   MyPacket.P12_DstX = 0;
+   MyPacket.P12_DstY = 0;
+   MyPacket.P12_RectWidth = src_w;
+   MyPacket.P12_RectHeight = src_h;
+
+   MyPacket.P12_YSrcAddr  = pPriv->bufAddr[index][pPriv->currentBuf[index]] + FBOFFSET;
+   MyPacket.P12_UVSrcAddr = pPriv->bufAddr[index][pPriv->currentBuf[index]] + bytesize + FBOFFSET;
+   SISWriteBlitPacket(pSiS, (CARD32*)&MyPacket);
+
+
+   /* setting stretch packet */
+   memset(&ScalePacket, 0, sizeof(SiS_Packet12_Stretch));
+
+   ScalePacket.P12_Header0 = SIS_PACKET12_HEADER0;
+   ScalePacket.P12_Header1 = SIS_PACKET12_HEADER1;
+   ScalePacket.P12_Null1 = SIS_NIL_CMD;
+   ScalePacket.P12_Null2 = SIS_NIL_CMD;
+   ScalePacket.P12_SrcPitch = srcPitch * 4;
+   ScalePacket.P12_SrcX = src_x;  ScalePacket.P12_SrcY = src_y;
+   ScalePacket.P12_SrcWidth= src_w;  ScalePacket.P12_SrcHeight= src_h;  
+   ScalePacket.P12_SrcAddr = pPriv->ScaleBufAddr[index][pPriv->currentBuf[index]] + FBOFFSET; 
+   
+   
+   ScalePacket.P12_DstHeight = 0x0fff;
+   ScalePacket.P12_DstAddr = dstbase + FBOFFSET;
+   ScalePacket.P12_DstPitch = pSiS->scrnOffset;
+   
+
+   ScalePacket.P12_DstX = drw_x;  
+   ScalePacket.P12_DstY = drw_y;
+   ScalePacket.P12_RectWidth = drw_w;  
+   ScalePacket.P12_RectHeight= drw_h;
+   
+   
+   if(drw_w > src_w){
+      MM_x = drw_w;  mm_x = src_w;   stretch_x = 1;
+   }else{
+      MM_x = src_w;  mm_x = drw_w;    stretch_x = 0;
+   }
+   diff_x = 2 * (mm_x - MM_x);
+
+   if(drw_h > src_h){
+      MM_y = drw_h;  mm_y = src_h;   stretch_y = 1;
+   }else{
+      MM_y = src_h;  mm_y = drw_h;    stretch_y = 0;
+   }
+   diff_y = 2 * (mm_y - MM_y);
+
+   ScalePacket.P12_InitErrorX = (stretch_x == 1) ? (src_w + diff_x) : src_w;  
+   ScalePacket.P12_X_K1 = 2 * mm_x;
+   ScalePacket.P12_X_K2 = diff_x;
+
+   ScalePacket.P12_InitErrorY =  (stretch_y == 1) ? (src_h + diff_y) : src_h; 
+   ScalePacket.P12_Y_K1 = 2 * mm_y;
+   ScalePacket.P12_Y_K2 = diff_y;
+
+   ScalePacket.P12_Command |= STRETCH_BITBLT		|
+			   SRCVIDEO			|
+			   0xcc00		|/* ROP: Src only */
+			   STRETCH_SRC_X_INC	|	
+			   STRETCH_SRC_Y_INC	|
+			   STRETCH_DST_X_INC	|
+			   STRETCH_DST_Y_INC	|
+			   CLIPENABLE		|
+			   pSiS->SiS310_AccelDepth	;
+
+
+   first = TRUE;
+   while(nbox--) {
+      left = pbox->x1;
+      if(left >= drw_x + drw_w) goto mycont;
+
+      right = pbox->x2;
+      if(right <= drw_x) goto mycont;
+
+      top = pbox->y1;
+      if(top >= drw_y + drw_h) goto mycont;
+
+      bottom = pbox->y2;
+      if(bottom <= drw_y) goto mycont;
+
+      if(left < drw_x) left = drw_x;
+      if(right > (drw_x + drw_w)) right = drw_x + drw_w;
+      if(top < drw_y) top = drw_y;
+      if(bottom > (drw_y + drw_h)) bottom = drw_y + drw_h;
+
+      ScalePacket.P12_ClipLeft= left;
+      ScalePacket.P12_ClipTop = top;
+      ScalePacket.P12_ClipRight = right;
+      ScalePacket.P12_ClipBottom = bottom;
+
+      SISWriteBlitPacket(pSiS, (CARD32*)&ScalePacket);
+
+      first = FALSE;
+mycont:
+	 pbox++;
+   }
 
    pPriv->currentBuf[index] ^= 1;
 
@@ -4504,6 +5220,8 @@ mycont:
    return Success;
 }
 
+
+
 static int
 SISQueryImageAttributesBlit(
   ScrnInfoPtr pScrn,
@@ -4578,9 +5296,8 @@ SISQueryBestSizeBlit(
   unsigned int *p_w, unsigned int *p_h,
   ULong index
 ){
-  /* We cannot scale */
-  *p_w = vid_w;
-  *p_h = vid_h;
+  *p_w = drw_w;
+  *p_h = drw_h;
 }
 #endif /* INCL_YUV */
 
@@ -4606,28 +5323,25 @@ SISVideoTimerCallback(ScrnInfoPtr pScrn, Time now)
        if(!pPriv->videoStatus) pPriv = NULL;
     }
 
-    if(pPriv) {
-       if(pPriv->videoStatus & TIMER_MASK) {
-          if(pPriv->videoStatus & OFF_TIMER) {
+    if(pPriv && !pPriv->grabbedByV4L) {
+       if(pPriv->videoStatus & OFF_TIMER) {
+	  setcallback = TRUE;
+	  if(pPriv->offTime < now) {
+	     sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
+             close_overlay(pSiS, pPriv);
+	     outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
+	     pPriv->mustwait = 1;
+             pPriv->videoStatus = FREE_TIMER;
+             pPriv->freeTime = now + FREE_DELAY;
+	  }
+       } else if(pPriv->videoStatus & FREE_TIMER) {
+	  if(pPriv->freeTime < now) {
+             SISFreeFBMemory(pScrn, &pPriv->handle);
+	     pPriv->mustwait = 1;
+             pPriv->videoStatus = 0;
+          } else {
 	     setcallback = TRUE;
-	     if(pPriv->offTime < now) {
-                /* Turn off the overlay */
-	        sridx = inSISREG(SISSR); cridx = inSISREG(SISCR);
-                close_overlay(pSiS, pPriv);
-	        outSISREG(SISSR, sridx); outSISREG(SISCR, cridx);
-	        pPriv->mustwait = 1;
-                pPriv->videoStatus = FREE_TIMER;
-                pPriv->freeTime = now + FREE_DELAY;
-	     }
-          } else if(pPriv->videoStatus & FREE_TIMER) {
-	     if(pPriv->freeTime < now) {
-                SISFreeFBMemory(pScrn, &pPriv->handle);
-	        pPriv->mustwait = 1;
-                pPriv->videoStatus = 0;
-             } else {
-	        setcallback = TRUE;
-	     }
-          }
+	  }
        }
     }
 
diff --git a/src/sis_video.h b/src/sis_video.h
index c15c068..5aba747 100644
--- a/src/sis_video.h
+++ b/src/sis_video.h
@@ -105,10 +105,12 @@ static int 	SISSetPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
 static int 	SISGetPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);
 static void 	SISQueryBestSize(ScrnInfoPtr, Bool, short, short, short,
 			short, unsigned int *,unsigned int *, pointer);
-static int 	SISPutImage( ScrnInfoPtr,
+static int 	SISPutImage(ScrnInfoPtr,
 			short, short, short, short, short, short, short, short,
-			int, UChar *, short, short, Bool, RegionPtr, pointer,
-			DrawablePtr);
+			int, UChar *, short, short, Bool, RegionPtr, pointer);
+static int	SISReputImage(ScrnInfoPtr pScrn,
+			short drw_x, short drw_y,
+			RegionPtr clipBoxes, pointer data);
 static int 	SISQueryImageAttributes(ScrnInfoPtr,
 			int, UShort *, UShort *, int *, int *);
 static void 	SISVideoTimerCallback(ScrnInfoPtr pScrn, Time now);
@@ -128,28 +130,29 @@ static int 	SISSetPortAttributeBlit(ScrnInfoPtr, Atom, INT32, ULong);
 static int 	SISGetPortAttributeBlit(ScrnInfoPtr, Atom ,INT32 *, ULong);
 static void 	SISQueryBestSizeBlit(ScrnInfoPtr, Bool, short, short, short,
 			short, unsigned int *,unsigned int *, ULong);
+static int 	SISPutImageBlit_671( ScrnInfoPtr,
+			short, short, short, short, short, short, short, short,
+			int, UChar *, short, short, Bool, RegionPtr, ULong);
 static int 	SISPutImageBlit( ScrnInfoPtr,
 			short, short, short, short, short, short, short, short,
-			int, UChar *, short, short, Bool, RegionPtr, ULong,
-			DrawablePtr);
+			int, UChar *, short, short, Bool, RegionPtr, ULong);
 static int 	SISQueryImageAttributesBlit(ScrnInfoPtr,
 			int, UShort *, UShort *, int *, int *);
 extern void     SISWriteBlitPacket(SISPtr pSiS, CARD32 *packet);
 #endif
 
-#ifdef XV_SD_DEPRECATED
+#ifdef TWDEBUG
 extern int	SISSetPortUtilAttribute(ScrnInfoPtr pScrn, Atom attribute,
 					INT32 value, SISPortPrivPtr pPriv);
-extern int	SISGetPortUtilAttribute(ScrnInfoPtr pScrn,  Atom attribute,
-					INT32 *value, SISPortPrivPtr pPriv);
 #endif
 
+
 #define OFF_DELAY   	200    /* milliseconds */
 #define FREE_DELAY  	30000
+
 #define OFF_TIMER   	0x01
 #define FREE_TIMER  	0x02
 #define CLIENT_VIDEO_ON 0x04
-
 #define TIMER_MASK      (OFF_TIMER | FREE_TIMER)
 
 #define WATCHDOG_DELAY  200000 /* Watchdog counter for Vertical Restrace waiting */
@@ -216,72 +219,15 @@ static char sisxvinsidechromakey[] 			= "XV_INSIDE_CHROMAKEY";
 static char sisxvyuvchromakey[] 			= "XV_YUV_CHROMAKEY";
 static char sisxvchromamin[] 				= "XV_CHROMAMIN";
 static char sisxvchromamax[] 				= "XV_CHROMAMAX";
-#ifdef SISDEINT
-static char sisxvdeinterlace[]				= "XV_OVERLAY_DEINTERLACING_METHOD";
-#endif
-#ifdef XV_SD_DEPRECATED
-static char sisxvqueryvbflags[] 			= "XV_QUERYVBFLAGS";
-static char sisxvsdgetdriverversion[] 			= "XV_SD_GETDRIVERVERSION";
-static char sisxvsdgethardwareinfo[]			= "XV_SD_GETHARDWAREINFO";
-static char sisxvsdgetbusid[] 				= "XV_SD_GETBUSID";
-static char sisxvsdqueryvbflagsversion[] 		= "XV_SD_QUERYVBFLAGSVERSION";
-static char sisxvsdgetsdflags[] 			= "XV_SD_GETSDFLAGS";
-static char sisxvsdgetsdflags2[] 			= "XV_SD_GETSDFLAGS2";
-static char sisxvsdunlocksisdirect[] 			= "XV_SD_UNLOCKSISDIRECT";
-static char sisxvsdsetvbflags[] 			= "XV_SD_SETVBFLAGS";
-static char sisxvsdquerydetecteddevices[] 		= "XV_SD_QUERYDETECTEDDEVICES";
-static char sisxvsdcrt1status[] 			= "XV_SD_CRT1STATUS";
-static char sisxvsdcheckmodeindexforcrt2[] 		= "XV_SD_CHECKMODEINDEXFORCRT2";
-static char sisxvsdresultcheckmodeindexforcrt2[] 	= "XV_SD_RESULTCHECKMODEINDEXFORCRT2";
-static char sisxvsdredetectcrt2[]			= "XV_SD_REDETECTCRT2DEVICES";
-static char sisxvsdsisantiflicker[] 			= "XV_SD_SISANTIFLICKER";
-static char sisxvsdsissaturation[] 			= "XV_SD_SISSATURATION";
-static char sisxvsdsisedgeenhance[] 			= "XV_SD_SISEDGEENHANCE";
-static char sisxvsdsiscolcalibf[] 			= "XV_SD_SISCOLCALIBF";
-static char sisxvsdsiscolcalibc[] 			= "XV_SD_SISCOLCALIBC";
-static char sisxvsdsiscfilter[] 			= "XV_SD_SISCFILTER";
-static char sisxvsdsisyfilter[] 			= "XV_SD_SISYFILTER";
-static char sisxvsdchcontrast[] 			= "XV_SD_CHCONTRAST";
-static char sisxvsdchtextenhance[] 			= "XV_SD_CHTEXTENHANCE";
-static char sisxvsdchchromaflickerfilter[] 		= "XV_SD_CHCHROMAFLICKERFILTER";
-static char sisxvsdchlumaflickerfilter[] 		= "XV_SD_CHLUMAFLICKERFILTER";
-static char sisxvsdchcvbscolor[] 			= "XV_SD_CHCVBSCOLOR";
-static char sisxvsdchoverscan[]				= "XV_SD_CHOVERSCAN";
-static char sisxvsdenablegamma[]			= "XV_SD_ENABLEGAMMA";
-static char sisxvsdtvxscale[] 				= "XV_SD_TVXSCALE";
-static char sisxvsdtvyscale[] 				= "XV_SD_TVYSCALE";
-static char sisxvsdgetscreensize[] 			= "XV_SD_GETSCREENSIZE";
-static char sisxvsdstorebrir[] 				= "XV_SD_STOREDGAMMABRIR";
-static char sisxvsdstorebrig[] 				= "XV_SD_STOREDGAMMABRIG";
-static char sisxvsdstorebrib[] 				= "XV_SD_STOREDGAMMABRIB";
-static char sisxvsdstorepbrir[] 			= "XV_SD_STOREDGAMMAPBRIR";
-static char sisxvsdstorepbrig[] 			= "XV_SD_STOREDGAMMAPBRIG";
-static char sisxvsdstorepbrib[] 			= "XV_SD_STOREDGAMMAPBRIB";
-static char sisxvsdstorebrir2[]				= "XV_SD_STOREDGAMMABRIR2";
-static char sisxvsdstorebrig2[]				= "XV_SD_STOREDGAMMABRIG2";
-static char sisxvsdstorebrib2[]				= "XV_SD_STOREDGAMMABRIB2";
-static char sisxvsdstorepbrir2[] 			= "XV_SD_STOREDGAMMAPBRIR2";
-static char sisxvsdstorepbrig2[] 			= "XV_SD_STOREDGAMMAPBRIG2";
-static char sisxvsdstorepbrib2[] 			= "XV_SD_STOREDGAMMAPBRIB2";
-static char sisxvsdstoregarc2[]				= "XV_SD_GAMMACRT2R";
-static char sisxvsdstoregagc2[]				= "XV_SD_GAMMACRT2G";
-static char sisxvsdstoregabc2[]				= "XV_SD_GAMMACRT2B";
-static char sisxvsdstorebrirc2[]			= "XV_SD_STOREDGAMMABRIRC2";
-static char sisxvsdstorebrigc2[]			= "XV_SD_STOREDGAMMABRIGC2";
-static char sisxvsdstorebribc2[]			= "XV_SD_STOREDGAMMABRIBC2";
-static char sisxvsdstorepbrirc2[] 			= "XV_SD_STOREDGAMMAPBRIRC2";
-static char sisxvsdstorepbrigc2[] 			= "XV_SD_STOREDGAMMAPBRIGC2";
-static char sisxvsdstorepbribc2[] 			= "XV_SD_STOREDGAMMAPBRIBC2";
-static char sisxvsdhidehwcursor[] 			= "XV_SD_HIDEHWCURSOR";
-static char sisxvsdpanelmode[] 				= "XV_SD_PANELMODE";
 #ifdef TWDEBUG
 static char sisxvsetreg[]				= "XV_SD_SETREG";
 #endif
-#endif /* XV_SD_DEPRECATED */
 
 #ifdef INCL_YUV_BLIT_ADAPTOR
+#if 0
 static char sisxvvsync[]				= "XV_SYNC_TO_VBLANK";
 #endif
+#endif
 
 /***********************************************/
 /*               OVERLAY ADAPTOR               */
@@ -313,67 +259,6 @@ static XF86AttributeRec SISAttributes_300[] =
    {XvSettable | XvGettable, 0, 1,             sisxvyuvchromakey},
    {XvSettable | XvGettable, 0, (1 << 24) - 1, sisxvchromamin},
    {XvSettable | XvGettable, 0, (1 << 24) - 1, sisxvchromamax},
-#ifdef SISDEINT
-   {XvSettable | XvGettable, 0, 4,             sisxvdeinterlace},
-#endif
-#ifdef XV_SD_DEPRECATED
-   {             XvGettable, 0, -1,    	       sisxvqueryvbflags},
-   {             XvGettable, 0, -1,	       sisxvsdgetdriverversion},
-   {             XvGettable, 0, -1,    	       sisxvsdgethardwareinfo},
-   {             XvGettable, 0, -1,    	       sisxvsdgetbusid},
-   {             XvGettable, 0, -1,    	       sisxvsdqueryvbflagsversion},
-   {             XvGettable, 0, -1,    	       sisxvsdgetsdflags},
-   {             XvGettable, 0, -1,    	       sisxvsdgetsdflags2},
-   {XvSettable | XvGettable, 0, -1,    	       sisxvsdunlocksisdirect},
-   {XvSettable             , 0, -1,    	       sisxvsdsetvbflags},
-   {             XvGettable, 0, -1,    	       sisxvsdquerydetecteddevices},
-   {XvSettable | XvGettable, 0, 1,    	       sisxvsdcrt1status},
-   {XvSettable             , 0, -1,    	       sisxvsdcheckmodeindexforcrt2},
-   {             XvGettable, 0, -1,    	       sisxvsdresultcheckmodeindexforcrt2},
-   {XvSettable             , 0, 0,             sisxvsdredetectcrt2},
-   {XvSettable | XvGettable, 0, 4,             sisxvsdsisantiflicker},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdsissaturation},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdsisedgeenhance},
-   {XvSettable | XvGettable, -128, 127,        sisxvsdsiscolcalibf},
-   {XvSettable | XvGettable, -120, 120,        sisxvsdsiscolcalibc},
-   {XvSettable | XvGettable, 0, 1,             sisxvsdsiscfilter},
-   {XvSettable | XvGettable, 0, 8,             sisxvsdsisyfilter},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchcontrast},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchtextenhance},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchchromaflickerfilter},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchlumaflickerfilter},
-   {XvSettable | XvGettable, 0, 1,             sisxvsdchcvbscolor},
-   {XvSettable | XvGettable, 0, 3,             sisxvsdchoverscan},
-   {XvSettable | XvGettable, 0, 3,             sisxvsdenablegamma},
-   {XvSettable | XvGettable, -16, 16,          sisxvsdtvxscale},
-   {XvSettable | XvGettable, -4, 3,            sisxvsdtvyscale},
-   {             XvGettable, 0, -1,    	       sisxvsdgetscreensize},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrir},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrig},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrib},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrir},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrig},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrib},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrir2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrig2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrib2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrir2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrig2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrib2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstoregarc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstoregagc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstoregabc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrirc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrigc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebribc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrirc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrigc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbribc2},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdpanelmode},
-#endif
-#ifdef SIS_CP
-   SIS_CP_VIDEO_ATTRIBUTES
-#endif
    {0                      , 0, 0,             NULL}
 };
 
@@ -398,71 +283,9 @@ static XF86AttributeRec SISAttributes_315[] =
    {XvSettable | XvGettable, 0, 1,             sisxvinsidechromakey},
    {XvSettable | XvGettable, 0, (1 << 24) - 1, sisxvchromamin},
    {XvSettable | XvGettable, 0, (1 << 24) - 1, sisxvchromamax},
-#ifdef SISDEINT
-   {XvSettable | XvGettable, 0, 4,             sisxvdeinterlace},
-#endif
-#ifdef XV_SD_DEPRECATED
-   {             XvGettable, 0, -1,    	       sisxvqueryvbflags},
-   {             XvGettable, 0, -1,    	       sisxvsdgetdriverversion},
-   {             XvGettable, 0, -1,    	       sisxvsdgethardwareinfo},
-   {             XvGettable, 0, -1,    	       sisxvsdgetbusid},
-   {             XvGettable, 0, -1,    	       sisxvsdqueryvbflagsversion},
-   {             XvGettable, 0, -1,   	       sisxvsdgetsdflags},
-   {             XvGettable, 0, -1,   	       sisxvsdgetsdflags2},
-   {XvSettable | XvGettable, 0, -1,   	       sisxvsdunlocksisdirect},
-   {XvSettable             , 0, -1,   	       sisxvsdsetvbflags},
-   {             XvGettable, 0, -1,    	       sisxvsdquerydetecteddevices},
-   {XvSettable | XvGettable, 0, 1,    	       sisxvsdcrt1status},
-   {XvSettable             , 0, -1,    	       sisxvsdcheckmodeindexforcrt2},
-   {             XvGettable, 0, -1,   	       sisxvsdresultcheckmodeindexforcrt2},
-   {XvSettable             , 0, 0,             sisxvsdredetectcrt2},
-   {XvSettable | XvGettable, 0, 4,             sisxvsdsisantiflicker},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdsissaturation},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdsisedgeenhance},
-   {XvSettable | XvGettable, -128, 127,        sisxvsdsiscolcalibf},
-   {XvSettable | XvGettable, -120, 120,        sisxvsdsiscolcalibc},
-   {XvSettable | XvGettable, 0, 1,             sisxvsdsiscfilter},
-   {XvSettable | XvGettable, 0, 8,             sisxvsdsisyfilter},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchcontrast},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchtextenhance},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchchromaflickerfilter},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdchlumaflickerfilter},
-   {XvSettable | XvGettable, 0, 1,             sisxvsdchcvbscolor},
-   {XvSettable | XvGettable, 0, 3,             sisxvsdchoverscan},
-   {XvSettable | XvGettable, 0, 7,             sisxvsdenablegamma},
-   {XvSettable | XvGettable, -16, 16,          sisxvsdtvxscale},
-   {XvSettable | XvGettable, -4, 3,            sisxvsdtvyscale},
-   {             XvGettable, 0, -1,   	       sisxvsdgetscreensize},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrir},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrig},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrib},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrir},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrig},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrib},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrir2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrig2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrib2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrir2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrig2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrib2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstoregarc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstoregagc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstoregabc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrirc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebrigc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorebribc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrirc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbrigc2},
-   {XvSettable | XvGettable, 100, 10000,       sisxvsdstorepbribc2},
-   {XvSettable | XvGettable, 0, 1,             sisxvsdhidehwcursor},
-   {XvSettable | XvGettable, 0, 15,            sisxvsdpanelmode},
 #ifdef TWDEBUG
    {XvSettable             , 0, -1,   	       sisxvsetreg},
 #endif
-#endif  /* XV_SD_DEPRECATED */
-#ifdef SIS_CP
-   SIS_CP_VIDEO_ATTRIBUTES
-#endif
    {XvSettable | XvGettable, 0, 1,             sisxvswitchcrt},
    {0                      , 0, 0,             NULL}
 };
@@ -480,6 +303,8 @@ static XF86AttributeRec SISAttributes_315[] =
 #define PIXEL_FMT_YVYU 0x55595659   /* 315/330+ only */
 #define PIXEL_FMT_NV12 0x3231564e   /* 330+ only */
 #define PIXEL_FMT_NV21 0x3132564e   /* 330+ only */
+#define PIXEL_FMT_IA44 FOURCC_IA44 /* 0x34344149 */
+#define PIXEL_FMT_AI44 FOURCC_AI44 /* 0x34344941 */
 
 /* TODO: */
 #define PIXEL_FMT_RAW8 0x38574152
@@ -578,12 +403,15 @@ static XF86ImageRec SISImages[NUM_IMAGES_330] =
    },
 };
 
+
 typedef struct {
     int pixelFormat;
 
     CARD16  pitch;
     CARD16  origPitch;
 
+    int     srcOffsetX, srcOffsetY;
+
     CARD8   keyOP;
     CARD16  HUSF;
     CARD16  VUSF;
@@ -618,6 +446,9 @@ typedef struct {
 
     CARD16  srcW2;
     CARD16  srcH2;
+
+    int     srcOffsetX2, srcOffsetY2;
+
     BoxRec  dstBox2;
     CARD32  PSY2;
     CARD32  PSV2;
@@ -640,7 +471,7 @@ typedef struct {
 
     CARD16  oldLine, oldtop;
 
-    CARD8   (*VBlankActiveFunc)(SISPtr, SISPortPrivPtr);
+    CARD8   (*VBlankActiveFunc)(SISPtr, SISPortPrivPtr);  
 #if 0
     CARD32  (*GetScanLineFunc)(SISPtr pSiS);
 #endif
@@ -655,11 +486,14 @@ typedef struct {
 
 #define NUM_BLIT_PORTS 16
 
+#define IMAGE_MAX_WIDTH_BLIT    2046
+#define IMAGE_MAX_HEIGHT_BLIT   2046
+
 static XF86VideoEncodingRec DummyEncodingBlit =
 {
    0,
    "XV_IMAGE",
-   2046, 2046,
+   IMAGE_MAX_WIDTH_BLIT, IMAGE_MAX_HEIGHT_BLIT,
    {1, 1}
 };
 
@@ -673,7 +507,7 @@ static XF86AttributeRec SISAttributes_Blit[NUM_ATTRIBUTES_BLIT] =
    {XvSettable             , 0, 0,             sisxvsetdefaults}
 };
 
-#define NUM_IMAGES_BLIT 7
+#define NUM_IMAGES_BLIT 7 /* 9 */
 
 static XF86ImageRec SISImagesBlit[NUM_IMAGES_BLIT] =
 {
@@ -682,6 +516,42 @@ static XF86ImageRec SISImagesBlit[NUM_IMAGES_BLIT] =
    XVIMAGE_YV12,
    XVIMAGE_UYVY,
    XVIMAGE_I420,
+#if 0
+   { /* RGB 555 */
+      PIXEL_FMT_RGB5,
+      XvRGB,
+      LSBFirst,
+      {'R','V','1','5',
+       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+      16,
+      XvPacked,
+      1,
+      15, 0x7C00, 0x03E0, 0x001F,
+      0, 0, 0,
+      0, 0, 0,
+      0, 0, 0,
+      {'R', 'V', 'B',0,
+       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
+      XvTopToBottom
+   },
+   { /* RGB 565 */
+      PIXEL_FMT_RGB6,
+      XvRGB,
+      LSBFirst,
+      {'R','V','1','6',
+       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+      16,
+      XvPacked,
+      1,
+      16, 0xF800, 0x07E0, 0x001F,
+      0, 0, 0,
+      0, 0, 0,
+      0, 0, 0,
+      {'R', 'V', 'B',0,
+       0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
+      XvTopToBottom
+   },
+#endif
    {  /* YVYU */
       PIXEL_FMT_YVYU, \
       XvYUV, \
@@ -739,6 +609,9 @@ typedef struct {
     void *	 handle[NUM_BLIT_PORTS];
     CARD32       bufAddr[NUM_BLIT_PORTS][2];
 
+    void *	 ScaleBufHandle[NUM_BLIT_PORTS];
+    CARD32       ScaleBufAddr[NUM_BLIT_PORTS][2];
+
     UChar        currentBuf[NUM_BLIT_PORTS];
 
     RegionRec    blitClip[NUM_BLIT_PORTS];
diff --git a/src/sis_videostr.h b/src/sis_videostr.h
index 5bbac50..1e3d9c5 100644
--- a/src/sis_videostr.h
+++ b/src/sis_videostr.h
@@ -43,12 +43,13 @@ typedef struct {
     void *	 handle;
     CARD32	 bufAddr[2];
 
-    UChar	 currentBuf;
+    UChar	 currentBuf, nextBuf;
 
     short	 drw_x, drw_y, drw_w, drw_h;
     short	 src_x, src_y, src_w, src_h;
     int		 id;
     short	 srcPitch, height;
+    Bool	 isRGB;
 
     char         brightness;
     UChar        contrast;
@@ -58,6 +59,7 @@ typedef struct {
     RegionRec    clip;
     CARD32       colorKey;
     Bool 	 autopaintColorKey;
+    int		 forceColorkey;
 
     Bool 	 disablegfx;
     Bool	 disablegfxlr;
@@ -65,9 +67,6 @@ typedef struct {
     Bool         usechromakey;
     Bool	 insidechromakey, yuvchromakey;
     CARD32	 chromamin, chromamax;
-#ifdef SISDEINT
-    int		 deinterlacemethod;
-#endif
 
     CARD32       videoStatus;
     Bool	 overlayStatus;
@@ -96,6 +95,7 @@ typedef struct {
 
     short  	 linebufMergeLimit;
     CARD8        linebufmask;
+    CARD8 	PitchAlignmentMask;
 
     short        oldx1, oldx2, oldy1, oldy2;
 #ifdef SISMERGED
@@ -117,6 +117,7 @@ typedef struct {
     Bool	 is760;
     Bool	 is340;
     Bool	 is761;
+    Bool	 is670;
     Bool	 isXGI;
 
 } SISPortPrivRec, *SISPortPrivPtr;
diff --git a/src/sispcirename.h b/src/sispcirename.h
new file mode 100644
index 0000000..c4beac6
--- /dev/null
+++ b/src/sispcirename.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2007 George Sapountzis
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/**
+ * Macros for porting drivers from legacy xfree86 PCI code to the pciaccess
+ * library. The main purpose being to facilitate source code compatibility.
+ */
+
+#ifndef SISPCIRENAME_H
+#define SISPCIRENAME_H
+
+enum region_type {
+    REGION_MEM,
+    REGION_IO 
+};
+
+#ifndef XSERVER_LIBPCIACCESS
+
+/* pciVideoPtr */
+#define PCI_DEV_VENDOR_ID(_pcidev) ((_pcidev)->vendor)
+#define PCI_DEV_DEVICE_ID(_pcidev) ((_pcidev)->chipType)
+#define PCI_DEV_REVISION(_pcidev)  ((_pcidev)->chipRev)
+
+#define PCI_SUB_VENDOR_ID(_pcidev) ((_pcidev)->subsysVendor)
+#define PCI_SUB_DEVICE_ID(_pcidev) ((_pcidev)->subsysCard)
+
+#define PCI_DEV_TAG(_pcidev) pciTag((_pcidev)->bus,    \
+                                    (_pcidev)->device, \
+                                    (_pcidev)->func)
+#define PCI_DEV_BUS(_pcidev)       ((_pcidev)->bus)
+#define PCI_DEV_DEV(_pcidev)       ((_pcidev)->device)
+#define PCI_DEV_FUNC(_pcidev)      ((_pcidev)->func)
+
+/* pciConfigPtr */
+#define PCI_CFG_TAG(_pcidev)  (((pciConfigPtr)(_pcidev)->thisCard)->tag)
+#define PCI_CFG_BUS(_pcidev)  (((pciConfigPtr)(_pcidev)->thisCard)->busnum)
+#define PCI_CFG_DEV(_pcidev)  (((pciConfigPtr)(_pcidev)->thisCard)->devnum)
+#define PCI_CFG_FUNC(_pcidev) (((pciConfigPtr)(_pcidev)->thisCard)->funcnum)
+
+/* region addr: xfree86 uses different fields for memory regions and I/O ports */
+#define PCI_REGION_BASE(_pcidev, _b, _type)             \
+    (((_type) == REGION_MEM) ? (_pcidev)->memBase[(_b)] \
+                             : (_pcidev)->ioBase[(_b)])
+
+/* region size: xfree86 uses the log2 of the region size,
+ * but with zero meaning no region, not size of one XXX */
+#define PCI_REGION_SIZE(_pcidev, _b) \
+    (((_pcidev)->size[(_b)] > 0) ? (1 << (_pcidev)->size[(_b)]) : 0)
+
+/* read/write PCI configuration space */
+#define PCI_READ_BYTE(_pcidev, _value_ptr, _offset) \
+    *(_value_ptr) = pciReadByte(PCI_CFG_TAG(_pcidev), (_offset))
+
+#define PCI_READ_LONG(_pcidev, _value_ptr, _offset) \
+    *(_value_ptr) = pciReadLong(PCI_CFG_TAG(_pcidev), (_offset))
+
+#define PCI_WRITE_LONG(_pcidev, _value, _offset) \
+    pciWriteLong(PCI_CFG_TAG(_pcidev), (_offset), (_value))
+
+#else /* XSERVER_LIBPCIACCESS */
+
+typedef struct pci_device *pciVideoPtr;
+
+#define PCI_DEV_VENDOR_ID(_pcidev) ((_pcidev)->vendor_id)
+#define PCI_DEV_DEVICE_ID(_pcidev) ((_pcidev)->device_id)
+#define PCI_DEV_REVISION(_pcidev)  ((_pcidev)->revision)
+
+#define PCI_SUB_VENDOR_ID(_pcidev) ((_pcidev)->subvendor_id)
+#define PCI_SUB_DEVICE_ID(_pcidev) ((_pcidev)->subdevice_id)
+
+/* pci-rework functions take a 'pci_device' parameter instead of a tag */
+#define PCI_DEV_TAG(_pcidev)        (_pcidev)
+
+/* PCI_DEV macros, typically used in printf's, add domain ? XXX */
+#define PCI_DEV_BUS(_pcidev)       ((_pcidev)->bus)
+#define PCI_DEV_DEV(_pcidev)       ((_pcidev)->dev)
+#define PCI_DEV_FUNC(_pcidev)      ((_pcidev)->func)
+
+/* pci-rework functions take a 'pci_device' parameter instead of a tag */
+#define PCI_CFG_TAG(_pcidev)        (_pcidev)
+
+/* PCI_CFG macros, typically used in DRI init, contain the domain */
+#define PCI_CFG_BUS(_pcidev)      (((_pcidev)->domain << 8) | \
+                                    (_pcidev)->bus)
+#define PCI_CFG_DEV(_pcidev)       ((_pcidev)->dev)
+#define PCI_CFG_FUNC(_pcidev)      ((_pcidev)->func)
+
+#define PCI_REGION_BASE(_pcidev, _b, _type) ((_pcidev)->regions[(_b)].base_addr)
+#define PCI_REGION_SIZE(_pcidev, _b)        ((_pcidev)->regions[(_b)].size)
+
+#define PCI_READ_BYTE(_pcidev, _value_ptr, _offset) \
+    pci_device_cfg_read_u8((_pcidev), (_value_ptr), (_offset))
+
+#define PCI_READ_LONG(_pcidev, _value_ptr, _offset) \
+    pci_device_cfg_read_u32((_pcidev), (_value_ptr), (_offset))
+
+#define PCI_WRITE_LONG(_pcidev, _value, _offset) \
+    pci_device_cfg_write_u32((_pcidev), (_value), (_offset))
+
+#endif /* XSERVER_LIBPCIACCESS */
+
+#endif /* SISPCIRENAME_H */
diff --git a/src/vgatypes.h b/src/vgatypes.h
index 1a217ce..ef88b54 100644
--- a/src/vgatypes.h
+++ b/src/vgatypes.h
@@ -106,15 +106,16 @@ typedef enum _SIS_CHIP_TYPE {
     SIS_330,
     SIS_661,
     SIS_741,
-    SIS_670,
     SIS_660 = 35,
     SIS_760,
-    SIS_761,
-    SIS_762,
-    SIS_770,
     SIS_340 = 55,
     SIS_341,
     SIS_342,
+    SIS_761,
+    SIS_662 ,
+    SIS_670 = 62,
+    SIS_770,
+    SIS_671,
     XGI_20  = 75,
     XGI_40,
     MAX_SIS_CHIP
diff --git a/src/vstruct.h b/src/vstruct.h
index 3142fdf..10b9ac4 100644
--- a/src/vstruct.h
+++ b/src/vstruct.h
@@ -233,6 +233,8 @@ struct SiS_ModeResInfo_S {
 #define CUT_UNKNOWNLCD		19
 #define CUT_AOP8060		20
 #define CUT_PANEL856		21
+#define CUT_ICOP550		22
+#define CUT_ICOP550_2		23
 
 struct SiS_Private
 {
@@ -246,6 +248,8 @@ struct SiS_Private
 #endif
 	unsigned char 			*VirtualRomBase;
 	BOOLEAN				UseROM;
+	Bool				MergedFB;
+	int                                    BIOSVersion;
 #ifdef SIS_LINUX_KERNEL
 	unsigned char SISIOMEMTYPE	*VideoMemoryAddress;
 	unsigned int			VideoMemorySize;
@@ -298,6 +302,7 @@ struct SiS_Private
 	BOOLEAN				SiS_CHSOverScan;
 	BOOLEAN				SiS_ChSW;
 	BOOLEAN				SiS_UseLCDA;
+	BOOLEAN				SiS_EnableBackLight;
 	int				SiS_UseOEM;
 	unsigned int			SiS_CustomT;
 	int				SiS_UseWide, SiS_UseWideCRT2;
@@ -383,6 +388,8 @@ struct SiS_Private
 
 	const struct SiS_PanelDelayTbl	*SiS_PanelDelayTbl;
 	const struct SiS_PanelDelayTbl	*SiS_PanelDelayTblLVDS;
+       BOOLEAN		UseFutroTiming;		/*for Fuji-Siemans Futro*/
+	
 
 	/* SiS bridge */
 
@@ -403,6 +410,10 @@ struct SiS_Private
 	const struct SiS_LCDData	*SiS_ExtLCD1600x1200Data;
 	const struct SiS_LCDData	*SiS_LCD1680x1050Data;
 	const struct SiS_LCDData	*SiS_NoScaleData;
+
+	const struct SiS_LCDData        *SiS_LCD1440x900Data;/*Ivans add 1440x900*/
+	const struct SiS_LCDData        *SiS_LCD1366x768Data;/*1366x768. Ivans@090109*/
+
 	const struct SiS_TVData		*SiS_StPALData;
 	const struct SiS_TVData		*SiS_ExtPALData;
 	const struct SiS_TVData		*SiS_StNTSCData;
-- 
1.6.2.4

