diff -up dhcp-4.2.0/client/dhc6.c.release6-elapsed dhcp-4.2.0/client/dhc6.c
--- dhcp-4.2.0/client/dhc6.c.release6-elapsed	2010-07-21 16:19:52.000000000 +0200
+++ dhcp-4.2.0/client/dhc6.c	2010-07-21 16:21:14.000000000 +0200
@@ -2177,7 +2177,7 @@ do_release6(void *input)
 	struct client_state *client;
 	struct data_string ds;
 	int send_ret;
-	struct timeval tv;
+	struct timeval elapsed, tv;
 
 	client = input;
 
@@ -2197,6 +2197,14 @@ do_release6(void *input)
 		client->start_time.tv_usec = cur_tv.tv_usec;
 	}
 
+	/* elapsed = cur - start */
+	elapsed.tv_sec = cur_tv.tv_sec - client->start_time.tv_sec;
+	elapsed.tv_usec = cur_tv.tv_usec - client->start_time.tv_usec;
+	if (elapsed.tv_usec < 0) {
+		elapsed.tv_sec -= 1;
+		elapsed.tv_usec += 1000000;
+	}
+
 	/*
 	 * Don't use unicast as we don't know if we still have an
 	 * available address with enough scope.
@@ -2213,6 +2221,18 @@ do_release6(void *input)
 	ds.buffer->data[0] = DHCPV6_RELEASE;
 	memcpy(ds.buffer->data + 1, client->dhcpv6_transaction_id, 3);
 
+	/* Form an elapsed option. */
+	/* Maximum value is 65535 1/100s coded as 0xffff. */
+	if ((elapsed.tv_sec < 0) || (elapsed.tv_sec > 655) ||
+	    ((elapsed.tv_sec == 655) && (elapsed.tv_usec > 350000))) {
+		client->elapsed = 0xffff;
+	} else {
+		client->elapsed = elapsed.tv_sec * 100;
+		client->elapsed += elapsed.tv_usec / 10000;
+	}
+
+	client->elapsed = htons(client->elapsed);
+
 	log_debug("XMT: Forming Release.");
 	make_client6_options(client, &client->sent_options,
 			     client->active_lease, DHCPV6_RELEASE);
