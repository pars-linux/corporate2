Index: src/appl/gssftp/ftpd/ftpd.c
===================================================================
--- src/appl/gssftp/ftpd/ftpd.c.orig
+++ src/appl/gssftp/ftpd/ftpd.c
@@ -1823,7 +1823,7 @@ reply(n, fmt, p0, p1, p2, p3, p4, p5)
 		 * radix_encode, gss_seal, plus slop.
 		 */
 		char in[FTP_BUFSIZ*3/2], out[FTP_BUFSIZ*3/2];
-		int length, kerror;
+		int length = 0, kerror;
 		if (n) sprintf(in, "%d%c", n, cont_char);
 		else in[0] = '\0';
 		strncat(in, buf, sizeof (in) - strlen(in) - 1);
Index: src/lib/rpc/svc_auth_gss.c
===================================================================
--- src/lib/rpc/svc_auth_gss.c.orig
+++ src/lib/rpc/svc_auth_gss.c
@@ -671,7 +671,7 @@ svcauth_gss_get_principal(SVCAUTH *auth)
 
 	gd = SVCAUTH_PRIVATE(auth);
 
-	if (gd->cname.length == 0)
+	if (gd->cname.length == 0 || gd->cname.length >= SIZE_MAX)
 		return (NULL);
 
 	if ((pname = malloc(gd->cname.length + 1)) == NULL)
Index: src/lib/gssapi/krb5/k5sealv3.c
===================================================================
--- src/lib/gssapi/krb5/k5sealv3.c.orig
+++ src/lib/gssapi/krb5/k5sealv3.c
@@ -248,7 +248,6 @@ gss_krb5int_make_seal_token_v3 (krb5_con
 	plain.data = 0;
 	if (err) {
 	    zap(outbuf,bufsize);
-	    free(outbuf);
 	    goto error;
 	}
 	if (sum.length != ctx->cksum_size)
Index: src/lib/gssapi/mechglue/g_initialize.c
===================================================================
--- src/lib/gssapi/mechglue/g_initialize.c.orig
+++ src/lib/gssapi/mechglue/g_initialize.c
@@ -208,7 +208,7 @@ gss_OID_set *mechSet;
 				free((*mechSet)->elements[j].elements);
 			}
 			free((*mechSet)->elements);
-			free(mechSet);
+			free(*mechSet);
 			*mechSet = NULL;
 			return (GSS_S_FAILURE);
 		}
Index: src/lib/kdb/kdb_default.c
===================================================================
--- src/lib/kdb/kdb_default.c.orig
+++ src/lib/kdb/kdb_default.c
@@ -185,8 +185,7 @@ krb5_def_store_mkey(context, keyfile, mn
 		kf) != key->length)) {
 	retval = errno;
 	(void) fclose(kf);
-    }
-    if (fclose(kf) == EOF)
+    } else if (fclose(kf) == EOF)
 	retval = errno;
 #if HAVE_UMASK
     (void) umask(oumask);
