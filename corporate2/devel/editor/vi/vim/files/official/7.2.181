To: vim-dev@vim.org
Subject: Patch 7.2.181
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.181
Problem:    Some more compiler warnings when using gcc -Wextra.
Solution:   Add UNUSED and type casts.
Files:	    src/if_mzsch.c, src/gui.c, src/gui_gtk.c, src/gui_gtk_x11.c,
	    src/gui_gtk_f.c, src/gui_beval.c, src/netbeans.c


*** ../vim-7.2.180/src/if_mzsch.c	2007-07-06 19:43:08.000000000 +0200
--- src/if_mzsch.c	2009-05-16 22:24:18.000000000 +0200
***************
*** 667,679 ****
      static void CALLBACK
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
- /*ARGSUSED*/
      static gint
! timer_proc(gpointer data)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
- /* ARGSUSED */
      static void
! timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
--- 667,677 ----
      static void CALLBACK
  timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
  # elif defined(FEAT_GUI_GTK)
      static gint
! timer_proc(gpointer data UNUSED)
  # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
      static void
! timer_proc(XtPointer timed_out UNUSED, XtIntervalId *interval_id UNUSED)
  # elif defined(FEAT_GUI_MAC)
      pascal void
  timer_proc(EventLoopTimerRef theTimer, void *userData)
*** ../vim-7.2.180/src/gui.c	2008-12-03 18:50:09.000000000 +0100
--- src/gui.c	2009-05-17 15:52:18.000000000 +0200
***************
*** 678,688 ****
   * Return OK when able to set the font.  When it failed FAIL is returned and
   * the fonts are unchanged.
   */
- /*ARGSUSED*/
      int
  gui_init_font(font_list, fontset)
      char_u	*font_list;
!     int		fontset;
  {
  #define FONTLEN 320
      char_u	font_name[FONTLEN];
--- 678,687 ----
   * Return OK when able to set the font.  When it failed FAIL is returned and
   * the fonts are unchanged.
   */
      int
  gui_init_font(font_list, fontset)
      char_u	*font_list;
!     int		fontset UNUSED;
  {
  #define FONTLEN 320
      char_u	font_name[FONTLEN];
***************
*** 1138,1147 ****
   * Position the various GUI components (text area, menu).  The vertical
   * scrollbars are NOT handled here.  See gui_update_scrollbars().
   */
- /*ARGSUSED*/
      static void
  gui_position_components(total_width)
!     int	    total_width;
  {
      int	    text_area_x;
      int	    text_area_y;
--- 1137,1145 ----
   * Position the various GUI components (text area, menu).  The vertical
   * scrollbars are NOT handled here.  See gui_update_scrollbars().
   */
      static void
  gui_position_components(total_width)
!     int	    total_width UNUSED;
  {
      int	    text_area_x;
      int	    text_area_y;
***************
*** 1374,1383 ****
   * If "fit_to_display" is TRUE then the size may be reduced to fit the window
   * on the screen.
   */
- /*ARGSUSED*/
      void
  gui_set_shellsize(mustset, fit_to_display, direction)
!     int		mustset;		/* set by the user */
      int		fit_to_display;
      int		direction;		/* RESIZE_HOR, RESIZE_VER */
  {
--- 1372,1380 ----
   * If "fit_to_display" is TRUE then the size may be reduced to fit the window
   * on the screen.
   */
      void
  gui_set_shellsize(mustset, fit_to_display, direction)
!     int		mustset UNUSED;		/* set by the user */
      int		fit_to_display;
      int		direction;		/* RESIZE_HOR, RESIZE_VER */
  {
***************
*** 3120,3126 ****
   * If "oldval" is not NULL, "oldval" is the previous value, the new value is
   * in p_go.
   */
- /*ARGSUSED*/
      void
  gui_init_which_components(oldval)
      char_u	*oldval;
--- 3117,3122 ----
***************
*** 4411,4417 ****
      if (curwin->w_p_wrap)
  	return FALSE;
  
!     if (curwin->w_leftcol == scrollbar_value)
  	return FALSE;
  
      curwin->w_leftcol = (colnr_T)scrollbar_value;
--- 4407,4413 ----
      if (curwin->w_p_wrap)
  	return FALSE;
  
!     if ((long_u)curwin->w_leftcol == scrollbar_value)
  	return FALSE;
  
      curwin->w_leftcol = (colnr_T)scrollbar_value;
***************
*** 4424,4430 ****
  	    && longest_lnum < curwin->w_botline
  	    && !virtual_active())
      {
! 	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
  	{
  	    curwin->w_cursor.lnum = longest_lnum;
  	    curwin->w_cursor.col = 0;
--- 4420,4426 ----
  	    && longest_lnum < curwin->w_botline
  	    && !virtual_active())
      {
! 	if (scrollbar_value > (long_u)scroll_line_len(curwin->w_cursor.lnum))
  	{
  	    curwin->w_cursor.lnum = longest_lnum;
  	    curwin->w_cursor.col = 0;
***************
*** 4670,4676 ****
  /*
   * Find window where the mouse pointer "y" coordinate is in.
   */
- /*ARGSUSED*/
      static win_T *
  xy2win(x, y)
      int		x;
--- 4666,4671 ----
***************
*** 5124,5130 ****
   * of dropped files, they will be freed in this function, and caller can't use
   * fnames after call this function.
   */
- /*ARGSUSED*/
      void
  gui_handle_drop(x, y, modifiers, fnames, count)
      int		x;
--- 5119,5124 ----
*** ../vim-7.2.180/src/gui_gtk.c	2008-07-31 22:29:28.000000000 +0200
--- src/gui_gtk.c	2009-05-17 16:06:30.000000000 +0200
***************
*** 285,298 ****
      return image;
  }
  
- /*ARGSUSED*/
      static gint
! toolbar_button_focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
! {
!     /* When we're in a GtkPlug, we don't have window focus events, only widget focus.
!      * To emulate stand-alone gvim, if a button gets focus (e.g., <Tab> into GtkPlug)
!      * immediately pass it to mainwin.
!      */
      if (gtk_socket_id != 0)
  	gtk_widget_grab_focus(gui.drawarea);
  
--- 285,298 ----
      return image;
  }
  
      static gint
! toolbar_button_focus_in_event(GtkWidget *widget UNUSED,
! 			      GdkEventFocus *event UNUSED,
! 			      gpointer data UNUSED)
! {
!     /* When we're in a GtkPlug, we don't have window focus events, only widget
!      * focus.  To emulate stand-alone gvim, if a button gets focus (e.g.,
!      * <Tab> into GtkPlug) immediately pass it to mainwin. */
      if (gtk_socket_id != 0)
  	gtk_widget_grab_focus(gui.drawarea);
  
***************
*** 585,593 ****
      gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
  }
  
- /*ARGSUSED*/
      static void
! menu_item_activate(GtkWidget *widget, gpointer data)
  {
      gui_menu_cb((vimmenu_T *)data);
  
--- 585,592 ----
      gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
  }
  
      static void
! menu_item_activate(GtkWidget *widget UNUSED, gpointer data)
  {
      gui_menu_cb((vimmenu_T *)data);
  
***************
*** 1202,1210 ****
  #endif
  
  #ifndef USE_FILE_CHOOSER
- /*ARGSUSED*/
      static void
! browse_ok_cb(GtkWidget *widget, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
--- 1201,1208 ----
  #endif
  
  #ifndef USE_FILE_CHOOSER
      static void
! browse_ok_cb(GtkWidget *widget UNUSED, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
***************
*** 1218,1226 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static void
! browse_cancel_cb(GtkWidget *widget, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
--- 1216,1223 ----
  	gtk_main_quit();
  }
  
      static void
! browse_cancel_cb(GtkWidget *widget UNUSED, gpointer cbdata)
  {
      gui_T *vw = (gui_T *)cbdata;
  
***************
*** 1234,1242 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static gboolean
! browse_destroy_cb(GtkWidget * widget)
  {
      if (gui.browse_fname != NULL)
      {
--- 1231,1238 ----
  	gtk_main_quit();
  }
  
      static gboolean
! browse_destroy_cb(GtkWidget *widget UNUSED)
  {
      if (gui.browse_fname != NULL)
      {
***************
*** 1262,1275 ****
   * initdir			initial directory, NULL for current dir
   * filter			not used (file name filter)
   */
- /*ARGSUSED*/
      char_u *
! gui_mch_browse(int saving,
  	       char_u *title,
  	       char_u *dflt,
! 	       char_u *ext,
  	       char_u *initdir,
! 	       char_u *filter)
  {
  #ifdef USE_FILE_CHOOSER
      GtkWidget		*fc;
--- 1258,1270 ----
   * initdir			initial directory, NULL for current dir
   * filter			not used (file name filter)
   */
      char_u *
! gui_mch_browse(int saving UNUSED,
  	       char_u *title,
  	       char_u *dflt,
! 	       char_u *ext UNUSED,
  	       char_u *initdir,
! 	       char_u *filter UNUSED)
  {
  #ifdef USE_FILE_CHOOSER
      GtkWidget		*fc;
***************
*** 1377,1383 ****
   * dflt				default name
   * initdir			initial directory, NULL for current dir
   */
- /*ARGSUSED*/
      char_u *
  gui_mch_browsedir(
  	       char_u *title,
--- 1372,1377 ----
***************
*** 1460,1466 ****
  }
  
  # ifdef FEAT_GUI_GNOME
- /* ARGSUSED */
      static int
  gui_gnome_dialog( int	type,
  		char_u	*title,
--- 1454,1459 ----
***************
*** 1611,1617 ****
      GtkWidget	*dialog;
  } CancelData;
  
- /* ARGSUSED */
      static void
  dlg_button_clicked(GtkWidget * widget, ButtonData *data)
  {
--- 1604,1609 ----
***************
*** 1622,1628 ****
  /*
   * This makes the Escape key equivalent to the cancel button.
   */
- /*ARGSUSED*/
      static int
  dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
  {
--- 1614,1619 ----
***************
*** 1655,1661 ****
  	gtk_main_quit();
  }
  
- /* ARGSUSED */
      int
  gui_mch_dialog(	int	type,		/* type of dialog */
  		char_u	*title,		/* title of dialog */
--- 1646,1651 ----
***************
*** 2215,2221 ****
      GtkDialog	*dialog;	    /* Widget of the dialog */
  } DialogInfo;
  
- /*ARGSUSED2*/
      static gboolean
  dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
--- 2205,2210 ----
***************
*** 2398,2411 ****
   * Note: The push_in output argument seems to affect scrolling of huge
   * menus that don't fit on the screen.	Leave it at the default for now.
   */
- /*ARGSUSED0*/
      static void
! popup_menu_position_func(GtkMenu *menu,
  			 gint *x, gint *y,
  # ifdef HAVE_GTK2
! 			 gboolean *push_in,
  # endif
! 			 gpointer user_data)
  {
      gdk_window_get_origin(gui.drawarea->window, x, y);
  
--- 2387,2399 ----
   * Note: The push_in output argument seems to affect scrolling of huge
   * menus that don't fit on the screen.	Leave it at the default for now.
   */
      static void
! popup_menu_position_func(GtkMenu *menu UNUSED,
  			 gint *x, gint *y,
  # ifdef HAVE_GTK2
! 			 gboolean *push_in UNUSED,
  # endif
! 			 gpointer user_data UNUSED)
  {
      gdk_window_get_origin(gui.drawarea->window, x, y);
  
***************
*** 2464,2476 ****
      GtkWidget *all;	/* 'Replace All' action button */
  } SharedFindReplace;
  
! static SharedFindReplace find_widgets = { NULL, };
! static SharedFindReplace repl_widgets = { NULL, };
  
- /* ARGSUSED */
      static int
  find_key_press_event(
! 		GtkWidget	*widget,
  		GdkEventKey	*event,
  		SharedFindReplace *frdp)
  {
--- 2452,2463 ----
      GtkWidget *all;	/* 'Replace All' action button */
  } SharedFindReplace;
  
! static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
! static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
  
      static int
  find_key_press_event(
! 		GtkWidget	*widget UNUSED,
  		GdkEventKey	*event,
  		SharedFindReplace *frdp)
  {
***************
*** 2962,2970 ****
  /*
   * Callback for actions of the find and replace dialogs
   */
- /*ARGSUSED*/
      static void
! find_replace_cb(GtkWidget *widget, gpointer data)
  {
      int			flags;
      char_u		*find_text;
--- 2949,2956 ----
  /*
   * Callback for actions of the find and replace dialogs
   */
      static void
! find_replace_cb(GtkWidget *widget UNUSED, gpointer data)
  {
      int			flags;
      char_u		*find_text;
***************
*** 3010,3018 ****
  }
  
  /* our usual callback function */
- /*ARGSUSED*/
      static void
! entry_activate_cb(GtkWidget *widget, gpointer data)
  {
      gtk_widget_grab_focus(GTK_WIDGET(data));
  }
--- 2996,3003 ----
  }
  
  /* our usual callback function */
      static void
! entry_activate_cb(GtkWidget *widget UNUSED, gpointer data)
  {
      gtk_widget_grab_focus(GTK_WIDGET(data));
  }
***************
*** 3055,3064 ****
  /*
   * ":helpfind"
   */
- /*ARGSUSED*/
      void
  ex_helpfind(eap)
!     exarg_T	*eap;
  {
      /* This will fail when menus are not loaded.  Well, it's only for
       * backwards compatibility anyway. */
--- 3040,3048 ----
  /*
   * ":helpfind"
   */
      void
  ex_helpfind(eap)
!     exarg_T	*eap UNUSED;
  {
      /* This will fail when menus are not loaded.  Well, it's only for
       * backwards compatibility anyway. */
*** ../vim-7.2.180/src/gui_gtk_x11.c	2008-11-28 21:26:50.000000000 +0100
--- src/gui_gtk_x11.c	2009-05-17 15:53:02.000000000 +0200
***************
*** 619,627 ****
   * Doesn't seem possible, since check_copy_area() relies on
   * this information.  --danielk
   */
- /*ARGSUSED*/
      static gint
! visibility_event(GtkWidget *widget, GdkEventVisibility *event, gpointer data)
  {
      gui.visibility = event->state;
      /*
--- 625,634 ----
   * Doesn't seem possible, since check_copy_area() relies on
   * this information.  --danielk
   */
      static gint
! visibility_event(GtkWidget *widget UNUSED,
! 		 GdkEventVisibility *event,
! 		 gpointer data UNUSED)
  {
      gui.visibility = event->state;
      /*
***************
*** 638,646 ****
  /*
   * Redraw the corresponding portions of the screen.
   */
- /*ARGSUSED*/
      static gint
! expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
  {
      /* Skip this when the GUI isn't set up yet, will redraw later. */
      if (gui.starting)
--- 645,654 ----
  /*
   * Redraw the corresponding portions of the screen.
   */
      static gint
! expose_event(GtkWidget *widget UNUSED,
! 	     GdkEventExpose *event,
! 	     gpointer data UNUSED)
  {
      /* Skip this when the GUI isn't set up yet, will redraw later. */
      if (gui.starting)
***************
*** 668,676 ****
  /*
   * Handle changes to the "Comm" property
   */
- /*ARGSUSED2*/
      static gint
! property_event(GtkWidget *widget, GdkEventProperty *event, gpointer data)
  {
      if (event->type == GDK_PROPERTY_NOTIFY
  	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
--- 676,685 ----
  /*
   * Handle changes to the "Comm" property
   */
      static gint
! property_event(GtkWidget *widget,
! 	       GdkEventProperty *event,
! 	       gpointer data UNUSED)
  {
      if (event->type == GDK_PROPERTY_NOTIFY
  	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
***************
*** 740,748 ****
      blink_state = BLINK_NONE;
  }
  
- /*ARGSUSED*/
      static gint
! blink_cb(gpointer data)
  {
      if (blink_state == BLINK_ON)
      {
--- 749,756 ----
      blink_state = BLINK_NONE;
  }
  
      static gint
! blink_cb(gpointer data UNUSED)
  {
      if (blink_state == BLINK_ON)
      {
***************
*** 781,789 ****
      }
  }
  
- /*ARGSUSED*/
      static gint
! enter_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
  {
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
--- 789,798 ----
      }
  }
  
      static gint
! enter_notify_event(GtkWidget *widget UNUSED,
! 		   GdkEventCrossing *event UNUSED,
! 		   gpointer data UNUSED)
  {
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
***************
*** 795,803 ****
      return FALSE;
  }
  
- /*ARGSUSED*/
      static gint
! leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
  {
      if (blink_state != BLINK_NONE)
  	gui_mch_stop_blink();
--- 804,813 ----
      return FALSE;
  }
  
      static gint
! leave_notify_event(GtkWidget *widget UNUSED,
! 		   GdkEventCrossing *event UNUSED,
! 		   gpointer data UNUSED)
  {
      if (blink_state != BLINK_NONE)
  	gui_mch_stop_blink();
***************
*** 805,813 ****
      return FALSE;
  }
  
- /*ARGSUSED*/
      static gint
! focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
  {
      gui_focus_change(TRUE);
  
--- 815,824 ----
      return FALSE;
  }
  
      static gint
! focus_in_event(GtkWidget *widget,
! 	       GdkEventFocus *event UNUSED,
! 	       gpointer data UNUSED)
  {
      gui_focus_change(TRUE);
  
***************
*** 826,834 ****
      return TRUE;
  }
  
- /*ARGSUSED*/
      static gint
! focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
  {
      gui_focus_change(FALSE);
  
--- 837,846 ----
      return TRUE;
  }
  
      static gint
! focus_out_event(GtkWidget *widget UNUSED,
! 	        GdkEventFocus *event UNUSED,
! 		gpointer data UNUSED)
  {
      gui_focus_change(FALSE);
  
***************
*** 956,964 ****
  /*
   * Main keyboard handler:
   */
- /*ARGSUSED*/
      static gint
! key_press_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
  #ifdef HAVE_GTK2
      /* 256 bytes is way over the top, but for safety let's reduce it only
--- 968,977 ----
  /*
   * Main keyboard handler:
   */
      static gint
! key_press_event(GtkWidget *widget UNUSED,
! 		GdkEventKey *event,
! 		gpointer data UNUSED)
  {
  #ifdef HAVE_GTK2
      /* 256 bytes is way over the top, but for safety let's reduce it only
***************
*** 1225,1233 ****
  }
  
  #if defined(FEAT_XIM) && defined(HAVE_GTK2)
- /*ARGSUSED0*/
      static gboolean
! key_release_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
      /*
       * GTK+ 2 input methods may do fancy stuff on key release events too.
--- 1238,1247 ----
  }
  
  #if defined(FEAT_XIM) && defined(HAVE_GTK2)
      static gboolean
! key_release_event(GtkWidget *widget UNUSED,
! 		  GdkEventKey *event,
! 		  gpointer data UNUSED)
  {
      /*
       * GTK+ 2 input methods may do fancy stuff on key release events too.
***************
*** 1243,1253 ****
   * Selection handlers:
   */
  
- /*ARGSUSED*/
      static gint
! selection_clear_event(GtkWidget		*widget,
  		      GdkEventSelection	*event,
! 		      gpointer		user_data)
  {
      if (event->selection == clip_plus.gtk_sel_atom)
  	clip_lose_selection(&clip_plus);
--- 1257,1266 ----
   * Selection handlers:
   */
  
      static gint
! selection_clear_event(GtkWidget		*widget UNUSED,
  		      GdkEventSelection	*event,
! 		      gpointer		user_data UNUSED)
  {
      if (event->selection == clip_plus.gtk_sel_atom)
  	clip_lose_selection(&clip_plus);
***************
*** 1265,1276 ****
  #define RS_FAIL	2	/* selection_received_cb() called and failed */
  static int received_selection = RS_NONE;
  
- /*ARGSUSED*/
      static void
! selection_received_cb(GtkWidget		*widget,
  		      GtkSelectionData	*data,
! 		      guint		time_,
! 		      gpointer		user_data)
  {
      VimClipboard    *cbd;
      char_u	    *text;
--- 1278,1288 ----
  #define RS_FAIL	2	/* selection_received_cb() called and failed */
  static int received_selection = RS_NONE;
  
      static void
! selection_received_cb(GtkWidget		*widget UNUSED,
  		      GtkSelectionData	*data,
! 		      guint		time_ UNUSED,
! 		      gpointer		user_data UNUSED)
  {
      VimClipboard    *cbd;
      char_u	    *text;
***************
*** 1414,1426 ****
   * Prepare our selection data for passing it to the external selection
   * client.
   */
- /*ARGSUSED*/
      static void
! selection_get_cb(GtkWidget	    *widget,
  		 GtkSelectionData   *selection_data,
  		 guint		    info,
! 		 guint		    time_,
! 		 gpointer	    user_data)
  {
      char_u	    *string;
      char_u	    *tmpbuf;
--- 1426,1437 ----
   * Prepare our selection data for passing it to the external selection
   * client.
   */
      static void
! selection_get_cb(GtkWidget	    *widget UNUSED,
  		 GtkSelectionData   *selection_data,
  		 guint		    info,
! 		 guint		    time_ UNUSED,
! 		 gpointer	    user_data UNUSED)
  {
      char_u	    *string;
      char_u	    *tmpbuf;
***************
*** 1678,1684 ****
  
  	offshoot = dx > dy ? dx : dy;
  
! 	/* Make a linearly declaying timer delay with a threshold of 5 at a
  	 * distance of 127 pixels from the main window.
  	 *
  	 * One could think endlessly about the most ergonomic variant here.
--- 1689,1695 ----
  
  	offshoot = dx > dy ? dx : dy;
  
! 	/* Make a linearly decaying timer delay with a threshold of 5 at a
  	 * distance of 127 pixels from the main window.
  	 *
  	 * One could think endlessly about the most ergonomic variant here.
***************
*** 1707,1715 ****
  /*
   * Timer used to recognize multiple clicks of the mouse button.
   */
- /*ARGSUSED0*/
      static gint
! motion_repeat_timer_cb(gpointer data)
  {
      int		    x;
      int		    y;
--- 1718,1725 ----
  /*
   * Timer used to recognize multiple clicks of the mouse button.
   */
      static gint
! motion_repeat_timer_cb(gpointer data UNUSED)
  {
      int		    x;
      int		    y;
***************
*** 1749,1757 ****
      return FALSE;
  }
  
- /*ARGSUSED2*/
      static gint
! motion_notify_event(GtkWidget *widget, GdkEventMotion *event, gpointer data)
  {
      if (event->is_hint)
      {
--- 1759,1768 ----
      return FALSE;
  }
  
      static gint
! motion_notify_event(GtkWidget *widget,
! 		    GdkEventMotion *event,
! 		    gpointer data UNUSED)
  {
      if (event->is_hint)
      {
***************
*** 1777,1785 ****
   * by our own timeout mechanism instead of the one provided by GTK+ itself.
   * This is due to the way the generic VIM code is recognizing multiple clicks.
   */
- /*ARGSUSED2*/
      static gint
! button_press_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
  {
      int button;
      int repeated_click = FALSE;
--- 1788,1797 ----
   * by our own timeout mechanism instead of the one provided by GTK+ itself.
   * This is due to the way the generic VIM code is recognizing multiple clicks.
   */
      static gint
! button_press_event(GtkWidget *widget,
! 		   GdkEventButton *event,
! 		   gpointer data UNUSED)
  {
      int button;
      int repeated_click = FALSE;
***************
*** 1855,1863 ****
   * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
   * Instead, it abstracts scrolling via the new GdkEventScroll.
   */
- /*ARGSUSED2*/
      static gboolean
! scroll_event(GtkWidget *widget, GdkEventScroll *event, gpointer data)
  {
      int	    button;
      int_u   vim_modifiers;
--- 1867,1876 ----
   * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
   * Instead, it abstracts scrolling via the new GdkEventScroll.
   */
      static gboolean
! scroll_event(GtkWidget *widget,
! 	     GdkEventScroll *event,
! 	     gpointer data UNUSED)
  {
      int	    button;
      int_u   vim_modifiers;
***************
*** 1896,1904 ****
  #endif /* HAVE_GTK2 */
  
  
- /*ARGSUSED*/
      static gint
! button_release_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
  {
      int x, y;
      int_u vim_modifiers;
--- 1909,1918 ----
  #endif /* HAVE_GTK2 */
  
  
      static gint
! button_release_event(GtkWidget *widget UNUSED,
! 		     GdkEventButton *event,
! 		     gpointer data UNUSED)
  {
      int x, y;
      int_u vim_modifiers;
***************
*** 2100,2106 ****
  /*
   * DND receiver.
   */
- /*ARGSUSED2*/
      static void
  drag_data_received_cb(GtkWidget		*widget,
  		      GdkDragContext	*context,
--- 2114,2119 ----
***************
*** 2109,2115 ****
  		      GtkSelectionData	*data,
  		      guint		info,
  		      guint		time_,
! 		      gpointer		user_data)
  {
      GdkModifierType state;
  
--- 2122,2128 ----
  		      GtkSelectionData	*data,
  		      guint		info,
  		      guint		time_,
! 		      gpointer		user_data UNUSED)
  {
      GdkModifierType state;
  
***************
*** 2143,2149 ****
   * be abandoned and pop up a dialog asking the user for confirmation if
   * necessary.
   */
- /*ARGSUSED0*/
      static void
  sm_client_check_changed_any(GnomeClient	    *client,
  			    gint	    key,
--- 2156,2161 ----
***************
*** 2251,2257 ****
   * for confirmation if necessary.  Save the current editing session and tell
   * the session manager how to restart Vim.
   */
- /*ARGSUSED1*/
      static gboolean
  sm_client_save_yourself(GnomeClient	    *client,
  			gint		    phase,
--- 2263,2268 ----
***************
*** 2339,2345 ****
   * here since "save_yourself" has been emitted before (unless serious trouble
   * is happening).
   */
- /*ARGSUSED0*/
      static void
  sm_client_die(GnomeClient *client, gpointer data)
  {
--- 2350,2355 ----
***************
*** 2379,2388 ****
  /*
   * GTK tells us that XSMP needs attention
   */
- /*ARGSUSED*/
      static gboolean
  local_xsmp_handle_requests(source, condition, data)
!     GIOChannel		*source;
      GIOCondition	condition;
      gpointer		data;
  {
--- 2389,2397 ----
  /*
   * GTK tells us that XSMP needs attention
   */
      static gboolean
  local_xsmp_handle_requests(source, condition, data)
!     GIOChannel		*source UNUSED;
      GIOCondition	condition;
      gpointer		data;
  {
***************
*** 2480,2495 ****
   * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
   * it should work with KDE as well.
   */
- /*ARGSUSED1*/
      static GdkFilterReturn
! global_event_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
  {
      XEvent *xevent = (XEvent *)xev;
  
      if (xevent != NULL
  	    && xevent->type == ClientMessage
  	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
! 	    && xevent->xclient.data.l[0] == GET_X_ATOM(save_yourself_atom))
      {
  	out_flush();
  	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
--- 2489,2506 ----
   * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
   * it should work with KDE as well.
   */
      static GdkFilterReturn
! global_event_filter(GdkXEvent *xev,
! 		    GdkEvent *event UNUSED,
! 		    gpointer data UNUSED)
  {
      XEvent *xevent = (XEvent *)xev;
  
      if (xevent != NULL
  	    && xevent->type == ClientMessage
  	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
! 	    && (long_u)xevent->xclient.data.l[0]
! 					    == GET_X_ATOM(save_yourself_atom))
      {
  	out_flush();
  	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
***************
*** 2512,2518 ****
  /*
   * GDK handler for X ClientMessage events.
   */
- /*ARGSUSED2*/
      static GdkFilterReturn
  gdk_wm_protocols_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
  {
--- 2523,2528 ----
***************
*** 2558,2566 ****
  /*
   * Setup the window icon & xcmdsrv comm after the main window has been realized.
   */
- /*ARGSUSED*/
      static void
! mainwin_realize(GtkWidget *widget, gpointer data)
  {
  /* If you get an error message here, you still need to unpack the runtime
   * archive! */
--- 2568,2575 ----
  /*
   * Setup the window icon & xcmdsrv comm after the main window has been realized.
   */
      static void
! mainwin_realize(GtkWidget *widget UNUSED, gpointer data UNUSED)
  {
  /* If you get an error message here, you still need to unpack the runtime
   * archive! */
***************
*** 2712,2722 ****
  }
  
  #ifdef HAVE_GTK_MULTIHEAD
- /*ARGSUSED1*/
      static void
  mainwin_screen_changed_cb(GtkWidget  *widget,
! 			  GdkScreen  *previous_screen,
! 			  gpointer   data)
  {
      if (!gtk_widget_has_screen(widget))
  	return;
--- 2721,2730 ----
  }
  
  #ifdef HAVE_GTK_MULTIHEAD
      static void
  mainwin_screen_changed_cb(GtkWidget  *widget,
! 			  GdkScreen  *previous_screen UNUSED,
! 			  gpointer   data UNUSED)
  {
      if (!gtk_widget_has_screen(widget))
  	return;
***************
*** 2757,2765 ****
   * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
   * fact that the main VIM engine doesn't take them into account anywhere.
   */
- /*ARGSUSED1*/
      static void
! drawarea_realize_cb(GtkWidget *widget, gpointer data)
  {
      GtkWidget *sbar;
  
--- 2765,2772 ----
   * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
   * fact that the main VIM engine doesn't take them into account anywhere.
   */
      static void
! drawarea_realize_cb(GtkWidget *widget, gpointer data UNUSED)
  {
      GtkWidget *sbar;
  
***************
*** 2789,2797 ****
  /*
   * Properly clean up on shutdown.
   */
- /*ARGSUSED0*/
      static void
! drawarea_unrealize_cb(GtkWidget *widget, gpointer data)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
--- 2796,2803 ----
  /*
   * Properly clean up on shutdown.
   */
      static void
! drawarea_unrealize_cb(GtkWidget *widget UNUSED, gpointer data UNUSED)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
***************
*** 2827,2837 ****
  #endif
  }
  
- /*ARGSUSED0*/
      static void
! drawarea_style_set_cb(GtkWidget	*widget,
! 		      GtkStyle	*previous_style,
! 		      gpointer	data)
  {
      gui_mch_new_colors();
  }
--- 2833,2842 ----
  #endif
  }
  
      static void
! drawarea_style_set_cb(GtkWidget	*widget UNUSED,
! 		      GtkStyle	*previous_style UNUSED,
! 		      gpointer	data UNUSED)
  {
      gui_mch_new_colors();
  }
***************
*** 2840,2848 ****
   * Callback routine for the "delete_event" signal on the toplevel window.
   * Tries to vim gracefully, or refuses to exit with changed buffers.
   */
- /*ARGSUSED*/
      static gint
! delete_event_cb(GtkWidget *widget, GdkEventAny *event, gpointer data)
  {
      gui_shell_closed();
      return TRUE;
--- 2845,2854 ----
   * Callback routine for the "delete_event" signal on the toplevel window.
   * Tries to vim gracefully, or refuses to exit with changed buffers.
   */
      static gint
! delete_event_cb(GtkWidget *widget UNUSED,
! 		GdkEventAny *event UNUSED,
! 		gpointer data UNUSED)
  {
      gui_shell_closed();
      return TRUE;
***************
*** 2964,2970 ****
  
      /* At start-up, don't try to set the hints until the initial
       * values have been used (those that dictate our initial size)
!      * Let forced (i.e., correct) values thruogh always.
       */
      if (!(force_width && force_height)  &&  init_window_hints_state > 0)
      {
--- 2970,2976 ----
  
      /* At start-up, don't try to set the hints until the initial
       * values have been used (those that dictate our initial size)
!      * Let forced (i.e., correct) values through always.
       */
      if (!(force_width && force_height)  &&  init_window_hints_state > 0)
      {
***************
*** 3142,3150 ****
  /*
   * Handle selecting an item in the tab line popup menu.
   */
- /*ARGSUSED*/
      static void
! tabline_menu_handler(GtkMenuItem *item, gpointer user_data)
  {
      /* Add the string cmd into input buffer */
      send_tabline_menu_event(clicked_page, (int)(long)user_data);
--- 3148,3155 ----
  /*
   * Handle selecting an item in the tab line popup menu.
   */
      static void
! tabline_menu_handler(GtkMenuItem *item UNUSED, gpointer user_data)
  {
      /* Add the string cmd into input buffer */
      send_tabline_menu_event(clicked_page, (int)(long)user_data);
***************
*** 3244,3256 ****
  /*
   * Handle selecting one of the tabs.
   */
- /*ARGSUSED*/
      static void
  on_select_tab(
! 	GtkNotebook	*notebook,
! 	GtkNotebookPage *page,
  	gint		idx,
! 	gpointer	data)
  {
      if (!ignore_tabline_evt)
      {
--- 3249,3260 ----
  /*
   * Handle selecting one of the tabs.
   */
      static void
  on_select_tab(
! 	GtkNotebook	*notebook UNUSED,
! 	GtkNotebookPage *page UNUSED,
  	gint		idx,
! 	gpointer	data UNUSED)
  {
      if (!ignore_tabline_evt)
      {
***************
*** 3784,3790 ****
  #endif
  
      if (gtk_socket_id != 0)
! 	/* make sure keybord input can go to the drawarea */
  	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
  
      /*
--- 3788,3794 ----
  #endif
  
      if (gtk_socket_id != 0)
! 	/* make sure keyboard input can go to the drawarea */
  	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
  
      /*
***************
*** 3922,3931 ****
  /*
   * This signal informs us about the need to rearrange our sub-widgets.
   */
- /*ARGSUSED*/
      static gint
! form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
! 		     gpointer data)
  {
      int usable_height = event->height;
  
--- 3926,3935 ----
  /*
   * This signal informs us about the need to rearrange our sub-widgets.
   */
      static gint
! form_configure_event(GtkWidget *widget UNUSED,
! 		     GdkEventConfigure *event,
! 		     gpointer data UNUSED)
  {
      int usable_height = event->height;
  
***************
*** 3948,3956 ****
   * We can't do much more here than to trying to preserve what had been done,
   * since the window is already inevitably going away.
   */
- /*ARGSUSED0*/
      static void
! mainwin_destroy_cb(GtkObject *object, gpointer data)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
--- 3952,3959 ----
   * We can't do much more here than to trying to preserve what had been done,
   * since the window is already inevitably going away.
   */
      static void
! mainwin_destroy_cb(GtkObject *object UNUSED, gpointer data UNUSED)
  {
      /* Don't write messages to the GUI anymore */
      full_screen = FALSE;
***************
*** 3980,3988 ****
   * scrollbar init.), actually do the standard hinst and stop the timer.
   * We'll not let the default hints be set while this timer's active.
   */
- /*ARGSUSED*/
      static gboolean
! check_startup_plug_hints(gpointer data)
  {
      if (init_window_hints_state == 1)
      {
--- 3983,3990 ----
   * scrollbar init.), actually do the standard hinst and stop the timer.
   * We'll not let the default hints be set while this timer's active.
   */
      static gboolean
! check_startup_plug_hints(gpointer data UNUSED)
  {
      if (init_window_hints_state == 1)
      {
***************
*** 4055,4061 ****
  	    Columns = w;
  	if (mask & HeightValue)
  	{
! 	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
  		p_window = h - 1;
  	    Rows = h;
  	}
--- 4057,4063 ----
  	    Columns = w;
  	if (mask & HeightValue)
  	{
! 	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
  		p_window = h - 1;
  	    Rows = h;
  	}
***************
*** 4229,4237 ****
  }
  
  
- /*ARGSUSED0*/
      void
! gui_mch_exit(int rc)
  {
      if (gui.mainwin != NULL)
  	gtk_widget_destroy(gui.mainwin);
--- 4231,4238 ----
  }
  
  
      void
! gui_mch_exit(int rc UNUSED)
  {
      if (gui.mainwin != NULL)
  	gtk_widget_destroy(gui.mainwin);
***************
*** 4286,4292 ****
   * report the new size through form_configure_event().  That caused the window
   * layout to be messed up.
   */
- /*ARGSUSED0*/
      static gboolean
  force_shell_resize_idle(gpointer data)
  {
--- 4287,4292 ----
***************
*** 4314,4325 ****
  /*
   * Set the windows size.
   */
- /*ARGSUSED2*/
      void
  gui_mch_set_shellsize(int width, int height,
! 		      int min_width,  int min_height,
! 		      int base_width, int base_height,
! 		      int direction)
  {
  #ifndef HAVE_GTK2
      /* Hack: When the form already is at the desired size, the window might
--- 4314,4324 ----
  /*
   * Set the windows size.
   */
      void
  gui_mch_set_shellsize(int width, int height,
! 		      int min_width UNUSED,  int min_height UNUSED,
! 		      int base_width UNUSED, int base_height UNUSED,
! 		      int direction UNUSED)
  {
  #ifndef HAVE_GTK2
      /* Hack: When the form already is at the desired size, the window might
***************
*** 4413,4421 ****
  }
  
  #if defined(FEAT_TITLE) || defined(PROTO)
- /*ARGSUSED*/
      void
! gui_mch_settitle(char_u *title, char_u *icon)
  {
  # ifdef HAVE_GTK2
      if (title != NULL && output_conv.vc_type != CONV_NONE)
--- 4412,4419 ----
  }
  
  #if defined(FEAT_TITLE) || defined(PROTO)
      void
! gui_mch_settitle(char_u *title, char_u *icon UNUSED)
  {
  # ifdef HAVE_GTK2
      if (title != NULL && output_conv.vc_type != CONV_NONE)
***************
*** 4493,4499 ****
   * Get a font structure for highlighting.
   * "cbdata" is a pointer to the global gui structure.
   */
- /*ARGSUSED*/
      static void
  font_sel_ok(GtkWidget *wgt, gpointer cbdata)
  {
--- 4491,4496 ----
***************
*** 4509,4515 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static void
  font_sel_cancel(GtkWidget *wgt, gpointer cbdata)
  {
--- 4506,4511 ----
***************
*** 4520,4526 ****
  	gtk_main_quit();
  }
  
- /*ARGSUSED*/
      static void
  font_sel_destroy(GtkWidget *wgt, gpointer cbdata)
  {
--- 4516,4521 ----
***************
*** 4620,4626 ****
  /*
   * Try to load the requested fontset.
   */
- /*ARGSUSED2*/
      GuiFontset
  gui_mch_get_fontset(char_u *name, int report_error, int fixed_width)
  {
--- 4615,4620 ----
***************
*** 4863,4869 ****
      styled_font[1] = &gui.ital_font;
      styled_font[2] = &gui.boldital_font;
  
!     /* First free whatever was freviously there. */
      for (i = 0; i < 3; ++i)
  	if (*styled_font[i])
  	{
--- 4857,4863 ----
      styled_font[1] = &gui.ital_font;
      styled_font[2] = &gui.boldital_font;
  
!     /* First free whatever was previously there. */
      for (i = 0; i < 3; ++i)
  	if (*styled_font[i])
  	{
***************
*** 5012,5020 ****
   * Initialize Vim to use the font or fontset with the given name.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
- /*ARGSUSED1*/
      int
! gui_mch_init_font(char_u *font_name, int fontset)
  {
  #ifdef HAVE_GTK2
      PangoFontDescription    *font_desc;
--- 5006,5013 ----
   * Initialize Vim to use the font or fontset with the given name.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
      int
! gui_mch_init_font(char_u *font_name, int fontset UNUSED)
  {
  #ifdef HAVE_GTK2
      PangoFontDescription    *font_desc;
***************
*** 5326,5334 ****
  /*
   * Return the name of font "font" in allocated memory.
   */
- /*ARGSUSED*/
      char_u *
! gui_mch_get_fontname(GuiFont font, char_u *name)
  {
  # ifdef HAVE_GTK2
      if (font != NOFONT)
--- 5319,5326 ----
  /*
   * Return the name of font "font" in allocated memory.
   */
      char_u *
! gui_mch_get_fontname(GuiFont font, char_u *name UNUSED)
  {
  # ifdef HAVE_GTK2
      if (font != NOFONT)
***************
*** 5732,5738 ****
  {
      int			i;
      int			offset;
!     const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
      int			y = FILL_Y(row + 1) - 1;
  
      /* Undercurl: draw curl at the bottom of the character cell. */
--- 5724,5730 ----
  {
      int			i;
      int			offset;
!     static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
      int			y = FILL_Y(row + 1) - 1;
  
      /* Undercurl: draw curl at the bottom of the character cell. */
***************
*** 6402,6408 ****
  /*
   * Callback function, used when data is available on the SNiFF connection.
   */
- /* ARGSUSED */
      static void
  sniff_request_cb(
      gpointer	data,
--- 6394,6399 ----
***************
*** 6711,6719 ****
  /*
   * Disown the selection.
   */
- /*ARGSUSED*/
      void
! clip_mch_lose_selection(VimClipboard *cbd)
  {
      /* WEIRD: when using NULL to actually disown the selection, we lose the
       * selection the first time we own it. */
--- 6702,6709 ----
  /*
   * Disown the selection.
   */
      void
! clip_mch_lose_selection(VimClipboard *cbd UNUSED)
  {
      /* WEIRD: when using NULL to actually disown the selection, we lose the
       * selection the first time we own it. */
***************
*** 6741,6749 ****
   * Send the current selection to the clipboard.  Do nothing for X because we
   * will fill in the selection only when requested by another app.
   */
- /*ARGSUSED*/
      void
! clip_mch_set_selection(VimClipboard *cbd)
  {
  }
  
--- 6731,6738 ----
   * Send the current selection to the clipboard.  Do nothing for X because we
   * will fill in the selection only when requested by another app.
   */
      void
! clip_mch_set_selection(VimClipboard *cbd UNUSED)
  {
  }
  
***************
*** 6950,6956 ****
  	    else
  		id &= ~1;	/* they are always even (why?) */
  	}
! 	else if (shape < sizeof(mshape_ids) / sizeof(int))
  	    id = mshape_ids[shape];
  	else
  	    return;
--- 6939,6945 ----
  	    else
  		id &= ~1;	/* they are always even (why?) */
  	}
! 	else if (shape < (int)(sizeof(mshape_ids) / sizeof(int)))
  	    id = mshape_ids[shape];
  	else
  	    return;
*** ../vim-7.2.180/src/gui_gtk_f.c	2007-05-10 19:50:33.000000000 +0200
--- src/gui_gtk_f.c	2009-05-17 15:48:51.000000000 +0200
***************
*** 227,240 ****
  
      if (!form_type)
      {
! 	GtkTypeInfo form_info =
! 	{
! 	    "GtkForm",
! 	    sizeof(GtkForm),
! 	    sizeof(GtkFormClass),
! 	    (GtkClassInitFunc) gtk_form_class_init,
! 	    (GtkObjectInitFunc) gtk_form_init
! 	};
  
  	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
      }
--- 227,239 ----
  
      if (!form_type)
      {
! 	GtkTypeInfo form_info;
! 
! 	form_info.type_name = "GtkForm";
! 	form_info.object_size = sizeof(GtkForm);
! 	form_info.class_size = sizeof(GtkFormClass);
! 	form_info.class_init_func = (GtkClassInitFunc)gtk_form_class_init;
! 	form_info.object_init_func = (GtkObjectInitFunc)gtk_form_init;
  
  	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
      }
***************
*** 611,620 ****
      }
  }
  
- /*ARGSUSED1*/
      static void
  gtk_form_forall(GtkContainer	*container,
! 		gboolean	include_internals,
  		GtkCallback	callback,
  		gpointer	callback_data)
  {
--- 610,618 ----
      }
  }
  
      static void
  gtk_form_forall(GtkContainer	*container,
! 		gboolean	include_internals UNUSED,
  		GtkCallback	callback,
  		gpointer	callback_data)
  {
***************
*** 786,794 ****
   * them or discards them, depending on whether we are obscured
   * or not.
   */
- /*ARGSUSED1*/
      static GdkFilterReturn
! gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
--- 784,791 ----
   * them or discards them, depending on whether we are obscured
   * or not.
   */
      static GdkFilterReturn
! gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event UNUSED, gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
***************
*** 821,829 ****
   * there is no corresponding event in GTK, so we have
   * to get the events from a filter
   */
- /*ARGSUSED1*/
      static GdkFilterReturn
! gtk_form_main_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
--- 818,827 ----
   * there is no corresponding event in GTK, so we have
   * to get the events from a filter
   */
      static GdkFilterReturn
! gtk_form_main_filter(GdkXEvent *gdk_xevent,
! 		     GdkEvent *event UNUSED,
! 		     gpointer data)
  {
      XEvent *xevent;
      GtkForm *form;
***************
*** 911,919 ****
  #endif
  }
  
- /*ARGSUSED0*/
      static void
! gtk_form_child_map(GtkWidget *widget, gpointer user_data)
  {
      GtkFormChild *child;
  
--- 909,916 ----
  #endif
  }
  
      static void
! gtk_form_child_map(GtkWidget *widget UNUSED, gpointer user_data)
  {
      GtkFormChild *child;
  
***************
*** 923,931 ****
      gdk_window_show(child->window);
  }
  
- /*ARGSUSED0*/
      static void
! gtk_form_child_unmap(GtkWidget *widget, gpointer user_data)
  {
      GtkFormChild *child;
  
--- 920,927 ----
      gdk_window_show(child->window);
  }
  
      static void
! gtk_form_child_unmap(GtkWidget *widget UNUSED, gpointer user_data)
  {
      GtkFormChild *child;
  
*** ../vim-7.2.180/src/gui_beval.c	2009-03-18 12:20:35.000000000 +0100
--- src/gui_beval.c	2009-05-17 15:53:22.000000000 +0200
***************
*** 15,21 ****
  /*
   * Common code, invoked when the mouse is resting for a moment.
   */
- /*ARGSUSED*/
      void
  general_beval_cb(beval, state)
      BalloonEval *beval;
--- 15,20 ----
***************
*** 551,559 ****
      return FALSE; /* continue emission */
  }
  
- /*ARGSUSED*/
      static gint
! mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)
  {
      BalloonEval *beval = (BalloonEval *)data;
  
--- 550,557 ----
      return FALSE; /* continue emission */
  }
  
      static gint
! mainwin_event_cb(GtkWidget *widget UNUSED, GdkEvent *event, gpointer data)
  {
      BalloonEval *beval = (BalloonEval *)data;
  
***************
*** 663,671 ****
      return FALSE; /* don't call me again */
  }
  
- /*ARGSUSED2*/
      static gint
! balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)
  {
      gtk_paint_flat_box(widget->style, widget->window,
  		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
--- 661,670 ----
      return FALSE; /* don't call me again */
  }
  
      static gint
! balloon_expose_event_cb(GtkWidget *widget,
! 			GdkEventExpose *event,
! 			gpointer data UNUSED)
  {
      gtk_paint_flat_box(widget->style, widget->window,
  		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
***************
*** 676,682 ****
  }
  
  # ifndef HAVE_GTK2
- /*ARGSUSED2*/
      static void
  balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)
  {
--- 675,680 ----
***************
*** 726,732 ****
  /*
   * The X event handler. All it does is call the real event handler.
   */
- /*ARGSUSED*/
      static void
  pointerEventEH(w, client_data, event, unused)
      Widget	w;
--- 724,729 ----
***************
*** 877,883 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  timerRoutine(dx, id)
      XtPointer	    dx;
--- 874,879 ----
*** ../vim-7.2.180/src/netbeans.c	2009-02-21 22:12:43.000000000 +0100
--- src/netbeans.c	2009-05-17 15:51:14.000000000 +0200
***************
*** 700,706 ****
  /*
   * Read and process a command from netbeans.
   */
- /*ARGSUSED*/
  #if defined(FEAT_GUI_W32) || defined(PROTO)
  /* Use this one when generating prototypes, the others are static. */
      void
--- 700,705 ----
***************
*** 708,719 ****
  #else
  # ifdef FEAT_GUI_MOTIF
      static void
! messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
  # endif
  # ifdef FEAT_GUI_GTK
      static void
! messageFromNetbeans(gpointer clientData, gint unused1,
! 						    GdkInputCondition unused2)
  # endif
  #endif
  {
--- 707,721 ----
  #else
  # ifdef FEAT_GUI_MOTIF
      static void
! messageFromNetbeans(XtPointer clientData UNUSED
! 		    int *unused1 UNUSED,
! 		    XtInputId *unused2 UNUSED)
  # endif
  # ifdef FEAT_GUI_GTK
      static void
! messageFromNetbeans(gpointer clientData UNUSED,
! 		    gint unused1 UNUSED,
! 		    GdkInputCondition unused2 UNUSED)
  # endif
  #endif
  {
***************
*** 1585,1591 ****
--- 1587,1595 ----
  			    buf_delsign(buf->bufp, id);
  			}
  			else
+ 			{
  			    nbdebug(("    No sign on line %d\n", i));
+ 			}
  		    }
  
  		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
***************
*** 2144,2150 ****
--- 2148,2156 ----
  #endif
  	    }
  	    else
+ 	    {
  		nbdebug(("    BAD POSITION in setDot: %s\n", s));
+ 	    }
  
  	    /* gui_update_cursor(TRUE, FALSE); */
  	    /* update_curbuf(NOT_VALID); */
***************
*** 2744,2754 ****
   * cursor and sends it to the debugger for evaluation.  The debugger should
   * respond with a showBalloon command when there is a useful result.
   */
- /*ARGSUSED*/
      void
  netbeans_beval_cb(
  	BalloonEval	*beval,
! 	int		 state)
  {
      win_T	*wp;
      char_u	*text;
--- 2750,2759 ----
   * cursor and sends it to the debugger for evaluation.  The debugger should
   * respond with a showBalloon command when there is a useful result.
   */
      void
  netbeans_beval_cb(
  	BalloonEval	*beval,
! 	int		 state UNUSED)
  {
      win_T	*wp;
      char_u	*text;
***************
*** 3061,3069 ****
  /*
   * Send netbeans an unmodufied command.
   */
- /*ARGSUSED*/
      void
! netbeans_unmodified(buf_T *bufp)
  {
  #if 0
      char_u	buf[128];
--- 3066,3073 ----
  /*
   * Send netbeans an unmodufied command.
   */
      void
! netbeans_unmodified(buf_T *bufp UNUSED)
  {
  #if 0
      char_u	buf[128];
***************
*** 3370,3382 ****
   * buf->signmapused[]	maps buffer-local annotation IDs to an index in
   *			globalsignmap[].
   */
- /*ARGSUSED*/
      static void
  addsigntype(
      nbbuf_T	*buf,
      int		typeNum,
      char_u	*typeName,
!     char_u	*tooltip,
      char_u	*glyphFile,
      int		use_fg,
      int		fg,
--- 3374,3385 ----
   * buf->signmapused[]	maps buffer-local annotation IDs to an index in
   *			globalsignmap[].
   */
      static void
  addsigntype(
      nbbuf_T	*buf,
      int		typeNum,
      char_u	*typeName,
!     char_u	*tooltip UNUSED,
      char_u	*glyphFile,
      int		use_fg,
      int		fg,
*** ../vim-7.2.180/src/version.c	2009-05-17 13:30:58.000000000 +0200
--- src/version.c	2009-05-17 16:07:26.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     181,
  /**/

-- 
I am always surprised in the Linux world how quickly solutions can be
obtained.  (Imagine sending an email to Bill Gates, asking why Windows
crashed, and how to fix it...  and then getting an answer that fixed the
problem... <0>_<0> !)		              -- Mark Langdon

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
