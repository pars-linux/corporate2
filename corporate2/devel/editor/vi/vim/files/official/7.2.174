To: vim-dev@vim.org
Subject: Patch 7.2.174
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 7.2.174
Problem:    Too many warnings from gcc -Wextra.
Solution:   Change initializer.  Add UNUSED.  Add type casts.
Files:      src/edit.c, src/eval.c, src/ex_cmds.c, src/ex_docmd.c,
            src/ex_getln.c, src/fileio.c, getchar.c, globals.h, main.c,
            memline.c, message.c, src/misc1.c, src/move.c, src/normal.c,
            src/option.c, src/os_unix.c, src/os_unix.h, src/regexp.c,
            src/search.c, src/tag.c


*** ../vim-7.2.173/src/edit.c	2009-05-14 22:19:19.000000000 +0200
--- src/edit.c	2009-05-15 21:06:07.000000000 +0200
***************
*** 8991,8997 ****
  	foldOpenCursor();
  #endif
      undisplay_dollar();
!     if (gchar_cursor() != NUL || virtual_active()
  	    )
      {
  	start_arrow(&curwin->w_cursor);
--- 8992,9001 ----
  	foldOpenCursor();
  #endif
      undisplay_dollar();
!     if (gchar_cursor() != NUL
! #ifdef FEAT_VIRTUALEDIT
! 	    || virtual_active()
! #endif
  	    )
      {
  	start_arrow(&curwin->w_cursor);
*** ../vim-7.2.173/src/eval.c	2009-04-22 16:07:57.000000000 +0200
--- src/eval.c	2009-05-15 21:18:08.000000000 +0200
***************
*** 8303,8312 ****
  /*
   * "argc()" function
   */
- /* ARGSUSED */
      static void
  f_argc(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = ARGCOUNT;
--- 8303,8311 ----
  /*
   * "argc()" function
   */
      static void
  f_argc(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = ARGCOUNT;
***************
*** 8315,8324 ****
  /*
   * "argidx()" function
   */
- /* ARGSUSED */
      static void
  f_argidx(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curwin->w_arg_idx;
--- 8314,8322 ----
  /*
   * "argidx()" function
   */
      static void
  f_argidx(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curwin->w_arg_idx;
***************
*** 8396,8405 ****
  /*
   * "browse(save, title, initdir, default)" function
   */
- /* ARGSUSED */
      static void
  f_browse(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
--- 8394,8402 ----
  /*
   * "browse(save, title, initdir, default)" function
   */
      static void
  f_browse(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
***************
*** 8431,8440 ****
  /*
   * "browsedir(title, initdir)" function
   */
- /* ARGSUSED */
      static void
  f_browsedir(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
--- 8428,8436 ----
  /*
   * "browsedir(title, initdir)" function
   */
      static void
  f_browsedir(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_BROWSE
***************
*** 8801,8810 ****
  /*
   * "changenr()" function
   */
- /*ARGSUSED*/
      static void
  f_changenr(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curbuf->b_u_seq_cur;
--- 8797,8805 ----
  /*
   * "changenr()" function
   */
      static void
  f_changenr(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
      rettv->vval.v_number = curbuf->b_u_seq_cur;
***************
*** 8854,8863 ****
  /*
   * "clearmatches()" function
   */
- /*ARGSUSED*/
      static void
  f_clearmatches(argvars, rettv)
!     typval_T	*argvars;
      typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
--- 8849,8857 ----
  /*
   * "clearmatches()" function
   */
      static void
  f_clearmatches(argvars, rettv)
!     typval_T	*argvars UNUSED;
      typval_T	*rettv;
  {
  #ifdef FEAT_SEARCH_EXTRA
*** ../vim-7.2.173/src/ex_cmds.c	2009-05-14 22:19:19.000000000 +0200
--- src/ex_cmds.c	2009-05-15 20:42:18.000000000 +0200
***************
*** 4040,4047 ****
--- 4040,4049 ----
  	bigness = curwin->w_height;
      else if (firstwin == lastwin)
  	bigness = curwin->w_p_scr * 2;
+ #ifdef FEAT_WINDOWS
      else
  	bigness = curwin->w_height - 3;
+ #endif
      if (bigness < 1)
  	bigness = 1;
  
*** ../vim-7.2.173/src/ex_docmd.c	2009-05-13 18:54:14.000000000 +0200
--- src/ex_docmd.c	2009-05-15 20:47:58.000000000 +0200
***************
*** 1578,1588 ****
   * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
   * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
- /*ARGSUSED*/
      int
  getline_equal(fgetline, cookie, func)
      char_u	*(*fgetline) __ARGS((int, void *, int));
!     void	*cookie;		/* argument for fgetline() */
      char_u	*(*func) __ARGS((int, void *, int));
  {
  #ifdef FEAT_EVAL
--- 1578,1587 ----
   * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
   * "func".  * Otherwise return TRUE when "fgetline" equals "func".
   */
      int
  getline_equal(fgetline, cookie, func)
      char_u	*(*fgetline) __ARGS((int, void *, int));
!     void	*cookie UNUSED;		/* argument for fgetline() */
      char_u	*(*func) __ARGS((int, void *, int));
  {
  #ifdef FEAT_EVAL
***************
*** 1610,1619 ****
   * If "fgetline" is get_loop_line(), return the cookie used by the original
   * getline function.  Otherwise return "cookie".
   */
- /*ARGSUSED*/
      void *
  getline_cookie(fgetline, cookie)
!     char_u	*(*fgetline) __ARGS((int, void *, int));
      void	*cookie;		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
--- 1609,1617 ----
   * If "fgetline" is get_loop_line(), return the cookie used by the original
   * getline function.  Otherwise return "cookie".
   */
      void *
  getline_cookie(fgetline, cookie)
!     char_u	*(*fgetline) __ARGS((int, void *, int)) UNUSED;
      void	*cookie;		/* argument for fgetline() */
  {
  # ifdef FEAT_EVAL
***************
*** 2754,2764 ****
   * "full" is set to TRUE if the whole command name matched.
   * Returns NULL for an ambiguous user command.
   */
- /*ARGSUSED*/
      static char_u *
  find_command(eap, full)
      exarg_T	*eap;
!     int		*full;
  {
      int		len;
      char_u	*p;
--- 2752,2761 ----
   * "full" is set to TRUE if the whole command name matched.
   * Returns NULL for an ambiguous user command.
   */
      static char_u *
  find_command(eap, full)
      exarg_T	*eap;
!     int		*full UNUSED;
  {
      int		len;
      char_u	*p;
***************
*** 5053,5062 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of command names.
   */
- /*ARGSUSED*/
      char_u *
  get_command_name(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx >= (int)CMD_SIZE)
--- 5050,5058 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of command names.
   */
      char_u *
  get_command_name(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx >= (int)CMD_SIZE)
***************
*** 5573,5582 ****
   * ":comclear"
   * Clear all user commands, global and for current buffer.
   */
- /*ARGSUSED*/
      void
  ex_comclear(eap)
!     exarg_T	*eap;
  {
      uc_clear(&ucmds);
      uc_clear(&curbuf->b_ucmds);
--- 5569,5577 ----
   * ":comclear"
   * Clear all user commands, global and for current buffer.
   */
      void
  ex_comclear(eap)
!     exarg_T	*eap UNUSED;
  {
      uc_clear(&ucmds);
      uc_clear(&curbuf->b_ucmds);
***************
*** 6072,6081 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of user command names.
   */
- /*ARGSUSED*/
      char_u *
  get_user_commands(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      if (idx < curbuf->b_ucmds.ga_len)
--- 6067,6075 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of user command names.
   */
      char_u *
  get_user_commands(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      if (idx < curbuf->b_ucmds.ga_len)
***************
*** 6090,6099 ****
   * Function given to ExpandGeneric() to obtain the list of user command
   * attributes.
   */
- /*ARGSUSED*/
      char_u *
  get_user_cmd_flags(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      static char *user_cmd_flags[] =
--- 6084,6092 ----
   * Function given to ExpandGeneric() to obtain the list of user command
   * attributes.
   */
      char_u *
  get_user_cmd_flags(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      static char *user_cmd_flags[] =
***************
*** 6108,6117 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -nargs.
   */
- /*ARGSUSED*/
      char_u *
  get_user_cmd_nargs(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
--- 6101,6109 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -nargs.
   */
      char_u *
  get_user_cmd_nargs(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
***************
*** 6124,6133 ****
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -complete.
   */
- /*ARGSUSED*/
      char_u *
  get_user_cmd_complete(xp, idx)
!     expand_T	*xp;
      int		idx;
  {
      return (char_u *)command_complete[idx].name;
--- 6116,6124 ----
  /*
   * Function given to ExpandGeneric() to obtain the list of values for -complete.
   */
      char_u *
  get_user_cmd_complete(xp, idx)
!     expand_T	*xp UNUSED;
      int		idx;
  {
      return (char_u *)command_complete[idx].name;
***************
*** 6305,6314 ****
  /*
   * ":cquit".
   */
- /*ARGSUSED*/
      static void
  ex_cquit(eap)
!     exarg_T	*eap;
  {
      getout(1);	/* this does not always pass on the exit code to the Manx
  		   compiler. why? */
--- 6296,6304 ----
  /*
   * ":cquit".
   */
      static void
  ex_cquit(eap)
!     exarg_T	*eap UNUSED;
  {
      getout(1);	/* this does not always pass on the exit code to the Manx
  		   compiler. why? */
***************
*** 6750,6759 ****
  /*
   * ":shell".
   */
- /*ARGSUSED*/
      static void
  ex_shell(eap)
!     exarg_T	*eap;
  {
      do_shell(NULL, 0);
  }
--- 6740,6748 ----
  /*
   * ":shell".
   */
      static void
  ex_shell(eap)
!     exarg_T	*eap UNUSED;
  {
      do_shell(NULL, 0);
  }
***************
*** 7057,7066 ****
  /*
   * ":preserve".
   */
- /*ARGSUSED*/
      static void
  ex_preserve(eap)
!     exarg_T	*eap;
  {
      curbuf->b_flags |= BF_PRESERVED;
      ml_preserve(curbuf, TRUE);
--- 7046,7054 ----
  /*
   * ":preserve".
   */
      static void
  ex_preserve(eap)
!     exarg_T	*eap UNUSED;
  {
      curbuf->b_flags |= BF_PRESERVED;
      ml_preserve(curbuf, TRUE);
***************
*** 7292,7301 ****
  /*
   * :tabs command: List tabs and their contents.
   */
- /*ARGSUSED*/
      static void
  ex_tabs(eap)
!     exarg_T	*eap;
  {
      tabpage_T	*tp;
      win_T	*wp;
--- 7280,7288 ----
  /*
   * :tabs command: List tabs and their contents.
   */
      static void
  ex_tabs(eap)
!     exarg_T	*eap UNUSED;
  {
      tabpage_T	*tp;
      win_T	*wp;
***************
*** 7482,7488 ****
  /*
   * ":edit <file>" command and alikes.
   */
- /*ARGSUSED*/
      void
  do_exedit(eap, old_curwin)
      exarg_T	*eap;
--- 7469,7474 ----
***************
*** 7694,7703 ****
  }
  #endif
  
- /*ARGSUSED*/
      static void
  ex_swapname(eap)
!     exarg_T	*eap;
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
  	MSG(_("No swap file"));
--- 7680,7688 ----
  }
  #endif
  
      static void
  ex_swapname(eap)
!     exarg_T	*eap UNUSED;
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
  	MSG(_("No swap file"));
***************
*** 7710,7719 ****
   * offset.
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
- /*ARGSUSED*/
      static void
  ex_syncbind(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_SCROLLBIND
      win_T	*wp;
--- 7695,7703 ----
   * offset.
   * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
   */
      static void
  ex_syncbind(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_SCROLLBIND
      win_T	*wp;
***************
*** 7983,7992 ****
  /*
   * ":pwd".
   */
- /*ARGSUSED*/
      static void
  ex_pwd(eap)
!     exarg_T	*eap;
  {
      if (mch_dirname(NameBuff, MAXPATHL) == OK)
      {
--- 7967,7975 ----
  /*
   * ":pwd".
   */
      static void
  ex_pwd(eap)
!     exarg_T	*eap UNUSED;
  {
      if (mch_dirname(NameBuff, MAXPATHL) == OK)
      {
***************
*** 8417,8426 ****
  /*
   * ":undo".
   */
- /*ARGSUSED*/
      static void
  ex_undo(eap)
!     exarg_T	*eap;
  {
      if (eap->addr_count == 1)	    /* :undo 123 */
  	undo_time(eap->line2, FALSE, TRUE);
--- 8400,8408 ----
  /*
   * ":undo".
   */
      static void
  ex_undo(eap)
!     exarg_T	*eap UNUSED;
  {
      if (eap->addr_count == 1)	    /* :undo 123 */
  	undo_time(eap->line2, FALSE, TRUE);
***************
*** 8431,8440 ****
  /*
   * ":redo".
   */
- /*ARGSUSED*/
      static void
  ex_redo(eap)
!     exarg_T	*eap;
  {
      u_redo(1);
  }
--- 8413,8421 ----
  /*
   * ":redo".
   */
      static void
  ex_redo(eap)
!     exarg_T	*eap UNUSED;
  {
      u_redo(1);
  }
***************
*** 8442,8448 ****
  /*
   * ":earlier" and ":later".
   */
- /*ARGSUSED*/
      static void
  ex_later(eap)
      exarg_T	*eap;
--- 8423,8428 ----
***************
*** 8627,8636 ****
  /*
   * ":redrawstatus": force redraw of status line(s)
   */
- /*ARGSUSED*/
      static void
  ex_redrawstatus(eap)
!     exarg_T	*eap;
  {
  #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
--- 8607,8615 ----
  /*
   * ":redrawstatus": force redraw of status line(s)
   */
      static void
  ex_redrawstatus(eap)
!     exarg_T	*eap UNUSED;
  {
  #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
***************
*** 8891,8901 ****
  
  #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
  	|| defined(PROTO)
- /*ARGSUSED*/
      int
  vim_mkdir_emsg(name, prot)
      char_u	*name;
!     int		prot;
  {
      if (vim_mkdir(name, prot) != 0)
      {
--- 8870,8879 ----
  
  #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
  	|| defined(PROTO)
      int
  vim_mkdir_emsg(name, prot)
      char_u	*name;
!     int		prot UNUSED;
  {
      if (vim_mkdir(name, prot) != 0)
      {
***************
*** 10968,10977 ****
  }
  #endif
  
- /*ARGSUSED*/
      static void
  ex_digraphs(eap)
!     exarg_T	*eap;
  {
  #ifdef FEAT_DIGRAPHS
      if (*eap->arg != NUL)
--- 10946,10954 ----
  }
  #endif
  
      static void
  ex_digraphs(eap)
!     exarg_T	*eap UNUSED;
  {
  #ifdef FEAT_DIGRAPHS
      if (*eap->arg != NUL)
***************
*** 11005,11014 ****
  /*
   * ":nohlsearch"
   */
- /*ARGSUSED*/
      static void
  ex_nohlsearch(eap)
!     exarg_T	*eap;
  {
      no_hlsearch = TRUE;
      redraw_all_later(SOME_VALID);
--- 10982,10990 ----
  /*
   * ":nohlsearch"
   */
      static void
  ex_nohlsearch(eap)
!     exarg_T	*eap UNUSED;
  {
      no_hlsearch = TRUE;
      redraw_all_later(SOME_VALID);
***************
*** 11087,11096 ****
  /*
   * ":X": Get crypt key
   */
- /*ARGSUSED*/
      static void
  ex_X(eap)
!     exarg_T	*eap;
  {
      (void)get_crypt_key(TRUE, TRUE);
  }
--- 11063,11071 ----
  /*
   * ":X": Get crypt key
   */
      static void
  ex_X(eap)
!     exarg_T	*eap UNUSED;
  {
      (void)get_crypt_key(TRUE, TRUE);
  }
*** ../vim-7.2.173/src/ex_getln.c	2009-04-29 18:44:38.000000000 +0200
--- src/ex_getln.c	2009-05-15 20:49:22.000000000 +0200
***************
*** 140,150 ****
   * Return pointer to allocated string if there is a commandline, NULL
   * otherwise.
   */
- /*ARGSUSED*/
      char_u *
  getcmdline(firstc, count, indent)
      int		firstc;
!     long	count;		/* only used for incremental search */
      int		indent;		/* indent for inside conditionals */
  {
      int		c;
--- 140,149 ----
   * Return pointer to allocated string if there is a commandline, NULL
   * otherwise.
   */
      char_u *
  getcmdline(firstc, count, indent)
      int		firstc;
!     long	count UNUSED;	/* only used for incremental search */
      int		indent;		/* indent for inside conditionals */
  {
      int		c;
***************
*** 2113,2123 ****
  /*
   * Get an Ex command line for the ":" command.
   */
- /* ARGSUSED */
      char_u *
! getexline(c, dummy, indent)
      int		c;		/* normally ':', NUL for ":append" */
!     void	*dummy;		/* cookie not used */
      int		indent;		/* indent for inside conditionals */
  {
      /* When executing a register, remove ':' that's in front of each line. */
--- 2112,2121 ----
  /*
   * Get an Ex command line for the ":" command.
   */
      char_u *
! getexline(c, cookie, indent)
      int		c;		/* normally ':', NUL for ":append" */
!     void	*cookie UNUSED;
      int		indent;		/* indent for inside conditionals */
  {
      /* When executing a register, remove ':' that's in front of each line. */
***************
*** 2132,2143 ****
   * mappings or abbreviations.
   * Returns a string in allocated memory or NULL.
   */
- /* ARGSUSED */
      char_u *
! getexmodeline(promptc, dummy, indent)
      int		promptc;	/* normally ':', NUL for ":append" and '?' for
  				   :s prompt */
!     void	*dummy;		/* cookie not used */
      int		indent;		/* indent for inside conditionals */
  {
      garray_T	line_ga;
--- 2130,2140 ----
   * mappings or abbreviations.
   * Returns a string in allocated memory or NULL.
   */
      char_u *
! getexmodeline(promptc, cookie, indent)
      int		promptc;	/* normally ':', NUL for ":append" and '?' for
  				   :s prompt */
!     void	*cookie UNUSED;
      int		indent;		/* indent for inside conditionals */
  {
      garray_T	line_ga;
***************
*** 3832,3842 ****
   * Returns EXPAND_NOTHING when the character that triggered expansion should
   * be inserted like a normal character.
   */
- /*ARGSUSED*/
      static int
  showmatches(xp, wildmenu)
      expand_T	*xp;
!     int		wildmenu;
  {
  #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
      int		num_files;
--- 3829,3838 ----
   * Returns EXPAND_NOTHING when the character that triggered expansion should
   * be inserted like a normal character.
   */
      static int
  showmatches(xp, wildmenu)
      expand_T	*xp;
!     int		wildmenu UNUSED;
  {
  #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
      int		num_files;
*** ../vim-7.2.173/src/fileio.c	2009-05-13 20:47:07.000000000 +0200
--- src/fileio.c	2009-05-15 20:52:40.000000000 +0200
***************
*** 3498,3504 ****
  		    if (mch_stat((char *)IObuff, &st) < 0
  			    || st.st_uid != st_old.st_uid
  			    || st.st_gid != st_old.st_gid
! 			    || st.st_mode != perm)
  			backup_copy = TRUE;
  # endif
  		    /* Close the file before removing it, on MS-Windows we
--- 3498,3504 ----
  		    if (mch_stat((char *)IObuff, &st) < 0
  			    || st.st_uid != st_old.st_uid
  			    || st.st_gid != st_old.st_gid
! 			    || (long)st.st_mode != perm)
  			backup_copy = TRUE;
  # endif
  		    /* Close the file before removing it, on MS-Windows we
***************
*** 5963,5969 ****
  	else if (*ext == '.')
  #endif
  	{
! 	    if (s - ptr > (size_t)8)
  	    {
  		s = ptr + 8;
  		*s = '\0';
--- 5971,5977 ----
  	else if (*ext == '.')
  #endif
  	{
! 	    if ((size_t)(s - ptr) > (size_t)8)
  	    {
  		s = ptr + 8;
  		*s = '\0';
***************
*** 6460,6470 ****
   * return 2 if a message has been displayed.
   * return 0 otherwise.
   */
- /*ARGSUSED*/
      int
  buf_check_timestamp(buf, focus)
      buf_T	*buf;
!     int		focus;		/* called for GUI focus event */
  {
      struct stat	st;
      int		stat_res;
--- 6468,6477 ----
   * return 2 if a message has been displayed.
   * return 0 otherwise.
   */
      int
  buf_check_timestamp(buf, focus)
      buf_T	*buf;
!     int		focus UNUSED;	/* called for GUI focus event */
  {
      struct stat	st;
      int		stat_res;
***************
*** 6868,6879 ****
      /* Careful: autocommands may have made "buf" invalid! */
  }
  
- /*ARGSUSED*/
      void
  buf_store_time(buf, st, fname)
      buf_T	*buf;
      struct stat	*st;
!     char_u	*fname;
  {
      buf->b_mtime = (long)st->st_mtime;
      buf->b_orig_size = (size_t)st->st_size;
--- 6875,6885 ----
      /* Careful: autocommands may have made "buf" invalid! */
  }
  
      void
  buf_store_time(buf, st, fname)
      buf_T	*buf;
      struct stat	*st;
!     char_u	*fname UNUSED;
  {
      buf->b_mtime = (long)st->st_mtime;
      buf->b_orig_size = (size_t)st->st_size;
***************
*** 6936,6945 ****
   * The returned pointer is to allocated memory.
   * The returned pointer is NULL if no valid name was found.
   */
- /*ARGSUSED*/
      char_u  *
  vim_tempname(extra_char)
!     int	    extra_char;	    /* character to use in the name instead of '?' */
  {
  #ifdef USE_TMPNAM
      char_u	itmp[L_tmpnam];	/* use tmpnam() */
--- 6942,6950 ----
   * The returned pointer is to allocated memory.
   * The returned pointer is NULL if no valid name was found.
   */
      char_u  *
  vim_tempname(extra_char)
!     int	    extra_char UNUSED;  /* char to use in the name instead of '?' */
  {
  #ifdef USE_TMPNAM
      char_u	itmp[L_tmpnam];	/* use tmpnam() */
***************
*** 6968,6974 ****
  	/*
  	 * Try the entries in TEMPDIRNAMES to create the temp directory.
  	 */
! 	for (i = 0; i < sizeof(tempdirs) / sizeof(char *); ++i)
  	{
  	    /* expand $TMP, leave room for "/v1100000/999999999" */
  	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
--- 6973,6979 ----
  	/*
  	 * Try the entries in TEMPDIRNAMES to create the temp directory.
  	 */
! 	for (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)
  	{
  	    /* expand $TMP, leave room for "/v1100000/999999999" */
  	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
***************
*** 9588,9600 ****
   *
   * Returns NULL when out of memory.
   */
- /*ARGSUSED*/
      char_u *
  file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
      char_u	*pat;
      char_u	*pat_end;	/* first char after pattern or NULL */
      char	*allow_dirs;	/* Result passed back out in here */
!     int		no_bslash;	/* Don't use a backward slash as pathsep */
  {
      int		size;
      char_u	*endp;
--- 9593,9604 ----
   *
   * Returns NULL when out of memory.
   */
      char_u *
  file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
      char_u	*pat;
      char_u	*pat_end;	/* first char after pattern or NULL */
      char	*allow_dirs;	/* Result passed back out in here */
!     int		no_bslash UNUSED; /* Don't use a backward slash as pathsep */
  {
      int		size;
      char_u	*endp;
*** ../vim-7.2.173/src/misc1.c	2009-04-29 11:00:09.000000000 +0200
--- src/misc1.c	2009-05-15 20:59:08.000000000 +0200
***************
*** 2188,2199 ****
   *
   * return FAIL for failure, OK otherwise
   */
- /*ARGSUSED*/
      int
  del_bytes(count, fixpos_arg, use_delcombine)
      long	count;
      int		fixpos_arg;
!     int		use_delcombine;	    /* 'delcombine' option applies */
  {
      char_u	*oldp, *newp;
      colnr_T	oldlen;
--- 2188,2198 ----
   *
   * return FAIL for failure, OK otherwise
   */
      int
  del_bytes(count, fixpos_arg, use_delcombine)
      long	count;
      int		fixpos_arg;
!     int		use_delcombine UNUSED;	    /* 'delcombine' option applies */
  {
      char_u	*oldp, *newp;
      colnr_T	oldlen;
*** ../vim-7.2.173/src/move.c	2008-11-15 16:05:30.000000000 +0100
--- src/move.c	2009-05-15 21:00:06.000000000 +0200
***************
*** 1238,1248 ****
  /*
   * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
   */
- /*ARGSUSED*/
      void
  scrolldown(line_count, byfold)
      long	line_count;
!     int		byfold;		/* TRUE: count a closed fold as one line */
  {
      long	done = 0;	/* total # of physical lines done */
      int		wrow;
--- 1238,1247 ----
  /*
   * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
   */
      void
  scrolldown(line_count, byfold)
      long	line_count;
!     int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
  {
      long	done = 0;	/* total # of physical lines done */
      int		wrow;
***************
*** 1349,1359 ****
  /*
   * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
   */
- /*ARGSUSED*/
      void
  scrollup(line_count, byfold)
      long	line_count;
!     int		byfold;		/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
--- 1348,1357 ----
  /*
   * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
   */
      void
  scrollup(line_count, byfold)
      long	line_count;
!     int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
*** ../vim-7.2.173/src/normal.c	2009-04-29 17:39:17.000000000 +0200
--- src/normal.c	2009-05-15 21:08:07.000000000 +0200
***************
*** 493,506 ****
      int		i;
  
      /* Fill the index table with a one to one relation. */
!     for (i = 0; i < NV_CMDS_SIZE; ++i)
  	nv_cmd_idx[i] = i;
  
      /* Sort the commands by the command character.  */
      qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
  
      /* Find the first entry that can't be indexed by the command character. */
!     for (i = 0; i < NV_CMDS_SIZE; ++i)
  	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
  	    break;
      nv_max_linear = i - 1;
--- 493,506 ----
      int		i;
  
      /* Fill the index table with a one to one relation. */
!     for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
  	nv_cmd_idx[i] = i;
  
      /* Sort the commands by the command character.  */
      qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
  
      /* Find the first entry that can't be indexed by the command character. */
!     for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
  	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
  	    break;
      nv_max_linear = i - 1;
***************
*** 561,571 ****
  /*
   * Execute a command in Normal mode.
   */
- /*ARGSUSED*/
      void
  normal_cmd(oap, toplevel)
      oparg_T	*oap;
!     int		toplevel;		/* TRUE when called from main() */
  {
      cmdarg_T	ca;			/* command arguments */
      int		c;
--- 561,570 ----
  /*
   * Execute a command in Normal mode.
   */
      void
  normal_cmd(oap, toplevel)
      oparg_T	*oap;
!     int		toplevel UNUSED;	/* TRUE when called from main() */
  {
      cmdarg_T	ca;			/* command arguments */
      int		c;
***************
*** 2188,2197 ****
  /*
   * Handle the "g@" operator: call 'operatorfunc'.
   */
- /*ARGSUSED*/
      static void
  op_function(oap)
!     oparg_T	*oap;
  {
  #ifdef FEAT_EVAL
      char_u	*(argv[1]);
--- 2187,2195 ----
  /*
   * Handle the "g@" operator: call 'operatorfunc'.
   */
      static void
  op_function(oap)
!     oparg_T	*oap UNUSED;
  {
  #ifdef FEAT_EVAL
      char_u	*(argv[1]);
***************
*** 4100,4109 ****
   * Command character that doesn't do anything, but unlike nv_ignore() does
   * start edit().  Used for "startinsert" executed while starting up.
   */
- /*ARGSUSED */
      static void
  nv_nop(cap)
!     cmdarg_T	*cap;
  {
  }
  
--- 4098,4106 ----
   * Command character that doesn't do anything, but unlike nv_ignore() does
   * start edit().  Used for "startinsert" executed while starting up.
   */
      static void
  nv_nop(cap)
!     cmdarg_T	*cap UNUSED;
  {
  }
  
***************
*** 5241,5247 ****
  	if (cap->oap->op_type != OP_NOP
  		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
  		    || cap->oap->start.col >
! 					 STRLEN(ml_get(cap->oap->start.lnum))))
  	    clearopbeep(cap->oap);
      }
  }
--- 5238,5244 ----
  	if (cap->oap->op_type != OP_NOP
  		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
  		    || cap->oap->start.col >
! 			       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))))
  	    clearopbeep(cap->oap);
      }
  }
***************
*** 5816,5822 ****
      for (n = cap->count1; n > 0; --n)
      {
  	if ((!PAST_LINE && oneright() == FAIL)
! 		|| (PAST_LINE && *ml_get_cursor() == NUL))
  	{
  	    /*
  	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
--- 5813,5822 ----
      for (n = cap->count1; n > 0; --n)
      {
  	if ((!PAST_LINE && oneright() == FAIL)
! #ifdef FEAT_VISUAL
! 		|| (PAST_LINE && *ml_get_cursor() == NUL)
! #endif
! 		)
  	{
  	    /*
  	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
*** ../vim-7.2.173/src/option.c	2009-03-18 15:40:03.000000000 +0100
--- src/option.c	2009-05-15 21:08:50.000000000 +0200
***************
*** 5302,5315 ****
   * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
   * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
   */
- /*ARGSUSED*/
      void
  set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
      char_u	*name;
      int		opt_idx;
      char_u	*val;
      int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		set_sid;
  {
      char_u	*s;
      char_u	**varp;
--- 5302,5314 ----
   * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
   * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
   */
      void
  set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
      char_u	*name;
      int		opt_idx;
      char_u	*val;
      int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
!     int		set_sid UNUSED;
  {
      char_u	*s;
      char_u	**varp;
***************
*** 9357,9366 ****
  /*
   * Check for NULL pointers in a winopt_T and replace them with empty_option.
   */
- /*ARGSUSED*/
      void
  check_winopt(wop)
!     winopt_T	*wop;
  {
  #ifdef FEAT_FOLDING
      check_string_option(&wop->wo_fdi);
--- 9356,9364 ----
  /*
   * Check for NULL pointers in a winopt_T and replace them with empty_option.
   */
      void
  check_winopt(wop)
!     winopt_T	*wop UNUSED;
  {
  #ifdef FEAT_FOLDING
      check_string_option(&wop->wo_fdi);
***************
*** 9382,9391 ****
  /*
   * Free the allocated memory inside a winopt_T.
   */
- /*ARGSUSED*/
      void
  clear_winopt(wop)
!     winopt_T	*wop;
  {
  #ifdef FEAT_FOLDING
      clear_string_option(&wop->wo_fdi);
--- 9380,9388 ----
  /*
   * Free the allocated memory inside a winopt_T.
   */
      void
  clear_winopt(wop)
!     winopt_T	*wop UNUSED;
  {
  #ifdef FEAT_FOLDING
      clear_string_option(&wop->wo_fdi);
*** ../vim-7.2.173/src/os_unix.c	2009-05-13 12:46:36.000000000 +0200
--- src/os_unix.c	2009-05-15 21:13:43.000000000 +0200
***************
*** 458,467 ****
   * Return total amount of memory available in Kbyte.
   * Doesn't change when memory has been allocated.
   */
- /* ARGSUSED */
      long_u
  mch_total_mem(special)
!     int special;
  {
  # ifdef __EMX__
      return ulimit(3, 0L) >> 10;   /* always 32MB? */
--- 458,466 ----
   * Return total amount of memory available in Kbyte.
   * Doesn't change when memory has been allocated.
   */
      long_u
  mch_total_mem(special)
!     int special UNUSED;
  {
  # ifdef __EMX__
      return ulimit(3, 0L) >> 10;   /* always 32MB? */
***************
*** 815,821 ****
   * Let me try it with a few tricky defines from my own osdef.h	(jw).
   */
  #if defined(SIGWINCH)
- /* ARGSUSED */
      static RETSIGTYPE
  sig_winch SIGDEFARG(sigarg)
  {
--- 814,819 ----
***************
*** 1355,1365 ****
  /*
   * Check_win checks whether we have an interactive stdout.
   */
- /* ARGSUSED */
      int
  mch_check_win(argc, argv)
!     int	    argc;
!     char    **argv;
  {
  #ifdef OS2
      /*
--- 1353,1362 ----
  /*
   * Check_win checks whether we have an interactive stdout.
   */
      int
  mch_check_win(argc, argv)
!     int	    argc UNUSED;
!     char    **argv UNUSED;
  {
  #ifdef OS2
      /*
***************
*** 2467,2473 ****
      }
  
      /* Catch file names which are too long. */
!     if (retval == FAIL || STRLEN(buf) + STRLEN(fname) >= len)
  	return FAIL;
  
      /* Do not append ".", "/dir/." is equal to "/dir". */
--- 2464,2470 ----
      }
  
      /* Catch file names which are too long. */
!     if (retval == FAIL || (int)(STRLEN(buf) + STRLEN(fname)) >= len)
  	return FAIL;
  
      /* Do not append ".", "/dir/." is equal to "/dir". */
***************
*** 2686,2692 ****
   */
      vim_acl_T
  mch_get_acl(fname)
!     char_u	*fname;
  {
      vim_acl_T	ret = NULL;
  #ifdef HAVE_POSIX_ACL
--- 2683,2689 ----
   */
      vim_acl_T
  mch_get_acl(fname)
!     char_u	*fname UNUSED;
  {
      vim_acl_T	ret = NULL;
  #ifdef HAVE_POSIX_ACL
***************
*** 2746,2752 ****
   */
      void
  mch_set_acl(fname, aclent)
!     char_u	*fname;
      vim_acl_T	aclent;
  {
      if (aclent == NULL)
--- 2743,2749 ----
   */
      void
  mch_set_acl(fname, aclent)
!     char_u	*fname UNUSED;
      vim_acl_T	aclent;
  {
      if (aclent == NULL)
***************
*** 2789,2798 ****
  /*
   * Set hidden flag for "name".
   */
- /* ARGSUSED */
      void
  mch_hide(name)
!     char_u	*name;
  {
      /* can't hide a file */
  }
--- 2786,2794 ----
  /*
   * Set hidden flag for "name".
   */
      void
  mch_hide(name)
!     char_u	*name UNUSED;
  {
      /* can't hide a file */
  }
***************
*** 3481,3490 ****
  /*
   * set screen mode, always fails.
   */
- /* ARGSUSED */
      int
  mch_screenmode(arg)
!     char_u   *arg;
  {
      EMSG(_(e_screenmode));
      return FAIL;
--- 3477,3485 ----
  /*
   * set screen mode, always fails.
   */
      int
  mch_screenmode(arg)
!     char_u   *arg UNUSED;
  {
      EMSG(_(e_screenmode));
      return FAIL;
***************
*** 4189,4197 ****
  			    {
  				s = vim_strchr(lp + written, NL);
  				len = write(toshell_fd, (char *)lp + written,
! 					   s == NULL ? l : s - (lp + written));
  			    }
! 			    if (len == l)
  			    {
  				/* Finished a line, add a NL, unless this line
  				 * should not have one. */
--- 4184,4193 ----
  			    {
  				s = vim_strchr(lp + written, NL);
  				len = write(toshell_fd, (char *)lp + written,
! 					   s == NULL ? l
! 					      : (size_t)(s - (lp + written)));
  			    }
! 			    if (len == (int)l)
  			    {
  				/* Finished a line, add a NL, unless this line
  				 * should not have one. */
***************
*** 4746,4752 ****
   * Returns also, when a request from Sniff is waiting -- toni.
   * Or when a Linux GPM mouse event is waiting.
   */
- /* ARGSUSED */
  #if defined(__BEOS__)
      int
  #else
--- 4742,4747 ----
***************
*** 4755,4761 ****
  RealWaitForChar(fd, msec, check_for_gpm)
      int		fd;
      long	msec;
!     int		*check_for_gpm;
  {
      int		ret;
  #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
--- 4750,4756 ----
  RealWaitForChar(fd, msec, check_for_gpm)
      int		fd;
      long	msec;
!     int		*check_for_gpm UNUSED;
  {
      int		ret;
  #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
***************
*** 5572,5578 ****
      i = fread((char *)buffer, 1, len, fd);
      fclose(fd);
      mch_remove(tempname);
!     if (i != len)
      {
  	/* unexpected read error */
  	EMSG2(_(e_notread), tempname);
--- 5567,5573 ----
      i = fread((char *)buffer, 1, len, fd);
      fclose(fd);
      mch_remove(tempname);
!     if (i != (int)len)
      {
  	/* unexpected read error */
  	EMSG2(_(e_notread), tempname);
***************
*** 5633,5639 ****
  	if (shell_style == STYLE_PRINT && !did_find_nul)
  	{
  	    /* If there is a NUL, set did_find_nul, else set check_spaces */
! 	    if (len && (int)STRLEN(buffer) < len - 1)
  		did_find_nul = TRUE;
  	    else
  		check_spaces = TRUE;
--- 5628,5634 ----
  	if (shell_style == STYLE_PRINT && !did_find_nul)
  	{
  	    /* If there is a NUL, set did_find_nul, else set check_spaces */
! 	    if (len && (int)STRLEN(buffer) < (int)len - 1)
  		did_find_nul = TRUE;
  	    else
  		check_spaces = TRUE;
*** ../vim-7.2.173/src/os_unix.h	2009-05-13 12:46:36.000000000 +0200
--- src/os_unix.h	2009-05-15 21:10:31.000000000 +0200
***************
*** 126,132 ****
  #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
  # else
  #  define SIGPROTOARG	(int)
! #  define SIGDEFARG(s)	(s) int s;
  #  define SIGDUMMYARG	0
  # endif
  #else
--- 126,132 ----
  #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
  # else
  #  define SIGPROTOARG	(int)
! #  define SIGDEFARG(s)	(s) int s UNUSED;
  #  define SIGDUMMYARG	0
  # endif
  #else
*** ../vim-7.2.173/src/regexp.c	2009-02-21 22:03:06.000000000 +0100
--- src/regexp.c	2009-05-15 21:14:18.000000000 +0200
***************
*** 471,477 ****
  
      if ((*pp)[1] == ':')
      {
! 	for (i = 0; i < sizeof(class_names) / sizeof(*class_names); ++i)
  	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
  	    {
  		*pp += STRLEN(class_names[i]) + 2;
--- 471,477 ----
  
      if ((*pp)[1] == ':')
      {
! 	for (i = 0; i < (int)(sizeof(class_names) / sizeof(*class_names)); ++i)
  	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
  	    {
  		*pp += STRLEN(class_names[i]) + 2;
***************
*** 3362,3373 ****
   * Match a regexp against a string ("line" points to the string) or multiple
   * lines ("line" is NULL, use reg_getline()).
   */
- /*ARGSUSED*/
      static long
  vim_regexec_both(line, col, tm)
      char_u	*line;
      colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      regprog_T	*prog;
      char_u	*s;
--- 3362,3372 ----
   * Match a regexp against a string ("line" points to the string) or multiple
   * lines ("line" is NULL, use reg_getline()).
   */
      static long
  vim_regexec_both(line, col, tm)
      char_u	*line;
      colnr_T	col;		/* column to start looking for match */
!     proftime_T	*tm UNUSED;	/* timeout limit or NULL */
  {
      regprog_T	*prog;
      char_u	*s;
*** ../vim-7.2.173/src/search.c	2009-04-22 18:43:06.000000000 +0200
--- src/search.c	2009-05-15 21:16:36.000000000 +0200
***************
*** 522,528 ****
   * When FEAT_EVAL is defined, returns the index of the first matching
   * subpattern plus one; one if there was none.
   */
- /*ARGSUSED*/
      int
  searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
      win_T	*win;		/* window to search in; can be NULL for a
--- 522,527 ----
***************
*** 535,541 ****
      int		options;
      int		pat_use;	/* which pattern to use when "pat" is empty */
      linenr_T	stop_lnum;	/* stop after this line number when != 0 */
!     proftime_T	*tm;		/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
--- 534,540 ----
      int		options;
      int		pat_use;	/* which pattern to use when "pat" is empty */
      linenr_T	stop_lnum;	/* stop after this line number when != 0 */
!     proftime_T	*tm UNUSED;	/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
***************
*** 554,561 ****
      int		save_called_emsg = called_emsg;
  #ifdef FEAT_SEARCH_EXTRA
      int		break_loop = FALSE;
- #else
- # define break_loop FALSE
  #endif
  
      if (search_regcomp(pat, RE_SEARCH, pat_use,
--- 553,558 ----
***************
*** 940,946 ****
  	     * twice.
  	     */
  	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
! 					       || break_loop || found || loop)
  		break;
  
  	    /*
--- 937,946 ----
  	     * twice.
  	     */
  	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
! #ifdef FEAT_SEARCH_EXTRA
! 					       || break_loop
! #endif
! 					       || found || loop)
  		break;
  
  	    /*
***************
*** 958,964 ****
  		give_warning((char_u *)_(dir == BACKWARD
  					  ? top_bot_msg : bot_top_msg), TRUE);
  	}
! 	if (got_int || called_emsg || break_loop)
  	    break;
      }
      while (--count > 0 && found);   /* stop after count matches or no match */
--- 958,968 ----
  		give_warning((char_u *)_(dir == BACKWARD
  					  ? top_bot_msg : bot_top_msg), TRUE);
  	}
! 	if (got_int || called_emsg
! #ifdef FEAT_SEARCH_EXTRA
! 		|| break_loop
! #endif
! 		)
  	    break;
      }
      while (--count > 0 && found);   /* stop after count matches or no match */
*** ../vim-7.2.173/src/tag.c	2009-02-23 00:53:35.000000000 +0100
--- src/tag.c	2009-05-15 21:16:59.000000000 +0200
***************
*** 1105,1114 ****
  /*
   * Print the tag stack
   */
- /*ARGSUSED*/
      void
  do_tags(eap)
!     exarg_T	*eap;
  {
      int		i;
      char_u	*name;
--- 1105,1113 ----
  /*
   * Print the tag stack
   */
      void
  do_tags(eap)
!     exarg_T	*eap UNUSED;
  {
      int		i;
      char_u	*name;
***************
*** 2530,2540 ****
   * Callback function for finding all "tags" and "tags-??" files in
   * 'runtimepath' doc directories.
   */
- /*ARGSUSED*/
      static void
  found_tagfile_cb(fname, cookie)
      char_u	*fname;
!     void	*cookie;
  {
      if (ga_grow(&tag_fnames, 1) == OK)
  	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
--- 2529,2538 ----
   * Callback function for finding all "tags" and "tags-??" files in
   * 'runtimepath' doc directories.
   */
      static void
  found_tagfile_cb(fname, cookie)
      char_u	*fname;
!     void	*cookie UNUSED;
  {
      if (ga_grow(&tag_fnames, 1) == OK)
  	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
*** ../vim-7.2.173/src/version.c	2009-05-14 22:19:19.000000000 +0200
--- src/version.c	2009-05-15 21:21:44.000000000 +0200
***************
*** 678,679 ****
--- 678,681 ----
  {   /* Add new patch number below this line */
+ /**/
+     174,
  /**/

-- 
TERRY GILLIAM PLAYED: PATSY (ARTHUR'S TRUSTY STEED), THE GREEN KNIGHT
                      SOOTHSAYER, BRIDGEKEEPER, SIR GAWAIN (THE FIRST TO BE
                      KILLED BY THE RABBIT)
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
