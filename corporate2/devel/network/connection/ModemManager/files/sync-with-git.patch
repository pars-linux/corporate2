commit 19c988d92b67b56d7c87993f7a8efd984124df39
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Jan 19 13:19:55 2010 -0800

    anydata: add plugin for AnyData CDMA devices (rh #547294)

diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 21fd8e3..a361358 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -10,7 +10,8 @@ pkglib_LTLIBRARIES = \
 	libmm-plugin-nokia.la \
 	libmm-plugin-zte.la \
 	libmm-plugin-mbm.la \
-	libmm-plugin-longcheer.la
+	libmm-plugin-longcheer.la \
+	libmm-plugin-anydata.la
 
 # Generic
 
@@ -232,6 +233,24 @@ libmm_plugin_longcheer_la_LDFLAGS = \
 	-module \
 	-avoid-version
 
+# AnyData CDMA
+
+libmm_plugin_anydata_la_SOURCES = \
+	mm-plugin-anydata.c \
+	mm-plugin-anydata.h \
+	mm-modem-anydata-cdma.c \
+	mm-modem-anydata-cdma.h
+
+libmm_plugin_anydata_la_CPPFLAGS = \
+	$(MM_CFLAGS) \
+	$(GUDEV_CFLAGS) \
+	-I$(top_srcdir)/src
+
+libmm_plugin_anydata_la_LDFLAGS = \
+	$(GUDEV_LDFLAGS) \
+	-module \
+	-avoid-version
+
 
 udevrulesdir = $(UDEV_BASE_DIR)/rules.d
 udevrules_DATA = \
diff --git a/plugins/mm-modem-anydata-cdma.c b/plugins/mm-modem-anydata-cdma.c
new file mode 100644
index 0000000..0988f8d
--- /dev/null
+++ b/plugins/mm-modem-anydata-cdma.c
@@ -0,0 +1,336 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2008 - 2009 Novell, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#define G_UDEV_API_IS_SUBJECT_TO_CHANGE
+#include <gudev/gudev.h>
+
+#include "mm-modem-anydata-cdma.h"
+#include "mm-errors.h"
+#include "mm-callback-info.h"
+#include "mm-serial-port.h"
+#include "mm-serial-parsers.h"
+
+G_DEFINE_TYPE (MMModemAnydataCdma, mm_modem_anydata_cdma, MM_TYPE_GENERIC_CDMA)
+
+#define MM_MODEM_ANYDATA_CDMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MM_TYPE_MODEM_ANYDATA_CDMA, MMModemAnydataCdmaPrivate))
+
+typedef enum {
+    SYS_MODE_UNKNOWN,
+    SYS_MODE_NO_SERVICE,
+    SYS_MODE_CDMA_1X,
+    SYS_MODE_EVDO_REV0,
+    SYS_MODE_EVDO_REVA
+} SysMode;
+
+typedef struct {
+    SysMode sys_mode;
+} MMModemAnydataCdmaPrivate;
+
+MMModem *
+mm_modem_anydata_cdma_new (const char *device,
+                           const char *driver,
+                           const char *plugin,
+                           gboolean evdo_rev0,
+                           gboolean evdo_revA)
+{
+    g_return_val_if_fail (device != NULL, NULL);
+    g_return_val_if_fail (driver != NULL, NULL);
+    g_return_val_if_fail (plugin != NULL, NULL);
+
+    return MM_MODEM (g_object_new (MM_TYPE_MODEM_ANYDATA_CDMA,
+                                   MM_MODEM_MASTER_DEVICE, device,
+                                   MM_MODEM_DRIVER, driver,
+                                   MM_MODEM_PLUGIN, plugin,
+                                   MM_GENERIC_CDMA_EVDO_REV0, evdo_rev0,
+                                   MM_GENERIC_CDMA_EVDO_REVA, evdo_revA,
+                                   NULL));
+}
+
+/*****************************************************************************/
+
+static const char *
+strip_response (const char *resp, const char *cmd)
+{
+    const char *p = resp;
+
+    if (p) {
+        if (!strncmp (p, cmd, strlen (cmd)))
+            p += strlen (cmd);
+        while (*p == ' ')
+            p++;
+    }
+    return p;
+}
+
+static gboolean
+uint_from_match_item (GMatchInfo *match_info, guint32 num, guint32 *val)
+{
+    long int tmp;
+    char *str;
+    gboolean success = FALSE;
+
+    str = g_match_info_fetch (match_info, num);
+    g_return_val_if_fail (str != NULL, FALSE);
+
+    errno = 0;
+    tmp = strtol (str, NULL, 10);
+    if (errno == 0 && tmp >= 0 && tmp <= G_MAXUINT) {
+        *val = (guint32) tmp;
+        success = TRUE;
+    }
+    g_free (str);
+    return success;
+}
+
+static gboolean
+int_from_match_item (GMatchInfo *match_info, guint32 num, gint *val)
+{
+    long int tmp;
+    char *str;
+    gboolean success = FALSE;
+
+    str = g_match_info_fetch (match_info, num);
+    g_return_val_if_fail (str != NULL, FALSE);
+
+    errno = 0;
+    tmp = strtol (str, NULL, 10);
+    if (errno == 0 && tmp >= G_MININT && tmp <= G_MAXINT) {
+        *val = (gint) tmp;
+        success = TRUE;
+    }
+    g_free (str);
+    return success;
+}
+
+static void
+evdo_state_done (MMSerialPort *port,
+                 GString *response,
+                 GError *error,
+                 gpointer user_data)
+{
+    MMCallbackInfo *info = (MMCallbackInfo *) user_data;
+    MMModemCdmaRegistrationState reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_UNKNOWN;
+    const char *reply;
+    GRegex *r;
+    GMatchInfo *match_info;
+
+    info->error = mm_modem_check_removed (info->modem, error);
+    if (info->error) {
+        if (info->modem) {
+            /* If HSTATE returned an error, assume the device is not EVDO capable
+             * or EVDO is not registered.
+             */
+            mm_generic_cdma_query_reg_state_set_callback_evdo_state (info, MM_MODEM_CDMA_REGISTRATION_STATE_UNKNOWN);
+        }
+
+        mm_callback_info_schedule (info);
+        return;
+    }
+
+    reply = strip_response (response->str, "*HSTATE:");
+
+    /* Format is "<at state>,<session state>,<channel>,<pn>,<EcIo>,<rssi>,..." */
+    r = g_regex_new ("\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([^,\\)]*)\\s*,\\s*([^,\\)]*)\\s*,.*",
+                     G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+    if (!r) {
+        /* Parse error; warn about it and assume EVDO is not available */
+        g_warning ("AnyData(%s): failed to create EVDO state regex: (%d) %s",
+                   __func__,
+                   error ? error->code : -1,
+                   error && error->message ? error->message : "(unknown)");
+        mm_generic_cdma_query_reg_state_set_callback_evdo_state (info, MM_MODEM_CDMA_REGISTRATION_STATE_UNKNOWN);
+        mm_callback_info_schedule (info);
+        return;
+    }
+
+    g_regex_match (r, reply, 0, &match_info);
+    if (g_match_info_get_match_count (match_info) >= 6) {
+        guint32 val = 0;
+        gint dbm = 0;
+
+        /* dBm is between -106 (worst) and -20.7 (best) */
+        int_from_match_item (match_info, 6, &dbm);
+
+        /* Parse the EVDO radio state */
+    	if (uint_from_match_item (match_info, 1, &val)) {
+    	    switch (val) {
+            case 3:  /* IDLE */
+                /* If IDLE and the EVDO dBm is -105 or lower, assume no service.
+                 * It may be that IDLE actually means NO SERVICE too; not sure.
+                 */
+                if (dbm > -105)
+                    reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED;
+                break;
+            case 4:  /* ACCESS */
+            case 5:  /* CONNECT */
+                reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED;
+                break;
+            default:
+                g_message ("ANYDATA: unknown *STATE (%d); assuming no service.", val);
+                /* fall through */
+    	    case 0:  /* NO SERVICE */
+    	    case 1:  /* ACQUISITION */
+    	    case 2:  /* SYNC */
+                break;
+    	    }
+    	}
+    }
+
+    mm_generic_cdma_query_reg_state_set_callback_evdo_state (info, reg_state);
+
+    mm_callback_info_schedule (info);
+}
+
+static void
+state_done (MMSerialPort *port,
+            GString *response,
+            GError *error,
+            gpointer user_data)
+{
+    MMCallbackInfo *info = (MMCallbackInfo *) user_data;
+    MMModemAnydataCdmaPrivate *priv;
+    MMModemCdmaRegistrationState reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_UNKNOWN;
+    const char *reply;
+    GRegex *r;
+    GMatchInfo *match_info;
+
+    info->error = mm_modem_check_removed (info->modem, error);
+    if (info->error) {
+        if (info->modem) {
+            /* Assume if we got this far, we're registered even if an error
+             * occurred.  We're not sure if all AnyData CDMA modems support
+             * the *STATE and *HSTATE commands.
+             */
+            mm_generic_cdma_query_reg_state_set_callback_1x_state (info, MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED);
+            mm_generic_cdma_query_reg_state_set_callback_evdo_state (info, MM_MODEM_CDMA_REGISTRATION_STATE_UNKNOWN);
+        }
+
+        mm_callback_info_schedule (info);
+        return;
+    }
+
+    priv = MM_MODEM_ANYDATA_CDMA_GET_PRIVATE (info->modem);
+
+    reply = strip_response (response->str, "*STATE:");
+
+    /* Format is "<channel>,<pn>,<sid>,<nid>,<state>,<rssi>,..." */
+    r = g_regex_new ("\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([^,\\)]*)\\s*,.*",
+                     G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+    if (!r) {
+        info->error = g_error_new_literal (MM_MODEM_ERROR,
+                                           MM_MODEM_ERROR_GENERAL,
+                                           "Could not parse sysinfo results (regex creation failed).");
+        mm_callback_info_schedule (info);
+        return;
+    }
+
+    g_regex_match (r, reply, 0, &match_info);
+    if (g_match_info_get_match_count (match_info) >= 6) {
+        guint32 val = 0;
+        gint dbm = 0;
+
+        /* dBm is between -106 (worst) and -20.7 (best) */
+        int_from_match_item (match_info, 6, &dbm);
+
+        /* Parse the 1x radio state */
+    	if (uint_from_match_item (match_info, 5, &val)) {
+    	    switch (val) {
+            case 1:  /* IDLE */
+                /* If IDLE and the 1X dBm is -105 or lower, assume no service.
+                 * It may be that IDLE actually means NO SERVICE too; not sure.
+                 */
+                if (dbm > -105)
+                    reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED;
+                break;
+            case 2:  /* ACCESS */
+            case 3:  /* PAGING */
+            case 4:  /* TRAFFIC */
+                reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED;
+                break;
+            default:
+                g_message ("ANYDATA: unknown *STATE (%d); assuming no service.", val);
+                /* fall through */
+    	    case 0:  /* NO SERVICE */
+                break;
+    	    }
+    	}
+    }
+
+    mm_generic_cdma_query_reg_state_set_callback_1x_state (info, reg_state);
+
+    /* Try for EVDO state too */
+    mm_serial_port_queue_command (port, "*HSTATE?", 3, evdo_state_done, info);
+}
+
+static void
+query_registration_state (MMGenericCdma *cdma,
+                          MMModemCdmaRegistrationStateFn callback,
+                          gpointer user_data)
+{
+    MMCallbackInfo *info;
+    MMSerialPort *primary, *secondary, *port;
+
+    port = primary = mm_generic_cdma_get_port (cdma, MM_PORT_TYPE_PRIMARY);
+    secondary = mm_generic_cdma_get_port (cdma, MM_PORT_TYPE_SECONDARY);
+
+    info = mm_generic_cdma_query_reg_state_callback_info_new (cdma, callback, user_data);
+
+    if (mm_port_get_connected (MM_PORT (primary))) {
+        if (!secondary) {
+            info->error = g_error_new_literal (MM_MODEM_ERROR, MM_MODEM_ERROR_CONNECTED,
+                                               "Cannot get query registration state while connected");
+            mm_callback_info_schedule (info);
+            return;
+        }
+
+        /* Use secondary port if primary is connected */
+        port = secondary;        
+    }
+
+    mm_serial_port_queue_command (port, "*STATE?", 3, state_done, info);
+}
+
+/*****************************************************************************/
+
+static void
+mm_modem_anydata_cdma_init (MMModemAnydataCdma *self)
+{
+}
+
+static void
+mm_modem_anydata_cdma_class_init (MMModemAnydataCdmaClass *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+    MMGenericCdmaClass *cdma_class = MM_GENERIC_CDMA_CLASS (klass);
+
+    mm_modem_anydata_cdma_parent_class = g_type_class_peek_parent (klass);
+    g_type_class_add_private (object_class, sizeof (MMModemAnydataCdmaPrivate));
+
+    cdma_class->query_registration_state = query_registration_state;
+
+#if 0
+    /* FIXME: maybe use AT*SLEEP=0/1 to disable/enable slotted mode for powersave */
+    cdma_class->post_enable = post_enable;
+    cdma_class->post_enable = post_disable;
+#endif
+}
+
diff --git a/plugins/mm-modem-anydata-cdma.h b/plugins/mm-modem-anydata-cdma.h
new file mode 100644
index 0000000..d2695d5
--- /dev/null
+++ b/plugins/mm-modem-anydata-cdma.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2008 - 2009 Novell, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#ifndef MM_MODEM_ANYDATA_CDMA_H
+#define MM_MODEM_ANYDATA_CDMA_H
+
+#include "mm-generic-cdma.h"
+
+#define MM_TYPE_MODEM_ANYDATA_CDMA            (mm_modem_anydata_cdma_get_type ())
+#define MM_MODEM_ANYDATA_CDMA(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_MODEM_ANYDATA_CDMA, MMModemAnydataCdma))
+#define MM_MODEM_ANYDATA_CDMA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_MODEM_ANYDATA_CDMA, MMModemAnydataCdmaClass))
+#define MM_IS_MODEM_ANYDATA_CDMA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_MODEM_ANYDATA_CDMA))
+#define MM_IS_MODEM_ANYDATA_CDMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_MODEM_ANYDATA_CDMA))
+#define MM_MODEM_ANYDATA_CDMA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_MODEM_ANYDATA_CDMA, MMModemAnydataCdmaClass))
+
+typedef struct {
+    MMGenericCdma parent;
+} MMModemAnydataCdma;
+
+typedef struct {
+    MMGenericCdmaClass parent;
+} MMModemAnydataCdmaClass;
+
+GType mm_modem_anydata_cdma_get_type (void);
+
+MMModem *mm_modem_anydata_cdma_new (const char *device,
+                                    const char *driver,
+                                    const char *plugin,
+                                    gboolean evdo_rev0,
+                                    gboolean evdo_revA);
+
+#endif /* MM_MODEM_ANYDATA_CDMA_H */
diff --git a/plugins/mm-plugin-anydata.c b/plugins/mm-plugin-anydata.c
new file mode 100644
index 0000000..e451714
--- /dev/null
+++ b/plugins/mm-plugin-anydata.c
@@ -0,0 +1,179 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2008 - 2009 Novell, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <gmodule.h>
+#include "mm-plugin-anydata.h"
+#include "mm-modem-anydata-cdma.h"
+
+G_DEFINE_TYPE (MMPluginAnydata, mm_plugin_anydata, MM_TYPE_PLUGIN_BASE)
+
+int mm_plugin_major_version = MM_PLUGIN_MAJOR_VERSION;
+int mm_plugin_minor_version = MM_PLUGIN_MINOR_VERSION;
+
+G_MODULE_EXPORT MMPlugin *
+mm_plugin_create (void)
+{
+    return MM_PLUGIN (g_object_new (MM_TYPE_PLUGIN_ANYDATA,
+                                    MM_PLUGIN_BASE_NAME, "AnyData",
+                                    NULL));
+}
+
+/*****************************************************************************/
+
+#define CAP_CDMA (MM_PLUGIN_BASE_PORT_CAP_IS707_A | \
+                  MM_PLUGIN_BASE_PORT_CAP_IS707_P | \
+                  MM_PLUGIN_BASE_PORT_CAP_IS856 | \
+                  MM_PLUGIN_BASE_PORT_CAP_IS856_A)
+
+static guint32
+get_level_for_capabilities (guint32 capabilities)
+{
+    /* Only CDMA for now */
+    if (capabilities & CAP_CDMA)
+        return 10;
+
+    return 0;
+}
+
+static void
+probe_result (MMPluginBase *base,
+              MMPluginBaseSupportsTask *task,
+              guint32 capabilities,
+              gpointer user_data)
+{
+    mm_plugin_base_supports_task_complete (task, get_level_for_capabilities (capabilities));
+}
+
+static MMPluginSupportsResult
+supports_port (MMPluginBase *base,
+               MMModem *existing,
+               MMPluginBaseSupportsTask *task)
+{
+    GUdevDevice *port;
+    guint32 cached = 0, level;
+    const char *subsys, *name;
+    guint16 vendor = 0;
+
+    /* Can't do anything with non-serial ports */
+    port = mm_plugin_base_supports_task_get_port (task);
+    if (strcmp (g_udev_device_get_subsystem (port), "tty"))
+        return MM_PLUGIN_SUPPORTS_PORT_UNSUPPORTED;
+
+    subsys = g_udev_device_get_subsystem (port);
+    name = g_udev_device_get_name (port);
+
+    if (!mm_plugin_base_get_device_ids (base, subsys, name, &vendor, NULL))
+        return MM_PLUGIN_SUPPORTS_PORT_UNSUPPORTED;
+
+    if (vendor != 0x16d5)
+        return MM_PLUGIN_SUPPORTS_PORT_UNSUPPORTED;
+
+    if (mm_plugin_base_get_cached_port_capabilities (base, port, &cached)) {
+        level = get_level_for_capabilities (cached);
+        if (level) {
+            mm_plugin_base_supports_task_complete (task, level);
+            return MM_PLUGIN_SUPPORTS_PORT_IN_PROGRESS;
+        }
+        return MM_PLUGIN_SUPPORTS_PORT_UNSUPPORTED;
+    }
+
+    /* Otherwise kick off a probe */
+    if (mm_plugin_base_probe_port (base, task, NULL))
+        return MM_PLUGIN_SUPPORTS_PORT_IN_PROGRESS;
+
+    return MM_PLUGIN_SUPPORTS_PORT_UNSUPPORTED;
+}
+
+static MMModem *
+grab_port (MMPluginBase *base,
+           MMModem *existing,
+           MMPluginBaseSupportsTask *task,
+           GError **error)
+{
+    GUdevDevice *port = NULL, *physdev = NULL;
+    MMModem *modem = NULL;
+    const char *name, *subsys, *devfile, *sysfs_path;
+    guint32 caps;
+
+    port = mm_plugin_base_supports_task_get_port (task);
+    g_assert (port);
+
+    devfile = g_udev_device_get_device_file (port);
+    if (!devfile) {
+        g_set_error (error, 0, 0, "Could not get port's sysfs file.");
+        return NULL;
+    }
+
+    physdev = mm_plugin_base_supports_task_get_physdev (task);
+    g_assert (physdev);
+    sysfs_path = g_udev_device_get_sysfs_path (physdev);
+    if (!sysfs_path) {
+        g_set_error (error, 0, 0, "Could not get port's physical device sysfs path.");
+        return NULL;
+    }
+
+    subsys = g_udev_device_get_subsystem (port);
+    name = g_udev_device_get_name (port);
+
+    caps = mm_plugin_base_supports_task_get_probed_capabilities (task);
+    if (caps & MM_PLUGIN_BASE_PORT_CAP_GSM) {
+        g_set_error (error, 0, 0, "Only CDMA modems are currently supported by this plugin.");
+        return NULL;
+    }
+
+    if (!existing) {
+        if (caps & CAP_CDMA) {
+            modem = mm_modem_anydata_cdma_new (sysfs_path,
+                                               mm_plugin_base_supports_task_get_driver (task),
+                                               mm_plugin_get_name (MM_PLUGIN (base)),
+                                               !!(caps & MM_PLUGIN_BASE_PORT_CAP_IS856),
+                                               !!(caps & MM_PLUGIN_BASE_PORT_CAP_IS856_A));
+        }
+
+        if (modem) {
+            if (!mm_modem_grab_port (modem, subsys, name, MM_PORT_TYPE_UNKNOWN, NULL, error)) {
+                g_object_unref (modem);
+                return NULL;
+            }
+        }
+    } else {
+        if (caps & CAP_CDMA) {
+            modem = existing;
+            if (!mm_modem_grab_port (modem, subsys, name, MM_PORT_TYPE_UNKNOWN, NULL, error))
+                return NULL;
+        }
+    }
+
+    return modem;
+}
+
+/*****************************************************************************/
+
+static void
+mm_plugin_anydata_init (MMPluginAnydata *self)
+{
+    g_signal_connect (self, "probe-result", G_CALLBACK (probe_result), NULL);
+}
+
+static void
+mm_plugin_anydata_class_init (MMPluginAnydataClass *klass)
+{
+    MMPluginBaseClass *pb_class = MM_PLUGIN_BASE_CLASS (klass);
+
+    pb_class->supports_port = supports_port;
+    pb_class->grab_port = grab_port;
+}
diff --git a/plugins/mm-plugin-anydata.h b/plugins/mm-plugin-anydata.h
new file mode 100644
index 0000000..b71aad3
--- /dev/null
+++ b/plugins/mm-plugin-anydata.h
@@ -0,0 +1,41 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details:
+ *
+ * Copyright (C) 2008 - 2009 Novell, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#ifndef MM_PLUGIN_ANYDATA_H
+#define MM_PLUGIN_ANYDATA_H
+
+#include "mm-plugin-base.h"
+
+#define MM_TYPE_PLUGIN_ANYDATA            (mm_plugin_anydata_get_type ())
+#define MM_PLUGIN_ANYDATA(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MM_TYPE_PLUGIN_ANYDATA, MMPluginAnydata))
+#define MM_PLUGIN_ANYDATA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  MM_TYPE_PLUGIN_ANYDATA, MMPluginAnydataClass))
+#define MM_IS_PLUGIN_ANYDATA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MM_TYPE_PLUGIN_ANYDATA))
+#define MM_IS_PLUGIN_ANYDATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_PLUGIN_ANYDATA))
+#define MM_PLUGIN_ANYDATA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_PLUGIN_ANYDATA, MMPluginAnydataClass))
+
+typedef struct {
+    MMPluginBase parent;
+} MMPluginAnydata;
+
+typedef struct {
+    MMPluginBaseClass parent;
+} MMPluginAnydataClass;
+
+GType mm_plugin_anydata_get_type (void);
+
+G_MODULE_EXPORT MMPlugin *mm_plugin_create (void);
+
+#endif /* MM_PLUGIN_ANYDATA_H */

commit f6a09050af45a0bdbf3ddcd27e8e6197040671f3
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Jan 19 13:46:07 2010 -0800

    cdma: allow plugins to override AT+CSS? during registration checking (rh #547294)
    
    Some modems key the AT+CSS? response off their 1X state, so if the
    modem has EVDO service but no 1X service, AT+CSS? will provide incorrect
    registration state information and the registration checking will
    end too early.  Allow modems that can handle more specific registration
    checking to skip the AT+CSS? part.

diff --git a/plugins/mm-modem-anydata-cdma.c b/plugins/mm-modem-anydata-cdma.c
index 0988f8d..7269c77 100644
--- a/plugins/mm-modem-anydata-cdma.c
+++ b/plugins/mm-modem-anydata-cdma.c
@@ -62,6 +62,7 @@ mm_modem_anydata_cdma_new (const char *device,
                                    MM_MODEM_PLUGIN, plugin,
                                    MM_GENERIC_CDMA_EVDO_REV0, evdo_rev0,
                                    MM_GENERIC_CDMA_EVDO_REVA, evdo_revA,
+                                   MM_GENERIC_CDMA_REGISTRATION_TRY_CSS, FALSE,
                                    NULL));
 }
 
diff --git a/src/mm-generic-cdma.c b/src/mm-generic-cdma.c
index e3c6004..dbaeb66 100644
--- a/src/mm-generic-cdma.c
+++ b/src/mm-generic-cdma.c
@@ -57,6 +57,7 @@ typedef struct {
     gboolean valid;
     gboolean evdo_rev0;
     gboolean evdo_revA;
+    gboolean reg_try_css;
 
     MMModemCdmaRegistrationState cdma_1x_reg_state;
     MMModemCdmaRegistrationState evdo_reg_state;
@@ -75,6 +76,7 @@ enum {
     PROP_0,
     PROP_EVDO_REV0,
     PROP_EVDO_REVA,
+    PROP_REG_TRY_CSS,
     LAST_PROP
 };
 
@@ -1247,6 +1249,26 @@ reg_state_query_done (MMModemCdma *cdma,
 }
 
 static void
+query_subclass_registration_state (MMGenericCdma *self, MMCallbackInfo *info)
+{
+    /* Let subclasses figure out roaming and detailed registration state */
+    if (MM_GENERIC_CDMA_GET_CLASS (self)->query_registration_state) {
+        MM_GENERIC_CDMA_GET_CLASS (self)->query_registration_state (self,
+                                                                    reg_state_query_done,
+                                                                    info);
+    } else {
+        /* Or if the subclass doesn't implement more specific checking,
+         * assume we're registered.
+         */
+        reg_state_query_done (MM_MODEM_CDMA (self),
+                              MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED,
+                              MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED,
+                              NULL,
+                              info);
+    }
+}
+
+static void
 reg_state_css_response (MMModemCdma *cdma,
                         guint32 class,
                         unsigned char band,
@@ -1255,7 +1277,6 @@ reg_state_css_response (MMModemCdma *cdma,
                         gpointer user_data)
 {
     MMCallbackInfo *info = (MMCallbackInfo *) user_data;
-    MMModem *modem = info->modem;
 
     /* We'll get an error if the SID isn't valid, so detect that and
      * report unknown registration state.
@@ -1273,19 +1294,7 @@ reg_state_css_response (MMModemCdma *cdma,
         return;
     }
 
-    /* SID is valid; let subclasses figure out roaming and detailed registration */
-    if (MM_GENERIC_CDMA_GET_CLASS (modem)->query_registration_state) {
-        MM_GENERIC_CDMA_GET_CLASS (modem)->query_registration_state (MM_GENERIC_CDMA (modem),
-                                                                     reg_state_query_done,
-                                                                     info);
-    } else {
-        /* Otherwise, success; we're registered */
-        reg_state_query_done (cdma,
-                              MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED,
-                              MM_MODEM_CDMA_REGISTRATION_STATE_REGISTERED,
-                              NULL,
-                              info);
-    }
+    query_subclass_registration_state (MM_GENERIC_CDMA (info->modem), info);
 }
 
 static void
@@ -1316,12 +1325,28 @@ get_analog_digital_done (MMSerialPort *port,
     }
 
     if (int_cad == 1) {  /* 1 == CDMA service */
+        MMGenericCdmaPrivate *priv = MM_GENERIC_CDMA_GET_PRIVATE (info->modem);
+
         /* Now that we have some sort of service, check if the the device is
          * registered on the network.
          */
-        get_serving_system (MM_MODEM_CDMA (info->modem),
-                            reg_state_css_response,
-                            info);
+
+        /* Some devices key the AT+CSS? response off the 1X state, but if the
+         * device has EVDO service but no 1X service, then reading AT+CSS? will
+         * error out too early.  Let subclasses that know that their AT+CSS?
+         * response is wrong in this case handle more specific registration
+         * themselves; if they do, they'll set priv->reg_try_css to FALSE.
+         */
+        if (priv->reg_try_css) {
+            get_serving_system (MM_MODEM_CDMA (info->modem),
+                                reg_state_css_response,
+                                info);
+        } else {
+            /* Subclass knows that AT+CSS? will respond incorrectly to EVDO
+             * state, so skip AT+CSS? query.
+             */
+            query_subclass_registration_state (MM_GENERIC_CDMA (info->modem), info);
+        }
         return;
     } else {
         /* No service */
@@ -1703,6 +1728,9 @@ set_property (GObject *object, guint prop_id,
     case PROP_EVDO_REVA:
         priv->evdo_revA = g_value_get_boolean (value);
         break;
+    case PROP_REG_TRY_CSS:
+        priv->reg_try_css = g_value_get_boolean (value);
+        break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -1731,6 +1759,9 @@ get_property (GObject *object, guint prop_id,
     case PROP_EVDO_REVA:
         g_value_set_boolean (value, priv->evdo_revA);
         break;
+    case PROP_REG_TRY_CSS:
+        g_value_set_boolean (value, priv->reg_try_css);
+        break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -1788,5 +1819,13 @@ mm_generic_cdma_class_init (MMGenericCdmaClass *klass)
                                   "Supports EVDO revA",
                                   FALSE,
                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+    g_object_class_install_property (object_class, PROP_REG_TRY_CSS,
+            g_param_spec_boolean (MM_GENERIC_CDMA_REGISTRATION_TRY_CSS,
+                                  "RegistrationTryCss",
+                                  "Use Serving System response when checking modem"
+                                  " registration state.",
+                                  TRUE,
+                                  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 }
 
diff --git a/src/mm-generic-cdma.h b/src/mm-generic-cdma.h
index fc042fe..5b4a0b6 100644
--- a/src/mm-generic-cdma.h
+++ b/src/mm-generic-cdma.h
@@ -30,8 +30,10 @@
 #define MM_IS_GENERIC_CDMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  MM_TYPE_GENERIC_CDMA))
 #define MM_GENERIC_CDMA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  MM_TYPE_GENERIC_CDMA, MMGenericCdmaClass))
 
-#define MM_GENERIC_CDMA_EVDO_REV0 "evdo-rev0"
-#define MM_GENERIC_CDMA_EVDO_REVA "evdo-revA"
+#define MM_GENERIC_CDMA_EVDO_REV0            "evdo-rev0"
+#define MM_GENERIC_CDMA_EVDO_REVA            "evdo-revA"
+
+#define MM_GENERIC_CDMA_REGISTRATION_TRY_CSS "registration-try-css"
 
 typedef struct {
     MMModemBase parent;

commit 7fc53d29cce23347b12d9c3be7a753a506a88c11
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Jan 19 13:48:21 2010 -0800

    anydata: remove unused code

diff --git a/plugins/mm-modem-anydata-cdma.c b/plugins/mm-modem-anydata-cdma.c
index 7269c77..311109c 100644
--- a/plugins/mm-modem-anydata-cdma.c
+++ b/plugins/mm-modem-anydata-cdma.c
@@ -31,20 +31,6 @@
 
 G_DEFINE_TYPE (MMModemAnydataCdma, mm_modem_anydata_cdma, MM_TYPE_GENERIC_CDMA)
 
-#define MM_MODEM_ANYDATA_CDMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MM_TYPE_MODEM_ANYDATA_CDMA, MMModemAnydataCdmaPrivate))
-
-typedef enum {
-    SYS_MODE_UNKNOWN,
-    SYS_MODE_NO_SERVICE,
-    SYS_MODE_CDMA_1X,
-    SYS_MODE_EVDO_REV0,
-    SYS_MODE_EVDO_REVA
-} SysMode;
-
-typedef struct {
-    SysMode sys_mode;
-} MMModemAnydataCdmaPrivate;
-
 MMModem *
 mm_modem_anydata_cdma_new (const char *device,
                            const char *driver,
@@ -208,7 +194,6 @@ state_done (MMSerialPort *port,
             gpointer user_data)
 {
     MMCallbackInfo *info = (MMCallbackInfo *) user_data;
-    MMModemAnydataCdmaPrivate *priv;
     MMModemCdmaRegistrationState reg_state = MM_MODEM_CDMA_REGISTRATION_STATE_UNKNOWN;
     const char *reply;
     GRegex *r;
@@ -229,8 +214,6 @@ state_done (MMSerialPort *port,
         return;
     }
 
-    priv = MM_MODEM_ANYDATA_CDMA_GET_PRIVATE (info->modem);
-
     reply = strip_response (response->str, "*STATE:");
 
     /* Format is "<channel>,<pn>,<sid>,<nid>,<state>,<rssi>,..." */
@@ -320,11 +303,9 @@ mm_modem_anydata_cdma_init (MMModemAnydataCdma *self)
 static void
 mm_modem_anydata_cdma_class_init (MMModemAnydataCdmaClass *klass)
 {
-    GObjectClass *object_class = G_OBJECT_CLASS (klass);
     MMGenericCdmaClass *cdma_class = MM_GENERIC_CDMA_CLASS (klass);
 
     mm_modem_anydata_cdma_parent_class = g_type_class_peek_parent (klass);
-    g_type_class_add_private (object_class, sizeof (MMModemAnydataCdmaPrivate));
 
     cdma_class->query_registration_state = query_registration_state;
 

commit e4439d399a055055b01306457b4541103d5c9b92
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Jan 19 13:56:07 2010 -0800

    anydata: capture some unsolicited messages

diff --git a/plugins/mm-modem-anydata-cdma.c b/plugins/mm-modem-anydata-cdma.c
index 311109c..905890f 100644
--- a/plugins/mm-modem-anydata-cdma.c
+++ b/plugins/mm-modem-anydata-cdma.c
@@ -29,7 +29,10 @@
 #include "mm-serial-port.h"
 #include "mm-serial-parsers.h"
 
-G_DEFINE_TYPE (MMModemAnydataCdma, mm_modem_anydata_cdma, MM_TYPE_GENERIC_CDMA)
+static void modem_init (MMModem *modem_class);
+
+G_DEFINE_TYPE_EXTENDED (MMModemAnydataCdma, mm_modem_anydata_cdma, MM_TYPE_GENERIC_CDMA, 0,
+                        G_IMPLEMENT_INTERFACE (MM_TYPE_MODEM, modem_init))
 
 MMModem *
 mm_modem_anydata_cdma_new (const char *device,
@@ -295,6 +298,69 @@ query_registration_state (MMGenericCdma *cdma,
 
 /*****************************************************************************/
 
+static gboolean
+grab_port (MMModem *modem,
+           const char *subsys,
+           const char *name,
+           MMPortType suggested_type,
+           gpointer user_data,
+           GError **error)
+{
+    MMPort *port = NULL;
+    GRegex *regex;
+
+    port = mm_generic_cdma_grab_port (MM_GENERIC_CDMA (modem), subsys, name, suggested_type, user_data, error);
+    if (port && MM_IS_SERIAL_PORT (port)) {
+        /* Data state notifications */
+
+        /* Data call has connected */
+        regex = g_regex_new ("\\r\\n\\*ACTIVE:(.*)\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+
+        /* Data call disconnected */
+        regex = g_regex_new ("\\r\\n\\*INACTIVE:(.*)\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+
+        /* Modem is now dormant */
+        regex = g_regex_new ("\\r\\n\\*DORMANT:(.*)\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+
+        /* Abnomral state notifications
+         *
+         * FIXME: set 1X/EVDO registration state to UNKNOWN when these
+         * notifications are received?
+         */
+
+        /* Network acquisition fail */
+        regex = g_regex_new ("\\r\\n\\*OFFLINE:(.*)\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+
+        /* Registration fail */
+        regex = g_regex_new ("\\r\\n\\*REGREQ:(.*)\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+
+        /* Authentication fail */
+        regex = g_regex_new ("\\r\\n\\*AUTHREQ:(.*)\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+    }
+
+    return !!port;
+}
+
+/*****************************************************************************/
+
+static void
+modem_init (MMModem *modem_class)
+{
+    modem_class->grab_port = grab_port;
+}
+
 static void
 mm_modem_anydata_cdma_init (MMModemAnydataCdma *self)
 {

commit e98401440475a1a82486fcb9ce4d02f092e627c5
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Jan 19 13:56:53 2010 -0800

    anydata: whitespace cleanup

diff --git a/plugins/mm-modem-anydata-cdma.c b/plugins/mm-modem-anydata-cdma.c
index 905890f..f6528ec 100644
--- a/plugins/mm-modem-anydata-cdma.c
+++ b/plugins/mm-modem-anydata-cdma.c
@@ -161,8 +161,8 @@ evdo_state_done (MMSerialPort *port,
         int_from_match_item (match_info, 6, &dbm);
 
         /* Parse the EVDO radio state */
-    	if (uint_from_match_item (match_info, 1, &val)) {
-    	    switch (val) {
+        if (uint_from_match_item (match_info, 1, &val)) {
+            switch (val) {
             case 3:  /* IDLE */
                 /* If IDLE and the EVDO dBm is -105 or lower, assume no service.
                  * It may be that IDLE actually means NO SERVICE too; not sure.
@@ -177,12 +177,12 @@ evdo_state_done (MMSerialPort *port,
             default:
                 g_message ("ANYDATA: unknown *STATE (%d); assuming no service.", val);
                 /* fall through */
-    	    case 0:  /* NO SERVICE */
-    	    case 1:  /* ACQUISITION */
-    	    case 2:  /* SYNC */
+            case 0:  /* NO SERVICE */
+            case 1:  /* ACQUISITION */
+            case 2:  /* SYNC */
                 break;
-    	    }
-    	}
+            }
+        }
     }
 
     mm_generic_cdma_query_reg_state_set_callback_evdo_state (info, reg_state);
@@ -239,8 +239,8 @@ state_done (MMSerialPort *port,
         int_from_match_item (match_info, 6, &dbm);
 
         /* Parse the 1x radio state */
-    	if (uint_from_match_item (match_info, 5, &val)) {
-    	    switch (val) {
+        if (uint_from_match_item (match_info, 5, &val)) {
+            switch (val) {
             case 1:  /* IDLE */
                 /* If IDLE and the 1X dBm is -105 or lower, assume no service.
                  * It may be that IDLE actually means NO SERVICE too; not sure.
@@ -256,10 +256,10 @@ state_done (MMSerialPort *port,
             default:
                 g_message ("ANYDATA: unknown *STATE (%d); assuming no service.", val);
                 /* fall through */
-    	    case 0:  /* NO SERVICE */
+            case 0:  /* NO SERVICE */
                 break;
-    	    }
-    	}
+            }
+        }
     }
 
     mm_generic_cdma_query_reg_state_set_callback_1x_state (info, reg_state);

commit ed885b7595294115b5cde8755c754515294f27cc
Merge: a919c83 e984014
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Jan 19 15:07:03 2010 -0800

    Merge commit 'origin/anydata'

commit 053db1d27ca5147e7d434ce660fa26ef83d3ed11
Author: Dan Williams <dcbw@redhat.com>
Date:   Fri Jan 22 14:11:24 2010 -0800

    misc: fix FSF address in license headers

diff --git a/plugins/mm-modem-mbm.c b/plugins/mm-modem-mbm.c
index 686b35c..4e08c68 100644
--- a/plugins/mm-modem-mbm.c
+++ b/plugins/mm-modem-mbm.c
@@ -17,10 +17,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include <stdlib.h>
diff --git a/plugins/mm-modem-mbm.h b/plugins/mm-modem-mbm.h
index 8756e47..db0f627 100644
--- a/plugins/mm-modem-mbm.h
+++ b/plugins/mm-modem-mbm.h
@@ -17,10 +17,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #ifndef MM_MODEM_MBM_H
diff --git a/plugins/mm-plugin-mbm.c b/plugins/mm-plugin-mbm.c
index a380f98..a80bd91 100644
--- a/plugins/mm-plugin-mbm.c
+++ b/plugins/mm-plugin-mbm.c
@@ -14,10 +14,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include <string.h>
diff --git a/plugins/mm-plugin-mbm.h b/plugins/mm-plugin-mbm.h
index c0e73b5..c478f11 100644
--- a/plugins/mm-plugin-mbm.h
+++ b/plugins/mm-plugin-mbm.h
@@ -14,10 +14,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #ifndef MM_PLUGIN_MBM_H

commit 22f6ab4dc604eba85271a10cdb5a1b987db6490f
Author: Michael Biebl <biebl@debian.org>
Date:   Wed Jan 27 15:48:10 2010 -0800

    build: use separate directory for m4 macros

diff --git a/Makefile.am b/Makefile.am
index eee0847..915f82e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -47,3 +47,5 @@ EXTRA_DIST = \
 	doc-generator.xsl \
 	$(dbusservice_DATA) \
 	$(dbusactivation_in_files)
+
+ACLOCAL_AMFLAGS = -I m4
diff --git a/configure.ac b/configure.ac
index aae718e..ab2886a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4,6 +4,8 @@ AC_INIT(ModemManager, 0.3, dcbw@redhat.com, ModemManager)
 AM_INIT_AUTOMAKE([1.9 subdir-objects tar-ustar no-dist-gzip dist-bzip2])
 AM_MAINTAINER_MODE
 
+AC_CONFIG_MACRO_DIR([m4])
+
 AC_CONFIG_HEADERS(config.h)
 
 dnl Required programs

commit 22e687833cda89855e6dba9b3771ab403771738d
Author: Michael Biebl <biebl@debian.org>
Date:   Wed Jan 27 15:48:55 2010 -0800

    build: unify compiler warnings

diff --git a/configure.ac b/configure.ac
index ab2886a..0e37ddd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -60,35 +60,6 @@ else
 fi
 AC_SUBST(PPPD_PLUGIN_DIR)
 
-AC_ARG_ENABLE(more-warnings,
-AS_HELP_STRING([--enable-more-warnings], [Maximum compiler warnings]), set_more_warnings="$enableval",set_more_warnings=yes)
-AC_MSG_CHECKING(for more warnings, including -Werror)
-if test "$GCC" = "yes" -a "$set_more_warnings" != "no"; then
-	AC_MSG_RESULT(yes)
-	CFLAGS="-Wall -Werror -std=gnu89 $CFLAGS"
-
-	for option in -Wshadow -Wmissing-declarations -Wmissing-prototypes \
-		      -Wdeclaration-after-statement -Wstrict-prototypes \
-		      -Wfloat-equal -Wno-unused-parameter -Wno-sign-compare \
-		      -fno-strict-aliasing; do
-		SAVE_CFLAGS="$CFLAGS"
-		CFLAGS="$CFLAGS $option"
-		AC_MSG_CHECKING([whether gcc understands $option])
-		AC_TRY_COMPILE([], [],
-			has_option=yes,
-			has_option=no)
-		if test $has_option = no; then
-			CFLAGS="$SAVE_CFLAGS"
-		fi
-		AC_MSG_RESULT($has_option)
-		unset has_option
-		unset SAVE_CFLAGS
-	done
-	unset option
-else
-	AC_MSG_RESULT(no)
-fi
-
 AC_ARG_WITH(docs, AC_HELP_STRING([--with-docs], [Build ModemManager documentation]))
 AM_CONDITIONAL(WITH_DOCS, test "x$with_docs" = "xyes")
 case $with_docs in
@@ -112,6 +83,8 @@ case $with_tests in
         ;;
 esac
 
+NM_COMPILER_WARNINGS
+
 AC_CONFIG_FILES([
 Makefile
 marshallers/Makefile
diff --git a/m4/compiler_warnings.m4 b/m4/compiler_warnings.m4
new file mode 100644
index 0000000..6cea2f7
--- /dev/null
+++ b/m4/compiler_warnings.m4
@@ -0,0 +1,31 @@
+AC_DEFUN([NM_COMPILER_WARNINGS],
+[AC_ARG_ENABLE(more-warnings,
+	AS_HELP_STRING([--enable-more-warnings], [Maximum compiler warnings]),
+	set_more_warnings="$enableval",set_more_warnings=yes)
+AC_MSG_CHECKING(for more warnings, including -Werror)
+if test "$GCC" = "yes" -a "$set_more_warnings" != "no"; then
+	AC_MSG_RESULT(yes)
+	CFLAGS="-Wall -Werror -std=gnu89 $CFLAGS"
+
+	for option in -Wshadow -Wmissing-declarations -Wmissing-prototypes \
+		      -Wdeclaration-after-statement -Wstrict-prototypes \
+		      -Wfloat-equal -Wno-unused-parameter -Wno-sign-compare \
+		      -fno-strict-aliasing; do
+		SAVE_CFLAGS="$CFLAGS"
+		CFLAGS="$CFLAGS $option"
+		AC_MSG_CHECKING([whether gcc understands $option])
+		AC_TRY_COMPILE([], [],
+			has_option=yes,
+			has_option=no,)
+		if test $has_option = no; then
+			CFLAGS="$SAVE_CFLAGS"
+		fi
+		AC_MSG_RESULT($has_option)
+		unset has_option
+		unset SAVE_CFLAGS
+	done
+	unset option
+else
+	AC_MSG_RESULT(no)
+fi
+])

commit 3d0f2ecf126734e96ad1f18d7e069ded3711b9f8
Author: Norbert Frese <nf2.email@gmail.com>
Date:   Sun Jan 31 11:06:55 2010 -0800

    core: add an UnlockRequired property that provides lock status (bgo #604551)
    
    Clients can check the property to determine lock/unlock status and thus
    unlock the modem before trying to connect if required.
    
    Bits of the patch by dcbw (see the bug).

diff --git a/introspection/mm-modem.xml b/introspection/mm-modem.xml
index 7896fff..da7635b 100644
--- a/introspection/mm-modem.xml
+++ b/introspection/mm-modem.xml
@@ -113,6 +113,18 @@
       </tp:docstring>
     </property>
 
+    <property name="UnlockRequired" type="s" access="read">
+      <tp:docstring>
+        Empty if the device is usable without an unlock code or has already
+        been unlocked. If the device needs to be unlocked before becoming usable this
+        property contains the specific unlock code required.  Valid unlock code values
+        are "" (blank), "sim-pin", "sim-puk", "ph-sim-pin", "ph-fsim-pin",
+        "ph-fsim-puk", "sim-pin2", "sim-puk2", "ph-net-pin", "ph-net-puk",
+        "ph-netsub-pin", "ph-netsub-puk", "ph-sp-pin", "ph-sp-puk", "ph-corp-pin", and
+        "ph-corp-puk".
+      </tp:docstring>
+    </property>
+
     <property name="IpMethod" type="u" access="read" tp:type="MM_MODEM_IP_METHOD">
       <tp:docstring>
         The IP configuration method.
diff --git a/src/mm-modem-base.c b/src/mm-modem-base.c
index 3d82f8e..af4f832 100644
--- a/src/mm-modem-base.c
+++ b/src/mm-modem-base.c
@@ -39,6 +39,7 @@ typedef struct {
     char *driver;
     char *plugin;
     char *device;
+    char *unlock_required;
     guint32 ip_method;
     gboolean valid;
     MMModemState state;
@@ -169,6 +170,26 @@ mm_modem_base_get_valid (MMModemBase *self)
     return MM_MODEM_BASE_GET_PRIVATE (self)->valid;
 }
 
+void mm_modem_base_set_unlock_required (MMModemBase *self, const char *unlock_required)
+{
+   MMModemBasePrivate *priv;
+
+   g_return_if_fail (self != NULL);
+   g_return_if_fail (MM_IS_MODEM_BASE (self));
+
+   priv = MM_MODEM_BASE_GET_PRIVATE (self);
+
+   /* Only do something if the value changes */
+   if (priv->unlock_required == unlock_required
+      || (priv->unlock_required && unlock_required
+      && !strcmp(priv->unlock_required, unlock_required)))
+      return;
+
+   g_free (priv->unlock_required);
+   priv->unlock_required = g_strdup (unlock_required);
+   g_object_notify (G_OBJECT (self), MM_MODEM_UNLOCK_REQUIRED);
+}
+
 /*****************************************************************************/
 
 static void
@@ -227,6 +248,7 @@ set_property (GObject *object, guint prop_id,
     case MM_MODEM_PROP_VALID:
     case MM_MODEM_PROP_TYPE:
     case MM_MODEM_PROP_ENABLED:
+    case MM_MODEM_PROP_UNLOCK_REQUIRED:
         break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -268,6 +290,9 @@ get_property (GObject *object, guint prop_id,
     case MM_MODEM_PROP_ENABLED:
         g_value_set_boolean (value, is_enabled (priv->state));
         break;
+    case MM_MODEM_PROP_UNLOCK_REQUIRED:
+        g_value_set_string (value, priv->unlock_required);
+        break;
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -284,6 +309,7 @@ finalize (GObject *object)
     g_free (priv->driver);
     g_free (priv->plugin);
     g_free (priv->device);
+    g_free (priv->unlock_required);
 
     G_OBJECT_CLASS (mm_modem_base_parent_class)->finalize (object);
 }
@@ -336,6 +362,10 @@ mm_modem_base_class_init (MMModemBaseClass *klass)
                                       MM_MODEM_PROP_ENABLED,
                                       MM_MODEM_ENABLED);
 
+    g_object_class_override_property (object_class,
+                                      MM_MODEM_PROP_UNLOCK_REQUIRED,
+                                      MM_MODEM_UNLOCK_REQUIRED);
+
     mm_properties_changed_signal_new (object_class);
 }
 
diff --git a/src/mm-modem-base.h b/src/mm-modem-base.h
index 9eb64ce..9078f3f 100644
--- a/src/mm-modem-base.h
+++ b/src/mm-modem-base.h
@@ -60,5 +60,8 @@ void mm_modem_base_set_valid (MMModemBase *self,
 
 gboolean mm_modem_base_get_valid (MMModemBase *self);
 
+void mm_modem_base_set_unlock_required (MMModemBase *self,
+                                        const char *unlock_required);
+
 #endif /* MM_MODEM_BASE_H */
 
diff --git a/src/mm-modem.c b/src/mm-modem.c
index a65d883..5bb2ef6 100644
--- a/src/mm-modem.c
+++ b/src/mm-modem.c
@@ -694,6 +694,15 @@ mm_modem_init (gpointer g_iface)
                                FALSE,
                                G_PARAM_READABLE));
 
+    g_object_interface_install_property
+        (g_iface,
+         g_param_spec_string (MM_MODEM_UNLOCK_REQUIRED,
+                               "UnlockRequired",
+                               "Whether or not the modem requires an unlock "
+                               "code to become usable, and if so, which unlock code is required",
+                               NULL,
+                               G_PARAM_READABLE));
+
     /* Signals */
     g_signal_new ("state-changed",
                   iface_type,
diff --git a/src/mm-modem.h b/src/mm-modem.h
index e8dd7ea..ead2cca 100644
--- a/src/mm-modem.h
+++ b/src/mm-modem.h
@@ -55,6 +55,7 @@ typedef enum {
 #define MM_MODEM_TYPE          "type"
 #define MM_MODEM_IP_METHOD     "ip-method"
 #define MM_MODEM_ENABLED       "enabled"
+#define MM_MODEM_UNLOCK_REQUIRED  "unlock-required"
 #define MM_MODEM_VALID         "valid"      /* not exported */
 #define MM_MODEM_PLUGIN        "plugin"     /* not exported */
 #define MM_MODEM_STATE         "state"      /* not exported */
@@ -78,7 +79,8 @@ typedef enum {
     MM_MODEM_PROP_VALID,       /* Not exported */
     MM_MODEM_PROP_PLUGIN,      /* Not exported */
     MM_MODEM_PROP_STATE,       /* Not exported */
-    MM_MODEM_PROP_ENABLED
+    MM_MODEM_PROP_ENABLED,
+    MM_MODEM_PROP_UNLOCK_REQUIRED
 } MMModemProp;
 
 typedef struct _MMModem MMModem;

commit 1561436788fc26b82f803ca818ec025253ca9d63
Author: Norbert Frese <nf2.email@gmail.com>
Date:   Sun Jan 31 11:43:52 2010 -0800

    core: check modem PIN state before exporting it (bgo #604551)
    
    And set UnlockRequired accordingly.  Large cleanups and rework by
    dcbw.

diff --git a/src/mm-generic-gsm.c b/src/mm-generic-gsm.c
index 4954ca1..d87f5a8 100644
--- a/src/mm-generic-gsm.c
+++ b/src/mm-generic-gsm.c
@@ -50,6 +50,7 @@ typedef struct {
     char *device;
 
     gboolean valid;
+    gboolean pin_checked;
 
     char *oper_code;
     char *oper_name;
@@ -167,6 +168,7 @@ mm_generic_gsm_set_reg_status (MMGenericGsm *modem,
 
 typedef struct {
     const char *result;
+    const char *normalized;
     guint code;
 } CPinResult;
 
@@ -179,22 +181,22 @@ pin_check_done (MMSerialPort *port,
     MMCallbackInfo *info = (MMCallbackInfo *) user_data;
     gboolean parsed = FALSE;
     static CPinResult results[] = {
-        { "SIM PIN", MM_MOBILE_ERROR_SIM_PIN },
-        { "SIM PUK", MM_MOBILE_ERROR_SIM_PUK },
-        { "PH-SIM PIN", MM_MOBILE_ERROR_PH_SIM_PIN },
-        { "PH-FSIM PIN", MM_MOBILE_ERROR_PH_FSIM_PIN },
-        { "PH-FSIM PUK", MM_MOBILE_ERROR_PH_FSIM_PUK },
-        { "SIM PIN2", MM_MOBILE_ERROR_SIM_PIN2 },
-        { "SIM PUK2", MM_MOBILE_ERROR_SIM_PUK2 },
-        { "PH-NET PIN", MM_MOBILE_ERROR_NETWORK_PIN },
-        { "PH-NET PUK", MM_MOBILE_ERROR_NETWORK_PUK },
-        { "PH-NETSUB PIN", MM_MOBILE_ERROR_NETWORK_SUBSET_PIN },
-        { "PH-NETSUB PUK", MM_MOBILE_ERROR_NETWORK_SUBSET_PUK },
-        { "PH-SP PIN", MM_MOBILE_ERROR_SERVICE_PIN },
-        { "PH-SP PUK", MM_MOBILE_ERROR_SERVICE_PUK },
-        { "PH-CORP PIN", MM_MOBILE_ERROR_CORP_PIN },
-        { "PH-CORP PUK", MM_MOBILE_ERROR_CORP_PUK },
-        { NULL, MM_MOBILE_ERROR_PHONE_FAILURE },
+        { "SIM PIN",       "sim-pin",       MM_MOBILE_ERROR_SIM_PIN },
+        { "SIM PUK",       "sim-puk",       MM_MOBILE_ERROR_SIM_PUK },
+        { "PH-SIM PIN",    "ph-sim-pin",    MM_MOBILE_ERROR_PH_SIM_PIN },
+        { "PH-FSIM PIN",   "ph-fsim-pin",   MM_MOBILE_ERROR_PH_FSIM_PIN },
+        { "PH-FSIM PUK",   "ph-fsim-puk",   MM_MOBILE_ERROR_PH_FSIM_PUK },
+        { "SIM PIN2",      "sim-pin2",      MM_MOBILE_ERROR_SIM_PIN2 },
+        { "SIM PUK2",      "sim-puk2",      MM_MOBILE_ERROR_SIM_PUK2 },
+        { "PH-NET PIN",    "ph-net-pin",    MM_MOBILE_ERROR_NETWORK_PIN },
+        { "PH-NET PUK",    "ph-net-puk",    MM_MOBILE_ERROR_NETWORK_PUK },
+        { "PH-NETSUB PIN", "ph-netsub-pin", MM_MOBILE_ERROR_NETWORK_SUBSET_PIN },
+        { "PH-NETSUB PUK", "ph-netsub-puk", MM_MOBILE_ERROR_NETWORK_SUBSET_PUK },
+        { "PH-SP PIN",     "ph-sp-pin",     MM_MOBILE_ERROR_SERVICE_PIN },
+        { "PH-SP PUK",     "ph-sp-puk",     MM_MOBILE_ERROR_SERVICE_PUK },
+        { "PH-CORP PIN",   "ph-corp-pin",   MM_MOBILE_ERROR_CORP_PIN },
+        { "PH-CORP PUK",   "ph-corp-puk",   MM_MOBILE_ERROR_CORP_PUK },
+        { NULL,            NULL,            MM_MOBILE_ERROR_PHONE_FAILURE },
     };
 
     if (error)
@@ -202,15 +204,17 @@ pin_check_done (MMSerialPort *port,
     else if (g_str_has_prefix (response->str, "+CPIN: ")) {
         const char *str = response->str + 7;
 
-        if (g_str_has_prefix (str, "READY"))
+        if (g_str_has_prefix (str, "READY")) {
+            mm_modem_base_set_unlock_required (MM_MODEM_BASE (info->modem), NULL);
             parsed = TRUE;
-        else {
+        } else {
             CPinResult *iter = &results[0];
 
             /* Translate the error */
             while (iter->result) {
                 if (g_str_has_prefix (str, iter->result)) {
                     info->error = mm_mobile_error_for_code (iter->code);
+                    mm_modem_base_set_unlock_required (MM_MODEM_BASE (info->modem), iter->normalized);
                     parsed = TRUE;
                     break;
                 }
@@ -219,11 +223,16 @@ pin_check_done (MMSerialPort *port,
         }
     }
 
-    if (!info->error && !parsed) {
-        info->error = g_error_new (MM_MODEM_ERROR,
-                                   MM_MODEM_ERROR_GENERAL,
-                                   "Could not parse PIN request response '%s'",
-                                   response->str);
+    if (!parsed) {
+        /* Assume unlocked if we don't recognize the pin request result */
+        mm_modem_base_set_unlock_required (MM_MODEM_BASE (info->modem), NULL);
+
+        if (!info->error) {
+            info->error = g_error_new (MM_MODEM_ERROR,
+                                       MM_MODEM_ERROR_GENERAL,
+                                       "Could not parse PIN request response '%s'",
+                                       response->str);
+        }
     }
 
     mm_callback_info_schedule (info);
@@ -282,12 +291,59 @@ check_valid (MMGenericGsm *self)
     MMGenericGsmPrivate *priv = MM_GENERIC_GSM_GET_PRIVATE (self);
     gboolean new_valid = FALSE;
 
-    if (priv->primary && priv->data)
+    if (priv->primary && priv->data && priv->pin_checked)
         new_valid = TRUE;
 
     mm_modem_base_set_valid (MM_MODEM_BASE (self), new_valid);
 }
 
+static void
+initial_pin_check_done (MMModem *modem, GError *error, gpointer user_data)
+{
+    MMGenericGsmPrivate *priv;
+    gboolean close_port = !!user_data;
+
+    /* modem could have been removed before we get here, in which case
+     * 'modem' will be NULL.
+     */
+    if (modem) {
+        g_return_if_fail (MM_IS_GENERIC_GSM (modem));
+        priv = MM_GENERIC_GSM_GET_PRIVATE (modem);
+
+        priv->pin_checked = TRUE;
+        if (close_port)
+            mm_serial_port_close (priv->primary);
+        check_valid (MM_GENERIC_GSM (modem));
+    }
+}
+
+static void
+initial_pin_check (MMGenericGsm *self)
+{
+    GError *error = NULL;
+    MMGenericGsmPrivate *priv;
+
+    g_return_if_fail (MM_IS_GENERIC_GSM (self));
+    priv = MM_GENERIC_GSM_GET_PRIVATE (self);
+
+    g_return_if_fail (priv->primary != NULL);
+
+    if (mm_serial_port_open (priv->primary, &error))
+        mm_generic_gsm_check_pin (self, initial_pin_check_done, GUINT_TO_POINTER (TRUE));
+    else {
+        g_warning ("%s: failed to open serial port: (%d) %s",
+                   __func__,
+                   error ? error->code : -1,
+                   error && error->message ? error->message : "(unknown)");
+        g_clear_error (&error);
+
+        /* Ensure the modem is still somewhat usable if opening the serial
+         * port fails for some reason.
+         */
+        initial_pin_check_done (MM_MODEM (self), NULL, GUINT_TO_POINTER (FALSE));
+    }
+}
+
 static gboolean
 owns_port (MMModem *modem, const char *subsys, const char *name)
 {
@@ -324,7 +380,10 @@ mm_generic_gsm_grab_port (MMGenericGsm *self,
                 priv->data = port;
                 g_object_notify (G_OBJECT (self), MM_MODEM_DATA_DEVICE);
             }
-            check_valid (self);
+
+            /* Get modem's initial lock/unlock state */
+            initial_pin_check (self);
+
         } else if (ptype == MM_PORT_TYPE_SECONDARY)
             priv->secondary = MM_SERIAL_PORT (port);
     } else {

commit 42a20ab1872ad8b570ddf97a920d83bc63defd9e
Author: Dan Williams <dcbw@redhat.com>
Date:   Sun Jan 31 11:57:05 2010 -0800

    core: whitespace fixup

diff --git a/src/mm-modem-base.c b/src/mm-modem-base.c
index af4f832..44f4b0e 100644
--- a/src/mm-modem-base.c
+++ b/src/mm-modem-base.c
@@ -172,22 +172,23 @@ mm_modem_base_get_valid (MMModemBase *self)
 
 void mm_modem_base_set_unlock_required (MMModemBase *self, const char *unlock_required)
 {
-   MMModemBasePrivate *priv;
+    MMModemBasePrivate *priv;
 
-   g_return_if_fail (self != NULL);
-   g_return_if_fail (MM_IS_MODEM_BASE (self));
+    g_return_if_fail (self != NULL);
+    g_return_if_fail (MM_IS_MODEM_BASE (self));
 
-   priv = MM_MODEM_BASE_GET_PRIVATE (self);
+    priv = MM_MODEM_BASE_GET_PRIVATE (self);
 
-   /* Only do something if the value changes */
-   if (priv->unlock_required == unlock_required
-      || (priv->unlock_required && unlock_required
-      && !strcmp(priv->unlock_required, unlock_required)))
-      return;
+    /* Only do something if the value changes */
+    if (  (priv->unlock_required == unlock_required)
+       || (   priv->unlock_required
+           && unlock_required
+           && !strcmp (priv->unlock_required, unlock_required)))
+       return;
 
-   g_free (priv->unlock_required);
-   priv->unlock_required = g_strdup (unlock_required);
-   g_object_notify (G_OBJECT (self), MM_MODEM_UNLOCK_REQUIRED);
+    g_free (priv->unlock_required);
+    priv->unlock_required = g_strdup (unlock_required);
+    g_object_notify (G_OBJECT (self), MM_MODEM_UNLOCK_REQUIRED);
 }
 
 /*****************************************************************************/

commit 765920803744c6b1326ed44894f73cb9b7481e38
Author: Dan Williams <dcbw@redhat.com>
Date:   Sun Jan 31 12:00:26 2010 -0800

    core: log when unlock state changes

diff --git a/src/mm-modem-base.c b/src/mm-modem-base.c
index 44f4b0e..6e9ee75 100644
--- a/src/mm-modem-base.c
+++ b/src/mm-modem-base.c
@@ -173,6 +173,7 @@ mm_modem_base_get_valid (MMModemBase *self)
 void mm_modem_base_set_unlock_required (MMModemBase *self, const char *unlock_required)
 {
     MMModemBasePrivate *priv;
+    const char *dbus_path;
 
     g_return_if_fail (self != NULL);
     g_return_if_fail (MM_IS_MODEM_BASE (self));
@@ -188,6 +189,15 @@ void mm_modem_base_set_unlock_required (MMModemBase *self, const char *unlock_re
 
     g_free (priv->unlock_required);
     priv->unlock_required = g_strdup (unlock_required);
+
+    dbus_path = (const char *) g_object_get_data (G_OBJECT (self), DBUS_PATH_TAG);
+    if (dbus_path) {
+        if (priv->unlock_required)
+            g_message ("Modem %s: unlock required (%s)", dbus_path, priv->unlock_required);
+        else
+            g_message ("Modem %s: unlock no longer required", dbus_path);
+    }
+
     g_object_notify (G_OBJECT (self), MM_MODEM_UNLOCK_REQUIRED);
 }
 

commit ba9634ae4fe0a3685cb9ccbc1d68fd05e0ebc1ac
Author: Dan Williams <dcbw@redhat.com>
Date:   Sun Jan 31 12:04:53 2010 -0800

    serial: add mm_serial_port_is_open()

diff --git a/src/mm-serial-port.c b/src/mm-serial-port.c
index 2600ae5..07010e1 100644
--- a/src/mm-serial-port.c
+++ b/src/mm-serial-port.c
@@ -852,6 +852,15 @@ mm_serial_port_open (MMSerialPort *self, GError **error)
     return TRUE;
 }
 
+gboolean
+mm_serial_port_is_open (MMSerialPort *self)
+{
+    g_return_val_if_fail (self != NULL, FALSE);
+    g_return_val_if_fail (MM_IS_SERIAL_PORT (self), FALSE);
+
+    return (MM_SERIAL_PORT_GET_PRIVATE (self)->fd >= 0);
+}
+
 void
 mm_serial_port_close (MMSerialPort *self)
 {
diff --git a/src/mm-serial-port.h b/src/mm-serial-port.h
index 841b4fa..a2697f3 100644
--- a/src/mm-serial-port.h
+++ b/src/mm-serial-port.h
@@ -79,6 +79,8 @@ void     mm_serial_port_set_response_parser (MMSerialPort *self,
                                              gpointer user_data,
                                              GDestroyNotify notify);
 
+gboolean mm_serial_port_is_open           (MMSerialPort *self);
+
 gboolean mm_serial_port_open              (MMSerialPort *self,
                                            GError  **error);
 

commit 27d1c8f936379ec88a0098388067d02571a6974d
Author: Dan Williams <dcbw@redhat.com>
Date:   Sun Jan 31 21:52:29 2010 -0800

    errors: rework error conversion
    
    Use the same error structure for parsing numeric and string-based errors.

diff --git a/src/mm-errors.c b/src/mm-errors.c
index 34f56c1..16b591c 100644
--- a/src/mm-errors.c
+++ b/src/mm-errors.c
@@ -16,6 +16,9 @@
 
 #include "mm-errors.h"
 
+#include <string.h>
+#include <ctype.h>
+
 #define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
 
 GQuark
@@ -222,69 +225,127 @@ mm_mobile_error_get_type (void)
     return etype;
 }
 
+typedef struct {
+    int code;
+    const char *error;  /* lowercase, and stripped of special chars and whitespace */
+    const char *message;
+} ErrorTable;
+
+static ErrorTable errors[] = {
+    { MM_MOBILE_ERROR_PHONE_FAILURE,             "phonefailure",                              "Phone failure" },
+    { MM_MOBILE_ERROR_NO_CONNECTION,             "noconnectiontophone",                       "No connection to phone" },
+    { MM_MOBILE_ERROR_LINK_RESERVED,             "phoneadapterlinkreserved",                  "Phone-adaptor link reserved" },
+    { MM_MOBILE_ERROR_NOT_ALLOWED,               "operationnotallowed",                       "Operation not allowed" },
+    { MM_MOBILE_ERROR_NOT_SUPPORTED,             "operationnotsupported",                     "Operation not supported" },
+    { MM_MOBILE_ERROR_PH_SIM_PIN,                "phsimpinrequired",                          "PH-SIM PIN required" },
+    { MM_MOBILE_ERROR_PH_FSIM_PIN,               "phfsimpinrequired",                         "PH-FSIM PIN required" },
+    { MM_MOBILE_ERROR_PH_FSIM_PUK,               "phfsimpukrequired",                         "PH-FSIM PUK required" },
+    { MM_MOBILE_ERROR_SIM_NOT_INSERTED,          "simnotinserted",                            "SIM not inserted" },
+    { MM_MOBILE_ERROR_SIM_PIN,                   "simpinrequired",                            "SIM PIN required" },
+    { MM_MOBILE_ERROR_SIM_PUK,                   "simpukrequired",                            "SIM PUK required" },
+    { MM_MOBILE_ERROR_SIM_FAILURE,               "simfailure",                                "SIM failure" },
+    { MM_MOBILE_ERROR_SIM_BUSY,                  "simbusy",                                   "SIM busy" },
+    { MM_MOBILE_ERROR_SIM_WRONG,                 "simwrong",                                  "SIM wrong" },
+    { MM_MOBILE_ERROR_WRONG_PASSWORD,            "incorrectpassword",                         "Incorrect password" },
+    { MM_MOBILE_ERROR_SIM_PIN2,                  "simpin2required",                           "SIM PIN2 required" },
+    { MM_MOBILE_ERROR_SIM_PUK2,                  "simpuk2required",                           "SIM PUK2 required" },
+    { MM_MOBILE_ERROR_MEMORY_FULL,               "memoryfull",                                "Memory full" },
+    { MM_MOBILE_ERROR_INVALID_INDEX,             "invalidindex",                              "Invalid index" },
+    { MM_MOBILE_ERROR_NOT_FOUND,                 "notfound",                                  "Not found" },
+    { MM_MOBILE_ERROR_MEMORY_FAILURE,            "memoryfailure",                             "Memory failure" },
+    { MM_MOBILE_ERROR_TEXT_TOO_LONG,             "textstringtoolong",                         "Text string too long" },
+    { MM_MOBILE_ERROR_INVALID_CHARS,             "invalidcharactersintextstring",             "Invalid characters in text string" },
+    { MM_MOBILE_ERROR_DIAL_STRING_TOO_LONG,      "dialstringtoolong",                         "Dial string too long" },
+    { MM_MOBILE_ERROR_DIAL_STRING_INVALID,       "invalidcharactersindialstring",             "Invalid characters in dial string" },
+    { MM_MOBILE_ERROR_NO_NETWORK,                "nonetworkservice",                          "No network service" },
+    { MM_MOBILE_ERROR_NETWORK_TIMEOUT,           "networktimeout",                            "Network timeout" },
+    { MM_MOBILE_ERROR_NETWORK_NOT_ALLOWED,       "networknotallowedemergencycallsonly",       "Network not allowed - emergency calls only" },
+    { MM_MOBILE_ERROR_NETWORK_PIN,               "networkpersonalizationpinrequired",         "Network personalization PIN required" },
+    { MM_MOBILE_ERROR_NETWORK_PUK,               "networkpersonalizationpukrequired",         "Network personalization PUK required" },
+    { MM_MOBILE_ERROR_NETWORK_SUBSET_PIN,        "networksubsetpersonalizationpinrequired",   "Network subset personalization PIN required" },
+    { MM_MOBILE_ERROR_NETWORK_SUBSET_PUK,        "networksubsetpersonalizationpukrequired",   "Network subset personalization PUK required" },
+    { MM_MOBILE_ERROR_SERVICE_PIN,               "serviceproviderpersonalizationpinrequired", "Service provider personalization PIN required" },
+    { MM_MOBILE_ERROR_SERVICE_PUK,               "serviceproviderpersonalizationpukrequired", "Service provider personalization PUK required" },
+    { MM_MOBILE_ERROR_CORP_PIN,                  "corporatepersonalizationpinrequired",       "Corporate personalization PIN required" },
+    { MM_MOBILE_ERROR_CORP_PUK,                  "corporatepersonalizationpukrequired",       "Corporate personalization PUK required" },
+    { MM_MOBILE_ERROR_HIDDEN_KEY,                "phsimpukrequired",                          "Hidden key required" },
+    { MM_MOBILE_ERROR_EAP_NOT_SUPPORTED,         "eapmethodnotsupported",                     "EAP method not supported" },
+    { MM_MOBILE_ERROR_INCORRECT_PARAMS,          "incorrectparameters",                       "Incorrect parameters" },
+    { MM_MOBILE_ERROR_UNKNOWN,                   "unknownerror",                              "Unknown error" },
+    { MM_MOBILE_ERROR_GPRS_ILLEGAL_MS,           "illegalms",                                 "Illegal MS" },
+    { MM_MOBILE_ERROR_GPRS_ILLEGAL_ME,           "illegalme",                                 "Illegal ME" },
+    { MM_MOBILE_ERROR_GPRS_SERVICE_NOT_ALLOWED,  "gprsservicesnotallowed",                    "GPRS services not allowed" },
+    { MM_MOBILE_ERROR_GPRS_PLMN_NOT_ALLOWED,     "plmnnotallowed",                            "PLMN not allowed" },
+    { MM_MOBILE_ERROR_GPRS_LOCATION_NOT_ALLOWED, "locationareanotallowed",                    "Location area not allowed" },
+    { MM_MOBILE_ERROR_GPRS_ROAMING_NOT_ALLOWED,  "roamingnotallowedinthislocationarea",       "Roaming not allowed in this location area" },
+    { MM_MOBILE_ERROR_GPRS_OPTION_NOT_SUPPORTED, "serviceoperationnotsupported",              "Service option not supported" },
+    { MM_MOBILE_ERROR_GPRS_NOT_SUBSCRIBED,       "requestedserviceoptionnotsubscribed",       "Requested service option not subscribed" },
+    { MM_MOBILE_ERROR_GPRS_OUT_OF_ORDER,         "serviceoptiontemporarilyoutoforder",        "Service option temporarily out of order" },
+    { MM_MOBILE_ERROR_GPRS_UNKNOWN,              "unspecifiedgprserror",                      "Unspecified GPRS error" },
+    { MM_MOBILE_ERROR_GPRS_PDP_AUTH_FAILURE,     "pdpauthenticationfailure",                  "PDP authentication failure" },
+    { MM_MOBILE_ERROR_GPRS_INVALID_CLASS,        "invalidmobileclass",                        "Invalid mobile class" },
+    { -1,                                        NULL,                                        NULL }
+};
+
 GError *
 mm_mobile_error_for_code (int error_code)
 {
-    const char *msg;
+    const char *msg = NULL;
+    const ErrorTable *ptr = &errors[0];
+
+    while (ptr->code >= 0) {
+        if (ptr->code == error_code) {
+            msg = ptr->message;
+            break;
+        }
+        ptr++;
+    }
 
-    switch (error_code) {
-    case MM_MOBILE_ERROR_PHONE_FAILURE: msg = "Phone failure"; break;
-    case MM_MOBILE_ERROR_NO_CONNECTION: msg = "No connection to phone"; break;
-    case MM_MOBILE_ERROR_LINK_RESERVED: msg = "Phone-adaptor link reserved"; break;
-    case MM_MOBILE_ERROR_NOT_ALLOWED: msg = "Operation not allowed"; break;
-    case MM_MOBILE_ERROR_NOT_SUPPORTED: msg = "Operation not supported"; break;
-    case MM_MOBILE_ERROR_PH_SIM_PIN: msg = "PH-SIM PIN required"; break;
-    case MM_MOBILE_ERROR_PH_FSIM_PIN: msg = "PH-FSIM PIN required"; break;
-    case MM_MOBILE_ERROR_PH_FSIM_PUK: msg = "PH-FSIM PUK required"; break;
-    case MM_MOBILE_ERROR_SIM_NOT_INSERTED: msg = "SIM not inserted"; break;
-    case MM_MOBILE_ERROR_SIM_PIN: msg = "SIM PIN required"; break;
-    case MM_MOBILE_ERROR_SIM_PUK: msg = "SIM PUK required"; break;
-    case MM_MOBILE_ERROR_SIM_FAILURE: msg = "SIM failure"; break;
-    case MM_MOBILE_ERROR_SIM_BUSY: msg = "SIM busy"; break;
-    case MM_MOBILE_ERROR_SIM_WRONG: msg = "SIM wrong"; break;
-    case MM_MOBILE_ERROR_WRONG_PASSWORD: msg = "Incorrect password"; break;
-    case MM_MOBILE_ERROR_SIM_PIN2: msg = "SIM PIN2 required"; break;
-    case MM_MOBILE_ERROR_SIM_PUK2: msg = "SIM PUK2 required"; break;
-    case MM_MOBILE_ERROR_MEMORY_FULL: msg = "Memory full"; break;
-    case MM_MOBILE_ERROR_INVALID_INDEX: msg = "Invalid index"; break;
-    case MM_MOBILE_ERROR_NOT_FOUND: msg = "Not found"; break;
-    case MM_MOBILE_ERROR_MEMORY_FAILURE: msg = "Memory failure"; break;
-    case MM_MOBILE_ERROR_TEXT_TOO_LONG: msg = "Text string too long"; break;
-    case MM_MOBILE_ERROR_INVALID_CHARS: msg = "Invalid characters in text string"; break;
-    case MM_MOBILE_ERROR_DIAL_STRING_TOO_LONG: msg = "Dial string too long"; break;
-    case MM_MOBILE_ERROR_DIAL_STRING_INVALID: msg = "Invalid characters in dial string"; break;
-    case MM_MOBILE_ERROR_NO_NETWORK: msg = "No network service"; break;
-    case MM_MOBILE_ERROR_NETWORK_TIMEOUT: msg = "Network timeout"; break;
-    case MM_MOBILE_ERROR_NETWORK_NOT_ALLOWED: msg = "Network not allowed - emergency calls only"; break;
-    case MM_MOBILE_ERROR_NETWORK_PIN: msg = "Network personalization PIN required"; break;
-    case MM_MOBILE_ERROR_NETWORK_PUK: msg = "Network personalization PUK required"; break;
-    case MM_MOBILE_ERROR_NETWORK_SUBSET_PIN: msg = "Network subset personalization PIN required"; break;
-    case MM_MOBILE_ERROR_NETWORK_SUBSET_PUK: msg = "Network subset personalization PUK required"; break;
-    case MM_MOBILE_ERROR_SERVICE_PIN: msg = "Service provider personalization PIN required"; break;
-    case MM_MOBILE_ERROR_SERVICE_PUK: msg = "Service provider personalization PUK required"; break;
-    case MM_MOBILE_ERROR_CORP_PIN: msg = "Corporate personalization PIN required"; break;
-    case MM_MOBILE_ERROR_CORP_PUK: msg = "Corporate personalization PUK required"; break;
-    case MM_MOBILE_ERROR_HIDDEN_KEY: msg = "Hidden key required"; break;
-    case MM_MOBILE_ERROR_EAP_NOT_SUPPORTED: msg = "EAP method not supported"; break;
-    case MM_MOBILE_ERROR_INCORRECT_PARAMS: msg = "Incorrect parameters"; break;
-    case MM_MOBILE_ERROR_UNKNOWN: msg = "Unknown error"; break;
-    case MM_MOBILE_ERROR_GPRS_ILLEGAL_MS: msg = "Illegal MS"; break;
-    case MM_MOBILE_ERROR_GPRS_ILLEGAL_ME: msg = "Illegal ME"; break;
-    case MM_MOBILE_ERROR_GPRS_SERVICE_NOT_ALLOWED: msg = "GPRS services not allowed"; break;
-    case MM_MOBILE_ERROR_GPRS_PLMN_NOT_ALLOWED: msg = "PLMN not allowed"; break;
-    case MM_MOBILE_ERROR_GPRS_LOCATION_NOT_ALLOWED: msg = "Location area not allowed"; break;
-    case MM_MOBILE_ERROR_GPRS_ROAMING_NOT_ALLOWED: msg = "Roaming not allowed in this location area"; break;
-    case MM_MOBILE_ERROR_GPRS_OPTION_NOT_SUPPORTED: msg = "Service option not supported"; break;
-    case MM_MOBILE_ERROR_GPRS_NOT_SUBSCRIBED: msg = "Requested service option not subscribed"; break;
-    case MM_MOBILE_ERROR_GPRS_OUT_OF_ORDER: msg = "Service option temporarily out of order"; break;
-    case MM_MOBILE_ERROR_GPRS_PDP_AUTH_FAILURE: msg = "PDP authentication failure"; break;
-    case MM_MOBILE_ERROR_GPRS_UNKNOWN: msg = "Unspecified GPRS error"; break;
-    case MM_MOBILE_ERROR_GPRS_INVALID_CLASS: msg = "Invalid mobile class"; break;
-    default:
-        g_warning ("Invalid error code");
+    if (!msg) {
+        g_warning ("Invalid error code: %d", error_code);
         error_code = MM_MOBILE_ERROR_UNKNOWN;
         msg = "Unknown error";
     }
 
     return g_error_new_literal (MM_MOBILE_ERROR, error_code, msg);
 }
+
+#define BUF_SIZE 100
+
+GError *
+mm_mobile_error_for_string (const char *str)
+{
+    int error_code = -1;
+    const ErrorTable *ptr = &errors[0];
+    char buf[BUF_SIZE + 1];
+    const char *msg = NULL, *p = str;
+    int i = 0;
+
+    g_return_val_if_fail (str != NULL, NULL);
+
+    /* Normalize the error code by stripping whitespace and odd characters */
+    while (*p && i < BUF_SIZE) {
+        if (isalnum (*p))
+            buf[i++] = tolower (*p);
+        p++;
+    }
+    buf[i] = '\0';
+
+    while (ptr->code >= 0) {
+        if (!strcmp (buf, ptr->error)) {
+            error_code = ptr->code;
+            msg = ptr->message;
+            break;
+        }
+        ptr++;
+    }
+
+    if (!msg) {
+        g_warning ("Invalid error code: %d", error_code);
+        error_code = MM_MOBILE_ERROR_UNKNOWN;
+        msg = "Unknown error";
+    }
+
+    return g_error_new_literal (MM_MOBILE_ERROR, error_code, msg);
+}
+
diff --git a/src/mm-errors.h b/src/mm-errors.h
index c02a351..2a6c565 100644
--- a/src/mm-errors.h
+++ b/src/mm-errors.h
@@ -64,6 +64,7 @@ GType   mm_modem_connect_error_get_type (void);
 GError *mm_modem_connect_error_for_code (int error_code);
 
 
+/* 3GPP TS 07.07 version 7.8.0 Release 1998 (page 90) ETSI TS 100 916 V7.8.0 (2003-03) */
 enum {
     MM_MOBILE_ERROR_PHONE_FAILURE = 0,
     MM_MOBILE_ERROR_NO_CONNECTION = 1,
@@ -115,8 +116,8 @@ enum {
     MM_MOBILE_ERROR_GPRS_OPTION_NOT_SUPPORTED = 132,
     MM_MOBILE_ERROR_GPRS_NOT_SUBSCRIBED = 133,
     MM_MOBILE_ERROR_GPRS_OUT_OF_ORDER = 134,
-    MM_MOBILE_ERROR_GPRS_PDP_AUTH_FAILURE = 149,
     MM_MOBILE_ERROR_GPRS_UNKNOWN = 148,
+    MM_MOBILE_ERROR_GPRS_PDP_AUTH_FAILURE = 149,
     MM_MOBILE_ERROR_GPRS_INVALID_CLASS = 150
 };
 
@@ -127,5 +128,6 @@ enum {
 GQuark  mm_mobile_error_quark    (void);
 GType   mm_mobile_error_get_type (void);
 GError *mm_mobile_error_for_code (int error_code);
+GError *mm_mobile_error_for_string (const char *str);
 
 #endif /* MM_MODEM_ERROR_H */

commit c85e61753000514ae140cf745e47e835edb934cb
Author: Dan Williams <dcbw@redhat.com>
Date:   Sun Jan 31 22:32:33 2010 -0800

    serial: handle string CME error codes too
    
    Some devices won't get to the initialization stage where we send
    CMEE=1 (for numeric error codes) before they return some errors,
    so handle the string representation of CME error codes too.

diff --git a/src/mm-serial-parsers.c b/src/mm-serial-parsers.c
index 58985d9..7c9598e 100644
--- a/src/mm-serial-parsers.c
+++ b/src/mm-serial-parsers.c
@@ -190,7 +190,8 @@ mm_serial_parser_v0_destroy (gpointer data)
 typedef struct {
     GRegex *regex_ok;
     GRegex *regex_connect;
-    GRegex *regex_detailed_error;
+    GRegex *regex_cme_error;
+    GRegex *regex_cme_error_str;
     GRegex *regex_unknown_error;
     GRegex *regex_connect_failed;
 } MMSerialParserV1;
@@ -205,7 +206,8 @@ mm_serial_parser_v1_new (void)
 
     parser->regex_ok = g_regex_new ("\\r\\nOK(\\r\\n)+$", flags, 0, NULL);
     parser->regex_connect = g_regex_new ("\\r\\nCONNECT.*\\r\\n", flags, 0, NULL);
-    parser->regex_detailed_error = g_regex_new ("\\r\\n\\+CME ERROR: (\\d+)\\r\\n$", flags, 0, NULL);
+    parser->regex_cme_error = g_regex_new ("\\r\\n\\+CME ERROR: (\\d+)\\r\\n$", flags, 0, NULL);
+    parser->regex_cme_error_str = g_regex_new ("\\r\\n\\+CME ERROR: ([^\\n\\r]+)\\r\\n$", flags, 0, NULL);
     parser->regex_unknown_error = g_regex_new ("\\r\\n(ERROR)|(COMMAND NOT SUPPORT)\\r\\n$", flags, 0, NULL);
     parser->regex_connect_failed = g_regex_new ("\\r\\n(NO CARRIER)|(BUSY)|(NO ANSWER)|(NO DIALTONE)\\r\\n$", flags, 0, NULL);
 
@@ -219,9 +221,10 @@ mm_serial_parser_v1_parse (gpointer data,
 {
     MMSerialParserV1 *parser = (MMSerialParserV1 *) data;
     GMatchInfo *match_info;
-    GError *local_error;
-    int code;
+    GError *local_error = NULL;
     gboolean found = FALSE;
+    char *str;
+    int code;
 
     g_return_val_if_fail (parser != NULL, FALSE);
     g_return_val_if_fail (response != NULL, FALSE);
@@ -243,56 +246,70 @@ mm_serial_parser_v1_parse (gpointer data,
     }
 
     /* Now failures */
-    code = MM_MOBILE_ERROR_UNKNOWN;
-    local_error = NULL;
 
-    found = g_regex_match_full (parser->regex_detailed_error,
+    /* Numeric CME errors */
+    found = g_regex_match_full (parser->regex_cme_error,
                                 response->str, response->len,
                                 0, 0, &match_info, NULL);
-
     if (found) {
-        char *str;
+        str = g_match_info_fetch (match_info, 1);
+        g_assert (str);
+        local_error = mm_mobile_error_for_code (atoi (str));
+        g_free (str);
+        g_match_info_free (match_info);
+        goto done;
+    }
 
+    /* String CME errors */
+    found = g_regex_match_full (parser->regex_cme_error_str,
+                                response->str, response->len,
+                                0, 0, &match_info, NULL);
+    if (found) {
         str = g_match_info_fetch (match_info, 1);
-        if (str) {
-            code = atoi (str);
-            g_free (str);
-        }
+        g_assert (str);
+        local_error = mm_mobile_error_for_string (str);
+        g_free (str);
         g_match_info_free (match_info);
-    } else 
-        found = g_regex_match_full (parser->regex_unknown_error, response->str, response->len, 0, 0, NULL, NULL);
+        goto done;
+    }
 
-    if (found)
-        local_error = mm_mobile_error_for_code (code);
-    else {
-        found = g_regex_match_full (parser->regex_connect_failed,
-                                    response->str, response->len,
-                                    0, 0, &match_info, NULL);
-        if (found) {
-            char *str;
+    /* Last resort; unknown error */
+    found = g_regex_match_full (parser->regex_unknown_error,
+                                response->str, response->len,
+                                0, 0, NULL, NULL);
+    if (found) {
+        local_error = mm_mobile_error_for_code (MM_MOBILE_ERROR_UNKNOWN);
+        goto done;
+    }
 
-            str = g_match_info_fetch (match_info, 1);
-            if (str) {
-                if (!strcmp (str, "NO CARRIER"))
-                    code = MM_MODEM_CONNECT_ERROR_NO_CARRIER;
-                else if (!strcmp (str, "BUSY"))
-                    code = MM_MODEM_CONNECT_ERROR_BUSY;
-                else if (!strcmp (str, "NO ANSWER"))
-                    code = MM_MODEM_CONNECT_ERROR_NO_ANSWER;
-                else if (!strcmp (str, "NO DIALTONE"))
-                    code = MM_MODEM_CONNECT_ERROR_NO_DIALTONE;
-                else
-                    /* uhm... make something up (yes, ok, lie!). */
-                    code = MM_MODEM_CONNECT_ERROR_NO_CARRIER;
+    /* Connection failures */
+    found = g_regex_match_full (parser->regex_connect_failed,
+                                response->str, response->len,
+                                0, 0, &match_info, NULL);
+    if (found) {
+        str = g_match_info_fetch (match_info, 1);
+        g_assert (str);
+
+        if (!strcmp (str, "NO CARRIER"))
+            code = MM_MODEM_CONNECT_ERROR_NO_CARRIER;
+        else if (!strcmp (str, "BUSY"))
+            code = MM_MODEM_CONNECT_ERROR_BUSY;
+        else if (!strcmp (str, "NO ANSWER"))
+            code = MM_MODEM_CONNECT_ERROR_NO_ANSWER;
+        else if (!strcmp (str, "NO DIALTONE"))
+            code = MM_MODEM_CONNECT_ERROR_NO_DIALTONE;
+        else {
+            /* uhm... make something up (yes, ok, lie!). */
+            code = MM_MODEM_CONNECT_ERROR_NO_CARRIER;
+        }
 
-                g_free (str);
-            }
-            g_match_info_free (match_info);
+        g_free (str);
+        g_match_info_free (match_info);
 
-            local_error = mm_modem_connect_error_for_code (code);
-        }
+        local_error = mm_modem_connect_error_for_code (code);
     }
 
+done:
     if (found)
         response_clean (response);
 
@@ -313,7 +330,8 @@ mm_serial_parser_v1_destroy (gpointer data)
 
     g_regex_unref (parser->regex_ok);
     g_regex_unref (parser->regex_connect);
-    g_regex_unref (parser->regex_detailed_error);
+    g_regex_unref (parser->regex_cme_error);
+    g_regex_unref (parser->regex_cme_error_str);
     g_regex_unref (parser->regex_unknown_error);
     g_regex_unref (parser->regex_connect_failed);
 

commit 469e54c364de5776b1b41db0f5eaa9cb3f34f6b0
Author: Dan Williams <dcbw@redhat.com>
Date:   Sun Jan 31 22:33:38 2010 -0800

    gsm: update UnlockRequired status on PIN/PUK entry result

diff --git a/src/mm-generic-gsm.c b/src/mm-generic-gsm.c
index d87f5a8..4718d6f 100644
--- a/src/mm-generic-gsm.c
+++ b/src/mm-generic-gsm.c
@@ -807,15 +807,40 @@ get_card_info (MMModem *modem,
 }
 
 static void
+pin_puk_recheck_done (MMModem *modem, GError *error, gpointer user_data)
+{
+    gboolean close_port = !!user_data;
+
+    /* modem could have been removed before we get here, in which case
+     * 'modem' will be NULL.
+     */
+    if (modem) {
+        g_return_if_fail (MM_IS_GENERIC_GSM (modem));
+
+        if (close_port)
+            mm_serial_port_close (MM_GENERIC_GSM_GET_PRIVATE (modem)->primary);
+    }
+}
+
+#define PIN_CLOSE_PORT_TAG "close-port"
+
+static void
 send_puk_done (MMSerialPort *port,
                GString *response,
                GError *error,
                gpointer user_data)
 {
     MMCallbackInfo *info = (MMCallbackInfo *) user_data;
+    gboolean close_port = !!mm_callback_info_get_data (info, PIN_CLOSE_PORT_TAG);
 
     if (error)
         info->error = g_error_copy (error);
+
+    /* Get latest PUK status */
+    mm_generic_gsm_check_pin (MM_GENERIC_GSM (info->modem),
+                              pin_puk_recheck_done,
+                              GUINT_TO_POINTER (close_port));
+
     mm_callback_info_schedule (info);
 }
 
@@ -829,10 +854,33 @@ send_puk (MMModemGsmCard *modem,
     MMGenericGsmPrivate *priv = MM_GENERIC_GSM_GET_PRIVATE (modem);
     MMCallbackInfo *info;
     char *command;
+    gboolean connected;
 
     info = mm_callback_info_new (MM_MODEM (modem), callback, user_data);
+
+    connected = mm_port_get_connected (MM_PORT (priv->primary));
+    if (connected && !priv->secondary) {
+        /* Ensure we have a usable port to use for the unlock */
+        info->error = g_error_new_literal (MM_MODEM_ERROR,
+                                           MM_MODEM_ERROR_CONNECTED,
+                                           "Cannot unlock device while connected");
+        mm_callback_info_schedule (info);
+        return;
+    } else if (!mm_serial_port_is_open (priv->primary)) {
+        /* Modem may not be enabled yet, which sometimes can't be done until
+         * the device has been unlocked.
+         */
+        if (!mm_serial_port_open (priv->primary, &info->error)) {
+            mm_callback_info_schedule (info);
+            return;
+        }
+
+        /* Clean up after ourselves if we opened the port */
+        mm_callback_info_set_data (info, PIN_CLOSE_PORT_TAG, GUINT_TO_POINTER (TRUE), NULL);
+    }
+
     command = g_strdup_printf ("+CPIN=\"%s\",\"%s\"", puk, pin);
-    mm_serial_port_queue_command (priv->primary, command, 3, send_puk_done, info);
+    mm_serial_port_queue_command (connected ? priv->secondary : priv->primary, command, 3, send_puk_done, info);
     g_free (command);
 }
 
@@ -843,9 +891,16 @@ send_pin_done (MMSerialPort *port,
                gpointer user_data)
 {
     MMCallbackInfo *info = (MMCallbackInfo *) user_data;
+    gboolean close_port = !!mm_callback_info_get_data (info, PIN_CLOSE_PORT_TAG);
 
     if (error)
         info->error = g_error_copy (error);
+
+    /* Get latest PIN status */
+    mm_generic_gsm_check_pin (MM_GENERIC_GSM (info->modem),
+                              pin_puk_recheck_done,
+                              GUINT_TO_POINTER (close_port));
+
     mm_callback_info_schedule (info);
 }
 
@@ -858,10 +913,33 @@ send_pin (MMModemGsmCard *modem,
     MMGenericGsmPrivate *priv = MM_GENERIC_GSM_GET_PRIVATE (modem);
     MMCallbackInfo *info;
     char *command;
+    gboolean connected;
 
     info = mm_callback_info_new (MM_MODEM (modem), callback, user_data);
+
+    connected = mm_port_get_connected (MM_PORT (priv->primary));
+    if (connected && !priv->secondary) {
+        /* Ensure we have a usable port to use for the unlock */
+        info->error = g_error_new_literal (MM_MODEM_ERROR,
+                                           MM_MODEM_ERROR_CONNECTED,
+                                           "Cannot unlock device while connected");
+        mm_callback_info_schedule (info);
+        return;
+    } else if (!mm_serial_port_is_open (priv->primary)) {
+        /* Modem may not be enabled yet, which sometimes can't be done until
+         * the device has been unlocked.
+         */
+        if (!mm_serial_port_open (priv->primary, &info->error)) {
+            mm_callback_info_schedule (info);
+            return;
+        }
+
+        /* Clean up after ourselves if we opened the port */
+        mm_callback_info_set_data (info, PIN_CLOSE_PORT_TAG, GUINT_TO_POINTER (TRUE), NULL);
+    }
+
     command = g_strdup_printf ("+CPIN=\"%s\"", pin);
-    mm_serial_port_queue_command (priv->primary, command, 3, send_pin_done, info);
+    mm_serial_port_queue_command (connected ? priv->secondary : priv->primary, command, 3, send_pin_done, info);
     g_free (command);
 }
 

commit a9918d59427eae2b00da8fbe92c556a90db38b43
Author: Martin Pitt <martin.pitt@ubuntu.com>
Date:   Tue Feb 2 10:02:53 2010 -0800

    core: ignore VTs
    
    Even just walking sysfs for driver and parent devices takes
    time for ports we know we'll never use, so take a short-cut
    and save some startup time.  This reduces the startup
    overhead to some 15%.

diff --git a/src/mm-manager.c b/src/mm-manager.c
index 1a93170..389acba 100644
--- a/src/mm-manager.c
+++ b/src/mm-manager.c
@@ -15,6 +15,7 @@
  */
 
 #include <string.h>
+#include <ctype.h>
 #include <gmodule.h>
 #define G_UDEV_API_IS_SUBJECT_TO_CHANGE
 #include <gudev/gudev.h>
@@ -517,6 +518,10 @@ device_added (MMManager *manager, GUdevDevice *device)
     subsys = g_udev_device_get_subsystem (device);
     name = g_udev_device_get_name (device);
 
+    /* ignore VTs */
+    if (strncmp (name, "tty", 3) == 0 && isdigit (name[3]))
+	return;
+
     if (find_modem_for_port (manager, subsys, name))
         return;
 

commit 8e3406bf740144ac657d13c69bff0f3407311b14
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Feb 3 15:19:36 2010 -0800

    longcheer: tag ChinaBird PL68 (pid 0x9000) ports (bgo #608668)

diff --git a/plugins/77-mm-longcheer-port-types.rules b/plugins/77-mm-longcheer-port-types.rules
index 7317df7..2900ca8 100644
--- a/plugins/77-mm-longcheer-port-types.rules
+++ b/plugins/77-mm-longcheer-port-types.rules
@@ -27,6 +27,11 @@ ATTRS{idProduct}=="6061", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE
 ATTRS{idProduct}=="6061", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
 ATTRS{idProduct}=="6061", ENV{ID_MM_LONGCHEER_TAGGED}="1"
 
+# ChinaBird PL68
+ATTRS{idProduct}=="9000", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9000", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9000", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
 GOTO="mm_longcheer_port_types_end"
 
 

commit 9eb376d782e1f40d430807794c5b0f60a91e058b
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Feb 3 18:37:24 2010 -0800

    longcheer: add more port tags

diff --git a/plugins/77-mm-longcheer-port-types.rules b/plugins/77-mm-longcheer-port-types.rules
index 2900ca8..5da0654 100644
--- a/plugins/77-mm-longcheer-port-types.rules
+++ b/plugins/77-mm-longcheer-port-types.rules
@@ -6,6 +6,11 @@
 # Alcatel One Touch X030
 # MobiData MBD-200HU 
 # ST Mobile Connect HSUPA USB Modem 
+#
+# Most of these values were scraped from various Longcheer-based Windows
+# driver .inf files.  cmmdm.inf lists the actual data (ie PPP) ports, while
+# cmser.inf lists the aux ports that may be either AT-capable or not but
+# cannot be used for PPP.
 
 
 ACTION!="add|change", GOTO="mm_longcheer_port_types_end"
@@ -18,6 +23,14 @@ GOTO="mm_longcheer_port_types_end"
 LABEL="mm_longcheer_vendorcheck"
 SUBSYSTEMS=="usb", ATTRS{bInterfaceNumber}=="?*", ENV{.MM_USBIFNUM}="$attr{bInterfaceNumber}"
 
+ATTRS{idProduct}=="3197", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="3197", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="3197", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="6000", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="6000", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="6000", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
 ATTRS{idProduct}=="6060", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
 ATTRS{idProduct}=="6060", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
 ATTRS{idProduct}=="6060", ENV{ID_MM_LONGCHEER_TAGGED}="1"
@@ -27,11 +40,92 @@ ATTRS{idProduct}=="6061", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE
 ATTRS{idProduct}=="6061", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
 ATTRS{idProduct}=="6061", ENV{ID_MM_LONGCHEER_TAGGED}="1"
 
+ATTRS{idProduct}=="7001", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="7001", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7001", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7001", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="7002", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="7002", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7002", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7002", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7002", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="7101", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="7101", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7101", ENV{.MM_USBIFNUM}=="05", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7101", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="7102", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="7102", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7102", ENV{.MM_USBIFNUM}=="05", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7102", ENV{.MM_USBIFNUM}=="06", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="7102", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="8000", ENV{.MM_USBIFNUM}=="05", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="8000", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="8000", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="8000", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="8001", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="8001", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="8001", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="8001", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="8002", ENV{.MM_USBIFNUM}=="04", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="8002", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="8002", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="8002", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
 # ChinaBird PL68
 ATTRS{idProduct}=="9000", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
 ATTRS{idProduct}=="9000", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
 ATTRS{idProduct}=="9000", ENV{ID_MM_LONGCHEER_TAGGED}="1"
 
+ATTRS{idProduct}=="9001", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9001", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9001", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9001", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9002", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9002", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9002", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9002", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9003", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9003", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9004", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9004", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9004", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9005", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9005", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9005", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9010", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9010", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9010", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9010", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9012", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9012", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9012", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9012", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9020", ENV{.MM_USBIFNUM}=="03", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9020", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9020", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9020", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
+ATTRS{idProduct}=="9022", ENV{.MM_USBIFNUM}=="02", ENV{ID_MM_LONGCHEER_PORT_TYPE_MODEM}="1"
+ATTRS{idProduct}=="9022", ENV{.MM_USBIFNUM}=="00", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9022", ENV{.MM_USBIFNUM}=="01", ENV{ID_MM_LONGCHEER_PORT_TYPE_AUX}="1"
+ATTRS{idProduct}=="9022", ENV{ID_MM_LONGCHEER_TAGGED}="1"
+
 GOTO="mm_longcheer_port_types_end"
 
 

commit 7fdacfc89bb233ee0018a9ae64ce1ffa5a23f5d3
Author: Dan Williams <dcbw@redhat.com>
Date:   Mon Feb 8 11:45:50 2010 -0800

    test: add SE K600i COPS response testcase

diff --git a/src/tests/test-modem-helpers.c b/src/tests/test-modem-helpers.c
index 3d93423..f5b4b6a 100644
--- a/src/tests/test-modem-helpers.c
+++ b/src/tests/test-modem-helpers.c
@@ -409,6 +409,27 @@ test_cops_response_gobi (void *f, gpointer d)
 }
 
 static void
+test_cops_response_sek600i (void *f, gpointer d)
+{
+    /* Phone is stupid enough to support 3G but not report cell technology,
+     * mixing together 2G and 3G cells without any way of distinguishing
+     * which is which...
+     */
+    const char *reply = "+COPS: (2,\"blau\",\"\",\"26203\"),(2,\"blau\",\"\",\"26203\"),(3,\"\",\"\",\"26201\"),(3,\"\",\"\",\"26202\"),(3,\"\",\"\",\"26207\"),(3,\"\",\"\",\"26201\"),(3,\"\",\"\",\"26207\")";
+    static OperEntry expected[] = {
+        { "2", "blau", NULL, "26203", NULL },
+        { "2", "blau", NULL, "26203", NULL },
+        { "3", NULL, NULL, "26201", NULL },
+        { "3", NULL, NULL, "26202", NULL },
+        { "3", NULL, NULL, "26207", NULL },
+        { "3", NULL, NULL, "26201", NULL },
+        { "3", NULL, NULL, "26207", NULL },
+    };
+
+    test_results ("Sony-Ericsson K600i", reply, &expected[0], ARRAY_LEN (expected));
+}
+
+static void
 test_cops_response_gsm_invalid (void *f, gpointer d)
 {
     const char *reply = "+COPS: (0,1,2,3),(1,2,3,4)";
@@ -470,6 +491,7 @@ int main (int argc, char **argv)
 	g_test_suite_add (suite, TESTCASE (test_cops_response_gtultraexpress, NULL));
 	g_test_suite_add (suite, TESTCASE (test_cops_response_n2720, NULL));
 	g_test_suite_add (suite, TESTCASE (test_cops_response_gobi, NULL));
+	g_test_suite_add (suite, TESTCASE (test_cops_response_sek600i, NULL));
 
 	g_test_suite_add (suite, TESTCASE (test_cops_response_gsm_invalid, NULL));
 	g_test_suite_add (suite, TESTCASE (test_cops_response_umts_invalid, NULL));

commit 33c63a6681f439012524e5a68f6aa7220f38d120
Author: Dan Williams <dcbw@redhat.com>
Date:   Mon Feb 8 12:37:06 2010 -0800

    zte: quite ZUSIMR messages for PIN-enabled devices too
    
    Normally this would get done by the prober, but if the device
    has a PIN enabled it'll reject almost all commands so the +CPMS?
    in the prober will fail.  Thus we have to do it after we've unlocked
    the device.

diff --git a/plugins/mm-modem-zte.c b/plugins/mm-modem-zte.c
index 92c23ae..6198a60 100644
--- a/plugins/mm-modem-zte.c
+++ b/plugins/mm-modem-zte.c
@@ -32,6 +32,8 @@ G_DEFINE_TYPE_EXTENDED (MMModemZte, mm_modem_zte, MM_TYPE_GENERIC_GSM, 0,
 
 typedef struct {
     gboolean init_retried;
+    guint32 cpms_tries;
+    guint cpms_timeout;
 } MMModemZtePrivate;
 
 MMModem *
@@ -54,6 +56,52 @@ mm_modem_zte_new (const char *device,
 /*    Modem class override functions                                         */
 /*****************************************************************************/
 
+static void cpms_try_done (MMSerialPort *port,
+                           GString *response,
+                           GError *error,
+                           gpointer user_data);
+
+static gboolean
+cpms_timeout_cb (gpointer user_data)
+{
+    MMCallbackInfo *info = user_data;
+    MMModem *modem = info->modem;
+    MMModemZtePrivate *priv = MM_MODEM_ZTE_GET_PRIVATE (modem);
+    MMSerialPort *primary;
+
+    priv->cpms_timeout = 0;
+
+    primary = mm_generic_gsm_get_port (MM_GENERIC_GSM (modem), MM_PORT_TYPE_PRIMARY);
+    mm_serial_port_queue_command (primary, "+CPMS?", 10, cpms_try_done, info);
+    return FALSE;
+}
+
+static void
+cpms_try_done (MMSerialPort *port,
+               GString *response,
+               GError *error,
+               gpointer user_data)
+{
+    MMCallbackInfo *info = user_data;
+    MMModemZtePrivate *priv = MM_MODEM_ZTE_GET_PRIVATE (info->modem);
+
+    if (error && g_error_matches (error, MM_MOBILE_ERROR, MM_MOBILE_ERROR_SIM_BUSY)) {
+        if (priv->cpms_tries++ < 4) {
+            if (priv->cpms_timeout)
+                g_source_remove (priv->cpms_timeout);
+
+            /* Have to try a few times; sometimes the SIM is busy */
+            priv->cpms_timeout = g_timeout_add_seconds (2, cpms_timeout_cb, info);
+            return;
+        } else {
+            /* oh well, proceed... */
+            error = NULL;
+        }
+    }
+
+    mm_generic_gsm_enable_complete (MM_GENERIC_GSM (info->modem), error, info);
+}
+
 static void
 init_modem_done (MMSerialPort *port,
                  GString *response,
@@ -62,7 +110,12 @@ init_modem_done (MMSerialPort *port,
 {
     MMCallbackInfo *info = (MMCallbackInfo *) user_data;
 
-    mm_generic_gsm_enable_complete (MM_GENERIC_GSM (info->modem), error, info);
+    /* Attempt to disable floods of "+ZUSIMR:2" unsolicited responses that
+     * eventually fill up the device's buffers and make it crash.  Normally
+     * done during probing, but if the device has a PIN enabled it won't
+     * accept the +CPMS? during the probe and we have to do it here.
+     */
+    mm_serial_port_queue_command (port, "+CPMS?", 10, cpms_try_done, info);
 }
 
 static void
@@ -222,6 +275,16 @@ mm_modem_zte_init (MMModemZte *self)
 }
 
 static void
+dispose (GObject *object)
+{
+    MMModemZte *self = MM_MODEM_ZTE (object);
+    MMModemZtePrivate *priv = MM_MODEM_ZTE_GET_PRIVATE (self);
+
+    if (priv->cpms_timeout)
+        g_source_remove (priv->cpms_timeout);
+}
+
+static void
 mm_modem_zte_class_init (MMModemZteClass *klass)
 {
     GObjectClass *object_class = G_OBJECT_CLASS (klass);
@@ -230,6 +293,7 @@ mm_modem_zte_class_init (MMModemZteClass *klass)
     mm_modem_zte_parent_class = g_type_class_peek_parent (klass);
     g_type_class_add_private (object_class, sizeof (MMModemZtePrivate));
 
+    object_class->dispose = dispose;
     gsm_class->do_enable = do_enable;
 }
 

commit 953095466d210b76d785175957af0cb686fc5c04
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Feb 9 22:14:06 2010 -0800

    sierra: ignore +PACSP0 on GSM devices

diff --git a/plugins/mm-modem-sierra-gsm.c b/plugins/mm-modem-sierra-gsm.c
index ee82234..c224090 100644
--- a/plugins/mm-modem-sierra-gsm.c
+++ b/plugins/mm-modem-sierra-gsm.c
@@ -117,9 +117,16 @@ grab_port (MMModem *modem,
 
     port = mm_generic_gsm_grab_port (gsm, subsys, name, ptype, error);
 
-    if (port && MM_IS_SERIAL_PORT (port))
+    if (port && MM_IS_SERIAL_PORT (port)) {
+        GRegex *regex;
+
         g_object_set (G_OBJECT (port), MM_PORT_CARRIER_DETECT, FALSE, NULL);
 
+        regex = g_regex_new ("\\r\\n\\+PACSP0\\r\\n", G_REGEX_RAW | G_REGEX_OPTIMIZE, 0, NULL);
+        mm_serial_port_add_unsolicited_msg_handler (MM_SERIAL_PORT (port), regex, NULL, NULL, NULL);
+        g_regex_unref (regex);
+    }
+
     return !!port;
 }
 

commit 95dd4b5be1ebb0408be6e282eb20e2c45df1f253
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Feb 9 22:58:44 2010 -0800

    gsm: try initial PIN check a few times in case SIM is busy

diff --git a/src/mm-generic-gsm.c b/src/mm-generic-gsm.c
index 4718d6f..fb14191 100644
--- a/src/mm-generic-gsm.c
+++ b/src/mm-generic-gsm.c
@@ -51,6 +51,8 @@ typedef struct {
 
     gboolean valid;
     gboolean pin_checked;
+    guint32 pin_check_tries;
+    guint pin_check_timeout;
 
     char *oper_code;
     char *oper_name;
@@ -297,6 +299,20 @@ check_valid (MMGenericGsm *self)
     mm_modem_base_set_valid (MM_MODEM_BASE (self), new_valid);
 }
 
+
+static void initial_pin_check_done (MMModem *modem, GError *error, gpointer user_data);
+
+static gboolean
+pin_check_again (gpointer user_data)
+{
+    MMGenericGsm *self = MM_GENERIC_GSM (user_data);
+    MMGenericGsmPrivate *priv = MM_GENERIC_GSM_GET_PRIVATE (self);
+
+    priv->pin_check_timeout = 0;
+    mm_generic_gsm_check_pin (self, initial_pin_check_done, GUINT_TO_POINTER (TRUE));
+    return FALSE;
+}
+
 static void
 initial_pin_check_done (MMModem *modem, GError *error, gpointer user_data)
 {
@@ -306,10 +322,18 @@ initial_pin_check_done (MMModem *modem, GError *error, gpointer user_data)
     /* modem could have been removed before we get here, in which case
      * 'modem' will be NULL.
      */
-    if (modem) {
-        g_return_if_fail (MM_IS_GENERIC_GSM (modem));
-        priv = MM_GENERIC_GSM_GET_PRIVATE (modem);
+    if (!modem)
+        return;
 
+    g_return_if_fail (MM_IS_GENERIC_GSM (modem));
+    priv = MM_GENERIC_GSM_GET_PRIVATE (modem);
+
+    if (error && priv->pin_check_tries++ < 3) {
+        /* Try it again a few times */
+        if (priv->pin_check_timeout)
+            g_source_remove (priv->pin_check_timeout);
+        priv->pin_check_timeout = g_timeout_add_seconds (2, pin_check_again, modem);
+    } else {
         priv->pin_checked = TRUE;
         if (close_port)
             mm_serial_port_close (priv->primary);
@@ -2284,6 +2308,9 @@ finalize (GObject *object)
 
     mm_generic_gsm_pending_registration_stop (MM_GENERIC_GSM (object));
 
+    if (priv->pin_check_timeout)
+        g_source_remove (priv->pin_check_timeout);
+
     g_free (priv->oper_code);
     g_free (priv->oper_name);
 

commit d8ea5ea003f6e06520ec1254d89ec5fec5438d18
Author: Dan Williams <dcbw@redhat.com>
Date:   Tue Feb 9 23:44:23 2010 -0800

    gsm: fix initial PIN checking for devices that echo by default
    
    If the modem echoed commands by	default (since we may not have
    initialized the modem yet), the echoed command would confuse
    the PIN check reply parser.

diff --git a/src/mm-generic-gsm.c b/src/mm-generic-gsm.c
index fb14191..d26f117 100644
--- a/src/mm-generic-gsm.c
+++ b/src/mm-generic-gsm.c
@@ -203,8 +203,8 @@ pin_check_done (MMSerialPort *port,
 
     if (error)
         info->error = g_error_copy (error);
-    else if (g_str_has_prefix (response->str, "+CPIN: ")) {
-        const char *str = response->str + 7;
+    else if (response && strstr (response->str, "+CPIN: ")) {
+        const char *str = strstr (response->str, "+CPIN: ") + 7;
 
         if (g_str_has_prefix (str, "READY")) {
             mm_modem_base_set_unlock_required (MM_MODEM_BASE (info->modem), NULL);
@@ -328,7 +328,9 @@ initial_pin_check_done (MMModem *modem, GError *error, gpointer user_data)
     g_return_if_fail (MM_IS_GENERIC_GSM (modem));
     priv = MM_GENERIC_GSM_GET_PRIVATE (modem);
 
-    if (error && priv->pin_check_tries++ < 3) {
+    if (   error
+        && priv->pin_check_tries++ < 3
+        && !mm_modem_base_get_unlock_required (MM_MODEM_BASE (modem))) {
         /* Try it again a few times */
         if (priv->pin_check_timeout)
             g_source_remove (priv->pin_check_timeout);
diff --git a/src/mm-modem-base.c b/src/mm-modem-base.c
index 6e9ee75..43ec6f8 100644
--- a/src/mm-modem-base.c
+++ b/src/mm-modem-base.c
@@ -170,7 +170,17 @@ mm_modem_base_get_valid (MMModemBase *self)
     return MM_MODEM_BASE_GET_PRIVATE (self)->valid;
 }
 
-void mm_modem_base_set_unlock_required (MMModemBase *self, const char *unlock_required)
+const char *
+mm_modem_base_get_unlock_required (MMModemBase *self)
+{
+    g_return_val_if_fail (self != NULL, NULL);
+    g_return_val_if_fail (MM_IS_MODEM_BASE (self), NULL);
+
+    return MM_MODEM_BASE_GET_PRIVATE (self)->unlock_required;
+}
+
+void
+mm_modem_base_set_unlock_required (MMModemBase *self, const char *unlock_required)
 {
     MMModemBasePrivate *priv;
     const char *dbus_path;
diff --git a/src/mm-modem-base.h b/src/mm-modem-base.h
index 9078f3f..db2b5fb 100644
--- a/src/mm-modem-base.h
+++ b/src/mm-modem-base.h
@@ -60,6 +60,8 @@ void mm_modem_base_set_valid (MMModemBase *self,
 
 gboolean mm_modem_base_get_valid (MMModemBase *self);
 
+const char *mm_modem_base_get_unlock_required (MMModemBase *self);
+
 void mm_modem_base_set_unlock_required (MMModemBase *self,
                                         const char *unlock_required);
 

commit 1a7be4a379e95a0ceb5ed1d30540eaf75354f27f
Author: Dan Williams <dcbw@redhat.com>
Date:   Thu Feb 11 08:12:41 2010 -0800

    huawei: ignore CSS on EVDO-capable modems (rh #553199)
    
    Since CSS doesn't reliably determine EVDO-only registration state.

diff --git a/plugins/mm-modem-huawei-cdma.c b/plugins/mm-modem-huawei-cdma.c
index 3b63a48..19b731a 100644
--- a/plugins/mm-modem-huawei-cdma.c
+++ b/plugins/mm-modem-huawei-cdma.c
@@ -41,16 +41,26 @@ mm_modem_huawei_cdma_new (const char *device,
                          gboolean evdo_rev0,
                          gboolean evdo_revA)
 {
+    gboolean try_css = TRUE;
+
     g_return_val_if_fail (device != NULL, NULL);
     g_return_val_if_fail (driver != NULL, NULL);
     g_return_val_if_fail (plugin != NULL, NULL);
 
+    /* Don't use AT+CSS on EVDO-capable hardware for determining registration
+     * status, because often the device will have only an EVDO connection and
+     * AT+CSS won't necessarily report EVDO registration status, only 1X.
+     */
+    if (evdo_rev0 || evdo_revA)
+        try_css = FALSE;
+
     return MM_MODEM (g_object_new (MM_TYPE_MODEM_HUAWEI_CDMA,
                                    MM_MODEM_MASTER_DEVICE, device,
                                    MM_MODEM_DRIVER, driver,
                                    MM_MODEM_PLUGIN, plugin,
                                    MM_GENERIC_CDMA_EVDO_REV0, evdo_rev0,
                                    MM_GENERIC_CDMA_EVDO_REVA, evdo_revA,
+                                   MM_GENERIC_CDMA_REGISTRATION_TRY_CSS, try_css,
                                    NULL));
 }
 
