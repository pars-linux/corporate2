diff --git a/Makefile.am b/Makefile.am
index cda6437..7e34571 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,20 +1,21 @@
-SUBDIRS = marshallers
-
-SUBDIRS += \
-	   libnm-util \
-	   libnm-glib \
-	   src \
-	   include \
-	   introspection \
-	   callouts \
-	   system-settings \
-	   tools \
-	   policy \
-	   initscript \
-	   test \
-	   po \
-	   man \
-	   docs
+SUBDIRS = \
+	marshallers \
+	libnm-util \
+	libnm-glib \
+	src \
+	include \
+	introspection \
+	callouts \
+	system-settings \
+	cli \
+	tools \
+	policy \
+	initscript \
+	test \
+	po \
+	man \
+	docs \
+	examples
 
 EXTRA_DIST = \
 	CONTRIBUTING \
diff --git a/autogen.sh b/autogen.sh
index 7454373..213fb08 100755
diff --git a/cli/Makefile.am b/cli/Makefile.am
new file mode 100644
index 0000000..f268924
--- /dev/null
+++ b/cli/Makefile.am
@@ -0,0 +1,2 @@
+SUBDIRS = src
+
diff --git a/cli/src/Makefile.am b/cli/src/Makefile.am
new file mode 100644
index 0000000..2a1bd12
--- /dev/null
+++ b/cli/src/Makefile.am
@@ -0,0 +1,36 @@
+bin_PROGRAMS = \
+	nmcli
+
+INCLUDES = \
+	-I${top_srcdir} \
+	-I${top_srcdir}/include \
+	-I${top_builddir}/marshallers \
+	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/libnm-glib
+
+nmcli_SOURCES = \
+	connections.c \
+	connections.h \
+	devices.c \
+	devices.h \
+	network-manager.c \
+	network-manager.h \
+	nmcli.c \
+	nmcli.h \
+	utils.c \
+	utils.h
+
+nmcli_CPPFLAGS = \
+	$(DBUS_CFLAGS) \
+	$(GLIB_CFLAGS) \
+	-DNMCLI_LOCALEDIR=\"$(datadir)/locale\" \
+	-DG_DISABLE_DEPRECATED
+
+nmcli_LDADD = \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS) \
+	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/libnm-util/libnm-util.la \
+	$(top_builddir)/libnm-glib/libnm-glib.la
+
+
diff --git a/cli/src/connections.c b/cli/src/connections.c
new file mode 100644
index 0000000..ae09fe0
--- /dev/null
+++ b/cli/src/connections.c
@@ -0,0 +1,1261 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <signal.h>
+#include <netinet/ether.h>
+
+#include <nm-client.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-wired.h>
+#include <nm-setting-pppoe.h>
+#include <nm-setting-wireless.h>
+#include <nm-setting-gsm.h>
+#include <nm-setting-cdma.h>
+#include <nm-setting-bluetooth.h>
+#include <nm-setting-olpc-mesh.h>
+#include <nm-device-ethernet.h>
+#include <nm-device-wifi.h>
+#include <nm-gsm-device.h>
+#include <nm-cdma-device.h>
+#include <nm-device-bt.h>
+//#include <nm-device-olpc-mesh.h>
+#include <nm-remote-settings.h>
+#include <nm-remote-settings-system.h>
+#include <nm-settings-interface.h>
+#include <nm-settings-connection-interface.h>
+#include <nm-vpn-connection.h>
+
+#include "utils.h"
+#include "connections.h"
+
+
+typedef struct {
+	NmCli *nmc;
+	int argc;
+	char **argv;
+} ArgsInfo;
+
+extern GMainLoop *loop;   /* glib main loop variable */
+
+static ArgsInfo args_info;
+
+/* static function prototypes */
+static void usage (void);
+static void quit (void);
+static void show_connection (NMConnection *data, gpointer user_data);
+static NMConnection *find_connection (GSList *list, const char *filter_type, const char *filter_val);
+static gboolean find_device_for_connection (NmCli *nmc, NMConnection *connection, const char *iface, const char *ap,
+                                            NMDevice **device, const char **spec_object, GError **error);
+static const char *active_connection_state_to_string (NMActiveConnectionState state);
+static void active_connection_state_cb (NMActiveConnection *active, GParamSpec *pspec, gpointer user_data);
+static void activate_connection_cb (gpointer user_data, const char *path, GError *error);
+static void get_connections_cb (NMSettingsInterface *settings, gpointer user_data);
+static NMCResultCode do_connections_list (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_connections_status (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_connection_up (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_connection_down (NmCli *nmc, int argc, char **argv);
+
+static void
+usage (void)
+{
+	fprintf (stderr,
+	 	 _("Usage: nmcli con { COMMAND | help }\n"
+		 "  COMMAND := { list | status | up | down }\n\n"
+		 "  list [id <id> | uuid <id> | system | user]\n"
+		 "  status\n"
+		 "  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout <timeout>]\n"
+		 "  down id <id> | uuid <id>\n"));
+}
+
+/* quit main loop */
+static void
+quit (void)
+{
+	g_main_loop_quit (loop);  /* quit main loop */
+}
+
+static void
+show_connection (NMConnection *data, gpointer user_data)
+{
+	NMConnection *connection = (NMConnection *) data;
+	NMSettingConnection *s_con;
+	const char *id;
+	const char *uuid;
+	const char *con_type;
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	if (s_con) {
+		id = nm_setting_connection_get_id (s_con);
+		uuid = nm_setting_connection_get_uuid (s_con);
+		con_type = nm_setting_connection_get_connection_type (s_con);
+		print_table_line (0, con_type, 17, uuid, 38, id, 0, NULL);
+	}
+}
+
+static NMConnection *
+find_connection (GSList *list, const char *filter_type, const char *filter_val)
+{
+	NMSettingConnection *s_con;
+	NMConnection *connection;
+	GSList *iterator;
+	const char *id;
+	const char *uuid;
+
+	iterator = list;
+	while (iterator) {
+		connection = NM_CONNECTION (iterator->data);
+		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+		if (s_con) {
+			id = nm_setting_connection_get_id (s_con);
+			uuid = nm_setting_connection_get_uuid (s_con);
+			if (filter_type) {
+				if ((strcmp (filter_type, "id") == 0 && strcmp (filter_val, id) == 0) ||
+				    (strcmp (filter_type, "uuid") == 0 && strcmp (filter_val, uuid) == 0)) {
+					return connection;
+				}
+			}
+		}
+		iterator = g_slist_next (iterator);
+	}
+
+	return NULL;
+}
+
+static NMCResultCode
+do_connections_list (NmCli *nmc, int argc, char **argv)
+{
+	gboolean valid_param_specified = FALSE;
+
+	nmc->should_wait = FALSE;
+
+	if (argc == 0) {
+		valid_param_specified = TRUE;
+		if (nmc->print_output == NMC_PRINT_PRETTY)
+			print_table_header (_("Connections"), _("Type"), 17, _("UUID"), 38, _("Name"), 20, NULL);
+		else if (nmc->print_output == NMC_PRINT_NORMAL)
+			print_table_line (0, _("Type"), 17, _("UUID"), 38, _("Name"), 0, NULL);
+
+		if (nmc->print_output > NMC_PRINT_TERSE)
+			printf (_("System connections:\n"));
+		g_slist_foreach (nmc->system_connections, (GFunc) show_connection, NULL);
+
+		if (nmc->print_output > NMC_PRINT_TERSE)
+			printf (_("User connections:\n"));
+		g_slist_foreach (nmc->user_connections, (GFunc) show_connection, NULL);
+	}
+	else {
+		while (argc > 0) {
+			if (strcmp (*argv, "id") == 0 || strcmp (*argv, "uuid") == 0) {
+				const char *selector = *argv;
+				NMConnection *con1;
+				NMConnection *con2;
+
+				if (next_arg (&argc, &argv) != 0) {
+					g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+					goto error;
+				}
+				valid_param_specified = TRUE;
+
+				con1 = find_connection (nmc->system_connections, selector, *argv);
+				con2 = find_connection (nmc->user_connections, selector, *argv);
+				if (con1) nm_connection_dump (con1);
+				if (con2) nm_connection_dump (con2);
+				if (!con1 && !con2) {
+					g_string_printf (nmc->return_text, _("Error: %s - no such connection."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				}
+			}
+			else if (strcmp (*argv, "system") == 0) {
+				valid_param_specified = TRUE;
+				if (nmc->print_output == NMC_PRINT_PRETTY)
+					print_table_header (_("System-wide connections"), _("Type"), 17, _("UUID"), 38, _("Name"), 20, NULL);
+				else if (nmc->print_output == NMC_PRINT_NORMAL)
+					print_table_line (0, _("Type"), 17, _("UUID"), 38, _("Name"), 0, NULL);
+
+				g_slist_foreach (nmc->system_connections, (GFunc) show_connection, NULL);
+			}
+			else if (strcmp (*argv, "user") == 0) {
+				valid_param_specified = TRUE;
+				if (nmc->print_output == NMC_PRINT_PRETTY)
+					print_table_header (_("User connections"), _("Type"), 17, _("UUID"), 38, _("Name"), 20, NULL);
+				else if (nmc->print_output == NMC_PRINT_NORMAL)
+					print_table_line (0, _("Type"), 17, _("UUID"), 38, _("Name"), 0, NULL);
+
+				g_slist_foreach (nmc->user_connections, (GFunc) show_connection, NULL);
+			}
+			else {
+				fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+			}
+
+			argc--;
+			argv++;
+		}
+	}
+
+	if (!valid_param_specified) {
+		g_string_printf (nmc->return_text, _("Error: no valid parameter specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+	}
+
+error:
+	return nmc->return_value;
+}
+
+static void
+show_active_connection (gpointer data, gpointer user_data)
+{
+	NMActiveConnection *active = NM_ACTIVE_CONNECTION (data);
+	GSList *con_list = (GSList *) user_data;
+	GSList *iter;
+	const char *active_path;
+	NMConnectionScope active_service_scope;
+	NMSettingConnection *s_con;
+	const GPtrArray *devices;
+	GString *dev_str;
+	int i;
+
+	dev_str = g_string_new (NULL);
+
+	active_path = nm_active_connection_get_connection (active);
+	active_service_scope = nm_active_connection_get_scope (active);
+
+	/* Get devices of the active connection */
+	devices = nm_active_connection_get_devices (active);
+	for (i = 0; devices && (i < devices->len); i++) {
+		NMDevice *device = g_ptr_array_index (devices, i);
+
+		g_string_append (dev_str, nm_device_get_iface (device));
+		g_string_append_c (dev_str, ',');
+	}
+	if (dev_str->len > 0)
+		g_string_truncate (dev_str, dev_str->len - 1);  /* Cut off last ',' */
+
+	for (iter = con_list; iter; iter = g_slist_next (iter)) {
+		NMConnection *connection = (NMConnection *) iter->data;
+		const char *con_path = nm_connection_get_path (connection);
+		NMConnectionScope con_scope = nm_connection_get_scope (connection);
+
+		if (!strcmp (active_path, con_path) && active_service_scope == con_scope) {
+			/* this connection is active */
+			s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+			g_assert (s_con != NULL);
+			// FIXME: Fix the output
+			print_table_line (0, nm_active_connection_get_default (active) ? _("yes") : _("no"), 8,
+			                     nm_active_connection_get_service_name (active), 45,
+//			                     nm_active_connection_get_specific_object (active), 0,
+//			                     nm_active_connection_get_connection (active), 0,
+			                     dev_str->str, 10,
+			                     nm_setting_connection_get_uuid (s_con), 38,
+			                     nm_setting_connection_get_id (s_con), 0, NULL);
+
+		}
+	}
+
+	g_string_free (dev_str, TRUE);
+}
+
+static NMCResultCode
+do_connections_status (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *active_cons;
+
+	nmc->should_wait = FALSE;
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		return nmc->return_value;
+
+	active_cons = nm_client_get_active_connections (nmc->client);
+
+	// FIXME: Fix the output
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("Active connections"), _("Default"), 8, _("Service"), 45, _("Devices"), 10, _("UUID"), 38, _("Name"), 20, NULL);
+	else if (nmc->print_output == NMC_PRINT_NORMAL)
+		print_table_line (0, _("Default"), 8, _("Service"), 45, _("Devices"), 10, _("UUID"), 38, _("Name"), 0, NULL);
+
+	if (active_cons && active_cons->len) {
+		g_ptr_array_foreach ((GPtrArray *) active_cons, show_active_connection, (gpointer) nmc->system_connections);
+		g_ptr_array_foreach ((GPtrArray *) active_cons, show_active_connection, (gpointer) nmc->user_connections);
+	}
+
+	return NMC_RESULT_SUCCESS;
+}
+
+/* --------------------
+ * These function should be moved to libnm-glib in the end.
+ */
+static gboolean
+check_ethernet_compatible (NMDeviceEthernet *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	const char *connection_type;
+	gboolean is_pppoe = FALSE;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	connection_type = nm_setting_connection_get_connection_type (s_con);
+	if (   strcmp (connection_type, NM_SETTING_WIRED_SETTING_NAME)
+	    && strcmp (connection_type, NM_SETTING_PPPOE_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a wired or PPPoE connection.");
+		return FALSE;
+	}
+
+	if (!strcmp (connection_type, NM_SETTING_PPPOE_SETTING_NAME))
+		is_pppoe = TRUE;
+
+	s_wired = (NMSettingWired *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED);
+	/* Wired setting is optional for PPPoE */
+	if (!is_pppoe && !s_wired) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid wired connection.");
+		return FALSE;
+	}
+
+	if (s_wired) {
+		const GByteArray *mac;
+		const char *device_mac_str;
+		struct ether_addr *device_mac;
+
+		device_mac_str = nm_device_ethernet_get_hw_address (device);
+		device_mac = ether_aton (device_mac_str);
+		if (!device_mac) {
+			g_set_error (error, 0, 0, "Invalid device MAC address.");
+			return FALSE;
+		}
+
+		mac = nm_setting_wired_get_mac_address (s_wired);
+		if (mac && memcmp (mac->data, device_mac->ether_addr_octet, ETH_ALEN)) {
+			g_set_error (error, 0, 0,
+			             "The connection's MAC address did not match this device.");
+			return FALSE;
+		}
+	}
+
+	// FIXME: check bitrate against device capabilities
+
+	return TRUE;
+}
+
+static gboolean
+check_wifi_compatible (NMDeviceWifi *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_WIRELESS_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a WiFi connection.");
+		return FALSE;
+	}
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	if (!s_wireless) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid WiFi connection.");
+		return FALSE;
+	}
+
+	if (s_wireless) {
+		const GByteArray *mac;
+		const char *device_mac_str;
+		struct ether_addr *device_mac;
+
+		device_mac_str = nm_device_wifi_get_hw_address (device);
+		device_mac = ether_aton (device_mac_str);
+		if (!device_mac) {
+			g_set_error (error, 0, 0, "Invalid device MAC address.");
+			return FALSE;
+		}
+
+		mac = nm_setting_wireless_get_mac_address (s_wireless);
+		if (mac && memcmp (mac->data, device_mac->ether_addr_octet, ETH_ALEN)) {
+			g_set_error (error, 0, 0,
+		        	     "The connection's MAC address did not match this device.");
+			return FALSE;
+		}
+	}
+
+	// FIXME: check channel/freq/band against bands the hardware supports
+	// FIXME: check encryption against device capabilities
+	// FIXME: check bitrate against device capabilities
+
+	return TRUE;
+}
+
+static gboolean
+check_bt_compatible (NMDeviceBt *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingBluetooth *s_bt;
+	const GByteArray *array;
+	char *str;
+	const char *device_hw_str;
+	int addr_match = FALSE;
+	const char *bt_type_str;
+	guint32 bt_type, bt_capab;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_BLUETOOTH_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a Bluetooth connection.");
+		return FALSE;
+	}
+
+	s_bt = NM_SETTING_BLUETOOTH (nm_connection_get_setting (connection, NM_TYPE_SETTING_BLUETOOTH));
+	if (!s_bt) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid Bluetooth connection.");
+		return FALSE;
+	}
+
+	array = nm_setting_bluetooth_get_bdaddr (s_bt);
+	if (!array || (array->len != ETH_ALEN)) {
+		g_set_error (error, 0, 0,
+		             "The connection did not contain a valid Bluetooth address.");
+		return FALSE;
+	}
+
+	bt_type_str = nm_setting_bluetooth_get_connection_type (s_bt);
+	g_assert (bt_type_str);
+
+	bt_type = NM_BT_CAPABILITY_NONE;
+	if (!strcmp (bt_type_str, NM_SETTING_BLUETOOTH_TYPE_DUN))
+		bt_type = NM_BT_CAPABILITY_DUN;
+	else if (!strcmp (bt_type_str, NM_SETTING_BLUETOOTH_TYPE_PANU))
+		bt_type = NM_BT_CAPABILITY_NAP;
+
+	bt_capab = nm_device_bt_get_capabilities (device);
+	if (!(bt_type & bt_capab)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not compatible with the device's capabilities.");
+		return FALSE;
+	}
+
+	device_hw_str = nm_device_bt_get_hw_address (device);
+
+	str = g_strdup_printf ("%02X:%02X:%02X:%02X:%02X:%02X",
+	                       array->data[0], array->data[1], array->data[2],
+	                       array->data[3], array->data[4], array->data[5]);
+	addr_match = !strcmp (device_hw_str, str);
+	g_free (str);
+
+	return addr_match;
+}
+
+#if 0
+static gboolean
+check_olpc_mesh_compatible (NMDeviceOlpcMesh *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingOlpcMesh *s_mesh;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	g_assert (s_con);
+
+	if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_OLPC_MESH_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a Mesh connection.");
+		return FALSE;
+	}
+
+	s_mesh = NM_SETTING_OLPC_MESH (nm_connection_get_setting (connection, NM_TYPE_SETTING_OLPC_MESH));
+	if (!s_mesh) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid Mesh connection.");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+#endif
+
+static gboolean
+nm_device_is_connection_compatible (NMDevice *device, NMConnection *connection, GError **error)
+{
+	g_return_val_if_fail (NM_IS_DEVICE (device), FALSE);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
+
+	if (NM_IS_DEVICE_ETHERNET (device))
+		return check_ethernet_compatible (NM_DEVICE_ETHERNET (device), connection, error);
+	else if (NM_IS_DEVICE_WIFI (device))
+		return check_wifi_compatible (NM_DEVICE_WIFI (device), connection, error);
+	else if (NM_IS_DEVICE_BT (device))
+		return check_bt_compatible (NM_DEVICE_BT (device), connection, error);
+//	else if (NM_IS_DEVICE_OLPC_MESH (device))
+//		return check_olpc_mesh_compatible (NM_DEVICE_OLPC_MESH (device), connection, error);
+
+	g_set_error (error, 0, 0, "unhandled device type '%s'", G_OBJECT_TYPE_NAME (device));
+	return FALSE;
+}
+
+
+/**
+ * nm_client_get_active_connection_by_path:
+ * @client: a #NMClient
+ * @object_path: the object path to search for
+ *
+ * Gets a #NMActiveConnection from a #NMClient.
+ *
+ * Returns: the #NMActiveConnection for the given @object_path or %NULL if none is found.
+ **/
+static NMActiveConnection *
+nm_client_get_active_connection_by_path (NMClient *client, const char *object_path)
+{
+	const GPtrArray *actives;
+	int i;
+	NMActiveConnection *active = NULL;
+
+	g_return_val_if_fail (NM_IS_CLIENT (client), NULL);
+	g_return_val_if_fail (object_path, NULL);
+
+	actives = nm_client_get_active_connections (client);
+	if (!actives)
+		return NULL;
+
+	for (i = 0; i < actives->len; i++) {
+		NMActiveConnection *candidate = g_ptr_array_index (actives, i);
+		if (!strcmp (nm_object_get_path (NM_OBJECT (candidate)), object_path)) {
+			active = candidate;
+			break;
+		}
+	}
+
+	return active;
+}
+/* -------------------- */
+
+static NMActiveConnection *
+get_default_active_connection (NmCli *nmc, NMDevice **device)
+{
+	NMActiveConnection *default_ac = NULL;
+	NMDevice *non_default_device = NULL;
+	NMActiveConnection *non_default_ac = NULL;
+	const GPtrArray *connections;
+	int i;
+
+	g_return_val_if_fail (nmc != NULL, NULL);
+	g_return_val_if_fail (device != NULL, NULL);
+	g_return_val_if_fail (*device == NULL, NULL);
+
+	connections = nm_client_get_active_connections (nmc->client);
+	for (i = 0; connections && (i < connections->len); i++) {
+		NMActiveConnection *candidate = g_ptr_array_index (connections, i);
+		const GPtrArray *devices;
+
+		devices = nm_active_connection_get_devices (candidate);
+		if (!devices || !devices->len)
+			continue;
+
+		if (nm_active_connection_get_default (candidate)) {
+			if (!default_ac) {
+				*device = g_ptr_array_index (devices, 0);
+				default_ac = candidate;
+			}
+		} else {
+			if (!non_default_ac) {
+				non_default_device = g_ptr_array_index (devices, 0);
+				non_default_ac = candidate;
+			}
+		}
+	}
+
+	/* Prefer the default connection if one exists, otherwise return the first
+	 * non-default connection.
+	 */
+	if (!default_ac && non_default_ac) {
+		default_ac = non_default_ac;
+		*device = non_default_device;
+	}
+	return default_ac;
+}
+
+/* Find a device to activate the connection on.
+ * IN:  connection:  connection to activate
+ *      iface:       device interface name to use (optional)
+ *      ap:          access point to use (optional; valid just for 802-11-wireless)
+ * OUT: device:      found device
+ *      spec_object: specific_object path of NMAccessPoint
+ * RETURNS: TRUE when a device is found, FALSE otherwise.
+ */
+static gboolean
+find_device_for_connection (NmCli *nmc, NMConnection *connection, const char *iface, const char *ap,
+                            NMDevice **device, const char **spec_object, GError **error)
+{
+	NMSettingConnection *s_con;
+	const char *con_type;
+	int i, j;
+
+	g_return_val_if_fail (nmc != NULL, FALSE);
+	g_return_val_if_fail (device != NULL && *device == NULL, FALSE);
+	g_return_val_if_fail (spec_object != NULL && *spec_object == NULL, FALSE);
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_assert (s_con);
+	con_type = nm_setting_connection_get_connection_type (s_con);
+
+	if (strcmp (con_type, "vpn") == 0) {
+		/* VPN connections */
+		NMActiveConnection *active = NULL;
+		if (iface) {
+			const GPtrArray *connections = nm_client_get_active_connections (nmc->client);
+			for (i = 0; connections && (i < connections->len) && !active; i++) {
+				NMActiveConnection *candidate = g_ptr_array_index (connections, i);
+				const GPtrArray *devices = nm_active_connection_get_devices (candidate);
+				if (!devices || !devices->len)
+					continue;
+
+				for (j = 0; devices && (j < devices->len); j++) {
+					NMDevice *dev = g_ptr_array_index (devices, j);
+					if (!strcmp (iface, nm_device_get_iface (dev))) {
+						active = candidate;
+						*device = dev;
+						break;
+					}
+				}
+			}
+			if (!active) {
+				g_set_error (error, 0, 0, _("no active connection on device '%s'"), iface);
+				return FALSE;
+			}
+			*spec_object = nm_object_get_path (NM_OBJECT (active));
+			return TRUE;
+		} else {
+			active = get_default_active_connection (nmc, device);
+			if (!active) {
+				g_set_error (error, 0, 0, _("no active connection or device"));
+				return FALSE;
+			}
+			*spec_object = nm_object_get_path (NM_OBJECT (active));
+			return TRUE;
+		}
+	} else {
+		/* Other connections */
+		NMDevice *found_device = NULL;
+		const GPtrArray *devices = nm_client_get_devices (nmc->client);
+
+		for (i = 0; devices && (i < devices->len) && !found_device; i++) {
+			NMDevice *dev = g_ptr_array_index (devices, i);
+
+			if (iface) {
+				const char *dev_iface = nm_device_get_iface (dev);
+				if (   !strcmp (dev_iface, iface)
+				    && nm_device_is_connection_compatible (dev, connection, NULL)) {
+					found_device = dev;
+				}
+			} else {
+				if (nm_device_is_connection_compatible (dev, connection, NULL)) {
+					found_device = dev;
+				}
+			}
+
+			if (found_device && ap && !strcmp (con_type, "802-11-wireless") && NM_IS_DEVICE_WIFI (dev)) {
+				char *hwaddr_up = g_ascii_strup (ap, -1);
+				const GPtrArray *aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (dev));
+				found_device = NULL;  /* Mark as not found; set to the device again later, only if AP matches */
+
+				for (j = 0; aps && (j < aps->len); j++) {
+					NMAccessPoint *candidate_ap = g_ptr_array_index (aps, j);
+					const char *candidate_hwaddr = nm_access_point_get_hw_address (candidate_ap);
+
+					if (!strcmp (hwaddr_up, candidate_hwaddr)) {
+						found_device = dev;
+						*spec_object = nm_object_get_path (NM_OBJECT (candidate_ap));
+						break;
+					}
+				}
+				g_free (hwaddr_up);
+			}
+		}
+
+		if (found_device) {
+			*device = found_device;
+			return TRUE;
+		} else {
+			if (iface)
+				g_set_error (error, 0, 0, "device '%s' not compatible with connection '%s'", iface, nm_setting_connection_get_id (s_con));
+			else
+				g_set_error (error, 0, 0, "no device found for connection '%s'", nm_setting_connection_get_id (s_con));
+			return FALSE;
+		}
+	}
+}
+
+static const char *
+active_connection_state_to_string (NMActiveConnectionState state)
+{
+	switch (state) {
+	case NM_ACTIVE_CONNECTION_STATE_ACTIVATING:
+		return _("activating");
+	case NM_ACTIVE_CONNECTION_STATE_ACTIVATED:
+		return _("activated");
+	case NM_ACTIVE_CONNECTION_STATE_UNKNOWN:
+	default:
+		return _("unknown");
+	}
+}
+
+static const char *
+vpn_connection_state_to_string (NMVPNConnectionState state)
+{
+	switch (state) {
+	case NM_VPN_CONNECTION_STATE_PREPARE:
+		return _("VPN connecting (prepare)");
+	case NM_VPN_CONNECTION_STATE_NEED_AUTH:
+		return _("VPN connecting (need authentication)");
+	case NM_VPN_CONNECTION_STATE_CONNECT:
+		return _("VPN connecting");
+	case NM_VPN_CONNECTION_STATE_IP_CONFIG_GET:
+		return _("VPN connecting (getting IP configuration)");
+	case NM_VPN_CONNECTION_STATE_ACTIVATED:
+		return _("VPN connected");
+	case NM_VPN_CONNECTION_STATE_FAILED:
+		return _("VPN connection failed");
+	case NM_VPN_CONNECTION_STATE_DISCONNECTED:
+		return _("VPN disconnected");
+	default:
+		return _("unknown");
+	}
+}
+
+static const char *
+vpn_connection_state_reason_to_string (NMVPNConnectionStateReason reason)
+{
+	switch (reason) {
+	case NM_VPN_CONNECTION_STATE_REASON_UNKNOWN:
+		return _("unknown reason");
+	case NM_VPN_CONNECTION_STATE_REASON_NONE:
+		return _("none");
+	case NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED:
+		return _("the user was disconnected");
+	case NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED:
+		return _("the base network connection was interrupted");
+	case NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED:
+		return _("the VPN service stopped unexpectedly");
+	case NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID:
+		return _("the VPN service returned invalid configuration");
+	case NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT:
+		return _("the connection attempt timed out");
+	case NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT:
+		return _("the VPN service did not start in time");
+	case NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED:
+		return _("the VPN service failed to start");
+	case NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS:
+		return _("no valid VPN secrets");
+	case NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED:
+		return _("invalid VPN secrets");
+	case NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED:
+		return _("the connection was removed");
+	default:
+		return _("unknown");
+	}
+}
+
+static void
+active_connection_state_cb (NMActiveConnection *active, GParamSpec *pspec, gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMActiveConnectionState state;
+
+	state = nm_active_connection_get_state (active);
+
+	printf (_("state: %s\n"), active_connection_state_to_string (state));
+
+	if (state == NM_ACTIVE_CONNECTION_STATE_ACTIVATED) {
+		printf (_("Connection activated\n"));
+		quit ();
+	} else if (state == NM_ACTIVE_CONNECTION_STATE_UNKNOWN) { 
+		g_string_printf (nmc->return_text, _("Error: Connection activation failed."));
+		nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		quit ();
+	}
+}
+
+static void
+vpn_connection_state_cb (NMVPNConnection *vpn,
+                         NMVPNConnectionState state,
+                         NMVPNConnectionStateReason reason,
+                         gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+
+	switch (state) {
+	case NM_VPN_CONNECTION_STATE_PREPARE:
+	case NM_VPN_CONNECTION_STATE_NEED_AUTH:
+	case NM_VPN_CONNECTION_STATE_CONNECT:
+	case NM_VPN_CONNECTION_STATE_IP_CONFIG_GET:
+		printf (_("state: %s (%d)\n"), vpn_connection_state_to_string (state), state);
+		break;
+
+	case NM_VPN_CONNECTION_STATE_ACTIVATED:
+		printf (_("Connection activated\n"));
+		quit ();
+		break;
+
+	case NM_VPN_CONNECTION_STATE_FAILED:
+	case NM_VPN_CONNECTION_STATE_DISCONNECTED:
+		g_string_printf (nmc->return_text, _("Error: Connection activation failed: %s."), vpn_connection_state_reason_to_string (reason));
+		nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		quit ();
+		break;
+
+	default:
+		break;
+	}
+}
+
+static gboolean
+timeout_cb (gpointer user_data)
+{
+	/* Time expired -> exit nmcli */
+
+	NmCli *nmc = (NmCli *) user_data;
+
+	g_string_printf (nmc->return_text, _("Error: Timeout %d sec expired."), nmc->timeout);
+	nmc->return_value = NMC_RESULT_ERROR_TIMEOUT_EXPIRED;
+	quit ();
+	return FALSE;
+}
+
+static void
+foo_active_connections_changed_cb (NMClient *client,
+                                   GParamSpec *pspec,
+                                   gpointer user_data)
+{
+	/* Call again activate_connection_cb with dummy arguments;
+	 * the correct ones are taken from its first call.
+	 */
+	activate_connection_cb (NULL, NULL, NULL);
+}
+
+static void
+activate_connection_cb (gpointer user_data, const char *path, GError *error)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMActiveConnection *active;
+	NMActiveConnectionState state;
+	static gulong handler_id = 0;
+	static NmCli *orig_nmc;
+	static const char *orig_path;
+	static GError *orig_error;
+
+	if (nmc)
+	{
+		/* Called first time; store actual arguments */
+		orig_nmc = nmc;
+		orig_path = path;
+		orig_error = error;
+	}
+
+	/* Disconnect the handler not to be run any more */
+	if (handler_id != 0) {
+		g_signal_handler_disconnect (orig_nmc->client, handler_id);
+		handler_id = 0;
+	}
+
+	if (orig_error) {
+		g_string_printf (orig_nmc->return_text, _("Error: Connection activation failed: %s"), orig_error->message);
+		orig_nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		quit ();
+	} else {
+		active = nm_client_get_active_connection_by_path (orig_nmc->client, orig_path);
+		if (!active) {
+			/* The active connection path is not in active connections list yet; wait for active-connections signal. */
+			/* This is basically the case for VPN connections. */
+			if (nmc) {
+				/* Called first time, i.e. by nm_client_activate_connection() */
+				handler_id = g_signal_connect (orig_nmc->client, "notify::active-connections",
+				                               G_CALLBACK (foo_active_connections_changed_cb), NULL);
+				return;
+			} else {
+				g_string_printf (orig_nmc->return_text, _("Error: Obtaining active connection for '%s' failed."), orig_path);
+				orig_nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+				quit ();
+				return;
+			}
+		}
+
+		state = nm_active_connection_get_state (active);
+
+		printf (_("Active connection state: %s\n"), active_connection_state_to_string (state));
+		printf (_("Active connection path: %s\n"), orig_path);
+
+		if (!orig_nmc->should_wait || state == NM_ACTIVE_CONNECTION_STATE_ACTIVATED) {
+			/* don't want to wait or already activated */
+			quit ();
+		} else {
+			if (NM_IS_VPN_CONNECTION (active))
+				g_signal_connect (NM_VPN_CONNECTION (active), "vpn-state-changed", G_CALLBACK (vpn_connection_state_cb), orig_nmc);
+			else
+				g_signal_connect (active, "notify::state", G_CALLBACK (active_connection_state_cb), orig_nmc);
+
+			/* Start timer not to loop forever when signals are not emitted */
+			g_timeout_add_seconds (orig_nmc->timeout, timeout_cb, orig_nmc);
+		}
+	}
+}
+
+static NMCResultCode
+do_connection_up (NmCli *nmc, int argc, char **argv)
+{
+	NMDevice *device = NULL;
+	const char *spec_object = NULL;
+	gboolean device_found;
+	NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	gboolean is_system;
+	const char *con_path;
+	const char *con_type;
+	const char *iface = NULL;
+	const char *ap = NULL;
+	gboolean id_specified = FALSE;
+	gboolean wait = TRUE;
+	GError *error = NULL;
+
+	/* Set default timeout for connection activation. It can take quite a long time.
+	 * Using 90 seconds.
+	 */
+	nmc->timeout = 90;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "id") == 0 || strcmp (*argv, "uuid") == 0) {
+			const char *selector = *argv;
+			id_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			if ((connection = find_connection (nmc->system_connections, selector, *argv)) == NULL)
+				connection = find_connection (nmc->user_connections, selector, *argv);
+
+			if (!connection) {
+				g_string_printf (nmc->return_text, _("Error: Unknown connection: %s."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+		}
+		else if (strcmp (*argv, "iface") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		}
+		else if (strcmp (*argv, "ap") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			ap = *argv;
+		}
+		else if (strcmp (*argv, "--nowait") == 0) {
+			wait = FALSE;
+		} else if (strcmp (*argv, "--timeout") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			errno = 0;
+			nmc->timeout = strtol (*argv, NULL, 10);
+			if (errno || nmc->timeout < 0) {
+				g_string_printf (nmc->return_text, _("Error: timeout value '%s' is not valid."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!id_specified) {
+		g_string_printf (nmc->return_text, _("Error: id or uuid has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	is_system = (nm_connection_get_scope (connection) == NM_CONNECTION_SCOPE_SYSTEM) ? TRUE : FALSE;
+	con_path = nm_connection_get_path (connection);
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_assert (s_con);
+	con_type = nm_setting_connection_get_connection_type (s_con);
+
+	device_found = find_device_for_connection (nmc, connection, iface, ap, &device, &spec_object, &error);
+
+	if (!device_found) {
+		if (error)
+			g_string_printf (nmc->return_text, _("Error: No suitable device found: %s."), error->message);
+		else
+			g_string_printf (nmc->return_text, _("Error: No suitable device found."));
+		nmc->return_value = NMC_RESULT_ERROR_CON_ACTIVATION;
+		goto error;
+	}
+
+	nmc->should_wait = wait;
+	nm_client_activate_connection (nmc->client,
+	                               is_system ? NM_DBUS_SERVICE_SYSTEM_SETTINGS : NM_DBUS_SERVICE_USER_SETTINGS,
+	                               con_path,
+	                               device,
+	                               spec_object,
+	                               activate_connection_cb,
+	                               nmc);
+
+	return nmc->return_value;
+error:
+	nmc->should_wait = FALSE;
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_connection_down (NmCli *nmc, int argc, char **argv)
+{
+	NMConnection *connection = NULL;
+	NMActiveConnection *active = NULL;
+	const GPtrArray *active_cons;
+	const char *con_path;
+	const char *active_path;
+	NMConnectionScope active_service_scope, con_scope;
+	gboolean id_specified = FALSE;
+	gboolean wait = TRUE;
+	int i;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "id") == 0 || strcmp (*argv, "uuid") == 0) {
+			const char *selector = *argv;
+			id_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			if ((connection = find_connection (nmc->system_connections, selector, *argv)) == NULL)
+				connection = find_connection (nmc->user_connections, selector, *argv);
+
+			if (!connection) {
+				g_string_printf (nmc->return_text, _("Error: Unknown connection: %s."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+		}
+		else if (strcmp (*argv, "--nowait") == 0) {
+			wait = FALSE;
+		}
+		else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!id_specified) {
+		g_string_printf (nmc->return_text, _("Error: id or uuid has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	con_path = nm_connection_get_path (connection);
+	con_scope = nm_connection_get_scope (connection);
+
+	active_cons = nm_client_get_active_connections (nmc->client);
+	for (i = 0; active_cons && (i < active_cons->len); i++) {
+		NMActiveConnection *candidate = g_ptr_array_index (active_cons, i);
+
+		active_path = nm_active_connection_get_connection (candidate);
+		active_service_scope = nm_active_connection_get_scope (candidate);
+		if (!strcmp (active_path, con_path) && active_service_scope == con_scope) {
+			active = candidate;
+			break;
+		}
+	}
+
+	if (active)
+		nm_client_deactivate_connection (nmc->client, active);
+	else {
+		fprintf (stderr, _("Warning: Connection not active\n"));
+	}
+
+error:
+	nmc->should_wait = FALSE;
+	return nmc->return_value;
+}
+
+/* callback called when connections are obtained from the settings service */
+static void
+get_connections_cb (NMSettingsInterface *settings, gpointer user_data)
+{
+	ArgsInfo *args = (ArgsInfo *) user_data;
+	static gboolean system_cb_called = FALSE;
+	static gboolean user_cb_called = FALSE;
+
+	if (NM_IS_REMOTE_SETTINGS_SYSTEM (settings)) {
+		system_cb_called = TRUE;
+		args->nmc->system_connections = nm_settings_interface_list_connections (settings);
+	}
+	else {
+		user_cb_called = TRUE;
+		args->nmc->user_connections = nm_settings_interface_list_connections (settings);
+	}
+
+	/* return and wait for the callback of the second settings is called */
+	if ((args->nmc->system_settings_running && !system_cb_called) || 
+	    (args->nmc->user_settings_running && !user_cb_called))
+		return;
+
+	if (args->argc == 0) {
+		args->nmc->return_value = do_connections_list (args->nmc, args->argc, args->argv);
+	} else {
+
+	 	if (matches (*args->argv, "list") == 0) {
+			args->nmc->return_value = do_connections_list (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches(*args->argv, "status") == 0) {
+			args->nmc->return_value = do_connections_status (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches(*args->argv, "up") == 0) {
+			args->nmc->return_value = do_connection_up (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches(*args->argv, "down") == 0) {
+			args->nmc->return_value = do_connection_down (args->nmc, args->argc-1, args->argv+1);
+		}
+		else if (matches (*args->argv, "help") == 0) {
+			usage ();
+			args->nmc->should_wait = FALSE;
+		} else {
+			usage ();
+			g_string_printf (args->nmc->return_text, _("Error: 'con' command '%s' is not valid."), *args->argv);
+			args->nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			args->nmc->should_wait = FALSE;
+		}
+	}
+
+	if (!args->nmc->should_wait)
+		quit ();
+}
+
+
+/* Entry point function for connections-related commands: 'nmcli con' */
+NMCResultCode
+do_connections (NmCli *nmc, int argc, char **argv)
+{
+	DBusGConnection *bus;
+	GError *error = NULL;
+
+	nmc->should_wait = TRUE;
+
+	args_info.nmc = nmc;
+	args_info.argc = argc;
+	args_info.argv = argv;
+
+	/* connect to DBus' system bus */
+	bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (error || !bus) {
+		g_string_printf (nmc->return_text, _("Error: could not connect to D-Bus."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+	}
+
+	/* get system settings */
+	if (!(nmc->system_settings = nm_remote_settings_system_new (bus))) {
+		g_string_printf (nmc->return_text, _("Error: Could not get system settings."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+
+	}
+
+	/* get user settings */
+	if (!(nmc->user_settings = nm_remote_settings_new (bus, NM_CONNECTION_SCOPE_USER))) {
+		g_string_printf (nmc->return_text, _("Error: Could not get user settings."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+	}
+
+	/* find out whether setting services are running */
+	g_object_get (nmc->system_settings, NM_REMOTE_SETTINGS_SERVICE_RUNNING, &nmc->system_settings_running, NULL);
+	g_object_get (nmc->user_settings, NM_REMOTE_SETTINGS_SERVICE_RUNNING, &nmc->user_settings_running, NULL);
+
+	if (!nmc->system_settings_running && !nmc->user_settings_running) {
+		g_string_printf (nmc->return_text, _("Error: Can't obtain connections: settings services are not running."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		return nmc->return_value;
+	}
+
+	/* connect to signal "connections-read" - emitted when connections are fetched and ready */
+	if (nmc->system_settings_running)
+		g_signal_connect (nmc->system_settings, NM_SETTINGS_INTERFACE_CONNECTIONS_READ,
+		                  G_CALLBACK (get_connections_cb), &args_info);
+
+	if (nmc->user_settings_running)
+		g_signal_connect (nmc->user_settings, NM_SETTINGS_INTERFACE_CONNECTIONS_READ,
+		                  G_CALLBACK (get_connections_cb), &args_info);
+
+	dbus_g_connection_unref (bus);
+
+	/* The rest will be done in get_connection_cb() callback.
+	 * We need to wait for signals that connections are read.
+	 */
+	return NMC_RESULT_SUCCESS;
+}
diff --git a/cli/src/connections.h b/cli/src/connections.h
new file mode 100644
index 0000000..a1ed1c1
--- /dev/null
+++ b/cli/src/connections.h
@@ -0,0 +1,27 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_CONNECTIONS_H
+#define NMC_CONNECTIONS_H
+
+#include "nmcli.h"
+
+NMCResultCode do_connections (NmCli *nmc, int argc, char **argv);
+
+#endif /* NMC_CONNECTIONS_H */
diff --git a/cli/src/devices.c b/cli/src/devices.c
new file mode 100644
index 0000000..d6c0b43
--- /dev/null
+++ b/cli/src/devices.c
@@ -0,0 +1,950 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <nm-client.h>
+#include <nm-device-wifi.h>
+
+#include <nm-client.h>
+#include <nm-device.h>
+#include <nm-device-ethernet.h>
+#include <nm-device-wifi.h>
+#include <nm-gsm-device.h>
+#include <nm-cdma-device.h>
+#include <nm-device-bt.h>
+//#include <nm-device-olpc-mesh.h>
+#include <nm-utils.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-vpn-connection.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-wired.h>
+#include <nm-setting-pppoe.h>
+#include <nm-setting-wireless.h>
+#include <nm-setting-gsm.h>
+#include <nm-setting-cdma.h>
+#include <nm-setting-bluetooth.h>
+#include <nm-setting-olpc-mesh.h>
+
+#include "utils.h"
+#include "devices.h"
+
+
+/* static function prototypes */
+static void usage (void);
+static const char *device_state_to_string (NMDeviceState state);
+static NMCResultCode do_devices_status (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_devices_list (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_device_disconnect (NmCli *nmc, int argc, char **argv);
+static NMCResultCode do_device_wifi (NmCli *nmc, int argc, char **argv);
+
+
+extern GMainLoop *loop;   /* glib main loop variable */
+
+static void
+usage (void)
+{
+	fprintf (stderr,
+	 	 _("Usage: nmcli dev { COMMAND | help }\n\n"
+		 "  COMMAND := { status | list | disconnect | wifi }\n\n"
+		 "  status\n"
+		 "  list [iface <iface>]\n"
+		 "  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+		 "  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n\n"));
+}
+
+/* quit main loop */
+static void
+quit (void)
+{
+	g_main_loop_quit (loop);  /* quit main loop */
+}
+
+static const char *
+device_state_to_string (NMDeviceState state)
+{
+	switch (state) {
+	case NM_DEVICE_STATE_UNMANAGED:
+		return _("unmanaged");
+	case NM_DEVICE_STATE_UNAVAILABLE:
+		return _("unavailable");
+	case NM_DEVICE_STATE_DISCONNECTED:
+		return _("disconnected");
+	case NM_DEVICE_STATE_PREPARE:
+		return _("connecting (prepare)");
+	case NM_DEVICE_STATE_CONFIG:
+		return _("connecting (configuring)");
+	case NM_DEVICE_STATE_NEED_AUTH:
+		return _("connecting (need authentication)");
+	case NM_DEVICE_STATE_IP_CONFIG:
+		return _("connecting (getting IP configuration)");
+	case NM_DEVICE_STATE_ACTIVATED:
+		return _("connected");
+	case NM_DEVICE_STATE_FAILED:
+		return _("connection failed");
+	default:
+		return _("unknown");
+	}
+}
+
+/* Return device type - use setting names to match with connection types */
+static const char *
+get_device_type (NMDevice * device)
+{
+	if (NM_IS_DEVICE_ETHERNET (device))
+		return NM_SETTING_WIRED_SETTING_NAME;
+	else if (NM_IS_DEVICE_WIFI (device))
+		return NM_SETTING_WIRELESS_SETTING_NAME;
+	else if (NM_IS_GSM_DEVICE (device))
+		return NM_SETTING_GSM_SETTING_NAME;
+	else if (NM_IS_CDMA_DEVICE (device))
+		return NM_SETTING_CDMA_SETTING_NAME;
+	else if (NM_IS_DEVICE_BT (device))
+		return NM_SETTING_BLUETOOTH_SETTING_NAME;
+//	else if (NM_IS_DEVICE_OLPC_MESH (device))
+//		return NM_SETTING_OLPC_MESH_SETTING_NAME;
+	else
+		return _("Unknown");
+}
+
+static char *
+ap_wpa_rsn_flags_to_string (guint32 flags)
+{
+	char *flags_str[16]; /* Enough space for flags and terminating NULL */
+	char *ret_str;
+	int i = 0;
+
+	if (flags & NM_802_11_AP_SEC_PAIR_WEP40)
+		flags_str[i++] = g_strdup ("pair_wpe40");
+	if (flags & NM_802_11_AP_SEC_PAIR_WEP104)
+		flags_str[i++] = g_strdup ("pair_wpe104");
+	if (flags & NM_802_11_AP_SEC_PAIR_TKIP)
+		flags_str[i++] = g_strdup ("pair_tkip");
+	if (flags & NM_802_11_AP_SEC_PAIR_CCMP)
+		flags_str[i++] = g_strdup ("pair_ccmp");
+	if (flags & NM_802_11_AP_SEC_GROUP_WEP40)
+		flags_str[i++] = g_strdup ("group_wpe40");
+	if (flags & NM_802_11_AP_SEC_GROUP_WEP104)
+		flags_str[i++] = g_strdup ("group_wpe104");
+	if (flags & NM_802_11_AP_SEC_GROUP_TKIP)
+		flags_str[i++] = g_strdup ("group_tkip");
+	if (flags & NM_802_11_AP_SEC_GROUP_CCMP)
+		flags_str[i++] = g_strdup ("group_ccmp");
+	if (flags & NM_802_11_AP_SEC_KEY_MGMT_PSK)
+		flags_str[i++] = g_strdup ("psk");
+	if (flags & NM_802_11_AP_SEC_KEY_MGMT_802_1X)
+		flags_str[i++] = g_strdup ("802.1X");
+
+	if (i == 0)
+		flags_str[i++] = g_strdup (_("(none)"));
+
+	flags_str[i] = NULL;
+
+	ret_str = g_strjoinv (" ", flags_str);
+
+	i = 0;
+	while (flags_str[i])
+		 g_free (flags_str[i++]);
+
+	return ret_str;
+}
+
+static void
+print_header (const char *label, const char *iface, const char *connection)
+{
+	GString *string;
+
+	string = g_string_sized_new (79);
+	g_string_append_printf (string, "- %s: ", label);
+	if (iface)
+		g_string_append_printf (string, "%s ", iface);
+	if (connection)
+		g_string_append_printf (string, " [%s] ", connection);
+
+	while (string->len < 80)
+		g_string_append_c (string, '-');
+
+	printf ("%s\n", string->str);
+
+	g_string_free (string, TRUE);
+}
+
+static gchar *
+ip4_address_as_string (guint32 ip)
+{
+	struct in_addr tmp_addr;
+	char buf[INET_ADDRSTRLEN+1];
+
+	memset (&buf, '\0', sizeof (buf));
+	tmp_addr.s_addr = ip;
+
+	if (inet_ntop (AF_INET, &tmp_addr, buf, INET_ADDRSTRLEN)) {
+		return g_strdup (buf);
+	} else {
+		g_warning (_("%s: error converting IP4 address 0x%X"),
+		            __func__, ntohl (tmp_addr.s_addr));
+		return NULL;
+	}
+}
+
+static void
+detail_access_point (gpointer data, gpointer user_data)
+{
+	NMAccessPoint *ap = NM_ACCESS_POINT (data);
+	const char *active_bssid = (const char *) user_data;
+	GString *str;
+	gboolean active = FALSE;
+	guint32 flags, wpa_flags, rsn_flags;
+	const GByteArray * ssid;
+	char *tmp;
+
+	flags = nm_access_point_get_flags (ap);
+	wpa_flags = nm_access_point_get_wpa_flags (ap);
+	rsn_flags = nm_access_point_get_rsn_flags (ap);
+
+	if (active_bssid) {
+		const char *current_bssid = nm_access_point_get_hw_address (ap);
+		if (current_bssid && !strcmp (current_bssid, active_bssid))
+			active = TRUE;
+	}
+
+	str = g_string_new (NULL);
+	g_string_append_printf (str,
+	                        _("%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"),
+	                        (nm_access_point_get_mode (ap) == NM_802_11_MODE_INFRA) ? ("Infra") : _("Ad-Hoc"),
+	                        nm_access_point_get_hw_address (ap),
+	                        nm_access_point_get_frequency (ap),
+	                        nm_access_point_get_max_bitrate (ap) / 1000,
+	                        nm_access_point_get_strength (ap));
+
+	if (   !(flags & NM_802_11_AP_FLAGS_PRIVACY)
+	    &&  (wpa_flags != NM_802_11_AP_SEC_NONE)
+	    &&  (rsn_flags != NM_802_11_AP_SEC_NONE))
+		g_string_append (str, _(", Encrypted: "));
+
+	if (   (flags & NM_802_11_AP_FLAGS_PRIVACY)
+	    && (wpa_flags == NM_802_11_AP_SEC_NONE)
+	    && (rsn_flags == NM_802_11_AP_SEC_NONE))
+		g_string_append (str, _(" WEP"));
+	if (wpa_flags != NM_802_11_AP_SEC_NONE)
+		g_string_append (str, _(" WPA"));
+	if (rsn_flags != NM_802_11_AP_SEC_NONE)
+		g_string_append (str, _(" WPA2"));
+	if (   (wpa_flags & NM_802_11_AP_SEC_KEY_MGMT_802_1X)
+	    || (rsn_flags & NM_802_11_AP_SEC_KEY_MGMT_802_1X))
+		g_string_append (str, _(" Enterprise"));
+
+	/* FIXME: broadcast/hidden */
+
+	ssid = nm_access_point_get_ssid (ap);
+	tmp = g_strdup_printf ("  %s%s", active ? "*" : "",
+	                       ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : _("(none)"));
+
+	print_table_line (0, tmp, 25, str->str, 0, NULL);
+
+	g_string_free (str, TRUE);
+	g_free (tmp);
+}
+
+struct cb_info {
+	NMClient *client;
+	const GPtrArray *active;
+};
+
+static void
+show_device_info (gpointer data, gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (data);
+//	struct cb_info *info = user_data;
+	char *tmp;
+	NMDeviceState state;
+	const char *dev_type;
+	guint32 caps;
+	guint32 speed;
+	const GArray *array;
+	gboolean is_default = FALSE;
+	const char *id = NULL;
+
+	state = nm_device_get_state (device);
+	print_header (_("Device"), nm_device_get_iface (device), id);
+
+	/* General information */
+	dev_type = get_device_type (device);
+	print_table_line (0, _("Type"), 25, dev_type, 0, NULL);
+	print_table_line (0, _("Driver"), 25, nm_device_get_driver (device) ? nm_device_get_driver (device) : _("(unknown)"), 0, NULL);
+	print_table_line (0, _("State"), 25, device_state_to_string (state), 0, NULL);
+	if (is_default)
+		print_table_line (0, _("Default"), 25, _("yes"), 0, NULL);
+	else
+		print_table_line (0, _("Default"), 25, _("no"), 0, NULL);
+
+	tmp = NULL;
+	if (NM_IS_DEVICE_ETHERNET (device))
+		tmp = g_strdup (nm_device_ethernet_get_hw_address (NM_DEVICE_ETHERNET (device)));
+	else if (NM_IS_DEVICE_WIFI (device))
+		tmp = g_strdup (nm_device_wifi_get_hw_address (NM_DEVICE_WIFI (device)));
+
+	if (tmp) {
+		print_table_line (0, _("HW Address"), 25, tmp, 0, NULL);
+		g_free (tmp);
+	}
+
+	/* Capabilities */
+	caps = nm_device_get_capabilities (device);
+	printf (_("\n  Capabilities:\n"));
+	if (caps & NM_DEVICE_CAP_CARRIER_DETECT)
+		print_table_line (2, _("Carrier Detect"), 23, _("yes"), 0, NULL);
+
+	speed = 0;
+	if (NM_IS_DEVICE_ETHERNET (device)) {
+		/* Speed in Mb/s */
+		speed = nm_device_ethernet_get_speed (NM_DEVICE_ETHERNET (device));
+	} else if (NM_IS_DEVICE_WIFI (device)) {
+		/* Speed in b/s */
+		speed = nm_device_wifi_get_bitrate (NM_DEVICE_WIFI (device));
+		speed /= 1000;
+	}
+
+	if (speed) {
+		char *speed_string;
+
+		speed_string = g_strdup_printf (_("%u Mb/s"), speed);
+		print_table_line (2, _("Speed"), 23, speed_string, 0, NULL);
+		g_free (speed_string);
+	}
+
+	/* Wireless specific information */
+	if ((NM_IS_DEVICE_WIFI (device))) {
+		guint32 wcaps;
+		NMAccessPoint *active_ap = NULL;
+		const char *active_bssid = NULL;
+		const GPtrArray *aps;
+
+		printf (_("\n  Wireless Properties\n"));
+
+		wcaps = nm_device_wifi_get_capabilities (NM_DEVICE_WIFI (device));
+
+		if (wcaps & (NM_WIFI_DEVICE_CAP_CIPHER_WEP40 | NM_WIFI_DEVICE_CAP_CIPHER_WEP104))
+			print_table_line (2, _("WEP Encryption"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_WPA)
+			print_table_line (2, _("WPA Encryption"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_RSN)
+			print_table_line (2, _("WPA2 Encryption"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_CIPHER_TKIP)
+			print_table_line (2, _("TKIP cipher"), 23, _("yes"), 0, NULL);
+		if (wcaps & NM_WIFI_DEVICE_CAP_CIPHER_CCMP)
+			print_table_line (2, _("CCMP cipher"), 23, _("yes"), 0, NULL);
+
+		if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED) {
+			active_ap = nm_device_wifi_get_active_access_point (NM_DEVICE_WIFI (device));
+			active_bssid = active_ap ? nm_access_point_get_hw_address (active_ap) : NULL;
+		}
+
+		printf (_("\n  Wireless Access Points %s\n"), active_ap ? _("(* = current AP)") : "");
+
+		aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
+		if (aps && aps->len)
+			g_ptr_array_foreach ((GPtrArray *) aps, detail_access_point, (gpointer) active_bssid);
+	} else if (NM_IS_DEVICE_ETHERNET (device)) {
+		printf (_("\n  Wired Properties\n"));
+
+		if (nm_device_ethernet_get_carrier (NM_DEVICE_ETHERNET (device)))
+			print_table_line (2, _("Carrier"), 23, _("on"), 0, NULL);
+		else
+			print_table_line (2, _("Carrier"), 23, _("off"), 0, NULL);
+	}
+
+	/* IP Setup info */
+	if (state == NM_DEVICE_STATE_ACTIVATED) {
+		NMIP4Config *cfg = nm_device_get_ip4_config (device);
+		GSList *iter;
+
+		printf (_("\n  IPv4 Settings:\n"));
+
+		for (iter = (GSList *) nm_ip4_config_get_addresses (cfg); iter; iter = g_slist_next (iter)) {
+			NMIP4Address *addr = (NMIP4Address *) iter->data;
+			guint32 prefix = nm_ip4_address_get_prefix (addr);
+			char *tmp2;
+
+			tmp = ip4_address_as_string (nm_ip4_address_get_address (addr));
+			print_table_line (2, _("Address"), 23, tmp, 0, NULL);
+			g_free (tmp);
+
+			tmp2 = ip4_address_as_string (nm_utils_ip4_prefix_to_netmask (prefix));
+			tmp = g_strdup_printf ("%d (%s)", prefix, tmp2);
+			g_free (tmp2);
+			print_table_line (2, _("Prefix"), 23, tmp, 0, NULL);
+			g_free (tmp);
+
+			tmp = ip4_address_as_string (nm_ip4_address_get_gateway (addr));
+			print_table_line (2, _("Gateway"), 23, tmp, 0, NULL);
+			g_free (tmp);
+			printf ("\n");
+		}
+
+		array = nm_ip4_config_get_nameservers (cfg);
+		if (array) {
+			int i;
+
+			for (i = 0; i < array->len; i++) {
+				tmp = ip4_address_as_string (g_array_index (array, guint32, i));
+				print_table_line (2, _("DNS"), 23, tmp, 0, NULL);
+				g_free (tmp);
+			}
+		}
+	}
+
+	printf ("\n\n");
+}
+
+static void
+show_device_status (NMDevice *device, NmCli *nmc)
+{
+	const char *iface;
+	const char *type;
+	const char *state;
+
+	iface = nm_device_get_iface (device);
+	type = get_device_type (device);
+	state = device_state_to_string (nm_device_get_state (device));
+
+	print_table_line (0, iface, 10, type, 17, state, 0, NULL);
+}
+
+static NMCResultCode
+do_devices_status (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	int i;
+
+	while (argc > 0) {
+		fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		argc--;
+		argv++;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("Status of devices"), _("Device"), 10, _("Type"), 17, _("State"), 12, NULL);
+	else if (nmc->print_output == NMC_PRINT_NORMAL)
+		print_table_line (0, _("Device"), 10, _("Type"), 17, _("State"), 0, NULL);
+
+	for (i = 0; devices && (i < devices->len); i++) {
+		NMDevice *device = g_ptr_array_index (devices, i);
+		show_device_status (device, nmc);
+	}
+
+	return NMC_RESULT_SUCCESS;
+
+error:
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_devices_list (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	NMDevice *device = NULL;
+	const char *iface = NULL;
+	gboolean iface_specified = FALSE;
+	int i;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			iface_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: '%s' argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	if (iface_specified) {
+		for (i = 0; devices && (i < devices->len); i++) {
+			NMDevice *candidate = g_ptr_array_index (devices, i);
+			const char *dev_iface = nm_device_get_iface (candidate);
+
+			if (!strcmp (dev_iface, iface))
+				device = candidate;
+		}
+		if (!device) {
+		 	g_string_printf (nmc->return_text, _("Error: Device '%s' not found."), iface);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			goto error;
+		}
+		show_device_info (device, nmc->client);
+	} else {
+		if (devices)
+			g_ptr_array_foreach ((GPtrArray *) devices, show_device_info, nmc->client);
+	}
+
+error:
+	return nmc->return_value;
+}
+
+static void
+device_state_cb (NMDevice *device, GParamSpec *pspec, gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMDeviceState state;
+
+	state = nm_device_get_state (device);
+
+	if (state == NM_DEVICE_STATE_DISCONNECTED) {
+		g_string_printf (nmc->return_text, _("Success: Device '%s' successfully disconnected."), nm_device_get_iface (device));
+		quit ();
+	}
+}
+
+static gboolean
+timeout_cb (gpointer user_data)
+{
+	/* Time expired -> exit nmcli */
+
+	NmCli *nmc = (NmCli *) user_data;
+
+	g_string_printf (nmc->return_text, _("Error: Timeout %d sec expired."), nmc->timeout);
+	nmc->return_value = NMC_RESULT_ERROR_TIMEOUT_EXPIRED;
+	quit ();
+	return FALSE;
+}
+
+static void
+disconnect_device_cb (NMDevice *device, GError *error, gpointer user_data)
+{
+	NmCli *nmc = (NmCli *) user_data;
+	NMDeviceState state;
+
+	if (error) {
+		g_string_printf (nmc->return_text, _("Error: Device '%s' (%s) disconnecting failed: %s"),
+		                 nm_device_get_iface (device),
+		                 nm_object_get_path (NM_OBJECT (device)),
+		                 error->message ? error->message : _("(unknown)"));
+		nmc->return_value = NMC_RESULT_ERROR_DEV_DISCONNECT;
+		quit ();
+	} else {
+		state = nm_device_get_state (device);
+		printf (_("Device state: %d (%s)\n"), state, device_state_to_string (state));
+
+		if (!nmc->should_wait || state == NM_DEVICE_STATE_DISCONNECTED) {
+			/* Don't want to wait or device already disconnected */
+			quit ();
+		} else {
+			g_signal_connect (device, "notify::state", G_CALLBACK (device_state_cb), nmc);
+			/* Start timer not to loop forever if "notify::state" signal is not issued */
+			g_timeout_add_seconds (nmc->timeout, timeout_cb, nmc);
+		}
+
+	}
+}
+
+static NMCResultCode
+do_device_disconnect (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	NMDevice *device = NULL;
+	const char *iface = NULL;
+	gboolean iface_specified = FALSE;
+	gboolean wait = TRUE;
+	int i;
+
+	/* Set default timeout for disconnect operation */
+	nmc->timeout = 10;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			iface_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		} else if (strcmp (*argv, "--nowait") == 0) {
+			wait = FALSE;
+		} else if (strcmp (*argv, "--timeout") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			errno = 0;
+			nmc->timeout = strtol (*argv, NULL, 10);
+			if (errno || nmc->timeout < 0) {
+				g_string_printf (nmc->return_text, _("Error: timeout value '%s' is not valid."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!iface_specified) {
+		g_string_printf (nmc->return_text, _("Error: iface has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+	for (i = 0; devices && (i < devices->len); i++) {
+		NMDevice *candidate = g_ptr_array_index (devices, i);
+		const char *dev_iface = nm_device_get_iface (candidate);
+
+		if (!strcmp (dev_iface, iface))
+			device = candidate;
+	}
+
+	if (!device) {
+		g_string_printf (nmc->return_text, _("Error: Device '%s' not found."), iface);
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	nmc->should_wait = wait;
+	nm_device_disconnect (device, disconnect_device_cb, nmc);
+
+error:
+	return nmc->return_value;
+}
+
+static void
+show_acces_point_info (NMDevice *device)
+{
+	NMAccessPoint *active_ap = NULL;
+	const char *active_bssid = NULL;
+	const GPtrArray *aps;
+
+	if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED) {
+		active_ap = nm_device_wifi_get_active_access_point (NM_DEVICE_WIFI (device));
+		active_bssid = active_ap ? nm_access_point_get_hw_address (active_ap) : NULL;
+	}
+
+	aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
+	if (aps && aps->len)
+		g_ptr_array_foreach ((GPtrArray *) aps, detail_access_point, (gpointer) active_bssid);
+}
+
+static NMCResultCode
+do_device_wifi_list (NmCli *nmc, int argc, char **argv)
+{
+	//TODO: cleanup
+	const GPtrArray *devices;
+	NMDevice *device = NULL;
+	const char *iface = NULL;
+	gboolean iface_specified = FALSE;
+	int i;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			iface_specified = TRUE;
+
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+
+			iface = *argv;
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	if (iface_specified) {
+		for (i = 0; devices && (i < devices->len); i++) {
+			NMDevice *candidate = g_ptr_array_index (devices, i);
+			const char *dev_iface = nm_device_get_iface (candidate);
+
+			if (!strcmp (dev_iface, iface))
+				device = candidate;
+		}
+
+		if (!device) {
+		 	g_string_printf (nmc->return_text, _("Error: Device '%s' not found."), iface);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			goto error;
+		}
+
+		if ((NM_IS_DEVICE_WIFI (device))) {
+			if (nmc->print_output == NMC_PRINT_PRETTY)
+				print_table_header (_("WiFi scan list"), NULL);
+
+			show_acces_point_info (device);
+		} else {
+		 	g_string_printf (nmc->return_text, _("Error: Device '%s' is not a WiFi device."), iface);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			goto error;
+		}
+	} else {
+		if (nmc->print_output == NMC_PRINT_PRETTY)
+			print_table_header (_("WiFi scan list"), NULL);
+
+		for (i = 0; devices && (i < devices->len); i++) {
+			NMDevice *dev = g_ptr_array_index (devices, i);
+			const char *dev_iface = nm_device_get_iface (dev);
+
+			if ((NM_IS_DEVICE_WIFI (dev))) {
+				if (nmc->print_output > NMC_PRINT_TERSE)
+					print_table_line (0, _("Device:"), 0, dev_iface, 0, NULL);
+
+				show_acces_point_info (dev);
+			}
+		}
+	}
+
+error:
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_device_wifi_apinfo (NmCli *nmc, int argc, char **argv)
+{
+	const GPtrArray *devices;
+	const GPtrArray *aps;
+	NMAccessPoint *ap = NULL;
+	const char *iface = NULL;
+	const char *hwaddr_user = NULL;
+	const char *hwaddr;
+	gboolean stop = FALSE;
+	guint32 flags, wpa_flags, rsn_flags, freq, bitrate;
+	guint8 strength;
+	const GByteArray *ssid; 
+	NM80211Mode mode;
+	char *freq_str, *ssid_str, *bitrate_str, *strength_str, *wpa_flags_str, *rsn_flags_str;
+	int i, j;
+
+	while (argc > 0) {
+		if (strcmp (*argv, "iface") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+			iface = *argv;
+		} else if (strcmp (*argv, "hwaddr") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				g_string_printf (nmc->return_text, _("Error: %s argument is missing."), *argv);
+				nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+				goto error;
+			}
+			hwaddr_user = *argv;
+		} else {
+			fprintf (stderr, _("Unknown parameter: %s\n"), *argv);
+		}
+
+		argc--;
+		argv++;
+	}
+
+	if (!hwaddr_user) {
+		g_string_printf (nmc->return_text, _("Error: hwaddr has to be specified."));
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	devices = nm_client_get_devices (nmc->client);
+
+	for (i = 0; !stop && devices && (i < devices->len); i++) {
+		NMDevice *device = g_ptr_array_index (devices, i);
+		const char *dev_iface = nm_device_get_iface (device);
+
+		if (iface) {
+			if (!strcmp (iface, dev_iface))
+				stop = TRUE;
+			else
+				continue;
+		}
+
+		aps = NULL;
+		if ((NM_IS_DEVICE_WIFI (device)))
+			aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
+		for (j = 0; aps && (j < aps->len); j++) {
+			char *hwaddr_up;
+			NMAccessPoint *candidate_ap = g_ptr_array_index (aps, j);
+			const char *candidate_hwaddr = nm_access_point_get_hw_address (candidate_ap);
+
+			hwaddr_up = g_ascii_strup (hwaddr_user, -1);
+			if (!strcmp (hwaddr_up, candidate_hwaddr))
+				ap = candidate_ap;
+			g_free (hwaddr_up);
+		}
+	}
+
+	if (!ap) {
+	 	g_string_printf (nmc->return_text, _("Error: Access point with hwaddr '%s' not found."), hwaddr_user);
+		nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		goto error;
+	}
+
+	/* get AP properties */
+	flags = nm_access_point_get_flags (ap);
+	wpa_flags = nm_access_point_get_wpa_flags (ap);
+	rsn_flags = nm_access_point_get_rsn_flags (ap);
+	ssid = nm_access_point_get_ssid (ap);
+	hwaddr = nm_access_point_get_hw_address (ap);
+	freq = nm_access_point_get_frequency (ap);
+	mode = nm_access_point_get_mode (ap);
+	bitrate = nm_access_point_get_max_bitrate (ap);
+	strength = nm_access_point_get_strength (ap);
+
+	/* print them */
+	ssid_str = g_strdup_printf ("%s", ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : _("(none)"));
+	freq_str = g_strdup_printf (_("%u MHz"), freq);
+	bitrate_str = g_strdup_printf (_("%u MB/s"), bitrate/1000);
+	strength_str = g_strdup_printf ("%u", strength);
+	wpa_flags_str = ap_wpa_rsn_flags_to_string (wpa_flags);
+	rsn_flags_str = ap_wpa_rsn_flags_to_string (rsn_flags);
+
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("AP parameters"), NULL);
+	else if (nmc->print_output == NMC_PRINT_NORMAL)
+		print_table_line (0, _("AP parameters"), 0, NULL);
+
+	print_table_line (0, _("SSID:"), 25, ssid_str, 0, NULL);
+	print_table_line (0, _("BSSID:"), 25, hwaddr, 0, NULL);
+	print_table_line (0, _("Frequency:"), 25, freq_str, 0, NULL);
+	print_table_line (0, _("Mode:"), 25, mode == NM_802_11_MODE_ADHOC ? _("Ad-hoc") : mode == NM_802_11_MODE_INFRA ? _("Infrastructure") : _("Unknown"), 0, NULL);
+	print_table_line (0, _("Maximal bitrate:"), 25, bitrate_str, 0, NULL);
+	print_table_line (0, _("Strength:"), 25, strength_str, 0, NULL);
+	print_table_line (0, _("Flags:"), 25, flags == NM_802_11_AP_FLAGS_PRIVACY ? _("privacy") : _("(none)"), 0, NULL);
+	print_table_line (0, _("WPA flags:"), 25, wpa_flags_str, 0, NULL);
+	print_table_line (0, _("RSN flags:"), 25, rsn_flags_str, 0, NULL);
+
+	g_free (ssid_str);
+	g_free (freq_str);
+	g_free (bitrate_str);
+	g_free (strength_str);
+	g_free (wpa_flags_str);
+	g_free (rsn_flags_str);
+
+error:
+	return nmc->return_value;
+}
+
+static NMCResultCode
+do_device_wifi (NmCli *nmc, int argc, char **argv)
+{
+	if (argc == 0)
+		nmc->return_value = do_device_wifi_list (nmc, argc-1, argv+1);
+	else if (argc > 0) {
+		if (matches (*argv, "list") == 0) {
+			nmc->return_value = do_device_wifi_list (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "apinfo") == 0) {
+			nmc->return_value = do_device_wifi_apinfo (nmc, argc-1, argv+1);
+		}
+		else {
+			g_string_printf (nmc->return_text, _("Error: 'dev wifi' command '%s' is not valid."), *argv);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+	return nmc->return_value;
+}
+
+
+NMCResultCode
+do_devices (NmCli *nmc, int argc, char **argv)
+{
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto error;
+
+	if (argc == 0)
+		nmc->return_value = do_devices_status (nmc, argc-1, argv+1);
+
+	if (argc > 0) {
+		if (matches (*argv, "status") == 0) {
+			nmc->return_value = do_devices_status (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "list") == 0) {
+			nmc->return_value = do_devices_list (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "disconnect") == 0) {
+			nmc->return_value = do_device_disconnect (nmc, argc-1, argv+1);
+		}
+		else if (matches (*argv, "wifi") == 0) {
+			nmc->return_value = do_device_wifi (nmc, argc-1, argv+1);
+		}
+		else if (strcmp (*argv, "help") == 0) {
+			usage ();
+		}
+		else {
+			g_string_printf (nmc->return_text, _("Error: 'dev' command '%s' is not valid."), *argv);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+error:
+	return nmc->return_value;
+}
diff --git a/cli/src/devices.h b/cli/src/devices.h
new file mode 100644
index 0000000..152dd20
--- /dev/null
+++ b/cli/src/devices.h
@@ -0,0 +1,27 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_DEVICES_H
+#define NMC_DEVICES_H
+
+#include "nmcli.h"
+
+NMCResultCode do_devices (NmCli *nmc, int argc, char **argv);
+
+#endif /* NMC_DEVICES_H */
diff --git a/cli/src/network-manager.c b/cli/src/network-manager.c
new file mode 100644
index 0000000..b5c3bd5
--- /dev/null
+++ b/cli/src/network-manager.c
@@ -0,0 +1,186 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <nm-client.h>
+#include <nm-setting-connection.h>
+
+#include "utils.h"
+#include "network-manager.h"
+
+
+extern GMainLoop *loop;
+
+/* static function prototypes */
+static void usage (void);
+static void quit (void);
+static const char *nm_state_to_string (NMState state);
+static NMCResultCode show_nm_status (NmCli *nmc);
+
+
+static void
+usage (void)
+{
+	fprintf (stderr,
+	 	 _("Usage: nmcli nm { COMMAND | help }\n\n"
+		 "  COMMAND := { status | sleep | wakeup | wifi | wwan }\n\n"
+		 "  status\n"
+		 "  sleep\n"
+		 "  wakeup\n"
+		 "  wifi [on|off]\n"
+		 "  wwan [on|off]\n\n"));
+}
+
+/* quit main loop */
+static void
+quit (void)
+{
+	g_main_loop_quit (loop);  /* quit main loop */
+}
+
+static const char *
+nm_state_to_string (NMState state)
+{
+	switch (state) {
+	case NM_STATE_ASLEEP:
+		return _("asleep");
+	case NM_STATE_CONNECTING:
+		return _("connecting");
+	case NM_STATE_CONNECTED:
+		return _("connected");
+	case NM_STATE_DISCONNECTED:
+		return _("disconnected");
+	case NM_STATE_UNKNOWN:
+	default:
+		return _("unknown");
+	}
+}
+
+static NMCResultCode
+show_nm_status (NmCli *nmc)
+{
+	gboolean nm_running;
+	NMState state;
+	const char *wireless_hw_enabled_str, *wireless_enabled_str;
+	const char *wwan_hw_enabled_str, *wwan_enabled_str;
+
+	g_return_val_if_fail (nmc->client != NULL, NMC_RESULT_ERROR_UNKNOWN);
+
+	nm_running = nm_client_get_manager_running (nmc->client);
+	state = nm_client_get_state (nmc->client);
+	if (nm_running) {
+		wireless_hw_enabled_str = nm_client_wireless_hardware_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+		wireless_enabled_str = nm_client_wireless_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+		wwan_hw_enabled_str = nm_client_wwan_hardware_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+		wwan_enabled_str = nm_client_wwan_get_enabled (nmc->client) ? _("enabled") : _("disabled");
+	} else {
+		wireless_hw_enabled_str = wireless_enabled_str = wwan_hw_enabled_str = wwan_enabled_str = _("unknown");
+	}
+
+	if (nmc->print_output == NMC_PRINT_PRETTY)
+		print_table_header (_("NetworkManager status"), NULL);
+
+	print_table_line (0, _("NM running:"), 25, nm_running ? _("running") : _("not running"), 0, NULL);
+	print_table_line (0, _("NM state:"), 25, nm_state_to_string (state), 0, NULL);
+	print_table_line (0, _("NM wireless hardware:"), 25, wireless_hw_enabled_str, 0, NULL);
+	print_table_line (0, _("NM wireless:"), 25, wireless_enabled_str, 0, NULL);
+	print_table_line (0, _("NM WWAN hardware:"), 25, wwan_hw_enabled_str, 0, NULL);
+	print_table_line (0, _("NM WWAN:"), 25, wwan_enabled_str, 0, NULL);
+
+	return NMC_RESULT_SUCCESS;
+}
+
+
+/* entry point function for global network manager related commands 'nmcli nm' */
+NMCResultCode
+do_network_manager (NmCli *nmc, int argc, char **argv)
+{
+	gboolean enable_wifi;
+	gboolean enable_wwan;
+
+	/* create NMClient */
+	if (!nmc->get_client (nmc))
+		goto end;
+
+	if (argc == 0) {
+		nmc->return_value = show_nm_status (nmc);
+	}
+
+	if (argc > 0) {
+		if (matches (*argv, "status") == 0) {
+			nmc->return_value = show_nm_status (nmc);
+		}
+		else if (matches (*argv, "sleep") == 0) {
+			nm_client_sleep (nmc->client, TRUE);		
+		}
+		else if (matches (*argv, "wakeup") == 0) {
+			nm_client_sleep (nmc->client, FALSE);
+		}
+		else if (matches (*argv, "wifi") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				/* no argument, show current state */
+				print_table_line (0, _("NM wireless:"), 25, nm_client_wireless_get_enabled (nmc->client) ? _("enabled") : _("disabled"), 0, NULL);
+			} else {
+				if (!strcmp (*argv, "on"))
+					enable_wifi = TRUE;
+				else if (!strcmp (*argv, "off"))
+					enable_wifi = FALSE;
+				else {
+					g_string_printf (nmc->return_text, _("Error: invalid 'wifi' parameter: '%s'."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+					goto end;
+				}
+				nm_client_wireless_set_enabled (nmc->client, enable_wifi);
+			}
+		}
+		else if (matches (*argv, "wwan") == 0) {
+			if (next_arg (&argc, &argv) != 0) {
+				/* no argument, show current state */
+				print_table_line (0, _("NM WWAN:"), 25, nm_client_wwan_get_enabled (nmc->client) ? _("enabled") : _("disabled"), 0, NULL);
+			} else {
+				if (!strcmp (*argv, "on"))
+					enable_wwan = TRUE;
+				else if (!strcmp (*argv, "off"))
+					enable_wwan = FALSE;
+				else {
+					g_string_printf (nmc->return_text, _("Error: invalid 'wwan' parameter: '%s'."), *argv);
+					nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+					goto end;
+				}
+				nm_client_wwan_set_enabled (nmc->client, enable_wwan);
+			}
+		}
+		else if (strcmp (*argv, "help") == 0) {
+			usage ();
+		}
+		else {
+			g_string_printf (nmc->return_text, _("Error: 'nm' command '%s' is not valid."), *argv);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+end:
+	quit ();
+	return nmc->return_value;
+}
diff --git a/cli/src/network-manager.h b/cli/src/network-manager.h
new file mode 100644
index 0000000..93cc1b0
--- /dev/null
+++ b/cli/src/network-manager.h
@@ -0,0 +1,27 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_NETWORK_MANAGER_H
+#define NMC_NETWORK_MANAGER_H
+
+#include "nmcli.h"
+
+NMCResultCode do_network_manager (NmCli *nmc, int argc, char **argv);
+
+#endif /* NMC_NETWORK_MANAGER_H */
diff --git a/cli/src/nmcli.c b/cli/src/nmcli.c
new file mode 100644
index 0000000..f2ed715
--- /dev/null
+++ b/cli/src/nmcli.c
@@ -0,0 +1,283 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * Jiri Klimes <jklimes@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+/* Generated configuration file */
+#include "config.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <locale.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <nm-client.h>
+#include <nm-setting-connection.h>
+#include <nm-remote-settings.h>
+#include <nm-remote-settings-system.h>
+#include <nm-settings-interface.h>
+#include <nm-settings-connection-interface.h>
+
+#include "nmcli.h"
+#include "utils.h"
+#include "connections.h"
+#include "devices.h"
+#include "network-manager.h"
+
+#define NMCLI_VERSION "0.1"
+
+
+typedef struct {
+	NmCli *nmc;
+	int argc;
+	char **argv;
+} ArgsInfo;
+
+/* --- Global variables --- */
+GMainLoop *loop = NULL;
+
+
+static void
+usage (const char *prog_name)
+{
+	fprintf (stderr,
+	         _("Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n\n"
+	         "OPTIONS\n"
+	         "  -t[erse]    terse output\n"
+	         "  -p[retty]   pretty output\n"
+	         "  -v[ersion]  show program version\n"
+	         "  -h[elp]     print this help\n\n"
+	         "OBJECT\n"
+	         "  nm          NetworkManager status\n"
+	         "  con         NetworkManager connections\n"
+	         "  dev         devices managed by NetworkManager\n\n"),
+	          prog_name);
+}
+
+static NMCResultCode 
+do_help (NmCli *nmc, int argc, char **argv)
+{
+	usage ("nmcli");
+	return NMC_RESULT_SUCCESS;
+}
+
+static const struct cmd {
+	const char *cmd;
+	NMCResultCode (*func) (NmCli *nmc, int argc, char **argv);
+} nmcli_cmds[] = {
+	{ "nm",         do_network_manager },
+	{ "con",        do_connections },
+	{ "dev",        do_devices },
+	{ "help",       do_help },
+	{ 0 }
+};
+
+static NMCResultCode
+do_cmd (NmCli *nmc, const char *argv0, int argc, char **argv)
+{
+	const struct cmd *c;
+
+	for (c = nmcli_cmds; c->cmd; ++c) {
+		if (matches (argv0, c->cmd) == 0)
+			return c->func (nmc, argc-1, argv+1);
+	}
+
+	g_string_printf (nmc->return_text, _("Object '%s' is unknown, try 'nmcli help'."), argv0);
+	nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+	return nmc->return_value;
+}
+
+static NMCResultCode
+parse_command_line (NmCli *nmc, int argc, char **argv)
+{
+	char *base;
+
+	base = strrchr (argv[0], '/');
+	if (base == NULL)
+		base = argv[0];
+	else
+		base++;
+
+	/* parse options */
+	while (argc > 1) {
+		char *opt = argv[1];
+		/* '--' ends options */
+		if (strcmp (opt, "--") == 0) {
+			argc--; argv++;
+			break;
+		}
+		if (opt[0] != '-')
+			break;
+		if (opt[1] == '-')
+			opt++;
+		if (matches (opt, "-terse") == 0) {
+			nmc->print_output = NMC_PRINT_TERSE;
+		} else if (matches (opt, "-pretty") == 0) {
+			nmc->print_output = NMC_PRINT_PRETTY;
+		} else if (matches (opt, "-version") == 0) {
+			printf (_("nmcli tool, version %s\n"), NMCLI_VERSION);
+			return NMC_RESULT_SUCCESS;
+		} else if (matches (opt, "-help") == 0) {
+			usage (base);
+			return NMC_RESULT_SUCCESS;
+		} else {
+			g_string_printf (nmc->return_text, _("Option '%s' is unknown, try 'nmcli -help'."), opt);
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+			return nmc->return_value;
+		}
+		argc--;
+		argv++;
+	}
+
+	if (argc > 1)
+		return do_cmd (nmc, argv[1], argc-1, argv+1);
+
+	usage (base);
+	return nmc->return_value;
+}
+
+static void
+signal_handler (int signo)
+{
+	if (signo == SIGINT || signo == SIGTERM) {
+		g_message (_("Caught signal %d, shutting down..."), signo);
+		g_main_loop_quit (loop);
+	}
+}
+
+static void
+setup_signals (void)
+{
+	struct sigaction action;
+	sigset_t mask;
+
+	sigemptyset (&mask);
+	action.sa_handler = signal_handler;
+	action.sa_mask = mask;
+	action.sa_flags = 0;
+	sigaction (SIGTERM,  &action, NULL);
+	sigaction (SIGINT,  &action, NULL);
+}
+
+static NMClient *
+nmc_get_client (NmCli *nmc)
+{
+	if (!nmc->client) {
+		nmc->client = nm_client_new ();
+		if (!nmc->client) {
+			g_string_printf (nmc->return_text, _("Error: Could not connect to NetworkManager."));
+			nmc->return_value = NMC_RESULT_ERROR_UNKNOWN;
+		}
+	}
+
+	return nmc->client;
+}
+
+/* Initialize NmCli structure - set default values */
+static void
+nmc_init (NmCli *nmc)
+{
+	nmc->client = NULL;
+	nmc->get_client = &nmc_get_client;
+
+	nmc->return_value = NMC_RESULT_SUCCESS;
+	nmc->return_text = g_string_new (_("Success"));
+
+	nmc->timeout = 10;
+
+	nmc->system_settings = NULL;
+	nmc->user_settings = NULL;
+
+	nmc->system_settings_running = FALSE;
+	nmc->user_settings_running = FALSE;
+
+	nmc->system_connections = NULL;
+	nmc->user_connections = NULL;
+
+	nmc->should_wait = FALSE;
+	nmc->print_output = NMC_PRINT_NORMAL;
+}
+
+static void
+nmc_cleanup (NmCli *nmc)
+{
+	if (nmc->client) g_object_unref (nmc->client);
+
+	g_string_free (nmc->return_text, TRUE);
+
+	if (nmc->system_settings) g_object_unref (nmc->system_settings);
+	if (nmc->user_settings) g_object_unref (nmc->user_settings);
+
+	g_slist_free (nmc->system_connections);
+	g_slist_free (nmc->user_connections);
+}
+
+static gboolean
+start (gpointer data)
+{
+	ArgsInfo *info = (ArgsInfo *) data;
+	info->nmc->return_value = parse_command_line (info->nmc, info->argc, info->argv);
+
+	if (!info->nmc->should_wait)
+		g_main_loop_quit (loop);
+
+	return FALSE;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+	NmCli nmc;
+	ArgsInfo args_info = { &nmc, argc, argv };
+
+	/* Set locale to use environment variables */
+	setlocale (LC_ALL, "");
+
+#ifdef GETTEXT_PACKAGE
+	/* Set i18n stuff */
+	bindtextdomain (GETTEXT_PACKAGE, NMCLI_LOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+	textdomain (GETTEXT_PACKAGE);
+#endif
+
+	g_type_init ();
+
+	nmc_init (&nmc);
+	g_idle_add (start, &args_info);
+
+	loop = g_main_loop_new (NULL, FALSE);  /* create main loop */
+	setup_signals ();                      /* setup UNIX signals */
+	g_main_loop_run (loop);                /* run main loop */
+
+	/* Print result descripting text */
+	if (nmc.return_value != NMC_RESULT_SUCCESS) {
+		fprintf (stderr, "%s\n", nmc.return_text->str);
+	}
+
+	g_main_loop_unref (loop);
+	nmc_cleanup (&nmc);
+
+	return nmc.return_value;
+}
diff --git a/cli/src/nmcli.h b/cli/src/nmcli.h
new file mode 100644
index 0000000..2daa415
--- /dev/null
+++ b/cli/src/nmcli.h
@@ -0,0 +1,77 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_NMCLI_H
+#define NMC_NMCLI_H
+
+#include <nm-remote-settings.h>
+#include <nm-remote-settings-system.h>
+
+
+/* nmcli exit codes */
+typedef enum {
+	/* Indicates successful execution */
+	NMC_RESULT_SUCCESS = 0,
+
+	/* Unknown / unspecified error */
+	NMC_RESULT_ERROR_UNKNOWN,
+
+	/* A timeout expired */
+	NMC_RESULT_ERROR_TIMEOUT_EXPIRED,
+
+	/* Error in connection activation */
+	NMC_RESULT_ERROR_CON_ACTIVATION,
+
+	/* Error in connection deactivation */
+	NMC_RESULT_ERROR_CON_DEACTIVATION,
+
+	/* Error in device disconnect */
+	NMC_RESULT_ERROR_DEV_DISCONNECT
+} NMCResultCode;
+
+typedef enum {
+	NMC_PRINT_TERSE = 0,
+	NMC_PRINT_NORMAL,
+	NMC_PRINT_PRETTY
+} NMCPrintOutput;
+
+/* NmCli - main structure */
+typedef struct _NmCli {
+	NMClient *client;
+	NMClient *(*get_client) (struct _NmCli *nmc);
+
+	NMCResultCode return_value;
+	GString *return_text;
+
+	int timeout;
+
+	NMRemoteSettingsSystem *system_settings;
+	NMRemoteSettings *user_settings;
+
+	gboolean system_settings_running;
+	gboolean user_settings_running;
+
+	GSList *system_connections;
+	GSList *user_connections;
+
+	gboolean should_wait;
+	NMCPrintOutput print_output;
+} NmCli;
+
+#endif /* NMC_NMCLI_H */
diff --git a/cli/src/utils.c b/cli/src/utils.c
new file mode 100644
index 0000000..cd99b10
--- /dev/null
+++ b/cli/src/utils.c
@@ -0,0 +1,126 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include "utils.h"
+
+int
+matches (const char *cmd, const char *pattern)
+{
+	int len = strlen (cmd);
+	if (len > strlen (pattern))
+		return -1;
+	return memcmp (pattern, cmd, len);
+}
+
+int
+next_arg (int *argc, char ***argv)
+{
+	if (*argc <= 1) {
+		return -1;
+	}
+	else {
+		(*argc)--;
+		(*argv)++;
+	}
+	return 0;
+}
+
+void
+print_table_header (const char *name, ...)
+{
+	va_list ap;
+	GString *str;
+	char *col, *line = NULL;
+	int col_width, width1, width2, table_width = 0;
+
+	str = g_string_new (NULL);
+
+	va_start (ap, name);
+	while ((col = va_arg (ap, char *)) != NULL) {
+		col_width = va_arg (ap, int);
+		width1 = strlen (col);
+		width2 = g_utf8_strlen (col, -1);  /* Width of the string (in screen colums) */
+		g_string_append_printf (str, "%-*s", col_width + width1 - width2, col);
+		g_string_append_c (str, ' ');  /* Column separator */
+		table_width += col_width + width1 - width2 + 1;
+	}
+	va_end (ap);
+
+	if (table_width <= 0)
+		table_width = g_utf8_strlen (name, -1) + 4;
+
+	/* Print the table header */
+	line = g_strnfill (table_width, '=');
+	printf ("%s\n", line);
+	width1 = strlen (name);
+	width2 = g_utf8_strlen (name, -1);
+	printf ("%*s\n", (table_width + width2)/2 + width1 - width2, name);
+	printf ("%s\n", line);
+	if (str->len > 0) {
+		g_string_truncate (str, str->len-1);  /* Chop off last column separator */
+		printf ("%s\n", str->str);
+		g_free (line);
+		line = g_strnfill (table_width, '-');
+		printf ("%s\n", line);
+	}
+
+	g_free (line);
+	g_string_free (str, TRUE);
+}
+
+void
+print_table_line (int indent, ...)
+{
+	va_list ap;
+	GString *str;
+	char *col, *indent_str;
+	int col_width, width1, width2;
+
+	str = g_string_new (NULL);
+
+	va_start (ap, indent);
+	while ((col = va_arg (ap, char *)) != NULL) {
+		col_width = va_arg (ap, int);
+		width1 = strlen (col);
+		width2 = g_utf8_strlen (col, -1);  /* Width of the string (in screen colums) */
+		g_string_append_printf (str, "%-*s", col_width + width1 - width2, col);
+		g_string_append_c (str, ' ');  /* Column separator */
+	}
+	va_end (ap);
+
+	/* Print the line */
+	if (str->len > 0)
+	{
+		g_string_truncate (str, str->len-1);  /* Chop off last column separator */
+		if (indent > 0) {
+			indent_str = g_strnfill (indent, ' ');
+			g_string_prepend (str,  indent_str);
+			g_free (indent_str);
+		}
+		printf ("%s\n", str->str);
+	}
+
+	g_string_free (str, TRUE);
+}
+
diff --git a/cli/src/utils.h b/cli/src/utils.h
new file mode 100644
index 0000000..468550e
--- /dev/null
+++ b/cli/src/utils.h
@@ -0,0 +1,28 @@
+/* nmcli - command-line tool to control NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2010 Red Hat, Inc.
+ */
+
+#ifndef NMC_UTILS_H
+#define NMC_UTILS_H
+
+int matches (const char *cmd, const char *pattern);
+int next_arg (int *argc, char ***argv);
+void print_table_header (const char *name, ...);
+void print_table_line (int indent, ...);
+
+#endif /* NMC_UTILS_H */
diff --git a/configure.ac b/configure.ac
index 124f47c..adfe67f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -164,6 +164,14 @@ if test x"$with_distro" = xpardus; then
   AC_DEFINE(TARGET_PARDUS, 1, [Define if you have Pardus])
 fi
 
+dnl
+dnl Distribution version string
+dnl
+AC_ARG_WITH(dist-version, AS_HELP_STRING([--with-dist-version=<NM-distribution-version>], [Define the NM's distribution version string]), ac_distver=$withval, ac_distver="")
+if ! test x"$ac_distver" = x""; then
+  AC_DEFINE_UNQUOTED(NM_DIST_VERSION, "$ac_distver", [Define the distribution version string])
+fi
+
 AC_MSG_CHECKING([Linux Wireless Extensions >= 18])
 AC_TRY_COMPILE([#ifndef __user
                 #define __user
@@ -292,67 +300,73 @@ else
 fi
 AC_SUBST(PPPD_PLUGIN_DIR)
 
-# DHCP client
-AC_ARG_WITH([dhcp-client], AS_HELP_STRING([--with-dhcp-client=dhcpcd|dhclient], [path to the chosen dhcp client]))
+# dhclient support
+AC_ARG_WITH([dhclient], AS_HELP_STRING([--with-dhclient=yes|no|path], [Enable dhclient 4.x support]))
 # If a full path is given, use that and do not test if it works or not.
-case "${with_dhcp_client}" in
+case "${with_dhclient}" in
 	/*)
-		DHCP_CLIENT_PATH="${with_dhcp_client}"
-		AC_MSG_NOTICE(using the DHCP client ${DHCP_CLIENT_PATH})
+		DHCLIENT_PATH="${with_dhclient}"
+		AC_MSG_NOTICE(using dhclient at ${DHCLIENT_PATH})
 		;;
-esac
-if test -z "$DHCP_CLIENT_PATH" -a \( -z "$with_dhcp_client" -o x`basename "$with_dhcp_client"` = "xdhclient" \); then
-	# We only work with ISC dhclient - the FreeBSD and OpenBSD derivatives don't have the same userland.
-	AC_MSG_CHECKING(for dhclient)
-	for client in "$with_dhcp_client" /sbin/dhclient /usr/pkg/sbin/dhclient /usr/local/sbin/dhclient; do
-		test -x "$client" || continue
-		case `"$client" --version 2>&1` in
-			"isc-dhclient-"*) DHCP_CLIENT_PATH="$client"; break;;
-		esac
-	done
-	if test -z "$DHCP_CLIENT_PATH"; then
-		AC_MSG_RESULT(no)
-		if test -n "$with_dhcp_client"; then
-			AC_MSG_ERROR([Could not find ISC dhclient])
+	no)	AC_MSG_NOTICE(dhclient support disabled)
+		;;
+	*)
+		AC_MSG_CHECKING(for dhclient)
+		# NM only works with ISC dhclient - other derivatives don't have
+		# the same userland.  NM also requires dhclient 4.x since older
+		# versions do not have IPv6 support.
+		for path in /sbin /usr/sbin /usr/pkg/sbin /usr/local/sbin; do
+			test -x "${path}/dhclient" || continue
+			case `"$path/dhclient" --version 2>&1` in
+				"isc-dhclient-4"*) DHCLIENT_PATH="$path/dhclient"; break;;
+			esac
+		done
+		if test -n "${DHCLIENT_PATH}"; then
+			AC_MSG_RESULT($DHCLIENT_PATH)
+		else
+			AC_MSG_RESULT(no)
 		fi
-	else
-		AC_MSG_RESULT($DHCP_CLIENT_PATH)
-	fi
-fi
-if test -z "$DHCP_CLIENT_PATH" -a \( -z "$with_dhcp_client" -o x`basename "$with_dhcp_client"` = "xdhcpcd" \); then
-	test -n "$DHCP_CLIENT_PATH" && echo bar
-	# We fully work with upstream dhcpcd-4
-	AC_MSG_CHECKING([for dhcpcd])
-	for client in "$with_dhcp_client" /sbin/dhcpcd /usr/pkg/sbin/dhcpcd /usr/local/sbin/dhcpcd; do
-		test -x "$client" || continue
-		case `"$client" --version 2>/dev/null` in
-			"dhcpcd "[123]*);;
-			"dhcpcd "*) DHCP_CLIENT_PATH="$client"; break;;
-		esac
-	done
-	if test -z "$DHCP_CLIENT_PATH"; then
-		AC_MSG_RESULT(no)
-		if test -n "$with_dhcp_client"; then
-			AC_MSG_ERROR([Could not find dhcpcd-4 or newer])
+		;;
+esac
+
+# dhcpcd support
+AC_ARG_WITH([dhcpcd], AS_HELP_STRING([--with-dhcpcd=yes|no|path], [Enable dhcpcd 4.x support]))
+# If a full path is given, use that and do not test if it works or not.
+case "${with_dhcpcd}" in
+	/*)
+		DHCPCD_PATH="${with_dhcpcd}"
+		AC_MSG_NOTICE(using dhcpcd at ${DHCPCD_PATH})
+		;;
+	no)	AC_MSG_NOTICE(dhcpcd support disabled)
+		;;
+	*)
+		AC_MSG_CHECKING(for dhcpcd)
+		# We fully work with upstream dhcpcd-4
+		for path in /sbin /usr/sbin /usr/pkg/sbin /usr/local/sbin; do
+			test -x "${path}/dhclient" || continue
+			case `"$path/dhcpcd" --version 2>/dev/null` in
+				"dhcpcd "[123]*);;
+				"dhcpcd "*) DHCP_CLIENT_PATH="$path/dhcpcd"; break;;
+			esac
+		done
+		if test -n "${DHCPCD_PATH}"; then
+			AC_MSG_RESULT($DHCPCD_PATH)
+		else
+			AC_MSG_RESULT(no)
 		fi
-	else
-		AC_MSG_RESULT($DHCP_CLIENT_PATH)
-	fi
-fi
-if test -z "$DHCP_CLIENT_PATH"; then
+		;;
+esac
+
+if test -z "$DHCPCD_PATH" -a -z "$DHCLIENT_PATH"; then
 	# DHCP clients are not a build time dependency, only runtime.
 	# dhclient has been the longtime default for NM and it's in /sbin
 	# in most distros, so use it.
 	AC_MSG_WARN([Could not find a suitable DHCP client])
-	DHCP_CLIENT_PATH=/sbin/dhclient
+	DHCLIENT_PATH=/sbin/dhclient
 	AC_MSG_WARN([Falling back to ISC dhclient, ${DHCP_CLIENT_PATH}])
 fi
-AC_SUBST(DHCP_CLIENT_PATH)
-DHCP_CLIENT=`basename "$DHCP_CLIENT_PATH"`
-if test "$DHCP_CLIENT" != "dhclient" -a "$DHCP_CLIENT" != "dhcpcd"; then
-	AC_MSG_ERROR([No backend for the DHCP client ${DHCP_CLIENT}])
-fi
-AC_SUBST(DHCP_CLIENT)
+AC_SUBST(DHCLIENT_PATH)
+AC_SUBST(DHCPCD_PATH)
 
 # resolvconf support
 AC_ARG_WITH([resolvconf],
@@ -434,6 +448,7 @@ include/Makefile
 src/Makefile
 src/tests/Makefile
 marshallers/Makefile
+src/logging/Makefile
 src/named-manager/Makefile
 src/vpn-manager/Makefile
 src/dhcp-manager/Makefile
@@ -466,6 +481,8 @@ system-settings/plugins/keyfile/Makefile
 system-settings/plugins/keyfile/io/Makefile
 system-settings/plugins/keyfile/tests/Makefile
 system-settings/plugins/keyfile/tests/keyfiles/Makefile
+cli/Makefile
+cli/src/Makefile
 test/Makefile
 initscript/Makefile
 initscript/RedHat/Makefile
@@ -487,6 +504,8 @@ initscript/Mandriva/networkmanager
 introspection/Makefile
 man/Makefile
 man/NetworkManager.8
+man/NetworkManager.conf.5
+man/nm-system-settings.conf.5
 man/nm-tool.1
 po/Makefile.in
 policy/Makefile
@@ -494,16 +513,31 @@ docs/Makefile
 docs/libnm-glib/Makefile
 docs/libnm-util/Makefile
 NetworkManager.pc
+examples/Makefile
+examples/python/Makefile
 ])
 AC_OUTPUT
 
 echo
-echo Distribution targeting: ${with_distro}
+echo Distribution target: ${with_distro}
 echo 'if this is not correct, please specifiy your distro with --with-distro=DISTRO'
 
+echo 
+
+if test -n "${DHCLIENT_PATH}"; then
+	echo ISC dhclient support: ${DHCLIENT_PATH}
+else
+	echo ISC dhclient support: no
+fi
+
+if test -n "${DHCPCD_PATH}"; then
+	echo dhcpcd support: ${DHCPCD_PATH}
+else
+	echo dhcpcd support: no
+fi
+
 echo
 echo Building documentation: ${with_docs}
-echo
 echo Building tests: ${with_tests}
 echo
 
diff --git a/docs/generate-settings-spec.c b/docs/generate-settings-spec.c
index dd78fc9..d7a391f 100644
--- a/docs/generate-settings-spec.c
+++ b/docs/generate-settings-spec.c
@@ -128,6 +128,7 @@ write_one_setting (FILE *f, SettingNewFunc func)
 		value_desc = g_param_spec_get_blurb (*iter);
 
 		g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (*iter));
+		g_param_value_set_default (*iter, &value);
 		default_value = g_strdup_value_contents (&value);
 		if (default_value && !strcmp (default_value, "NULL")) {
 			g_free (default_value);
diff --git a/docs/libnm-glib/Makefile.am b/docs/libnm-glib/Makefile.am
index 297722a..96ff66e 100644
--- a/docs/libnm-glib/Makefile.am
+++ b/docs/libnm-glib/Makefile.am
@@ -34,23 +34,26 @@ IGNORE_HFILES= \
 	nm-device-private.h \
 	nm-object-cache.h \
 	nm-object-private.h \
+	nm-remote-connection-private.h \
 	nm-types-private.h \
 	nm-access-point-bindings.h \
+	nm-active-connection-bindings.h \
 	nm-client-bindings.h \
 	nm-device-bindings.h \
+	nm-device-bt-bindings.h \
 	nm-device-ethernet-bindings.h \
 	nm-device-wifi-bindings.h \
-	nm-exported-connection-glue.h \
+	nm-dhcp4-config-bindings.h \
+	nm-dhcp6-config-bindings.h \
 	nm-exported-connection-bindings.h \
-	nm-settings-glue.h \
+	nm-exported-connection-glue.h \
+	nm-ip4-config-bindings.h \
+	nm-ip6-config-bindings.h \
 	nm-settings-bindings.h \
+	nm-settings-glue.h \
 	nm-settings-system-bindings.h \
 	nm-vpn-connection-bindings.h \
-	nm-vpn-plugin-glue.h \
-	nm-active-connection-bindings.h \
-	nm-ip4-config-bindings.h \
-	nm-dhcp4-config-bindings.h \
-	nm-ip4-config-bindings.h
+	nm-vpn-plugin-glue.h
 
 # Images to copy into HTML directory.
 HTML_IMAGES = 
diff --git a/docs/libnm-glib/libnm-glib-docs.sgml b/docs/libnm-glib/libnm-glib-docs.sgml
index 8fe5a1d..b4e5dac 100644
--- a/docs/libnm-glib/libnm-glib-docs.sgml
+++ b/docs/libnm-glib/libnm-glib-docs.sgml
@@ -5,35 +5,40 @@
   <bookinfo>
     <title>libnm-glib Reference Manual</title>
     <releaseinfo>
-      for libnm-glib [VERSION]
+      for libnm-glib 0.8
       The latest version of this documentation can be found on-line at
-      <ulink role="online-location" url="http://[SERVER]/libnm-glib/index.html">http://[SERVER]/libnm-glib/</ulink>.
+      <ulink role="online-location" url="http://projects.gnome.org/NetworkManager/developers/libnm-glib/08/">http://projects.gnome.org/NetworkManager/developers/libnm-glib/08/</ulink>.
     </releaseinfo>
   </bookinfo>
 
   <chapter>
-    <title>[Insert title here]</title>
-    <xi:include href="xml/nm-access-point.xml"/>
-    <xi:include href="xml/nm-cdma-device.xml"/>
+    <title>libnm-glib Objects</title>
     <xi:include href="xml/nm-client.xml"/>
-    <xi:include href="xml/nm-gsm-device.xml"/>
+    <xi:include href="xml/nm-active-connection.xml"/>
     <xi:include href="xml/nm-device.xml"/>
+    <xi:include href="xml/nm-device-ethernet.xml"/>
+    <xi:include href="xml/nm-device-wifi.xml"/>
+    <xi:include href="xml/nm-serial-device.xml"/>
+    <xi:include href="xml/nm-gsm-device.xml"/>
+    <xi:include href="xml/nm-cdma-device.xml"/>
+    <xi:include href="xml/nm-device-bt.xml"/>
+    <xi:include href="xml/nm-access-point.xml"/>
     <xi:include href="xml/nm-ip4-config.xml"/>
     <xi:include href="xml/nm-ip6-config.xml"/>
+    <xi:include href="xml/nm-dhcp4-config.xml"/>
+    <xi:include href="xml/nm-dhcp6-config.xml"/>
+    <xi:include href="xml/nm-exported-connection.xml"/>
     <xi:include href="xml/nm-object.xml"/>
-    <xi:include href="xml/nm-settings.xml"/>
+    <xi:include href="xml/nm-remote-connection.xml"/>
+    <xi:include href="xml/nm-remote-settings.xml"/>
+    <xi:include href="xml/nm-remote-settings-system.xml"/>
+    <xi:include href="xml/nm-settings-connection-interface.xml"/>
+    <xi:include href="xml/nm-settings-interface.xml"/>
+    <xi:include href="xml/nm-settings-service.xml"/>
+    <xi:include href="xml/nm-settings-system-interface.xml"/>
+    <xi:include href="xml/nm-types.xml"/>
     <xi:include href="xml/nm-vpn-connection.xml"/>
     <xi:include href="xml/nm-vpn-plugin.xml"/>
-    <xi:include href="xml/nm-dbus-settings-system.xml"/>
-    <xi:include href="xml/nm-active-connection.xml"/>
-    <xi:include href="xml/nm-device-ethernet.xml"/>
-    <xi:include href="xml/nm-device-wifi.xml"/>
-    <xi:include href="xml/nm-dbus-connection.xml"/>
-    <xi:include href="xml/nm-serial-device.xml"/>
-    <xi:include href="xml/nm-dbus-settings.xml"/>
-    <xi:include href="xml/nm-dhcp4-config.xml"/>
     <xi:include href="xml/nm-vpn-plugin-ui-interface.xml"/>
-    <xi:include href="xml/libnm_glib.xml"/>
-    <xi:include href="xml/nm-types.xml"/>
   </chapter>
 </book>
diff --git a/docs/libnm-util/libnm-util-docs.sgml b/docs/libnm-util/libnm-util-docs.sgml
index 3758b6e..78b931d 100644
--- a/docs/libnm-util/libnm-util-docs.sgml
+++ b/docs/libnm-util/libnm-util-docs.sgml
@@ -8,9 +8,9 @@
   <bookinfo>
     <title>libnm-util Reference Manual</title>
     <releaseinfo>
-      for libnm-util [VERSION]
+      for libnm-util 0.8
       The latest version of this documentation can be found on-line at
-      <ulink role="online-location" url="http://[SERVER]/libnm-util/index.html">http://[SERVER]/libnm-util/</ulink>.
+      <ulink role="online-location" url="http://projects.gnome.org/NetworkManager/developers/libnm-util/08/">http://projects.gnome.org/NetworkManager/developers/libnm-util/08/</ulink>.
     </releaseinfo>
   </bookinfo>
 
diff --git a/examples/Makefile.am b/examples/Makefile.am
new file mode 100644
index 0000000..c2ddf78
--- /dev/null
+++ b/examples/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS=python
diff --git a/examples/python/Makefile.am b/examples/python/Makefile.am
new file mode 100644
index 0000000..a64727a
--- /dev/null
+++ b/examples/python/Makefile.am
@@ -0,0 +1,4 @@
+EXTRA_DIST = \
+	nm-state.py \
+	add-system-connection.py
+
diff --git a/examples/python/add-system-connection.py b/examples/python/add-system-connection.py
new file mode 100644
index 0000000..3cf350e
--- /dev/null
+++ b/examples/python/add-system-connection.py
@@ -0,0 +1,48 @@
+#!/bin/env python
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Copyright (C) 2010 Red Hat, Inc.
+#
+
+import dbus
+
+s_wired = dbus.Dictionary({'duplex': 'full'})
+s_con = dbus.Dictionary({
+            'type': '802-3-ethernet',
+            'uuid': '7371bb78-c1f7-42a3-a9db-5b9566e8ca07',
+            'id': 'MyConnection'})
+
+addr1 = dbus.Array([dbus.UInt32(50462986L), dbus.UInt32(0L), dbus.UInt32(16908554L)], signature=dbus.Signature('u'))
+s_ip4 = dbus.Dictionary({
+            'addresses': dbus.Array([addr1], signature=dbus.Signature('au')),
+            'method': 'manual'})
+
+s_ip6 = dbus.Dictionary({'method': 'ignore'})
+
+con = dbus.Dictionary({
+    '802-3-ethernet': s_wired,
+    'connection': s_con,
+    'ipv4': s_ip4,
+    'ipv6': s_ip6})
+
+
+bus = dbus.SystemBus()
+
+proxy = bus.get_object("org.freedesktop.NetworkManagerSystemSettings", "/org/freedesktop/NetworkManagerSettings")
+settings = dbus.Interface(proxy, "org.freedesktop.NetworkManagerSettings")
+
+settings.AddConnection(con)
+
diff --git a/examples/python/nm-state.py b/examples/python/nm-state.py
new file mode 100644
index 0000000..fddd2da
--- /dev/null
+++ b/examples/python/nm-state.py
@@ -0,0 +1,69 @@
+#!/bin/env python
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Copyright (C) 2010 Red Hat, Inc.
+#
+
+import dbus
+
+bus = dbus.SystemBus()
+
+proxy = bus.get_object("org.freedesktop.NetworkManager", "/org/freedesktop/NetworkManager")
+manager = dbus.Interface(proxy, "org.freedesktop.NetworkManager")
+
+# Get device-specific state
+devices = manager.GetDevices()
+for d in devices:
+    dev_proxy = bus.get_object("org.freedesktop.NetworkManager", d)
+    prop_iface = dbus.Interface(dev_proxy, "org.freedesktop.DBus.Properties")
+
+    # Get the device's current state and interface name
+    state = prop_iface.Get("org.freedesktop.NetworkManager.Device", "State")
+    name = prop_iface.Get("org.freedesktop.NetworkManager.Device", "Interface")
+
+    # and print them out
+    if state == 8:   # activated
+        print "Device %s is activated" % name
+    else:
+        print "Device %s is not activated" % name
+
+
+# Get active connection state
+manager_prop_iface = dbus.Interface(proxy, "org.freedesktop.DBus.Properties")
+active = manager_prop_iface.Get("org.freedesktop.NetworkManager", "ActiveConnections")
+for a in active:
+    ac_proxy = bus.get_object("org.freedesktop.NetworkManager", a)
+    prop_iface = dbus.Interface(ac_proxy, "org.freedesktop.DBus.Properties")
+    state = prop_iface.Get("org.freedesktop.NetworkManager.ActiveConnection", "State")
+
+    # Connections in NM are a collection of settings that describe everything
+    # needed to connect to a specific network.  Lets get those details so we
+    # can find the user-readable name of the connection.
+    con_path = prop_iface.Get("org.freedesktop.NetworkManager.ActiveConnection", "Connection")
+    con_service = prop_iface.Get("org.freedesktop.NetworkManager.ActiveConnection", "ServiceName")
+
+    # ask the provider of the connection for its details
+    service_proxy = bus.get_object(con_service, con_path)
+    con_iface = dbus.Interface(service_proxy, "org.freedesktop.NetworkManagerSettings.Connection")
+    con_details = con_iface.GetSettings()
+    con_name = con_details['connection']['id']
+
+    if state == 2:   # activated
+        print "Connection '%s' is activated" % con_name
+    else:
+        print "Connection '%s' is activating" % con_name
+
+
diff --git a/examples/python/vpn.py b/examples/python/vpn.py
new file mode 100644
index 0000000..4b4057f
--- /dev/null
+++ b/examples/python/vpn.py
@@ -0,0 +1,152 @@
+#!/usr/bin/python
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Copyright (C) 2009 Novell, Inc.
+# Copyright (C) 2009 Red Hat, Inc.
+#
+
+# Run this script without any arguments to list the available connection uuids.
+
+# The uuid of the connection to activate
+CONNECTION_UUID="ac6dc9b2-85ef-4311-83d8-add5d7db3f59"
+
+# UID to use. Note that NM only allows the owner of the connection to activate it.
+#UID=1000
+UID=0
+
+import sys
+import os
+import dbus
+from dbus.mainloop.glib import DBusGMainLoop
+import gobject
+
+DBusGMainLoop(set_as_default=True)
+
+def get_connections():
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', '/org/freedesktop/NetworkManagerSettings')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings')
+    return iface.ListConnections()
+
+
+def get_connection_by_uuid(uuid):
+    bus = dbus.SystemBus()
+    for c in get_connections():
+        proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', c)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings.Connection')
+        settings = iface.GetSettings()
+        if settings['connection']['uuid'] == uuid:
+            return c
+
+    return None
+
+
+def list_uuids():
+    bus = dbus.SystemBus()
+    for c in get_connections():
+        proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', c)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings.Connection')
+        settings = iface.GetSettings()
+        conn = settings['connection']
+        print "%s - %s (%s)" % (conn['uuid'], conn['id'], conn['type'])
+
+
+def get_active_connection_path(uuid):
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.DBus.Properties')
+    active_connections = iface.Get('org.freedesktop.NetworkManager', 'ActiveConnections')
+    all_connections = get_connections()
+
+    for a in active_connections:
+        proxy = bus.get_object('org.freedesktop.NetworkManager', a)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.DBus.Properties')
+        path = iface.Get('org.freedesktop.NetworkManager.Connection.Active', 'Connection')
+
+        proxy = bus.get_object('org.freedesktop.NetworkManagerUserSettings', path)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManagerSettings.Connection')
+        settings = iface.GetSettings()
+
+        if settings['connection']['uuid'] == uuid:
+            return a
+
+    return None
+
+
+def get_wifi_device_path():
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManager')
+    devices = iface.GetDevices()
+    for d in devices:
+        proxy = bus.get_object('org.freedesktop.NetworkManager', d)
+        iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.DBus.Properties')
+        devtype = iface.Get('org.freedesktop.NetworkManager.Device', 'DeviceType')
+        if devtype == 2:
+            return d
+    return None
+
+def activate_connection(connection_path, device_path):
+
+    def reply_handler(opath):
+    	print "Success: device activating"
+        sys.exit(0)
+
+    def error_handler(*args):
+    	print "Error activating device: %s" % args
+        sys.exit(1)
+
+    bus = dbus.SystemBus()
+    proxy = bus.get_object('org.freedesktop.NetworkManager', '/org/freedesktop/NetworkManager')
+    iface = dbus.Interface(proxy, dbus_interface='org.freedesktop.NetworkManager')
+    iface.ActivateConnection('org.freedesktop.NetworkManagerUserSettings',
+                             connection_path,
+                             device_path, 
+                             "/",
+                             reply_handler=reply_handler,
+                             error_handler=error_handler)
+
+
+# Change the UID first if required
+if UID != 0:
+    os.setuid(UID)
+
+# Are we configured?
+if not len(CONNECTION_UUID):
+    print "missing connection UUID"
+    sys.exit(0)
+
+connection_path = get_connection_by_uuid(CONNECTION_UUID)
+if not connection_path:
+    # Configured VPN connection is not known to NM, check CONNECTION_UUID.
+    print "couldn't find the connection"
+    sys.exit(1)
+
+device_path = get_wifi_device_path()
+if not device_path:
+    print "no wifi device found"
+    sys.exit(1)
+
+# Is it already activated?
+if get_active_connection_path(CONNECTION_UUID):
+    print "already connected"
+    sys.exit(0)
+
+print "Activating connection..."
+activate_connection(connection_path, device_path)
+loop = gobject.MainLoop()
+loop.run()
+
diff --git a/include/NetworkManager.h b/include/NetworkManager.h
index c8d5074..9df444f 100644
--- a/include/NetworkManager.h
+++ b/include/NetworkManager.h
@@ -42,6 +42,7 @@
 #define NM_DBUS_INTERFACE_IP4_CONFIG        NM_DBUS_INTERFACE ".IP4Config"
 #define NM_DBUS_INTERFACE_DHCP4_CONFIG      NM_DBUS_INTERFACE ".DHCP4Config"
 #define NM_DBUS_INTERFACE_IP6_CONFIG        NM_DBUS_INTERFACE ".IP6Config"
+#define NM_DBUS_INTERFACE_DHCP6_CONFIG      NM_DBUS_INTERFACE ".DHCP6Config"
 
 
 #define NM_DBUS_SERVICE_USER_SETTINGS     "org.freedesktop.NetworkManagerUserSettings"
@@ -240,130 +241,136 @@ typedef enum {
 	NM_DEVICE_STATE_REASON_NONE = 0,
 
 	/* Unknown error */
-	NM_DEVICE_STATE_REASON_UNKNOWN,
+	NM_DEVICE_STATE_REASON_UNKNOWN = 1,
 
 	/* Device is now managed */
-	NM_DEVICE_STATE_REASON_NOW_MANAGED,
+	NM_DEVICE_STATE_REASON_NOW_MANAGED = 2,
 
 	/* Device is now managed unmanaged */
-	NM_DEVICE_STATE_REASON_NOW_UNMANAGED,
+	NM_DEVICE_STATE_REASON_NOW_UNMANAGED = 3,
 
 	/* The device could not be readied for configuration */
-	NM_DEVICE_STATE_REASON_CONFIG_FAILED,
+	NM_DEVICE_STATE_REASON_CONFIG_FAILED = 4,
 
 	/* IP configuration could not be reserved (no available address, timeout, etc) */
-	NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE,
+	NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE = 5,
 
 	/* The IP config is no longer valid */
-	NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED,
+	NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED = 6,
 
 	/* Secrets were required, but not provided */
-	NM_DEVICE_STATE_REASON_NO_SECRETS,
+	NM_DEVICE_STATE_REASON_NO_SECRETS = 7,
 
 	/* 802.1x supplicant disconnected */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT = 8,
 
 	/* 802.1x supplicant configuration failed */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED = 9,
 
 	/* 802.1x supplicant failed */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED = 10,
 
 	/* 802.1x supplicant took too long to authenticate */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT = 11,
 
 	/* PPP service failed to start */
-	NM_DEVICE_STATE_REASON_PPP_START_FAILED,
+	NM_DEVICE_STATE_REASON_PPP_START_FAILED = 12,
 
 	/* PPP service disconnected */
-	NM_DEVICE_STATE_REASON_PPP_DISCONNECT,
+	NM_DEVICE_STATE_REASON_PPP_DISCONNECT = 13,
 
 	/* PPP failed */
-	NM_DEVICE_STATE_REASON_PPP_FAILED,
+	NM_DEVICE_STATE_REASON_PPP_FAILED = 14,
 
 	/* DHCP client failed to start */
-	NM_DEVICE_STATE_REASON_DHCP_START_FAILED,
+	NM_DEVICE_STATE_REASON_DHCP_START_FAILED = 15,
 
 	/* DHCP client error */
-	NM_DEVICE_STATE_REASON_DHCP_ERROR,
+	NM_DEVICE_STATE_REASON_DHCP_ERROR = 16,
 
 	/* DHCP client failed */
-	NM_DEVICE_STATE_REASON_DHCP_FAILED,
+	NM_DEVICE_STATE_REASON_DHCP_FAILED = 17,
 
 	/* Shared connection service failed to start */
-	NM_DEVICE_STATE_REASON_SHARED_START_FAILED,
+	NM_DEVICE_STATE_REASON_SHARED_START_FAILED = 18,
 
 	/* Shared connection service failed */
-	NM_DEVICE_STATE_REASON_SHARED_FAILED,
+	NM_DEVICE_STATE_REASON_SHARED_FAILED = 19,
 
 	/* AutoIP service failed to start */
-	NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED,
+	NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED = 20,
 
 	/* AutoIP service error */
-	NM_DEVICE_STATE_REASON_AUTOIP_ERROR,
+	NM_DEVICE_STATE_REASON_AUTOIP_ERROR = 21,
 
 	/* AutoIP service failed */
-	NM_DEVICE_STATE_REASON_AUTOIP_FAILED,
+	NM_DEVICE_STATE_REASON_AUTOIP_FAILED = 22,
 
 	/* The line is busy */
-	NM_DEVICE_STATE_REASON_MODEM_BUSY,
+	NM_DEVICE_STATE_REASON_MODEM_BUSY = 23,
 
 	/* No dial tone */
-	NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE,
+	NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE = 24,
 
 	/* No carrier could be established */
-	NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER,
+	NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER = 25,
 
 	/* The dialing request timed out */
-	NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT,
+	NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT = 26,
 
 	/* The dialing attempt failed */
-	NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED,
+	NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED = 27,
 
 	/* Modem initialization failed */
-	NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED,
+	NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED = 28,
 
 	/* Failed to select the specified APN */
-	NM_DEVICE_STATE_REASON_GSM_APN_FAILED,
+	NM_DEVICE_STATE_REASON_GSM_APN_FAILED = 29,
 
 	/* Not searching for networks */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING = 30,
 
 	/* Network registration denied */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED = 31,
 
 	/* Network registration timed out */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT = 32,
 
 	/* Failed to register with the requested network */
-	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED,
+	NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED = 33,
 
 	/* PIN check failed */
-	NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED,
+	NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED = 34,
 
 	/* Necessary firmware for the device may be missing */
-	NM_DEVICE_STATE_REASON_FIRMWARE_MISSING,
+	NM_DEVICE_STATE_REASON_FIRMWARE_MISSING = 35,
 
 	/* The device was removed */
-	NM_DEVICE_STATE_REASON_REMOVED,
+	NM_DEVICE_STATE_REASON_REMOVED = 36,
 
 	/* NetworkManager went to sleep */
-	NM_DEVICE_STATE_REASON_SLEEPING,
+	NM_DEVICE_STATE_REASON_SLEEPING = 37,
 
 	/* The device's active connection disappeared */
-	NM_DEVICE_STATE_REASON_CONNECTION_REMOVED,
+	NM_DEVICE_STATE_REASON_CONNECTION_REMOVED = 38,
 
 	/* Device disconnected by user or client */
-	NM_DEVICE_STATE_REASON_USER_REQUESTED,
+	NM_DEVICE_STATE_REASON_USER_REQUESTED = 39,
 
 	/* Carrier/link changed */
-	NM_DEVICE_STATE_REASON_CARRIER,
+	NM_DEVICE_STATE_REASON_CARRIER = 40,
 
 	/* The device's existing connection was assumed */
-	NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED,
+	NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED = 41,
 
 	/* The supplicant is now available */
-	NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE,
+	NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE = 42,
+
+	/* The modem could not be found */
+	NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND = 43,
+
+	/* The Bluetooth connection failed or timed out */
+	NM_DEVICE_STATE_REASON_BT_FAILED = 44,
 
 	/* Unused */
 	NM_DEVICE_STATE_REASON_LAST = 0xFFFF
diff --git a/introspection/Makefile.am b/introspection/Makefile.am
index 0dc286a..212da3a 100644
--- a/introspection/Makefile.am
+++ b/introspection/Makefile.am
@@ -23,5 +23,6 @@ EXTRA_DIST = \
 	nm-vpn-connection.xml \
 	nm-ppp-manager.xml \
 	nm-active-connection.xml \
-	nm-dhcp4-config.xml
+	nm-dhcp4-config.xml \
+	nm-dhcp6-config.xml
 
diff --git a/introspection/all.xml b/introspection/all.xml
index 67f1e54..d6b2f23 100644
--- a/introspection/all.xml
+++ b/introspection/all.xml
@@ -38,6 +38,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</
 <xi:include href="nm-ip4-config.xml"/>
 <xi:include href="nm-ip6-config.xml"/>
 <xi:include href="nm-dhcp4-config.xml"/>
+<xi:include href="nm-dhcp6-config.xml"/>
 <xi:include href="nm-settings.xml"/>
 <xi:include href="nm-exported-connection.xml"/>
 <xi:include href="nm-active-connection.xml"/>
diff --git a/introspection/nm-device.xml b/introspection/nm-device.xml
index c23b596..0d0a950 100644
--- a/introspection/nm-device.xml
+++ b/introspection/nm-device.xml
@@ -392,7 +392,17 @@
           The 802.1x supplicant is now available.
         </tp:docstring>
       </tp:enumvalue>
-	</tp:enum>
+      <tp:enumvalue suffix="MODEM_NOT_FOUND" value="43">
+        <tp:docstring>
+          The modem could not be found.
+        </tp:docstring>
+      </tp:enumvalue>
+      <tp:enumvalue suffix="BT_FAILED" value="44">
+        <tp:docstring>
+          The Bluetooth connection timed out or failed.
+        </tp:docstring>
+      </tp:enumvalue>
+    </tp:enum>
 
   </interface>
 </node>
diff --git a/introspection/nm-dhcp6-config.xml b/introspection/nm-dhcp6-config.xml
new file mode 100644
index 0000000..93b0f1c
--- /dev/null
+++ b/introspection/nm-dhcp6-config.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+    <interface name="org.freedesktop.NetworkManager.DHCP6Config">
+        <tp:docstring>
+            Options and configuration returned by the IPv6 DHCP server.
+        </tp:docstring>
+        <property name="Options" type="a{sv}" access="read">
+            <tp:docstring>Configuration options returned by a DHCP server, if any.</tp:docstring>
+        </property>
+
+        <signal name="PropertiesChanged">
+            <arg name="properties" type="a{sv}" tp:type="String_Variant_Map">
+                <tp:docstring>
+                    A dictionary mapping property names to variant boxed values
+                </tp:docstring>
+            </arg>
+        </signal>
+    </interface>
+</node>
diff --git a/introspection/nm-exported-connection.xml b/introspection/nm-exported-connection.xml
index 5cb157e..46907c0 100644
--- a/introspection/nm-exported-connection.xml
+++ b/introspection/nm-exported-connection.xml
@@ -46,7 +46,7 @@
             </tp:docstring>
             <arg name="settings" type="a{sa{sv}}" tp:type="String_String_Variant_Map_Map">
                 <tp:docstring>
-                    Contains the changed settings.
+                    Contains complete connection setting parameters, including changes.
                 </tp:docstring>
             </arg>
         </signal>
diff --git a/introspection/nm-manager.xml b/introspection/nm-manager.xml
index 8303f4d..406b5cf 100644
--- a/introspection/nm-manager.xml
+++ b/introspection/nm-manager.xml
@@ -96,6 +96,28 @@
       </arg>
     </method>
 
+    <method name="SetLogging">
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_manager_set_logging"/>
+      <tp:docstring>
+        Set logging verbosity and which operations are logged.
+      </tp:docstring>
+      <arg name="level" type="s" direction="in">
+        <tp:docstring>
+          One of [ERR, WARN, INFO, DEBUG].
+        </tp:docstring>
+      </arg>
+      <arg name="domains" type="s" direction="in">
+        <tp:docstring>
+          A combination of logging domains separated by commas (','), or "NONE"
+          to disable logging.  Each domain enables logging for operations
+          related to that domain.  Available domains are: [NONE, HW, RKILL,
+          ETHER, WIFI, BT, MB, DHCP4, DHCP6, PPP, WIFI_SCAN, IP4, IP6, AUTOIP4,
+          DNS, VPN, SHARING, SUPPLICANT, USER_SET, SYS_SET, SUSPEND, CORE,
+          DEVICE, OLPC]
+        </tp:docstring>
+      </arg>
+    </method>
+
     <property name="WirelessEnabled" type="b" access="readwrite">
       <tp:docstring>
         Indicates if wireless is currently enabled or not.
diff --git a/libnm-glib/Makefile.am b/libnm-glib/Makefile.am
index 2aa6124..58b5bc5 100644
--- a/libnm-glib/Makefile.am
+++ b/libnm-glib/Makefile.am
@@ -20,7 +20,32 @@ BUILT_SOURCES = \
 	nm-active-connection-bindings.h \
 	nm-ip4-config-bindings.h \
 	nm-dhcp4-config-bindings.h \
-	nm-ip6-config-bindings.h
+	nm-ip6-config-bindings.h \
+	nm-dhcp6-config-bindings.h
+
+#####################################################
+# Deprecated original libnm_glib bits
+#####################################################
+
+noinst_LTLIBRARIES = libdeprecated-nm-glib.la
+
+libdeprecated_nm_glib_la_SOURCES = \
+	libnm_glib.h \
+	libnm_glib.c
+
+libdeprecated_nm_glib_la_CPPFLAGS = \
+	$(DBUS_CFLAGS) \
+	$(GLIB_CFLAGS) \
+	-Wno-deprecated-declarations \
+	-Wno-deprecated
+
+libdeprecated_nm_glib_la_LIBADD = \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS)
+
+#####################################################
+# Real libnm-glib stuff
+#####################################################
 
 lib_LTLIBRARIES = libnm-glib.la libnm-glib-vpn.la
 
@@ -52,6 +77,7 @@ libnminclude_HEADERS = \
 	nm-active-connection.h \
 	nm-dhcp4-config.h \
 	nm-ip6-config.h \
+	nm-dhcp6-config.h \
 	nm-remote-connection.h \
 	nm-settings-interface.h \
 	nm-settings-system-interface.h \
@@ -62,7 +88,6 @@ libnminclude_HEADERS = \
 	nm-settings-service.h
 
 libnm_glib_la_SOURCES = \
-	libnm_glib.c \
 	nm-object.c \
 	nm-object-private.h \
 	nm-client.c \
@@ -86,6 +111,7 @@ libnm_glib_la_SOURCES = \
 	nm-active-connection.c \
 	nm-dhcp4-config.c \
 	nm-ip6-config.c \
+	nm-dhcp6-config.c \
 	nm-remote-connection.c \
 	nm-remote-connection-private.h \
 	nm-settings-interface.c \
@@ -99,13 +125,14 @@ libnm_glib_la_SOURCES = \
 libnm_glib_la_LIBADD = \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(builddir)/libdeprecated-nm-glib.la \
 	$(GLIB_LIBS) \
 	$(DBUS_LIBS) \
 	$(GCONF_LIBS) \
 	$(GUDEV_LIBS)
 
 libnm_glib_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-glib.ver \
-	-version-info "4:0:2"
+	-version-info "4:1:2"
 
 noinst_PROGRAMS = libnm-glib-test
 
@@ -172,6 +199,9 @@ nm-dhcp4-config-bindings.h: $(top_srcdir)/introspection/nm-dhcp4-config.xml
 nm-ip6-config-bindings.h: $(top_srcdir)/introspection/nm-ip6-config.xml
 	dbus-binding-tool --prefix=nm_ip6_config --mode=glib-client --output=$@ $<
 
+nm-dhcp6-config-bindings.h: $(top_srcdir)/introspection/nm-dhcp6-config.xml
+	dbus-binding-tool --prefix=nm_dhcp6_config --mode=glib-client --output=$@ $<
+
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libnm-glib.pc libnm-glib-vpn.pc
 
@@ -179,5 +209,4 @@ DISTCLEANFILES = libnm-glib.pc libnm-glib.pc
 
 EXTRA_DIST = libnm-glib.pc.in libnm-glib-vpn.pc.in libnm-glib.ver libnm-glib-vpn.ver
 
-CLEANFILES = \
-	$(BUILT_SOURCES)
+CLEANFILES = $(BUILT_SOURCES)
diff --git a/libnm-glib/libnm-glib-test.c b/libnm-glib/libnm-glib-test.c
index ed29601..3ac0a24 100644
--- a/libnm-glib/libnm-glib-test.c
+++ b/libnm-glib/libnm-glib-test.c
@@ -36,6 +36,7 @@
 #include "nm-device-wifi.h"
 #include "nm-utils.h"
 #include "nm-active-connection.h"
+#include "nm-vpn-connection.h"
 #include "nm-setting-ip4-config.h"
 
 static gboolean
@@ -291,8 +292,10 @@ active_connections_changed (NMClient *client, GParamSpec *pspec, gpointer user_d
 		connection = g_ptr_array_index (connections, i);
 		g_print ("    %s\n", nm_object_get_path (NM_OBJECT (connection)));
 		devices = nm_active_connection_get_devices (connection);
-		for (j = 0; j < devices->len; j++)
+		for (j = 0; devices && j < devices->len; j++)
 			g_print ("           %s\n", nm_device_get_udi (g_ptr_array_index (devices, j)));
+		if (NM_IS_VPN_CONNECTION (connection))
+			g_print ("           VPN base connection: %s\n", nm_active_connection_get_specific_object (connection));
 	}
 }
 
diff --git a/libnm-glib/libnm-glib.ver b/libnm-glib/libnm-glib.ver
index 1caa2d4..dfe4fe5 100644
--- a/libnm-glib/libnm-glib.ver
+++ b/libnm-glib/libnm-glib.ver
@@ -129,6 +129,7 @@ global:
 	nm_settings_connection_interface_get_type;
 	nm_settings_connection_interface_update;
 	nm_settings_interface_add_connection;
+	nm_settings_interface_error_get_type;
 	nm_settings_interface_error_quark;
 	nm_settings_interface_get_connection_by_path;
 	nm_settings_interface_get_type;
diff --git a/libnm-glib/libnm_glib.h b/libnm-glib/libnm_glib.h
index fa3c812..01c055d 100644
--- a/libnm-glib/libnm_glib.h
+++ b/libnm-glib/libnm_glib.h
@@ -37,21 +37,21 @@ typedef enum libnm_glib_state
 	LIBNM_NO_NETWORK_CONNECTION,
 	LIBNM_ACTIVE_NETWORK_CONNECTION,
 	LIBNM_INVALID_CONTEXT
-} libnm_glib_state;
+} libnm_glib_state G_GNUC_DEPRECATED;
 
-typedef struct libnm_glib_ctx libnm_glib_ctx;
+typedef struct libnm_glib_ctx libnm_glib_ctx G_GNUC_DEPRECATED;
 
 
-typedef void (*libnm_glib_callback_func) (libnm_glib_ctx *libnm_ctx, gpointer user_data);
+typedef void (*libnm_glib_callback_func) (libnm_glib_ctx *libnm_ctx, gpointer user_data) G_GNUC_DEPRECATED;
 
 
-libnm_glib_ctx		*libnm_glib_init				(void);
-void				 libnm_glib_shutdown			(libnm_glib_ctx *ctx);
+G_GNUC_DEPRECATED libnm_glib_ctx *  libnm_glib_init                (void);
+G_GNUC_DEPRECATED void              libnm_glib_shutdown            (libnm_glib_ctx *ctx);
 
-libnm_glib_state	 libnm_glib_get_network_state		(const libnm_glib_ctx *ctx);
+G_GNUC_DEPRECATED libnm_glib_state  libnm_glib_get_network_state   (const libnm_glib_ctx *ctx);
 
-guint				 libnm_glib_register_callback		(libnm_glib_ctx *ctx, libnm_glib_callback_func func, gpointer user_data, GMainContext *g_main_ctx);
-void				 libnm_glib_unregister_callback	(libnm_glib_ctx *ctx, guint id);
+G_GNUC_DEPRECATED guint             libnm_glib_register_callback   (libnm_glib_ctx *ctx, libnm_glib_callback_func func, gpointer user_data, GMainContext *g_main_ctx);
+G_GNUC_DEPRECATED void              libnm_glib_unregister_callback (libnm_glib_ctx *ctx, guint id);
 
 G_END_DECLS
 
diff --git a/libnm-glib/nm-device.c b/libnm-glib/nm-device.c
index 17caa99..a24eb06 100644
--- a/libnm-glib/nm-device.c
+++ b/libnm-glib/nm-device.c
@@ -59,6 +59,8 @@ typedef struct {
 	gboolean null_dhcp4_config;
 	NMIP6Config *ip6_config;
 	gboolean null_ip6_config;
+	NMDHCP6Config *dhcp6_config;
+	gboolean null_dhcp6_config;
 	NMDeviceState state;
 
 	GUdevClient *client;
@@ -79,6 +81,7 @@ enum {
 	PROP_STATE,
 	PROP_PRODUCT,
 	PROP_VENDOR,
+	PROP_DHCP6_CONFIG,
 
 	LAST_PROP
 };
@@ -220,6 +223,46 @@ demarshal_ip6_config (NMObject *object, GParamSpec *pspec, GValue *value, gpoint
 	return TRUE;
 }
 
+static gboolean
+demarshal_dhcp6_config (NMObject *object, GParamSpec *pspec, GValue *value, gpointer field)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (object);
+	const char *path;
+	NMDHCP6Config *config = NULL;
+	DBusGConnection *connection;
+
+	if (!G_VALUE_HOLDS (value, DBUS_TYPE_G_OBJECT_PATH))
+		return FALSE;
+
+	priv->null_dhcp6_config = FALSE;
+
+	path = g_value_get_boxed (value);
+	if (path) {
+		if (!strcmp (path, "/"))
+			priv->null_dhcp6_config = TRUE;
+		else {
+			config = NM_DHCP6_CONFIG (_nm_object_cache_get (path));
+			if (config)
+				config = g_object_ref (config);
+			else {
+				connection = nm_object_get_connection (object);
+				config = NM_DHCP6_CONFIG (nm_dhcp6_config_new (connection, path));
+			}
+		}
+	}
+
+	if (priv->dhcp6_config) {
+		g_object_unref (priv->dhcp6_config);
+		priv->dhcp6_config = NULL;
+	}
+
+	if (config)
+		priv->dhcp6_config = config;
+
+	_nm_object_queue_notify (object, NM_DEVICE_DHCP6_CONFIG);
+	return TRUE;
+}
+
 static void
 register_for_property_changed (NMDevice *device)
 {
@@ -230,9 +273,10 @@ register_for_property_changed (NMDevice *device)
 		{ NM_DEVICE_DRIVER,       _nm_object_demarshal_generic, &priv->driver },
 		{ NM_DEVICE_CAPABILITIES, _nm_object_demarshal_generic, &priv->capabilities },
 		{ NM_DEVICE_MANAGED,      _nm_object_demarshal_generic, &priv->managed },
-		{ NM_DEVICE_IP4_CONFIG,   demarshal_ip4_config,        &priv->ip4_config },
-		{ NM_DEVICE_DHCP4_CONFIG, demarshal_dhcp4_config,      &priv->dhcp4_config },
-		{ NM_DEVICE_IP6_CONFIG,   demarshal_ip6_config,        &priv->ip6_config },
+		{ NM_DEVICE_IP4_CONFIG,   demarshal_ip4_config,         &priv->ip4_config },
+		{ NM_DEVICE_DHCP4_CONFIG, demarshal_dhcp4_config,       &priv->dhcp4_config },
+		{ NM_DEVICE_IP6_CONFIG,   demarshal_ip6_config,         &priv->ip6_config },
+		{ NM_DEVICE_DHCP6_CONFIG, demarshal_dhcp6_config,       &priv->dhcp6_config },
 		{ NULL },
 	};
 
@@ -318,6 +362,8 @@ dispose (GObject *object)
 		g_object_unref (priv->dhcp4_config);
 	if (priv->ip6_config)
 		g_object_unref (priv->ip6_config);
+	if (priv->dhcp6_config)
+		g_object_unref (priv->dhcp6_config);
 	if (priv->client)
 		g_object_unref (priv->client);
 
@@ -371,6 +417,9 @@ get_property (GObject *object,
 	case PROP_IP6_CONFIG:
 		g_value_set_object (value, nm_device_get_ip6_config (device));
 		break;
+	case PROP_DHCP6_CONFIG:
+		g_value_set_object (value, nm_device_get_dhcp6_config (device));
+		break;
 	case PROP_STATE:
 		g_value_set_uint (value, nm_device_get_state (device));
 		break;
@@ -506,6 +555,19 @@ nm_device_class_init (NMDeviceClass *device_class)
 		                      G_PARAM_READABLE));
 
 	/**
+	 * NMDevice:dhcp6-config:
+	 *
+	 * The #NMDHCP6Config of the device.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_DHCP6_CONFIG,
+		 g_param_spec_object (NM_DEVICE_DHCP6_CONFIG,
+						  "DHCP6 Config",
+						  "DHCP6 Config",
+						  NM_TYPE_DHCP6_CONFIG,
+						  G_PARAM_READABLE));
+
+	/**
 	 * NMDevice:state:
 	 *
 	 * The state of the device.
@@ -871,6 +933,41 @@ nm_device_get_ip6_config (NMDevice *device)
 }
 
 /**
+ * nm_device_get_dhcp6_config:
+ * @device: a #NMDevice
+ *
+ * Gets the current #NMDHCP6Config associated with the #NMDevice.
+ *
+ * Returns: the #NMDHCPConfig or %NULL if the device is not activated or not
+ * using DHCP.
+ **/
+NMDHCP6Config *
+nm_device_get_dhcp6_config (NMDevice *device)
+{
+	NMDevicePrivate *priv;
+	char *path;
+	GValue value = { 0, };
+
+	g_return_val_if_fail (NM_IS_DEVICE (device), NULL);
+
+	priv = NM_DEVICE_GET_PRIVATE (device);
+	if (priv->dhcp6_config)
+		return priv->dhcp6_config;
+	if (priv->null_dhcp6_config)
+		return NULL;
+
+	path = _nm_object_get_object_path_property (NM_OBJECT (device), NM_DBUS_INTERFACE_DEVICE, "Dhcp6Config");
+	if (path) {
+		g_value_init (&value, DBUS_TYPE_G_OBJECT_PATH);
+		g_value_take_boxed (&value, path);
+		demarshal_dhcp6_config (NM_OBJECT (device), NULL, &value, &priv->dhcp6_config);
+		g_value_unset (&value);
+	}
+
+	return priv->dhcp6_config;
+}
+
+/**
  * nm_device_get_state:
  * @device: a #NMDevice
  *
diff --git a/libnm-glib/nm-device.h b/libnm-glib/nm-device.h
index da015d6..64694ec 100644
--- a/libnm-glib/nm-device.h
+++ b/libnm-glib/nm-device.h
@@ -32,6 +32,7 @@
 #include "nm-ip4-config.h"
 #include "nm-dhcp4-config.h"
 #include "nm-ip6-config.h"
+#include "nm-dhcp6-config.h"
 #include "nm-connection.h"
 
 G_BEGIN_DECLS
@@ -51,6 +52,7 @@ G_BEGIN_DECLS
 #define NM_DEVICE_IP4_CONFIG "ip4-config"
 #define NM_DEVICE_DHCP4_CONFIG "dhcp4-config"
 #define NM_DEVICE_IP6_CONFIG "ip6-config"
+#define NM_DEVICE_DHCP6_CONFIG "dhcp6-config"
 #define NM_DEVICE_STATE "state"
 #define NM_DEVICE_VENDOR "vendor"
 #define NM_DEVICE_PRODUCT "product"
@@ -89,6 +91,7 @@ gboolean      nm_device_get_managed        (NMDevice *device);
 NMIP4Config * nm_device_get_ip4_config     (NMDevice *device);
 NMDHCP4Config * nm_device_get_dhcp4_config (NMDevice *device);
 NMIP6Config * nm_device_get_ip6_config     (NMDevice *device);
+NMDHCP6Config * nm_device_get_dhcp6_config (NMDevice *device);
 NMDeviceState nm_device_get_state          (NMDevice *device);
 const char *  nm_device_get_product        (NMDevice *device);
 const char *  nm_device_get_vendor         (NMDevice *device);
diff --git a/libnm-glib/nm-dhcp6-config.c b/libnm-glib/nm-dhcp6-config.c
new file mode 100644
index 0000000..49eeda3
--- /dev/null
+++ b/libnm-glib/nm-dhcp6-config.c
@@ -0,0 +1,248 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
+ * Copyright (C) 2008 Novell, Inc.
+ */
+
+#include <string.h>
+
+#include "nm-dhcp6-config.h"
+#include "NetworkManager.h"
+#include "nm-types-private.h"
+#include "nm-object-private.h"
+#include "nm-utils.h"
+
+G_DEFINE_TYPE (NMDHCP6Config, nm_dhcp6_config, NM_TYPE_OBJECT)
+
+#define NM_DHCP6_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigPrivate))
+
+typedef struct {
+	DBusGProxy *proxy;
+
+	GHashTable *options;
+} NMDHCP6ConfigPrivate;
+
+enum {
+	PROP_0,
+	PROP_OPTIONS,
+
+	LAST_PROP
+};
+
+static void
+nm_dhcp6_config_init (NMDHCP6Config *config)
+{
+}
+
+static void
+copy_options (gpointer key, gpointer data, gpointer user_data)
+{
+	GHashTable *options = (GHashTable *) user_data;
+	GValue *value = (GValue *) data;
+
+	g_hash_table_insert (options, g_strdup (key), g_value_dup_string (value));
+}
+
+static gboolean
+demarshal_dhcp6_options (NMObject *object, GParamSpec *pspec, GValue *value, gpointer field)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+	GHashTable *new_options;
+
+	g_hash_table_remove_all (priv->options);
+
+	new_options = g_value_get_boxed (value);
+	if (new_options)
+		g_hash_table_foreach (new_options, copy_options, priv->options);
+
+	_nm_object_queue_notify (object, NM_DHCP6_CONFIG_OPTIONS);
+	return TRUE;
+}
+
+static void
+register_for_property_changed (NMDHCP6Config *config)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (config);
+	const NMPropertiesChangedInfo property_changed_info[] = {
+		{ NM_DHCP6_CONFIG_OPTIONS,   demarshal_dhcp6_options,  &priv->options },
+		{ NULL },
+	};
+
+	_nm_object_handle_properties_changed (NM_OBJECT (config),
+	                                     priv->proxy,
+	                                     property_changed_info);
+}
+
+static GObject*
+constructor (GType type,
+		   guint n_construct_params,
+		   GObjectConstructParam *construct_params)
+{
+	NMObject *object;
+	DBusGConnection *connection;
+	NMDHCP6ConfigPrivate *priv;
+
+	object = (NMObject *) G_OBJECT_CLASS (nm_dhcp6_config_parent_class)->constructor (type,
+																 n_construct_params,
+																 construct_params);
+	if (!object)
+		return NULL;
+
+	priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+
+	connection = nm_object_get_connection (object);
+
+	priv->proxy = dbus_g_proxy_new_for_name (connection,
+										   NM_DBUS_SERVICE,
+										   nm_object_get_path (object),
+										   NM_DBUS_INTERFACE_DHCP6_CONFIG);
+
+	register_for_property_changed (NM_DHCP6_CONFIG (object));
+
+	return G_OBJECT (object);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+
+	if (priv->options)
+		g_hash_table_destroy (priv->options);
+
+	g_object_unref (priv->proxy);
+
+	G_OBJECT_CLASS (nm_dhcp6_config_parent_class)->finalize (object);
+}
+
+static void
+get_property (GObject *object,
+              guint prop_id,
+              GValue *value,
+              GParamSpec *pspec)
+{
+	NMDHCP6Config *self = NM_DHCP6_CONFIG (object);
+
+	switch (prop_id) {
+	case PROP_OPTIONS:
+		g_value_set_boxed (value, nm_dhcp6_config_get_options (self));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_dhcp6_config_class_init (NMDHCP6ConfigClass *config_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (config_class);
+
+	g_type_class_add_private (config_class, sizeof (NMDHCP6ConfigPrivate));
+
+	/* virtual methods */
+	object_class->constructor = constructor;
+	object_class->get_property = get_property;
+	object_class->finalize = finalize;
+
+	/* properties */
+
+	/**
+	 * NMDHCP6Config:options:
+	 *
+	 * The #GHashTable containing options of the configuration.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_OPTIONS,
+		 g_param_spec_boxed (NM_DHCP6_CONFIG_OPTIONS,
+						       "Options",
+						       "Options",
+						       G_TYPE_HASH_TABLE,
+						       G_PARAM_READABLE));
+}
+
+/**
+ * nm_dhcp6_config_new:
+ * @connection: the #DBusGConnection
+ * @object_path: the DBus object path of the device
+ *
+ * Creates a new #NMDHCP6Config.
+ *
+ * Returns: a new configuration
+ **/
+GObject *
+nm_dhcp6_config_new (DBusGConnection *connection, const char *object_path)
+{
+	return (GObject *) g_object_new (NM_TYPE_DHCP6_CONFIG,
+									 NM_OBJECT_DBUS_CONNECTION, connection,
+									 NM_OBJECT_DBUS_PATH, object_path,
+									 NULL);
+}
+
+/**
+ * nm_dhcp6_config_get_options:
+ * @config: a #NMDHCP6Config
+ *
+ * Gets all the options contained in the configuration.
+ *
+ * Returns: the #GHashTable containing strings for keys and values.
+ * This is the internal copy used by the configuration, and must not be modified.
+ **/
+GHashTable *
+nm_dhcp6_config_get_options (NMDHCP6Config *config)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (config);
+	GValue value = { 0, };
+
+	if (g_hash_table_size (priv->options))
+		return priv->options;
+
+	if (!_nm_object_get_property (NM_OBJECT (config),
+	                             "org.freedesktop.DBus.Properties",
+	                             "Options",
+	                             &value))
+		goto out;
+
+	demarshal_dhcp6_options (NM_OBJECT (config), NULL, &value, &priv->options);	
+	g_value_unset (&value);
+
+out:
+	return priv->options;
+}
+
+/**
+ * nm_dhcp6_config_get_one_option:
+ * @config: a #NMDHCP6Config
+ * @option: the option to retrieve
+ *
+ * Gets one option by option name.
+ *
+ * Returns: the configuration option's value. This is the internal string used by the
+ * configuration, and must not be modified.
+ **/
+const char *
+nm_dhcp6_config_get_one_option (NMDHCP6Config *config, const char *option)
+{
+	g_return_val_if_fail (NM_IS_DHCP6_CONFIG (config), NULL);
+
+	return g_hash_table_lookup (nm_dhcp6_config_get_options (config), option);
+}
+
diff --git a/libnm-glib/nm-dhcp6-config.h b/libnm-glib/nm-dhcp6-config.h
new file mode 100644
index 0000000..91f32fa
--- /dev/null
+++ b/libnm-glib/nm-dhcp6-config.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
+ * Copyright (C) 2008 Novell, Inc.
+ */
+
+#ifndef NM_DHCP6_CONFIG_H
+#define NM_DHCP6_CONFIG_H
+
+#include <glib.h>
+#include <glib-object.h>
+#include <dbus/dbus-glib.h>
+#include "nm-object.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DHCP6_CONFIG            (nm_dhcp6_config_get_type ())
+#define NM_DHCP6_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP6_CONFIG, NMDHCP6Config))
+#define NM_DHCP6_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigClass))
+#define NM_IS_DHCP6_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+#define NM_IS_DHCP6_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+
+typedef struct {
+	NMObject parent;
+} NMDHCP6Config;
+
+typedef struct {
+	NMObjectClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+	void (*_reserved5) (void);
+	void (*_reserved6) (void);
+} NMDHCP6ConfigClass;
+
+#define NM_DHCP6_CONFIG_OPTIONS "options"
+
+GType nm_dhcp6_config_get_type (void);
+
+GObject *nm_dhcp6_config_new (DBusGConnection *connection, const char *object_path);
+
+GHashTable * nm_dhcp6_config_get_options (NMDHCP6Config *config);
+
+const char * nm_dhcp6_config_get_one_option (NMDHCP6Config *config, const char *option);
+
+G_END_DECLS
+
+#endif /* NM_DHCP6_CONFIG_H */
diff --git a/libnm-glib/nm-exported-connection.c b/libnm-glib/nm-exported-connection.c
index 8ca64e7..3a8e51c 100644
--- a/libnm-glib/nm-exported-connection.c
+++ b/libnm-glib/nm-exported-connection.c
@@ -228,7 +228,9 @@ impl_exported_connection_get_secrets (NMExportedConnection *self,
 	if (NM_EXPORTED_CONNECTION_GET_CLASS (self)->get_secrets)
 		NM_EXPORTED_CONNECTION_GET_CLASS (self)->get_secrets (self, setting_name, hints, request_new, context);
 	else {
-		error = g_error_new (0, 0, "%s: %s:%d get_secrets() unimplemented", __func__, __FILE__, __LINE__);
+		error = g_error_new (NM_SETTINGS_INTERFACE_ERROR,
+		                     NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		                     "%s: %s:%d get_secrets() unimplemented", __func__, __FILE__, __LINE__);
 		dbus_g_method_return_error (context, error);
 		g_error_free (error);
 	}
diff --git a/libnm-glib/nm-remote-connection.c b/libnm-glib/nm-remote-connection.c
index 6495647..5d104d0 100644
--- a/libnm-glib/nm-remote-connection.c
+++ b/libnm-glib/nm-remote-connection.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2009 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -324,12 +324,14 @@ constructor (GType type,
 	                                         nm_connection_get_path (NM_CONNECTION (object)),
 	                                         NM_DBUS_IFACE_SETTINGS_CONNECTION);
 	g_assert (priv->proxy);
+	dbus_g_proxy_set_default_timeout (priv->proxy, G_MAXINT);
 
 	priv->secrets_proxy = dbus_g_proxy_new_for_name (priv->bus,
 	                                                 service,
 	                                                 nm_connection_get_path (NM_CONNECTION (object)),
 	                                                 NM_DBUS_IFACE_SETTINGS_CONNECTION_SECRETS);
 	g_assert (priv->secrets_proxy);
+	dbus_g_proxy_set_default_timeout (priv->secrets_proxy, G_MAXINT);
 
 	dbus_g_proxy_add_signal (priv->proxy, "Updated", DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, G_TYPE_INVALID);
 	dbus_g_proxy_connect_signal (priv->proxy, "Updated", G_CALLBACK (updated_cb), object, NULL);
diff --git a/libnm-glib/nm-remote-settings-system.c b/libnm-glib/nm-remote-settings-system.c
index 4e30fda..95098c7 100644
--- a/libnm-glib/nm-remote-settings-system.c
+++ b/libnm-glib/nm-remote-settings-system.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2008 Novell, Inc.
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -280,6 +280,7 @@ constructor (GType type,
 	                                         NM_DBUS_PATH_SETTINGS,
 	                                         NM_DBUS_IFACE_SETTINGS_SYSTEM);
 	g_assert (priv->proxy);
+	dbus_g_proxy_set_default_timeout (priv->proxy, G_MAXINT);
 
 	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__BOXED,
 	                                   G_TYPE_NONE,
diff --git a/libnm-glib/nm-remote-settings.c b/libnm-glib/nm-remote-settings.c
index 55ae0f3..92814a1 100644
--- a/libnm-glib/nm-remote-settings.c
+++ b/libnm-glib/nm-remote-settings.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2008 Novell, Inc.
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -414,6 +414,7 @@ constructor (GType type,
 	                                         NM_DBUS_PATH_SETTINGS,
 	                                         NM_DBUS_IFACE_SETTINGS);
 	g_assert (priv->proxy);
+	dbus_g_proxy_set_default_timeout (priv->proxy, G_MAXINT);
 
 	dbus_g_proxy_add_signal (priv->proxy, "NewConnection",
 	                         DBUS_TYPE_G_OBJECT_PATH,
diff --git a/libnm-glib/nm-vpn-connection.c b/libnm-glib/nm-vpn-connection.c
index f66ed19..6910b6f 100644
--- a/libnm-glib/nm-vpn-connection.c
+++ b/libnm-glib/nm-vpn-connection.c
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2008 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -41,6 +41,17 @@ typedef struct {
 } NMVPNConnectionPrivate;
 
 enum {
+	PROP_0,
+	PROP_VPN_STATE,
+	PROP_BANNER,
+
+	LAST_PROP
+};
+
+#define DBUS_PROP_VPN_STATE "VpnState"
+#define DBUS_PROP_BANNER "Banner"
+
+enum {
 	VPN_STATE_CHANGED,
 
 	LAST_SIGNAL
@@ -74,8 +85,8 @@ nm_vpn_connection_get_banner (NMVPNConnection *vpn)
 
 	if (!priv->banner) {
 		priv->banner = _nm_object_get_string_property (NM_OBJECT (vpn),
-		                                              NM_DBUS_INTERFACE_VPN_CONNECTION,
-		                                              "Banner");
+		                                               NM_DBUS_INTERFACE_VPN_CONNECTION,
+		                                               DBUS_PROP_BANNER);
 		if (priv->banner && !strlen (priv->banner)) {
 			g_free (priv->banner);
 			priv->banner = NULL;
@@ -94,8 +105,8 @@ nm_vpn_connection_get_vpn_state (NMVPNConnection *vpn)
 	priv = NM_VPN_CONNECTION_GET_PRIVATE (vpn);
 	if (priv->vpn_state == NM_VPN_CONNECTION_STATE_UNKNOWN) {
 		priv->vpn_state = _nm_object_get_uint_property (NM_OBJECT (vpn),
-		                                           NM_DBUS_INTERFACE_VPN_CONNECTION,
-		                                           "VpnState");
+		                                                NM_DBUS_INTERFACE_VPN_CONNECTION,
+		                                                DBUS_PROP_VPN_STATE);
 	}
 	return priv->vpn_state;
 }
@@ -173,6 +184,27 @@ finalize (GObject *object)
 }
 
 static void
+get_property (GObject *object,
+              guint prop_id,
+              GValue *value,
+              GParamSpec *pspec)
+{
+	NMVPNConnection *self = NM_VPN_CONNECTION (object);
+
+	switch (prop_id) {
+	case PROP_VPN_STATE:
+		g_value_set_uint (value, nm_vpn_connection_get_vpn_state (self));
+		break;
+	case PROP_BANNER:
+		g_value_set_string (value, nm_vpn_connection_get_banner (self));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
 nm_vpn_connection_class_init (NMVPNConnectionClass *connection_class)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (connection_class);
@@ -181,8 +213,37 @@ nm_vpn_connection_class_init (NMVPNConnectionClass *connection_class)
 
 	/* virtual methods */
 	object_class->constructor = constructor;
+	object_class->get_property = get_property;
 	object_class->finalize = finalize;
 
+	/* properties */
+
+	/**
+	 * NMVPNConnection:vpn-state:
+	 *
+	 * The VPN state of the active VPN connection.
+	 **/
+	g_object_class_install_property (object_class, PROP_VPN_STATE,
+	                                 g_param_spec_uint (NM_VPN_CONNECTION_VPN_STATE,
+	                                                    "VpnState",
+	                                                    "Current VPN state",
+	                                                    NM_VPN_CONNECTION_STATE_UNKNOWN,
+	                                                    NM_VPN_CONNECTION_STATE_DISCONNECTED,
+	                                                    NM_VPN_CONNECTION_STATE_UNKNOWN,
+	                                                    G_PARAM_READABLE));
+
+	/**
+	 * NMVPNConnection:banner:
+	 *
+	 * The VPN login banner of the active VPN connection.
+	 **/
+	g_object_class_install_property (object_class, PROP_BANNER,
+	                                 g_param_spec_string (NM_VPN_CONNECTION_BANNER,
+	                                                      "Banner",
+	                                                      "Login Banner",
+	                                                      NULL,
+	                                                      G_PARAM_READABLE));
+
 	/* signals */
 	signals[VPN_STATE_CHANGED] =
 		g_signal_new ("vpn-state-changed",
diff --git a/libnm-glib/nm-vpn-connection.h b/libnm-glib/nm-vpn-connection.h
index 122a85b..e03a80c 100644
--- a/libnm-glib/nm-vpn-connection.h
+++ b/libnm-glib/nm-vpn-connection.h
@@ -18,7 +18,7 @@
  * Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2008 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #ifndef NM_VPN_CONNECTION_H
@@ -39,6 +39,9 @@ G_BEGIN_DECLS
 #define NM_IS_VPN_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_VPN_CONNECTION))
 #define NM_VPN_CONNECTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_VPN_CONNECTION, NMVPNConnectionClass))
 
+#define NM_VPN_CONNECTION_VPN_STATE "vpn-state"
+#define NM_VPN_CONNECTION_BANNER "banner"
+
 typedef struct {
 	NMActiveConnection parent;
 } NMVPNConnection;
diff --git a/libnm-util/Makefile.am b/libnm-util/Makefile.am
index 2aa4c4e..8f6a0cc 100644
--- a/libnm-util/Makefile.am
+++ b/libnm-util/Makefile.am
@@ -59,7 +59,7 @@ libnm_util_la_SOURCES=			\
 libnm_util_la_LIBADD = $(GLIB_LIBS) $(DBUS_LIBS) $(UUID_LIBS)
 
 libnm_util_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-util.ver \
-	-version-info "2:0:1"
+	-version-info "4:2:3"
 
 if WITH_GNUTLS
 libnm_util_la_SOURCES += crypto_gnutls.c
diff --git a/libnm-util/libnm-util.ver b/libnm-util/libnm-util.ver
index 17ce174..44d9ac5 100644
--- a/libnm-util/libnm-util.ver
+++ b/libnm-util/libnm-util.ver
@@ -132,9 +132,11 @@ global:
 	nm_setting_gsm_get_apn;
 	nm_setting_gsm_get_network_id;
 	nm_setting_gsm_get_network_type;
+	nm_setting_gsm_get_allowed_bands;
 	nm_setting_gsm_get_band;
 	nm_setting_gsm_get_pin;
 	nm_setting_gsm_get_puk;
+	nm_setting_gsm_get_home_only;
 	nm_setting_ip4_config_error_get_type;
 	nm_setting_ip4_config_error_quark;
 	nm_setting_ip4_config_get_type;
@@ -345,6 +347,7 @@ global:
 	nm_utils_ip4_addresses_to_gvalue;
 	nm_utils_ip4_netmask_to_prefix;
 	nm_utils_ip4_prefix_to_netmask;
+	nm_utils_ip4_get_default_prefix;
 	nm_utils_ip4_routes_from_gvalue;
 	nm_utils_ip4_routes_to_gvalue;
 	nm_utils_ip6_addresses_from_gvalue;
diff --git a/libnm-util/nm-setting-connection.c b/libnm-util/nm-setting-connection.c
index 1dedad3..65f613e 100644
--- a/libnm-util/nm-setting-connection.c
+++ b/libnm-util/nm-setting-connection.c
@@ -434,7 +434,7 @@ nm_setting_connection_class_init (NMSettingConnectionClass *setting_class)
 						  "(ie, contains only hexadecimal characters and '-'). "
 						  "The UUID should be assigned when the connection is "
 						  "created and never changed as long as the connection "
-						  "stilla pplies to the same network.  For example, "
+						  "still applies to the same network.  For example, "
 						  "it should not be changed when the user changes the "
 						  "connection's 'id', but should be recreated when the "
 						  "WiFi SSID, mobile broadband network provider, or the "
diff --git a/libnm-util/nm-setting-gsm.c b/libnm-util/nm-setting-gsm.c
index 626d219..4b4560c 100644
--- a/libnm-util/nm-setting-gsm.c
+++ b/libnm-util/nm-setting-gsm.c
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  * (C) Copyright 2007 - 2008 Novell, Inc.
  */
 
@@ -80,6 +80,8 @@ typedef struct {
 	guint32 allowed_bands;     /* A bitfield of NM_SETTING_GSM_BAND_* */
 
 	char *pin;
+
+	gboolean home_only;
 } NMSettingGsmPrivate;
 
 enum {
@@ -94,6 +96,7 @@ enum {
 	PROP_PIN,
 	PROP_PUK,
 	PROP_ALLOWED_BANDS,
+	PROP_HOME_ONLY,
 
 	LAST_PROP
 };
@@ -191,6 +194,14 @@ nm_setting_gsm_get_puk (NMSettingGsm *setting)
 	return NULL;
 }
 
+gboolean
+nm_setting_gsm_get_home_only (NMSettingGsm *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_GSM (setting), FALSE);
+
+	return NM_SETTING_GSM_GET_PRIVATE (setting)->home_only;
+}
+
 static gboolean
 verify (NMSetting *setting, GSList *all_settings, GError **error)
 {
@@ -356,6 +367,9 @@ set_property (GObject *object, guint prop_id,
 		if (str && strlen (str))
 			g_warning ("Tried to set deprecated property " NM_SETTING_GSM_SETTING_NAME "/" NM_SETTING_GSM_PUK);
 		break;
+	case PROP_HOME_ONLY:
+		priv->home_only = g_value_get_boolean (value);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -401,6 +415,9 @@ get_property (GObject *object, guint prop_id,
 		/* deprecated */
 		g_value_set_int (value, -1);
 		break;
+	case PROP_HOME_ONLY:
+		g_value_set_boolean (value, nm_setting_gsm_get_home_only (setting));
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -572,7 +589,8 @@ nm_setting_gsm_class_init (NMSettingGsmClass *setting_class)
 		                     || NM_SETTING_GSM_BAND_U800
 		                     || NM_SETTING_GSM_BAND_U850
 		                     || NM_SETTING_GSM_BAND_U900
-		                     || NM_SETTING_GSM_BAND_U17IX,
+		                     || NM_SETTING_GSM_BAND_U17IX
+		                     || NM_SETTING_GSM_BAND_U1900,
 		                    NM_SETTING_GSM_BAND_ANY,
 		                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
@@ -593,6 +611,22 @@ nm_setting_gsm_class_init (NMSettingGsmClass *setting_class)
 						  NULL,
 						  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE | NM_SETTING_PARAM_SECRET));
 
+	/**
+	 * NMSettingGsm:home-only:
+	 *
+	 * When TRUE, only connections to the home network will be allowed.
+	 * Connections to roaming networks will not be made.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_HOME_ONLY,
+		 g_param_spec_boolean (NM_SETTING_GSM_HOME_ONLY,
+						  "PIN",
+						  "When TRUE, only connections to the home network will "
+						  "be allowed.  Connections to roaming networks will "
+						  "not be made.",
+						  FALSE,
+						  G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
 	/* Deprecated properties */
 	/**
 	 * NMSettingGsm:puk:
diff --git a/libnm-util/nm-setting-gsm.h b/libnm-util/nm-setting-gsm.h
index 5b6a056..0ac7122 100644
--- a/libnm-util/nm-setting-gsm.h
+++ b/libnm-util/nm-setting-gsm.h
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  * (C) Copyright 2007 - 2008 Novell, Inc.
  */
 
@@ -61,6 +61,7 @@ GQuark nm_setting_gsm_error_quark (void);
 #define NM_SETTING_GSM_NETWORK_TYPE  "network-type"
 #define NM_SETTING_GSM_ALLOWED_BANDS "allowed-bands"
 #define NM_SETTING_GSM_PIN           "pin"
+#define NM_SETTING_GSM_HOME_ONLY     "home-only"
 
 /* DEPRECATED & UNUSED */
 #define NM_SETTING_GSM_PUK           "puk"
@@ -95,6 +96,7 @@ typedef enum {
 	NM_SETTING_GSM_BAND_U850         = 0x00000200, /* WCDMA 3GPP UMTS 850 MHz      (Class V) */
 	NM_SETTING_GSM_BAND_U900         = 0x00000400, /* WCDMA 3GPP UMTS 900 MHz      (Class VIII) */
 	NM_SETTING_GSM_BAND_U17IX        = 0x00000800, /* WCDMA 3GPP UMTS 1700 MHz     (Class IX) */
+	NM_SETTING_GSM_BAND_U1900        = 0x00001000, /* WCDMA 3GPP UMTS 1900 MHz     (Class II) */
 } NMSettingGsmNetworkBand;
 
 typedef struct {
@@ -122,6 +124,7 @@ const char *nm_setting_gsm_get_network_id    (NMSettingGsm *setting);
 int         nm_setting_gsm_get_network_type  (NMSettingGsm *setting);
 guint32     nm_setting_gsm_get_allowed_bands (NMSettingGsm *setting);
 const char *nm_setting_gsm_get_pin           (NMSettingGsm *setting);
+gboolean    nm_setting_gsm_get_home_only     (NMSettingGsm *setting);
 
 /* DEPRECATED & UNUSED */
 const char *nm_setting_gsm_get_puk           (NMSettingGsm *setting);
diff --git a/libnm-util/nm-setting-ip4-config.c b/libnm-util/nm-setting-ip4-config.c
index 580369f..46ebbd3 100644
--- a/libnm-util/nm-setting-ip4-config.c
+++ b/libnm-util/nm-setting-ip4-config.c
@@ -879,7 +879,7 @@ nm_setting_ip4_config_class_init (NMSettingIP4ConfigClass *setting_class)
 	 * NMSettingIP4Config:ignore-auto-dns:
 	 *
 	 * When the method is set to 'auto' and this property to TRUE, automatically
-	 * configured nameservers and search domains are ignored and only namservers
+	 * configured nameservers and search domains are ignored and only nameservers
 	 * and search domains specified in #NMSettingIP4Config:dns and
 	 * #NMSettingIP4Config:dns-search, if any, are used.
 	 **/
@@ -889,7 +889,7 @@ nm_setting_ip4_config_class_init (NMSettingIP4ConfigClass *setting_class)
 						   "Ignore automatic DNS",
 						   "When the method is set to 'auto' and this property "
 						   "to TRUE, automatically configured nameservers and "
-						   "search domains are ignored and only namservers and "
+						   "search domains are ignored and only nameservers and "
 						   "search domains specified in the 'dns' and 'dns-search' "
 						   "properties, if any, are used.",
 						   FALSE,
diff --git a/libnm-util/nm-setting-ip6-config.c b/libnm-util/nm-setting-ip6-config.c
index b1577f0..3fbf1a2 100644
--- a/libnm-util/nm-setting-ip6-config.c
+++ b/libnm-util/nm-setting-ip6-config.c
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -435,26 +435,23 @@ verify (NMSetting *setting, GSList *all_settings, GError **error)
 			             NM_SETTING_IP6_CONFIG_ADDRESSES);
 			return FALSE;
 		}
-	} else if (   !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
-	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)
+	} else if (   !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)
 	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)
 	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
-		if (!priv->ignore_auto_dns) {
-			if (priv->dns && g_slist_length (priv->dns)) {
-				g_set_error (error,
-				             NM_SETTING_IP6_CONFIG_ERROR,
-				             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
-				             NM_SETTING_IP6_CONFIG_DNS);
-				return FALSE;
-			}
-
-			if (g_slist_length (priv->dns_search)) {
-				g_set_error (error,
-				             NM_SETTING_IP6_CONFIG_ERROR,
-				             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
-				             NM_SETTING_IP6_CONFIG_DNS_SEARCH);
-				return FALSE;
-			}
+		if (g_slist_length (priv->dns)) {
+			g_set_error (error,
+			             NM_SETTING_IP6_CONFIG_ERROR,
+			             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
+			             NM_SETTING_IP6_CONFIG_DNS);
+			return FALSE;
+		}
+
+		if (g_slist_length (priv->dns_search)) {
+			g_set_error (error,
+			             NM_SETTING_IP6_CONFIG_ERROR,
+			             NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD,
+			             NM_SETTING_IP6_CONFIG_DNS_SEARCH);
+			return FALSE;
 		}
 
 		if (g_slist_length (priv->addresses)) {
@@ -464,6 +461,9 @@ verify (NMSetting *setting, GSList *all_settings, GError **error)
 			             NM_SETTING_IP6_CONFIG_ADDRESSES);
 			return FALSE;
 		}
+	} else if (   !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_AUTO)
+	           || !strcmp (priv->method, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
+		/* nothing to do */
 	} else {
 		g_set_error (error,
 		             NM_SETTING_IP6_CONFIG_ERROR,
@@ -598,30 +598,33 @@ nm_setting_ip6_config_class_init (NMSettingIP6ConfigClass *setting_class)
 	 *
 	 * IPv6 configuration method.  If 'auto' is specified then the appropriate
 	 * automatic method (DHCP, PPP, advertisement, etc) is used for the
-	 * interface and most other properties can be left unset.  If 'link-local'
-	 * is specified, then an IPv6 link-local address will be assigned to the
-	 * interface.  If 'manual' is specified, static IP addressing is used and
-	 * at least one IP address must be given in the 'addresses' property.  If
-	 * 'ignored' is specified, IPv6 configuration is not done. This property
-	 * must be set.  NOTE: DHCP configuration and the 'shared' method are not
-	 * yet supported.
+	 * interface and most other properties can be left unset.  To force the use
+	 * of DHCP only, specify 'dhcp'; this  method is only valid for ethernet-
+	 * based hardware.  If 'link-local' is specified, then an IPv6 link-local
+	 * address will be assigned to the interface.  If 'manual' is specified,
+	 * static IP addressing is used and at least one IP address must be given
+	 * in the 'addresses' property.  If 'ignored' is specified, IPv6
+	 * configuration is not done. This property must be set.  NOTE: the 'shared'
+	 * method are not yet supported.
 	 **/
 	g_object_class_install_property
 		(object_class, PROP_METHOD,
 		 g_param_spec_string (NM_SETTING_IP6_CONFIG_METHOD,
 						      "Method",
 						      "IPv6 configuration method.  If 'auto' is specified "
-						      "then the appropriate automatic method (DHCP, PPP, "
+						      "then the appropriate automatic method (PPP, router "
 						      "advertisement, etc) is used for the device and "
-						      "most other properties can be left unset.  If "
+						      "most other properties can be left unset.  To force "
+						      "the use of DHCP only, specify 'dhcp'; this method "
+						      "is only valid for ethernet-based hardware.  If "
 						      "'link-local' is specified, then an IPv6 link-local "
 						      "address will be assigned to the interface.  If "
 						      "'manual' is specified, static IP addressing is "
 						      "used and at least one IP address must be given in "
 						      " the 'addresses' property.  If 'ignored' is "
 						      "specified, IPv6 configuration is not done. This "
-						      "property must be set.  NOTE: DHCP configuration "
-						      "and the 'shared' method are not yet supported.",
+						      "property must be set.  NOTE: the 'shared' method"
+						      "is not yet supported.",
 						      NULL,
 						      G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
 
@@ -740,38 +743,39 @@ nm_setting_ip6_config_class_init (NMSettingIP6ConfigClass *setting_class)
 	/**
 	 * NMSettingIP6Config:ignore-auto-routes:
 	 *
-	 * When the method is set to 'auto' and this property to TRUE, automatically
-	 * configured routes are ignored and only routes specified in
-	 * #NMSettingIP6Config:routes, if any, are used.
+	 * When the method is set to 'auto' or 'dhcp' and this property is set to
+	 * TRUE, automatically configured routes are ignored and only routes
+	 * specified in #NMSettingIP6Config:routes, if any, are used.
 	 **/
 	g_object_class_install_property
 		(object_class, PROP_IGNORE_AUTO_ROUTES,
 		 g_param_spec_boolean (NM_SETTING_IP6_CONFIG_IGNORE_AUTO_ROUTES,
 						   "Ignore automatic routes",
-						   "When the method is set to 'auto' and this property "
-						   "to TRUE, automatically configured routes are "
-						   "ignored and only routes specified in the 'routes' "
-						   "property, if any, are used.",
+						   "When the method is set to 'auto' or 'dhcp' and this "
+						   "property is set to TRUE, automatically configured "
+						   "routes are ignored and only routes specified in the "
+						   "'routes' property, if any, are used.",
 						   FALSE,
 						   G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
 	/**
 	 * NMSettingIP6Config:ignore-auto-dns:
 	 *
-	 * When the method is set to 'auto' and this property to TRUE, automatically
-	 * configured nameservers and search domains are ignored and only namservers
-	 * and search domains specified in #NMSettingIP6Config:dns and
-	 * #NMSettingIP6Config:dns-search, if any, are used.
+	 * When the method is set to 'auto' or 'dhcp' and this property is set to
+	 * TRUE, automatically configured nameservers and search domains are ignored
+	 * and only nameservers and search domains specified in
+	 * #NMSettingIP6Config:dns and #NMSettingIP6Config:dns-search, if any, are
+	 * used.
 	 **/
 	g_object_class_install_property
 		(object_class, PROP_IGNORE_AUTO_DNS,
 		 g_param_spec_boolean (NM_SETTING_IP6_CONFIG_IGNORE_AUTO_DNS,
 						   "Ignore DHCPv6/RDNSS DNS",
-						   "When the method is set to 'auto' and this property "
-						   "to TRUE, automatically configured nameservers and "
-						   "search domains are ignored and only namservers and "
-						   "search domains specified in the 'dns' and 'dns-search' "
-						   "properties, if any, are used.",
+						   "When the method is set to 'auto' or 'dhcp' and this "
+						   "property is set to TRUE, automatically configured "
+						   "nameservers and search domains are ignored and only "
+						   "nameservers and search domains specified in the 'dns' "
+						   "and 'dns-search' properties, if any, are used.",
 						   FALSE,
 						   G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
 
diff --git a/libnm-util/nm-setting-ip6-config.h b/libnm-util/nm-setting-ip6-config.h
index 18082e4..b089679 100644
--- a/libnm-util/nm-setting-ip6-config.h
+++ b/libnm-util/nm-setting-ip6-config.h
@@ -19,7 +19,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2008 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  */
 
 #ifndef NM_SETTING_IP6_CONFIG_H
@@ -65,6 +65,7 @@ GQuark nm_setting_ip6_config_error_quark (void);
 
 #define NM_SETTING_IP6_CONFIG_METHOD_IGNORE     "ignore"
 #define NM_SETTING_IP6_CONFIG_METHOD_AUTO       "auto"
+#define NM_SETTING_IP6_CONFIG_METHOD_DHCP       "dhcp"
 #define NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL "link-local"
 #define NM_SETTING_IP6_CONFIG_METHOD_MANUAL     "manual"
 #define NM_SETTING_IP6_CONFIG_METHOD_SHARED     "shared"
diff --git a/libnm-util/nm-utils.c b/libnm-util/nm-utils.c
index 8ec872d..5ca3014 100644
--- a/libnm-util/nm-utils.c
+++ b/libnm-util/nm-utils.c
@@ -21,7 +21,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2005 - 2009 Red Hat, Inc.
+ * (C) Copyright 2005 - 2010 Red Hat, Inc.
  */
 
 #include <string.h>
@@ -624,7 +624,7 @@ nm_utils_convert_uint_array_to_string (const GValue *src_value, GValue *dest_val
 }
 
 static void
-nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValue *dest_value)
+nm_utils_convert_ip4_addr_route_struct_array_to_string (const GValue *src_value, GValue *dest_value)
 {
 	GPtrArray *ptr_array;
 	GString *printable;
@@ -639,6 +639,7 @@ nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValu
 		GArray *array;
 		char buf[INET_ADDRSTRLEN + 1];
 		struct in_addr addr;
+		gboolean is_addr; /* array contains address x route */
 
 		if (i > 0)
 			g_string_append (printable, ", ");
@@ -649,13 +650,17 @@ nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValu
 			g_string_append (printable, "invalid");
 			continue;
 		}
+		is_addr = (array->len < 4);
 
 		memset (buf, 0, sizeof (buf));
 		addr.s_addr = g_array_index (array, guint32, 0);
 		if (!inet_ntop (AF_INET, &addr, buf, INET_ADDRSTRLEN))
 			nm_warning ("%s: error converting IP4 address 0x%X",
 			            __func__, ntohl (addr.s_addr));
-		g_string_append_printf (printable, "ip = %s", buf);
+		if (is_addr)
+			g_string_append_printf (printable, "ip = %s", buf);
+		else
+			g_string_append_printf (printable, "dst = %s", buf);
 		g_string_append (printable, ", ");
 
 		memset (buf, 0, sizeof (buf));
@@ -670,7 +675,18 @@ nm_utils_convert_ip4_addr_struct_array_to_string (const GValue *src_value, GValu
 			if (!inet_ntop (AF_INET, &addr, buf, INET_ADDRSTRLEN))
 				nm_warning ("%s: error converting IP4 address 0x%X",
 				            __func__, ntohl (addr.s_addr));
-			g_string_append_printf (printable, "gw = %s", buf);
+			if (is_addr)
+				g_string_append_printf (printable, "gw = %s", buf);
+			else
+				g_string_append_printf (printable, "nh = %s", buf);
+		}
+
+		if (array->len > 3) {
+			g_string_append (printable, ", ");
+
+			memset (buf, 0, sizeof (buf));
+			g_string_append_printf (printable, "mt = %u",
+			                        g_array_index (array, guint32, 3));
 		}
 
 		g_string_append (printable, " }");
@@ -764,6 +780,203 @@ nm_utils_convert_byte_array_to_string (const GValue *src_value, GValue *dest_val
 	g_string_free (printable, FALSE);
 }
 
+static gboolean
+nm_utils_inet6_ntop (struct in6_addr *addr, char *buf)
+{
+	if (!inet_ntop (AF_INET6, addr, buf, INET6_ADDRSTRLEN)) {
+		int i;
+		GString *ip6_str = g_string_new (NULL);
+		g_string_append_printf (ip6_str, "%02X", addr->s6_addr[0]);
+		for (i = 1; i < 16; i++)
+			g_string_append_printf (ip6_str, " %02X", addr->s6_addr[i]);
+		nm_warning ("%s: error converting IP6 address %s",
+		            __func__, ip6_str->str);
+		g_string_free (ip6_str, TRUE);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static void
+nm_utils_convert_ip6_dns_array_to_string (const GValue *src_value, GValue *dest_value)
+{
+	GPtrArray *ptr_array;
+	GString *printable;
+	guint i = 0;
+
+	g_return_if_fail (g_type_is_a (G_VALUE_TYPE (src_value), DBUS_TYPE_G_ARRAY_OF_ARRAY_OF_UCHAR));
+
+	ptr_array = (GPtrArray *) g_value_get_boxed (src_value);
+
+	printable = g_string_new ("[");
+	while (ptr_array && (i < ptr_array->len)) {
+		GByteArray *bytearray;
+		char buf[INET6_ADDRSTRLEN];
+		struct in6_addr *addr;
+
+		if (i > 0)
+			g_string_append (printable, ", ");
+
+		bytearray = (GByteArray *) g_ptr_array_index (ptr_array, i++);
+		if (bytearray->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) bytearray->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "%s", buf);
+	}
+	g_string_append_c (printable, ']');
+
+	g_value_take_string (dest_value, printable->str);
+	g_string_free (printable, FALSE);
+}
+
+static void
+nm_utils_convert_ip6_addr_struct_array_to_string (const GValue *src_value, GValue *dest_value)
+{
+	GPtrArray *ptr_array;
+	GString *printable;
+	guint i = 0;
+
+	g_return_if_fail (g_type_is_a (G_VALUE_TYPE (src_value), DBUS_TYPE_G_ARRAY_OF_IP6_ADDRESS));
+
+	ptr_array = (GPtrArray *) g_value_get_boxed (src_value);
+
+	printable = g_string_new ("[");
+	while (ptr_array && (i < ptr_array->len)) {
+		GValueArray *elements;
+		GValue *tmp;
+		GByteArray *ba_addr;
+		char buf[INET6_ADDRSTRLEN];
+		struct in6_addr *addr;
+		guint32 prefix;
+
+		if (i > 0)
+			g_string_append (printable, ", ");
+
+		g_string_append (printable, "{ ");
+		elements = (GValueArray *) g_ptr_array_index (ptr_array, i++);
+		if (   (elements->n_values != 2)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 0)) != DBUS_TYPE_G_UCHAR_ARRAY)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 1)) != G_TYPE_UINT)) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+
+		/* IPv6 address */
+		tmp = g_value_array_get_nth (elements, 0);
+		ba_addr = g_value_get_boxed (tmp);
+		if (ba_addr->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) ba_addr->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "ip = %s", buf);
+		g_string_append (printable, ", ");
+
+		/* Prefix */
+		tmp = g_value_array_get_nth (elements, 1);
+		prefix = g_value_get_uint (tmp);
+		if (prefix > 128) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		g_string_append_printf (printable, "px = %u", prefix);
+		g_string_append (printable, " }");
+	}
+	g_string_append_c (printable, ']');
+
+	g_value_take_string (dest_value, printable->str);
+	g_string_free (printable, FALSE);
+}
+
+static void
+nm_utils_convert_ip6_route_struct_array_to_string (const GValue *src_value, GValue *dest_value)
+{
+	GPtrArray *ptr_array;
+	GString *printable;
+	guint i = 0;
+
+	g_return_if_fail (g_type_is_a (G_VALUE_TYPE (src_value), DBUS_TYPE_G_ARRAY_OF_IP6_ROUTE));
+
+	ptr_array = (GPtrArray *) g_value_get_boxed (src_value);
+
+	printable = g_string_new ("[");
+	while (ptr_array && (i < ptr_array->len)) {
+		GValueArray *elements;
+		GValue *tmp;
+		GByteArray *ba_addr;
+		char buf[INET6_ADDRSTRLEN];
+		struct in6_addr *addr;
+		guint32 prefix, metric;
+
+		if (i > 0)
+			g_string_append (printable, ", ");
+
+		g_string_append (printable, "{ ");
+		elements = (GValueArray *) g_ptr_array_index (ptr_array, i++);
+		if (   (elements->n_values != 4)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 0)) != DBUS_TYPE_G_UCHAR_ARRAY)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 1)) != G_TYPE_UINT)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 2)) != DBUS_TYPE_G_UCHAR_ARRAY)
+		    || (G_VALUE_TYPE (g_value_array_get_nth (elements, 3)) != G_TYPE_UINT)) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+
+		/* Destination address */
+		tmp = g_value_array_get_nth (elements, 0);
+		ba_addr = g_value_get_boxed (tmp);
+		if (ba_addr->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) ba_addr->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "dst = %s", buf);
+		g_string_append (printable, ", ");
+
+		/* Prefix */
+		tmp = g_value_array_get_nth (elements, 1);
+		prefix = g_value_get_uint (tmp);
+		if (prefix > 128) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		g_string_append_printf (printable, "px = %u", prefix);
+		g_string_append (printable, ", ");
+
+		/* Next hop addresses */
+		tmp = g_value_array_get_nth (elements, 2);
+		ba_addr = g_value_get_boxed (tmp);
+		if (ba_addr->len != 16) {
+			g_string_append (printable, "invalid");
+			continue;
+		}
+		addr = (struct in6_addr *) ba_addr->data;
+		memset (buf, 0, sizeof (buf));
+		nm_utils_inet6_ntop (addr, buf);
+		g_string_append_printf (printable, "nh = %s", buf);
+		g_string_append (printable, ", ");
+
+		/* Metric */
+		tmp = g_value_array_get_nth (elements, 3);
+		metric = g_value_get_uint (tmp);
+		g_string_append_printf (printable, "mt = %u", metric);
+
+		g_string_append (printable, " }");
+	}
+	g_string_append_c (printable, ']');
+
+	g_value_take_string (dest_value, printable->str);
+	g_string_free (printable, FALSE);
+}
+
 void
 _nm_utils_register_value_transformations (void)
 {
@@ -781,7 +994,7 @@ _nm_utils_register_value_transformations (void)
 		                                 nm_utils_convert_uint_array_to_string);
 		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_ARRAY_OF_UINT,
 		                                 G_TYPE_STRING, 
-		                                 nm_utils_convert_ip4_addr_struct_array_to_string);
+		                                 nm_utils_convert_ip4_addr_route_struct_array_to_string);
 		g_value_register_transform_func (DBUS_TYPE_G_MAP_OF_VARIANT,
 		                                 G_TYPE_STRING, 
 		                                 nm_utils_convert_gvalue_hash_to_string);
@@ -791,6 +1004,15 @@ _nm_utils_register_value_transformations (void)
 		g_value_register_transform_func (DBUS_TYPE_G_UCHAR_ARRAY,
 		                                 G_TYPE_STRING,
 		                                 nm_utils_convert_byte_array_to_string);
+		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_ARRAY_OF_UCHAR,
+		                                 G_TYPE_STRING, 
+		                                 nm_utils_convert_ip6_dns_array_to_string);
+		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_IP6_ADDRESS,
+		                                 G_TYPE_STRING, 
+		                                 nm_utils_convert_ip6_addr_struct_array_to_string);
+		g_value_register_transform_func (DBUS_TYPE_G_ARRAY_OF_IP6_ROUTE,
+		                                 G_TYPE_STRING, 
+		                                 nm_utils_convert_ip6_route_struct_array_to_string);
 		registered = TRUE;
 	}
 }
@@ -1209,6 +1431,41 @@ nm_utils_ip4_prefix_to_netmask (guint32 prefix)
 }
 
 
+/**
+ * nm_utils_ip4_get_default_prefix:
+ * @ip: an IPv4 address (in network byte order)
+ *
+ * When the Internet was originally set up, various ranges of IP addresses were
+ * segmented into three network classes: A, B, and C.  This function will return
+ * a prefix that is associated with the IP address specified defining where it
+ * falls in the predefined classes.
+ *
+ * Returns: the default class prefix for the given IP
+ **/
+/* The function is originally from ipcalc.c of Red Hat's initscripts. */
+guint32
+nm_utils_ip4_get_default_prefix (guint32 ip)
+{
+	if (((ntohl (ip) & 0xFF000000) >> 24) <= 127)
+		return 8;  /* Class A - 255.0.0.0 */
+	else if (((ntohl (ip) & 0xFF000000) >> 24) <= 191)
+		return 16;  /* Class B - 255.255.0.0 */
+
+	return 24;  /* Class C - 255.255.255.0 */
+}
+
+/**
+ * nm_utils_ip6_addresses_from_gvalue:
+ * @value: gvalue containing a GPtrArray of GValueArrays of (GArray of guchars) and guint32
+ *
+ * Utility function to convert a #GPtrArray of #GValueArrays of (#GArray of guchars) and guint32
+ * representing a list of NetworkManager IPv6 addresses (which is a pair of address
+ * and prefix), into a GSList of #NMIP6Address objects.  The specific format of
+ * this serialization is not guaranteed to be stable and the #GValueArray may be
+ * extended in the future.
+ *
+ * Returns: a newly allocated #GSList of #NMIP6Address objects
+ **/
 GSList *
 nm_utils_ip6_addresses_from_gvalue (const GValue *value)
 {
@@ -1257,6 +1514,19 @@ nm_utils_ip6_addresses_from_gvalue (const GValue *value)
 	return g_slist_reverse (list);
 }
 
+/**
+ * nm_utils_ip6_addresses_to_gvalue:
+ * @list: a list of #NMIP6Address objects
+ * @value: a pointer to a #GValue into which to place the converted addresses,
+ * which should be unset by the caller (when no longer needed) with
+ * g_value_unset().
+ *
+ * Utility function to convert a #GSList of #NMIP6Address objects into a
+ * GPtrArray of GValueArrays of (GArray or guchars) and guint32 representing a list
+ * of NetworkManager IPv6 addresses (which is a pair of address and prefix).
+ * The specific format of this serialization is not guaranteed to be stable and may be
+ * extended in the future.
+ **/
 void
 nm_utils_ip6_addresses_to_gvalue (GSList *list, GValue *value)
 {
@@ -1291,6 +1561,19 @@ nm_utils_ip6_addresses_to_gvalue (GSList *list, GValue *value)
 	g_value_take_boxed (value, addresses);
 }
 
+/**
+ * nm_utils_ip6_routes_from_gvalue:
+ * @value: gvalue containing a GPtrArray of GValueArrays of (GArray or guchars), guint32,
+ * (GArray of guchars), and guint32
+ *
+ * Utility function GPtrArray of GValueArrays of (GArray or guchars), guint32,
+ * (GArray of guchars), and guint32 representing a list of NetworkManager IPv6
+ * routes (which is a tuple of destination, prefix, next hop, and metric)
+ * into a GSList of #NMIP6Route objects.  The specific format of this serialization
+ * is not guaranteed to be stable and may be extended in the future.
+ *
+ * Returns: a newly allocated #GSList of #NMIP6Route objects
+ **/
 GSList *
 nm_utils_ip6_routes_from_gvalue (const GValue *value)
 {
@@ -1343,6 +1626,19 @@ nm_utils_ip6_routes_from_gvalue (const GValue *value)
 	return g_slist_reverse (list);
 }
 
+/**
+ * nm_utils_ip6_routes_to_gvalue:
+ * @list: a list of #NMIP6Route objects
+ * @value: a pointer to a #GValue into which to place the converted routes,
+ * which should be unset by the caller (when no longer needed) with
+ * g_value_unset().
+ *
+ * Utility function to convert a #GSList of #NMIP6Route objects into a GPtrArray of
+ * GValueArrays of (GArray or guchars), guint32, (GArray of guchars), and guint32
+ * representing a list of NetworkManager IPv6 routes (which is a tuple of destination,
+ * prefix, next hop, and metric).  The specific format of this serialization is not 
+ * guaranteed to be stable and may be extended in the future.
+ **/
 void
 nm_utils_ip6_routes_to_gvalue (GSList *list, GValue *value)
 {
diff --git a/libnm-util/nm-utils.h b/libnm-util/nm-utils.h
index bbb304f..8308a23 100644
--- a/libnm-util/nm-utils.h
+++ b/libnm-util/nm-utils.h
@@ -20,7 +20,7 @@
  * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2005 - 2008 Red Hat, Inc.
+ * (C) Copyright 2005 - 2010 Red Hat, Inc.
  */
 
 #ifndef NM_UTILS_H
@@ -192,6 +192,7 @@ void nm_utils_ip4_routes_to_gvalue (GSList *list, GValue *value);
 
 guint32 nm_utils_ip4_netmask_to_prefix (guint32 netmask);
 guint32 nm_utils_ip4_prefix_to_netmask (guint32 prefix);
+guint32 nm_utils_ip4_get_default_prefix (guint32 ip);
 
 GSList *nm_utils_ip6_addresses_from_gvalue (const GValue *value);
 void nm_utils_ip6_addresses_to_gvalue (GSList *list, GValue *value);
diff --git a/libnm-util/tests/test-settings-defaults.c b/libnm-util/tests/test-settings-defaults.c
index 7f0adc5..9f38a14 100644
--- a/libnm-util/tests/test-settings-defaults.c
+++ b/libnm-util/tests/test-settings-defaults.c
@@ -118,7 +118,7 @@ int main (int argc, char **argv)
 	test_defaults (NM_TYPE_SETTING_CDMA, NM_SETTING_CDMA_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_GSM, NM_SETTING_GSM_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_IP4_CONFIG, NM_SETTING_IP4_CONFIG_SETTING_NAME);
-//	test_defaults (NM_TYPE_SETTING_IP6_CONFIG, NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	test_defaults (NM_TYPE_SETTING_IP6_CONFIG, NM_SETTING_IP6_CONFIG_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_PPP, NM_SETTING_PPP_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_PPPOE, NM_SETTING_PPPOE_SETTING_NAME);
 	test_defaults (NM_TYPE_SETTING_SERIAL, NM_SETTING_SERIAL_SETTING_NAME);
diff --git a/man/Makefile.am b/man/Makefile.am
index c3000d7..7cbc5a1 100644
--- a/man/Makefile.am
+++ b/man/Makefile.am
@@ -1,8 +1,15 @@
 man_MANS =				\
 	NetworkManager.8		\
+	NetworkManager.conf.5		\
+	nm-system-settings.conf.5	\
 	nm-tool.1
 
 EXTRA_DIST =				\
 	$(man_MANS)			\
 	NetworkManager.8.in		\
+	NetworkManager.conf.5.in	\
+	nm-system-settings.conf.5.in	\
 	nm-tool.1.in
+
+CLEANFILES = $(man_MANS)
+
diff --git a/man/NetworkManager.8.in b/man/NetworkManager.8.in
index 426cc7b..a6be073 100644
--- a/man/NetworkManager.8.in
+++ b/man/NetworkManager.8.in
@@ -1,14 +1,14 @@
 .\" NetworkManager(8) manual page
 .\"
-.\" Copyright (C) 2005 - 2009 Red Hat, Inc.
+.\" Copyright (C) 2005 - 2010 Red Hat, Inc.
 .\" Copyright (C) 2005 - 2009 Novell, Inc.
 .\" Copyright (C) 2005 Robert Love
 .\"
-.TH NETWORKMANAGER "8"
+.TH NETWORKMANAGER "8" "January 29, 2010"
 .SH NAME
 NetworkManager \- network management daemon
 .SH SYNOPSIS
-.B NetworkManager [\-\-no-daemon]
+.B NetworkManager [\-\-no\-daemon] [\-\-pid\-file=<filename>] [\-\-state\-file=<filename>] [\-\-config=<filename>] [\-\-plugins=<plugin1>,plugin2>,...] [\-\-log\-level=<level>] [\-\-log\-domains=<domain1>,<domain2>,...]
 .SH DESCRIPTION
 The \fINetworkManager\fP daemon attempts to make  networking configuration and
 operation as painless and automatic as possible by managing the primary network
@@ -18,7 +18,7 @@ connection for that device becomes available, unless that behavior is disabled.
 Information about networking is exported via a D-Bus interface to any interested
 application, providing a rich API with which to inspect and control network
 settings and operation.
-.TP
+.P
 NetworkManager will execute scripts in the /etc/NetworkManager/dispatcher.d
 directory in alphabetical order in response to network events.  Each script
 should be (a) a regular file, (b) owned by root, (c) not writable by group or
@@ -29,12 +29,12 @@ and second an action.
 .I "up"
 The interface has been activated.  The environment contains more information
 about the interface; CONNECTION_UUID contains the UUID of the connection.  Other
-variables are IP4_ADDRESS_N where N is a number from 0 to (# IPv4 addresses - 1),
+variables are IP4_ADDRESS_N where N is a number from 0 to (# IPv4 addresses \- 1),
 in the format "address/prefix gateway".  IP4_NUM_ADDRESSES contains the number
 addresses the script may expect.  IP4_NAMESERVERS contains a space-separated
 list of the DNS servers, and IP4_DOMAINS contains a space-separated list of the
 search domains.  Routes use the format IP4_ROUTE_N where N is a number from 0
-to (# IPv4 routes - 1), in the format "address/prefix next-hop metric", and
+to (# IPv4 routes \- 1), in the format "address/prefix next-hop metric", and
 IP4_NUM_ROUTES contains the number of routes to expect.  If the connection used
 DHCP for address configuration, the received DHCP configuration is passed in the
 environment using standard DHCP option names, prefixed with "DHCP4_", like
@@ -43,11 +43,11 @@ environment using standard DHCP option names, prefixed with "DHCP4_", like
 .I "down"
 The interface has been deactivated.
 .TP
-.I "vpn-up"
+.I "vpn\-up"
 A VPN connection has been activated.  The environment contains the connection
 UUID in the variable CONNECTION_UUID.
 .TP
-.I "vpn-down"
+.I "vpn\-down"
 A VPN connection has been deactivated.
 .TP
 .I "hostname"
@@ -55,21 +55,54 @@ The system hostname has been updated.  Use gethostname(2) to retrieve it.
 .SH OPTIONS
 The following options are supported:
 .TP
-.I "--no-daemon"
+.I "\-\-no\-daemon"
 Do not daemonize.  This is useful for debugging, and directs log output to the
 controlling terminal in addition to syslog.
+.TP
+.I "\-\-pid\-file=<filename>"
+Specify location of a PID file.  The PID file is used for storing PID of the
+running proccess and prevents running multiple instances.
+.TP
+.I "\-\-state\-file=<filename>"
+Specify file for storing state of the NetworkManager persistently.  If not specified,
+the default value of '<LOCALSTATEDIR>/lib/NetworkManager/NetworkManager.state' is
+used; where <LOCALSTATEDIR> is dependent on your distribution (usually it's /var).
+.TP
+.I "\-\-config=<filename>"
+Specify configuration file to set up various settings for NetworkManager.  If not
+specified, the default value of '<SYSCONFDIR>/NetworkManager/NetworkManager.conf'
+is used with a fallback to the older 'nm\-system\-settings.conf' if located in
+the same directory; where <SYSCONFDIR> is dependent on your distribution (usually
+it's /etc).  See \fBNetworkManager.conf\fP(5) for more information on configuration
+file.
+.TP
+.I "\-\-plugins=<plugin1>,<plugin2>, ...
+List plugins used to manage system-wide connection settings.   This list has
+preference over plugins specified in the configuration file.  Currently supported
+plugins are: keyfile, ifcfg\-rh, ifcfg\-suse, ifupdown.
+See \fBNetworkManager.conf\fP(5) for more information on the plugins.
+.TP
+.I "\-\-log\-level=<level>
+Sets how much information NetworkManager sends to the log destination (usually
+syslog's "daemon" facility).  By default, only informational, warning, and error
+messages are logged.  See \fBNetworkManager.conf\fP(5) for more information on
+log levels and domains.
+.TP
+.I "\-\-log\-domains=<domain1>,<domain2>, ...
+Sets which operations are logged to the log destination (usually syslog).  By
+default, most domains are logging-enabled.  See \fBNetworkManager.conf\fP(5) for
+more information on log levels and domains.
 .SH DEBUGGING
 The following environment variables are supported to help debugging.  When used
-in conjunction with the "--no-daemon" option (thus echoing PPP and DHCP helper
+in conjunction with the "\-\-no\-daemon" option (thus echoing PPP and DHCP helper
 output to stdout) these can quickly help pinpoint the source of connection
-issues.
-.TP
-.I "NM_SERIAL_DEBUG"
-When set to anything, causes NetworkManager to log all serial communication to
-and from serial devices like mobile broadband 3G modems.
+issues.  Also see the \-\-log\-level and \-\-log\-domains to enable debug logging inside
+NetworkManager itself.
 .TP
 .I "NM_PPP_DEBUG"
 When set to anything, causes NetworkManager to turn on PPP debugging in pppd,
 which logs all PPP and PPTP frames and client/server exchanges.
 .SH SEE ALSO
-.BR nm-tool (1)
+.BR nm\-tool (1),
+.BR NetworkManager.conf (5).
+
diff --git a/man/NetworkManager.conf.5.in b/man/NetworkManager.conf.5.in
new file mode 100644
index 0000000..c3af611
--- /dev/null
+++ b/man/NetworkManager.conf.5.in
@@ -0,0 +1,139 @@
+.\" NetworkManager.conf(5) manual page
+.\"
+.\" Copyright (C) 2010 Red Hat, Inc.
+.\"
+.TH "NetworkManager.conf" "5" "1 February 2010" ""
+.SH NAME
+NetworkManager.conf \- NetworkManager configuration file
+.SH SYNOPSIS
+/etc/NetworkManager/NetworkManager.conf
+.br
+or
+.br
+\fI<SYSCONFDIR>\fP/NetworkManager/NetworkManager.conf
+.br
+where <SYSCONFDIR> depends on your distribution or build.
+.SH DESCRIPTION
+.P
+.I NetworkManager.conf
+is a configuration file for NetworkManager. It is used to set up various
+aspects of NetworkManager's behavior. The location of
+the file may be changed through use of the "\-\-config=" argument for
+\fBNetworkManager\fP (8).
+
+It is not necessary to restart NetworkManager when making changes, as the
+configuration file is watched for changes and reloaded automatically when necessary.
+.SH "FILE FORMAT"
+.P
+The configuration file format is so-called key file (sort of ini-style format).
+It consists of sections (groups) of key-value pairs. Lines beginning with a '#' and blank
+lines are considered comments. Sections are started by a header line containing
+the section enclosed in '[' and ']', and ended implicitly by the start of
+the next section or the end of the file. Each key-value pair must be contained
+in a section.
+.br
+Minimal system settings configuration file looks like this:
+.P
+.nf
+[main]
+plugins=keyfile
+.fi
+.P
+Description of sections and available keys follows:
+.SS [main]
+This section is the only mandatory section of the configuration file.
+.TP
+.B plugins=\fIplugin1\fP,\fIplugin2\fP, ...
+List plugin names separated by ','. Plugins are used to read/write system-wide
+connection. When more plugins are specified, the connections are read from all
+listed plugins. When writing connections, the plugins will be asked to save the
+connection in the order listed here. If the first plugin cannot write out that
+connection type, or can't write out any connections, the next plugin is tried.
+If none of the plugins can save the connection, the error is returned to the user.
+.P
+.RS
+.B "Available plugins:"
+.br
+.TP 
+.I keyfile
+plugin is the generic plugin that supports all the connection types and
+capabilities that NetworkManager has. It writes files out in a .ini-style format in
+/etc/NetworkManager/system-connections. For security, it will ignore files
+that are readable or writeable by any user or group other than
+.I root
+since private keys and passphrases may be stored in plaintext inside the file.
+.TP 
+.I ifcfg\-rh
+plugin is used on the Fedora and Red Hat Enterprise Linux distributions
+to read and write configuration from the standard /etc/sysconfig/network-scripts/ifcfg-* files.
+It currently supports reading wired, WiFi, and 802.1x connections, but does not yet support reading
+or writing mobile broadband, PPPoE, or VPN connections. To allow reading and writing of these
+add \fIkeyfile\fP plugin to your configuration as well.
+.TP
+.I ifupdown
+plugin is used on the Debian and Ubuntu distributions, and reads connections from
+/etc/network/interfaces. Since it cannot write connections out (that support isn't planned),
+it is usually paired with the \fIkeyfile\fP plugin to enable saving and editing of new connections.
+The \fIifupdown\fP plugin supports basic wired and WiFi connections, including WPA-PSK.
+.TP
+.I ifcfg\-suse
+plugin is only provided for simple backward compatibility with SUSE and OpenSUSE configuration.
+Most setups should be using the \fIkeyfile\fP plugin instead. The \fIifcfg\-suse\fP plugin supports
+reading wired and WiFi connections, but does not support saving any connection types.
+.RE
+.TP
+.B dhcp=\fIdhclient\fP | \fIdhcpcd\fP
+This key sets up what DHCP client NetworkManager will use. Presently
+\fIdhclient\fP and \fIdhcpcd\fP are supported. The client configured here should
+be available on your system too. If this key is missing, available DHCP clients
+are looked for in this order: dhclient, dhcpcd.
+.SS [keyfile]
+This section contains keyfile-specific options and thus only has effect when using \fIkeyfile\fP plugin.
+.TP
+.B hostname=\fI<hostname>\fP
+Set a persistent hostname when using the \fIkeyfile\fP plugin.
+.TP
+.B unmanaged-devices=\fImac:<hwaddr>\fP;\fImac:<hwaddr>\fP;...
+Set devices that should be ignored by NetworkManager when using the \fIkeyfile\fP
+plugin. Devices are specified in the following format: "mac:<hwaddr>", where
+<hwaddr> is MAC address of the device to be ignored, in lowercase. Multiple
+entries are separated by a semicolon. Example:
+.nf
+unmanaged-devices=mac:00:22:68:1c:59:b1;mac:00:1e:65:30:d1:c4
+.fi
+.SS [ifupdown]
+This section contains ifupdown-specific options and thus only has effect when using \fIifupdown\fP plugin.
+.TP
+.B managed=\fIfalse\fP | \fItrue\fP
+Controls whether interfaces listed in the 'interfaces' file are managed by NetworkManager.
+If set to \fItrue\fP, then interfaces listed in /etc/network/interfaces are managed by NetworkManager.
+If set to \fIfalse\fP, then any interface listed in /etc/network/interfaces will be
+ignored by NetworkManager. Remember that NetworkManager controls the default route,
+so because the interface is ignored, NetworkManager may assign the default route to
+some other interface.
+When the option is missing, \fIfalse\fP value is taken as default.
+.SS [logging]
+This section controls NetworkManager's logging.  Any settings here are
+overridden by the \-\-log\-level and \-\-log\-domains command-line options.
+.TP
+.B level=\fI<level>\fP
+One of [ERR, WARN, INFO, DEBUG].  The ERR level logs only critical errors.  WARN
+logs warnings that may reflect operation.  INFO logs various informational
+messages that are useful for tracking state and operations.  DEBUG enables
+verbose logging for debugging purposes.  Subsequent levels also log all messages
+from earlier levels; thus setting the log level to INFO also logs error and
+warning messages.
+.TP
+.B domains=\fI<domain1>,<domain2>, ...\fP
+The following log domains are available: [NONE, HW, RKILL, ETHER, WIFI, BT, MB,
+DHCP4, DHCP6, PPP, WIFI_SCAN, IP4, IP6, AUTOIP4, DNS, VPN, SHARING, SUPPLICANT,
+USER_SET, SYS_SET, SUSPEND, CORE, DEVICE, OLPC].  When "NONE" is given by itself,
+logging is disabled.  MB = Mobile Broadband, USER_SET = user settings operations
+and communication, SYS_SET = system settings service operations, OLPC = OLPC
+Mesh device operations, CORE = core daemon operations, DEVICE = activation and
+general interface operations.
+.SH "SEE ALSO"
+.BR http://live.gnome.org/NetworkManager/SystemSettings
+.sp
+.BR NetworkManager (8),
+.BR nm\-tool (1).
diff --git a/man/nm-system-settings.conf.5.in b/man/nm-system-settings.conf.5.in
new file mode 100644
index 0000000..e48d0c8
--- /dev/null
+++ b/man/nm-system-settings.conf.5.in
@@ -0,0 +1,26 @@
+.\" nm-system-settings.conf(5) manual page
+.\"
+.\" Copyright (C) 2010 Red Hat, Inc.
+.\"
+.TH "nm-system-settings.conf" "5" "1 February 2010" ""
+.SH NAME
+nm\-system\-settings.conf \- Deprecated NetworkManager configuration file
+.SH SYNOPSIS
+/etc/NetworkManager/nm\-system\-settings.conf
+.br
+or
+.br
+\fI<SYSCONFDIR>\fP/NetworkManager/nm\-system\-settings.conf
+.br
+where <SYSCONFDIR> depends on your distribution or build.
+.SH DESCRIPTION
+.P
+.I nm\-system\-settings.conf
+is a deprecated configuration file for \fBNetworkManager\fP (5).  While this
+file can still be used, NetworkManager now defaults to reading the config
+file <SYSCONFDIR>\fP/NetworkManager/NetworkManager.conf\fP instead, falling back
+to nm\-system\-settings.conf if NetworkManager.conf does not exist.
+.SH "SEE ALSO"
+.BR NetworkManager (8),
+.BR NetworkManager.conf (5),
+.BR nm\-tool (1).
diff --git a/marshallers/nm-marshal.list b/marshallers/nm-marshal.list
index 38669dd..e19f8be 100644
--- a/marshallers/nm-marshal.list
+++ b/marshallers/nm-marshal.list
@@ -16,10 +16,14 @@ VOID:STRING,STRING,STRING,UINT
 VOID:OBJECT,UINT,UINT
 VOID:STRING,INT
 VOID:STRING,UINT
+VOID:STRING,UINT,BOOLEAN
 VOID:OBJECT,OBJECT,ENUM
 VOID:POINTER,STRING
 VOID:STRING,BOXED
 BOOLEAN:POINTER,STRING,BOOLEAN,UINT,STRING,STRING
+VOID:STRING,BOOLEAN,UINT,STRING,STRING
 BOOLEAN:VOID
 VOID:STRING,BOOLEAN
+VOID:STRING,OBJECT,POINTER
+VOID:BOOLEAN,UINT
 
diff --git a/po/LINGUAS b/po/LINGUAS
index 4ab6fac..9494643 100644
--- a/po/LINGUAS
+++ b/po/LINGUAS
@@ -22,6 +22,7 @@ fr
 gl
 gu
 he
+hi
 hr
 hu
 id
@@ -34,6 +35,7 @@ ku
 lt
 lv
 mk
+ml
 mr
 nb
 ne
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 44235ea..2cf4d23 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -1,14 +1,21 @@
 [encoding: UTF-8]
 # List of source files containing translatable strings.
 # Please keep this file sorted alphabetically.
+cli/src/connections.c
+cli/src/devices.c
+cli/src/network-manager.c
+cli/src/nmcli.c
+cli/src/utils.c
 libnm-util/crypto.c
 libnm-util/crypto_gnutls.c
 libnm-util/crypto_nss.c
 libnm-util/nm-utils.c
 src/nm-netlink-monitor.c
-src/NetworkManager.c
+src/main.c
 src/dhcp-manager/nm-dhcp-dhclient.c
+src/dhcp-manager/nm-dhcp-manager.c
 src/ip6-manager/nm-netlink-listener.c
+src/logging/nm-logging.c
 src/named-manager/nm-named-manager.c
 src/system-settings/nm-default-wired-connection.c
 system-settings/plugins/ifcfg-rh/reader.c
diff --git a/po/bn_IN.po b/po/bn_IN.po
index 9a71891..4ace70d 100644
--- a/po/bn_IN.po
+++ b/po/bn_IN.po
@@ -1,17 +1,17 @@
-# translation of NetworkManager.po.master.po to Bengali INDIA
+# translation of NetworkManager.master.po to Bengali INDIA
 # Bengali (India) translation of NetworkManager.
 # Copyright (C) 2009 NetworkManager's COPYRIGHT HOLDER
 # This file is distributed under the same license as the NetworkManager package.
 #
-# Runa Bhattacharjee <runab@redhat.com>, 2009.
+# Runa Bhattacharjee <runab@redhat.com>, 2009, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: NetworkManager.po.master\n"
+"Project-Id-Version: NetworkManager.master\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-06-04 03:24+0000\n"
-"PO-Revision-Date: 2009-06-05 18:45+0530\n"
+"POT-Creation-Date: 2009-09-29 03:25+0000\n"
+"PO-Revision-Date: 2010-02-19 17:25+0530\n"
 "Last-Translator: Runa Bhattacharjee <runab@redhat.com>\n"
-"Language-Team: Bengali INDIA <discuss@lists.ankur.org.in>\n"
+"Language-Team: Bengali INDIA <anubad@lists.ankur.org.in>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
@@ -103,8 +103,9 @@ msgstr "IV সংরক্ষণের জন্য পর্যাপ্ত ম
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV-র মধ্যে হেক্সাডেসিম্যাল-ভিন্ন অন্যান্য সংখ্যা উপস্থিত রয়েছে।"
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:335
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "ব্যক্তিগত-কি'র সাইফার '%s' অজানা।"
@@ -124,72 +125,111 @@ msgstr "ব্যক্তিগত-কি'র ধরন নির্ধার
 msgid "Not enough memory to store decrypted private key."
 msgstr "ডিক্রিপ্ট করা ব্যক্তিগত-কি সংরক্ষণের জন্য পর্যাপ্ত মেমরি অনুপস্থিত।"
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "ক্রিপ্টো ইঞ্জিন আরম্ভ করতে ব্যর্থ।"
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "MD5 ইঞ্জিন আরম্ভ করতে ব্যর্থ: %s / %s।"
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "IV-র অবৈধ দৈর্ঘ্য (অন্তত %zd হওয়া আবশ্যক)।"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "ডিক্রিপ্ট করা কি-বাফারের জন্য পর্যাপ্ত মেমরি অনুপস্থিত।"
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "ডিক্রিপশন সাইফারের কনটেক্সট আরম্ভ করতে ব্যর্থ: %s / %s।"
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "ডিক্রিপশনের জন্য সিমেট্রিক-কি নির্ধারণ করতে ব্যর্থ: %s / %s।"
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "ডিক্রিপশনের উদ্দেশ্যে IV নির্ধারণ করতে ব্যর্থ: %s / %s।"
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "ব্যক্তিগত-কি ডিক্রিপ্ট করতে ব্যর্থ: %s / %s।"
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:266
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "ব্যক্তিগত-কি ডিক্রিপ্ট করতে ব্যর্থ: প্যাডিংয়ের দৈর্ঘ্য বৈধ নয়।"
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:277
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "ব্যক্তিগত-কি ডিক্রিপ্ট করতে ব্যর্থ।"
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:355
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "এনক্রিপ্ট করার জন্য মেমরি বরাদ্দ করতে ব্যর্থ।"
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "এনক্রিপশন সাইফারের কনটেক্সট আরম্ভ করতে ব্যর্থ: %s / %s।"
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "এনক্রিপশনের জন্য সিমেট্রিক-কি নির্ধারণ করতে ব্যর্থ: %s / %s।"
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "এনক্রিপশনের উদ্দেশ্যে IV নির্ধারণ করতে ব্যর্থ: %s / %s।"
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "তথ্য এনক্রিপ্ট করতে ব্যর্থ: %s / %s।"
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "সার্টিফিকেটের তথ্য আরম্ভ করতে সমস্যা: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "সার্টিফিকেট ডি-কোড করতে ব্যর্থ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "PKCS#12 ডিকোডার আরম্ভ করতে ব্যর্থ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "PKCS#12 ফাইল ডিকোড করতে ব্যর্থ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12 ফাইল যাচাই করতে ব্যর্থ: %s"
 
 #: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "ক্রিপ্টো ইঞ্জিন আরম্ভ করতে ব্যর্থ: %d।"
@@ -199,105 +239,186 @@ msgstr "ক্রিপ্টো ইঞ্জিন আরম্ভ করতে
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "MD5 কনটেক্সট আরম্ভ করতে ব্যর্থ: %d।"
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "IV-র অবৈধ দৈর্ঘ্য (অন্তত %d হওয়া আবশ্যক)।"
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "ডিক্রিপশন সাইফার স্লট আরম্ভ করতে ব্যর্থ।"
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "ডিক্রিপশনের উদ্দেশ্যে সিমেট্রিক-কি নির্ধারণ করতে ব্যর্থ।"
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "ডিক্রিপশনের উদ্দেশ্যে IV নির্ধারণ করতে ব্যর্থ।"
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "ডিক্রিপশন কনটেক্সট আরম্ভ করতে ব্যর্থ।"
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "ব্যক্তিগত-কি ডিক্রিপ্ট করতে ব্যর্থ: %d।"
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "ব্যক্তিগত-কি ডিক্রিপ্ট করতে ব্যর্থ: ডিক্রিপ্ট করা তথ্য অত্যাধিক বড়।"
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "ব্যক্তিগত-কি'র ডিক্রিপশন সমাপ্ত করতে ব্যর্থ: %d।"
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:363
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "এনক্রিপশন সাইফার স্লট আরম্ভ করতে ব্যর্থ।"
+
+#: ../libnm-util/crypto_nss.c:371
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "এনক্রিপশনের উদ্দেশ্যে সিমেট্রিক-কি নির্ধারণ করতে ব্যর্থ।"
+
+#: ../libnm-util/crypto_nss.c:379
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "এনক্রিপশনের উদ্দেশ্যে IV নির্ধারণ করতে ব্যর্থ।"
+
+#: ../libnm-util/crypto_nss.c:387
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "এনক্রিপশন কনটেক্সট আরম্ভ করতে ব্যর্থ।"
+
+#: ../libnm-util/crypto_nss.c:395
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "এনক্রিপ্ট করতে ব্যর্থ: %d।"
+
+#: ../libnm-util/crypto_nss.c:403
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "এনক্রিপ্ট করার পরে অপ্রত্যাশিত পরিমাণ তথ্য উপলব্ধ হয়েছে।"
+
+#: ../libnm-util/crypto_nss.c:446
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "সার্টিফিকেট ডিকোড করতে ব্যর্থ: %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:481
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "পাসওয়ার্ডকে UCS2-তে রূপান্তর করতে ব্যর্থ: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:509
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12 ডিকোডার আরম্ভ করতে ব্যর্থ: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:518
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12 ফাইল ডিকোড করতে ব্যর্থ: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:527
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12 ফাইল যাচাই করতে ব্যর্থ: %d"
 
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:458
+#: ../libnm-util/crypto_nss.c:556
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "র‍্যান্ড তথ্য নির্মাণ করতে ব্যর্থ।"
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+#| msgid "Not enough memory to decrypt private key."
+msgid "Not enough memory to make encryption key."
+msgstr "এনক্রিপশন-কি নির্মাণের জন্য পর্যাপ্ত মেমরি অনুপস্থিত।"
+
+#: ../libnm-util/nm-utils.c:1633
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM ফাইল নির্মাণের জন্য মেমরি বরাদ্দ করতে ব্যর্থ।"
+
+#: ../libnm-util/nm-utils.c:1645
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM ফাইলের মধ্যে IV লেখার জন্য মেমরি বরাদ্দ করতে ব্যর্থ।"
+
+#: ../libnm-util/nm-utils.c:1657
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM ফাইলের মধ্যে এনক্রিপ্ট করা কি লেখার জন্য মেমরি বরাদ্দ করা যায়নি।"
+
+#: ../libnm-util/nm-utils.c:1676
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM ফাইলের তথ্যে সংরক্ষণের জন্য মেমরি বরাদ্দ করতে ব্যর্থ।"
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:569
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "netlink বার্তা প্রক্রিয়াকরণে ত্রুটি: %s"
 
-#: ../src/nm-netlink-monitor.c:255
+#: ../src/nm-netlink-monitor.c:260
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
 msgstr "লিংকের অবস্থা নিরীক্ষণের উদ্দেশ্যে netlink হ্যান্ডেল বরাদ্দ করতে ব্যর্থ: %s"
 
-#: ../src/nm-netlink-monitor.c:265
+#: ../src/nm-netlink-monitor.c:270
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
 msgstr "লিংকের অবস্থা নিরীক্ষণের উদ্দেশ্যে netlink-র সাথে সংযোগ করতে ব্যর্থ: %s"
 
-#: ../src/nm-netlink-monitor.c:273
+#: ../src/nm-netlink-monitor.c:278
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
 msgstr "লিংকের অবস্থা নিরীক্ষণের উদ্দেশ্যে netlink দলে যোগ করতে ব্যর্থ: %s"
 
-#: ../src/nm-netlink-monitor.c:281
+#: ../src/nm-netlink-monitor.c:286
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
 msgstr "লিংকের অবস্থা নিরীক্ষণের উদ্দেশ্যে netlink লিংক ক্যাশে বরাদ্দ করতে ব্যর্থ: %s"
 
-#: ../src/nm-netlink-monitor.c:422
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "তথ্যের জন্য সকেটে অপেক্ষাকালে সমস্যা"
+
+#: ../src/nm-netlink-monitor.c:558
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "লিংক ক্যাশে আপডেট করতে সমস্যা: %s"
 
-#: ../src/nm-netlink-monitor.c:488
-msgid "error occurred while waiting for data on socket"
-msgstr "তথ্যের জন্য সকেটে অপেক্ষাকালে সমস্যা"
-
-#: ../src/NetworkManager.c:296
+#: ../src/NetworkManager.c:330
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr "অবৈধ বিকল্প।  বৈধ বিকল্পগুলির তালিকা দেখার জন্য অনুগ্রহ করে --help প্রয়োগ করুন।\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:97
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
 msgid "# Created by NetworkManager\n"
 msgstr "# NetworkManager দ্বারা নির্মিত\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:103
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -306,28 +427,77 @@ msgstr ""
 "# %s থেকে মার্জ করা হয়েছে\n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:255
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "netlink হ্যান্ডেল বরাদ্দ করতে ব্যর্থ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "netlink-র সাথে সংযোগ করতে ব্যর্থ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "netlink দলে যোগ করতে ব্যর্থ: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr "উল্লেখ্য: libc resolver দ্বারা ৩-টির বেশি নেম-সার্ভার সমর্থিত না হওয়ার সম্ভাবনা রয়েছে।"
+msgstr ""
+"উল্লেখ্য: libc resolver দ্বারা ৩-টির বেশি নেম-সার্ভার সমর্থিত না হওয়ার সম্ভাবনা "
+"রয়েছে।"
 
-#: ../src/named-manager/nm-named-manager.c:257
+#: ../src/named-manager/nm-named-manager.c:317
 msgid "The nameservers listed below may not be recognized."
 msgstr "নিম্নলিখিত নেম-সার্ভারগুলি সনাক্ত না হওয়ার সম্ভাবনা রয়েছে।"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2149
-msgid "System"
-msgstr "সিস্টেম"
-
-#: ../system-settings/src/nm-default-wired-connection.c:182
+#: ../src/system-settings/nm-default-wired-connection.c:194
 #, c-format
 msgid "Auto %s"
 msgstr "স্বয়ংক্রিয় %s"
 
+#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+msgid "System"
+msgstr "সিস্টেম"
+
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "নিরাপদ ওয়াই-ফাইল নেটওয়ার্কের মাধ্যমে সংযোগের যৌথ ব্যবহার"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "উন্মুক্ত ওয়াই-ফাইল নেটওয়ার্কের মাধ্যমে সংযোগের যৌথ ব্যবহার"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "সিস্টেমের স্থায়ী হোস্ট-নেম পরিবর্তন করুন"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
 msgid "Modify system connections"
 msgstr "সিস্টেমের সংযোগ পরিবর্তন করুন"
 
-#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
 msgid "System policy prevents modification of system settings"
-msgstr "সিস্টেমে ব্যবহৃত নিয়ম-নীতির বিধিনিষেধের কারণে সিস্টেমের বৈশিষ্ট্য পরিবর্তন করা সম্ভব নয়"
+msgstr ""
+"সিস্টেমে ব্যবহৃত নিয়ম-নীতির বিধিনিষেধের কারণে সিস্টেমের বৈশিষ্ট্য পরিবর্তন করা সম্ভব "
+"নয়"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+#| msgid "System policy prevents modification of system settings"
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr ""
+"সিস্টেমে ব্যবহৃত নিয়ম-নীতির বিধিনিষেধের কারণে সিস্টেমের স্থায়ী হোস্ট-নেম পরিবর্তন করা সম্ভব "
+"নয়"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "সিস্টেমের নিয়মনীতির কারণে, নিরাপদ ওয়াই-ফাই নেটওয়ার্কের মাধ্যমে সংযোগের যৌথ ব্যবহার প্রতিরোধ করা হয়েছে"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "সিস্টেমের নিয়মনীতির কারণে, উন্মুক্ত ওয়াই-ফাই নেটওয়ার্কের মাধ্যমে সংযোগের যৌথ ব্যবহার প্রতিরোধ করা হয়েছে"
 
diff --git a/po/cs.po b/po/cs.po
index ed0ac8c..1be6b82 100644
--- a/po/cs.po
+++ b/po/cs.po
@@ -5,269 +5,1382 @@
 # Miloslav Trmac <mitr@volny.cz>, 2004 - 2006.
 # Jakub Friedl <jfriedl@suse.cz>, 2006.
 # Jiří Eischmann <jiri@eischmann.cz>, 2008.
-#
+# Marek Černocký <marek@manet.cz>, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-09-17 22:27+0200\n"
-"PO-Revision-Date: 2008-09-17 22:08+0200\n"
-"Last-Translator: Petr Kovar <pknbe@volny.cz>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-09 03:24+0000\n"
+"PO-Revision-Date: 2010-04-23 13:02+0200\n"
+"Last-Translator: Marek Černocký <marek@manet.cz>\n"
 "Language-Team: Czech <gnome-cs-list@gnome.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"
 
-#: ../src/nm-netlink-monitor.c:193 ../src/nm-netlink-monitor.c:474
+#: ../cli/src/connections.c:86
 #, c-format
-msgid "error processing netlink message: %s"
-msgstr "chyba při zpracování zprávy netlink: %s"
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Použití: nmcli con {PŘÍKAZ | help}\n"
+"  PŘÍKAZ := {list | status | up | down}\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <rozhraní>] [ap <hw_adresa>] [--nowait] [--"
+"timeout <časový_limit>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Připojení"
 
-#: ../src/nm-netlink-monitor.c:250
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Název"
+
+#: ../cli/src/connections.c:163
 #, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "nelze alokovat ovládání netlinku pro sledování stavu spojení: %s"
+msgid "System connections:\n"
+msgstr "Systémová připojení:\n"
 
-#: ../src/nm-netlink-monitor.c:260
+#: ../cli/src/connections.c:167
 #, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "nelze se připojit k netlinku pro sledování stavu spojení: %s"
+msgid "User connections:\n"
+msgstr "Uživatelská připojení:\n"
 
-#: ../src/nm-netlink-monitor.c:268
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
 #, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "nelze se připojit ke skupině netlink pro sledování stavu spojení: %s"
+msgid "Error: %s argument is missing."
+msgstr "Chyba: schází argument %s."
 
-#: ../src/nm-netlink-monitor.c:276
+#: ../cli/src/connections.c:189
 #, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgid "Error: %s - no such connection."
+msgstr "Chyba: %s - takové připojení neexistuje."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Připojení v rámci systému"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Uživatelská připojení"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Neznámý parametr: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Chyba: nezadán žádný platný parametr."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ano"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "ne"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Aktivní připojení"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Výchozí"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Služba"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Zařízení"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "žádné aktivní připojení nebo zařízení „%s“"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "žádné aktivní připojení nebo zařízení"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktivuje se"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktivováno"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "neznámo"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN se připojuje (příprava)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN se připojuje (požaduje ověření)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN se připojuje"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN se připojuje (získává se nastavení IP)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN připojena"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN se nezdařilo připojit"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN odpojena"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "neznámý důvod"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "žádný"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "uživatel byl odpojen"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "základní síťové připojení bylo přerušeno"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "služba VPN neočekávaně zastavena"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "služba VPN vrátila neplatné nastavení"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "pokusu o připojení vypršel časový limit"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "služba VPN se nespustila v časovém limitu"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "službu VPN se nezdařilo spustit"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "žádná platná utajení VPN"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "neplatná utajení VPN"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "připojení odstraněno"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "stav: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Připojení aktivováno\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Chyba: Selhala aktivace připojení."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "stav: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Chyba: Selhala aktivace připojení: %s"
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Chyba: Časový limit %d sekund vypršel."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Chyba: Selhala aktivace připojení: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Chyba: Získání aktivního připojení pro „%s“ selhalo."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Stav aktivního připojení: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Cesta aktivního připojení: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Chyba: Neznámé připojení: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Chyba: hodnota časového limitu „%s“ není platná."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Chyba: nebylo určeno id nebo uuid."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Chyba: Nenalezeno vhodné zařízení: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Chyba: Nenalezeno vhodné zařízení."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Varování: Připojení není aktivní\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Chyba: příkaz „%s“ není pro „con“ platný."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Chyba: nelze se připojit ke sběrnici D-Bus."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Chyba: Nelze získat systémová nastavení."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Chyba: Nelze získat uživatelská nastavení."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Chyba: Nelze získat připojení: služba správy nastavení neběží."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"nelze alokovat vyrovnávací paměť netlinku pro sledování stavu spojení: %s"
+"Použití: nmcli dev {PŘÍKAZ | help}\n"
+"\n"
+"  PŘÍKAZ := {status | list | disconnect | wifi}\n"
+"\n"
+"  status\n"
+"  list [iface <rozhraní>]\n"
+"  disconnect iface <rozhraní> [--nowait] [--timeout <časový_limit>]\n"
+"  wifi [list [iface <rozhraní>] | apinfo iface <rozhraní> hwaddr "
+"<hw_adresa>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "není pod správou"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "nedostupné"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "odpojeno"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "připojuje se (příprava)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "připojuje se (nastavování)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "připojuje se (požadováno ověření)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "připojuje se (získává se nastavení IP)"
 
-#: ../src/nm-netlink-monitor.c:439
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "připojeno"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "připojení se nezdařilo"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Neznámý"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(nic)"
+
+#: ../cli/src/devices.c:209
 #, c-format
-msgid "error updating link cache: %s"
-msgstr "chyba při aktualizaci link cache: %s"
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: chyba převodu adresy IP4 0x%X"
 
-#: ../src/nm-netlink-monitor.c:497
+#: ../cli/src/devices.c:238
 #, c-format
-msgid "error occurred while waiting for data on socket"
-msgstr "při čekání na data ze socketu došlo k chybě"
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Frekv %d MHz, Rychlost %d Mb/s, Síla sig %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", Šifrováno: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Podnikové"
 
-#: ../src/NetworkManager.c:250
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Zařízení"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Ovladač"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(neznámo)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Stav"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW adresa"
+
+#: ../cli/src/devices.c:319
 #, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Neplatná volba. Platné volby uvidíte při použití --help.\n"
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Schopnosti:\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:89
-msgid "# Created by NetworkManager\n"
-msgstr "# Vytvořeno NetworkManagerem\n"
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Detekce nosného signálu"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:95
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Rychlost"
+
+#: ../cli/src/devices.c:348
 #, c-format
 msgid ""
-"# Merged from %s\n"
 "\n"
+"  Wireless Properties\n"
 msgstr ""
-"# Sloučeno z %s\n"
 "\n"
+"  Vlastnosti bezdrátové části\n"
 
-#: ../src/named-manager/nm-named-manager.c:256
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr "Poznámka: libc resolver nemůže podporovat více než 3 nameservery."
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "Šifrování WEP"
 
-#: ../src/named-manager/nm-named-manager.c:258
-msgid "The nameservers listed below may not be recognized."
-msgstr "Nameservery uvedené v seznamu dole nelze rozpoznat."
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "Šifrování WPA"
 
-#: ../system-settings/src/main.c:366
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "Šifrování WPA2"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "Šifra TKIP"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "Šifra CCMP"
+
+#: ../cli/src/devices.c:368
 #, c-format
-msgid "Auto %s"
-msgstr "Auto %s"
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Bezdrátový přístupový bod %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = aktuální přístupový bod)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Vlastnosti drátové části\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Nosný signál"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "zapnut"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "vypnut"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  Nastavení IPv4:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adresa"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Předčíslí"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Brána"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Stav zařízení"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Chyba: schází argument „%s“."
 
-#: ../libnm-util/crypto.c:125
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Chyba: Zařízení „%s“ nenalezeno."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Úspěch: Zařízení „%s“ úspěšně odpojeno."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Chyba: Odpojení zařízení „%s“ (%s) selhalo: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Stav zařízení: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Chyba: nebylo určeno rozhraní."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Seznam prohledání WiFi"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Chyba: Zařízení „%s“ není zařízení WiFi."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Zařízení:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Chyba: musí být určena hardwarová adresa."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Chyba: Přístupový bod s hardwarovou adresou „%s“ nenalezen."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parametry přístupového bodu"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Kmitočet:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Režim:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastruktura"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Max. přenosová rychlost:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Síla signálu:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Příznaky:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "soukromé"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "Příznaky WPA:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "Příznaky RSN:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Chyba: příkaz „%s“ není pro „dev wifi“ platný."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Chyba: příkaz „%s“ není pro „dev“ platný."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Použití: nmcli nm {PŘÍKAZ | help}\n"
+"\n"
+"  PŘÍKAZ := {status | sleep | wakeup | wifi | wwan}\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "uspán"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "připojuje se"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "povoleno"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "zakázáno"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Stav správce sítě NetworkManager"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "Běh NM:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "běží"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "neběží"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Stav NM:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "Bezdrátový hardware NM:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "Bezdrátové sítě NM:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "Hardware WWAN NM"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "Sítě WWAN NM:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Chyba: neplatný parametr pro „wifi“: „%s“"
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Chyba: neplatný parametr pro „wwan“: „%s“"
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Chyba: příkaz „%s“ není pro „nm“ platný."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Použití: %s [PŘEPÍNAČE] OBJEKT {PŘÍKAZ | help}\n"
+"\n"
+"PŘEPÍNAČE\n"
+"  -t[erse]    stručný výpis\n"
+"  -p[retty]   hezký výpis\n"
+"  -v[ersion]  zobrazit verzi programu\n"
+"  -h[elp]     zobrazit tuto nápovědu\n"
+"\n"
+"OBJEKT\n"
+"  nm          stav NetworkManageru\n"
+"  con         připojení v NetworkManageru\n"
+"  dev         zařízení spravovaná NetworkManagerem\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Objekt „%s“ je neznámý, zkuste „nmcli help“."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nástroj nmcli, verze %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Přepínač „%s“ je neznámý, zkuste „nmcli -help“."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Zachycen signál %d, vypíná se…"
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Chyba: Nelze se připojit ke správci sítě NetworkManager."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Úspěch"
+
+#: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
-msgstr "Soubor klíče PEM neměl koncovou značku '%s'."
+msgstr "Soubor klíče PEM neměl koncovou značku „%s“."
 
-#: ../libnm-util/crypto.c:135
+#: ../libnm-util/crypto.c:130
 #, c-format
 msgid "Doesn't look like a PEM private key file."
 msgstr "Nevypadá jako soubor soukromého klíče PEM."
 
-#: ../libnm-util/crypto.c:143
+#: ../libnm-util/crypto.c:138
 #, c-format
 msgid "Not enough memory to store PEM file data."
-msgstr "Není dostatek paměti na uložení dat PEM souboru."
+msgstr "Není dostatek paměti pro uložení dat souboru PEM."
 
-#: ../libnm-util/crypto.c:159
+#: ../libnm-util/crypto.c:154
 #, c-format
 msgid "Malformed PEM file: Proc-Type was not first tag."
-msgstr "Nesprávný PEM soubor: Proc-Type nebylo první značkou."
+msgstr "Vadný soubor PEM: značka Proc-Type nebyla první značkou."
 
-#: ../libnm-util/crypto.c:167
+#: ../libnm-util/crypto.c:162
 #, c-format
 msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
-msgstr "Nesprávný PEM soubor: neznámá značka Proc-Type '%s'."
+msgstr "Vadný soubor PEM: neznámá značka Proc-Type „%s“."
 
-#: ../libnm-util/crypto.c:177
+#: ../libnm-util/crypto.c:172
 #, c-format
 msgid "Malformed PEM file: DEK-Info was not the second tag."
-msgstr "Nesprávný PEM soubor: DEK-Info nebylo druhou značkou."
+msgstr "Vadný soubor PEM: značka DEK-Info nebyla druhou značkou."
 
-#: ../libnm-util/crypto.c:188
+#: ../libnm-util/crypto.c:183
 #, c-format
 msgid "Malformed PEM file: no IV found in DEK-Info tag."
-msgstr "Nesprávný PEM soubor: nebylo nalezeno IV ve značce DEK-Info."
+msgstr "Vadný soubor PEM: nebyl nalezen IV ve značce DEK-Info."
 
-#: ../libnm-util/crypto.c:195
+#: ../libnm-util/crypto.c:190
 #, c-format
 msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
-msgstr "Nesprávný PEM soubor: neplatný formát IV ve značce DEK-Info."
+msgstr "Vadný soubor PEM: neplatný formát IV ve značce DEK-Info."
 
-#: ../libnm-util/crypto.c:208
+#: ../libnm-util/crypto.c:203
 #, c-format
 msgid "Malformed PEM file: unknown private key cipher '%s'."
-msgstr "Nesprávný PEM soubor: neznámá šifra soukromého klíče '%s'."
+msgstr "Vadný soubor PEM: neznámá šifra soukromého klíče „%s“."
 
-#: ../libnm-util/crypto.c:227
+#: ../libnm-util/crypto.c:222
 #, c-format
 msgid "Could not decode private key."
 msgstr "Nelze dekódovat soukromý klíč."
 
-#: ../libnm-util/crypto.c:271
+#: ../libnm-util/crypto.c:267
 #, c-format
 msgid "PEM certificate '%s' had no end tag '%s'."
-msgstr "PEM certifikát '%s' nemá koncovou značku '%s'."
+msgstr "Certifikát PEM „%s“ nemá koncovou značku „%s“."
 
-#: ../libnm-util/crypto.c:281
+#: ../libnm-util/crypto.c:277
 #, c-format
 msgid "Failed to decode certificate."
 msgstr "Selhalo dekódování certifikátu."
 
-#: ../libnm-util/crypto.c:290 ../libnm-util/crypto.c:298
+#: ../libnm-util/crypto.c:286
 #, c-format
 msgid "Not enough memory to store certificate data."
-msgstr "Není dostatek paměti na uložení dat certifikátu."
+msgstr "Nedostatek paměti pro uložení dat certifikátu."
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Not enough memory to store file data."
+msgstr "Nedostatek paměti na uložení dat souboru."
 
-#: ../libnm-util/crypto.c:328
+#: ../libnm-util/crypto.c:324
 #, c-format
 msgid "IV must be an even number of bytes in length."
-msgstr "IV musí být sudé číslo bajtů na délku."
+msgstr "IV musí mít na délku sudý počet bajtů."
 
-#: ../libnm-util/crypto.c:337
+#: ../libnm-util/crypto.c:333
 #, c-format
 msgid "Not enough memory to store the IV."
-msgstr "Není dostatek paměti pro uložení IV."
+msgstr "Nedostatek paměti pro uložení IV."
 
-#: ../libnm-util/crypto.c:348
+#: ../libnm-util/crypto.c:344
 #, c-format
 msgid "IV contains non-hexadecimal digits."
-msgstr "IV obsahuje nešestnáctkové číslice."
+msgstr "IV obsahuje jiné než šestnáctkové číslice."
 
-#: ../libnm-util/crypto.c:386 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:157
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
-msgstr "Šifra soukromého klíče '%s' je neznámá."
+msgstr "Šifra soukromého klíče „%s“ je neznámá."
 
-#: ../libnm-util/crypto.c:395
+#: ../libnm-util/crypto.c:391
 #, c-format
-msgid "Not enough memory to create private key decryption key."
-msgstr ""
-"Není dostatek paměti pro vytvoření dešifrovacího klíče k soukromému klíči."
+#| msgid "Not enough memory to store decrypted private key."
+msgid "Not enough memory to decrypt private key."
+msgstr "Nedostatek paměti pro dešifrování soukromého klíče."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Unable to determine private key type."
+msgstr "Nelze určit typ soukromého klíče."
 
-#: ../libnm-util/crypto.c:513
+#: ../libnm-util/crypto.c:530
 #, c-format
 msgid "Not enough memory to store decrypted private key."
-msgstr "Není dostatek paměti pro uložení dešifrovaného soukromého klíče."
+msgstr "Nedostatek paměti pro uložení dešifrovaného soukromého klíče."
 
-#: ../libnm-util/crypto_gnutls.c:45
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
-msgstr "Nelze inicializovat šifrovací engine."
+msgstr "Selhala inicializace šifrovacího programu."
 
-#: ../libnm-util/crypto_gnutls.c:89
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
-msgstr "Nelze inicializovat MD5 engine: %s / %s."
+msgstr "Selhala inicializace programu pro MD5: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:166
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Neplatná délka IV (musí být nejméně %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
-msgstr "Není dostatek paměti pro vyrovnávací paměť dešifrovaného klíče."
+msgstr "Nedostatek paměti pro vyrovnávací paměť dešifrovaného klíče."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
-msgstr "Nelze inicializovat kontext dekódovací šifry: %s / %s."
+msgstr "Selhala inicializace kontextu dešifrovací šifry: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
-msgstr "Nelze nastavit symetrický klíč pro dekódování: %s / %s."
+msgstr "Selhalo nastavení symetrického klíče pro dešifrování: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
-msgstr "Nelze nastavit IV pro dekódování: %s / %s."
+msgstr "Selhalo nastavení IV pro dekódování: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
-msgstr "Nelze dekódovat soukromý klíč: %s / %s."
+msgstr "Selhalo dekódování soukromého klíče: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Selhalo dešifrování soukromého klíče: neočekávané zarovnání délky."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key."
+msgstr "Selhalo dešifrování soukromého klíče."
 
-#: ../libnm-util/crypto_gnutls.c:225
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Nelze alokovat paměť pro šifrování."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Selhala inicializace kontextu šifrovací šifry: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Selhalo nastavení symetrického klíče pro šifrování: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Selhalo nastavení IV pro šifrování: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Selhalo šifrování dat: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Chyba při inicializaci dat certifikátu: %s"
 
-#: ../libnm-util/crypto_gnutls.c:237
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "Nelze dekódovat certifikát: %s"
 
-#: ../libnm-util/crypto_nss.c:52
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "Nelze inicializovat dekodér PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "Nelze dekódovat soubor PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "Nelze ověřit soubor PKCS#12: %s"
+
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
-msgstr "Nelze inicializovat šifrovací engine: %d."
+msgstr "Selhala inicializace šifrovacího programu: %d."
 
-#: ../libnm-util/crypto_nss.c:98
+#: ../libnm-util/crypto_nss.c:111
 #, c-format
 msgid "Failed to initialize the MD5 context: %d."
-msgstr "Nelze inicializovat MD5 kontext: %d."
+msgstr "Selhala inicializace kontextu MD5: %d."
 
-#: ../libnm-util/crypto_nss.c:174
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Neplatná délka IV (musí být nejméně %d)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
-msgstr "Nelze inicializovat slot dekódovací šifry."
+msgstr "Selhala inicializace slotu dešifrovací šifry."
 
-#: ../libnm-util/crypto_nss.c:184
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
-msgstr "Nelze nastavit symetrický klíč pro dekódování."
+msgstr "Selhalo nastavení symetrického klíče pro dešifrování."
 
-#: ../libnm-util/crypto_nss.c:194
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
-msgstr "Nelze nastavit IV pro dekódování."
+msgstr "Selhalo nastavení IV pro dešifrování."
 
-#: ../libnm-util/crypto_nss.c:202
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
-msgstr "Nelze inicializovat kontext dekódování."
+msgstr "Selhala inicializace dešifrovacího kontextu."
 
-#: ../libnm-util/crypto_nss.c:215
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
-msgstr "Nelze dekódovat soukromý klíč: %d."
+msgstr "Selhalo dešifrování soukromého klíče: %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr ""
+"Selhalo dešifrování soukromého klíče: dešifrovaná data jsou příliš velká."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
-msgstr "Nelze dokončit dekódování soukromého klíče: %d."
+msgstr "Selhalo dokončení dešifrování soukromého klíče: %d."
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Selhala inicializace slotu šifrovací šifry."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "Selhalo nastavení symetrického klíče pro šifrování."
 
-#: ../libnm-util/crypto_nss.c:271
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "Selhalo nastavení IV pro šifrování."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "Selhala inicializace kontextu šifrování."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "Selhalo šifrování: %d"
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Neočekávané množství dat po zašifrování."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "Nelze dekódovat certifikát: %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "Nelze převést heslo na UCS2: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "Nelze inicializovat dekodér PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "Nelze dekódovat soubor PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "Nelze ověřit soubor PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "Nelze vygenerovat náhodná data."
+
+#: ../libnm-util/nm-utils.c:1818
+#, c-format
+#| msgid "Not enough memory to create private key decryption key."
+msgid "Not enough memory to make encryption key."
+msgstr "Nedostatek paměti pro vytvoření šifrovacího klíče."
+
+#: ../libnm-util/nm-utils.c:1928
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Nelze alokovat paměť pro vytvoření souboru PEM."
+
+#: ../libnm-util/nm-utils.c:1940
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Nelze alokovat paměť pro zápis IV do souboru PEM."
+
+#: ../libnm-util/nm-utils.c:1952
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Nelze alokovat paměť pro zápis šifrovaného klíče do souboru PEM."
+
+#: ../libnm-util/nm-utils.c:1971
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "Nelze alokovat paměť pro data souboru PEM."
+
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "chyba při zpracování zprávy netlink: %s"
+
+#: ../src/nm-netlink-monitor.c:259
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "nelze alokovat ovládání netlinku pro sledování stavu spojení: %s"
+
+#: ../src/nm-netlink-monitor.c:269
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "nelze se připojit k netlinku pro sledování stavu spojení: %s"
+
+#: ../src/nm-netlink-monitor.c:277
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "nelze se připojit ke skupině netlink pro sledování stavu spojení: %s"
+
+#: ../src/nm-netlink-monitor.c:285
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "nelze alokovat mezipaměť netlinku pro sledování stavu spojení: %s"
+
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
+msgid "error occurred while waiting for data on socket"
+msgstr "vyskytla se chyba při čekání na data ze soketu"
+
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "chyba při aktualizaci mezipaměti spojení: %s"
+
+#: ../src/main.c:498
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr ""
+"Neplatný přepínač. Platné přepínače si můžete zobrazit pomocí --help.\n"
+
+#: ../src/main.c:558
+#, c-format
+#| msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s. Pomocí --help si prosím zobrazte seznam platných přepínačů.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
+msgid "# Created by NetworkManager\n"
+msgstr "# Vytvořeno NetworkManagerem\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# Sloučeno z %s\n"
+"\n"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "nebyl nalezen žádný použitelný klient DHCP."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "„dhclient“ byl nalezen."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "„dhcpcd“ byl nalezen."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "nepodporovaný klient DHCP „%s“"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "nelze alokovat ovládání netlinku: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:209
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "nelze se připojit k netlinku: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:306
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "nelze se připojit ke skupině netlink: %s"
+
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "Neznámá úroveň evidence „%s“"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "Neznámá doména evidence „%s“"
+
+#: ../src/named-manager/nm-named-manager.c:314
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ""
+"Poznámka: překladač adres z libc nemůže podporovat více než 3 jmenné servery."
+
+#: ../src/named-manager/nm-named-manager.c:316
+msgid "The nameservers listed below may not be recognized."
+msgstr "Jmenné servery uvedené v následujícím seznamu nelze rozpoznat."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "%s (automaticky)"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "Systém"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Sdílení připojení přes chráněnou síť WiFi"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Sdílení připojení přes otevřenou síť WiFi"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Měnit trvalý systémový název počítače"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Měnit systémová připojení"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "Systémová politika zabránila změně systémového nastavení."
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "Systémová politika zabránila změně trvalého systémového názvu počítače"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "Systémová politika zabránila sdílení připojení přes chráněnou síť WiFi"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "Systémová politika zabránila sdílení připojení přes otevřenou síť WiFi"
diff --git a/po/de.po b/po/de.po
index 0570938..ea2fe02 100644
--- a/po/de.po
+++ b/po/de.po
@@ -7,20 +7,867 @@
 # Thomas Gier <info@thomasgier.de>, 2007.
 # Andre Klapper <ak-47@gmx.net>, 2007.
 # Hauke Mehrtens <hauke@hauke-m.de>, 2008.
-# Christian Kirbach <Christian.Kirbach@googlemail.com>, 2009.
-#
+# Christian Kirbach <Christian.Kirbach@googlemail.com>, 2009, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager HEAD\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2009-10-15 23:02+0200\n"
-"PO-Revision-Date: 2009-10-14 11:27+0200\n"
+"POT-Creation-Date: 2010-03-12 08:15+0100\n"
+"PO-Revision-Date: 2010-03-12 08:17+0100\n"
 "Last-Translator: Christian Kirbach <Christian.Kirbach@googlemail.com>\n"
-"Language-Team: German <gnome-de@gnome.org>\n"
+"Language-Team: Deutsch <gnome-de@gnome.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1)\n"
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Aufruf: nmcli con { BEFEHL | help }\n"
+"  BEFEHL := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Verbindungen"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Name"
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "System-Verbindungen:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "Benutzer-Verbindungen:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Fehler: %s Argument fehlt."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Fehler: %s - keine solche Verbindung."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Systemweite Verbindungen"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Benutzer-Verbindungen"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Unbekannter Parameter: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Fehler: Kein gültiger Parameter angegeben."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ja"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "nein"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Aktive Verbindungen "
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Vorgabe"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Dienst"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Gerät"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "keine aktive Verbindung auf Gerät »%s«"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "keine aktive Verbindung auf Gerät"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "wird aktiviert"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktiviert"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "unbekannt"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN wird verbunden (vorbereiten)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN wird verbunden (Legitimierung erforderlich)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN wird verbunden"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN wird verbunden (IP-Konfiguration wird ermittelt)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN verbunden"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN-Verbindung fehlgeschlagen"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN getrennt"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "unbekannter Grund"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "kein"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "der Benutzer wurde getrennt"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "die Basisverbindung wurde unterbrochen"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "der VPN-Dienst brach unerwartet ab"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "der VPN-Dienst gab eine ungültige Konfiguration zurück"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "Der Verbindungsversuch ist zeitlich abgelaufen"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "der VPN-Dienst ist nicht rechtzeitig gestartet"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "der VPN-Dienst konnte nicht starten"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "keine gültigen VPN-Geheimnisse"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "ungültige VPN-Geheimnisse"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "Die Verbindung wurde entfernt"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "Zustand: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Verbindung aktiviert\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Fehler: Aktivierung der Verbindung fehlgeschlagen."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "Zustand: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Fehler: Aktivierung der Verbindung fehlgeschlagen: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Fehler: Zeitbeschränkung von %d Sekunden abgelaufen."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Fehler: Aktivierung der Verbindung fehlgeschlagen: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Fehler: Erlangen der Verbindung für »%s« ist fehlgeschlagen."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Zustand der aktiven Verbindung: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Pfad der aktiven Verbindung: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Fehler: Unbekannte Verbindung: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Fehler: Der Wert »%s« für den Zeitablauf ist nicht gültig."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Fehler: id oder uuid muss angegeben werden."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Fehler: Kein passendes Gerät gefunden: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Fehler: Kein passendes Gerät gefunden."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Warnung: Verbindung ist derzeit nicht aktiv\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Fehler: Der Befehl »%s« für »con« ist nicht gültig."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Fehler: Es konnte nicht mit D-Bus verbunden werden."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Fehler: Systemeinstellungen konnten nicht ermittelt werden"
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Fehler: Benutzereinstellungen konnten nicht ermittelt werden."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr ""
+"Fehler: Verbindungen können nicht erlangt werden: Die Einstellungsdienste "
+"werden nicht ausgeführt."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Aufruf: nmcli dev { BEFEHL | help }\n"
+"\n"
+"  BEFEHL := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "nicht verwaltet"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "nicht verfügbar"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "getrennt"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "wird verbunden (vorbereiten)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "wird verbunden (konfigurieren)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "wird verbunden (Legitimierung erforderlich)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "wird verbunden (IP-Konfiguration wird ermittelt)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "verbunden"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "Verbindung fehlgeschlagen"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Unbekannt"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(keine)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: Fehler bei Umwandlung der IPv4-Addresse 0x%X"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Frequenz %d MHz, Durchsatz %d Mb/s, Stärke %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", Verschlüsselt:"
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+# Das ergibt z.B. WPA-Enterprise, klingt komisch mit »Unternehmen«
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr "Enterprise"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Gerät"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Treiber"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(unbekannt)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Zustand"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Hardware-Adresse"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"Fähigkeiten:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Trägersignal erkannt"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Geschwindigkeit"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  Eigenschaften der drahtlosen Verbindung\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP-Verschlüsselung"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA-Verschlüsselung"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2-Verschlüsselung"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP-Chiffre"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP-Chiffre"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Zugangspunkte für Drahtlosnetzwerk %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = aktueller Zugangspunkt)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Eigenschaften der kabelgebundenen Verbindung\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Trägersignal"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "an"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "aus"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4-Einstellungen:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adresse"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Präfix"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Gateway"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Status von Geräten"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Fehler: Argument »%s« fehlt."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Fehler: Gerät »%s« wurde nicht gefunden"
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Erfolg: Gerät »%s« wurde erfolgreich getrennt."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Fehler: Trennung des Gerätes »%s« (%s) ist fehlgeschlagen: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Gerätezustand:  %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Fehler: Schnittstelle muss angegeben werden."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Suchliste für WiFi"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Fehler: Gerät »%s« ist kein WiFi-Gerät."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Gerät:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Fehler: Hardware-Adresse muss angegeben werden."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr ""
+"Fehler: Der Zugangspunkt mit Hardware-Adresse »%s« wurde nicht gefunden."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parameter des Zugangspunktes"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Frequenz:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Modus:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastuktur"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Maximale Bitrate:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Stärke:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Flags:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "Datenschutzmodus"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA-Flags:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN-Flags:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Fehler: Der Befehl »%s« für »dev wifi« ist nicht gültig."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Fehler: Der Befehl »%s« für »dev« ist nicht gültig."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Aufruf: nmcli nm { BEFEHL | help }\n"
+"\n"
+"  BEFEHL := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "schlafend"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "wird verbunden"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "aktiviert"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "deaktiviert"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Status von NetworkManager"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM läuft:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "wird ausgeführt"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "wird nicht ausgeführt"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Status von NM:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM Drahtlos-Hardware:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM drahtlos:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN-Hardware:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Fehler: Ungültiger »wifi«-Parameter: »%s«."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Fehler: Ungültiger »wwan«-Parameter: »%s«."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Fehler: Der Befehl »%s« für »nm« ist nicht gültig."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Aufruf: %s [OPTIONEN] OBJEKT { BEFEHL | help }\n"
+"\n"
+"OPTIONEN\n"
+"  -t[erse]    knappe Ausgabe\n"
+"  -p[retty]   hübsche Ausgabe\n"
+"  -v[ersion]  Programm-Version anzeigen\n"
+"  -h[elp]     dies Hilfe ausgeben\n"
+"\n"
+"OBJEKT\n"
+"  nm          Status von NetworkManager\n"
+"  con         Verbindungen von NetworkManager\n"
+"  dev         von NetworkManager verwaltete Verbindungen\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Objekt »%s« ist unbekannt, versuchen Sie »nmcli help«."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli, Version %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Option »%s« ist unbekannt, versuchen Sie »nmcli -help«."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Signal %d wurde empfangen, wird beendet …"
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Fehler: Verbindung konnte nicht mit NetworkManager hergestellt werden."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Erfolg"
 
 #: ../libnm-util/crypto.c:120
 #, c-format
@@ -237,7 +1084,7 @@ msgstr "PKCS#12 konnte nicht decodiert werden: %s"
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12-Datei konnte nicht überprüft werden: %s"
 
-#: ../libnm-util/crypto_nss.c:57
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Fehler beim Initialisieren der Verschlüsselung: %d."
@@ -351,38 +1198,38 @@ msgstr "PKCS#12-Datei konnte nicht überprüft werden: %d"
 msgid "Could not generate random data."
 msgstr "Zufällige Daten konnten nicht erstellt werden."
 
-#: ../libnm-util/nm-utils.c:1522
+#: ../libnm-util/nm-utils.c:1545
 #, c-format
 msgid "Not enough memory to make encryption key."
 msgstr "Nicht genug Speicher zum Erstellen eines Schlüssels."
 
-#: ../libnm-util/nm-utils.c:1633
+#: ../libnm-util/nm-utils.c:1655
 msgid "Could not allocate memory for PEM file creation."
 msgstr ""
 "Es konnte kein Speicher zum Erstellen der PEM-Datei angefordert werden."
 
-#: ../libnm-util/nm-utils.c:1645
+#: ../libnm-util/nm-utils.c:1667
 #, c-format
 msgid "Could not allocate memory for writing IV to PEM file."
 msgstr ""
 "Es konnte kein Speicher zum Schreiben des IV in die PEM-Datei angefordert "
 "werden."
 
-#: ../libnm-util/nm-utils.c:1657
+#: ../libnm-util/nm-utils.c:1679
 #, c-format
 msgid "Could not allocate memory for writing encrypted key to PEM file."
 msgstr ""
 "Es konnte kein Speicher zum Schreiben des IV in die PEM-Datei angefordert "
 "werden."
 
-#: ../libnm-util/nm-utils.c:1676
+#: ../libnm-util/nm-utils.c:1698
 #, c-format
 msgid "Could not allocate memory for PEM file data."
 msgstr ""
 "Es konnte kein Speicher für die Daten der PEM-Datei angefordert werden."
 
 #: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
-#: ../src/nm-netlink-monitor.c:569
+#: ../src/nm-netlink-monitor.c:582
 #: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
@@ -421,23 +1268,23 @@ msgstr ""
 msgid "error occurred while waiting for data on socket"
 msgstr "Während des Wartens auf Daten am Socket ist ein Fehler aufgetreten"
 
-#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "Fehler beim Aktualisieren des Verbindungs-Cache: %s"
 
-#: ../src/NetworkManager.c:330
+#: ../src/main.c:494
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr ""
-"Ungültige Option.  Verwenden Sie Bitte »--help«, um eine Liste der gültigen "
+"Ungültige Option.  Verwenden Sie bitte »--help«, um eine Liste der gültigen "
 "Optionen zu erhalten.\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
 msgid "# Created by NetworkManager\n"
 msgstr "# Erstellt von NetworkManager\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -478,7 +1325,7 @@ msgstr ""
 msgid "Auto %s"
 msgstr "Auto %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
 msgid "System"
 msgstr "System"
 
diff --git a/po/es.po b/po/es.po
index 6120118..6919c06 100644
--- a/po/es.po
+++ b/po/es.po
@@ -1,102 +1,872 @@
-# translation of NetworkManager.HEAD.po to Español
-# translation of NetworkManager.HEAD.po to
-# Traducción de NetworkManager al español.
+# translation of NetworkManager.HEAD.po to Spanish
 # Copyright (C) Spanish translation for NetworkManager
 # This file is distributed under the same license as the NetworkManager package.
 #
 # Antonio Ognio <antonio@linux.org.pe>, 2004.
-# Francisco Javier F. Serrador <serrador@cvs.gnome.org>, 2004, 2005, 2006.
+# Francisco Javier F. Serrador <serrador@cvs.gnome.org>, 2004, 2005, 2006, 2010.
 # Lucas Vieites Fariña <lucas@asixinformatica.com>, 2005, 2006.
-# Jorge González <jorgegonz@svn.gnome.org>, 2007, 2008.
+# Jorge González <jorgegonz@svn.gnome.org>, 2007, 2008, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager.HEAD\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
-"product=NetworkManager&amp;component=general\n"
-"POT-Creation-Date: 2008-11-13 21:19+0000\n"
-"PO-Revision-Date: 2008-11-14 20:28+0100\n"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-09 03:24+0000\n"
+"PO-Revision-Date: 2010-04-10 19:52+0200\n"
 "Last-Translator: Jorge González <jorgegonz@svn.gnome.org>\n"
 "Language-Team: Español <gnome-es-list@gnome.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms:  nplurals=2; plural=(n != 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
-#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:476
+#: ../cli/src/connections.c:86
 #, c-format
-msgid "error processing netlink message: %s"
-msgstr "error al procesar el mensaje de netlink: %s"
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Uso: nmcli con { COMANDO | help }\n"
+"  COMANDO := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <interfaz>] [ap <dirección-hardware>] [--"
+"nowait] [--timeout <tiempo-de-expiración>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Conexiones"
 
-#: ../src/nm-netlink-monitor.c:252
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Tipo"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Nombre"
+
+#: ../cli/src/connections.c:163
 #, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "System connections:\n"
+msgstr "Conexiones del sistema:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "Conexiones del usuario:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Error: falta el argumento %s."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Error: %s; no existe tal conexión."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Conexiones amplias del sistema"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Conexiones del usuario"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Parámetro desconocido: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Error: no se especificó un parámetro válido."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "sí"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "no"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Activar conexiones"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Predeterminada"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Servicio"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Dispositivos"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "no existe una conexión activa en el dispositivo «%s»"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "no existe una conexión o dispositivo activo"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "activando"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "activada"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "desconocido"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "Conectando con la VPN (preparación)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "Conectando con la VPN (necesita autorización)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "Conectando con la VPN"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "Conectando con la VPN (obteniendo configuración IP)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN conectada"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "Falló la conexión VPN"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN desconectada"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "razón desconocida"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "ninguna"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "se desconectó al usuario"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "se interrumpió la conexión base de red"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "el servicio VPN finalizó inesperadamente"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "el servicio VPN devolvió una configuración no válida"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "expiró el intento de conexión"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "el servicio VPN no se inició a tiempo"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "el servicio VPN falló al iniciar"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "secretos VPN no válidos"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "secretos VPN inválidos"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "se rechazó la conexión"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "estado: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Conexión activada\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Error: falló la activación de la conexión."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "estado: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Error: falló la activación de la conexión: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Error: Expiró el tiempo de conexión de %d segs."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Error: falló la activación de la conexión: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Error: falló la obtención de una conexión activa para «%s»."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Estado de la conexión activa: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Ruta de la conexión activa: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Error: conexión desconocida: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Error: el valor «%s» no es válido para el tiempo de expiración."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Error: se debe especificar el «id» o «uuid»."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Error: no se encontró un dispositivo apropiado: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Error: no se encontró un dispositivo apropiado."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Aviso: la conexión no está activa\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Error: el comando «con» «%s» no es válido."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Error: no se pudo conectar con D-Bus."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Error: no se pudo obtener la configuración del sistema."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Error: no se pudo obtener la configuración del usuario."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
 msgstr ""
-"no se puede asignar el manejador netlink para monitorizar el estado del "
-"enlace: %s"
+"Error: no se pueden obtener las conexiones: los servicios de configuración "
+"no se están ejecutando."
 
-#: ../src/nm-netlink-monitor.c:262
+#: ../cli/src/devices.c:73
 #, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"no se puede conectar con netlink para monitorizar el estado del enlace: %s"
+"Uso: nmcli dev { COMANDO | help }\n"
+"\n"
+"  COMANDO := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <interfaz>]\n"
+"  disconnect iface <interfaz> [--nowait] [--timeout <tiempo-de-expiración>]\n"
+"  wifi [list [iface <interfaz>] | apinfo iface <interfaz> hwaddr <dirección-"
+"hardware>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "sin gestionar"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "no disponible"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "desconectado"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "conectando (preparación)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "conectando (configuración)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "conectando (necesita autorización)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "conectando (obteniendo configuración IP)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "conectado"
 
-#: ../src/nm-netlink-monitor.c:270
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "falló la conexión"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Desconocido"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(nada)"
+
+#: ../cli/src/devices.c:209
 #, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: error al convertir la dirección IP4 en 0x%X"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, frecuencia %d MHz, tasa %d Mb/s, intensidad %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", cifrado: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Enterprise"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Dispositivo"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Controlador"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(desconocido)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Estado"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Dirección hardware"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
 msgstr ""
-"no pudo unirse al grupo netlink para monitorizar el estado del enlace: %s"
+"\n"
+"  Capacidades:\n"
 
-#: ../src/nm-netlink-monitor.c:278
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Detector de portadora"
+
+#: ../cli/src/devices.c:336
 #, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Velocidad"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
 msgstr ""
-"no se puede asignar el enlace a la caché de netlink para monitorizar el "
-"estado del enlace: %s"
+"\n"
+"  Propiedades de la conexión inalámbrica\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "Cifrado WEP"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "Cifrado WPA"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "Cifrado WPA2"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "Cifrado TKIP"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "Cifrado CCMP"
 
-#: ../src/nm-netlink-monitor.c:441
+#: ../cli/src/devices.c:368
 #, c-format
-msgid "error updating link cache: %s"
-msgstr "error al actualizar el enlace caché: %s"
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Puntos de acceso inalámbricos %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = PA actual)"
 
-#: ../src/nm-netlink-monitor.c:499
+#: ../cli/src/devices.c:374
 #, c-format
-msgid "error occurred while waiting for data on socket"
-msgstr "ha ocurrido un error mientras esperaban datos en un socket"
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Propiedades de la conexión cableada\n"
 
-#: ../src/NetworkManager.c:252
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Portadora"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "encendido"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "apagado"
+
+#: ../cli/src/devices.c:387
 #, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
 msgstr ""
-"Opción no válida. Use --help para ver una lista de las opciones válidas.\n"
+"\n"
+"  Ajustes de IPv4:\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:88
-msgid "# Created by NetworkManager\n"
-msgstr "# Creado por NetworkManager\n"
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Dirección"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Prefijo"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Pasarela"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Estado de los dispositivos"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Error: falta el argumento «%s»."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Error: no se encontró el dispositivo «%s»"
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Éxito: se desconectó correctamente el dispositivo «%s»."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Error: falló la desconexión del dispositivo «%s» (%s): %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Estado del dispositivo: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Error: se debe especificar la interfaz."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Lista de la inspección inalámbrica"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Error: el dispositivo «%s» no es un dispositivo inalámbrico."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Dispositivo:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Error: se debe especificar la dirección hardware."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Error: no se encontró el punto de acceso con dirección hardware «%s»."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:94
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parámetros del PA"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Frecuencia:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Modo:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infraestructura"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Tasa de bits máxima:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Intensidad:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Opciones:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "privacidad"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "Opciones WPA:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "Opciones RSN:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Error: el comando «dev wifi» «%s» no es válido."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Error: el comando «dev» «%s» no es válido."
+
+#: ../cli/src/network-manager.c:46
 #, c-format
 msgid ""
-"# Merged from %s\n"
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
 "\n"
 msgstr ""
-"# Mezclado de %s\n"
+"Uso: nmcli nm {COMANDO | help }\n"
+"\n"
+"  COMANDO := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:256
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "dormida"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "conectando"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "activado"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "desactivado"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Estado de NetworkManager"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM en ejecución:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "en ejecución"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "no está en ejecución"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Estado de NM:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "Hardware inalámbrico de NM:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "Inalámbrico de NM:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "Hardware WWAN de NM:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "WWAN de NM:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Error: parámetro «wifi» no válido: «%s»."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Error: parámetro «wwan» no válido: «%s»."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Error: el comando «nm» «%s» no es válido."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
 msgstr ""
-"NOTA: el resolutor de nombres de libc puede que no soporte más de 3 "
-"servidores de nombres."
+"Uso: %s [OPCIONES] OBJETO { COMANDO | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    salida breve\n"
+"  -p[retty]   salida bonita\n"
+"  -v[ersion]  mostrar la versión del programa\n"
+"  -h[elp]     mostrar esta ayuda\n"
+"\n"
+"OBJECT\n"
+"  nm          estado de NetworkManager\n"
+"  con         conexiones de NetworkManager\n"
+"  dev         dispositivos gestionados por NetworkManager\n"
+"\n"
 
-#: ../src/named-manager/nm-named-manager.c:258
-msgid "The nameservers listed below may not be recognized."
-msgstr "Puede que los servidores de nombres listados abajo no se reconozcan."
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Se desconoce el objeto «%s», intente «nmcli help»."
 
-#: ../system-settings/src/main.c:376
+#: ../cli/src/nmcli.c:139
 #, c-format
-msgid "Auto %s"
-msgstr "Auto %ss"
+msgid "nmcli tool, version %s\n"
+msgstr "herramienta nmcli, versión %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Se desconoce la opción «%s», intente «nmcli -help»."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Se capturó la señal %d, apagando..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Error: no se pudo conectar con NetworkManager."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Éxito"
 
 #: ../libnm-util/crypto.c:120
 #, c-format
@@ -184,8 +954,9 @@ msgstr "No hay memoria suficiente para almacenar la IV."
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV contiene dígitos no hexadecimales."
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Se desconocía el cifrador de clave privada «%s»."
@@ -205,71 +976,106 @@ msgstr "No se pudo determinar el tipo de clave privada."
 msgid "Not enough memory to store decrypted private key."
 msgstr "No hay memoria suficiente para almacenar la clave privada descifrada."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "Falló al inicializar el motor de descifrado."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "Falló al inicializar el motor MD5: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Longitud IV no válida (debe ser al menos %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "No hay memoria suficiente para el búfer de la clave descifrada."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "Falló al inicializar el contexto de descifrado: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "Falló al establecer la clave simétrica para el descifrado: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "Falló al establecer IV para el descifrado: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "Falló al descifrar la clave privada: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Falló al descifrar la clave privada: longitud inesperada del relleno."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "Falló al descifrar la clave privada."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "No se pudo reservar memoria para el cifrado."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Falló al inicializar el contexto de cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Falló al establecer la clave simétrica para el cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Falló al establecer IV para el cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Falló al cifrar los datos: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Error al inicializar los datos del certificado: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "No se pudo decodificar el certificado: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "No se pudo inicializar el decodificador PKCS#12: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "No se pudo decodificar el archivo PKCS#12: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "No se pudo verificar el archivo PKCS#12: %s"
 
-#: ../libnm-util/crypto_nss.c:57
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Falló al inicializar el motor de cifrado: %d."
@@ -279,62 +1085,296 @@ msgstr "Falló al inicializar el motor de cifrado: %d."
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "Falló al inicializar el contexto MD5: %d"
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Longitud de IV no válida (debe ser al menos %d)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "Falló al inicializar la ranura de descifrado."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "Falló al establecer la clave simétrica para el descifrado."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "Falló al establecer IV para el descifrado."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "Falló al inicializar el contexto de descifrado."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "Falló al descifrar la clave privada: %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr ""
+"Falló al descifrar la clave privada: los datos descifrados son demasiado "
+"grandes."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "Falló la finalización del descifrado de la clave privada: %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Falló al inicializar la ranura de cifrado."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "Falló al establecer la clave simétrica para el cifrado."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "Falló al establecer IV para el cifrado."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "Falló al inicializar el contexto de cifrado."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "Falló al cifrar: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Cantidad de datos inesperada después de cifrar."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "No se pudo decodificar el certificado: %d"
 
-#: ../libnm-util/crypto_nss.c:317
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "No se pudo convertir la contraseña a UCS2: %d"
 
-#: ../libnm-util/crypto_nss.c:345
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "No se pudo inicializar el decodificador PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:354
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "No se pudo decodificar el archivo PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:363
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "No se pudo verificar el archivo PKCS#12: %d"
 
-#~ msgid "Not enough memory to create private key decryption key."
-#~ msgstr ""
-#~ "No hay memoria suficiente para crear la clave privada de la clave de "
-#~ "descifrado."
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "No se pudo generar datos aleatorios."
+
+#: ../libnm-util/nm-utils.c:1818
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "No hay memoria suficiente para crear la clave privada de cifrado."
+
+#: ../libnm-util/nm-utils.c:1928
+msgid "Could not allocate memory for PEM file creation."
+msgstr "No se pudo reservar memoria para crear el archivo PEM."
+
+#: ../libnm-util/nm-utils.c:1940
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "No se pudo asignar memoria para escribir IV en el archivo PEM."
+
+#: ../libnm-util/nm-utils.c:1952
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr ""
+"No se pudo asignar memoria para escribir la clave cifrada en el archivo PEM."
+
+#: ../libnm-util/nm-utils.c:1971
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "No se pudo reservar memoria para el archivo de datos PEM."
+
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "error al procesar el mensaje de netlink: %s"
+
+#: ../src/nm-netlink-monitor.c:259
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr ""
+"no se puede asignar el manejador netlink para monitorizar el estado del "
+"enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:269
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr ""
+"no se puede conectar con netlink para monitorizar el estado del enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:277
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr ""
+"no pudo unirse al grupo netlink para monitorizar el estado del enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:285
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr ""
+"no se puede asignar el enlace a la caché de netlink para monitorizar el "
+"estado del enlace: %s"
+
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
+msgid "error occurred while waiting for data on socket"
+msgstr "ha ocurrido un error mientras esperaban datos en un socket"
+
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "error al actualizar el enlace caché: %s"
+
+#: ../src/main.c:498
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr ""
+"Opción no válida. Use --help para ver una lista de las opciones válidas.\n"
+
+#: ../src/main.c:558
+#, c-format
+#| msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s. Use --help para ver una lista de las opciones válidas.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
+msgid "# Created by NetworkManager\n"
+msgstr "# Creado por NetworkManager\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# Mezclado de %s\n"
+"\n"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "no se encontró ningún cliente de DHCP usable."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "no se pudo encontrar «dhclient»."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "no se pudo encontrar «dhcpd»."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "no se soporta el cliente de DHCP «%s»"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "no se puede asignar el manejador netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:209
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "no se puede conectar con netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:306
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "no pudo unirse al grupo netlink: %s"
+
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "Nivel de registro «%s» desconocido"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "Dominio de registro «%s» desconocido"
+
+#: ../src/named-manager/nm-named-manager.c:314
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr ""
+"NOTA: el resolutor de nombres de libc puede que no soporte más de 3 "
+"servidores de nombres."
+
+#: ../src/named-manager/nm-named-manager.c:316
+msgid "The nameservers listed below may not be recognized."
+msgstr "Puede que los servidores de nombres listados abajo no se reconozcan."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "Auto %ss"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "Sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Compartir la conexión a través de una red inalámbrica protegida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Compartir la conexión a través de una red inalámbrica abierta"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Modificar el nombre de equipo persistente del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Modificar las conexiones del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr ""
+"La política del sistema impide modificaciones de los ajustes del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr ""
+"La política del sistema impide la modificaciones del nombre de equipo "
+"persistente del sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr ""
+"La política del sistema impide compartir conexiones a través de una red "
+"inalámbrica protegida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr ""
+"La política del sistema impide compartir conexiones a través de una red "
+"inalámbrica abierta"
diff --git a/po/eu.po b/po/eu.po
index 58353d1..f2e96a5 100644
--- a/po/eu.po
+++ b/po/eu.po
@@ -1,276 +1,1351 @@
-# translation of eu.po to Basque
+# translation of NetworkManager.master.po to Basque
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
 # This file is distributed under the same license as the PACKAGE package.
 #
-# Iñaki Larrañaga Murgoitio <dooteo@euskalgnu.org>, 2008.
+# Iñaki Larrañaga Murgoitio <dooteo@euskalgnu.org>, 2008, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: eu\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-09-09 16:04+0200\n"
-"PO-Revision-Date: 2008-09-09 16:25+0200\n"
+"Project-Id-Version: NetworkManager.master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-02-26 03:24+0000\n"
+"PO-Revision-Date: 2010-03-16 17:05+0100\n"
 "Last-Translator: Iñaki Larrañaga Murgoitio <dooteo@euskalgnu.org>\n"
 "Language-Team: Basque <itzulpena@euskalgnu.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms:  nplurals=2; plural=(n > 1);\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
 "X-Generator: KBabel 1.11.4\n"
 
-#: ../src/nm-netlink-monitor.c:193 ../src/nm-netlink-monitor.c:474
+#: ../cli/src/connections.c:86
 #, c-format
-msgid "error processing netlink message: %s"
-msgstr "errorea netlink-en mezua prozesatzean: %s"
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Erabilera: nmcli con { KOMANDOA| help }\n"
+"  KOMANDOA := { list | status | up | down }\n"
+"\n"
+"  list [id <IDa> | uuid <IDa> | system | user]\n"
+"  status\n"
+"  up id <IDa> | uuid <IDa> [iface <interfazea>] [ap <HW_helbidea>] [--nowait] [--timeout "
+"<denbora-muga>]\n"
+"  down id <IDa> | uuid <IDa>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Konexioak"
 
-#: ../src/nm-netlink-monitor.c:250
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Mota"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUIDa"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Izena"
+
+#: ../cli/src/connections.c:163
 #, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+msgid "System connections:\n"
+msgstr "Sistemako konexioak:\n"
 
-#: ../src/nm-netlink-monitor.c:260
+#: ../cli/src/connections.c:167
 #, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+msgid "User connections:\n"
+msgstr "Erabiltzailearen konexioak:\n"
 
-#: ../src/nm-netlink-monitor.c:268
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
 #, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "ezin da netlink taldearekin elkartu konexioaren egoera monitorizatzeko: %s"
+msgid "Error: %s argument is missing."
+msgstr "Errorea: %s argumentua falta da."
 
-#: ../src/nm-netlink-monitor.c:276
+#: ../cli/src/connections.c:189
 #, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgid "Error: %s - no such connection."
+msgstr "Errorea: %s - ez dago halako konexiorik"
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Sistema osoko konexioak"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Erabiltzailearen konexioak"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Parametro ezezagunak: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Errorea: ez da baliozko parametrorik zehaztu."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "bai"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "ez"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Konexio aktiboak"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Lehenetsia"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Zerbitzua"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Gailuak"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "ez dago konexio aktiborik '%s' gailuan"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ez dago konexio edo gailu aktiborik"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktibatzen"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktibatuta"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "ezezaguna"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN konektatzen (prestatzen)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN konektatzen (autentifikazioa behar da)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN konektatzen"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN konektatzen (IP konfigurazioa lortzen)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN konektatuta"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN konexioak huts egin du"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN deskonektatuta"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "arrazoi ezezaguna"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "bat ere ez"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "erabiltzailea deskonektatu egin da"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "oinarriko sarearen konexioa eten egin da"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN zerbitzua ustekabean gelditu da"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN zerbitzuak konfigurazio baliogabea itzuli du"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "konexioaren saiakeraren denbora-muga"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN zerbitzua ez da orduan abiatu"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "huts egin du VPN zerbitzuak abiaraztean"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "VPNren ezkutukoak ez dira baliozkoak"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "VPNren ezkutukoak baliogabeak"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "konexioa kendu egin da"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "egoera: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Konexioa aktibatuta\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Errorea: konexioaren aktibazioak huts egin du"
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "egoera: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Errorea: konexioaren aktibazioak huts egin du: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Errorea: denbora-muga %d segundotan iraungituta."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Errorea: konexioaren aktibazioak huts egin du: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Errorea: hust egin du '%s'(r)en konexio aktiboa lortzean."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Konexio aktiboaren egoera: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Konexio aktiboaren bide-izena: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Errorea: konexio ezezaguna: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Errorea: denbora-mugaren '%s' balioa ez da baliozkoa."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Errorea: IDa edo UUIDa zehaztu behar da."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Errorea: ez da gailu egokirik aurkitu: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Errorea: ez da gailu egokirik aurkitu."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Abisua: konexioa ez dago aktibo\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Errorea: 'con' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Errorea: ezin izan da 'D-Bus'-arekin konektatu."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Errorea: ezin izan da sistemako ezarpenik lortu."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Errorea: ezin izan da erabiltzailearen ezarpenik lortu."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Errorea: ezin da konexiorik lortu. Ezarpenen zerbitzuak ez dira exekutatzen ari."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"ezin da netlink-en konexio-cachea esleitu konexioaren egoera "
-"monitorizatzeko: %s"
+"Erabilera: nmcli dev { KOMANDOA | help }\n"
+"\n"
+"  KOMANDOA := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <interfazea>]\n"
+"  disconnect iface <interfazea> [--nowait] [--timeout <denbora-muga>]\n"
+"  wifi [list [iface <interfazea>] | apinfo iface <interfazea> hwaddr <HW_helbidea>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "kudeatu gabea"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "ez dago erabilgarri"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "deskonektatuta"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "konektatzen (prestatzen)"
 
-#: ../src/nm-netlink-monitor.c:439
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "konektatzen (konfiguratzen)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "konektatzen (autentifikazioa behar da)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "konektatzen (IParen konfigurazioa lortzen)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "konektatuta"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "konexioak huts egin du"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Ezezaguna"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(bat ere ez)"
+
+#: ../cli/src/devices.c:209
 #, c-format
-msgid "error updating link cache: %s"
-msgstr "errorea netlink-en konexio-cachea eguneratzean: %s"
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: errorea 0x%X IP4 helbidea bihurtzean"
 
-#: ../src/nm-netlink-monitor.c:497
+#: ../cli/src/devices.c:238
 #, c-format
-msgid "error occurred while waiting for data on socket"
-msgstr "errorea gertatu da socket-eko datuen zai egotean"
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Maizt. %d MHz, Emaria: %d Mb/s, Indarra %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
 
-#: ../src/NetworkManager.c:250
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", enkriptatuta: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " enpresa"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Gailua"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Kontrolatzailea"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(ezezaguna)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "Egoera"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW helbidea"
+
+#: ../cli/src/devices.c:319
 #, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Aukera baliogabea. Erabili '--help' baliozko aukeren zerrenda ikusteko.\n"
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Ahalmenak:\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:89
-msgid "# Created by NetworkManager\n"
-msgstr "# NetworkManager-ek sortuta\n"
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Garraiolaria detektatuta"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Abiadura"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:95
+#: ../cli/src/devices.c:348
 #, c-format
 msgid ""
-"# Merged from %s\n"
 "\n"
+"  Wireless Properties\n"
 msgstr ""
-"# %s(e)ndik batuta\n"
 "\n"
+"  Haririk gabekoaren propietateak\n"
 
-#: ../src/named-manager/nm-named-manager.c:240
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP enkriptatzea"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA enkriptatzea"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 enkriptatzea"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP zifratua"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP zifratua"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
 msgstr ""
-"OHARRA: libc-en ebaztaileak ez du 3 izen-zerbitzari baino gehiago "
-"onartzen."
+"\n"
+"  %s haririk gabeko sarbide-puntua\n"
 
-#: ../src/named-manager/nm-named-manager.c:242
-msgid "The nameservers listed below may not be recognized."
-msgstr "Azpian zerrendatutako izen-zenbitzariak ez dira ezagutuko."
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = uneko SarPunt)"
 
-#: ../system-settings/src/main.c:366
+#: ../cli/src/devices.c:374
 #, c-format
-msgid "Auto %s"
-msgstr "Auto %s"
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Haridunaren propietateak\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Garraiolaria"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "piztu"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "itzali"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4 ezarpenak:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Helbidea"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Aurrizkia"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Atebidea"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Gailuen egoera"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Errorea: '%s' argumentua falta da."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Errorea: '%s' gailua ez da aurkitu."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Ongi burututa: '%s' gailua ongi deskonektatu da."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Errorea: huts egin du '%s' (%s) gailua deskonektatzean: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Gailuaren egoera: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Errorea: interfazea zehaztu behar da."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Wifi-en eskaneatze-zerrenda"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Errorea: '%s' gailua ez da haririk gabeko gailu bat."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Gailua:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Errorea: hardwarearen helbidea zehaztu behar da."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Errorea: ez da '%s' hw helbideko sarbide-punturik aurkitu."
 
-#: ../libnm-util/crypto.c:125
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "SPuntuaren parametroak"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSIDa:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSIDa:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Maiztasuna:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Modua:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Azpiegitura"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Gehienezko bit-emaria:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Indarra:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Banderak:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "pribatutasuna"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA banderak:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN banderak:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Errorea: 'dev wifi' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Errorea: 'dev' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Erabilera: nmcli nm { KOMANDOA | help }\n"
+"\n"
+"  KOMANDOA := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "lotan"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "konektatzen"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "gaituta"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "desgaituta"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "NetworkManager-en egoera"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM-ren exekuzioa:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "exekutatzen"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "ez da exekutatzen ari"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM-ren egoera:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM haririk gabeko hardwarea:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM haririk gabekoa:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN hardwarea:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Errorea: baliogabeko 'wifi' parametroa: '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Errorea: baliogabeko 'wwan' parametroa: '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Errorea: 'nm' komandoko '%s' ez da baliozkoa."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Erabilera: %s [AUKERAK] OBJEKTUA { KOMANDOA | help }\n"
+"\n"
+"AUKERAK\n"
+"  -t[erse]    xehetasunezko irteera\n"
+"  -p[retty]   irteera politta\n"
+"  -v[ersion]  erakutsi programaren bertsioa\n"
+"  -h[elp]     erakutsi laguntza hau\n"
+"\n"
+"OBJEKTUA\n"
+"  nm          NetworkManager-en egoera\n"
+"  con         NetworkManager-en konexioak\n"
+"  dev         NetworkManager-ek kudeatutako gailuak\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "'%s' objektua ezezaguna da. Saiatu honako komandoarekin: nmcli help"
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli tresna, %s bertsioa\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "'%s' aukera ezezaguna da. Saiatu honako komandoarekin: nmcli -help"
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d seinalea jaso da, itzaltzen..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Errorea: ezin izan da NetworkManager-ekin konektatu."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Behar bezala egin da"
+
+#: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
 msgstr "PEM gako-fitxategiak ez du amaierako '%s' etiketa."
 
-#: ../libnm-util/crypto.c:135
+#: ../libnm-util/crypto.c:130
 #, c-format
 msgid "Doesn't look like a PEM private key file."
 msgstr "Ez dirudi PEM gako pribatuaren fitxategia denik."
 
-#: ../libnm-util/crypto.c:143
+#: ../libnm-util/crypto.c:138
 #, c-format
 msgid "Not enough memory to store PEM file data."
 msgstr "Ez dago nahikoa memoria PEM fitxategiko datuak gordetzeko."
 
-#: ../libnm-util/crypto.c:159
+#: ../libnm-util/crypto.c:154
 #, c-format
 msgid "Malformed PEM file: Proc-Type was not first tag."
 msgstr "Gaizki osatutako PEM fitxategia: Proc-Type ez da aurreneko etiketa."
 
-#: ../libnm-util/crypto.c:167
+#: ../libnm-util/crypto.c:162
 #, c-format
 msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
 msgstr "Gaizki osatutako PEM fitxategia: Proc-Type '%s' etiketa ezezaguna."
 
-#: ../libnm-util/crypto.c:177
+#: ../libnm-util/crypto.c:172
 #, c-format
 msgid "Malformed PEM file: DEK-Info was not the second tag."
 msgstr "Gaizki osatutako PEM fitxategia: DEK-Info ez da bigarren etiketa."
 
-#: ../libnm-util/crypto.c:188
+#: ../libnm-util/crypto.c:183
 #, c-format
 msgid "Malformed PEM file: no IV found in DEK-Info tag."
 msgstr "Gaizki osatutako PEM fitxategia: ez da IV aurkitu DEK-Info etiketan."
 
-#: ../libnm-util/crypto.c:195
+#: ../libnm-util/crypto.c:190
 #, c-format
 msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
 msgstr ""
 "Gaizki osatutako PEM fitxategia: IV-ek okerreko formatua du DEK-Info "
 "etiketan."
 
-#: ../libnm-util/crypto.c:208
+#: ../libnm-util/crypto.c:203
 #, c-format
 msgid "Malformed PEM file: unknown private key cipher '%s'."
 msgstr "Gaizki osatutako PEM fitxategia: gako pribatuaren '%s' zifratua ezezaguna."
 
-#: ../libnm-util/crypto.c:227
+#: ../libnm-util/crypto.c:222
 #, c-format
 msgid "Could not decode private key."
 msgstr "Ezin izan da gako pribatua deskodetu."
 
-#: ../libnm-util/crypto.c:271
+#: ../libnm-util/crypto.c:267
 #, c-format
 msgid "PEM certificate '%s' had no end tag '%s'."
 msgstr "'%s' PEM ziurtagiriak ez du amaierako '%s' etiketa."
 
-#: ../libnm-util/crypto.c:281
+#: ../libnm-util/crypto.c:277
 #, c-format
 msgid "Failed to decode certificate."
 msgstr "Huts egin du ziurtagiria deskodetzean."
 
-#: ../libnm-util/crypto.c:290 ../libnm-util/crypto.c:298
+#: ../libnm-util/crypto.c:286
 #, c-format
 msgid "Not enough memory to store certificate data."
 msgstr "Ez dago nahikoa memoria ziurtagiriaren datuak gordetzeko."
 
-#: ../libnm-util/crypto.c:328
+#: ../libnm-util/crypto.c:294
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Not enough memory to store file data."
+msgstr "Ez dago nahikoa memoria fitxategiko datuak gordetzeko."
+
+#: ../libnm-util/crypto.c:324
 #, c-format
 msgid "IV must be an even number of bytes in length."
 msgstr "IV-ek byte-kopuru bikoitia izan behar du luzeran."
 
-#: ../libnm-util/crypto.c:337
+#: ../libnm-util/crypto.c:333
 #, c-format
 msgid "Not enough memory to store the IV."
 msgstr "Ez dago nahikoa memoria IV gordetzeko."
 
-#: ../libnm-util/crypto.c:348
+#: ../libnm-util/crypto.c:344
 #, c-format
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV-ek hamaseitarrak ez diren digituak ditu."
 
-#: ../libnm-util/crypto.c:386 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:157
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Gako pribatuaren '%s' zifratua ezezaguna da."
 
-#: ../libnm-util/crypto.c:395
+#: ../libnm-util/crypto.c:391
+#, c-format
+#| msgid "Not enough memory to store decrypted private key."
+msgid "Not enough memory to decrypt private key."
+msgstr "Ez dago nahikoa memoria gako pribatua deszifratzeko."
+
+#: ../libnm-util/crypto.c:511
 #, c-format
-msgid "Not enough memory to create private key decryption key."
-msgstr "Ez dago nahikoa memoria gako pribatuaren gako deszifratua sortzeko."
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Unable to determine private key type."
+msgstr "Huts egin du gako pribatuaren mota zehaztean."
 
-#: ../libnm-util/crypto.c:513
+#: ../libnm-util/crypto.c:530
 #, c-format
 msgid "Not enough memory to store decrypted private key."
 msgstr "Ez dago nahikoa memoria deszifratutako gako pribatua gordetzeko."
 
-#: ../libnm-util/crypto_gnutls.c:45
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "Huts egin du zifratzearen motorra hasieratzean."
 
-#: ../libnm-util/crypto_gnutls.c:89
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "Huts egin du MD5 motorra hasieratzean: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:166
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Baliogabeko IV luzera (gutxienez %zd izan behar du)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "Ez dago nahikoa memoria deszifratutako gako buferrarentzako."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "Huts egin du zifratze-testuingurua hasieratzean deszifratzeko: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "Huts egin du gako simetrikoa ezartzean deszifratzeko: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "Huts egin du IV ezartzean deszifratzeko: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "Huts egin du gako pribatua deszifratzean: %s /%s."
 
-#: ../libnm-util/crypto_gnutls.c:225
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Huts egin du gako pribatua deszifratzean: ustekabeko betegarriaren luzera."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key."
+msgstr "Huts egin du gako pribatua deszifratzean."
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Ezin izan da memoria esleitu enkriptatzeko."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Huts egin du zifratze-testuingurua enkriptazioa hasieratzean: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Huts egin du gako simetrikoa ezartzean enkriptatzeko: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Huts egin du IV ezartzean enkriptatzeko: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Huts egin du datuak enkriptatzean: %s /%s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Errorea ziurtagiriaren datuak hasieratzean: %s"
 
-#: ../libnm-util/crypto_gnutls.c:237
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "Ezin izan da ziurtagiria deskodetu: %s."
 
-#: ../libnm-util/crypto_nss.c:52
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "Ezin izan da PKCS#12 deskodetzailea hasieratu: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "Ezin izan da PKCS#12 fitxategia deskodetu: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+#| msgid "Couldn't decode certificate: %s"
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "Ezin izan da PKCS#12 fitxategia egiaztatu: %s"
+
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Huts egin du zifratzearen motorra hasieratzean: %d."
 
-#: ../libnm-util/crypto_nss.c:98
+#: ../libnm-util/crypto_nss.c:111
 #, c-format
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "Huts egin du MD5-en testuingurua hasieratzean: %d."
 
-#: ../libnm-util/crypto_nss.c:174
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Baliogabeko IV luzera (gutxienez %d izan behar du)"
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "Huts egin du zifratuaren erretena hasieratzean deszifratzeko."
 
-#: ../libnm-util/crypto_nss.c:184
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "Huts egin du gako simetrikoa ezartzean deszifratzeko."
 
-#: ../libnm-util/crypto_nss.c:194
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "Huts egin du IV ezartzean deszifratzeko."
 
-#: ../libnm-util/crypto_nss.c:202
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "Huts egin du deszifratzearen testuingurua hasieratzean."
 
-#: ../libnm-util/crypto_nss.c:215
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "Huts egin du gako pribatua deszifratzean: %d."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Huts egin du gako pribatua deszifratzean: deszifratutako datuak luzeegiak dira."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "Huts egin du gako pribatuaren deszifratzea amaitzean: %d."
 
-#: ../libnm-util/crypto_nss.c:271
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Huts egin du zifratuaren erretenaren enkriptazioa hasieratzean."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "Huts egin du gako simetrikoa ezartzean enkriptatzeko."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "Huts egin du IV ezartzean enkriptatzeko."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "Huts egin du enkriptazioaren testuingurua hasieratzean."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "Huts egin du enkriptatzean: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Ustekabeko datu kopurua enkriptatu ostean."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "Ezin izan da ziurtagiria dekodetu: %d"
 
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "Ezin izan da pasahitza UCS2-ra bihurtu: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "Ezin izan da PKCS#12 deskodetzailea hasieratu: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "Ezin izan da PKCS#12 fitxategia deskodetu: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+#| msgid "Couldn't decode certificate: %d"
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "Ezin izan da PKCS#12 fitxategia egiaztatu: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "Ezin izan da ausazko daturik sortu."
+
+#: ../libnm-util/nm-utils.c:1545
+#, c-format
+#| msgid "Not enough memory to create private key decryption key."
+msgid "Not enough memory to make encryption key."
+msgstr "Ez dago nahikoa memoria gakoa enkriptatzeko."
+
+#: ../libnm-util/nm-utils.c:1655
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Ezin izan da memoria esleitu PEM fitxategia sortzeko."
+
+#: ../libnm-util/nm-utils.c:1667
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Ezin izan da memoria esleitu IV idazteko PEM fitxategian."
+
+#: ../libnm-util/nm-utils.c:1679
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Ezin izan da memoria esleitu enkriptatutako gakoa idazteko PEM fitxategian."
+
+#: ../libnm-util/nm-utils.c:1698
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "Ezin izan da memoria esleitu PEM fitxategiko datuentzako."
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "errorea netlink-en mezua prozesatzean: %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "ezin da netlink-ekin konektatu konexioaren egoera monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "ezin da netlink taldearekin elkartu konexioaren egoera monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr ""
+"ezin da netlink-en konexio-cachea esleitu konexioaren egoera "
+"monitorizatzeko: %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "errorea gertatu da socket-eko datuen zai egotean"
+
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "errorea netlink-en konexio-cachea eguneratzean: %s"
+
+#: ../src/NetworkManager.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "Aukera baliogabea. Erabili '--help' baliozko aukeren zerrenda ikusteko.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
+msgid "# Created by NetworkManager\n"
+msgstr "# NetworkManager-ek sortuta\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# %s(e)ndik batuta\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "ezin da netlink-en kudeaketa esleitu: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "ezin da netlink-ekin konektatu: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "ezin da netlink taldearekin elkartu: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "OHARRA: libc-en ebaztaileak ez du 3 izen-zerbitzari baino gehiago onartzen."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "Azpian zerrendatutako izen-zenbitzariak ez dira ezagutuko."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "Auto %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "Sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Konexio partekatua babestutako haririk gabeko sarearen bidez"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Konexio partekatua irekitako haririk gabeko sarearen bidez"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Aldatu sistemako ostalari-izen iraunkorra"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Aldatu sistemako konexioak"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "Sistemako arauek sistemako ezarpenak aldatzea saihesten dute"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "Sistemako arauek sistemako ostalari-izen iraunkorra aldatzea saihesten dute"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "Sistemako arauek babestutako haririk gabeko sareen bidez konexioak partekatzea saihesten dute"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "Sistemako arauek irakitako haririk gabeko sareen bidez konexioak partekatzea saihesten dute"
+
diff --git a/po/gl.po b/po/gl.po
index 5193a4b..ca5d3d5 100644
--- a/po/gl.po
+++ b/po/gl.po
@@ -2,53 +2,487 @@
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
 # This file is distributed under the same license as the PACKAGE package.
 #
-# Ignacio Casal Quinteiro <icq@cvs.gnome.org>, 2007.
-# Ignacio Casal Quinteiro <icq@svn.gnome.org>, 2008.
+# Ignacio Casal Quinteiro <icq@cvs.gnome.org>, 2007, 2008.
+# Miguel Anxo Bouzada <mbouzada@gmail.com>, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: gl\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-02-13 16:21+0100\n"
-"PO-Revision-Date: 2008-02-13 16:23+0100\n"
-"Last-Translator: Ignacio Casal Quinteiro <icq@svn.gnome.org>\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2009-09-29 03:25+0000\n"
+"PO-Revision-Date: 2010-02-25 11:06+0100\n"
+"Last-Translator: Miguel Anxo Bouzada <mbouzada@gmail.com>\n"
 "Language-Team: Galego <proxecto@trasno.net>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
 
-#: ../src/nm-netlink-monitor.c:188 ../src/nm-netlink-monitor.c:448
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "O ficheiro de chave PEM non ten a etiqueta de final «%s»."
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr "Non parece un ficheiro de chave privada PEM."
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr "Non hai memoria abondo para almacenar o ficheiro PEM."
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr "Ficheiro PEM malformado: Proc-Type non é a primeira etiqueta."
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr "Ficheiro PEM malformado: a etiqueta Proc-Type «%s »é descoñecida."
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr "Ficheiro PEM malformado: Proc-Type non é a segunda etiqueta."
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr "Ficheiro PEM malformado: non se atopou ningún IV na etiqueta DEK-Info"
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr "Ficheiro PEM malformado: formato de IV incorrecto na etiqueta DEK-Info"
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr "Ficheiro PEM malformado: o cifrado da chave privada «%s» é descoñecido"
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "Non puido ser decodificada a chave privada."
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "O certificado PEM «%s» non ten unha etiqueta de final «%s»."
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "Fallou ao decodificar o certificado"
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "Non hai memoria abondo para almacenar os datos do certificado"
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "Non hai memoriaabondo para almacenar os datos do ficheiro"
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV debe ter un número par de bytes en lonxitude."
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "Non hai memoria abondo para almacenar o IV."
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV contén díxitos non hexadecimais."
+
+#: ../libnm-util/crypto.c:382
+#: ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266
+#: ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:335
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "O cifrado «%s» da chave privada é descoñecido."
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "Non hai memoria abondo para descifrar esta chave privada."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "Non foi posíbel determinar o tipo de chave privada"
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "Non hai memoria abondo para almacenar a chave privada descifrada."
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "Produciuse un erro ao iniciar o motor de cifrado"
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "Produciuse un erro ao iniciar a arquitectura MD5: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Lonxitude de IV incorrecta (debe ser polo menos %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165
+#: ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "Non hai memoria abondo para o búfer da chave descifrada."
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "Produciuse un erro ao inicializar o contexto de cifrado para o descifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "Produciuse un erro ao establecer a chave simétrica para o descifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "Produciuse un erro ao establecer IV para o descifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "Produciuse un erro ao descifrar a chave privada: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210
+#: ../libnm-util/crypto_nss.c:266
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Produciuse un fallo ao descifrar a chave privada: lonxitude de desprazamento non esperada."
+
+#: ../libnm-util/crypto_gnutls.c:221
+#: ../libnm-util/crypto_nss.c:277
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "Produciuse un erro ao descifrar a chave privada"
+
+#: ../libnm-util/crypto_gnutls.c:286
+#: ../libnm-util/crypto_nss.c:355
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Non foi posíbel asignar a memoria para cifrar."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Produciuse un erro ao inicializar o contexto da chave de cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Produciuse un erro ao establecer a chave simétrica para o cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Produciuse un erro ao establecer IV para o cifrado: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Produciuse un erro ao cifrar os datos: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "Produciuse un erro ao iniciar a certificación dos datos: %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "Non se puido decodificar o certificado: %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "Non foi posíbel iniciar o decodificador PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "Non foi posíbel decodificar o ficheiro PKCS#12: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "Non foi posíbel verificar o ficheiro PKCS#12: %s"
+
+#: ../libnm-util/crypto_nss.c:57
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "Produciuse un erro ao iniciar o motor de cifrado:%d."
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "Produciuse un erro ao iniciar o contexto MD5: %d."
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Lonxitude de IV incorrecta (debe ser polo menos %d)."
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "Produciuse un erro ao iniciar a rañura de cifrado para o descifrado"
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "Produciuse un erro ao establecer a chave simétrica para o descifrado."
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "Produciuse un erro ao establecer IV para o descifrado."
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "Produciuse un erro ao iniciar o contexto de descifrado."
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "Produciuse un erro ao descifrar a chave privada: %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Produciuse un erro ao descifrar a chave privada: os datos descifrados son moi grandes."
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "Produciuse un erro ao finalizar o descifrado da chave privada: %d."
+
+#: ../libnm-util/crypto_nss.c:363
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Produciuse un erro ao inicializar a rañura da cifra de cifrado."
+
+#: ../libnm-util/crypto_nss.c:371
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "Produciuse un erro ao establecer a chave simétrica para o cifrado."
+
+#: ../libnm-util/crypto_nss.c:379
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "Produciuse un erro ao establecer IV para o cifrado."
+
+#: ../libnm-util/crypto_nss.c:387
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "Produciuse un erro ao inicializar o contexto de cifrado."
+
+#: ../libnm-util/crypto_nss.c:395
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "Produciuse un erro ao cifrar: %d."
+
+#: ../libnm-util/crypto_nss.c:403
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Tamaño non agardado de datos despois de cifrar."
+
+#: ../libnm-util/crypto_nss.c:446
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "Non foi posíbel decodificar o certificado: %d"
+
+#: ../libnm-util/crypto_nss.c:481
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "Non foi posíbel converter a chave a UCS2: %d"
+
+#: ../libnm-util/crypto_nss.c:509
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "Non foi posíbel iniciar o decodificador PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:518
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "Non fo posíbel decodificar o ficheiro PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:527
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "Non foi posíbel verficar o ficheiro PKCS#12: %d"
+
+#: ../libnm-util/crypto_nss.c:556
+msgid "Could not generate random data."
+msgstr "Non foi posíbel xerar datos aleatorios."
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "Sen memoria abondo para crear a chave de cifrado."
+
+#: ../libnm-util/nm-utils.c:1633
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Non foi posíbel asignar memoria para a creación do ficheiro PEM,"
+
+#: ../libnm-util/nm-utils.c:1645
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Non foi posíbel asignar memoria para escribir IV no ficheiro PEM."
+
+#: ../libnm-util/nm-utils.c:1657
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Non foi posíbel asignar memoria para escribir a chave cifrada no ficheiro PEM."
+
+#: ../libnm-util/nm-utils.c:1676
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "Non foi posíbel asignar memoria para os datos do ficheiro PEM."
+
+#: ../src/nm-netlink-monitor.c:194
+#: ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:569
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
-msgstr "erro procesando a mensaxe netlink: %s"
+msgstr "produciuse un erro procesando a mensaxe netlink: %s"
 
-#: ../src/nm-netlink-monitor.c:245
+#: ../src/nm-netlink-monitor.c:260
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "non se pode crear o manexador netlink para monitorizar o estado da ligazón: %s"
+msgstr "non é posíbel crear o manexador netlink para monitorizar o estado da ligazón: %s"
 
-#: ../src/nm-netlink-monitor.c:255
+#: ../src/nm-netlink-monitor.c:270
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "non se pode conectar ao netlink para monitorizar o estado da lingazón: %s"
+msgstr "non é posíbel conectar ao netlink para monitorizar o estado da lingazón: %s"
 
-#: ../src/nm-netlink-monitor.c:263
+#: ../src/nm-netlink-monitor.c:278
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "non se pode unir ao grupo netlink para monitorizar o estado da ligazón: %s"
+msgstr "non é posíbel unir ao grupo netlink para monitorizar o estado da ligazón: %s"
 
-#: ../src/nm-netlink-monitor.c:271
+#: ../src/nm-netlink-monitor.c:286
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "non se pode asignar a ligazón á caché netlink para monitorizar o estado da ligazón: %s"
+msgstr "non é posíbel asignar a ligazón á caché netlink para monitorizar o estado da ligazón: %s"
 
-#: ../src/nm-netlink-monitor.c:471
-#, c-format
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
-msgstr "ocorreu un erro agardando por datos nun socket"
+msgstr "producouse un erro agardando por datos nun socket"
+
+#: ../src/nm-netlink-monitor.c:558
+#, c-format
+#| msgid "error processing netlink message: %s"
+msgid "error updating link cache: %s"
+msgstr "produciuse un erro ao actualizar a caché de ligazóns: %s"
 
-#: ../src/NetworkManager.c:255
+#: ../src/NetworkManager.c:330
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Opción inválida. Use --help para ver a lista de opcións válidas.\n"
+msgstr "Opción incorrecta. Use --help para ver a lista de opcións válidas.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+msgid "# Created by NetworkManager\n"
+msgstr "# Creado por NetworkManager\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# Fusionado desde %s\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "non é posíbel asignar un manexador para a ligazon de rede: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "non é posíbel conectar coa ligazón de rede: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "non é posíbel unir ao grupo da ligazón de rede: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "NOTE: o importador libc non permite máis de 3 nomes de servidores."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "Os nomes de servidores listados a seguir poden non ser recoñecidos"
+
+#: ../src/system-settings/nm-default-wired-connection.c:194
+#, c-format
+msgid "Auto %s"
+msgstr "Auto %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+msgid "System"
+msgstr "Sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "Conexión compartida a través dunha rede WiFi protexida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "Conexión compartida a través dunha rede WiFi aberta"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "Modificar o nome persistente do anfitrión do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "Modificar as conexións do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "A política do sistema impide a modificación da configuración do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "A política do sistema impide a modificación do nome do anfitrión do sistema"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "A política do sistema impide compartir conexións a través dunha rede WiFi protexida"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "A política do sistema impide compartir conexións a través dunha rede WiFi aberta"
 
diff --git a/po/hi.po b/po/hi.po
new file mode 100644
index 0000000..291b17a
--- /dev/null
+++ b/po/hi.po
@@ -0,0 +1,477 @@
+# translation of NetworkManager.master.po to Hindi
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+#
+# Rajesh Ranjan <rranjan@redhat.com>, 2010.
+msgid ""
+msgstr ""
+"Project-Id-Version: NetworkManager.master\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-02-24 03:25+0000\n"
+"PO-Revision-Date: 2010-02-24 12:47+0530\n"
+"Last-Translator: Rajesh Ranjan <rranjan@redhat.com>\n"
+"Language-Team: Hindi <Red Hat>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.11.4\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n\n"
+
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "PEM कुंजी फाइल के पास कोई अंत टैग '%s' नहीं है."
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr "एक PEM निजी कुंजी फाइल की तरह का नहीं दिखता है."
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr "PEM फाइल डेटा जमा करने के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr "विरूपित PEM फाइल: Proc-Type पहला टैग नहीं था."
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr "विरूपित PEM फाइल: अज्ञात Proc-Type टैग '%s'."
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr "विरूपित PEM फाइल: DEK-Info दूसरा टैग नहीं था."
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr "विरूपित PEM फाइल: कोई IV DEK-Info टैग में नहीं मिला."
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr "विरूपित PEM फाइल: IV का अवैध प्रारूप DEK-Info टैग में."
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr "विरूपित PEM फाइल: अज्ञात निजी कुंजी साइफर '%s'."
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "निजी कुंजी को विगोपित नहीं कर सका."
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "PEM प्रमाणपत्र '%s' के पास कोई अंत टैग '%s' नहीं है."
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "प्रमाणपत्र विगोपित करने में विफल."
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "प्रमाणपत्र आँकड़ा जमा करने के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "फाइल आँकड़ा जमा करने के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV की लंबाई में बाइट संख्या सम संख्या होनी चाहिए."
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "IV जमा करने के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV गैर हेक्साडेसीमेल अंक समाहित करता है."
+
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "निजी कुंजी साइफर '%s' अज्ञात था."
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "निजी कुंजी गोपित करने के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "निजी कुंजी प्रकार निर्धारित करने में असमर्थ."
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "विगोपित निजी कुंजी जमा करने के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "क्रिप्टो ईंजन आरंभीकृत करने में विफल."
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "MD5 ईंजन आरंभीकृत करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "अवैध IV लंबाई (कम से कम %zd होना चाहिए)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "विगोपित कुंजी बफर के लिए पर्याप्त स्मृति नहीं."
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "विगोपन साइफर संदर्भ को आरंभीकृत करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "गोपन के लिए सममितीय कुंजी सेट करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "IV को गोपन के लिए सेट करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "निजी कुंजी गोपित करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "निजी कुंजी गोपित करने में विफल: अप्रत्याशित पैडिंग लंबाई."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "निजी कुंजी गोपित करने में विफल."
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "गोपन के लिए स्मृति आबंटित नहीं कर सका."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "गोपन साइफर संदर्भ को आरंभीकृत करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "गोपन के लिए सममितीय कुंजी सेट करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "IV को गोपन के लिए सेट करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "आँकड़ा गोपित करने में विफल: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "प्रमाणपत्र आँकड़ा आरंभीकृत करने में विफल: %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "प्रमाणपत्र विगोपित नहीं कर सका: %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "PKCS#12 विगोपक आरंभीकृत नहीं कर सका: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "PKCS#12 फाइल विगोपित नहीं कर सका: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "PKCS#12 फाइल जाँच नहीं सका: %s"
+
+#: ../libnm-util/crypto_nss.c:56
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "क्रिप्टो ईंजन आरंभीकृत करने में विफल: %d."
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "MD5 संदर्भ आरंभीकृत करने में विफल: %d."
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "अवैध IV लंबाई (जरूर कम से कम %d होना चाहिए)."
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "विगोपन साइफर स्लॉट को आरंभीकृत करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "गोपन के लिए सममितीय कुंजी सेट करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "IV को गोपन के लिए सेट करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "गोपन संदर्भ आरंभीकृत करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "निजी कुंजी गोपित करने में विफल: %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "निजी कुंजी गोपित करने में विफल: विगोपित आँकड़ा काफी बड़ा है."
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "निजी कुंजी के विगोपन को अंतिम रूप देने में विफल: %d."
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "गोपन साइफर स्लाट आरंभीकृत करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "गोपन के लिए सममितीय कुंजी सेट करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "IV को गोपन के लिए सेट करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "गोपन संदर्भ आरंभीकृत करने में विफल."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "गोपित करने में विफल: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "गोपन के बाद आँकड़ा की अप्रत्याशित मात्रा."
+
+#: ../libnm-util/crypto_nss.c:447
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "प्रमाणपत्र डिकोड नहीं कर सका: %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "कूटशब्द को UCS2 में बदल नहीं सका: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "PKCS#12 डिकोडर को आरंभीकृत नहीं कर सका: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "PKCS#12 फाइल विगोपित नहीं कर सका: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "PKCS#12 फाइल जाँच नहीं सका: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "क्रमहीन आँकड़ा बना नहीं सका."
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "गोपन कुंजी बनाने के लिए पर्याप्त मात्रा में स्मृति नहीं."
+
+#: ../libnm-util/nm-utils.c:1632
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM फाइल निर्माण के लिए स्मृति नहीं आबंटित कर सका."
+
+#: ../libnm-util/nm-utils.c:1644
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "IV से PEM फाइल में लिखने के लिए स्मृति नहीं आबंटित कर सका."
+
+#: ../libnm-util/nm-utils.c:1656
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "गोपित कुंजी को PEM फाइल में लिखने के लिए स्मृति नहीं आबंटित कर सका."
+
+#: ../libnm-util/nm-utils.c:1675
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM फाइल आँकड़ा के लिए स्मृति नहीं आबंटित कर सका."
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "netlink संदेश की प्रक्रिया में त्रुटि: %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "लिंक स्थिति मॉनिटर करने के लिए नेटलिंक नियंत्रण का आबंटित नहीं कर सका: %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "नेटलिंक को मॉनिटरिंग लिंक स्थिति के लिए कनेक्ट करने में असमर्थ: %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "मॉनिटरिंग लिंक स्थिति के लिए नेटलिंक में शामिल होने में असमर्थ: %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "नेटलिंक कैश को मॉनिटरिंग लिंक स्थिति के लिए आबंटित करने में असमर्थ: %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "सॉकेट पर आँकड़ा के लिए प्रतीक्षा करने के दौरान त्रुटि"
+
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "लिंक कैश अद्यतन करने में त्रुटि: %s"
+
+#: ../src/NetworkManager.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "अवैध विकल्प.  कृपया --help का उपयोग वैध विकल्प देने के लिए करें.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:297
+msgid "# Created by NetworkManager\n"
+msgstr "# संजाल प्रबंधक द्वारा निर्मित\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:313
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"#%s से मिलाया गया\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "नेटलिंक हैंडल आबंटित करने में असमर्थ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "नेटलिंक में कनेक्ट करने में असमर्थ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "नेटलिंक समूह में शामिल होने में असमर्थ: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "नोट: libc समाधानकर्ता 3 नेमसर्वर से अधिक का समर्थन नहीं कर सकता है."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "नीचे सूची में दिया गया नेमसर्वर पहचाना नहीं जा सकता है."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "स्वतः %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3220
+msgid "System"
+msgstr "तंत्र"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "किसी संरक्षित WiFi संजाल के द्वारा कनेक्शन साझा"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "किसी खुले WiFi संजाल के द्वारा कनेक्शन साझा"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "स्थिर सिस्टम होस्टनेम को सुधारें"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "सिस्टम कनेक्शन सुधारें"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "सिस्टम नीति सिस्टम सेटिंग के रूपांतरण को रोकता है."
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "सिस्टम नीति स्थिर सिस्टम होस्टनेम के रूपांतरण को रोकता है."
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "किसी संरक्षित WiFi संजाल के द्वारा साझा कनेक्शन को सिस्टम नीति रोकता है"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "किसी खुले WiFi संजाल के द्वारा साझा कनेक्शन को सिस्टम नीति रोकता है"
+
diff --git a/po/kn.po b/po/kn.po
index 999ee84..bd04652 100644
--- a/po/kn.po
+++ b/po/kn.po
@@ -3,21 +3,866 @@
 # Copyright (C) 2009 NetworkManager's COPYRIGHT HOLDER
 # This file is distributed under the same license as the NetworkManager package.
 #
-# Shankar Prasad <svenkate@redhat.com>, 2009.
+# Shankar Prasad <svenkate@redhat.com>, 2009, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager.po.master.kn\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-06-15 03:24+0000\n"
-"PO-Revision-Date: 2009-06-15 14:24+0530\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-21 03:24+0000\n"
+"PO-Revision-Date: 2010-04-20 18:07+0530\n"
 "Last-Translator: Shankar Prasad <svenkate@redhat.com>\n"
-"Language-Team: Kannada <en@li.org>\n"
+"Language-Team: kn-IN <>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: KBabel 1.11.4\n"
+"X-Generator: Lokalize 1.0\n"
 "Plural-Forms:  nplurals=2; plural=(n != 1);\n"
 
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"ಬಳಕೆ: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "ಸಂಪರ್ಕಗಳು"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "ಬಗೆ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "ಹೆಸರು"
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "ವ್ಯವಸ್ಥೆಯ ಸಂಪರ್ಕಗಳು:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "ಬಳಕೆದಾರ ಸಂಪರ್ಕಗಳು:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "ದೋಷ: %s ಆರ್ಗ್ಯುಮೆಂಟ್ ಕಾಣಿಸುತ್ತಿಲ್ಲ"
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "ದೋಷ: %s - ಅಂತಹ ಯಾವುದೆ ಸಂಪರ್ಕಗಳಿಲ್ಲ."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "ವ್ಯವಸ್ಥೆಯಾದ್ಯಂತದ ಸಂಪರ್ಕಗಳು"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "ಬಳಕೆದಾರ ಸಂಪರ್ಕಗಳು"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "ಗೊತ್ತಿರದ ನಿಯತಾಂಕಗಳು: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "ದೋಷ: ಮಾನ್ಯವಾದ ಯಾವುದೆ ನಿಯತಾಂಖವನ್ನು ಸೂಚಿಸಲಾಗಿಲ್ಲ."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ಹೌದು"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "ಇಲ್ಲ"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "ಸಕ್ರಿಯ ಸಂಪರ್ಕಗಳು"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "ಪೂರ್ವನಿಯೋಜಿತ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "ಸೇವೆ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "ಸಾಧನಗಳು"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "'%s' ಎಂಬ ಸಾಧನದಲ್ಲಿ ಯಾವುದೆ ಸಕ್ರಿಯ ಸಂಪರ್ಕವು ಕಂಡುಬಂದಿಲ್ಲ"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ಯಾವುದೆ ಸಕ್ರಿಯ ಸಂಪರ್ಕ ಅಥವ ಸಾಧನವು ಕಂಡುಬಂದಿಲ್ಲ"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "ಸಕ್ರಿಯಗೊಳ್ಳುತ್ತಿದೆ"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "ಸಕ್ರಿಯಗೊಂಡಿದೆ"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "ಗೊತ್ತಿಲ್ಲದ"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ (ಸಿದ್ಧಗೊಳಿಕೆ)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ (ದೃಢೀಕರಣದ ಅಗತ್ಯವಿದೆ)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN ಸಂಪರ್ಕಿತಗೊಳ್ಳುತ್ತಿದೆ"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN ಸಂಪರ್ಕಗೊಂಡಿದೆ (IP ಸಂರಚನೆಯನ್ನು ಪಡೆಯಲಾಗುತ್ತಿದೆ)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN ಸಂಪರ್ಕಗೊಂಡಿದೆ"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN ಸಂಪರ್ಕವು ವಿಫಲಗೊಂಡಿದೆ"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN ಸಂಪರ್ಕ ಕಡಿದಿದೆ"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "ಗೊತ್ತಿರದ ಕಾರಣ"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "ಯಾವುದೂ ಇಲ್ಲ"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "ಬಳಕೆದಾರರೊಂದಿಗೆ ಸಂಪರ್ಕ ಕಡಿದುಹೋಗಿದೆ"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "ಮೂಲ ಜಾಲಬಂಧ ಸಂಪರ್ಕಕ್ಕೆ ತಡೆಯುಂಟಾಗಿದೆ"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN ಸೇವೆಯನ್ನು ಅನಿರೀಕ್ಷಿತವಾಗಿ ನಿಲ್ಲಿಸಲಾಗಿದೆ"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN ಸೇವೆಯು ಅಮಾನ್ಯವಾದ ಸಂರಚನೆಯನ್ನು ಮರಳಿಸಿದೆ"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "ಸಂಪರ್ಕದ ಪ್ರಯತ್ನದ ಕಾಲಾವಧಿ ಮೀರಿದೆ"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN ಸೇವೆಯು ಸರಿಯಾದ ಸಮಯದಲ್ಲಿ ಆರಂಭಗೊಳ್ಳಲಿಲ್ಲ"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN ಸೇವೆಯು ಆರಂಭಗೊಳ್ಳಲು ವಿಫಲಗೊಂಡಿದೆ"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "ಯಾವುದೆ ಮಾನ್ಯವಾದ VPN ರಹಸ್ಯಗಳಿಲ್ಲ (ಸೀಕ್ರೇಟ್‌ಗಳಿಲ್ಲ)"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "ಅಮಾನ್ಯವಾದ VPN ರಹಸ್ಯಗಳು"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "ಸಂಪರ್ಕವನ್ನು ತೆಗೆದು ಹಾಕಲಾಗಿದೆ"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "ಸ್ಥಿತಿ: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "ಸಂಪರ್ಕವನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "ದೋಷ: ಸಂಪರ್ಕವನ್ನು ಸಕ್ರಿಯಗೊಳಿಕೆಯು ವಿಫಲಗೊಂಡಿದೆ."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "ಸ್ಥಿತಿ: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "ದೋಷ: ಸಂಪರ್ಕ ಸಕ್ರಿಯಗೊಳಿಕೆಯು ವಿಫಲಗೊಂಡಿದೆ: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "ದೋಷ: ಕಾಲಾವಧಿ %d sec ತೀರಿದೆ."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "ದೋಷ: ಸಂಪರ್ಕ ಸಕ್ರಿಯಗೊಳಿಕೆಯು ವಿಫಲಗೊಂಡಿದೆ: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "ದೋಷ: '%s' ಗಾಗಿ ಸಕ್ರಿಯ ಸಂಪರ್ಕವನ್ನು ಪಡೆಯುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "ಸಕ್ರಿಯ ಸಂಪರ್ಕದ ಸ್ಥಿತಿ: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "ಸಕ್ರಿಯ ಸಂಪರ್ಕ ಮಾರ್ಗ: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "ದೋಷ: ಗೊತ್ತಿರದ ಸಂಪರ್ಕ: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "ದೋಷ: '%s' ಎಂಬ ಕಾಲಾವಧಿ ತೀರಿಕೆ ಮೌಲ್ಯವು ಅಮಾನ್ಯವಾಗಿದೆ."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "ದೋಷ: id ಅಥವ uuid ಅನ್ನು ಸೂಚಿಸಬೇಕು."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "ದೋಷ: ಯಾವುದೆ ಸೂಕ್ತವಾದ ಸಾಧನವು ಕಂಡು ಬಂದಿಲ್ಲ: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "ದೋಷ: ಯಾವುದೆ ಸೂಕ್ತವಾದ ಸಾಧನವು ಕಂಡು ಬಂದಿಲ್ಲ."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "ಎಚ್ಚರಿಕೆ: ಸಂಪರ್ಕವು ಸಕ್ರಿಯವಾಗಿಲ್ಲ\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "ದೋಷ: 'con' ಆಜ್ಷೆ '%s' ಎಂಬುದು ಮಾನ್ಯವಾದುದಲ್ಲ."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "ದೋಷ: D-Bus ನೊಂದಿಗೆ ಸಂಪರ್ಕಸಾಧಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "ದೋಷ: ವ್ಯವಸ್ಥೆಯ ಸಿದ್ಧತೆಗಳು ಕಂಡುಬಂದಿಲ್ಲ."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "ದೋಷ: ಬಳಕೆದಾರ ಸಿದ್ಧತೆಗಳು ಕಂಡುಬಂದಿಲ್ಲ."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "ದೋಷ: ಸಂಪರ್ಕಗಳನ್ನು ಪಡೆಯಲಾಗಿಲ್ಲ: ಸಿದ್ಧತೆಗಳು ಚಾಲನೆಯಲ್ಲಿಲ್ಲ."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"ಬಳಕೆ: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "ನಿರ್ವಹಿಸದೆ ಇರುವ"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "ಲಭ್ಯವಿಲ್ಲ"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "ಸಂಪರ್ಕಕಡಿದು ಹೋಗಿದೆ"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ (ಸಿದ್ಧಗೊಳಿಕೆ)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ (ಸಂರಚಿಸುವಿಕೆ)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ (ದೃಢೀಕರಣದ ಅಗತ್ಯವಿದೆ)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ (IP ಸಂರಚನೆಯನ್ನು ಪಡೆಯಲಾಗುತ್ತಿದೆ)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "ಸಂಪರ್ಕಗೊಂಡಿದೆ"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "ಸಂಪರ್ಕ ವಿಫಲಗೊಂಡಿದೆ"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "ಗೊತ್ತಿರದ"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(ಯಾವುದೂ ಇಲ್ಲ)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: IP4 ವಿಳಾಸ 0x%X ಅನ್ನು ಪರಿವರ್ತಿಸುವಲ್ಲಿ ದೋಷ"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, ಫ್ರೀಕ್ವೆ %d MHz, ದರ %d Mb/s, ದೃಢತೆ %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "ತಾತ್ಕಾಲಿಕ"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", ಗೂಢಲಿಪೀಕರಣಗೊಂಡ: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " ಎಂಟರ್ಪೈಸ್"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "ಸಾಧನ"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "ಚಾಲಕ"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(ಗೊತ್ತಿರದ)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "ಸ್ಥಿತಿ"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW ವಿಳಾಸ"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+" ಸಾಮಾರ್ಥ್ಯಗಳು:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "ಕ್ಯಾರಿಯರ್ ಪತ್ತೆ"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "ವೇಗ"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  ವೈರ್ಲೆಸ್‌ ಗುಣಧರ್ಮಗಳು\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP ಗೂಢಲಿಪೀಕರಣ"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA ಗೂಢಲಿಪೀಕರಣ"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 ಗೂಢಲಿಪೀಕರಣ"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP ಸಿಫರ್"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP ಸಿಫರ್"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  ವೈರ್ಲೆಸ್ ನಿಲುಕಣಾ ಬಿಂದುಗಳು %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = ಪ್ರಸಕ್ತ AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  ವೈರ್ಡ್ ಗುಣಧರ್ಮಗಳು\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "ವಾಹಕ(ಕ್ಯಾರಿಯರ್)"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "ಆನ್‌"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "ಆಫ್"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPV4 ಸಿದ್ಧತೆಗಳು:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "ವಿಳಾಸ"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "ಪ್ರಿಫಿಕ್ಸ್"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "ಗೇಟ್‌ವೇ"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "ಸಾಧನಗಳ ಸ್ಥಿತಿ"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "ದೋಷ: '%s' ಆರ್ಗ್ಯುಮೆಂಟ್ ಕಾಣಿಸುತ್ತಿಲ್ಲ."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "ದೋಷ: '%s' ಎಂಬ ಸಾಧನವು ಕಂಡು ಬಂದಿಲ್ಲ."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "ಯಶಸ್ಸು: '%s' ಎಂಬ ಸಾಧನದಿಂದ ಯಶಸ್ವಿಯಾಗಿ ಸಂಪರ್ಕವನ್ನು ಕಡಿದುಹಾಕಲಾಗಿದೆ."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "ದೋಷ: '%s' (%s) ಎಂಬ ಸಾಧನದ ಸಂಪರ್ಕವನ್ನು ಕಡಿದು ಹಾಕುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "ಸಾಧನದ ಸ್ಥಿತಿ: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "ದೋಷ: iface ಅನ್ನು ಸೂಚಿಸಬೇಕು."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi ಸ್ಕ್ಯಾನ್ ಪಟ್ಟಿ"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "ದೋಷ: '%s' ಎಂಬುದು ಒಂದು WiFi ಸಾಧನವಾಗಿಲ್ಲ."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "ಸಾಧನ:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "ದೋಷ: hwaddr ಅನ್ನು ಸೂಚಿಸಬೇಕು."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "ದೋಷ: '%s' ಎಂಬ hwaddr ನ ನಿಲುಕಣಾ ಬಿಂದುವು ಕಾಣಿಸುತ್ತಿಲ್ಲ."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP ನಿಯತಾಂಕಗಳು"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "ಫ್ರೀಕ್ವೆನ್ಸಿ:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "ಕ್ರಮ:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "ತಾತ್ಕಾಲಿಕ"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "ಮೂಲಭೂತ ವ್ಯವಸ್ಥೆ"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "ಗರಿಷ್ಟ ಬಿಟ್ ದರ:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "ದೃಢತೆ:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "ಫ್ಲಾಗ್‌ಗಳು:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "ಗೌಪ್ಯತೆ"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA ಫ್ಲಾಗ್‌ಗಳು:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN ಫ್ಲಾಗ್‌ಗಳು:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "ದೋಷ: '%s' ಎಂಬ 'dev wifi' ಆಜ್ಞೆಯು ಮಾನ್ಯವಾದುದಲ್ಲ."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "ದೋಷ: '%s' ಎಂಬ 'dev' ಆಜ್ಞೆಯು ಮಾನ್ಯವಾದುದಲ್ಲ."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"ಬಳಕೆ: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "ನಿದ್ರಿಸುವ"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "ಸಂಪರ್ಕ ಕಲ್ಪಿಸಲಾಗುತ್ತಿದೆ"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "ಸಕ್ರಿಯಗೊಂಡ"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "ಅಶಕ್ತಗೊಂಡ"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "NetworkManager ಸ್ಥಿತಿ"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM ಚಾಲನೆಯಲ್ಲಿದೆ:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "ಚಾಲನೆಯಲ್ಲಿದೆ"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "ಚಾಲನೆಯಲ್ಲಿಲ್ಲ"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM ಸ್ಥಿತಿ:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM ವೈರ್ಲೆಸ್‌ ಯಂತ್ರಾಂಶ:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM ಯಂತ್ರಾಂಶ:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN ಯಂತ್ರಾಂಶ:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "ದೋಷ: ಅಮಾನ್ಯವಾದ 'wifi' ನಿಯತಾಂಕ: '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "ದೋಷ: ಅಮಾನ್ಯವಾದ 'wwan' ರ ನಿಯತಾಂಕ: '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "ದೋಷ: '%s' ಎಂಬ 'nm' ಆಜ್ಞೆಯು ಮಾನ್ಯವಾದುದಲ್ಲ."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"ಬಳಕೆ: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "'%s' ಎಂಬ ವಸ್ತುವಿನ ಬಗೆಗೆ ತಿಳಿದಿಲ್ಲ, 'nmcli help' ಅನ್ನು ಪ್ರಯತ್ನಿಸಿ."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli ಉಪಕರಣ, ಆವೃತ್ತಿ %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "'%s' ಎಂಬ ಆಯ್ಕೆಯ ಬಗೆಗೆ ತಿಳಿದಿಲ್ಲ, 'nmcli -help' ಅನ್ನು ಪ್ರಯತ್ನಿಸಿ."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d ಎಂಬ ಸಂಕೇತವು ಕಂಡುಬಂದಿದೆ,  ಮುಚ್ಚಲಾಗುತ್ತಿದೆ......"
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "ದೋಷ: NetworkManager ನೊಂದಿಗೆ ಸಂಪರ್ಕಸಾಧಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "ಯಶಸ್ವಿಯಾಗಿದೆ"
+
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -103,8 +948,9 @@ msgstr "IV ಅನ್ನು ಶೇಖರಿಸಿಡಲು ಸಾಕಷ್ಟು
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV ಯು ಹೆಕ್ಸಾ-ದಶಮಾಂಶ ಅಲ್ಲದ ಅಂಕೆಗಳನ್ನು ಹೊಂದಿದೆ."
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "ಖಾಸಗಿ ಕೀಲಿ ಸಿಫರ್ '%s' ತಿಳಿದಿಲ್ಲ."
@@ -124,72 +970,106 @@ msgstr "ಖಾಸಗಿ ಕೀಲಿಯ ಬಗೆಯನ್ನು ನಿರ್ಧ
 msgid "Not enough memory to store decrypted private key."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲಾದ ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಶೇಖರಿಸಿಡಲು ಸಾಕಷ್ಟು ಮೆಮೊರಿ ಇಲ್ಲ."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "ಕ್ರಿಪ್ಟೋ ಎಂಜಿನ್ ಅನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "MD5 ಎಂಜಿನ್ ಅನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "ಅಮಾನ್ಯವಾದ IV ಗಾತ್ರ (ಕನಿಷ್ಟ %zd ಇರಬೇಕು)."
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲಾದ ಬಫರಿಗಾಗಿ ಸಾಕಷ್ಟು ಮೆಮೊರಿ ಇಲ್ಲ."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "ಡೀಕ್ರಿಪ್ಸ್ ಮಾಡುವ ಸಿಫರ್ ಸಂದರ್ಭವನ್ನು ಆರಂಭಗೊಳಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲು ಸಿಮಿಟ್ರಿಕ್ ಕೀಲಿಯನ್ನು ಹೊಂದಿಸಲು ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲು IV ಅನ್ನು ಹೊಂದಿಸಲು ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: ಅನಿರೀಕ್ಷಿತವಾದ ಪ್ಯಾಡಿಂಗ್ ಗಾತ್ರ"
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲು ಮೆಮೊರಿಯನ್ನು ನಿಯೋಜಸಿಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "ಗೂಢಲಿಪೀಕರಣ ಸಿಫರ್ ಸಂದರ್ಭವನ್ನು ಆರಂಭಗೊಳಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲು ಸಿಮಿಟ್ರಿಕ್ ಕೀಲಿಯನ್ನು ಹೊಂದಿಸಲು ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲು IV ಅನ್ನು ಹೊಂದಿಸಲು ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಗೂಢಲಿಪೀಕರಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "ಪ್ರಮಾಣಪತ್ರ ದತ್ತಾಂಶವನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ದೋಷ ಉಂಟಾಗಿದೆ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "ಪ್ರಮಾಣಪತ್ರವನ್ನು ಡೀಕೋಡ್ ಮಾಡಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "PKCS#12 ಡೀಕೋಡರ್ ಅನ್ನು ಆರಂಭಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "PKCS#12 ಕಡತವನ್ನು ಡೀಕೋಡ್ ಮಾಡಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12 ಕಡತವನ್ನು ಪರಿಶೀಲಿಸಲಾಗಿಲ್ಲ: %s"
 
-#: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "ಕ್ರಿಪ್ಟೊ ಎಂಜಿನ್ ಅನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %d."
@@ -199,105 +1079,191 @@ msgstr "ಕ್ರಿಪ್ಟೊ ಎಂಜಿನ್ ಅನ್ನು ಆರಂಭ
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "MD5 ಸಂದರ್ಭವನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %d."
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "ಅಮಾನ್ಯವಾದ IV ಗಾತ್ರ (ಕನಿಷ್ಟ %d ಇರಬೇಕು)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "ಡೀಕ್ರಪ್ಟ್ ಮಾಡಲಾಗುವ ಸಿಫರ್ ಜಾಗವನ್ನು ಆರಂಭಿಸಲು ವಿಫಲಗೊಂಡಿದೆ."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲು ಸಿಮಿಟ್ರಿಕ್ ಕೀಲಿಯನ್ನು ಹೊಂದಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲು IV ಅನ್ನು ಹೊಂದಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವ ಸನ್ನಿವೇಶವನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr ""
+"ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡಲಾದ ದತ್ತಾಂಶದ ಗಾತ್ರವು "
+"ಬಹಳ ದೊಡ್ಡದಾಗಿದೆ."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಡೀಕ್ರಿಪ್ಟ್ ಮಾಡುವಿಕೆಯನ್ನು ಪೂರ್ಣಗೊಳಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲಾಗುವ ಸಿಫರ್ ಜಾಗವನ್ನು ಆರಂಭಿಸಲು ವಿಫಲಗೊಂಡಿದೆ."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲು ಸಿಮಿಟ್ರಿಕ್ ಕೀಲಿಯನ್ನು ಹೊಂದಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲು IV ಅನ್ನು ಹೊಂದಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸುವ ಸನ್ನಿವೇಶವನ್ನು ಆರಂಭಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸುವಲ್ಲಿ ವಿಫಲಗೊಂಡಿದೆ: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "ಗೂಢಲಿಪೀಕರಿಸಲು ಅನಿರೀಕ್ಷಿತವಾದ ದತ್ತಾಂಶದ ಮೊತ್ತ."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "ಪ್ರಮಾಣಪತ್ರವನ್ನು ಡೀಕೋಡ್ ಮಾಡಲು ಸಾಧ್ಯವಾಗಲಿಲ್ಲ: %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "ಗುಪ್ತಪದವನ್ನು UCS2 ಗೆ ಬದಲಾಯಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12 ಡೀಕೋಡರ್ ಅನ್ನು ಆರಂಭಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12 ಕಡತವನ್ನು ಡೀಕೋಡ್ ಮಾಡಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12 ಕಡತವನ್ನು ಖಚಿತಪಡಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %d"
 
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:458
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "ಮನಸ್ಸಿಗೆ ಬಂದ ದತ್ತಾಂಶವನ್ನು ಉತ್ಪಾದಿಸಲಾಗಲಿಲ್ಲ."
+
+#: ../libnm-util/nm-utils.c:1818
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "ಖಾಸಗಿ ಕೀಲಿಯನ್ನು ಗೂಢಲಿಪೀಕರಿಸಲು ಸಾಕಷ್ಟು ಮೆಮೊರಿ ಇಲ್ಲ."
+
+#: ../libnm-util/nm-utils.c:1928
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM ಕಡತ ರಚನೆಗೆ ಮೆಮೊರಿಯನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../libnm-util/nm-utils.c:1940
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "IV ಅನ್ನು PEM ಕಡತಕ್ಕೆ ಬರೆಯಲು ಮೆಮೊರಿಯನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../libnm-util/nm-utils.c:1952
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr ""
+"ಗೂಢಲಿಪೀಕರಿಸಲಾದ ಕೀಲಿಯನ್ನು PEM ಕಡತಕ್ಕೆ ಬರೆಯಲು ಮೆಮೊರಿಯನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../libnm-util/nm-utils.c:1971
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM ಕಡತ ದತ್ತಾಂಶಕ್ಕಾಗಿ ಮೆಮೊರಿಯನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ."
+
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "ನೆಟ್‌ಲಿಂಕ್ ಸಂದೇಶವನ್ನು ಸಂಸ್ಕರಿಸುವಲ್ಲಿ ದೋಷ ಉಂಟಾಗಿದೆ: %s"
 
-#: ../src/nm-netlink-monitor.c:255
+#: ../src/nm-netlink-monitor.c:259
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್  ಹ್ಯಾಂಡಲ್ ಅನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+msgstr ""
+"ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್  ಹ್ಯಾಂಡಲ್ ಅನ್ನು ನಿಯೋಜಿಸಲು "
+"ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
 
-#: ../src/nm-netlink-monitor.c:265
+#: ../src/nm-netlink-monitor.c:269
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್‌ನೊಂದಿಗೆ ಸಂಪರ್ಕ ಜೋಡಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+msgstr ""
+"ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್‌ನೊಂದಿಗೆ ಸಂಪರ್ಕ ಜೋಡಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %"
+"s"
 
-#: ../src/nm-netlink-monitor.c:273
+#: ../src/nm-netlink-monitor.c:277
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್ ಗುಂಪನ್ನು ಸೇರಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+msgstr ""
+"ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್ ಗುಂಪನ್ನು ಸೇರಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
 
-#: ../src/nm-netlink-monitor.c:281
+#: ../src/nm-netlink-monitor.c:285
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್ ಕೊಂಡಿ ಕ್ಯಾಶೆಯನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+msgstr ""
+"ಕೊಂಡಿಯ ಸ್ಥಿತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ನಡೆಸಲು ನೆಟ್‌ಲಿಂಕ್ ಕೊಂಡಿ ಕ್ಯಾಶೆಯನ್ನು ನಿಯೋಜಿಸಲು "
+"ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
+msgid "error occurred while waiting for data on socket"
+msgstr "ಸಾಕೆಟ್‌ನಲ್ಲಿ ದತ್ತಾಂಶಕ್ಕಾಗಿ ಕಾಯುವಾಗ ದೋಷವು ಎದುರಾಗಿದೆ"
 
-#: ../src/nm-netlink-monitor.c:422
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "ಕೊಂಡಿ ಕ್ಯಾಶೆಯನ್ನು ಅಪ್‌ಡೇಟ್ ಮಾಡುವಾಗ ದೋಷ ಉಂಟಾಗಿದೆ: %s"
 
-#: ../src/nm-netlink-monitor.c:488
-msgid "error occurred while waiting for data on socket"
-msgstr "ಸಾಕೆಟ್‌ನಲ್ಲಿ ದತ್ತಾಂಶಕ್ಕಾಗಿ ಕಾಯುವಾಗ ದೋಷವು ಎದುರಾಗಿದೆ"
-
-#: ../src/NetworkManager.c:329
+#: ../src/main.c:498
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr "ಅಮಾನ್ಯವಾದ ಆಯ್ಕೆ.  ಮಾನ್ಯವಾದ ಆಯ್ಕೆಗಳಿಗಾಗಿ ದಯವಿಟ್ಟು --help ಅನ್ನು ನೋಡಿ.\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:97
+#: ../src/main.c:558
+#, c-format
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s.  ಮಾನ್ಯವಾದ ಆಯ್ಕೆಗಳಿಗಾಗಿ ದಯವಿಟ್ಟು --help ಅನ್ನು ನೋಡಿ.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
 msgid "# Created by NetworkManager\n"
 msgstr "# NetworkManager ನಿಂದ ನಿರ್ಮಿಸಲಾಗಿದೆ\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:103
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -306,28 +1272,97 @@ msgstr ""
 "# %s ಇಂದ ಒಗ್ಗೂಡಿಸಲಾಗಿದೆ\n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:255
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "ಬಳಸಬಹುದಾದ ಯಾವುದೆ DHCP ಕ್ಲೈಂಟ್ ಕಂಡುಬಂದಿಲ್ಲ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "'dhclient' ಕಂಡು ಬಂದಿದೆ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "'dhcpcd' ಕಂಡು ಬಂದಿದೆ."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "ಬೆಂಬಲವಿರದ DHCP ಕ್ಲೈಂಟ್ '%s'"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "ನೆಟ್‌ಲಿಂಕ್ ಹ್ಯಾಂಡಲ್ ಅನ್ನು ನಿಯೋಜಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:209
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "ನೆಟ್‌ಲಿಂಕ್‌ನೊಂದಿಗೆ ಸಂಪರ್ಕ ಜೋಡಿಸಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:306
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "ನೆಟ್‌ಲಿಂಕ್ ಗುಂಪನ್ನು ಸೇರಲು ಸಾಧ್ಯವಾಗಿಲ್ಲ: %s"
+
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "ಗೊತ್ತಿರದ ದಾಖಲೆ ಮಟ್ಟ '%s'"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "ಗೊತ್ತಿರದ ದಾಖಲೆ ಡೊಮೈನ್ '%s'"
+
+#: ../src/named-manager/nm-named-manager.c:314
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr "ಸೂಚನೆ: libc ಪರಿಹಾರಕವು(ರಿಸಾಲ್ವರ್) ೩ ನಾಮಪರಿಚಾರಕಗಳಿಗಿಂತ ಹೆಚ್ಚಿನವುಗಳನ್ನು ಬೆಂಬಲಿಸುವುದಿಲ್ಲ."
+msgstr ""
+"ಸೂಚನೆ: libc ಪರಿಹಾರಕವು(ರಿಸಾಲ್ವರ್) ೩ ನಾಮಪರಿಚಾರಕಗಳಿಗಿಂತ ಹೆಚ್ಚಿನವುಗಳನ್ನು "
+"ಬೆಂಬಲಿಸುವುದಿಲ್ಲ."
 
-#: ../src/named-manager/nm-named-manager.c:257
+#: ../src/named-manager/nm-named-manager.c:316
 msgid "The nameservers listed below may not be recognized."
 msgstr "ಈ ಕೆಳಗೆ ಸೂಚಿಸಲಾದ ನಾಮಪರಿಚಾರಕಗಳನ್ನು ಗುರುತಿಸಲಾಗಿಲ್ಲ."
 
-#: ../src/system-settings/nm-default-wired-connection.c:182
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
 msgstr "ಸ್ವಯಂ %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2168
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3229
 msgid "System"
-msgstr "ಗಣಕ"
+msgstr "ವ್ಯವಸ್ಥೆ"
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "ಒಂದು ಸಂರಕ್ಷಿತವಾದ WiFi ಜಾಲಬಂಧದ ಮೂಲಕ ಸಂಪರ್ಕ ಸಾಧಿಸುವಿಕೆ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "ಒಂದು ಮುಕ್ತವಾದ WiFi ಜಾಲಬಂಧದ ಮೂಲಕ ಸಂಪರ್ಕ ಸಾಧಿಸುವಿಕೆ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "ಸ್ಥಿರ ವ್ಯವಸ್ಥೆಯ ಆತಿಥೇಯ ಹೆಸರನ್ನು ಮಾರ್ಪಡಿಸಿ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
 msgid "Modify system connections"
 msgstr "ವ್ಯವಸ್ಥೆಯ ಸಂಪರ್ಕಗಳನ್ನು ಮಾರ್ಪಡಿಸು"
 
-#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
 msgid "System policy prevents modification of system settings"
 msgstr "ವ್ಯವಸ್ಥೆಯ ಸಂಪರ್ಕಗಳನ್ನು ಮಾರ್ಪಡಿಸದಂತೆ ವ್ಯವಸ್ಥೆಯ ನಿಯಮಗಳು ತಡೆಯುತ್ತಿವೆ"
 
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "ಸ್ಥಿರ ವ್ಯವಸ್ಥೆಯ ಆತಿಥೇಯ ಹೆಸರನ್ನು ಮಾರ್ಪಡಿಸದಂತೆ ವ್ಯವಸ್ಥೆಯ ನಿಯಮಗಳು ತಡೆಯುತ್ತವೆ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr ""
+"ಒಂದು ಸಂರಕ್ಷಿತವಾದ WiFi ಜಾಲಬಂಧದ ಮೂಲಕ ಸಂಪರ್ಕ ಸಾಧಿಸದಂತೆ ವ್ಯವಸ್ಥೆಯ ನಿಯಮಗಳು ತಡೆಯುತ್ತವೆ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr ""
+"ಒಂದು ಮುಕ್ತವಾದ WiFi ಜಾಲಬಂಧದ ಮೂಲಕ ಸಂಪರ್ಕ ಸಾಧಿಸದಂತೆ ವ್ಯವಸ್ಥೆಯ ನಿಯಮಗಳು ತಡೆಯುತ್ತವೆ"
diff --git a/po/ml.po b/po/ml.po
new file mode 100644
index 0000000..d5728ea
--- /dev/null
+++ b/po/ml.po
@@ -0,0 +1,1320 @@
+# translation of NetworkManager.master_upstream.ml.po to
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the PACKAGE package.
+# Ani Peter <apeter@redhat.com>, 2010
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: NetworkManager.master_upstream.ml\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-03-23 03:25+0000\n"
+"PO-Revision-Date: 2010-03-23 17:04+0530\n"
+"Last-Translator: Ani Peter <apeter@redhat.com> | അനി പീറ്റര്‍\n"
+"Language-Team:  Swathantra Malayalam Computing | സ്വതന്ത്ര മലയാളം കമ്പ്യൂട്ടിങ് <smc-discuss@googlegroups.com>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.11.4\n"
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"ഉപയോഗിക്കേണ്ട വിധം: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "കണക്ഷനുകള്‍"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "തരം"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "പേരു്"
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "സിസ്റ്റം കണക്ഷനുകള്‍:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "ഉപയോക്താവിനുള്ള കണക്ഷനുകള്‍:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "പിശക്: %s ആര്‍ഗ്യുമെന്റ് ലഭ്യമല്ല."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "പിശക്: %s - ഇത്തരം കണക്ഷന്‍ ലഭ്യമല്ല."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "സിസ്റ്റത്തിലുള്ള കണക്ഷനുകള്‍"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "ഉപയോക്താവിനുള്ള കണക്ഷനുകള്‍"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "അപരിചിതമായ പരാമീറ്റര്‍: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "പിശക്: ശരിയായ പരാമീറ്റര്‍ നല്‍കിയിട്ടില്ല."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ഉവ്വു്"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "ഇല്ല"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "സജീവമായ കണക്ഷനുകള്‍"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "സ്വതവേയുള്ള"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "സര്‍വീസ്"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "ഡിവൈസുകള്‍"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "ഡിവൈസ് '%s'-ല്‍ സജീവമായ കണക്ഷന്‍ ലഭ്യമല്ല"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "സജീവമായ കണക്ഷന്‍ അല്ലെങ്കില്‍ ഡിവൈസ് ലഭ്യമല്ല"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "സജീവമാക്കുന്നു"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "സജീവമാക്കിയിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "അപരിചിതം"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "വിപിഎന്‍ കണക്ട് ചെയ്യുന്നു (തയ്യാറാകുക)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "വിപിഎന്‍ കണക്ട് ചെയ്യുന്നു (ആധികാരികത ഉറപ്പാക്കേണ്ടതുണ്ടു്)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "വിപിഎന്‍ കണക്ട് ചെയ്യുന്നു"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "വിപിഎന്‍ കണക്ട് ചെയ്യുന്നു (ഐപി ക്രമീകരണം ലഭ്യമാക്കുന്നു)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "വിപിഎന്‍ കണക്ട് ചെയ്തിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "വിപിഎന്‍ കണക്ഷന്‍ പരാജയപ്പെട്ടു"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "വിപിഎന്‍ വിഛേദിച്ചിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "അപരിചിതമായ കാരണം"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "ഒന്നുമില്ല"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "ഉപയോക്താവു് വിഛേദിച്ചിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "അടിസ്ഥാന നെറ്റ്‌വര്‍ക്ക് കണക്ഷന്‍ തടസ്സപ്പെടുത്തിയിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "വിപിഎന്‍ സര്‍വീസ് അപ്രതീക്ഷിതമായി നിര്‍ത്തിയിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "വിപിഎന്‍ സര്‍വീസ് തെറ്റായ ക്രമീകരണം തിരികെ നല്‍കിയിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "കണക്ഷനുള്ള ശ്രമം കഴിഞ്ഞിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "വിപിഎന്‍ സര്‍വീസ് സമയത്തിനു് ആരംഭിച്ചില്ല"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "വിപിഎന്‍ സര്‍വീസ് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "ശരിയായ വിപിഎന്‍ രഹസ്യങ്ങള്‍ ലഭ്യമല്ല"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "തെറ്റായ വിപിഎന്‍ രഹസ്യങ്ങള്‍"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "കണക്ഷന്‍ നീക്കം ചെയ്തിരിക്കുന്നു"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "അവസ്ഥ: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "കണക്ഷന്‍ സജീവമാക്കിയിരിക്കുന്നു\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "പിശക്: കണക്ഷന്‍ സജീവമാക്കല്‍ പരാജയപ്പെട്ടു."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "അവസ്ഥ: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "പിശക്: കണക്ഷന്‍ സജീവമാക്കല്‍ പരാജയപ്പെട്ടു: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "പിശക്: സമയപരിധി %d നിമിഷത്തിന്റെ കാലാവധി കഴിഞ്ഞിരിക്കുന്നു."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "പിശക്: കണക്ഷന്‍ സജീവമാക്കല്‍ പരാജയപ്പെട്ടു: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "പിശക്: '%s'-നുള്ള സജീവമായ കണക്ഷന്‍ ലഭ്യമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "സജീവമായ കണക്ഷന്റെ അവസ്ഥ: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "സജീവമായ കണക്ഷന്‍ പാഥ്: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "പിശക്: അപരിചിതമായ കണക്ഷന്‍: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "പിശഖ്: സമയപരിധിയുടെ മൂല്ല്യം '%s' തെറ്റാണു്."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "പിശക്: id അല്ലെങ്കില്‍ uuid വ്യക്തമാക്കേണ്ടതുണ്ടു്."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "പിശക്: ഉചിതമായ ഡിവൈസ് ലഭ്യമായില്ല: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "പിശക്: ഉചിതമായ ഡിവൈസ് ലഭ്യമായില്ല."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "മുന്നറിയിപ്പു്: കണക്ഷന്‍ സജീവമല്ല\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "പിശക്: 'con' കമാന്‍ഡ് '%s' ശരിയല്ല."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "പിശക്: D-Bus-ലേക്കു് കണക്ട് ചെയ്യുവാന്‍ സാധ്യമായില്ല."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "പിശക്: സിസ്റ്റം സജ്ജീകരണങ്ങള്‍ ലഭ്യമാക്കവാന്‍ സാധ്യമായില്ല."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "പിശക്: ഉപയോക്താവിനുള്ള സജ്ജീകരണങ്ങള്‍ ലഭ്യമാക്കുവാന്‍ സാധ്യമായില്ല."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "പിശക്: കണക്ഷനുകള്‍ ലഭ്യമാക്കുവാന്‍ സാധ്യമല്ല: സജ്ജീകരണങ്ങള്‍ക്കുള്ള സര്‍വീസുകള്‍ പ്രവര്‍ത്തിക്കുന്നില്ല."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"ഉപയോഗിക്കേണ്ട വിധം: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "കൈകാര്യം ചെയ്തിട്ടില്ലാത്തതു്"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "ലഭ്യമല്ലാത്തതു്"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "വിഛേദിച്ചിരിക്കുന്നു"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "കണക്ട് ചെയ്യുന്നു (തയ്യാറാക്കുക)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "കണക്ട് ചെയ്യുന്നു (ക്രമീകരിക്കുന്നു)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "കണക്ട് ചെയ്യുന്നു (ആധികാരികത ഉറപ്പാക്കേണ്ടതുണ്ടു്)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "കണക്ട് ചെയ്യുന്നു (ഐപി ക്രമീകരണം ലഭ്യമാക്കുന്നു)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "കണക്ട് ചെയ്തിരിക്കുന്നു"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "കണക്ഷന്‍ പരാജയപ്പെട്ടു"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "അപരിചിതം"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(ഒന്നുമില്ല)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s:IP4 വിലാസം 0x%X വേര്‍തിരിക്കുന്നതില്‍ പിശക്"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Freq %d MHz, Rate %d Mb/s, അളവു് %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "അഡ്-ഹോക്"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", എന്‍ക്രിപ്റ്റ് ചെയ്തിരിക്കുന്നു: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr "എന്റര്‍പ്രൈസ്"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "ഡിവൈസ്"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "ഡ്രൈവര്‍"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(അപരിചിതം)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "അവസ്ഥ"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW വിലാസം"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  വിശേഷതകള്‍:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "കാരിയര്‍ ഡിറ്റെക്ട്"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "വേഗത"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  വയര്‍ലെസ്സ് വിശേഷതകള്‍\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP എന്‍ക്രിപ്ഷന്‍"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA എന്‍ക്രിപ്ഷന്‍"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 എന്‍ക്രിപ്ഷന്‍"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP സിഫര്‍"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP സിഫര്‍"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  വയര്‍ലെസ്സ് ആക്സെസ്സ് പോയിന്റുകള്‍ %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = current AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  വയര്‍ഡ് വിശേഷതകള്‍\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "കാരിയര്‍"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "ഓണ്‍"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "ഓഫ്"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4 സജ്ജീകരണങ്ങള്‍:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "വിലാസം"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "പ്രീഫിക്സ്"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "ഗേറ്റ്‌വേ"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "ഡിവൈസുകളുടെ അവസ്ഥ"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "പിശക്: '%s' ആര്‍ഗ്യുമെന്റ് ലഭ്യമല്ല."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "പിശക്: ഡിവൈസ് '%s' ലഭ്യമായില്ല."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "വിജയിച്ചു: ഡിവൈസ് '%s' വിജയകരമായി വിഛേദിച്ചിരിക്കുന്നു."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "പിശക്: ഡിവൈസ് '%s' (%s) വിഛേദിക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "ഡിവൈസിന്റെ അവസ്ഥ: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "പിശക്: iface നല്‍കേണ്ടതുണ്ടു്."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi പരിശോധന പട്ടിക"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "പിശക്: '%s' ഡിവൈസ് ഒരു വൈഫൈ ഡിവൈസല്ല."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "ഡിവൈസ്:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "പിശക്: hwaddr വ്യക്തമാക്കേണ്ടതുണ്ടു്."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "പിശക്: hwaddr '%s'-നുള്ള ആക്സെസ്സ് പോയിന്റ് ലഭ്യമല്ല."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "എപി പരാമീറ്ററുകള്‍"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "ഫ്രീക്വന്‍സി:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "മോഡ്:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "ആഡ്-ഹോക്"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "ഇന്‍ഫ്രാസ്ട്രക്ചര്‍"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "ഏറ്റവും കൂടിയ ബിറ്റ്റേറ്റ്:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "അളവു്:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "ഫ്ലാഗുകള്‍:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "സ്വകാര്യത"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA ഫ്ലാഗുകള്‍:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN ഫ്ലാഗുകള്‍:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "പിശക്: 'dev wifi' കമാന്‍ഡ് '%s' ശരിയല്ല."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "പിശക്: 'dev' കമാന്‍ഡ് '%s' ശരിയല്ല."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"ഉപയോഗിക്കേണ്ട വിധം: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "asleep"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "കണക്ട് ചെയ്യുന്നു"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "enabled"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "disabled"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "നെറ്റ്‌വര്‍ക്ക്മാനേജറിന്റെ അവസ്ഥ"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM പ്രവര്‍ത്തനത്തില്‍:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "പ്രവര്‍ത്തനത്തില്‍"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "പ്രവര്‍ത്തനത്തിലില്ല"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM അവസ്ഥ:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM വയര്‍ലെസ്സ് ഹാര്‍ഡ്‌വെയര്‍:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM വയര്‍ലെസ്സ്:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN ഹാര്‍ഡ്‌വെയര്‍:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "പിശക്: തെറ്റായ 'wifi' പരാമീറ്റര്‍: '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "പിശക്: തെറ്റായ 'wwan' പരാമീറ്റര്‍: '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "പിശക്: 'nm' കമാന്‍ഡ് '%s' ശരിയല്ല."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"ഉപയോഗിക്കേണ്ട വിധം: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "'%s' ഐഛികം അപരിചിതം, 'nmcli help' ശ്രമിക്കുക."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli പ്രയോഗം, പതിപ്പു് %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "'%s' ഐഛികം അപരിചിതം, 'nmcli -help' ശ്രമിക്കുക."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d സിഗ്നല്‍ ലഭ്യമായി, അടച്ചു പൂട്ടുന്നു..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "പിശക്: നെറ്റ്‌വര്‍ക്ക്മാനേജറിലേക്കു് കണക്ട് ചെയ്യുവാന്‍ സാധ്യമായില്ല."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "വിജയിച്ചു"
+
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "PEM കീ ഫയലിനു് അവസാനമുള്ള റ്റാഗ് '%s' ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr "ഒരു PEM സ്വകാര്യ കീ ഫയല്‍ പോലെയല്ലിതു്."
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr " ‌PEM ഫയല്‍ ഡേറ്റാ സൂക്ഷിക്കുന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr "തെറ്റായ PEM ഫയല്‍: Proc-രീതിയിലുള്ളതു് ആദ്യത്തെ റ്റാഗ് അല്ല."
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr "തെറ്റായ PEM ഫയല്‍: അപരിചിതമായ Proc-രീതിയിലുള്ള റ്റാഗ് '%s'."
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr "തെറ്റായ PEM ഫയല്‍: DEK-Info രണ്ടാത്തെ റ്റാഗ് അല്ല."
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr "തെറ്റായ PEM ഫയല്‍: DEK-Info റ്റാഗില്‍ IV ലഭ്യമായില്ല."
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr "തെറ്റായ PEM ഫയല്‍: DEK-Info റ്റാഗില്‍ IV-ന്റെ ശൈലി തെറ്റാണു്."
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr "തെറ്റായ PEM ഫയല്‍: അപരിചിതമായ സ്വകാര്യ കീ സിഫര്‍ '%s'."
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "സ്വകാര്യ കീ ഡീകോഡ് ചെയ്യുവാന്‍ സാധ്യമല്ല."
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "PEM സര്‍ട്ടിഫിക്കേറ്റ് '%s'-നു് ഒടുവിലുള്ള റ്റാഗ് '%s' ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "സര്‍ട്ടിഫിക്കേറ്റ് ഡീകോഡ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "‌സര്‍ട്ടിഫിക്കേറ്റ് ഡേറ്റാ സൂക്ഷിക്കുന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "ഫയല്‍ ഡേറ്റാ സൂക്ഷിക്കുന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV-ന്റെ വ്യാപ്തി ഈവന്‍ അക്കത്തിലുള്ള ബൈറ്റുകളായിരിക്കണം."
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "IV സൂക്ഷിക്കുന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV-ല്‍ നോണ്‍-ഹെക്സാഡെസിമല്‍ അക്കങ്ങളുണ്ടു്."
+
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "സ്വകാര്യ കീ സിഫര്‍ '%s' അപരിചിതം."
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "സ്വകാര്യ കീ ഡീക്രിപ്റ്റ് ചെയ്യന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "സ്വകാര്യ കീ രീതി കണ്ടുപിടിക്കുവാന്‍ സാധ്യമല്ല."
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "ഡീക്രിപ്റ്റ് ചെയ്ത സ്വകാര്യ കീ സൂക്ഷിക്കുന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "ക്രിപ്റ്റോ എഞ്ചില്‍ ആരംഭിക്കുന്നതില്‍ പരാജയം."
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "MD5 എഞ്ചില്‍ ആരംഭിക്കുവാന്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "തെറ്റായ IV വ്യാപ്തി (കുറഞ്ഞതു് %zd ആയിരിക്കണം)"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "ഡീക്രിപ്റ്റ് ചെയ്ത കീ ബഫറിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "ഡീക്രിപ്ഷന്‍ സിഫര്‍ കോണ്‍ടെക്സ്റ്റ് ആരംഭിക്കുന്നതില്‍ പരാജയം: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "ഡീക്രിപ്ഷനുള്ള സിമ്മെട്രിക് കീ സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "ഡീക്രിപ്ഷനുള്ള IV സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "സ്വകാര്യ കീ ഡീക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "സ്വകാര്യ കീ ഡീക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു: അപ്രതീക്ഷിതമായ പാഢിങ് നീളം."
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "സ്വകാര്യ കീ ഡീക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "എന്‍ക്രിപ്റ്റിങിനുള്ള മെമ്മറി അനുവദിക്കുന്നതില്‍ പരാജയപ്പെട്ടു,"
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "എന്‍ക്രിപ്ഷന്‍ സിഫര്‍ കോണ്‍ടെക്സ്റ്റ് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "എന്‍ക്രിപ്ഷനുള്ള സിമ്മെട്രിക് കീ സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "എന്‍ക്രിപ്ഷനുള്ള IV സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "ഡേറ്റാ എന്‍ക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "സര്‍ട്ടിഫിക്കേറ്റ് ഡേറ്റാ ആരംഭിക്കുന്നതില്‍ പിശക്: %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "സര്‍ട്ടിഫിക്കേറ്റ് ഡീകോഡ് ചെയ്യുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "PKCS#12 ഡീകോഡര്‍ ആരംഭിക്കുവാന്‍ സാധ്യമായില്ല: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "PKCS#12 ഫയല്‍ ഡീകോഡ് ചെയ്യുവാന്‍ സാധ്യമായില്ല: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "PKCS#12 ഫയല്‍ ഉറപ്പാക്കുവാന്‍ സാധ്യമായില്ല: %s"
+
+#: ../libnm-util/crypto_nss.c:56
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "ക്രിപ്റ്റോ എഞ്ചിന്‍ ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %d."
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "MD5 കോണ്‍ടെക്സ്റ്റ് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %d."
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "തെറ്റായ IV നീളം (കുറഞ്ഞതു് %d ആയിരിക്കണം)."
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "ഡീക്രിപ്ഷന്‍ സിഫര്‍ സ്ലോട്ട് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "ഡീക്രിപ്ഷനുള്ള സിമ്മെട്രിക് കീ സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "ഡീക്രിപ്ഷനായി IV സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "ഡീക്രിപ്ഷന്‍ കോണ്‍ടെക്സ്റ്റ് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "സ്വകാര്യ കീ ഡീക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു: %d."
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "സ്വകാര്യ കീ ഡീക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു: ഡീക്രിപ്റ്റ് ചെയ്ത ഡേറ്റ വളരെ വലുതാണു്."
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "സ്വകാര്യ കീയുടെ ‍ഡീക്രിപ്ഷന്‍ ഉറപ്പാക്കുന്നതില്‍ പരാജയപ്പെട്ടു: %d."
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "എന്‍ക്രിപ്ഷന്‍ സിഫര്‍ സ്ലോട്ട് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "എന്‍ക്രിപ്ഷനുള്ള സിമ്മെട്രിക് കീ സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "എന്‍ക്രിപ്ഷനുള്ള IV കീ സജ്ജമാക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "എന്‍ക്രിപ്ഷന്‍ കോണ്‍ടെക്സ്റ്റ് ആരംഭിക്കുന്നതില്‍ പരാജയപ്പെട്ടു."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "എന്‍ക്രിപ്റ്റ് ചെയ്യുന്നതില്‍ പരാജയപ്പെട്ടു: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "എന്‍ക്രിപ്റ്റ് ചെയ്തതിനു് ശേഷം അപ്രതീക്ഷിതമായ ഡേറ്റാ"
+
+#: ../libnm-util/crypto_nss.c:447
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "സര്‍ട്ടിഫിക്കേറ്റ് ഡീകോഡ് ചെയ്യുവാന്‍ സാധ്യമായില്ല: %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "രഹസ്യവാക്ക് UCS2-ലേക്ക് വേര്‍തിരിക്കുവാന്‍ സാധ്യമായില്ല: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "PKCS#12 ഡീകോഡര്‍ ആരംഭിക്കുവാന്‍ സാധ്യമായില്ല: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "PKCS#12 ഫയല്‍ ഡീകോഡ് ചെയ്യുവാന്‍ സാധ്യമായില്ല: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "PKCS#12 ഫയല്‍ ഉറപ്പാക്കുവാന്‍ സാധ്യമായില്ല: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "വേഗത്തില്‍ ഡേറ്റാ തയ്യാറാക്കുവാന്‍ സാധ്യമായില്ല."
+
+#: ../libnm-util/nm-utils.c:1802
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "എന്‍ക്രിപ്ഷന്‍ കീ തയ്യാറാക്കുന്നതിനാവശ്യമായ മെമ്മറി ലഭ്യമല്ല."
+
+#: ../libnm-util/nm-utils.c:1912
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM ഫയല്‍ ഉണ്ടാക്കുന്നതിനുള്ള മെമ്മറി അനുവദിക്കുവാന്‍ സാധ്യമായില്ല."
+
+#: ../libnm-util/nm-utils.c:1924
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM ഫയലിലേക്ക് IV സൂക്ഷിക്കുന്നതിനാവശ്യമുള്ള മെമ്മറി അനുവദിക്കുവാന്‍ സാധ്യമായില്ല."
+
+#: ../libnm-util/nm-utils.c:1936
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM ഫയലിലേക്ക് എന്‍ക്രിപ്റ്റ് ചെയ്ത കീ സൂക്ഷിക്കുന്നതിനുള്ള മെമ്മറി അനുവദിക്കുവാന്‍ സാധ്യമായില്ല."
+
+#: ../libnm-util/nm-utils.c:1955
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM ഫയല്‍ ഡേറ്റായ്ക്കുള്ള മെമ്മറി അനുവദിക്കുവാന്‍ സാധ്യമായില്ല."
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "നെറ്റ്ലിങ്ക് സന്ദേശം പ്രവര്‍ത്തിപ്പിക്കുമ്പോള്‍ പിശക്: %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "ലിിങ്കിന്റെ അവസ്ഥ നിരീക്ഷിക്കുന്നതിനുള്ള നെറ്റ്ലിങ്ക് ഹാന്‍ഡില്‍ അനുവദിക്കുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "ലിങ്കിന്റെ അവസ്ഥ നിരീക്ഷിക്കുന്നതിനുള്ള നെറ്റ്ലിങ്കുമായി കണക്ട് ചെയ്യുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "ലിങ്കിന്റെ അവസ്ഥ നിരീക്ഷിക്കുന്നതിനുള്ള നെറ്റ്ലിങ്ക് ഗ്രൂപ്പിലേക്ക് പങ്കു് ചേരുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "ലിങ്കിന്റെ അവസ്ഥ നിരീക്ഷിക്കുന്നതിനുള്ള നെറ്റ്ലിങ്ക് ലിങ്ക് കാഷേ അനുവദിക്കുവാന്‍ സാധ്യമല്ല: %s "
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "സോക്കറ്റില്‍ ഡേറ്റായ്ക്കായി കാത്തിരിക്കുമ്പോള്‍ പിശകുണ്ടായിരിക്കുന്നു"
+
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "ലിങ്ക് കാഷേ പരിഷ്കരിക്കുന്നതില്‍ പിശക്: %s"
+
+#: ../src/main.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "തെറ്റായ ഉപാധി.  ശരിയായ കൂടുതല്‍ ഉപാധികള്‍ക്കായി ദയവായി --help ഉപയോഗിക്കുക.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
+msgid "# Created by NetworkManager\n"
+msgstr "# തയ്യാറാക്കിയതു് NetworkManager\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# %s-ല്‍ നിന്നും കൂട്ടിചേര്‍ത്തിരിക്കുന്നു\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "നെറ്റ്ലിങ്ക് ഹാന്‍ഡില്‍ അനുവദിക്കുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "നെറ്റ്ലിങ്കിലേക്കു് കണക്ട് ചെയ്യുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "നെറ്റ്ലിങ്ക് ഗ്രൂപ്പില്‍ ചേരുവാന്‍ സാധ്യമല്ല: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "കുറിപ്പു്: libc റിസോള്‍വര്‍ 3 നെയിംസര്‍വറുകളില്‍ കൂടതല്‍ പിന്തുണയ്ക്കുന്നതല്ല."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "താഴെ പറഞ്ഞിരിക്കുന്ന നെയിംസര്‍വറുകള്‍ തിരിച്ചറിയപ്പെടുന്നവയല്ല."
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "ഓട്ടോ %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "സിസ്റ്റം"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "സുരക്ഷിതമായ ഒരു വൈഫൈ നെറ്റ്‌വര്‍ക്ക് വഴി കണക്ഷന്‍ പങ്കിടുക"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "ഒരു തുറന്ന വൈഫൈ നെറ്റ്‌വര്‍ക്ക് വഴി കണക്ഷന്‍ പങ്കിടുക"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "സിസ്റ്റത്തിന്റെ ഹോസ്റ്റ്നാമത്തില്‍ മാറ്റം വരുത്തുക"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "സിസ്റ്റം കണക്ഷനുകളില്‍ മാറ്റം വരുത്തുക"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr " സിസ്റ്റത്തിന്റെ സജ്ജീകരണങ്ങളില്‍ മാറ്റം വരുത്തുന്നതു് സിസ്റ്റം പോളിസി തടയുന്നു"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "സിസ്റ്റത്തിന്റെ ഹോസ്റ്റ്നാമത്തില്‍ മാറ്റം വരുത്തുന്നതു് സിസ്റ്റം പോളിസി തടയുന്നു"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "സുരക്ഷിതമായ ഒരു വൈഫൈ നെറ്റ്‌വര്‍ക്ക് വഴി കണക്ഷനുകള്‍ പങ്കിടുന്നതു് സിസ്റ്റം പോളിസി തടയുന്നു"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "ഒരു തുറന്ന വൈഫൈ നെറ്റ്‌വര്‍ക്ക് വഴി കണക്ഷനുകള്‍ പങ്കിടുന്നതു് സിസ്റ്റം പോളിസി തടയുന്നു"
+
diff --git a/po/or.po b/po/or.po
index dc12475..5ab219e 100644
--- a/po/or.po
+++ b/po/or.po
@@ -1,87 +1,23 @@
-# translation of or.po to Oriya
+# translation of NetworkManager.master.or.po to Oriya
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
 # This file is distributed under the same license as the PACKAGE package.
 #
-# Manoj Kumar Giri <mgiri@redhat.com>, 2008.
+# Manoj Kumar Giri <mgiri@redhat.com>, 2008, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: or\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&amp;component=general\n"
-"POT-Creation-Date: 2008-11-25 21:02+0000\n"
-"PO-Revision-Date: 2008-11-26 19:09+0530\n"
+"Project-Id-Version: NetworkManager.master.or\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2009-09-29 03:25+0000\n"
+"PO-Revision-Date: 2010-02-10 16:09+0530\n"
 "Last-Translator: Manoj Kumar Giri <mgiri@redhat.com>\n"
-"Language-Team: Oriya\n"
+"Language-Team: Oriya <oriya-it@googlegroups.com>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms: nplurals=2;plural=(n!=1)\n"
-
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:454
-#, c-format
-msgid "error processing netlink message: %s"
-msgstr "netlink ସନ୍ଦେଶ ପଠାଇବାରେ ତ୍ରୁଟି: %s"
-
-#: ../src/nm-netlink-monitor.c:251
-#, c-format
-msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink ନିୟନ୍ତ୍ରଣ ଦର୍ଶାଇବାରେ ଅସମର୍ଥ: %s"
-
-#: ../src/nm-netlink-monitor.c:261
-#, c-format
-msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink ସହିତ ସଂଯୋଗ ହେବାରେ ଅସମର୍ଥ: %s"
-
-#: ../src/nm-netlink-monitor.c:269
-#, c-format
-msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink ଶ୍ରେଣୀରେ ମିଶିବାରେ ଅସମର୍ଥ: %s"
-
-#: ../src/nm-netlink-monitor.c:277
-#, c-format
-msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink କ୍ୟାଶେ ଦର୍ଶାଇବାରେ ଅସମର୍ଥ: %s"
-
-#: ../src/nm-netlink-monitor.c:418
-#, c-format
-msgid "error updating link cache: %s"
-msgstr "ସଂଯୋଗ କ୍ୟାଶେ ଅଦ୍ୟତନ କରିବାରେ ତ୍ରୁଟି: %s"
-
-#: ../src/nm-netlink-monitor.c:484
-msgid "error occurred while waiting for data on socket"
-msgstr "ସକେଟରେ ତଥ୍ୟ ପାଇଁ ଅପେକ୍ଷା କରିବା ସମୟରେ ତ୍ରୁଟି"
-
-#: ../src/NetworkManager.c:293
-#, c-format
-msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "ଅବୈଧ ବିକଳ୍ପ.   ବୈଧ ବିକଳ୍ପର ତାଲିକା ଦେଖିବା ପାଇଁ ଦୟାକରି --ସହାୟତା ବ୍ୟବହାର କରନ୍ତୁ.\n"
-
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:88
-msgid "# Created by NetworkManager\n"
-msgstr "# NetworkManager ଦ୍ୱାରା ନିର୍ମିତ\n"
-
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:94
-#, c-format
-msgid ""
-"# Merged from %s\n"
-"\n"
-msgstr ""
-"# %s ରୁ ମିଶ୍ରିତ\n"
+"Plural-Forms:  nplurals=2; plural=(n!=1);\n\n"
 "\n"
 
-#: ../src/named-manager/nm-named-manager.c:256
-msgid "NOTE: the libc resolver may not support more than 3 nameservers."
-msgstr "ଟିପ୍ପଣୀ: libc resolver 3 ରୁ ଅଧିକ nameserverଗୁଡ଼ିକୁ ସମର୍ଥନ କରିନପାରେ."
-
-#: ../src/named-manager/nm-named-manager.c:258
-msgid "The nameservers listed below may not be recognized."
-msgstr "ନିମ୍ନରେ ତାଲିକାଭୁକ୍ତ nameserverଗୁଡ଼ିକୁ ଚିହ୍ନି ହୋଇନପାରେ."
-
-#: ../system-settings/src/main.c:376
-#, c-format
-msgid "Auto %s"
-msgstr "ସ୍ୱୟଂ %s"
-
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -167,8 +103,9 @@ msgstr "IV କୁ ସଂରକ୍ଷଣ କରିବା ପାଇଁ ଯଥେ
 msgid "IV contains non-hexadecimal digits."
 msgstr "IV ଷୋହଳମିକ ସଂଖ୍ୟା ଧାରଣ କରିନଥାଏ."
 
-#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:335
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "ବ୍ୟକ୍ତିଗତ କି କୁଞ୍ଜି '%s' ଅଜଣା ଥିଲା."
@@ -188,66 +125,106 @@ msgstr "ବ୍ୟକ୍ତିଗତ କି ପ୍ରକାର ନିର୍ଧା
 msgid "Not enough memory to store decrypted private key."
 msgstr "ବିକୋଡ଼ନ ବ୍ୟକ୍ତିଗତ ତଥ୍ୟ ସଂରକ୍ଷଣ କରିବା ପାଇଁ ଯଥେଷ୍ଟ ସ୍ଥାନ ନାହିଁ."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "କ୍ରିପ୍ଟ ଯନ୍ତ୍ରକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "MD5 ଯନ୍ତ୍ରକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152 ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "ଅବୈଧ IV ଲମ୍ବ (ଅତିକମରେ %zd ହେବା ଉଚିତ)।"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "କି ବଫରକୁ ବିକୋଡ଼ନ କରିବା ପାଇଁ ଯଥେଷ୍ଟ ସ୍ଥାନ ନାହିଁ."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "ବିକୋଡ଼ନ କୁଞ୍ଜି ପ୍ରସଙ୍ଗକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "ବିକୋଡ଼ନ ପାଇଁ ସମମିତ କି ବିନ୍ୟାସ କରିବାରେ ବିଫଳ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "ବିକୋଡ଼ନ ପାଇଁ IV ବିନ୍ୟାସ କରିବାରେ ବିଫଳ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "ବ୍ୟକ୍ତିଗତ କି କୁ ବିକୋଡ଼ନ କରିବାରେ ବିଫଳ: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:266
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "ବ୍ୟକ୍ତିଗତ କିକୁ ଅବସଂକେତ କରିବାରେ ବିଫଳ: ଅପ୍ରତ୍ୟାଶିତ ପ୍ୟାଡିଙ୍ଗ ଲମ୍ବ।"
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:277
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "ବ୍ୟକ୍ତିଗତ କି କୁ ବିକୋଡ଼ନ କରିବାରେ ବିଫଳ."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:355
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "ସଂଗୁପ୍ତ କରିବା ପାଇଁ ସ୍ମୃତି ସ୍ଥାନକୁ ବଣ୍ଟନ କରିପାରିଲା ନାହିଁ।"
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "ବିକୋଡ଼ନ କୁଞ୍ଜି ପ୍ରସଙ୍ଗକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "ବିକୋଡ଼ନ ପାଇଁ ସମମିତ କି ବିନ୍ୟାସ କରିବାରେ ବିଫଳ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "ବିକୋଡ଼ନ ପାଇଁ IV ବିନ୍ୟାସ କରିବାରେ ବିଫଳ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "ତଥ୍ୟକୁ ବିକୋଡ଼ନ କରିବାରେ ବିଫଳ: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "ପ୍ରମାଣପତ୍ର ତଥ୍ୟକୁ ଆରମ୍ଭ କରିବାରେ ତ୍ରୁଟି: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "ପ୍ରମାଣପତ୍ରକୁ ଅବସଂକେତ କରିପାରିଲେ ନାହିଁ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "PKCS#12 ଅବସଂକେତକକୁ ଆରମ୍ଭ କରିପାରିଲେ ନାହିଁ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "PKCS#12 ଫାଇଲକୁ ଅବସଂକେତ କରିହେବ ନାହିଁ: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12 ଫାଇଲକୁ ଯାଞ୍ଚ କରିହେଲା ନାହିଁ: %s"
@@ -262,58 +239,258 @@ msgstr "କ୍ରିପ୍ଟ ଯନ୍ତ୍ରକୁ ଆରମ୍ଭ କରି
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "MD5 ପ୍ରସଙ୍ଗକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ: %d."
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "ଅବୈଧ IV ଲମ୍ବ (ନିଶ୍ଚିତ ଭାବରେ ଅତିକମରେ %d ହେବା ଉଚିତ)।"
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "ଅବସଂକେତନ କୁଞ୍ଜି ସ୍ଥାନକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "ଅବସଂକେତନ ପାଇଁ ସମମିତ କିକୁ ବିନ୍ୟାସ କରିବାରେ ବିଫଳ."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "ଅବସଂକେତନ ପାଇଁ IV ବିନ୍ୟାସ କରିବାରେ ବିଫଳ."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "ଅବସଂକେତନ ପ୍ରସଙ୍ଗକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "ବ୍ୟକ୍ତିଗତ କିକୁ ଅବସଂକେତ କରିବାରେ ବିଫଳ: %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "ବ୍ୟକ୍ତିଗତ କିକୁ ଅବସଂକେତ କରିବାରେ ବିଫଳ: ଅବସଂକେତ ତଥ୍ୟଟି ଅତ୍ୟଧିକ ବଡ଼।"
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "ବ୍ୟକ୍ତିଗତ କିର ଅବସଂକେତନକୁ ନିଶ୍ଚୟ କରିବାରେ ବିଫଳ: %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:363
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "ଅବସଂକେତନ କୁଞ୍ଜି ସ୍ଥାନକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ।"
+
+#: ../libnm-util/crypto_nss.c:371
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "ଅବସଂକେତନ ପାଇଁ ସମମିତ କିକୁ ବିନ୍ୟାସ କରିବାରେ ବିଫଳ।"
+
+#: ../libnm-util/crypto_nss.c:379
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "ଅବସଂକେତନ ପାଇଁ IV ବିନ୍ୟାସ କରିବାରେ ବିଫଳ।"
+
+#: ../libnm-util/crypto_nss.c:387
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "ଅବସଂକେତନ ପ୍ରସଙ୍ଗକୁ ଆରମ୍ଭ କରିବାରେ ବିଫଳ।"
+
+#: ../libnm-util/crypto_nss.c:395
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "ଅବସଂକେତ କରିବାରେ ବିଫଳ: %d."
+
+#: ../libnm-util/crypto_nss.c:403
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "ସଂଗୁପ୍ତ କରିବା ପରେ ଅପ୍ରତ୍ୟଶିତ ପରିମାଣର ତଥ୍ୟ।"
+
+#: ../libnm-util/crypto_nss.c:446
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "ପ୍ରମାଣପତ୍ରକୁ ଅବସଂକେତନ କରିହେଲା ନାହିଁ: %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:481
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "ପ୍ରବେଶସଙ୍କେତକୁ UCS2ରେ ପରିବର୍ତ୍ତନ କରିହେଲା ନାହିଁ: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:509
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12 ଅବସଂକେତକକୁ ଆରମ୍ଭ କରିହେଲା ନାହିଁ: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:518
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12 ଫାଇଲକୁ ଅବସଂକେତନ କରିହେଲା ନାହିଁ: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:527
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12 ଫାଇଲକୁ ଯାଞ୍ଚ କରିହେଲାନାହିଁ: %d"
 
+#: ../libnm-util/crypto_nss.c:556
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "ମନଇଚ୍ଛା ତଥ୍ୟକୁ ଅବସଂକେତ କରିହେଲା ନାହିଁ।"
+
+#: ../libnm-util/nm-utils.c:1522
+#, c-format
+#| msgid "Not enough memory to decrypt private key."
+msgid "Not enough memory to make encryption key."
+msgstr "ବିକୋଡ଼ନ କି କୁ ନିର୍ମାଣ କରିବା ପାଇଁ ଯଥେଷ୍ଟ ସ୍ମୃତି ସ୍ଥାନ ନାହିଁ।"
+
+#: ../libnm-util/nm-utils.c:1633
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM ଫାଇଲ ନିର୍ମାଣ ପାଇଁ ସ୍ମୃତି ସ୍ଥାନ ବଣ୍ଟନ କରିପାରିଲା ନାହିଁ।"
+
+#: ../libnm-util/nm-utils.c:1645
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM ଫାଇଲରେ IV ଲେଖିବା ପାଇଁ ସ୍ମୃତି ସ୍ଥାନ ବଣ୍ଟନ କରିପାରିଲା ନାହିଁ।"
+
+#: ../libnm-util/nm-utils.c:1657
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM ଫାଇଲରେ ସଂଗୁପ୍ତ କି ଲେଖିବା ପାଇଁ ସ୍ମୃତି ସ୍ଥାନ ବଣ୍ଟନ କରିପାରିଲା ନାହିଁ।"
+
+#: ../libnm-util/nm-utils.c:1676
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM ଫାଇଲ ତଥ୍ୟକୁ ବଣ୍ଟନ କରିପାରିଲା ନାହିଁ।"
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:569
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "netlink ସନ୍ଦେଶ ପଠାଇବାରେ ତ୍ରୁଟି: %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink ନିୟନ୍ତ୍ରଣ ଦର୍ଶାଇବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink ସହିତ ସଂଯୋଗ ହେବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink ଶ୍ରେଣୀରେ ମିଶିବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "ସଂଯୋଗ ସ୍ଥିତି ଅନ୍ୱେଷଣ କରିବା ପାଇଁ netlink କ୍ୟାଶେ ଦର୍ଶାଇବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
+msgid "error occurred while waiting for data on socket"
+msgstr "ସକେଟରେ ତଥ୍ୟ ପାଇଁ ଅପେକ୍ଷା କରିବା ସମୟରେ ତ୍ରୁଟି"
+
+#: ../src/nm-netlink-monitor.c:558
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "ସଂଯୋଗ କ୍ୟାଶେ ଅଦ୍ୟତନ କରିବାରେ ତ୍ରୁଟି: %s"
+
+#: ../src/NetworkManager.c:330
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "ଅବୈଧ ବିକଳ୍ପ.   ବୈଧ ବିକଳ୍ପର ତାଲିକା ଦେଖିବା ପାଇଁ ଦୟାକରି --ସହାୟତା ବ୍ୟବହାର କରନ୍ତୁ.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+msgid "# Created by NetworkManager\n"
+msgstr "# NetworkManager ଦ୍ୱାରା ନିର୍ମିତ\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"# %s ରୁ ମିଶ୍ରିତ\n"
+"\n"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "netlink ନିୟନ୍ତ୍ରଣ ଦର୍ଶାଇବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "netlink ସହିତ ସଂଯୋଗ ହେବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "netlink ଶ୍ରେଣୀରେ ମିଶିବାରେ ଅସମର୍ଥ: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "ଟିପ୍ପଣୀ: libc resolver 3 ରୁ ଅଧିକ nameserverଗୁଡ଼ିକୁ ସମର୍ଥନ କରିନପାରେ."
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "ନିମ୍ନରେ ତାଲିକାଭୁକ୍ତ nameserverଗୁଡ଼ିକୁ ଚିହ୍ନି ହୋଇନପାରେ."
+
+#: ../src/system-settings/nm-default-wired-connection.c:194
+#, c-format
+msgid "Auto %s"
+msgstr "ସ୍ୱୟଂ %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+msgid "System"
+msgstr "ତନ୍ତ୍ର"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "ଗୋଟିଏ ସୁରକ୍ଷିତ WiFi ନେଟୱର୍କରେ ସଂଯୋଗ ସହଭାଗ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "ଗୋଟିଏ ଖୋଲା WiFi ନେଟୱର୍କରେ ସଂଯୋଗ ସହଭାଗ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "ସ୍ଥାୟୀ ତନ୍ତ୍ର ହୋଷ୍ଟନାମକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "ତନ୍ତ୍ର ସଂଯୋଗଗୁଡ଼ିକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "ତନ୍ତ୍ର ନିତୀ ତନ୍ତ୍ର ବିନ୍ୟାସ ପରିବର୍ତ୍ତନକୁ ବାରଣ କରିଥାଏ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "ତନ୍ତ୍ର ନିତୀ ସ୍ଥାୟୀ ତନ୍ତ୍ର ହୋଷ୍ଟନାମର ପରିବର୍ତ୍ତନକୁ ବାରଣ କରିଥାଏ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr "ତନ୍ତ୍ର ନିତୀ ଗୋଟିଏ ସୁରକ୍ଷିତ WiFi ନେଟୱର୍କରେ ସଂଯୋଗ ସହଭାଗ କରିବାରେ ବାରଣ କରିଥାଏ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr "ତନ୍ତ୍ର ନିତୀ ଗୋଟିଏ ଖୋଲା WiFi ନେଟୱର୍କରେ ସଂଯୋଗ ସହଭାଗ କରିବାରେ ବାରଣ କରିଥାଏ"
+
diff --git a/po/pa.po b/po/pa.po
index 859ec9f..052406e 100644
--- a/po/pa.po
+++ b/po/pa.po
@@ -4,221 +4,1478 @@
 #
 # Amanpreet Singh Alam <aalam@redhat.com>, 2004.
 # Amanpreet Singh Alam <amanpreetalam@yahoo.com>, 2005.
-# A S Alam <aalam@users.sf.net>, 2007.
+# A S Alam <aalam@users.sf.net>, 2007, 2010.
 msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager.HEAD\n"
-"Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2007-02-03 18:35+0000\n"
-"PO-Revision-Date: 2007-02-04 08:37+0530\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug."
+"cgi?product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-03-24 03:26+0000\n"
+"PO-Revision-Date: 2010-04-03 14:08+0530\n"
 "Last-Translator: A S Alam <aalam@users.sf.net>\n"
-"Language-Team: Punjabi <fedora-trans-pa@redhat.com>\n"
+"Language-Team: Punjabi/Panjabi <kde-i18n-doc@kde.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: KBabel 1.11.4\n"
+"X-Generator: Lokalize 1.0\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 "\n"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:417
-msgid "Cannot add VPN connection"
-msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਜੋੜਿਆ ਨਹੀਂ ਜਾ ਸਕਦਾ ਹੈ"
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"ਵਰਤੋਂ: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+#| msgid "VPN Connections"
+msgid "Connections"
+msgstr "ਕੁਨੈਕਸ਼ਨ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "ਕਿਸਮ"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "ਨਾਂ"
+
+#: ../cli/src/connections.c:163
+#, c-format
+#| msgid "VPN Connections"
+msgid "System connections:\n"
+msgstr "ਸਿਸਟਮ ਕੁਨੈਕਸ਼ਨ:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+#| msgid "VPN Connections"
+msgid "User connections:\n"
+msgstr "ਯੂਜ਼ਰ ਕੁਨੈਕਸ਼ਨ:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "ਗਲਤੀ: %s ਆਰਗੂਮੈਂਟ ਮੌਜੂਦ ਨਹੀਂ ਹੈ।"
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "ਗਲਤੀ: %s - ਇੰਝ ਦਾ ਕੋਈ ਕੁਨੈਕਸ਼ਨ ਨਹੀਂ ਹੈ"
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "ਸਿਸਟਮ-ਲਈ ਕੁਨੈਕਸ਼ਨ"
+
+#: ../cli/src/connections.c:205
+#| msgid "VPN Connections"
+msgid "User connections"
+msgstr "ਯੂਜ਼ਰ ਕੁਨੈਕਸ਼ਨ"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "ਅਣਜਾਣ ਪੈਰਾਮੀਟਰ: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "ਗਲਤੀ: ਕੋਈ ਢੁੱਕਵਾਂ ਪੈਰਾਮੀਟਰ ਨਹੀਂ ਦਿੱਤਾ।"
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ਹਾਂ"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+#| msgid "none"
+msgid "no"
+msgstr "ਨਹੀਂ"
+
+#: ../cli/src/connections.c:297
+#| msgid "VPN Connections"
+msgid "Active connections"
+msgstr "ਚਾਲੂ ਕੁਨੈਕਸ਼ਨ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "ਡਿਫਾਲਟ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "ਸਰਵਿਸ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "ਜੰਤਰ"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "ਜੰਤਰ '%s' ਉੱਤੇ ਕੋਈ ਚਾਲੂ ਕੁਨੈਕਸ਼ਨ ਨਹੀਂ ਹੈ"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ਕੋਈ ਚਾਲੂ ਕੁਨੈਕਸ਼ਨ ਜਾਂ ਜੰਤਰ ਨਹੀਂ ਹੈ"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "ਚਾਲੂ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "ਚਾਲੂ ਕੀਤਾ"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "ਅਣਜਾਣ"
+
+#: ../cli/src/connections.c:744
+#| msgid "VPN Connections"
+msgid "VPN connecting (prepare)"
+msgstr "VPN ਕੁਨੈਕਸ਼ਨ (ਤਿਆਰੀ)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ (ਪਰਮਾਣਕਿਤਾ ਦੀ ਲੋੜ ਹੈ)"
+
+#: ../cli/src/connections.c:748
+#| msgid "VPN Connections"
+msgid "VPN connecting"
+msgstr "VPN ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ (IP ਸੰਰਚਨਾ ਲਈ ਜਾ ਰਹੀ ਹੈ)"
+
+#: ../cli/src/connections.c:752
+#| msgid "VPN Connections"
+msgid "VPN connected"
+msgstr "VPN ਕੁਨੈਕਟ ਹੈ"
+
+#: ../cli/src/connections.c:754
+#| msgid "VPN Connections"
+msgid "VPN connection failed"
+msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਫੇਲ੍ਹ ਹੋਇਆ"
+
+#: ../cli/src/connections.c:756
+#| msgid "VPN Connections"
+msgid "VPN disconnected"
+msgstr "VPN ਡਿਸ-ਕੁਨੈਕਟ"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "ਅਣਜਾਣ ਕਾਰਨ"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "ਕੋਈ ਨਹੀਂ"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "ਯੂਜ਼ਰ ਡਿਸ-ਕੁਨੈਕਟ ਹੋ ਗਿਆ"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "ਬੇਸ ਨੈੱਟਵਰਕ ਕੁਨੈਕਸ਼ਨ 'ਚ ਰੁਕਾਵਟ"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN ਸਰਵਿਸ ਅਚਾਨਕ ਰੁਕ ਗਈ"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN ਸਰਵਿਸ ਨੇ ਅਢੁੱਕਵੀਂ ਸੰਰਚਨਾ ਵਾਪਸ ਕੀਤੀ"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "ਕੁਨੈਕਸ਼ਨ ਕੋਸ਼ਿਸ਼ ਦੌਰਾਨ ਸਮਾਂ ਸਮਾਪਤ ਹੋ ਗਿਆ"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN ਸਰਵਿਸ ਸਮੇਂ 'ਚ ਸ਼ੁਰੂ ਨਹੀਂ ਹੋਈ"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN ਸਰਵਿਸ ਸ਼ੁਰੂ ਹੋਣ ਲਈ ਫੇਲ੍ਹ ਹੋਈ"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "ਕੋਈ ਢੁੱਕਵਾਂ VPN ਭੇਦ  ਨਹੀਂ"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "ਅਢੁੱਕਵਾਂ VPN ਭੇਦ"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "ਕੁਨੈਕਸ਼ਨ ਹਟਾਇਆ ਗਿਆ"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:419
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "ਹਾਲਤ: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "ਕੁਨੈਕਸ਼ਨ ਚਾਲੂ ਕੀਤਾ\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "ਗਲਤ: ਕੁਨੈਕਸ਼ਨ ਚਾਲੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "ਹਾਲਤ: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "ਗਲਤੀ: ਕੁਨੈਕਸ਼ਨ ਚਾਲੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s।"
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "ਗਲਤੀ: ਸਮਾਂ-ਸਮਾਪਤੀ %d ਸਕਿੰਟ ਖਤਮ ਹੋਏ।"
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "ਗਲਤੀ: ਕੁਨੈਕਸ਼ਨ ਚਾਲੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+#| msgid "Error retrieving VPN connection '%s'"
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "ਗਲਤੀ: '%s' ਲਈ ਚਾਲੂ ਕੁਨੈਕਸ਼ਨ ਲੈਣ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "ਚਾਲੂ ਕੁਨੈਕਸ਼ਨ ਹਾਲਤ: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "ਚਾਲੂ ਕੁਨੈਕਸ਼ਨ ਪਾਥ: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+#| msgid "Error retrieving VPN connection '%s'"
+msgid "Error: Unknown connection: %s."
+msgstr "ਗਲਤੀ: ਅਣਜਾਣ ਕੁਨੈਕਸ਼ਨ: %s।"
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "ਗਲਤੀ: ਸਮਾਂ-ਸਮਾਪਤੀ ਮੁੱਲ '%s' ਢੁੱਕਵਾਂ ਨਹੀਂ ਹੈ।"
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "ਗਲਤੀ: id ਜਾਂ uuid ਨਹੀਂ ਦਿੱਤਾ।"
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "ਗਲਤੀ: ਕੋਈ ਢੁੱਕਵਾਂ ਜੰਤਰ ਨਹੀਂ ਲੱਭਿਆ: %s।"
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "ਗਲਤੀ: ਕੋਈ ਢੁੱਕਵਾਂ ਜੰਤਰ ਨਹੀਂ ਮਿਲਿਆ।"
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "ਚੇਤਾਵਨੀ: ਕੁਨੈਕਸ਼ਨ ਚਾਲੂ ਨਹੀਂ ਹੈ\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "ਗਲਤੀ: 'con' ਕਮਾਂਡ '%s' ਢੁੱਕਵਾਂ ਨਹੀਂ।"
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "ਗਲਤੀ: ਡੀ-ਬੱਸ ਨਾਲ ਕੁਨੈਕਟ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ।"
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "ਗਲਤੀ: ਸਿਸਟਮ ਸੈਟਿੰਗ ਨਹੀਂ ਲਈ ਜਾ ਸਕੀ।"
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "ਗਲਤੀ: ਯੂਜ਼ਰ ਸੈਟਿੰਗ ਨਹੀਂ ਲਈ ਜਾ ਸਕੀ।"
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "ਗਲਤੀ: ਕੁਨੈਕਸ਼ਨ ਨਹੀਂ ਲਿਆ ਜਾ ਸਕਦਾ: ਸਿਸਟਮ ਸਰਵਿਸ ਨਹੀਂ ਚੱਲ ਰਹੀ ਹੈ।"
+
+#: ../cli/src/devices.c:73
+#, c-format
 msgid ""
-"No suitable VPN software was found on your system. Contact your system "
-"administrator."
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
 msgstr ""
-"ਤੁਹਾਡੇ ਸਿਸਟਮ ਉੱਤੇ ਕੋਈ ਠੀਕ VPN ਸਾਫਟਵੇਅਰ ਨਹੀਂ ਲੱਭਾ ਹੈ। ਆਪਣੇ ਸਿਸਟਮ "
-"ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰੋ।"
+"ਵਰਤੋਂ: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "ਬਿਨ-ਪਰਬੰਧ"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "ਅਣ-ਉਪਲੱਬਧ"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "ਡਿਸ-ਕੁਨੈਕਟ ਕੀਤਾ"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ (ਤਿਆਰੀ)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ (ਸੰਰਚਨਾ ਜਾਰੀ)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ (ਪਰਮਾਣਕਿਤਾ ਦੀ ਲੋੜ)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ (IP ਸੰਰਚਨਾ ਲਈ ਜਾ ਰਹੀ ਹੈ)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "ਕੁਨੈਕਟ ਹੋਇਆ"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:461
-msgid "Cannot import VPN connection"
-msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਆਯਾਤ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਦਾ"
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "ਕੁਨੈਕਸ਼ਨ ਫੇਲ੍ਹ ਹੈ"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:463
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "ਅਣਜਾਣ"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+#| msgid "none"
+msgid "(none)"
+msgstr "(ਕੋਈ ਨਹੀਂ)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: IP4 ਐਡਰੈੱਸ 0x%X ਬਦਲਣ ਦੌਰਾਨ ਗਲਤੀ"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, ਫਰੀਕਿਊਂਸੀ %d MHz, ਦਰ %d Mb/s, ਤਾਕਤ %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "ਐਡ-ਹਾਕ"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", ਇੰਕ੍ਰਿਪਟ ਕੀਤਾ: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+#| msgid "WPA Enterprise"
+msgid " Enterprise"
+msgstr " ਇੰਟਰਪਰਾਈਸ"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "ਜੰਤਰ"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "ਡਰਾਇਵਰ"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(ਅਣਜਾਣ)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "ਹਾਲਤ"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW ਐਡਰੈੱਸ"
+
+#: ../cli/src/devices.c:319
 #, c-format
 msgid ""
-"Cannot find suitable software for VPN connection type '%s' to import the "
-"file '%s'. Contact your system administrator."
+"\n"
+"  Capabilities:\n"
 msgstr ""
-"VPN ਕੁਨੈਕਸ਼ਨ ਕਿਸਮ '%s' ਲਈ ਫਾਇਲ '%s' ਆਯਾਤ ਕਰਨ ਲਈ ਕੋਈ ਢੁੱਕਵਾਂ "
-"ਸਾਫਟਵੇਅਰ ਨਹੀਂ ਲੱਭਿਆ ਹੈ। ਆਪਣੇ ਸਿਸਟਮ ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰੋ।"
+"\n"
+"  ਸਮਰੱਥਾ:\n"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:580
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "ਕੈਰੀਅਰ ਖੋਜ"
+
+#: ../cli/src/devices.c:336
 #, c-format
-msgid "Error retrieving VPN connection '%s'"
-msgstr "VPN ਕੁਨੈਕਸ਼ਨ '%s' ਲੈਣ ਦੌਰਾਨ ਗਲਤੀ"
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "ਸਪੀਡ"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:583
+#: ../cli/src/devices.c:348
 #, c-format
 msgid ""
-"Could not find the UI files for VPN connection type '%s'. Contact your "
-"system administrator."
+"\n"
+"  Wireless Properties\n"
 msgstr ""
-"VPN ਕੁਨੈਕਸ਼ਨ ਕਿਸਮ '%s' ਲਈ UI ਫਾਇਲਾਂ ਨਹੀਂ ਲੱਭੀਆਂ ਹਨ। ਆਪਣੇ ਸਿਸਟਮ "
-"ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰੋ।"
+"\n"
+" ਬੇਤਾਰ ਵਿਸ਼ੇਸ਼ਤਾ\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP ਇੰਕ੍ਰਿਪਸ਼ਨ"
+
+#: ../cli/src/devices.c:355
+#| msgid "WPA Enterprise"
+msgid "WPA Encryption"
+msgstr "WPA ਇੰਕ੍ਰਿਪਸ਼ਨ"
+
+#: ../cli/src/devices.c:357
+#| msgid "WPA2 Enterprise"
+msgid "WPA2 Encryption"
+msgstr "WPA2  ਇੰਕ੍ਰਿਪਸ਼ਨ"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:727
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP ਸਿਫਰ"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP ਸੀਫਰ"
+
+#: ../cli/src/devices.c:368
 #, c-format
-msgid "Delete VPN connection \"%s\"?"
-msgstr "ਕੀ VPN \"%s\" ਕੁਨੈਕਸ਼ਨ ਹਟਾਉਣਾ ਹੈ?"
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  ਬੇਤਾਰ ਅਸੈੱਸ ਪੁਆਇੰਟ %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = ਮੌਜੂਦਾ AP)"
 
-#: ../gnome/vpn-properties/nm-vpn-properties.c:730
+#: ../cli/src/devices.c:374
 #, c-format
 msgid ""
-"All information about the VPN connection \"%s\" will be lost and you may "
-"need your system administrator to provide information to create a new "
-"connection."
+"\n"
+"  Wired Properties\n"
 msgstr ""
-"VPN ਕੁਨੈਕਸ਼ਨ \"%s\" ਬਾਰੇ ਸਭ ਜਾਣਕਾਰੀ ਖਤਮ ਹੋ ਗਈ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ "
-"ਨਵੇਂ ਕੁਨੈਕਸ਼ਨ ਬਣਾਉਣ ਲਈ ਜਾਣਕਾਰੀ ਵਾਸਤੇ ਆਪਣੇ ਸਿਸਟਮ ਪਰਸ਼ਾਸ਼ਕ "
-"ਨਾਲ ਸੰਪਰਕ ਕਰਨਾ ਪਵੇਗਾ।"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.c:924
-msgid "Unable to load"
-msgstr "ਲੋਡ ਕਰਨ ਲਈ ਫੇਲ੍ਹ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.c:926
-msgid "Cannot find some needed resources (the glade file)!"
-msgstr "ਕੁਝ ਲੋੜੀਦੇ ਸਰੋਤ ਨਹੀਂ ਮਿਲੇ (ਗਲੇਡ ਫਾਇਲ)!"
-
-#. druid_window = GTK_DIALOG (gtk_dialog_new_with_buttons (_("Create VPN Connection"),
-#. NULL,
-#. GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
-#. GTK_STOCK_CANCEL,
-#. GTK_RESPONSE_REJECT,
-#. GTK_STOCK_APPLY,
-#. GTK_RESPONSE_ACCEPT,
-#. NULL));
-#: ../gnome/vpn-properties/nm-vpn-properties.c:1081
-msgid "Create VPN Connection"
-msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਬਣਾਓ"
-
-#. gtk_container_add (GTK_CONTAINER (druid_window->vbox), GTK_WIDGET(gtk_label_new("Some label")));
-#. gtk_box_pack_start (GTK_BOX (druid_window->vbox), GTK_WIDGET(druid), TRUE,TRUE,0);
-#. gtk_box_pack_start (GTK_BOX (druid_window->vbox), GTK_WIDGET(gtk_label_new("Some label")), TRUE,TRUE,0);
-#. toplevel = gtk_widget_get_toplevel (GTK_WIDGET (druid));
-#. gtk_signal_connect (GTK_OBJECT (toplevel), "delete_event", GTK_SIGNAL_FUNC (vpn_window_close), NULL);
-#. make the druid window modal wrt. our main window
-#. gtk_window_set_modal (druid_window, TRUE);
-#. gtk_window_set_transient_for (GTK_WINDOW(druid_window), GTK_WINDOW (dialog));
-#. Edit dialog
-#: ../gnome/vpn-properties/nm-vpn-properties.c:1099
-msgid "Edit VPN Connection"
-msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਸੋਧ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:1
-msgid "Add a new VPN connection"
-msgstr "ਇੱਕ ਨਵਾਂ VPN ਕੁਨੈਕਸ਼ਨ ਸ਼ਾਮਿਲ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:2
-msgid "Delete the selected VPN connection"
-msgstr "ਚੁਣਿਆ VPN ਕੁਨੈਕਸ਼ਨ ਹਟਾਓ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:3
-msgid "E_xport"
-msgstr "ਨਿਰਯਾਤ(_x)"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:4
-msgid "Edit the selected VPN connection"
-msgstr "ਚੁਣੇ VPN ਕੁਨੈਕਸ਼ਨ 'ਚ ਸੋਧ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:5
-msgid "Export the VPN settings to a file"
-msgstr "VPN ਸੈਟਿੰਗ ਨੂੰ ਫਾਇਲ 'ਚ ਭੇਜੋ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:6
-msgid "Export the selected VPN connection to a file"
-msgstr "ਚੁਣੇ VPN ਕੁਨੈਕਸ਼ਨ ਫਾਇਲ 'ਚ ਭੇਜੋ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:7
-msgid "Manage Virtual Private Network Connections"
-msgstr "ਵੁਰਚੁਅਲ ਪ੍ਰਾਈਵੇਟ ਨੈੱਟਵਰਕ ਕੁਨੈਕਸ਼ਨ ਪਰਬੰਧ"
-
-#: ../gnome/vpn-properties/nm-vpn-properties.glade.h:8
-msgid "VPN Connections"
-msgstr "VPN ਕੁਨੈਕਸ਼ਨ"
-
-#: ../src/nm-ap-security-wep.c:52
-msgid "40-bit WEP"
-msgstr "40-ਬਿੱਟ WEP"
-
-#: ../src/nm-ap-security-wep.c:54
-msgid "104-bit WEP"
-msgstr "104-ਬਿੱਟ WEP"
-
-#: ../src/nm-ap-security-wpa-psk.c:51
-msgid "WPA TKIP"
-msgstr "WPA TKIP"
-
-#: ../src/nm-ap-security-wpa-psk.c:53
-msgid "WPA CCMP"
-msgstr "WPA CCMP"
-
-#: ../src/nm-ap-security-wpa-psk.c:55
-msgid "WPA Automatic"
-msgstr "WPA ਆਟੋਮੈਟਿਕ"
-
-#: ../src/nm-ap-security-wpa-psk.c:60
-msgid "WPA2 TKIP"
-msgstr "WPA2 TKIP"
-
-#: ../src/nm-ap-security-wpa-psk.c:62
-msgid "WPA2 CCMP"
-msgstr "WPA2 CCMP"
-
-#: ../src/nm-ap-security-wpa-psk.c:64
-msgid "WPA2 Automatic"
-msgstr "WPA2 ਆਟੋਮੈਟਿਕ"
-
-#: ../src/nm-ap-security.c:334
-msgid "none"
-msgstr "ਕੋਈ ਨਹੀਂ"
+"\n"
+"  ਤਾਰ ਨਾਲ ਵਿਸ਼ੇਸ਼ਤਾ\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "ਕੈਰੀਅਰ"
+
+#: ../cli/src/devices.c:377
+#| msgid "none"
+msgid "on"
+msgstr "ਚਾਲੂ"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "ਬੰਦ"
 
-#: ../src/nm-netlink-monitor.c:174
+#: ../cli/src/devices.c:387
 #, c-format
-msgid "unable to create netlink socket for monitoring wired ethernet devices - %s"
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
 msgstr ""
-"ਤਾਰ ਵਾਲੇ ਇਥਰਨੈੱਟ ਜੰਤਰ - %s ਦੀ ਨਿਗਰਾਨੀ ਲਈ netlink ਸਾਕਟ ਬਣਾਉਣ "
-"ਲਈ ਅਸਫ਼ਲ"
+"\n"
+"  IPv4 ਵਿਸ਼ੇਸ਼ਤਾ:\n"
 
-#: ../src/nm-netlink-monitor.c:192
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "ਐਡਰੈੱਸ"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "ਪ੍ਰੀ-ਫਿਕਸ"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "ਗੇਟਵੇ"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "ਜੰਤਰਾਂ ਦੀ ਹਾਲਤ"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "ਗਲਤੀ: '%s' ਆਰਗੂਮੈਂਟ ਗੁੰਮ ਹੈ।"
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
 #, c-format
-msgid "unable to bind to netlink socket for monitoring wired ethernet devices - %s"
+msgid "Error: Device '%s' not found."
+msgstr "ਗਲਤੀ: ਜੰਤਰ '%s' ਨਹੀਂ ਲੱਭਿਆ।"
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "ਸਫ਼ਲ: ਜੰਤਰ '%s' ਠੀਕ ਤਰ੍ਹਾਂ ਡਿਸ-ਕੁਨੈਕਟ ਹੋ ਗਿਆ।"
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "ਗਲਤੀ: ਜੰਤਰ '%s' (%s) ਡਿਸ-ਕੁਨੈਕਸ਼ਨ ਫੇਲ੍ਹ: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "ਜੰਤਰ ਹਾਲਤ: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "ਗਲਤੀ: iface ਦੇਣ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "ਵਾਈਫਾਈ ਸਕੈਨ ਲਿਸਟ"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "ਗਲਤੀ: ਜੰਤਰ '%s' ਵਾਈ-ਫਾਈ ਜੰਤਰ ਨਹੀਂ ਹੈ।"
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "ਜੰਤਰ:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "ਗਲਤੀ: hwaddr ਦੇਣ ਦੀ ਲੋੜ ਹੈ।"
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "ਗਲਤੀ: hwaddr '%s' ਵਾਲਾ ਅਸੈੱਸ ਪੁਆਇੰਟ ਨਹੀਂ ਲੱਭਿਆ।"
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP ਪੈਰਾਮੀਟਰ"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "ਫਰੀਕਿਊਨਸੀ:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "ਮੋਡ:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "ਐਡ-ਹਾਕ"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "ਇੰਫਰਾਸਟੱਕਚਰ"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "ਵੱਧੋ-ਵੱਧ ਬਿੱਟਰੇਟ:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "ਤਾਕਤ:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "ਫਲੈਗ:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "ਪਰਾਈਵੇਸੀ"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA ਫਲੈਗ:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN ਫਲੈਗ:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "ਗਲਤੀ: 'dev wifi' ਕਮਾਂਡ '%s' ਢੁੱਕਵੀਂ ਨਹੀਂ ਹੈ।"
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "ਗਲਤੀ: 'dev' ਕਮਾਂਡ '%s' ਢੁੱਕਵੀਂ ਨਹੀਂ ਹੈ।"
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
 msgstr ""
-"ਤਾਰ ਵਾਲੇ ਇਥਰਨੈੱਟ ਜੰਤਰ - %s ਦੀ ਨਿਗਰਾਨੀ ਲਈ netlink ਸਾਕਟ ਜੋੜਨ "
-"ਲਈ ਅਸਫ਼ਲ"
+"ਵਰਤੋਂ: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "asleep"
+
+#: ../cli/src/network-manager.c:69
+#| msgid "VPN Connections"
+msgid "connecting"
+msgstr "ਕੁਨੈਕਟ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "ਚਾਲੂ ਹੈ"
 
-#: ../src/nm-netlink-monitor.c:427
-msgid "operation took too long"
-msgstr "ਓਪਰੇਸ਼ਨ ਨੂੰ ਬਹੁਤ ਸਮਾਂ ਲੱਗ ਗਿਆ"
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "ਬੰਦ ਹੈ"
 
-#: ../src/nm-netlink-monitor.c:524
-msgid "received data from wrong type of sender"
-msgstr "ਭੇਜਣ ਵਾਲੇ ਦੀ ਗਲਤ ਕਿਸਮ ਤੋਂ ਡਾਟਾ ਮਿਲਿਆ"
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "ਨੈੱਟਵਰਕਮੈਨੇਜਰ ਹਾਲਤ"
 
-#: ../src/nm-netlink-monitor.c:537
-msgid "received data from unexpected sender"
-msgstr "ਅਣਜਾਣ ਭੇਜਣ ਵਾਲੇ ਵਲੋਂ ਡਾਟਾ ਮਿਲਿਆ"
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM ਚੱਲ ਰਿਹਾ ਹੈ:"
 
-#: ../src/nm-netlink-monitor.c:666
-msgid "too much data was sent over socket and some of it was lost"
-msgstr "ਸਾਕਟ ਉੱਤੇ ਬਹੁਤ ਵੱਧ ਡਾਟਾ ਭੇਜਿਆ ਗਿਆ ਅਤੇ ਇਸ 'ਚੋਂ ਕੁਝ ਗੁੰਮ ਹੋ ਗਿਆ"
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "ਚੱਲ ਰਿਹਾ ਹੈ"
 
-#: ../src/nm-netlink-monitor.c:774
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "ਨਹੀਂ ਚੱਲ ਰਿਹਾ ਹੈ"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM ਹਾਲਤ:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM ਬੇਤਾਰ ਹਾਰਡਵੇਅਰ:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM ਬੇਤਾਰ:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN ਹਾਰਡਵੇਅਰ:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "ਗਲਤੀ: ਅਢੁੱਕਵਾਂ 'wifi' ਪੈਰਾਮੀਟਰ: '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "ਗਲਤੀ: ਅਢੁੱਕਵਾਂ 'wwan' ਪੈਰਾਮੀਟਰ: '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "ਗਲਤੀ: 'nm' ਕਮਾਂਡ '%s' ਢੁੱਕਵੀਂ ਨਹੀਂ ਹੈ।"
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"ਵਰਤੋਂ: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "ਆਬਜੈਕਟ '%s' ਅਣਜਾਣ ਹੈ, 'nmcli help' ਵਰਤ ਕੇ ਵੇਖੋ।"
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli ਟੂਲ, ਵਰਜਨ %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "ਚੋਣ '%s' ਅਣਜਾਣੀ ਹੈ 'nmcli -help' ਵਰਤ ਕੇ ਵੇਖੋ।"
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "%d ਸਿਗਨਲ ਮਿਲਿਆ, ਬੰਦ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "ਗਲਤੀ: ਨੈੱਟਵਰਕਮੈਨੇਜਰ ਨਾਲ ਕੁਨੈਕਟ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ।"
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "ਸਫ਼ਲ"
+
+#: ../libnm-util/crypto.c:120
+#, c-format
+msgid "PEM key file had no end tag '%s'."
+msgstr "PEM ਕੁੰਜੀ ਫਾਇਲ ਵਿੱਚ ਕੋਈ ਅੰਤ ਟੈਗ '%s' ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:130
+#, c-format
+msgid "Doesn't look like a PEM private key file."
+msgstr "PEM ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਫਾਇਲ ਵਾਂਗ ਨਹੀਂ ਜਾਪਦੀ।"
+
+#: ../libnm-util/crypto.c:138
+#, c-format
+msgid "Not enough memory to store PEM file data."
+msgstr "PEM ਫਾਇਲ ਡਾਟਾ ਸਟੋਰ ਕਰਨ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:154
+#, c-format
+msgid "Malformed PEM file: Proc-Type was not first tag."
+msgstr "ਨਿਕਾਰਾ PEM ਫਾਇਲ: Proc-Type ਪਹਿਲਾਂ ਟੈਗ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:162
+#, c-format
+msgid "Malformed PEM file: unknown Proc-Type tag '%s'."
+msgstr "ਨਿਕਾਰਾ PEM ਫਾਇਲ: ਅਣਜਾਣ Proc-Type ਟੈਗ '%s' ਹੈ।"
+
+#: ../libnm-util/crypto.c:172
+#, c-format
+msgid "Malformed PEM file: DEK-Info was not the second tag."
+msgstr "ਨਿਕਾਰਾ PEM ਫਾਇਲ: DEK-Info ਦੂਜਾ ਟੈਗ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:183
+#, c-format
+msgid "Malformed PEM file: no IV found in DEK-Info tag."
+msgstr "ਨਿਕਾਰਾ PEM ਫਾਇਲ: DEK-Info ਟੈਗ ਵਿੱਚ ਕੋਈ IV ਨਹੀਂ ਲੱਭਿਆ।"
+
+#: ../libnm-util/crypto.c:190
+#, c-format
+msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
+msgstr " ਨਿਕਾਰਾ PEM ਫਾਇਲ: DEK-Info ਟੈਗ ਵਿੱਚ ਗਲਤ ਫਾਰਮੈਟ IV"
+
+#: ../libnm-util/crypto.c:203
+#, c-format
+msgid "Malformed PEM file: unknown private key cipher '%s'."
+msgstr "ਨਿਕਾਰਾ PEM ਫਾਇਲ: ਅਣਜਾਣ ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਸੀਫਰ '%s'।"
+
+#: ../libnm-util/crypto.c:222
+#, c-format
+msgid "Could not decode private key."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡੀਕੋਡ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕੀ।"
+
+#: ../libnm-util/crypto.c:267
+#, c-format
+msgid "PEM certificate '%s' had no end tag '%s'."
+msgstr "PEM ਸਰਟੀਫਿਕੇਟ '%s' ਵਿੱਚ ਕੋਈ ਅੰਤ ਟੈਗ '%s' ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:277
+#, c-format
+msgid "Failed to decode certificate."
+msgstr "ਸਰਟੀਫਿਕੇਟ ਡੀਕੋਡ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto.c:286
+#, c-format
+msgid "Not enough memory to store certificate data."
+msgstr "ਸਰਟੀਫਿਕੇਟ ਡਾਟਾ ਸਟੋਰ ਕਰਨ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:294
+#, c-format
+msgid "Not enough memory to store file data."
+msgstr "ਫਾਇਲ ਡਾਟਾ ਸਟੋਰ ਕਰਨ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:324
+#, c-format
+msgid "IV must be an even number of bytes in length."
+msgstr "IV ਲਈ ਲੰਬਾਈ ਜਿਸਤ ਅੰਕ ਹੋਣੀ ਲਾਜ਼ਮੀ ਹੈ।"
+
+#: ../libnm-util/crypto.c:333
+#, c-format
+msgid "Not enough memory to store the IV."
+msgstr "IV ਸਟੋਰ ਕਰਨ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:344
+#, c-format
+msgid "IV contains non-hexadecimal digits."
+msgstr "IV ਵਿੱਚ ਗ਼ੈਰ-ਹੈਕਸਾਡੈਸੀਮਲ ਅੰਕ ਹਨ।"
+
+#: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
+#, c-format
+msgid "Private key cipher '%s' was unknown."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਸੀਫ਼ਰ '%s' ਅਣਜਾਣ ਹੈ।"
+
+#: ../libnm-util/crypto.c:391
+#, c-format
+msgid "Not enough memory to decrypt private key."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡੀਕੋਡ ਕਰਨ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto.c:511
+#, c-format
+msgid "Unable to determine private key type."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਕਿਸਮ ਜਾਣਨ ਲਈ ਅਸਮਰੱਥ ਹੈ।"
+
+#: ../libnm-util/crypto.c:530
+#, c-format
+msgid "Not enough memory to store decrypted private key."
+msgstr "ਡਿਕ੍ਰਿਪਟ ਕੀਤੀ ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਸਟੋਰ ਕਰਨ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto_gnutls.c:49
+msgid "Failed to initialize the crypto engine."
+msgstr "ਕ੍ਰਿਪਟੂ ਇੰਜਣ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_gnutls.c:93
+#, c-format
+msgid "Failed to initialize the MD5 engine: %s / %s."
+msgstr "MD5 ਇੰਜਣ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "ਅਢੁੱਕਵੀਂ IV ਲੰਬਾਈ (ਘੱਟੋ-ਘੱਟ %zd ਹੋਣੀ ਲਾਜ਼ਮੀ ਹੈ)।"
+
+#: ../libnm-util/crypto_gnutls.c:165 ../libnm-util/crypto_nss.c:188
+#, c-format
+msgid "Not enough memory for decrypted key buffer."
+msgstr "ਡੀਕ੍ਰਿਪਟ ਕੀਤੇ ਕੁੰਜੀ ਬਫ਼ਰ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/crypto_gnutls.c:173
+#, c-format
+msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgstr "ਡਿਕ੍ਰਿਪਸ਼ਨ ਸੀਫਰ ਪਰਸੰਗ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:182
+#, c-format
+msgid "Failed to set symmetric key for decryption: %s / %s."
+msgstr "ਡਿਕ੍ਰਿਪਸ਼ਨ ਲਈ ਸਮਮਿਤੀ ਕੁੰਜੀ ਸੈੱਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:191
+#, c-format
+msgid "Failed to set IV for decryption: %s / %s."
+msgstr "%s / %s : ਡਿਕ੍ਰਿਪਟ ਲਈ IV ਸੈੱਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_gnutls.c:200
+#, c-format
+msgid "Failed to decrypt the private key: %s / %s."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡਿਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡਿਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: ਅਣਜਾਣ ਪੈਡਿੰਗ ਲੰਬਾਈ।"
+
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
+#, c-format
+msgid "Failed to decrypt the private key."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡਿਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ"
+
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਲਈ ਮੈਮੋਰੀ ਜਾਰੀ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕੀ।"
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਸੀਫ਼ਰ ਪਰਸੰਗ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਲਈ ਸਮਮਿਤੀ ਕੁੰਜੀ ਸੈੱਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਲਈ IV ਸੈੱਟ ਕਰਨ ਵਾਸਤੇ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "ਡਾਟਾ ਡਿਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %s / %s"
+
+#: ../libnm-util/crypto_gnutls.c:362
+#, c-format
+msgid "Error initializing certificate data: %s"
+msgstr "ਸਰਟੀਫਿਕੇਟ ਡਾਟਾ ਸ਼ੁਰੂ 'ਚ ਗਲਤੀ: %s"
+
+#: ../libnm-util/crypto_gnutls.c:384
+#, c-format
+msgid "Couldn't decode certificate: %s"
+msgstr "ਸਰਟੀਫਿਕੇਟ ਡੀਕੋਡ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ: %s"
+
+#: ../libnm-util/crypto_gnutls.c:408
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %s"
+msgstr "PKCS#12 ਡੀਕੋਡਰ ਸ਼ੁਰੂ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ: %s"
+
+#: ../libnm-util/crypto_gnutls.c:421
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %s"
+msgstr "PKCS#12 ਫਾਇਲ ਡੀਕੋਡ ਨਹੀਂ ਜਾ ਸਕੀ: %s"
+
+#: ../libnm-util/crypto_gnutls.c:433
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %s"
+msgstr "PKCS#12 ਫਾਇਲ ਜਾਂਚੀ ਨਹੀਂ ਜਾ ਸਕੀ: %s"
+
+#: ../libnm-util/crypto_nss.c:56
+#, c-format
+msgid "Failed to initialize the crypto engine: %d."
+msgstr "ਕ੍ਰਿਪਟੂ ਇੰਜਣ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %d"
+
+#: ../libnm-util/crypto_nss.c:111
+#, c-format
+msgid "Failed to initialize the MD5 context: %d."
+msgstr "MD5 ਪਰਸੰਗ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %d"
+
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "ਅਢੁੱਕਵੀਂ IV ਲੰਬਾਈ (ਘੱਟੋ-ਘੱਟ %d ਹੋਣੀ ਲਾਜ਼ਮੀ ਹੈ)।"
+
+#: ../libnm-util/crypto_nss.c:196
+#, c-format
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "ਡਿਕ੍ਰਿਪਸ਼ਨ ਸੀਫਰ ਸਲਾਟ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_nss.c:206
+#, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "ਡਿਕ੍ਰਿਪਸ਼ਨ ਲਈ ਸਮਮਿਤੀ ਕੁੰਜੀ ਸੈੱਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
+msgid "Failed to set IV for decryption."
+msgstr "ਡਿਕ੍ਰਿਪਟ ਲਈ IV ਸੈੱਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_nss.c:224
+#, c-format
+msgid "Failed to initialize the decryption context."
+msgstr "ਡਿਕ੍ਰਿਪਸ਼ਨ ਪਰਸੰਗ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: "
+
+#: ../libnm-util/crypto_nss.c:237
+#, c-format
+msgid "Failed to decrypt the private key: %d."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡਿਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %d"
+
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜੀ ਡਿਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: ਡਿਕ੍ਰਿਪਟ ਡਾਟਾ ਬਹੁਤ ਵੱਡਾ ਹੈ।"
+
+#: ../libnm-util/crypto_nss.c:256
+#, c-format
+msgid "Failed to finalize decryption of the private key: %d."
+msgstr "ਪ੍ਰਾਈਵੇਟ ਕੁੰਜ ਲਈ ਡੀਕ੍ਰਿਪਸ਼ਨ ਮੁਕੰਮਲ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ: %d।"
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "ਕ੍ਰਿਪਸ਼ਨ ਸੀਫ਼ਰ ਸਲਾਟ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਲਈ ਸਮਮਿਤੀ ਕੁੰਜੀ ਸੈੱਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ।"
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਲਈ IV ਸੈੱਟ ਕਰਨ ਵਾਸਤੇ ਫੇਲ੍ਹ।"
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਪਰਸੰਗ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਫੇਲ੍ਹ ਹੈ।"
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "ਇੰਕ੍ਰਿਪਟ ਕਰਨ ਲਈ ਫੇਲ੍ਹ: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "ਇੰਕ੍ਰਿਪਟ ਕਰਨ ਦੇ ਬਾਅਦ ਅਚਾਨਕ ਅਣਜਾਣ ਮਾਤਰਾ 'ਚ ਡਾਟਾ।"
+
+#: ../libnm-util/crypto_nss.c:447
+#, c-format
+msgid "Couldn't decode certificate: %d"
+msgstr "ਸਰਟੀਫਿਕੇਟ ਡੀਕੋਡ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ: %d"
+
+#: ../libnm-util/crypto_nss.c:482
+#, c-format
+msgid "Couldn't convert password to UCS2: %d"
+msgstr "ਪਾਸਵਰਡ ਨੂੰ UCS2 'ਚ ਬਦਲਿਆ ਨਹੀਂ ਜਾ ਸਕਿਆ: %d"
+
+#: ../libnm-util/crypto_nss.c:510
+#, c-format
+msgid "Couldn't initialize PKCS#12 decoder: %d"
+msgstr "PKCS#12 ਡੀਕੋਡਰ ਸ਼ੁਰੂ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ: %d"
+
+#: ../libnm-util/crypto_nss.c:519
+#, c-format
+msgid "Couldn't decode PKCS#12 file: %d"
+msgstr "PKCS#12 ਫਾਇਲ ਜਾਂਚੀ ਨਹੀਂ ਜਾ ਸਕੀ: %d"
+
+#: ../libnm-util/crypto_nss.c:528
+#, c-format
+msgid "Couldn't verify PKCS#12 file: %d"
+msgstr "PKCS#12 ਫਾਇਲ ਜਾਂਚੀ ਨਹੀਂ ਜਾ ਸਕੀ: %d"
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "ਰਲਵਾਂ ਡਾਟਾ ਤਿਆਰ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਿਆ।"
+
+#: ../libnm-util/nm-utils.c:1802
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "ਇੰਕ੍ਰਿਪਸ਼ਨ ਕੁੰਜੀ ਬਣਾਉਣ ਲਈ ਲੋੜੀਦੀ ਮੈਮੋਰੀ ਨਹੀਂ ਹੈ।"
+
+#: ../libnm-util/nm-utils.c:1912
+msgid "Could not allocate memory for PEM file creation."
+msgstr "PEM ਫਾਇਲ ਬਣਾਉਣ ਲਈ ਮੈਮੋਰੀ ਜਾਰੀ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕੀ।"
+
+#: ../libnm-util/nm-utils.c:1924
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "PEM ਫਾਇਲ ਵਾਸਤੇ IV ਲਿਖਣ ਲਈ ਮੈਮੋਰੀ ਦਿੱਤੀ ਨਹੀਂ ਜਾ ਸਕੀ।"
+
+#: ../libnm-util/nm-utils.c:1936
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "PEM ਫਾਇਲ ਵਾਸਤੇ ਇੰਕ੍ਰਿਪਟ ਕੀਤੀ ਕੁੰਜੀ ਲਿਖਣ ਲਈ ਮੈਮੋਰੀ ਦਿੱਤੀ ਨਹੀਂ ਜਾ ਸਕੀ।"
+
+#: ../libnm-util/nm-utils.c:1955
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "PEM ਫਾਇਲ ਡਾਟੇ ਲਈ ਮੈਮੋਰੀ ਜਾਰੀ ਨਹੀਂ ਕੀਤੀ ਜਾ ਸਕੀ"
+
+#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
+#, c-format
+msgid "error processing netlink message: %s"
+msgstr "ਨੈੱਟਲਿੰਕ ਸੁਨੇਹੇ ਉੱਤੇ ਕਾਰਵਾਈ ਕਰਨ ਦੌਰਾਨ ਗਲਤੀ: %s"
+
+#: ../src/nm-netlink-monitor.c:260
+#, c-format
+#| msgid ""
+#| "unable to create netlink socket for monitoring wired ethernet devices - %s"
+msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgstr "ਲਿੰਕ ਹਾਲਤ ਦੀ ਨਿਗਰਾਨੀ ਲਈ ਨੈੱਟਲਿੰਕ ਜਾਰੀ ਕਰਨ ਲਈ ਅਸਮਰੱਥ: %s"
+
+#: ../src/nm-netlink-monitor.c:270
+#, c-format
+#| msgid ""
+#| "unable to bind to netlink socket for monitoring wired ethernet devices - %"
+#| "s"
+msgid "unable to connect to netlink for monitoring link status: %s"
+msgstr "ਲਿੰਕ ਹਾਲਤ ਦੀ ਨਿਗਰਾਨੀ ਲਈ ਨੈੱਟਲਿੰਕ ਨਾਲ ਕੁਨੈਕਟ ਕਰਨ ਲਈ ਅਸਮਰੱਥ: %s"
+
+#: ../src/nm-netlink-monitor.c:278
+#, c-format
+#| msgid ""
+#| "unable to bind to netlink socket for monitoring wired ethernet devices - %"
+#| "s"
+msgid "unable to join netlink group for monitoring link status: %s"
+msgstr "ਲਿੰਕ ਹਾਲਤ ਦੀ ਨਿਗਰਾਨੀ ਲਈ ਨੈੱਟਲਿੰਕ ਗਰੁੱਪ ਜੁਆਇੰਨ ਕਰਨ ਲਈ ਅਸਮਰੱਥ: %s"
+
+#: ../src/nm-netlink-monitor.c:286
+#, c-format
+#| msgid ""
+#| "unable to create netlink socket for monitoring wired ethernet devices - %s"
+msgid "unable to allocate netlink link cache for monitoring link status: %s"
+msgstr "ਲਿੰਕ ਹਾਲਤ ਦੀ ਨਿਗਰਾਨੀ ਲਈ ਨੈੱਟਲਿੰਕ ਲਿੰਕ ਕੈਸ਼ ਜਾਰੀ ਕਰਨ ਲਈ ਅਸਮਰੱਥ: %s"
+
+#: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
 msgstr "ਸਾਕਟ ਉੱਤੇ ਡਾਟੇ ਦੀ ਉਡੀਕ ਕਰਨ ਦੌਰਾਨ ਗਲਤੀ"
 
-#: ../src/nm-ap-security-wpa-eap.c:93 ../src/nm-ap-security-wpa-eap.c:117
-msgid "WPA2 Enterprise"
-msgstr "WPA2 ਇੰਟਰਪਰਾਈਸ"
+#: ../src/nm-netlink-monitor.c:558 ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "ਲਿੰਕ ਕੈਸ਼ ਅੱਪਡੇਟ ਕਰਨ ਦੌਰਾਨ ਗਲਤੀ: %s"
+
+#: ../src/main.c:494
+#, c-format
+msgid "Invalid option.  Please use --help to see a list of valid options.\n"
+msgstr "ਗਲਤ ਚੋਣ। ਢੁੱਕਵੀਆਂ ਚੋਣਾਂ ਵੇਖਣ ਲਈ --help ਵਰਤੋਂ ਜੀ।\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:324
+msgid "# Created by NetworkManager\n"
+msgstr "#ਨੈੱਟਵਰਕ ਮੈਨੇਜਰ ਵਲੋਂ ਬਣਾਈ\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:340
+#, c-format
+msgid ""
+"# Merged from %s\n"
+"\n"
+msgstr ""
+"#%s ਤੋਂ ਮਿਲਾਇਆ\n"
+"\n"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "ਕੋਈ ਵਰਤੋਂਯੋਗ DHCP ਕਲਾਇਟ ਨਹੀਂ ਲੱਭਿਆ ਜਾ ਸਕਿਆ।"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "'dhclient' ਲੱਭਿਆ ਜਾ ਸਕਿਆ।"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "'dhcpcd' ਲੱਭਿਆ ਜਾ ਸਕਿਆ।"
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "ਗੈਰਸਹਾਇਕ DHCP ਕਲਾਇਟ '%s'"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "netlink ਹੈੱਡਲ ਦੇਣ ਲਈ ਅਸਮਰੱਥ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "netlink ਨਾਲ ਕੁਨੈਕਟ ਹੋਣ ਲਈ ਅਸਮਰੱਥ: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "netlink ਗਰੁੱਪ ਜੁਆਇੰਨ ਕਰਨ ਲਈ ਅਣਸਮਰੱਥ:: %s"
+
+#: ../src/named-manager/nm-named-manager.c:315
+msgid "NOTE: the libc resolver may not support more than 3 nameservers."
+msgstr "ਨੋਟ: libc ਰਿਜ਼ੋਲਵਰ ੩ ਤੋਂ ਵੱਧ ਨੇਮ-ਸਰਵਰ ਲਈ ਸਹਾਇਕ ਨਹੀਂ ਹੋ ਸਕਦਾ ਹੈ।"
+
+#: ../src/named-manager/nm-named-manager.c:317
+msgid "The nameservers listed below may not be recognized."
+msgstr "ਹੇਠਾਂ ਦਿੱਤੇ ਨੇਮ-ਸਰਵਰ ਪਛਾਣੇ ਨਹੀਂ ਜਾ ਸਕਦੇ।"
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
+#, c-format
+msgid "Auto %s"
+msgstr "ਆਟੋ %s"
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
+msgid "System"
+msgstr "ਸਿਸਟਮ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
+msgid "Connection sharing via a protected WiFi network"
+msgstr "ਸੁਰੱਖਿਅਤ ਵਾਈ-ਫਾਈ ਨੈੱਟਵਰਕ ਰਾਹੀਂ ਕੁਨੈਕਸ਼ਨ ਸਾਂਝਾ ਕਰੋ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:2
+msgid "Connection sharing via an open WiFi network"
+msgstr "ਓਪਨ ਵਾਈ-ਫਾਈ ਨੈੱਟਵਰਕ ਰਾਹੀਂ ਕੁਨੈਕਸ਼ਨ ਸਾਂਝਾ ਕਰੋ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:3
+msgid "Modify persistent system hostname"
+msgstr "ਸਥਿਰ ਸਿਸਟਮ ਹੋਸਟ-ਨਾਂ ਸੋਧ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
+msgid "Modify system connections"
+msgstr "ਸਿਸਟਮ ਕੁਨੈਸ਼ਨ ਸੋਧ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:5
+msgid "System policy prevents modification of system settings"
+msgstr "ਸਿਸਟਮ ਪਾਲਸੀ ਸਿਸਟਮ ਸੈਟਿੰਗ ਲਈ ਸੋਧ ਤੋਂ ਰੋਕਦੀ ਹੈ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
+msgid "System policy prevents modification of the persistent system hostname"
+msgstr "ਸਿਸਟਮ ਪਾਲਸੀ ਸਥਿਰ ਸਿਸਟਮ ਹੋਸਟ-ਨਾਂ ਲਈ ਸੋਧਾਂ ਤੋਂ ਰੋਕਦੀ ਹੈ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:7
+msgid "System policy prevents sharing connections via a protected WiFi network"
+msgstr ""
+"ਸਿਸਟਮ ਪਾਲਸੀ ਕੁਨੈਕਸ਼ਨ ਨੂੰ ਸੁਰੱਖਿਅਤ ਵਾਈ-ਫਾਈ ਨੈੱਟਵਰਕ ਰਾਹੀਂ ਸਾਂਝਾ ਕਰਨ ਤੋਂ ਰੋਕਦੀ "
+"ਹੈ"
+
+#: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
+msgid "System policy prevents sharing connections via an open WiFi network"
+msgstr ""
+"ਸਿਸਟਮ ਪਾਲਸੀ ਕੁਨੈਕਸ਼ਨ ਨੂੰ ਓਪਨ ਵਾਈ-ਫਾਈ ਨੈੱਟਵਰਕ ਰਾਹੀਂ ਸਾਂਝਾ ਕਰਨ ਤੋਂ ਰੋਕਦੀ ਹੈ"
+
+#~ msgid "Cannot add VPN connection"
+#~ msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਜੋੜਿਆ ਨਹੀਂ ਜਾ ਸਕਦਾ ਹੈ"
+
+#~ msgid ""
+#~ "No suitable VPN software was found on your system. Contact your system "
+#~ "administrator."
+#~ msgstr ""
+#~ "ਤੁਹਾਡੇ ਸਿਸਟਮ ਉੱਤੇ ਕੋਈ ਠੀਕ VPN ਸਾਫਟਵੇਅਰ ਨਹੀਂ ਲੱਭਾ ਹੈ। ਆਪਣੇ ਸਿਸਟਮ ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰੋ।"
+
+#~ msgid "Cannot import VPN connection"
+#~ msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਆਯਾਤ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਦਾ"
+
+#~ msgid ""
+#~ "Cannot find suitable software for VPN connection type '%s' to import the "
+#~ "file '%s'. Contact your system administrator."
+#~ msgstr ""
+#~ "VPN ਕੁਨੈਕਸ਼ਨ ਕਿਸਮ '%s' ਲਈ ਫਾਇਲ '%s' ਆਯਾਤ ਕਰਨ ਲਈ ਕੋਈ ਢੁੱਕਵਾਂ ਸਾਫਟਵੇਅਰ ਨਹੀਂ ਲੱਭਿਆ ਹੈ। "
+#~ "ਆਪਣੇ ਸਿਸਟਮ ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰੋ।"
+
+#~ msgid ""
+#~ "Could not find the UI files for VPN connection type '%s'. Contact your "
+#~ "system administrator."
+#~ msgstr ""
+#~ "VPN ਕੁਨੈਕਸ਼ਨ ਕਿਸਮ '%s' ਲਈ UI ਫਾਇਲਾਂ ਨਹੀਂ ਲੱਭੀਆਂ ਹਨ। ਆਪਣੇ ਸਿਸਟਮ ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰੋ।"
+
+#~ msgid "Delete VPN connection \"%s\"?"
+#~ msgstr "ਕੀ VPN \"%s\" ਕੁਨੈਕਸ਼ਨ ਹਟਾਉਣਾ ਹੈ?"
+
+#~ msgid ""
+#~ "All information about the VPN connection \"%s\" will be lost and you may "
+#~ "need your system administrator to provide information to create a new "
+#~ "connection."
+#~ msgstr ""
+#~ "VPN ਕੁਨੈਕਸ਼ਨ \"%s\" ਬਾਰੇ ਸਭ ਜਾਣਕਾਰੀ ਖਤਮ ਹੋ ਗਈ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਨਵੇਂ ਕੁਨੈਕਸ਼ਨ ਬਣਾਉਣ ਲਈ "
+#~ "ਜਾਣਕਾਰੀ ਵਾਸਤੇ ਆਪਣੇ ਸਿਸਟਮ ਪਰਸ਼ਾਸ਼ਕ ਨਾਲ ਸੰਪਰਕ ਕਰਨਾ ਪਵੇਗਾ।"
+
+#~ msgid "Unable to load"
+#~ msgstr "ਲੋਡ ਕਰਨ ਲਈ ਫੇਲ੍ਹ"
+
+#~ msgid "Cannot find some needed resources (the glade file)!"
+#~ msgstr "ਕੁਝ ਲੋੜੀਦੇ ਸਰੋਤ ਨਹੀਂ ਮਿਲੇ (ਗਲੇਡ ਫਾਇਲ)!"
+
+#~ msgid "Create VPN Connection"
+#~ msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਬਣਾਓ"
+
+#~ msgid "Edit VPN Connection"
+#~ msgstr "VPN ਕੁਨੈਕਸ਼ਨ ਸੋਧ"
+
+#~ msgid "Add a new VPN connection"
+#~ msgstr "ਇੱਕ ਨਵਾਂ VPN ਕੁਨੈਕਸ਼ਨ ਸ਼ਾਮਿਲ"
+
+#~ msgid "Delete the selected VPN connection"
+#~ msgstr "ਚੁਣਿਆ VPN ਕੁਨੈਕਸ਼ਨ ਹਟਾਓ"
+
+#~ msgid "E_xport"
+#~ msgstr "ਨਿਰਯਾਤ(_x)"
+
+#~ msgid "Edit the selected VPN connection"
+#~ msgstr "ਚੁਣੇ VPN ਕੁਨੈਕਸ਼ਨ 'ਚ ਸੋਧ"
+
+#~ msgid "Export the VPN settings to a file"
+#~ msgstr "VPN ਸੈਟਿੰਗ ਨੂੰ ਫਾਇਲ 'ਚ ਭੇਜੋ"
+
+#~ msgid "Export the selected VPN connection to a file"
+#~ msgstr "ਚੁਣੇ VPN ਕੁਨੈਕਸ਼ਨ ਫਾਇਲ 'ਚ ਭੇਜੋ"
+
+#~ msgid "Manage Virtual Private Network Connections"
+#~ msgstr "ਵੁਰਚੁਅਲ ਪ੍ਰਾਈਵੇਟ ਨੈੱਟਵਰਕ ਕੁਨੈਕਸ਼ਨ ਪਰਬੰਧ"
+
+#~ msgid "40-bit WEP"
+#~ msgstr "40-ਬਿੱਟ WEP"
+
+#~ msgid "104-bit WEP"
+#~ msgstr "104-ਬਿੱਟ WEP"
+
+#~ msgid "WPA TKIP"
+#~ msgstr "WPA TKIP"
+
+#~ msgid "WPA CCMP"
+#~ msgstr "WPA CCMP"
+
+#~ msgid "WPA Automatic"
+#~ msgstr "WPA ਆਟੋਮੈਟਿਕ"
+
+#~ msgid "WPA2 TKIP"
+#~ msgstr "WPA2 TKIP"
+
+#~ msgid "WPA2 CCMP"
+#~ msgstr "WPA2 CCMP"
+
+#~ msgid "WPA2 Automatic"
+#~ msgstr "WPA2 ਆਟੋਮੈਟਿਕ"
+
+#~ msgid "operation took too long"
+#~ msgstr "ਓਪਰੇਸ਼ਨ ਨੂੰ ਬਹੁਤ ਸਮਾਂ ਲੱਗ ਗਿਆ"
+
+#~ msgid "received data from wrong type of sender"
+#~ msgstr "ਭੇਜਣ ਵਾਲੇ ਦੀ ਗਲਤ ਕਿਸਮ ਤੋਂ ਡਾਟਾ ਮਿਲਿਆ"
 
-#: ../src/nm-ap-security-wpa-eap.c:95 ../src/nm-ap-security-wpa-eap.c:122
-msgid "WPA Enterprise"
-msgstr "WPA ਇੰਟਰਪਰਾਈਸ"
+#~ msgid "received data from unexpected sender"
+#~ msgstr "ਅਣਜਾਣ ਭੇਜਣ ਵਾਲੇ ਵਲੋਂ ਡਾਟਾ ਮਿਲਿਆ"
 
-#: ../src/nm-ap-security-leap.c:66 ../src/nm-ap-security-leap.c:82
-msgid "LEAP"
-msgstr "LEAP"
+#~ msgid "too much data was sent over socket and some of it was lost"
+#~ msgstr "ਸਾਕਟ ਉੱਤੇ ਬਹੁਤ ਵੱਧ ਡਾਟਾ ਭੇਜਿਆ ਗਿਆ ਅਤੇ ਇਸ 'ਚੋਂ ਕੁਝ ਗੁੰਮ ਹੋ ਗਿਆ"
 
+#~ msgid "LEAP"
+#~ msgstr "LEAP"
diff --git a/po/pl.po b/po/pl.po
index bcee37a..7ffa179 100644
--- a/po/pl.po
+++ b/po/pl.po
@@ -8,9 +8,9 @@ msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-08-27 03:24+0000\n"
-"PO-Revision-Date: 2009-09-09 01:47+0200\n"
-"Last-Translator: Piotr Drąg <piotrdrag@gmail.com>\n"
+"POT-Creation-Date: 2010-02-26 03:24+0000\n"
+"PO-Revision-Date: 2010-03-08 11:52+0100\n"
+"Last-Translator: Tomasz Dominikowski <dominikowski@gmail.com>\n"
 "Language-Team: Polish <gnomepl@aviary.pl>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -19,6 +19,1076 @@ msgstr ""
 "X-Poedit-Language: Polish\n"
 "X-Poedit-Country: Poland\n"
 
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout <timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Użycie: nmcli con { POLECENIE | help }\n"
+"  POLECENIE := { list | status | up | down }\n"
+"\n"
+"  list [id <identyfikator> | uuid <identyfikator> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <interfejs>] [ap <adres_sprzętowy>] [--nowait] [--timeout <czas>]\n"
+"  down id <identyfikator> | uuid <identyfikator>\n"
+
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "Połączenia"
+
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Nazwa"
+
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "Połączenia systemowe:\n"
+
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "Połączenia użytkownika:\n"
+
+
+#: ../cli/src/connections.c:178
+#: ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983
+#: ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003
+#: ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604
+#: ../cli/src/devices.c:614
+#: ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785
+#: ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Błąd: brak parametru %s."
+
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Błąd: %s - nie ma takiego połączenia."
+
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "Połączenia systemowe"
+
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "Połączenia użytkownika"
+
+
+#: ../cli/src/connections.c:212
+#: ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103
+#: ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494
+#: ../cli/src/devices.c:628
+#: ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Nieznany parametr: %s\n"
+
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Błąd: nie podano prawidłowego parametru."
+
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321
+#: ../cli/src/devices.c:353
+#: ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357
+#: ../cli/src/devices.c:359
+#: ../cli/src/devices.c:361
+msgid "yes"
+msgstr "tak"
+
+
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:304
+msgid "no"
+msgstr "nie"
+
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "Aktywne połączenia"
+
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Domyślne"
+
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Usługa"
+
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Urządzenia"
+
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "brak aktywnych połączeń na urządzeniu \"%s\""
+
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "brak aktywnych połączeń na urządzeń"
+
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktywowanie"
+
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktywowano"
+
+
+#: ../cli/src/connections.c:735
+#: ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791
+#: ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76
+#: ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "nieznane"
+
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "Łączenie z VPN (przygotowanie)"
+
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "Łączenie z VPN (wymaga uwierzytelnienia)"
+
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "Łączenie z VPN"
+
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "Łączenie z VPN (pobieranie konfiguracji adresu IP)"
+
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "Połączono z VPN"
+
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "Połączenie z VPN się nie powiodło"
+
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "Rozłączono z VPN"
+
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "nieznany powód"
+
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "brak"
+
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "użytkownik został rozłączony"
+
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "podstawowe połączenie sieciowe zostało przerwane"
+
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "usługa VPN została nieoczekiwanie zatrzymana"
+
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "usługa VPN zwróciła nieprawidłową konfigurację"
+
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "próba połączenia przekroczyła czas oczekiwania"
+
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "usługa VPN nie została uruchomiona w czasie"
+
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "uruchomienie usługi VPN się nie powiodło"
+
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "brak prawidłowych haseł VPN"
+
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "nieprawidłowe hasła VPN"
+
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "połączenie zostało usunięte"
+
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "stan: %s\n"
+
+
+#: ../cli/src/connections.c:806
+#: ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "Aktywowano połączenie\n"
+
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "Błąd: aktywacja połączenia się nie powiodła."
+
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "stan: %s (%d)\n"
+
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Błąd: aktywacja połączenia się nie powiodła: %s."
+
+
+#: ../cli/src/connections.c:855
+#: ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Błąd: przekroczono czas oczekiwania o %d sekund."
+
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Błąd: aktywacja połączenia się nie powiodła: %s"
+
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Błąd: uzyskanie aktywnego połączenia dla \"%s\" się nie powiodło."
+
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "Stan aktywnego połączenia: %s\n"
+
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "Ścieżka aktywnego połączenia: %s\n"
+
+
+#: ../cli/src/connections.c:976
+#: ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Błąd: nieznane połączenie: %s."
+
+
+#: ../cli/src/connections.c:1011
+#: ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Błąd: wartość czasu oczekiwania \"%s\" jest nieprawidłowa."
+
+
+#: ../cli/src/connections.c:1024
+#: ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Błąd: należy podać identyfikator lub UUID."
+
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Błąd: nie odnaleziono odpowiedniego urządzenia: %s"
+
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Błąd: nie odnaleziono odpowiedniego urządzenia."
+
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Ostrzeżenie: połączenie nie jest aktywne\n"
+
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Błąd: polecenie \"con\" \"%s\" jest nieprawidłowe."
+
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Błąd: nie można połączyć się z D-Bus."
+
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Błąd: nie można uzyskać ustawień systemu."
+
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Błąd: nie można uzyskać ustawień użytkownika."
+
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Błąd: nie można uzyskać połączeń: usługi ustawień nie są uruchomione."
+
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Użycie: nmcli dev { POLECENIE | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <interfejs>]\n"
+"  disconnect iface <interfejs> [--nowait] [--timeout <czas>]\n"
+"  wifi [list [iface <interfejs>] | apinfo iface <interfejs> hwaddr <adres_sprzętowy>]\n"
+"\n"
+
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "niezarządzane"
+
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "niedostępne"
+
+
+#: ../cli/src/devices.c:97
+#: ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "rozłączono"
+
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "łączenie (przygotowanie)"
+
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "łączenie (konfigurowanie)"
+
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "łączenie (wymaga uwierzytelnienia)"
+
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "łączenie (pobieranie konfiguracji adresu IP)"
+
+
+#: ../cli/src/devices.c:107
+#: ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "połączono"
+
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "połączenie się nie powiodło"
+
+
+#: ../cli/src/devices.c:132
+#: ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Nieznane"
+
+
+#. print them
+#: ../cli/src/devices.c:164
+#: ../cli/src/devices.c:266
+#: ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(brak)"
+
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: błąd podczas konwertowania adresu IPv4 0x%X"
+
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, częstotliwość %d MHz, prędkość %d Mb/s, siła sygnału %d"
+
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-hoc"
+
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", zaszyfrowane: "
+
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Enterprise"
+
+
+#: ../cli/src/devices.c:294
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Urządzenie"
+
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Sterownik"
+
+
+#: ../cli/src/devices.c:299
+#: ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(nieznane)"
+
+
+#: ../cli/src/devices.c:300
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "State"
+msgstr "Stan"
+
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Adres sprzętowy"
+
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Możliwości:\n"
+
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Wykrywanie operatora"
+
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Prędkość"
+
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  Właściwości sieci bezprzewodowej\n"
+
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "Szyfrowanie WEP"
+
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "Szyfrowanie WPA"
+
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "Szyfrowanie WPA2"
+
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "Szyfr TKIP"
+
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "Szyfr CCMP"
+
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Bezprzewodowe punkty dostępowe %s\n"
+
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = bieżący punkt dostępowy)"
+
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Właściwości sieci przewodowej\n"
+
+
+#: ../cli/src/devices.c:377
+#: ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Operator"
+
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "włączone"
+
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "wyłączone"
+
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  Ustawienia IPv4:\n"
+
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adres"
+
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Przedrostek"
+
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Brama"
+
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Stan urządzenia"
+
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Błąd: brak parametru \"%s\"."
+
+
+#: ../cli/src/devices.c:516
+#: ../cli/src/devices.c:655
+#: ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Błąd: nie odnaleziono urządzenia \"%s\"."
+
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Powodzenie: urządzenie \"%s\" zostało rozłączone."
+
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Błąd: rozłączenie urządzenia \"%s\" (%s) się nie powiodło: %s"
+
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Stan urządzenia: %d (%s)\n"
+
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Błąd: należy podać interfejs."
+
+
+#: ../cli/src/devices.c:736
+#: ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "Lista skanowania sieci WiFi"
+
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Błąd: urządzenie \"%s\" nie jest urządzeniem WiFi."
+
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Urządzenie:"
+
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Błąd: należy podać adres sprzętowy."
+
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Błąd: nie odnaleziono punktu dostępowego z adresem sprzętowym \"%s\"."
+
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+
+#: ../cli/src/devices.c:869
+#: ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "Parametry punkty dostępowego"
+
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Częstotliwość:"
+
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Tryb:"
+
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastruktura"
+
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Maksymalna prędkość:"
+
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Siła sygnału:"
+
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Flagi:"
+
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "prywatne"
+
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "Flagi WPA:"
+
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "Flagi RSN:"
+
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Błąd: polecenie \"dev wifi\" \"%s\" jest nieprawidłowe."
+
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Błąd: polecenie \"dev\" \"%s\" jest nieprawidłowe."
+
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Użycie: nmcli nm { POLECENIE | help }\n"
+"\n"
+"  POLECENIE := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "wstrzymane"
+
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "łączenie"
+
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "włączone"
+
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "wyłączone"
+
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "Stan programu NetworkManager"
+
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "Program NetworkManager jest uruchomiony:"
+
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "uruchamiany"
+
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "nieuruchomiony"
+
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "Stan programu NetworkManager:"
+
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "Adres sprzętowy programu NetworkManager:"
+
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107
+#: ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "Sieć bezprzewodowa programu NetworkManager:"
+
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "WWAM sprzętu programu NetworkManager:"
+
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109
+#: ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "WWAN programu NetworkManager:"
+
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Błąd: nieprawidłowy parametr \"wifi\": \"%s\"."
+
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Błąd: nieprawidłowy parametr \"wwan\": \"%s\"."
+
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Błąd: parametr \"nm\" \"%s\" jest nieprawidłowy."
+
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Użycie: %s [OPCJE] OBIEKT { POLECENIE | help }\n"
+"\n"
+"OPCJE\n"
+"  -t[erse]    zwięzłe wyjście\n"
+"  -p[retty]   sformatowane wyjście\n"
+"  -v[ersion]  wyświetla wersję programu\n"
+"  -h[elp]     wyświetla tę opcję\n"
+"\n"
+"OBIEKT\n"
+"  nm          stan programu NetworkManager\n"
+"  con         połączenia programu NetworkManager\n"
+"  dev         urządzenia zarządzane przez program NetworkManager\n"
+"\n"
+
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Obiekt \"%s\" jest nieznany. Można spróbować polecenie \"nmcli help\"."
+
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "narzędzie nmcli, wersja %s\n"
+
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Opcja \"%s\" jest nieznana. Można spróbować polecenie \"nmcli help\"."
+
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Przechwycono sygnał %d, wyłączanie..."
+
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Błąd: nie można połączyć się z programem NetworkManager."
+
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Powodzenie"
+
+
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -29,10 +1099,11 @@ msgstr "Plik klucza PEM nie zawiera znacznika końcowego \"%s\"."
 msgid "Doesn't look like a PEM private key file."
 msgstr "Nie wygląda na plik klucza prywatnego PEM."
 
+
 #: ../libnm-util/crypto.c:138
 #, c-format
 msgid "Not enough memory to store PEM file data."
-msgstr "Brak wystarczającej ilości pamięci do przechowania danych PEM."
+msgstr "Brak wystarczającej ilości pamięci do przechowania danych pliku PEM."
 
 #: ../libnm-util/crypto.c:154
 #, c-format
@@ -57,7 +1128,7 @@ msgstr "Uszkodzony plik PEM: brak IV w znaczniku DEK-Info."
 #: ../libnm-util/crypto.c:190
 #, c-format
 msgid "Malformed PEM file: invalid format of IV in DEK-Info tag."
-msgstr "Uszkodzony plik PEM: niepoprawny format IV w znaczniku DEK-Info."
+msgstr "Uszkodzony plik PEM: nieprawidłowy format IV w znaczniku DEK-Info."
 
 #: ../libnm-util/crypto.c:203
 #, c-format
@@ -67,17 +1138,18 @@ msgstr "Uszkodzony plik PEM: nieznany szyfr klucza prywatnego: \"%s\"."
 #: ../libnm-util/crypto.c:222
 #, c-format
 msgid "Could not decode private key."
-msgstr "Nie można było zdekodować klucza prywatnego."
+msgstr "Nie można zdekodować klucza prywatnego."
 
 #: ../libnm-util/crypto.c:267
 #, c-format
 msgid "PEM certificate '%s' had no end tag '%s'."
 msgstr "Certyfikat PEM \"%s\" nie zawiera kończącego znacznika \"%s\"."
 
+
 #: ../libnm-util/crypto.c:277
 #, c-format
 msgid "Failed to decode certificate."
-msgstr "Nieudane zdekodowanie certyfikatu."
+msgstr "Zdekodowanie certyfikatu się nie powiodło."
 
 #: ../libnm-util/crypto.c:286
 #, c-format
@@ -89,24 +1161,28 @@ msgstr "Brak wystarczającej ilości pamięci do przechowania danych certyfikatu
 msgid "Not enough memory to store file data."
 msgstr "Brak wystarczającej ilości pamięci do przechowania danych pliku."
 
+
 #: ../libnm-util/crypto.c:324
 #, c-format
 msgid "IV must be an even number of bytes in length."
-msgstr "Ilość bajtów w IV musi być parzystą liczbą."
+msgstr "Liczba bajtów w IV musi być liczbą parzystą."
 
 #: ../libnm-util/crypto.c:333
 #, c-format
 msgid "Not enough memory to store the IV."
 msgstr "Brak wystarczającej ilości pamięci do przechowania IV."
 
+
 #: ../libnm-util/crypto.c:344
 #, c-format
 msgid "IV contains non-hexadecimal digits."
-msgstr "IV zawiera nie-szesnastkowe cyfry."
+msgstr "IV zawiera nieszesnastkowe cyfry."
 
 #: ../libnm-util/crypto.c:382
-#: ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266
+#: ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Nieznany szyfr klucza prywatnego \"%s\"."
@@ -116,187 +1192,353 @@ msgstr "Nieznany szyfr klucza prywatnego \"%s\"."
 msgid "Not enough memory to decrypt private key."
 msgstr "Brak wystarczającej ilości pamięci do odszyfrowania klucza prywatnego."
 
+
 #: ../libnm-util/crypto.c:511
 #, c-format
 msgid "Unable to determine private key type."
-msgstr "Nieudane określenie typu klucza prywatnego."
+msgstr "Nie można określić typu klucza prywatnego."
 
 #: ../libnm-util/crypto.c:530
 #, c-format
 msgid "Not enough memory to store decrypted private key."
 msgstr "Brak wystarczającej ilości pamięci do przechowania odszyfrowanego klucza prywatnego."
 
-#: ../libnm-util/crypto_gnutls.c:46
+
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
-msgstr "Nieudana inicjacja modułu szyfrowania."
+msgstr "Zainicjowanie modułu szyfrowania się nie powiodło."
+
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
-msgstr "Nieudana inicjacja modułu MD5: %s / %s."
+msgstr "Zainicjowanie modułu MD5 się nie powiodło: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152
-#: ../libnm-util/crypto_nss.c:178
+
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Nieprawidłowa długość IV (musi wynosić co najmniej %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165
+#: ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "Brak wystarczającej ilości pamięci dla bufora odszyfrowanego klucza."
 
-#: ../libnm-util/crypto_gnutls.c:160
+
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
-msgstr "Nieudana inicjacja kontekstu szyfru do odszyfrowania: %s / %s."
+msgstr "Zainicjowanie kontekstu szyfru do odszyfrowania się nie powiodło: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
-msgstr "Nieudane ustawienie klucza symetrycznego do odszyfrowania: %s / %s."
+msgstr "Ustawienie klucza symetrycznego do odszyfrowania się nie powiodło: %s / %s."
+
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
-msgstr "Nieudane ustawienie IV do odszyfrowania: %s / %s."
+msgstr "Ustawienie IV do odszyfrowania się nie powiodło: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
-msgstr "Nieudane odszyfrowanie klucza prywatnego: %s / %s."
+msgstr "Odszyfrowanie klucza prywatnego się nie powiodło: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+
+#: ../libnm-util/crypto_gnutls.c:210
+#: ../libnm-util/crypto_nss.c:267
+#, c-format
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Odszyfrowanie klucza prywatnego się nie powiodło: nieoczekiwana długość wypełnienia."
+
+
+#: ../libnm-util/crypto_gnutls.c:221
+#: ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
-msgstr "Nieudane odszyfrowanie klucza prywatnego."
+msgstr "Odszyfrowanie klucza prywatnego się nie powiodło."
+
+
+#: ../libnm-util/crypto_gnutls.c:286
+#: ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Nie można przydzielić pamięci do szyfrowania."
+
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Zainicjowanie kontekstu szyfru do szyfrowania się nie powiodło: %s / %s."
+
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Ustawienie klucza symetrycznego do szyfrowania się nie powiodło: %s / %s."
+
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Ustawienie IV do szyfrowania się nie powiodło: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:235
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Zaszyfrowanie danych się nie powiodło: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Błąd podczas inicjowania danych certyfikatu: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
-msgstr "Nie można było zdekodować certyfikatu: %s"
+msgstr "Nie można zdekodować certyfikatu: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "Nie można zainicjować dekodera PKCS#12: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
-msgstr "Nie można było odszyfrować pliku PKCS#12: %s"
+msgstr "Nie można odszyfrować pliku PKCS#12: %s"
+
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
-msgstr "Nie można było zweryfikować pliku PKCS#12: %s"
+msgstr "Nie można zweryfikować pliku PKCS#12: %s"
 
-#: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
+
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
-msgstr "Nieudana inicjacja modułu szyfrowania: %d."
+msgstr "Zainicjowanie modułu szyfrowania się nie powiodło: %d."
+
 
 #: ../libnm-util/crypto_nss.c:111
 #, c-format
 msgid "Failed to initialize the MD5 context: %d."
-msgstr "Nieudana inicjacja kontekstu MD5: %d."
+msgstr "Zainicjowanie kontekstu MD5 się nie powiodło: %d."
 
-#: ../libnm-util/crypto_nss.c:186
+
+#: ../libnm-util/crypto_nss.c:179
 #, c-format
-msgid "Failed to initialize the decryption cipher slot."
-msgstr "Nieudana inicjacja slotu szyfru do odszyfrowania."
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Nieprawidłowa długość IV (musi wynosić co najmniej %d)."
+
 
 #: ../libnm-util/crypto_nss.c:196
 #, c-format
-msgid "Failed to set symmetric key for decryption."
-msgstr "Nieudane ustawienie klucza symetrycznego do odszyfrowania."
+msgid "Failed to initialize the decryption cipher slot."
+msgstr "Zainicjowanie gniazda szyfru do odszyfrowania się nie powiodło."
+
 
 #: ../libnm-util/crypto_nss.c:206
 #, c-format
+msgid "Failed to set symmetric key for decryption."
+msgstr "Ustawienie klucza symetrycznego do odszyfrowania się nie powiodło."
+
+
+#: ../libnm-util/crypto_nss.c:216
+#, c-format
 msgid "Failed to set IV for decryption."
-msgstr "Nieudane ustawienie IV do odszyfrowania."
+msgstr "Ustawienie IV do odszyfrowania się nie powiodło."
+
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
-msgstr "Nieudana inicjacja kontekstu odszyfrowania."
+msgstr "Zainicjowanie kontekstu odszyfrowania się nie powiodło."
 
-#: ../libnm-util/crypto_nss.c:227
+
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
-msgstr "Nieudane odszyfrowanie klucza prywatnego: %d."
+msgstr "Odszyfrowanie klucza prywatnego się nie powiodło: %d."
+
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Odszyfrowanie klucza prywatnego się nie powiodło: odszyfrowane dane są za duże."
+
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
-msgstr "Nieudane ukończenie odszyfrowania klucza prywatnego: %d."
+msgstr "Zakończenie odszyfrowania klucza prywatnego się nie powiodło: %d."
+
+
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Zainicjowanie gniazda szyfru do szyfrowania się nie powiodło."
+
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+msgid "Failed to set symmetric key for encryption."
+msgstr "Ustawienie klucza symetrycznego do szyfrowania się nie powiodło."
+
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+msgid "Failed to set IV for encryption."
+msgstr "Ustawienie IV do szyfrowania się nie powiodło."
 
-#: ../libnm-util/crypto_nss.c:284
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+msgid "Failed to initialize the encryption context."
+msgstr "Zainicjowanie kontekstu szyfrowania się nie powiodło."
+
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+msgid "Failed to encrypt: %d."
+msgstr "Zaszyfrowanie się nie powiodło: %d."
+
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Nieoczekiwana ilość danych po zaszyfrowaniu."
+
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
-msgstr "Nie można było zdekodować certyfikatu: %d"
+msgstr "Nie można zdekodować certyfikatu: %d"
+
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
-msgstr "Nie można skonwertować hasła do UCS2: %d"
+msgstr "Nie można przekonwertować hasła do UCS2: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "Nie można zainicjować dekodera PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
-msgstr "Nie można było odszyfrować pliku PKCS#12: %d"
+msgstr "Nie można odszyfrować pliku PKCS#12: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
-msgstr "Nie można było zweryfikować pliku PKCS#12: %d"
+msgstr "Nie można zweryfikować pliku PKCS#12: %d"
+
+
+#: ../libnm-util/crypto_nss.c:557
+msgid "Could not generate random data."
+msgstr "Nie można utworzyć losowych danych."
+
+
+#: ../libnm-util/nm-utils.c:1545
+#, c-format
+msgid "Not enough memory to make encryption key."
+msgstr "Brak wystarczającej ilości pamięci, aby utworzyć klucz szyfrowania."
+
+
+#: ../libnm-util/nm-utils.c:1655
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Nie można przydzielić pamięci do utworzenia pliku PEM."
+
+
+#: ../libnm-util/nm-utils.c:1667
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Nie można przydzielić pamięci do zapisywania IV do pliku PEM."
+
+
+#: ../libnm-util/nm-utils.c:1679
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Nie można przydzielić pamięci do zapisywania zaszyfrowanego klucza do pliku PEM."
+
+
+#: ../libnm-util/nm-utils.c:1698
+#, c-format
+msgid "Could not allocate memory for PEM file data."
+msgstr "Nie można przydzielić pamięci dla danych pliku PEM."
 
 #: ../src/nm-netlink-monitor.c:194
 #: ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "błąd podczas przetwarzania komunikatu netlink: %s"
 
+
 #: ../src/nm-netlink-monitor.c:260
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
-msgstr "nie można utworzyć uchwytu netlink dla monitorowania statusu połączenia: %s"
+msgstr "nie można przydzielić uchwytu netlink dla monitorowania stanu połączenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:270
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
-msgstr "nie można połączyć się z netlink dla monitorowania statusu połączenia: %s"
+msgstr "nie można połączyć się z netlink dla monitorowania stanu połączenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:278
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
-msgstr "nie można dołączyć do grupy netlink dla monitorowania statusu połączenia: %s"
+msgstr "nie można dołączyć do grupy netlink dla monitorowania stanu połączenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:286
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
-msgstr "nie można utworzyć buforów połączenia netlink dla monitorowania statusu połączenia: %s"
+msgstr "nie można przydzielić pamięci podręcznej połączenia netlink dla monitorowania stanu połączenia: %s"
+
 
 #: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
-msgstr "napotkano błąd podczas oczekiwania na dane"
+msgstr "wystąpił błąd podczas oczekiwania na dane na gnieździe"
+
+
+#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "błąd podczas aktualizowania pamięci podręcznej połączenia: %s"
 
-#: ../src/NetworkManager.c:330
+
+#: ../src/NetworkManager.c:494
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
-msgstr "Błędna opcja. Parametr --help wyświetla listę poprawnych opcji.\n"
+msgstr "Nieprawidłowa opcja. Parametr --help wyświetli listę prawidłowych opcji.\n"
+
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
 msgid "# Created by NetworkManager\n"
-msgstr "# Utworzony przez NetworkManager\n"
+msgstr "# Utworzony przez program NetworkManager\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -305,6 +1547,22 @@ msgstr ""
 "# Scalony od %s\n"
 "\n"
 
+
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+msgid "unable to allocate netlink handle: %s"
+msgstr "nie można przydzielić uchwytu netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+msgid "unable to connect to netlink: %s"
+msgstr "nie można połączyć się z netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+msgid "unable to join netlink group: %s"
+msgstr "nie można dołączyć do grupy netlink: %s"
+
 #: ../src/named-manager/nm-named-manager.c:315
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
 msgstr "UWAGA: obsługa nazw libc nie obsługuje więcej niż 3 serwery nazw."
@@ -313,14 +1571,16 @@ msgstr "UWAGA: obsługa nazw libc nie obsługuje więcej niż 3 serwery nazw."
 msgid "The nameservers listed below may not be recognized."
 msgstr "Poniższe serwery nazw nie mogą nie zostać rozpoznane."
 
-#: ../src/system-settings/nm-default-wired-connection.c:194
+
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
-msgstr "Auto %s"
+msgstr "Automatyczne %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2446
+
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
 msgid "System"
-msgstr "System"
+msgstr "Systemowe"
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:1
 msgid "Connection sharing via a protected WiFi network"
@@ -353,3 +1613,4 @@ msgstr "Polityka systemu powstrzymuje współdzielenie połączeń przez chronio
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
 msgid "System policy prevents sharing connections via an open WiFi network"
 msgstr "Polityka systemu powstrzymuje współdzielenie połączeń przez otwartą sieć WiFi"
+
diff --git a/po/sv.po b/po/sv.po
index f8f2d2b..d9d9147 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -1,7 +1,7 @@
 # Swedish messages for NetworkManager.
-# Copyright (C) 2004, 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 2004, 2005, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 # Christian Rose <menthos@menthos.com>, 2004, 2005, 2006.
-# Daniel Nylander <po@danielnylander.se>, 2006, 2008, 2009.
+# Daniel Nylander <po@danielnylander.se>, 2006, 2008, 2009, 2010.
 #
 # $Id: sv.po,v 1.14 2006/12/10 18:34:55 dnylande Exp $
 #
@@ -9,8 +9,8 @@ msgid ""
 msgstr ""
 "Project-Id-Version: NetworkManager\n"
 "Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-08-27 03:24+0000\n"
-"PO-Revision-Date: 2009-09-05 09:45+0100\n"
+"POT-Creation-Date: 2010-02-26 03:24+0000\n"
+"PO-Revision-Date: 2010-03-02 22:05+0100\n"
 "Last-Translator: Daniel Nylander <po@danielnylander.se>\n"
 "Language-Team: Swedish <tp-sv@listor.tp-sv.se>\n"
 "MIME-Version: 1.0\n"
@@ -18,6 +18,940 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout <timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Användning: nmcli con { KOMMANDO | help }\n"
+"  KOMMANDO := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | användare]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <gränssnitt>] [ap <hwaddr>] [--nowait] [--timeout <tidsgräns>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+#| msgid "_VPN Connections"
+msgid "Connections"
+msgstr "Anslutningar"
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Type"
+msgstr "Typ"
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158
+#: ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196
+#: ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205
+#: ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Name"
+msgstr "Namn"
+
+#: ../cli/src/connections.c:163
+#, c-format
+#| msgid "Modify system connections"
+msgid "System connections:\n"
+msgstr "Systemanslutningar:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+#| msgid "No network connection"
+msgid "User connections:\n"
+msgstr "Användaranslutningar:\n"
+
+#: ../cli/src/connections.c:178
+#: ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983
+#: ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003
+#: ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604
+#: ../cli/src/devices.c:614
+#: ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785
+#: ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "Fel: %s-argument saknas."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "Fel: %s - ingen sådan anslutning."
+
+#: ../cli/src/connections.c:196
+#| msgid "Modify system connections"
+msgid "System-wide connections"
+msgstr "Systemanslutningar"
+
+#: ../cli/src/connections.c:205
+#| msgid "No network connection"
+msgid "User connections"
+msgstr "Användaranslutningar"
+
+#: ../cli/src/connections.c:212
+#: ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103
+#: ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494
+#: ../cli/src/devices.c:628
+#: ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "Okänd parameter: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "Fel: ingen giltig parameter angiven."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321
+#: ../cli/src/devices.c:353
+#: ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357
+#: ../cli/src/devices.c:359
+#: ../cli/src/devices.c:361
+msgid "yes"
+msgstr "ja"
+
+#: ../cli/src/connections.c:268
+#: ../cli/src/devices.c:304
+msgid "no"
+msgstr "nej"
+
+#: ../cli/src/connections.c:297
+#| msgid "Modify system connections"
+msgid "Active connections"
+msgstr "Aktiva anslutningar"
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302
+#: ../cli/src/devices.c:304
+msgid "Default"
+msgstr "Standard"
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Service"
+msgstr "Tjänst"
+
+#: ../cli/src/connections.c:297
+#: ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "Enheter"
+
+#: ../cli/src/connections.c:659
+#, c-format
+#| msgid "VPN connection to '%s'"
+msgid "no active connection on device '%s'"
+msgstr "ingen aktiv anslutning på enheten \"%s\""
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ingen aktiv anslutning eller enhet"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "aktiverar"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "aktiverad"
+
+#: ../cli/src/connections.c:735
+#: ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791
+#: ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76
+#: ../cli/src/network-manager.c:98
+#| msgid "(unknown)"
+msgid "unknown"
+msgstr "okänt"
+
+#: ../cli/src/connections.c:744
+#| msgid "VPN connecting to '%s'"
+msgid "VPN connecting (prepare)"
+msgstr "VPN ansluter (förbereder)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN ansluter (behöver autentisering)"
+
+#: ../cli/src/connections.c:748
+#| msgid "_VPN Connections"
+msgid "VPN connecting"
+msgstr "VPN ansluter"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN ansluter (hämtar IP-konfiguration)"
+
+#: ../cli/src/connections.c:752
+#| msgid "_VPN Connections"
+msgid "VPN connected"
+msgstr "VPN ansluten"
+
+#: ../cli/src/connections.c:754
+#| msgid "VPN Connect Failure"
+msgid "VPN connection failed"
+msgstr "VPN-anslutning misslyckades"
+
+#: ../cli/src/connections.c:756
+#| msgid "VPN Connect Failure"
+msgid "VPN disconnected"
+msgstr "VPN frånkopplad"
+
+#: ../cli/src/connections.c:767
+#| msgid "(unknown)"
+msgid "unknown reason"
+msgstr "okänd anledning"
+
+#: ../cli/src/connections.c:769
+#| msgid "None"
+msgid "none"
+msgstr "ingen"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "användaren kopplades från"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "basnätverksanslutningen avbröts"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN-tjänsten stoppades oväntat"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN-tjänsten returnerade en ogiltig konfiguration"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "anslutningsförsöket översteg tidsgränsen"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN-tjänsten startade inte i tid"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN-tjänsten misslyckades med att starta"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "inga giltiga VPN-hemligheter"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "ogiltiga VPN-hemligheter"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "anslutningen togs bort"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "tillstånd: %s\n"
+
+#: ../cli/src/connections.c:806
+#: ../cli/src/connections.c:832
+#, c-format
+#| msgid "Connection _Information"
+msgid "Connection activated\n"
+msgstr "Anslutning aktiverad\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+#| msgid "Connection to the wired network failed."
+msgid "Error: Connection activation failed."
+msgstr "Fel: Aktivering av anslutning misslyckades."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "tillstånd: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "Fel: Aktivering av anslutning misslyckades: %s."
+
+#: ../cli/src/connections.c:855
+#: ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "Fel: Tidsgränsen %d sekunder gick ut."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "Fel: Aktivering av anslutning misslyckades: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "Fel: Hämtning av aktiv anslutning för \"%s\" misslyckades."
+
+#: ../cli/src/connections.c:921
+#, c-format
+#| msgid "VPN connection to '%s'"
+msgid "Active connection state: %s\n"
+msgstr "Tillstånd för aktiv anslutning: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+#| msgid "VPN connection to '%s'"
+msgid "Active connection path: %s\n"
+msgstr "Sökväg för aktiv anslutning: %s\n"
+
+#: ../cli/src/connections.c:976
+#: ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "Fel: Okänd anslutning: %s."
+
+#: ../cli/src/connections.c:1011
+#: ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "Fel: värdet \"%s\" för tidsgränsen är inte giltigt."
+
+#: ../cli/src/connections.c:1024
+#: ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "Fel: id eller uuid måste anges."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "Fel: Ingen lämplig enhet hittades: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "Fel: Ingen lämplig enhet hittades."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "Varning: Anslutningen är inte aktiv\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "Fel: \"con\"-kommandot \"%s\" är inte giltigt."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "Fel: kunde inte ansluta till D-Bus."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "Fel: Kunde inte få systeminställningar."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "Fel: Kunde inte få användarinställningar."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "Fel: Kan inte få anslutningar: inställningstjänster är inte igång."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Användning: nmcli dev { KOMMANDO | help }\n"
+"\n"
+"  KOMMANDO := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <gränssnitt>]\n"
+"  disconnect iface <gränssnitt> [--nowait] [--timeout <tidsgräns>]\n"
+"  wifi [list [iface <gränssnitt>] | apinfo iface <gränssnitt> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "ohanterad"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "otillgänglig"
+
+#: ../cli/src/devices.c:97
+#: ../cli/src/network-manager.c:73
+#| msgid "_Disconnect VPN..."
+msgid "disconnected"
+msgstr "frånkopplad"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "ansluter (förbereder)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "ansluter (konfigurerar)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "ansluter (behöver autentisering)"
+
+#: ../cli/src/devices.c:105
+#| msgid "Connection _Information"
+msgid "connecting (getting IP configuration)"
+msgstr "ansluter (hämtar IP-konfiguration)"
+
+#: ../cli/src/devices.c:107
+#: ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "ansluten"
+
+#: ../cli/src/devices.c:109
+#| msgid "Connection _Information"
+msgid "connection failed"
+msgstr "anslutningen misslyckades"
+
+#: ../cli/src/devices.c:132
+#: ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "Okänt"
+
+#. print them
+#: ../cli/src/devices.c:164
+#: ../cli/src/devices.c:266
+#: ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+#| msgid "(unknown)"
+msgid "(none)"
+msgstr "(ingen)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: fel vid konvertering av IP4-adress 0x%X"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, Frekv %d MHz, Hast %d Mb/s, Styrka %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", Krypterad: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr " Enterprise"
+
+#: ../cli/src/devices.c:294
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "Device"
+msgstr "Enhet"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "Drivrutin"
+
+#: ../cli/src/devices.c:299
+#: ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(okänt)"
+
+#: ../cli/src/devices.c:300
+#: ../cli/src/devices.c:458
+#: ../cli/src/devices.c:460
+msgid "State"
+msgstr "Tillstånd"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "Hårdvaruadress"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  Förmågor:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "Bärardetektering"
+
+#: ../cli/src/devices.c:336
+#, c-format
+#| msgid "%d Mb/s"
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "Hastighet"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  Trådlösa egenskaper\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP-kryptering"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA-kryptering"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2-kryptering"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP-chiffer"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP-chiffer"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  Trådlösa accesspunkter %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = aktuell AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  Trådbundna egenskaper\n"
+
+#: ../cli/src/devices.c:377
+#: ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "Bärare"
+
+#: ../cli/src/devices.c:377
+#| msgid "None"
+msgid "on"
+msgstr "på"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "av"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4-inställningar:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "Adress"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "Prefix"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "Gateway"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "Status för enheter"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "Fel: \"%s\"-argument saknas."
+
+#: ../cli/src/devices.c:516
+#: ../cli/src/devices.c:655
+#: ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "Fel: Enheten \"%s\" hittades inte."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "Lyckades: Enheten \"%s\" kopplades från."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "Fel: Frånkoppling av enheten \"%s\" (%s) misslyckades: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "Enhetstillstånd: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "Fel: gränssnitt (iface) måste anges."
+
+#: ../cli/src/devices.c:736
+#: ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi-avsökningslista"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "Fel: Enheten \"%s\" är inte en WiFi-enhet."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "Enhet:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "Fel: hwaddr måste anges."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "Fel: Accesspunkt med hwaddr \"%s\" hittades inte."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+#| msgid "%d Mb/s"
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869
+#: ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP-parametrar"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "Frekvens:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "Läge:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "Infrastruktur"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "Maximal bitfrekvens:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "Styrka:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "Flaggor:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "integritet"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA-flaggor:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN-flaggor:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "Fel: \"dev wifi\"-kommandot \"%s\" är inte giltigt."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "Fel: \"dev\"-kommandot \"%s\" är inte giltigt."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Användning: nmcli nm { KOMMANDO | help }\n"
+"\n"
+"  KOMMANDO := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "sover"
+
+#: ../cli/src/network-manager.c:69
+#| msgid "VPN connecting to '%s'"
+msgid "connecting"
+msgstr "ansluter"
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "aktiverad"
+
+#: ../cli/src/network-manager.c:93
+#: ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95
+#: ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143
+#: ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "inaktiverad"
+
+#: ../cli/src/network-manager.c:102
+#| msgid "NetworkManager Applet"
+msgid "NetworkManager status"
+msgstr "Status för Nätverkshanterare"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "NM kör:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "kör"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "kör inte"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "NM tillstånd:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "NM trådlös hårdvara:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107
+#: ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "NM trådlös:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "NM WWAN hårdvara:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109
+#: ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "Fel: ogiltig \"wifi\"-parameter: \"%s\"."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "Fel: ogiltig \"wwan\"-parameter: \"%s\"."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "Fel: \"nm\"-kommandot \"%s\" är inte giltigt."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Användning: %s [FLAGGOR] OBJEKT { KOMMANDO | help }\n"
+"\n"
+"FLAGGOR\n"
+"  -t[erse]    kort utdata\n"
+"  -p[retty]   vackert utdata\n"
+"  -v[ersion]  visa programversion\n"
+"  -h[elp]     skriv ut denna hjälp\n"
+"\n"
+"OBJEKT\n"
+"  nm          status för Nätverkshanterare\n"
+"  con         anslutningar i Nätverkshanterare\n"
+"  dev         enheter hanterade av Nätverkshanterare\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "Objektet \"%s\" är okänt, prova \"nmcli help\"."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli-verktyg, version %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "Flagan \"%s\" är okänd, prova \"nmcli -help\"."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "Fångade signal %d, stänger av..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "Fel: Kunde inte ansluta till Nätverkshanterare."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "Lyckades"
+
 #: ../libnm-util/crypto.c:120
 #, c-format
 msgid "PEM key file had no end tag '%s'."
@@ -104,8 +1038,10 @@ msgid "IV contains non-hexadecimal digits."
 msgstr "IV innehåller icke-hexadecimala siffror."
 
 #: ../libnm-util/crypto.c:382
-#: ../libnm-util/crypto_gnutls.c:143
-#: ../libnm-util/crypto_nss.c:169
+#: ../libnm-util/crypto_gnutls.c:148
+#: ../libnm-util/crypto_gnutls.c:266
+#: ../libnm-util/crypto_nss.c:171
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "Privata nyckelchiffret \"%s\" var okänt."
@@ -125,73 +1061,115 @@ msgstr "Kunde inte bestämma typ av privat nyckel."
 msgid "Not enough memory to store decrypted private key."
 msgstr "Inte tillräckligt mycket minne för att lagra dekrypterad privat nyckel."
 
-#: ../libnm-util/crypto_gnutls.c:46
+#: ../libnm-util/crypto_gnutls.c:49
 msgid "Failed to initialize the crypto engine."
 msgstr "Misslyckades med att initiera krypteringsmotorn."
 
-#: ../libnm-util/crypto_gnutls.c:90
+#: ../libnm-util/crypto_gnutls.c:93
 #, c-format
 msgid "Failed to initialize the MD5 engine: %s / %s."
 msgstr "Misslyckades med att initiera MD5-motorn: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:152
-#: ../libnm-util/crypto_nss.c:178
+#: ../libnm-util/crypto_gnutls.c:156
+#, c-format
+msgid "Invalid IV length (must be at least %zd)."
+msgstr "Ogiltig IV-längd (måste vara minst %zd)."
+
+#: ../libnm-util/crypto_gnutls.c:165
+#: ../libnm-util/crypto_nss.c:188
 #, c-format
 msgid "Not enough memory for decrypted key buffer."
 msgstr "Inte tillräckligt mycket minne för buffert för dekrypterade nycklar."
 
-#: ../libnm-util/crypto_gnutls.c:160
+#: ../libnm-util/crypto_gnutls.c:173
 #, c-format
 msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgstr "Misslyckades med att initiera chifferkontexten för dekryptering: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:169
+#: ../libnm-util/crypto_gnutls.c:182
 #, c-format
 msgid "Failed to set symmetric key for decryption: %s / %s."
 msgstr "Misslyckades med att ställa in symmetrisk nyckel för dekryptering: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:178
+#: ../libnm-util/crypto_gnutls.c:191
 #, c-format
 msgid "Failed to set IV for decryption: %s / %s."
 msgstr "Misslyckades med att ställa in IV för dekryptering: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:187
+#: ../libnm-util/crypto_gnutls.c:200
 #, c-format
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "Misslyckades med att dekryptera den privata nyckeln: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:200
+#: ../libnm-util/crypto_gnutls.c:210
+#: ../libnm-util/crypto_nss.c:267
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: unexpected padding length."
+msgstr "Misslyckades med att dekryptera privata nyckeln: oväntad utfyllningslängd."
+
+#: ../libnm-util/crypto_gnutls.c:221
+#: ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "Misslyckades med att dekryptera privata nyckeln."
 
-#: ../libnm-util/crypto_gnutls.c:235
+#: ../libnm-util/crypto_gnutls.c:286
+#: ../libnm-util/crypto_nss.c:356
+#, c-format
+msgid "Could not allocate memory for encrypting."
+msgstr "Kunde inte allokera minne för kryptering."
+
+#: ../libnm-util/crypto_gnutls.c:294
+#, c-format
+#| msgid "Failed to initialize the decryption cipher context: %s / %s."
+msgid "Failed to initialize the encryption cipher context: %s / %s."
+msgstr "Misslyckades med att initiera chifferkontexten för kryptering: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:303
+#, c-format
+#| msgid "Failed to set symmetric key for decryption: %s / %s."
+msgid "Failed to set symmetric key for encryption: %s / %s."
+msgstr "Misslyckades med att ställa in symmetrisk nyckel för kryptering: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:313
+#, c-format
+#| msgid "Failed to set IV for decryption: %s / %s."
+msgid "Failed to set IV for encryption: %s / %s."
+msgstr "Misslyckades med att ställa in IV för kryptering: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:322
+#, c-format
+#| msgid "Failed to decrypt the private key: %s / %s."
+msgid "Failed to encrypt the data: %s / %s."
+msgstr "Misslyckades med att kryptera datat: %s / %s."
+
+#: ../libnm-util/crypto_gnutls.c:362
 #, c-format
 msgid "Error initializing certificate data: %s"
 msgstr "Fel vid initiering av certifikatdata: %s"
 
-#: ../libnm-util/crypto_gnutls.c:257
+#: ../libnm-util/crypto_gnutls.c:384
 #, c-format
 msgid "Couldn't decode certificate: %s"
 msgstr "Kunde inte avkoda certifikat: %s"
 
-#: ../libnm-util/crypto_gnutls.c:281
+#: ../libnm-util/crypto_gnutls.c:408
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %s"
 msgstr "Kunde inte initiera PKCS#12-avkodare: %s"
 
-#: ../libnm-util/crypto_gnutls.c:294
+#: ../libnm-util/crypto_gnutls.c:421
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %s"
 msgstr "Kunde inte avkoda PKCS#12-fil: %s"
 
-#: ../libnm-util/crypto_gnutls.c:306
+#: ../libnm-util/crypto_gnutls.c:433
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "Kunde inte verifiera PKCS#12-fil: %s"
 
-#: ../libnm-util/crypto_nss.c:57
-#: ../system-settings/plugins/ifcfg-rh/crypto.c:52
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "Misslyckades med att initiera krypteringsmotorn: %d."
@@ -201,63 +1179,143 @@ msgstr "Misslyckades med att initiera krypteringsmotorn: %d."
 msgid "Failed to initialize the MD5 context: %d."
 msgstr "Misslyckades med att initiera MD5-kontexten: %d."
 
-#: ../libnm-util/crypto_nss.c:186
+#: ../libnm-util/crypto_nss.c:179
+#, c-format
+msgid "Invalid IV length (must be at least %d)."
+msgstr "Ogiltig IV-längd (måste vara minst %d)."
+
+#: ../libnm-util/crypto_nss.c:196
 #, c-format
 msgid "Failed to initialize the decryption cipher slot."
 msgstr "Misslyckades med att initiera dekrypteringschifferplatsen."
 
-#: ../libnm-util/crypto_nss.c:196
+#: ../libnm-util/crypto_nss.c:206
 #, c-format
 msgid "Failed to set symmetric key for decryption."
 msgstr "Misslyckades med att ställa in symmetrisk nyckel för dekryptering."
 
-#: ../libnm-util/crypto_nss.c:206
+#: ../libnm-util/crypto_nss.c:216
 #, c-format
 msgid "Failed to set IV for decryption."
 msgstr "Misslyckades med att ställa in IV för dekryptering."
 
-#: ../libnm-util/crypto_nss.c:214
+#: ../libnm-util/crypto_nss.c:224
 #, c-format
 msgid "Failed to initialize the decryption context."
 msgstr "Misslyckades med att initiera dekrypteringskontexten."
 
-#: ../libnm-util/crypto_nss.c:227
+#: ../libnm-util/crypto_nss.c:237
 #, c-format
 msgid "Failed to decrypt the private key: %d."
 msgstr "Misslyckades med att dekryptera privata nyckeln: %d."
 
-#: ../libnm-util/crypto_nss.c:239
+#: ../libnm-util/crypto_nss.c:245
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to decrypt the private key: decrypted data too large."
+msgstr "Misslyckades med att dekryptera privata nyckeln: dekrypterat data är för stort."
+
+#: ../libnm-util/crypto_nss.c:256
 #, c-format
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "Misslyckades med att färdigställa dekryptering av den privata nyckeln: %d."
 
-#: ../libnm-util/crypto_nss.c:284
+#: ../libnm-util/crypto_nss.c:364
+#, c-format
+#| msgid "Failed to initialize the decryption cipher slot."
+msgid "Failed to initialize the encryption cipher slot."
+msgstr "Misslyckades med att initiera krypteringschifferplatsen."
+
+#: ../libnm-util/crypto_nss.c:372
+#, c-format
+#| msgid "Failed to set symmetric key for decryption."
+msgid "Failed to set symmetric key for encryption."
+msgstr "Misslyckades med att ställa in symmetrisk nyckel för kryptering."
+
+#: ../libnm-util/crypto_nss.c:380
+#, c-format
+#| msgid "Failed to set IV for decryption."
+msgid "Failed to set IV for encryption."
+msgstr "Misslyckades med att ställa in IV för kryptering."
+
+#: ../libnm-util/crypto_nss.c:388
+#, c-format
+#| msgid "Failed to initialize the decryption context."
+msgid "Failed to initialize the encryption context."
+msgstr "Misslyckades med att initiera krypteringskontexten."
+
+#: ../libnm-util/crypto_nss.c:396
+#, c-format
+#| msgid "Failed to decrypt the private key: %d."
+msgid "Failed to encrypt: %d."
+msgstr "Misslyckades med att kryptera: %d."
+
+#: ../libnm-util/crypto_nss.c:404
+#, c-format
+msgid "Unexpected amount of data after encrypting."
+msgstr "Oväntad mängd data efter kryptering."
+
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "Kunde inte avkoda certifikat: %d"
 
-#: ../libnm-util/crypto_nss.c:319
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "Kunde inte konvertera lösenord till UCS2: %d"
 
-#: ../libnm-util/crypto_nss.c:347
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "Kunde inte initiera PKCS#12-avkodare: %d"
 
-#: ../libnm-util/crypto_nss.c:356
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "Kunde inte avkoda PKCS#12-fil: %d"
 
-#: ../libnm-util/crypto_nss.c:365
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "Kunde inte verifiera PKCS#12-fil: %d"
 
+#: ../libnm-util/crypto_nss.c:557
+#| msgid "Could not decode private key."
+msgid "Could not generate random data."
+msgstr "Kunde inte generera slumpmässigt data."
+
+#: ../libnm-util/nm-utils.c:1545
+#, c-format
+#| msgid "Not enough memory to create private key decryption key."
+msgid "Not enough memory to make encryption key."
+msgstr "Inte tillräckligt mycket minne för att skapa krypteringsnyckel."
+
+#: ../libnm-util/nm-utils.c:1655
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file creation."
+msgstr "Kunde inte allokera minne för att skapa PEM-fil."
+
+#: ../libnm-util/nm-utils.c:1667
+#, c-format
+msgid "Could not allocate memory for writing IV to PEM file."
+msgstr "Kunde inte allokera minne för skrivning av IV till PEM-fil."
+
+#: ../libnm-util/nm-utils.c:1679
+#, c-format
+msgid "Could not allocate memory for writing encrypted key to PEM file."
+msgstr "Kunde inte allokera minne för skrivning av krypterad nyckel till PEM-fil."
+
+#: ../libnm-util/nm-utils.c:1698
+#, c-format
+#| msgid "Not enough memory to store PEM file data."
+msgid "Could not allocate memory for PEM file data."
+msgstr "Kunde inte allokera minne för PEM-fildata."
+
 #: ../src/nm-netlink-monitor.c:194
 #: ../src/nm-netlink-monitor.c:464
+#: ../src/nm-netlink-monitor.c:582
+#: ../src/ip6-manager/nm-netlink-listener.c:352
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "fel vid behandling av netlink-meddelande: %s"
@@ -283,19 +1341,26 @@ msgid "unable to allocate netlink link cache for monitoring link status: %s"
 msgstr "kan inte allokera netlink-länkcache för övervakning av länkstatus: %s"
 
 #: ../src/nm-netlink-monitor.c:494
+#: ../src/ip6-manager/nm-netlink-listener.c:382
 msgid "error occurred while waiting for data on socket"
 msgstr "fel inträffade vid väntan på data i uttaget"
 
-#: ../src/NetworkManager.c:330
+#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:571
+#, c-format
+msgid "error updating link cache: %s"
+msgstr "fel vid uppdatering av länkcache: %s"
+
+#: ../src/NetworkManager.c:494
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr "Ogiltig flagga.  Använd --help för att se en lista över giltiga flaggor.\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:300
 msgid "# Created by NetworkManager\n"
 msgstr "# Skapad av Nätverkshanterare\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:316
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -304,6 +1369,24 @@ msgstr ""
 "# Sammanfogad från %s\n"
 "\n"
 
+#: ../src/ip6-manager/nm-netlink-listener.c:200
+#, c-format
+#| msgid "unable to allocate netlink handle for monitoring link status: %s"
+msgid "unable to allocate netlink handle: %s"
+msgstr "kan inte allokera netlink-handtag: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:210
+#, c-format
+#| msgid "unable to connect to netlink for monitoring link status: %s"
+msgid "unable to connect to netlink: %s"
+msgstr "kan inte ansluta till netlink: %s"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:307
+#, c-format
+#| msgid "unable to join netlink group for monitoring link status: %s"
+msgid "unable to join netlink group: %s"
+msgstr "kan inte gå med i netlink-grupp: %s"
+
 #: ../src/named-manager/nm-named-manager.c:315
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
 msgstr "OBSERVERA: uppslag via glibc kanske inte har stöd för fler än 3 namnservrar."
@@ -312,13 +1395,12 @@ msgstr "OBSERVERA: uppslag via glibc kanske inte har stöd för fler än 3 namns
 msgid "The nameservers listed below may not be recognized."
 msgstr "Namnservrarna listade nedan kanske inte kommer att kännas igen."
 
-#: ../src/system-settings/nm-default-wired-connection.c:194
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
 msgstr "Automatisk %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2446
-#| msgid "Open System"
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3213
 msgid "System"
 msgstr "System"
 
@@ -335,7 +1417,6 @@ msgid "Modify persistent system hostname"
 msgstr "Ändra bestående värdnamn för systemet"
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:4
-#| msgid "No active connections!"
 msgid "Modify system connections"
 msgstr "Ändra systemanslutningar"
 
@@ -355,12 +1436,6 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett skyddat tr
 msgid "System policy prevents sharing connections via an open WiFi network"
 msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trådlöst nätverk"
 
-#~ msgid "error updating link cache: %s"
-#~ msgstr "fel vid uppdatering av länkcache: %s"
-#~ msgid "Not enough memory to create private key decryption key."
-#~ msgstr ""
-#~ "Inte tillräckligt mycket minne för att skapa dekrypteringsnyckel för "
-#~ "privat nyckel."
 #~ msgid "operation took too long"
 #~ msgstr "åtgärden tog för lång tid"
 #~ msgid "received data from wrong type of sender"
@@ -373,22 +1448,14 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trå
 #~ msgstr "Lösenfras för det trådlösa nätverket %s"
 #~ msgid "Connection to the wireless network '%s' failed."
 #~ msgstr "Anslutning till det trådlösa nätverket \"%s\" misslyckades."
-#~ msgid "Connection to the wired network failed."
-#~ msgstr "Anslutning till det trådburna nätverket misslyckades."
 #~ msgid "Error displaying connection information:"
 #~ msgstr "Fel vid visning av anslutningsinformation:"
 #~ msgid "Could not find some required resources (the glade file)!"
 #~ msgstr "Kunde inte hitta en del nödvändiga resurser (glade-filen)!"
-#~ msgid "%d Mb/s"
-#~ msgstr "%d Mb/s"
 #~ msgid "Wired Ethernet (%s)"
 #~ msgstr "Trådbundet Ethernet (%s)"
 #~ msgid "Wireless Ethernet (%s)"
 #~ msgstr "Trådlöst Ethernet (%s)"
-#~ msgid "Unknown"
-#~ msgstr "Okänt"
-#~ msgid "NetworkManager Applet"
-#~ msgstr "Panelprogram för nätverkshantering"
 #~ msgid ""
 #~ "Copyright © 2004-2006 Red Hat, Inc.\n"
 #~ "Copyright © 2005-2006 Novell, Inc."
@@ -427,8 +1494,6 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trå
 #~ msgstr ""
 #~ "Kunde inte starta VPN-anslutningen \"%s\" på grund av ett fel vid start "
 #~ "av VPN-programmet."
-#~ msgid "VPN Connect Failure"
-#~ msgstr "VPN-anslutningsfel"
 #~ msgid "Could not start the VPN connection '%s' due to a connection error."
 #~ msgstr ""
 #~ "Kunde inte starta VPN-anslutningen \"%s\" på grund av ett anslutningsfel."
@@ -454,8 +1519,6 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trå
 #~ msgstr "Nätverksenheten \"%s (%s)\" stöder inte trådlös genomsökning."
 #~ msgid "The network device \"%s (%s)\" does not support link detection."
 #~ msgstr "Nätverksenheten \"%s (%s)\" stöder inte länkdetektering."
-#~ msgid "(unknown)"
-#~ msgstr "(okänt)"
 #~ msgid "Preparing device %s for the wired network..."
 #~ msgstr "Förbereder enheten %s för det trådbundna nätverket..."
 #~ msgid "Preparing device %s for the wireless network '%s'..."
@@ -478,28 +1541,18 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trå
 #~ msgstr "Nätverkshanteraren är inte igång"
 #~ msgid "Networking disabled"
 #~ msgstr "Nätverk inaktiverat"
-#~ msgid "No network connection"
-#~ msgstr "Ingen nätverksanslutning"
 #~ msgid "Wired network connection"
 #~ msgstr "Trådbunden nätverksanslutning"
 #~ msgid "Connected to an Ad-Hoc wireless network"
 #~ msgstr "Ansluten till ett trådlöst ad hoc-nätverk"
 #~ msgid "Wireless network connection to '%s' (%d%%)"
 #~ msgstr "Trådlös nätverksanslutning till \"%s\" (%d%%)"
-#~ msgid "VPN connection to '%s'"
-#~ msgstr "VPN-anslutning till \"%s\""
-#~ msgid "VPN connecting to '%s'"
-#~ msgstr "VPN-ansluter till \"%s\""
 #~ msgid "_Connect to Other Wireless Network..."
 #~ msgstr "_Anslut till annat trådlöst nätverk..."
 #~ msgid "Create _New Wireless Network..."
 #~ msgstr "Skapa _nytt trådlöst nätverk..."
-#~ msgid "_VPN Connections"
-#~ msgstr "_VPN-anslutningar"
 #~ msgid "_Configure VPN..."
 #~ msgstr "_Konfigurera VPN..."
-#~ msgid "_Disconnect VPN..."
-#~ msgstr "Koppla _från VPN..."
 #~ msgid "_Dial Up Connections"
 #~ msgstr "_Uppringda anslutningar"
 #~ msgid "Connect to %s..."
@@ -514,8 +1567,6 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trå
 #~ msgstr "Aktivera _nätverk"
 #~ msgid "Enable _Wireless"
 #~ msgstr "Aktivera _trådlöst"
-#~ msgid "Connection _Information"
-#~ msgstr "Anslutnings_information"
 #~ msgid "_Help"
 #~ msgstr "_Hjälp"
 #~ msgid "_About"
@@ -536,8 +1587,6 @@ msgstr "Systemets policy förhindrar delning av anslutningar via ett öppet trå
 #~ msgstr "TKIP"
 #~ msgid "Dynamic WEP"
 #~ msgstr "Dynamisk WEP"
-#~ msgid "None"
-#~ msgstr "Ingen"
 #~ msgid "WEP 64/128-bit ASCII"
 #~ msgstr "WEP 64/128-bitars ASCII"
 #~ msgid "WEP 64/128-bit Hex"
diff --git a/po/te.po b/po/te.po
index 7b3ace2..4d9101b 100644
--- a/po/te.po
+++ b/po/te.po
@@ -1,4 +1,4 @@
-# translation of NetworkManager.master.te.po to Telugu
+# translation of te.po to Telugu
 # Telugu translation of NetworkManager.
 # Copyright (C) 2009 NetworkManager's COPYRIGHT HOLDER
 # This file is distributed under the same license as the NetworkManager package.
@@ -6,18 +6,866 @@
 # Krishna Babu K <kkrothap@redhat.com>, 2009, 2010.
 msgid ""
 msgstr ""
-"Project-Id-Version: NetworkManager.master.te\n"
-"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?product=NetworkManager&component=general\n"
-"POT-Creation-Date: 2009-09-29 03:25+0000\n"
-"PO-Revision-Date: 2010-01-29 15:20+0530\n"
+"Project-Id-Version: te\n"
+"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
+"product=NetworkManager&component=general\n"
+"POT-Creation-Date: 2010-04-21 03:24+0000\n"
+"PO-Revision-Date: 2010-04-21 18:32+0530\n"
 "Last-Translator: Krishna Babu K <kkrothap@redhat.com>\n"
 "Language-Team: Telugu <en@li.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Generator: KBabel 1.11.4\n"
-"Plural-Forms: nplurals=2; plural=(n!=1);\n\n"
+"Plural-Forms: nplurals=2; plural=(n!=1);\n"
 "\n"
+"\n"
+"\n"
+"\n"
+
+#: ../cli/src/connections.c:86
+#, c-format
+msgid ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+msgstr ""
+"Usage: nmcli con { COMMAND | help }\n"
+"  COMMAND := { list | status | up | down }\n"
+"\n"
+"  list [id <id> | uuid <id> | system | user]\n"
+"  status\n"
+"  up id <id> | uuid <id> [iface <iface>] [ap <hwaddr>] [--nowait] [--timeout "
+"<timeout>]\n"
+"  down id <id> | uuid <id>\n"
+
+#: ../cli/src/connections.c:158
+msgid "Connections"
+msgstr "అనుసంధానములు"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/devices.c:298 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Type"
+msgstr "రకము"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "UUID"
+msgstr "UUID"
+
+#: ../cli/src/connections.c:158 ../cli/src/connections.c:160
+#: ../cli/src/connections.c:196 ../cli/src/connections.c:198
+#: ../cli/src/connections.c:205 ../cli/src/connections.c:207
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Name"
+msgstr "నామము"
+
+#: ../cli/src/connections.c:163
+#, c-format
+msgid "System connections:\n"
+msgstr "సిస్టమ్ అనుసంధానములు:\n"
+
+#: ../cli/src/connections.c:167
+#, c-format
+msgid "User connections:\n"
+msgstr "వినియోగదారి అనుసంధానములు:\n"
+
+#: ../cli/src/connections.c:178 ../cli/src/connections.c:967
+#: ../cli/src/connections.c:983 ../cli/src/connections.c:992
+#: ../cli/src/connections.c:1003 ../cli/src/connections.c:1085
+#: ../cli/src/devices.c:604 ../cli/src/devices.c:614 ../cli/src/devices.c:699
+#: ../cli/src/devices.c:785 ../cli/src/devices.c:792
+#, c-format
+msgid "Error: %s argument is missing."
+msgstr "దోషము: %s ఆర్గుమెంట్ తప్పిపోయినది."
+
+#: ../cli/src/connections.c:189
+#, c-format
+msgid "Error: %s - no such connection."
+msgstr "దోషము: %s - అటువంటి అనుసంధానము లేదు."
+
+#: ../cli/src/connections.c:196
+msgid "System-wide connections"
+msgstr "సిస్టమ్-వ్యాప్త అనుసంధానములు"
+
+#: ../cli/src/connections.c:205
+msgid "User connections"
+msgstr "వినియోగదారి అనుసంధానములు"
+
+#: ../cli/src/connections.c:212 ../cli/src/connections.c:1016
+#: ../cli/src/connections.c:1103 ../cli/src/devices.c:446
+#: ../cli/src/devices.c:494 ../cli/src/devices.c:628 ../cli/src/devices.c:706
+#: ../cli/src/devices.c:798
+#, c-format
+msgid "Unknown parameter: %s\n"
+msgstr "తెలియని పారామితి: %s\n"
+
+#: ../cli/src/connections.c:221
+#, c-format
+msgid "Error: no valid parameter specified."
+msgstr "దోషము: ఏ చెల్లునటువంటి పారామితి తెలుపబడలేదు."
+
+#. FIXME: Fix the output
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:302
+#: ../cli/src/devices.c:321 ../cli/src/devices.c:353 ../cli/src/devices.c:355
+#: ../cli/src/devices.c:357 ../cli/src/devices.c:359 ../cli/src/devices.c:361
+msgid "yes"
+msgstr "అవును"
+
+#: ../cli/src/connections.c:268 ../cli/src/devices.c:304
+msgid "no"
+msgstr "కాదు"
+
+#: ../cli/src/connections.c:297
+msgid "Active connections"
+msgstr "క్రియాశీల అనుసంధానములు"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+#: ../cli/src/devices.c:302 ../cli/src/devices.c:304
+msgid "Default"
+msgstr "అప్రమేయ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Service"
+msgstr "సేవ"
+
+#: ../cli/src/connections.c:297 ../cli/src/connections.c:299
+msgid "Devices"
+msgstr "పరికరములు"
+
+#: ../cli/src/connections.c:659
+#, c-format
+msgid "no active connection on device '%s'"
+msgstr "పరికరము '%s' పైన యెటువంటి క్రియాశీల అనుసంధానము లేదు"
+
+#: ../cli/src/connections.c:667
+#, c-format
+msgid "no active connection or device"
+msgstr "ఎటువంటి క్రియాశీల అనుసంధానము లేదా పరికరము లేదు"
+
+#: ../cli/src/connections.c:730
+msgid "activating"
+msgstr "క్రియాశీలపరచుచున్నది"
+
+#: ../cli/src/connections.c:732
+msgid "activated"
+msgstr "క్రియాశీలపరచబడింది"
+
+#: ../cli/src/connections.c:735 ../cli/src/connections.c:758
+#: ../cli/src/connections.c:791 ../cli/src/devices.c:111
+#: ../cli/src/network-manager.c:76 ../cli/src/network-manager.c:98
+msgid "unknown"
+msgstr "తెలియని"
+
+#: ../cli/src/connections.c:744
+msgid "VPN connecting (prepare)"
+msgstr "VPN అనుసంధానమౌచున్నది (సిద్దపరచు)"
+
+#: ../cli/src/connections.c:746
+msgid "VPN connecting (need authentication)"
+msgstr "VPN అనుసంధానమౌచున్నది (ధృవీకరణము అవసరము)"
+
+#: ../cli/src/connections.c:748
+msgid "VPN connecting"
+msgstr "VPN అనుసంధానమౌచున్నది"
+
+#: ../cli/src/connections.c:750
+msgid "VPN connecting (getting IP configuration)"
+msgstr "VPN అనుసంధానమౌచున్నది (IP ఆకృతీకరణను పొందుచున్నది)"
+
+#: ../cli/src/connections.c:752
+msgid "VPN connected"
+msgstr "VPN అనుసంధానమైంది"
+
+#: ../cli/src/connections.c:754
+msgid "VPN connection failed"
+msgstr "VPN అనుసంధానము విఫలమైంది"
+
+#: ../cli/src/connections.c:756
+msgid "VPN disconnected"
+msgstr "VPN అననుసంధానమైంది"
+
+#: ../cli/src/connections.c:767
+msgid "unknown reason"
+msgstr "తెలియని కారణము"
+
+#: ../cli/src/connections.c:769
+msgid "none"
+msgstr "ఏదీకాదు"
+
+#: ../cli/src/connections.c:771
+msgid "the user was disconnected"
+msgstr "వినియోగదారి అననుసంధానింప బడినారు"
+
+#: ../cli/src/connections.c:773
+msgid "the base network connection was interrupted"
+msgstr "ఆధార నెట్వర్కు అనుసంధానము ఆటంకపరచబడింది"
+
+#: ../cli/src/connections.c:775
+msgid "the VPN service stopped unexpectedly"
+msgstr "VPN సేవ అనుకోకుండా ఆపివేయబడింది"
+
+#: ../cli/src/connections.c:777
+msgid "the VPN service returned invalid configuration"
+msgstr "VPN సేవ చెల్లని ఆకృతీకరణను తిప్పియిచ్చినది"
+
+#: ../cli/src/connections.c:779
+msgid "the connection attempt timed out"
+msgstr "అనుసంధానపు ప్రయత్నం సమయం మించిపోయినది"
+
+#: ../cli/src/connections.c:781
+msgid "the VPN service did not start in time"
+msgstr "VPN సేవ సమయం లోపల ప్రారంభించబడలేదు"
+
+#: ../cli/src/connections.c:783
+msgid "the VPN service failed to start"
+msgstr "VPN సేవ ప్రారంభమగుటకు విఫలమైంది"
+
+#: ../cli/src/connections.c:785
+msgid "no valid VPN secrets"
+msgstr "ఏ విలువైన VPN రహస్యాలు లేవు"
+
+#: ../cli/src/connections.c:787
+msgid "invalid VPN secrets"
+msgstr "చెల్లని VPN రహస్యాలు"
+
+#: ../cli/src/connections.c:789
+msgid "the connection was removed"
+msgstr "అనుసంధానము తీసివేయబడింది"
+
+#: ../cli/src/connections.c:803
+#, c-format
+msgid "state: %s\n"
+msgstr "స్థితి: %s\n"
+
+#: ../cli/src/connections.c:806 ../cli/src/connections.c:832
+#, c-format
+msgid "Connection activated\n"
+msgstr "అనుసంధానము క్రియాశీలపరచబడింది\n"
+
+#: ../cli/src/connections.c:809
+#, c-format
+msgid "Error: Connection activation failed."
+msgstr "దోషము: అనుసంధానము క్రియాశీలపరచుట విఫలమైంది."
+
+#: ../cli/src/connections.c:828
+#, c-format
+msgid "state: %s (%d)\n"
+msgstr "స్థితి: %s (%d)\n"
+
+#: ../cli/src/connections.c:838
+#, c-format
+msgid "Error: Connection activation failed: %s."
+msgstr "దోషము: అనుసంధానము క్రియాశీలపరచుట విఫలమైంది: %s."
+
+#: ../cli/src/connections.c:855 ../cli/src/devices.c:551
+#, c-format
+msgid "Error: Timeout %d sec expired."
+msgstr "దోషము: కాలపరిమితి %d సె మించినది."
+
+#: ../cli/src/connections.c:898
+#, c-format
+msgid "Error: Connection activation failed: %s"
+msgstr "దోషము: అనుసంధానము క్రియాశీలపరచుట విఫలమైంది: %s"
+
+#: ../cli/src/connections.c:912
+#, c-format
+msgid "Error: Obtaining active connection for '%s' failed."
+msgstr "దోషము: '%s' కొరకు క్రియాశీల అనుసంధానమును పొందుటలో విఫలమైంది."
+
+#: ../cli/src/connections.c:921
+#, c-format
+msgid "Active connection state: %s\n"
+msgstr "క్రియాశీల అనుసంధానము స్థితి: %s\n"
+
+#: ../cli/src/connections.c:922
+#, c-format
+msgid "Active connection path: %s\n"
+msgstr "క్రియాశీల అనుసంధానము పాత్: %s\n"
+
+#: ../cli/src/connections.c:976 ../cli/src/connections.c:1094
+#, c-format
+msgid "Error: Unknown connection: %s."
+msgstr "దోషము: తెలియని దోషము: %s."
+
+#: ../cli/src/connections.c:1011 ../cli/src/devices.c:622
+#, c-format
+msgid "Error: timeout value '%s' is not valid."
+msgstr "దోషము: కాలముగింపు విలువ '%s' చెల్లనిది."
+
+#: ../cli/src/connections.c:1024 ../cli/src/connections.c:1111
+#, c-format
+msgid "Error: id or uuid has to be specified."
+msgstr "దోషము: id లేదా uuid తెలుపవలసి వుంది."
+
+#: ../cli/src/connections.c:1044
+#, c-format
+msgid "Error: No suitable device found: %s."
+msgstr "దోషము: ఎటువంటి సూటయ్యే పరికరము కనబడలేదు: %s."
+
+#: ../cli/src/connections.c:1046
+#, c-format
+msgid "Error: No suitable device found."
+msgstr "దోషము: ఏ సూటగు పరికరము కనబడలేదు."
+
+#: ../cli/src/connections.c:1138
+#, c-format
+msgid "Warning: Connection not active\n"
+msgstr "హెచ్చరిక: అనుసంధానము క్రియాశీలంగా లేదు\n"
+
+#: ../cli/src/connections.c:1189
+#, c-format
+msgid "Error: 'con' command '%s' is not valid."
+msgstr "దోషము: 'con' ఆదేశము '%s' చెల్లునది కాదు."
+
+#: ../cli/src/connections.c:1216
+#, c-format
+msgid "Error: could not connect to D-Bus."
+msgstr "దోషము: D-Busకు అనుసంధానము కాలేకపోయినది."
+
+#: ../cli/src/connections.c:1223
+#, c-format
+msgid "Error: Could not get system settings."
+msgstr "దోషము: సిస్టమ్ అమరికలను పొందలేక పోయింది."
+
+#: ../cli/src/connections.c:1231
+#, c-format
+msgid "Error: Could not get user settings."
+msgstr "దోషము: వినియోగదారి అమరికలను పొందలేక పోయింది."
+
+#: ../cli/src/connections.c:1241
+#, c-format
+msgid "Error: Can't obtain connections: settings services are not running."
+msgstr "దోషము: అనుసంధానములను పొందలేదు: అమరికల సేవలు నడుచుటలేదు."
+
+#: ../cli/src/devices.c:73
+#, c-format
+msgid ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+msgstr ""
+"Usage: nmcli dev { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | list | disconnect | wifi }\n"
+"\n"
+"  status\n"
+"  list [iface <iface>]\n"
+"  disconnect iface <iface> [--nowait] [--timeout <timeout>]\n"
+"  wifi [list [iface <iface>] | apinfo iface <iface> hwaddr <hwaddr>]\n"
+"\n"
+
+#: ../cli/src/devices.c:93
+msgid "unmanaged"
+msgstr "నిర్వహించని"
+
+#: ../cli/src/devices.c:95
+msgid "unavailable"
+msgstr "అందుబాటులోలేని"
+
+#: ../cli/src/devices.c:97 ../cli/src/network-manager.c:73
+msgid "disconnected"
+msgstr "అననుసంధానమైన"
+
+#: ../cli/src/devices.c:99
+msgid "connecting (prepare)"
+msgstr "అనుసంధానమౌచున్నది (సిద్దపడుతోంది)"
+
+#: ../cli/src/devices.c:101
+msgid "connecting (configuring)"
+msgstr "అనుసంధానమౌచున్నది (ఆకృతీకరించబడుతోంది)"
+
+#: ../cli/src/devices.c:103
+msgid "connecting (need authentication)"
+msgstr "అనుసంధానమౌచున్నది (ధృవీకరణము అవసరము)"
+
+#: ../cli/src/devices.c:105
+msgid "connecting (getting IP configuration)"
+msgstr "అనుసంధానమౌచున్నది (IP ఆకృతీకరణను పొందుచున్నది)"
+
+#: ../cli/src/devices.c:107 ../cli/src/network-manager.c:71
+msgid "connected"
+msgstr "అనుసంధానమైంది"
+
+#: ../cli/src/devices.c:109
+msgid "connection failed"
+msgstr "అనుసంధానము విఫలమైంది"
+
+#: ../cli/src/devices.c:132 ../cli/src/devices.c:876
+msgid "Unknown"
+msgstr "తెలియని"
+
+#. print them
+#: ../cli/src/devices.c:164 ../cli/src/devices.c:266 ../cli/src/devices.c:861
+#: ../cli/src/devices.c:879
+msgid "(none)"
+msgstr "(ఏదీకాదు)"
+
+#: ../cli/src/devices.c:209
+#, c-format
+msgid "%s: error converting IP4 address 0x%X"
+msgstr "%s: IP4 చిరునామా 0x%X మార్చుటలో దోషము"
+
+#: ../cli/src/devices.c:238
+#, c-format
+msgid "%s, %s, Freq %d MHz, Rate %d Mb/s, Strength %d"
+msgstr "%s, %s, పౌనఃపున్యం(ఫ్రీక్వెన్సీ) %d MHz, రేటు %d Mb/s, బలం(స్ట్రెన్త్) %d"
+
+#: ../cli/src/devices.c:239
+msgid "Ad-Hoc"
+msgstr "Ad-Hoc"
+
+#: ../cli/src/devices.c:248
+msgid ", Encrypted: "
+msgstr ", ఎన్క్రిప్టెడ్: "
+
+#: ../cli/src/devices.c:253
+msgid " WEP"
+msgstr " WEP"
+
+#: ../cli/src/devices.c:255
+msgid " WPA"
+msgstr " WPA"
+
+#: ../cli/src/devices.c:257
+msgid " WPA2"
+msgstr " WPA2"
+
+#: ../cli/src/devices.c:260
+msgid " Enterprise"
+msgstr "ఎంటర్‌ప్రైజ్"
+
+#: ../cli/src/devices.c:294 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "Device"
+msgstr "పరికరము"
+
+#: ../cli/src/devices.c:299
+msgid "Driver"
+msgstr "డ్రైవర్"
+
+#: ../cli/src/devices.c:299 ../cli/src/devices.c:567
+msgid "(unknown)"
+msgstr "(తెలియని)"
+
+#: ../cli/src/devices.c:300 ../cli/src/devices.c:458 ../cli/src/devices.c:460
+msgid "State"
+msgstr "స్థితి"
+
+#: ../cli/src/devices.c:313
+msgid "HW Address"
+msgstr "HW చిరునామా"
+
+#: ../cli/src/devices.c:319
+#, c-format
+msgid ""
+"\n"
+"  Capabilities:\n"
+msgstr ""
+"\n"
+"  సామర్ధ్యములు:\n"
+
+#: ../cli/src/devices.c:321
+msgid "Carrier Detect"
+msgstr "కారియర్ గుర్తించబడింది"
+
+#: ../cli/src/devices.c:336
+#, c-format
+msgid "%u Mb/s"
+msgstr "%u Mb/s"
+
+#: ../cli/src/devices.c:337
+msgid "Speed"
+msgstr "వేగము"
+
+#: ../cli/src/devices.c:348
+#, c-format
+msgid ""
+"\n"
+"  Wireless Properties\n"
+msgstr ""
+"\n"
+"  వైర్‌లెస్ లక్షణములు\n"
+
+#: ../cli/src/devices.c:353
+msgid "WEP Encryption"
+msgstr "WEP ఎన్క్రిప్షన్"
+
+#: ../cli/src/devices.c:355
+msgid "WPA Encryption"
+msgstr "WPA ఎన్క్రిప్షన్"
+
+#: ../cli/src/devices.c:357
+msgid "WPA2 Encryption"
+msgstr "WPA2 ఎన్క్రిప్షన్"
+
+#: ../cli/src/devices.c:359
+msgid "TKIP cipher"
+msgstr "TKIP సైఫర్"
+
+#: ../cli/src/devices.c:361
+msgid "CCMP cipher"
+msgstr "CCMP సైఫర్"
+
+#: ../cli/src/devices.c:368
+#, c-format
+msgid ""
+"\n"
+"  Wireless Access Points %s\n"
+msgstr ""
+"\n"
+"  వైర్‌లెస్ యాక్సిస్ పాయింట్స్ %s\n"
+
+#: ../cli/src/devices.c:368
+msgid "(* = current AP)"
+msgstr "(* = current AP)"
+
+#: ../cli/src/devices.c:374
+#, c-format
+msgid ""
+"\n"
+"  Wired Properties\n"
+msgstr ""
+"\n"
+"  వైర్డు లక్షణములు\n"
+
+#: ../cli/src/devices.c:377 ../cli/src/devices.c:379
+msgid "Carrier"
+msgstr "కారియర్"
+
+#: ../cli/src/devices.c:377
+msgid "on"
+msgstr "ఆన్"
+
+#: ../cli/src/devices.c:379
+msgid "off"
+msgstr "ఆఫ్"
+
+#: ../cli/src/devices.c:387
+#, c-format
+msgid ""
+"\n"
+"  IPv4 Settings:\n"
+msgstr ""
+"\n"
+"  IPv4 అమరికలు:\n"
+
+#: ../cli/src/devices.c:395
+msgid "Address"
+msgstr "చిరునామా"
+
+#: ../cli/src/devices.c:401
+msgid "Prefix"
+msgstr "ప్రిఫిక్స్"
+
+#: ../cli/src/devices.c:405
+msgid "Gateway"
+msgstr "గేట్‌వే"
+
+#: ../cli/src/devices.c:416
+msgid "DNS"
+msgstr "DNS"
+
+#: ../cli/src/devices.c:458
+msgid "Status of devices"
+msgstr "పరికరముల యొక్క స్థితి"
+
+#: ../cli/src/devices.c:487
+#, c-format
+msgid "Error: '%s' argument is missing."
+msgstr "దోషము: '%s' ఆర్గుమెంట్ తప్పిపోయినది."
+
+#: ../cli/src/devices.c:516 ../cli/src/devices.c:655 ../cli/src/devices.c:729
+#, c-format
+msgid "Error: Device '%s' not found."
+msgstr "దోషము: పరికరము '%s' కనబడలేదు."
+
+#: ../cli/src/devices.c:539
+#, c-format
+msgid "Success: Device '%s' successfully disconnected."
+msgstr "సఫలమైంది: పరికరము '%s' సఫలవంతంగా అననుసంధానించబడింది."
+
+#: ../cli/src/devices.c:564
+#, c-format
+msgid "Error: Device '%s' (%s) disconnecting failed: %s"
+msgstr "దోషము: పరికరము '%s' (%s) అననుసంధానము విఫలమైంది: %s"
+
+#: ../cli/src/devices.c:572
+#, c-format
+msgid "Device state: %d (%s)\n"
+msgstr "పరికరము స్థితి: %d (%s)\n"
+
+#: ../cli/src/devices.c:636
+#, c-format
+msgid "Error: iface has to be specified."
+msgstr "దోషము: iface తెలుపవలసి వుంది."
+
+#: ../cli/src/devices.c:736 ../cli/src/devices.c:746
+msgid "WiFi scan list"
+msgstr "WiFi స్కాన్ జాబితా"
+
+#: ../cli/src/devices.c:740
+#, c-format
+msgid "Error: Device '%s' is not a WiFi device."
+msgstr "దోషము: పరికరము '%s' అనునది WiFi పరికరము కాదు."
+
+#: ../cli/src/devices.c:754
+msgid "Device:"
+msgstr "పరికరము:"
+
+#: ../cli/src/devices.c:806
+#, c-format
+msgid "Error: hwaddr has to be specified."
+msgstr "దోషము: hwaddr తెలుపవలసి వుంది."
+
+#: ../cli/src/devices.c:844
+#, c-format
+msgid "Error: Access point with hwaddr '%s' not found."
+msgstr "దోషము: హార్డువేర్‌చిరునామా '%s'తో యాక్సెస్ పాయింట్ కనబడలేదు."
+
+#: ../cli/src/devices.c:862
+#, c-format
+msgid "%u MHz"
+msgstr "%u MHz"
+
+#: ../cli/src/devices.c:863
+#, c-format
+msgid "%u MB/s"
+msgstr "%u MB/s"
+
+#: ../cli/src/devices.c:869 ../cli/src/devices.c:871
+msgid "AP parameters"
+msgstr "AP పారామితులు"
+
+#: ../cli/src/devices.c:873
+msgid "SSID:"
+msgstr "SSID:"
+
+#: ../cli/src/devices.c:874
+msgid "BSSID:"
+msgstr "BSSID:"
+
+#: ../cli/src/devices.c:875
+msgid "Frequency:"
+msgstr "పౌనఃపున్యము:"
+
+#: ../cli/src/devices.c:876
+msgid "Mode:"
+msgstr "రీతి:"
+
+#: ../cli/src/devices.c:876
+msgid "Ad-hoc"
+msgstr "Ad-hoc"
+
+#: ../cli/src/devices.c:876
+msgid "Infrastructure"
+msgstr "అవస్థాపన(ఇన్ఫ్రాస్ట్రక్చర్)"
+
+#: ../cli/src/devices.c:877
+msgid "Maximal bitrate:"
+msgstr "గరిష్ట బిట్‌రేట్:"
+
+#: ../cli/src/devices.c:878
+msgid "Strength:"
+msgstr "బలం:"
+
+#: ../cli/src/devices.c:879
+msgid "Flags:"
+msgstr "ఫ్లాగ్స్:"
+
+#: ../cli/src/devices.c:879
+msgid "privacy"
+msgstr "గోప్యత"
+
+#: ../cli/src/devices.c:880
+msgid "WPA flags:"
+msgstr "WPA ఫ్లాగ్స్:"
+
+#: ../cli/src/devices.c:881
+msgid "RSN flags:"
+msgstr "RSN ఫ్లాగ్స్:"
+
+#: ../cli/src/devices.c:907
+#, c-format
+msgid "Error: 'dev wifi' command '%s' is not valid."
+msgstr "దోషము: 'dev wifi' ఆదేశము '%s' చెల్లనిది."
+
+#: ../cli/src/devices.c:943
+#, c-format
+msgid "Error: 'dev' command '%s' is not valid."
+msgstr "దోషము: 'dev' ఆదేశము '%s' చెల్లనిది."
+
+#: ../cli/src/network-manager.c:46
+#, c-format
+msgid ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+msgstr ""
+"Usage: nmcli nm { COMMAND | help }\n"
+"\n"
+"  COMMAND := { status | sleep | wakeup | wifi | wwan }\n"
+"\n"
+"  status\n"
+"  sleep\n"
+"  wakeup\n"
+"  wifi [on|off]\n"
+"  wwan [on|off]\n"
+"\n"
+
+#: ../cli/src/network-manager.c:67
+msgid "asleep"
+msgstr "స్థబ్దుగా(asleep)"
+
+#: ../cli/src/network-manager.c:69
+msgid "connecting"
+msgstr "అనుసంధానమౌచున్నది"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "enabled"
+msgstr "చేతనమైంది"
+
+#: ../cli/src/network-manager.c:93 ../cli/src/network-manager.c:94
+#: ../cli/src/network-manager.c:95 ../cli/src/network-manager.c:96
+#: ../cli/src/network-manager.c:143 ../cli/src/network-manager.c:160
+msgid "disabled"
+msgstr "అచేతనమైంది"
+
+#: ../cli/src/network-manager.c:102
+msgid "NetworkManager status"
+msgstr "నెట్వర్కునిర్వాహిక స్థితి"
+
+#: ../cli/src/network-manager.c:104
+msgid "NM running:"
+msgstr "నెని నడుచుచున్నది:"
+
+#: ../cli/src/network-manager.c:104
+msgid "running"
+msgstr "నడుచుచున్నది"
+
+#: ../cli/src/network-manager.c:104
+msgid "not running"
+msgstr "నడుచుటలేదు"
+
+#: ../cli/src/network-manager.c:105
+msgid "NM state:"
+msgstr "నెని స్థితి:"
+
+#: ../cli/src/network-manager.c:106
+msgid "NM wireless hardware:"
+msgstr "నెని వైర్‌లెస్ హార్డువేరు:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:107 ../cli/src/network-manager.c:143
+msgid "NM wireless:"
+msgstr "నెని వైర్‌లెస్:"
+
+#: ../cli/src/network-manager.c:108
+msgid "NM WWAN hardware:"
+msgstr "నెని WWAN హార్డువేర్:"
+
+#. no argument, show current state
+#: ../cli/src/network-manager.c:109 ../cli/src/network-manager.c:160
+msgid "NM WWAN:"
+msgstr "NM WWAN:"
+
+#: ../cli/src/network-manager.c:150
+#, c-format
+msgid "Error: invalid 'wifi' parameter: '%s'."
+msgstr "దోషము: చెల్లని 'wifi' పారామితి: '%s'."
+
+#: ../cli/src/network-manager.c:167
+#, c-format
+msgid "Error: invalid 'wwan' parameter: '%s'."
+msgstr "దోషము: చెల్లని 'wwan' పారామితి: '%s'."
+
+#: ../cli/src/network-manager.c:178
+#, c-format
+msgid "Error: 'nm' command '%s' is not valid."
+msgstr "దోషము: 'nm' ఆదేశము '%s' చెల్లనిది."
+
+#: ../cli/src/nmcli.c:65
+#, c-format
+msgid ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+msgstr ""
+"Usage: %s [OPTIONS] OBJECT { COMMAND | help }\n"
+"\n"
+"OPTIONS\n"
+"  -t[erse]    terse output\n"
+"  -p[retty]   pretty output\n"
+"  -v[ersion]  show program version\n"
+"  -h[elp]     print this help\n"
+"\n"
+"OBJECT\n"
+"  nm          NetworkManager status\n"
+"  con         NetworkManager connections\n"
+"  dev         devices managed by NetworkManager\n"
+"\n"
+
+#: ../cli/src/nmcli.c:106
+#, c-format
+msgid "Object '%s' is unknown, try 'nmcli help'."
+msgstr "ఆబ్జక్టు '%s' తెలియనిది, 'nmcli help' ప్రయత్నించండి."
+
+#: ../cli/src/nmcli.c:139
+#, c-format
+msgid "nmcli tool, version %s\n"
+msgstr "nmcli సాధనము, వర్షన్ %s\n"
+
+#: ../cli/src/nmcli.c:145
+#, c-format
+msgid "Option '%s' is unknown, try 'nmcli -help'."
+msgstr "ఐచ్చికము '%s' తెలియనిది, 'nmcli -help' ప్రయత్నించండి."
+
+#: ../cli/src/nmcli.c:164
+#, c-format
+msgid "Caught signal %d, shutting down..."
+msgstr "సిగ్నల్ %d వచ్చింది, మూసివేయుచున్నది..."
+
+#: ../cli/src/nmcli.c:189
+#, c-format
+msgid "Error: Could not connect to NetworkManager."
+msgstr "దోషము: నెట్వర్కునిర్వాహికకు అనుసంధానము కాలేకపోయింది."
+
+#: ../cli/src/nmcli.c:205
+msgid "Success"
+msgstr "సఫలంమైంది"
 
 #: ../libnm-util/crypto.c:120
 #, c-format
@@ -106,7 +954,7 @@ msgstr "IV నాన్-హెక్సాడెసిమల్ సంఖ్య
 
 #: ../libnm-util/crypto.c:382 ../libnm-util/crypto_gnutls.c:148
 #: ../libnm-util/crypto_gnutls.c:266 ../libnm-util/crypto_nss.c:171
-#: ../libnm-util/crypto_nss.c:335
+#: ../libnm-util/crypto_nss.c:336
 #, c-format
 msgid "Private key cipher '%s' was unknown."
 msgstr "వ్యక్తిగత కీ సైఫర్ '%s' అనునది తెలియనిది."
@@ -165,43 +1013,38 @@ msgstr "వివరణ కొరకు IV అమర్చుటలో విఫ
 msgid "Failed to decrypt the private key: %s / %s."
 msgstr "వ్యక్తిగత కీను డిక్రిప్టు చేయుటలో విఫలమైంది: %s / %s."
 
-#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:266
+#: ../libnm-util/crypto_gnutls.c:210 ../libnm-util/crypto_nss.c:267
 #, c-format
-#| msgid "Failed to decrypt the private key: %d."
 msgid "Failed to decrypt the private key: unexpected padding length."
 msgstr "వ్యక్తిగత కీను డిక్రిప్టు చేయుటలో విఫలమైంది: అనుకోని పాడింగ్ పొడవు."
 
-#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:277
+#: ../libnm-util/crypto_gnutls.c:221 ../libnm-util/crypto_nss.c:278
 #, c-format
 msgid "Failed to decrypt the private key."
 msgstr "వ్యక్తిగత కీను డిక్రిప్టు చేయుటలో విఫలమైంది."
 
-#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:355
+#: ../libnm-util/crypto_gnutls.c:286 ../libnm-util/crypto_nss.c:356
 #, c-format
 msgid "Could not allocate memory for encrypting."
 msgstr "ఎన్క్రిప్టింగ్ కొరకు మెమొరీ కేటాయించలేక పోయింది."
 
 #: ../libnm-util/crypto_gnutls.c:294
 #, c-format
-#| msgid "Failed to initialize the decryption cipher context: %s / %s."
 msgid "Failed to initialize the encryption cipher context: %s / %s."
 msgstr "ఎన్క్రిప్షన్ సైఫర్ కాంటెస్టును సిద్దము చేయుటలో విఫలమైంది: %s / %s."
 
 #: ../libnm-util/crypto_gnutls.c:303
 #, c-format
-#| msgid "Failed to set symmetric key for decryption: %s / %s."
 msgid "Failed to set symmetric key for encryption: %s / %s."
 msgstr "ఎన్క్రిప్షన్ కొరకు సిమెట్రిక్ కీను అమర్చుటలో విఫలమైంది: %s / %s."
 
 #: ../libnm-util/crypto_gnutls.c:313
 #, c-format
-#| msgid "Failed to set IV for decryption: %s / %s."
 msgid "Failed to set IV for encryption: %s / %s."
 msgstr "ఎన్క్రిప్షన్ కొరకు IV అమర్చుటలో విఫలమైంది: %s / %s."
 
 #: ../libnm-util/crypto_gnutls.c:322
 #, c-format
-#| msgid "Failed to decrypt the private key: %s / %s."
 msgid "Failed to encrypt the data: %s / %s."
 msgstr "డాటాను ఎన్క్రిప్టు చేయుటలో విఫలమైంది: %s / %s."
 
@@ -230,7 +1073,7 @@ msgstr "PKCS#12 ఫైలును డీకోడ్ పరచలేక పో
 msgid "Couldn't verify PKCS#12 file: %s"
 msgstr "PKCS#12 ఫైలును నిర్ధారించలేక పోయింది: %s"
 
-#: ../libnm-util/crypto_nss.c:57
+#: ../libnm-util/crypto_nss.c:56
 #, c-format
 msgid "Failed to initialize the crypto engine: %d."
 msgstr "క్రిప్టో యింజన్ సిద్దము చేయుటలో విఫలమైంది: %d."
@@ -272,7 +1115,6 @@ msgstr "వ్యక్తిగత కీను డిక్రిప్టు
 
 #: ../libnm-util/crypto_nss.c:245
 #, c-format
-#| msgid "Failed to decrypt the private key: %d."
 msgid "Failed to decrypt the private key: decrypted data too large."
 msgstr "వ్యక్తిగత కీను డిక్రిప్టు చేయుటలో విఫలమైంది: డిక్రిప్టు చేసిన డాటా మరీ పెద్దది."
 
@@ -281,145 +1123,141 @@ msgstr "వ్యక్తిగత కీను డిక్రిప్టు
 msgid "Failed to finalize decryption of the private key: %d."
 msgstr "వ్యక్తిగత కీ యొక్క డిక్రిప్షన్ ఖరారు చేయుటలో విఫలమైంది: %d."
 
-#: ../libnm-util/crypto_nss.c:363
+#: ../libnm-util/crypto_nss.c:364
 #, c-format
-#| msgid "Failed to initialize the decryption cipher slot."
 msgid "Failed to initialize the encryption cipher slot."
 msgstr "ఎన్క్రిప్షన్ సైఫర్ స్లాట్‌ను సిద్దముచేయుటలో విఫలమైంది."
 
-#: ../libnm-util/crypto_nss.c:371
+#: ../libnm-util/crypto_nss.c:372
 #, c-format
-#| msgid "Failed to set symmetric key for decryption."
 msgid "Failed to set symmetric key for encryption."
 msgstr "ఎన్క్రిప్షన్ కొరకు సిమ్మెట్రిక్ కీను అమర్చుటలో విఫలమైంది."
 
-#: ../libnm-util/crypto_nss.c:379
+#: ../libnm-util/crypto_nss.c:380
 #, c-format
-#| msgid "Failed to set IV for decryption."
 msgid "Failed to set IV for encryption."
 msgstr "ఎన్క్రిప్షన్ కొరకు IV అమర్చుటలో విఫలమైంది."
 
-#: ../libnm-util/crypto_nss.c:387
+#: ../libnm-util/crypto_nss.c:388
 #, c-format
-#| msgid "Failed to initialize the decryption context."
 msgid "Failed to initialize the encryption context."
 msgstr "ఎన్క్రిప్షన్ సందర్భమును సిద్దముచేయుటలో విఫలమైంది."
 
-#: ../libnm-util/crypto_nss.c:395
+#: ../libnm-util/crypto_nss.c:396
 #, c-format
-#| msgid "Failed to decrypt the private key: %d."
 msgid "Failed to encrypt: %d."
 msgstr "ఎన్క్రిప్టు చేయుటకు విఫలమైంది: %d."
 
-#: ../libnm-util/crypto_nss.c:403
+#: ../libnm-util/crypto_nss.c:404
 #, c-format
 msgid "Unexpected amount of data after encrypting."
 msgstr "ఎన్క్రిప్టు చేసిన తర్వాత అనుకోని డాటా మొత్తము."
 
-#: ../libnm-util/crypto_nss.c:446
+#: ../libnm-util/crypto_nss.c:447
 #, c-format
 msgid "Couldn't decode certificate: %d"
 msgstr "దృవీకరణపత్రమును డీకోడ్ చేయలేక పోయింది: %d"
 
-#: ../libnm-util/crypto_nss.c:481
+#: ../libnm-util/crypto_nss.c:482
 #, c-format
 msgid "Couldn't convert password to UCS2: %d"
 msgstr "సంకేతపదమును UCS2కు మార్చలేక పోయింది: %d"
 
-#: ../libnm-util/crypto_nss.c:509
+#: ../libnm-util/crypto_nss.c:510
 #, c-format
 msgid "Couldn't initialize PKCS#12 decoder: %d"
 msgstr "PKCS#12 డీకోడర్‌ను సిద్దము చేయలేక పోయింది: %d"
 
-#: ../libnm-util/crypto_nss.c:518
+#: ../libnm-util/crypto_nss.c:519
 #, c-format
 msgid "Couldn't decode PKCS#12 file: %d"
 msgstr "PKCS#12 ఫైలు డీకోడ్ చేయలేక పోయింది: %d"
 
-#: ../libnm-util/crypto_nss.c:527
+#: ../libnm-util/crypto_nss.c:528
 #, c-format
 msgid "Couldn't verify PKCS#12 file: %d"
 msgstr "PKCS#12 ఫైలు నిర్దారించలేక పోయింది: %d"
 
-#: ../libnm-util/crypto_nss.c:556
-#| msgid "Could not decode private key."
+#: ../libnm-util/crypto_nss.c:557
 msgid "Could not generate random data."
 msgstr "యాదృశ్చిక డాటాను జనియింపచేయలేక పోయింది."
 
-#: ../libnm-util/nm-utils.c:1522
+#: ../libnm-util/nm-utils.c:1818
 #, c-format
-#| msgid "Not enough memory to decrypt private key."
 msgid "Not enough memory to make encryption key."
 msgstr "ఎన్క్రిప్షన్ కీను తయారుచేయుటకు సరిపోవు మెమొరీ లేదు."
 
-#: ../libnm-util/nm-utils.c:1633
-#| msgid "Not enough memory to store PEM file data."
+#: ../libnm-util/nm-utils.c:1928
 msgid "Could not allocate memory for PEM file creation."
 msgstr "మెమొరీను PEM ఫైలు సృష్టీకరణ కొరకు కేటాయించలేక పోయింది."
 
-#: ../libnm-util/nm-utils.c:1645
+#: ../libnm-util/nm-utils.c:1940
 #, c-format
 msgid "Could not allocate memory for writing IV to PEM file."
 msgstr "IVను PEM ఫైలునకు వ్రాయుటకు మెమొరీను కేటాయించలేక పోయింది."
 
-#: ../libnm-util/nm-utils.c:1657
+#: ../libnm-util/nm-utils.c:1952
 #, c-format
 msgid "Could not allocate memory for writing encrypted key to PEM file."
 msgstr "ఎన్క్రిప్టు చేసిన కీను PEM ఫైలునకు వ్రాయుటకు మెమొరీను కేటాయించలేక పోయింది."
 
-#: ../libnm-util/nm-utils.c:1676
+#: ../libnm-util/nm-utils.c:1971
 #, c-format
-#| msgid "Not enough memory to store PEM file data."
 msgid "Could not allocate memory for PEM file data."
 msgstr "PEM ఫైలు డాటా కొరకు మెమొరీను కేటాయించలేక పోయింది."
 
-#: ../src/nm-netlink-monitor.c:194 ../src/nm-netlink-monitor.c:464
-#: ../src/nm-netlink-monitor.c:569
-#: ../src/ip6-manager/nm-netlink-listener.c:352
+#: ../src/nm-netlink-monitor.c:195 ../src/nm-netlink-monitor.c:463
+#: ../src/nm-netlink-monitor.c:581
+#: ../src/ip6-manager/nm-netlink-listener.c:351
 #, c-format
 msgid "error processing netlink message: %s"
 msgstr "నెట్‌లింక్ సందేశమును ప్రోసెసింగ్ చేయుటలో దోషము: %s"
 
-#: ../src/nm-netlink-monitor.c:260
+#: ../src/nm-netlink-monitor.c:259
 #, c-format
 msgid "unable to allocate netlink handle for monitoring link status: %s"
 msgstr "లింకు స్థితిని పర్యవేక్షించుటకు నెట్‌లింకు హాండిల్‌ను కేటాయించలేక పోయింది: %s"
 
-#: ../src/nm-netlink-monitor.c:270
+#: ../src/nm-netlink-monitor.c:269
 #, c-format
 msgid "unable to connect to netlink for monitoring link status: %s"
 msgstr "లింకు స్థితిని పర్యవేక్షించుటకు నెట్‌లింకుకు అనుసంధానము కాలేకపోయింది: %s"
 
-#: ../src/nm-netlink-monitor.c:278
+#: ../src/nm-netlink-monitor.c:277
 #, c-format
 msgid "unable to join netlink group for monitoring link status: %s"
 msgstr "లింకు స్థితిని పర్యవేక్షించుటకు నెట్‌లింకు సమూహమును కలుపలేక పోయింది:%s"
 
-#: ../src/nm-netlink-monitor.c:286
+#: ../src/nm-netlink-monitor.c:285
 #, c-format
 msgid "unable to allocate netlink link cache for monitoring link status: %s"
 msgstr "లింకు స్థితిని పర్యవేక్షించుటకు నెట్‌లింకు క్యాచీని కేటాయించలేక పోయింది: %s"
 
-#: ../src/nm-netlink-monitor.c:494
-#: ../src/ip6-manager/nm-netlink-listener.c:382
+#: ../src/nm-netlink-monitor.c:493
+#: ../src/ip6-manager/nm-netlink-listener.c:381
 msgid "error occurred while waiting for data on socket"
 msgstr "సాకెట్ నందు డాటా కొరకు వేచివుండునప్పుడు దోషము సంభవించినది"
 
-#: ../src/nm-netlink-monitor.c:558
+#: ../src/nm-netlink-monitor.c:557 ../src/nm-netlink-monitor.c:570
 #, c-format
 msgid "error updating link cache: %s"
 msgstr "లింకు క్యాచీని నవీకరించుటలో దోషము: %s"
 
-#: ../src/NetworkManager.c:330
+#: ../src/main.c:498
 #, c-format
 msgid "Invalid option.  Please use --help to see a list of valid options.\n"
 msgstr "చెల్లని ఐచ్చికము.  చెల్లునటువంటి ఐచ్చికముల జాబితా కొరకు --help వుపయోగించండి.\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:304
+#: ../src/main.c:558
+#, c-format
+msgid "%s.  Please use --help to see a list of valid options.\n"
+msgstr "%s.  చెల్లునటువంటి ఐచ్చికముల జాబితా చూచుటకు దయచేసి --help వుపయోగించుము.\n"
+
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:325
 msgid "# Created by NetworkManager\n"
 msgstr "# నెట్వర్కునిర్వాహిక ద్వారా సృష్టించబడింది\n"
 
-#: ../src/dhcp-manager/nm-dhcp-dhclient.c:310
+#: ../src/dhcp-manager/nm-dhcp-dhclient.c:341
 #, c-format
 msgid ""
 "# Merged from %s\n"
@@ -428,38 +1266,62 @@ msgstr ""
 "# %sనుండి కలుపబడింది\n"
 "\n"
 
-#: ../src/ip6-manager/nm-netlink-listener.c:200
+#: ../src/dhcp-manager/nm-dhcp-manager.c:279
+msgid "no usable DHCP client could be found."
+msgstr "ఎటువంటి వుపయోగకర DHCP క్లైంట్ కనుగొనబడలేదు."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:288
+msgid "'dhclient' could be found."
+msgstr "'dhclient' కనుగొనబడ గలదు."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:298
+msgid "'dhcpcd' could be found."
+msgstr "'dhcpcd' కనుగొనబడ గలదు."
+
+#: ../src/dhcp-manager/nm-dhcp-manager.c:306
+#, c-format
+msgid "unsupported DHCP client '%s'"
+msgstr "మద్దతీయని DHCP క్లైంట్ '%s'"
+
+#: ../src/ip6-manager/nm-netlink-listener.c:199
 #, c-format
-#| msgid "unable to allocate netlink handle for monitoring link status: %s"
 msgid "unable to allocate netlink handle: %s"
 msgstr "నెట్‌లింక్ సంభాలికను కేటాయించలేక పోయింది: %s"
 
-#: ../src/ip6-manager/nm-netlink-listener.c:210
+#: ../src/ip6-manager/nm-netlink-listener.c:209
 #, c-format
-#| msgid "unable to connect to netlink for monitoring link status: %s"
 msgid "unable to connect to netlink: %s"
 msgstr "నెట్‌లింక్‌కు అనుసంధానము కాలేకపోయింది: %s"
 
-#: ../src/ip6-manager/nm-netlink-listener.c:307
+#: ../src/ip6-manager/nm-netlink-listener.c:306
 #, c-format
-#| msgid "unable to join netlink group for monitoring link status: %s"
 msgid "unable to join netlink group: %s"
 msgstr "నెట్‌లింకు సమూహాన్ని చేర్చుకొనలేక పోయింది: %s"
 
-#: ../src/named-manager/nm-named-manager.c:315
+#: ../src/logging/nm-logging.c:146
+#, c-format
+msgid "Unknown log level '%s'"
+msgstr "తెలియని లాగ్ స్థాయి '%s'"
+
+#: ../src/logging/nm-logging.c:171
+#, c-format
+msgid "Unknown log domain '%s'"
+msgstr "తెలియని లాగ్ డొమైన్ '%s'"
+
+#: ../src/named-manager/nm-named-manager.c:314
 msgid "NOTE: the libc resolver may not support more than 3 nameservers."
 msgstr "గమనిక: libc రిజాల్వర్ 3 నామపు సేవికలకన్నా యెక్కువ వాటికి మద్దతివ్వలేదు."
 
-#: ../src/named-manager/nm-named-manager.c:317
+#: ../src/named-manager/nm-named-manager.c:316
 msgid "The nameservers listed below may not be recognized."
 msgstr "క్రిందన జాబితాచేసివున్న నామపుసేవికలు గుర్తించబడక పోవచ్చును."
 
-#: ../src/system-settings/nm-default-wired-connection.c:194
+#: ../src/system-settings/nm-default-wired-connection.c:157
 #, c-format
 msgid "Auto %s"
 msgstr "స్వయంచాలక %s"
 
-#: ../system-settings/plugins/ifcfg-rh/reader.c:2406
+#: ../system-settings/plugins/ifcfg-rh/reader.c:3229
 msgid "System"
 msgstr "సిస్టమ్"
 
@@ -484,7 +1346,6 @@ msgid "System policy prevents modification of system settings"
 msgstr "సిస్టమ్ అమరికలు సవరించుటకు సిస్టమ్ పాలసి నిరోధిస్తుంది"
 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:6
-#| msgid "System policy prevents modification of system settings"
 msgid "System policy prevents modification of the persistent system hostname"
 msgstr "నిరంతర సిస్టమ్ హోస్టునామమును సవరించుటను సిస్టమ్ విధానము నిరోధించుచున్నది"
 
@@ -495,4 +1356,3 @@ msgstr "రక్షిత WiFi నెట్వర్కు ద్వారా 
 #: ../policy/org.freedesktop.network-manager-settings.system.policy.in.h:8
 msgid "System policy prevents sharing connections via an open WiFi network"
 msgstr "ఓపెన్ WiFi నెట్వర్కు ద్వారా అనుసంధానములను భాగస్వామ్యపరచుట సిస్టమ్ విధానము నిరోధించుచున్నది"
-
diff --git a/src/Makefile.am b/src/Makefile.am
index f351c78..214f754 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,4 +1,5 @@
 SUBDIRS= \
+	logging \
 	named-manager \
 	vpn-manager \
 	dhcp-manager \
@@ -16,6 +17,7 @@ SUBDIRS= \
 INCLUDES = -I${top_srcdir}                   \
            -I${top_srcdir}/include           \
            -I${top_builddir}/marshallers   \
+           -I${top_srcdir}/src/logging \
            -I${top_srcdir}/src/named-manager \
            -I${top_srcdir}/src/vpn-manager   \
            -I${top_srcdir}/src/dhcp-manager  \
@@ -30,13 +32,18 @@ INCLUDES = -I${top_srcdir}                   \
            -I${top_srcdir}/callouts
 
 ###########################################
-# DHCP test library
+# Test libraries
 ###########################################
 
-noinst_LTLIBRARIES = libtest-dhcp.la
+noinst_LTLIBRARIES = libtest-dhcp.la libtest-policy-hosts.la
+
+###########################################
+# DHCP test library
+###########################################
 
 libtest_dhcp_la_SOURCES = \
 	nm-ip4-config.c \
+	nm-ip6-config.c \
 	nm-hostname-provider.c \
 	nm-dbus-manager.c
 
@@ -46,11 +53,26 @@ libtest_dhcp_la_CPPFLAGS = \
 	$(LIBNL_CFLAGS)
 
 libtest_dhcp_la_LIBADD = \
+	$(top_builddir)/marshallers/libmarshallers.la \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(GLIB_LIBS) \
 	$(DBUS_LIBS) \
 	$(LIBNL_LIBS)
 
+###########################################
+# Hosts policy test library
+###########################################
+
+libtest_policy_hosts_la_SOURCES = \
+	nm-policy-hosts.c \
+	nm-policy-hosts.h
+
+libtest_policy_hosts_la_CPPFLAGS = \
+	$(GLIB_CFLAGS)
+
+libtest_policy_hosts_la_LIBADD = \
+	$(GLIB_LIBS)
+
 
 ###########################################
 # NetworkManager
@@ -74,8 +96,14 @@ NetworkManager_SOURCES = \
 		nm-device-olpc-mesh.h	\
 		nm-device-bt.c \
 		nm-device-bt.h \
-		NetworkManagerAP.c \
-		NetworkManagerAP.h \
+		nm-device-modem.h \
+		nm-device-modem.c \
+		nm-device-cdma.c \
+		nm-device-cdma.h \
+		nm-device-gsm.c \
+		nm-device-gsm.h \
+		nm-wifi-ap.c \
+		nm-wifi-ap.h \
 		nm-dbus-manager.h \
 		nm-dbus-manager.c \
 		nm-udev-manager.c \
@@ -90,15 +118,15 @@ NetworkManager_SOURCES = \
 		nm-secrets-provider-interface.h \
 		nm-active-connection.h \
 		nm-active-connection.c \
-		NetworkManager.c \
-		NetworkManagerPolicy.c \
-		NetworkManagerPolicy.h \
+		main.c \
+		nm-policy.c \
+		nm-policy.h \
+		nm-policy-hosts.c \
+		nm-policy-hosts.h \
 		NetworkManagerUtils.c \
 		NetworkManagerUtils.h \
-		NetworkManagerSystem.c \
-		NetworkManagerSystem.h \
-		nm-logging.c \
-		nm-logging.h \
+		nm-system.c \
+		nm-system.h \
 		nm-manager.c \
 		nm-manager.h \
 		nm-netlink-monitor.c \
@@ -113,6 +141,8 @@ NetworkManager_SOURCES = \
 		nm-netlink.h \
 		nm-dhcp4-config.c \
 		nm-dhcp4-config.h \
+		nm-dhcp6-config.c \
+		nm-dhcp6-config.h \
 		nm-rfkill.h
 
 nm-access-point-glue.h: $(top_srcdir)/introspection/nm-access-point.xml
@@ -148,6 +178,15 @@ nm-active-connection-glue.h: $(top_srcdir)/introspection/nm-active-connection.xm
 nm-dhcp4-config-glue.h: $(top_srcdir)/introspection/nm-dhcp4-config.xml
 	dbus-binding-tool --prefix=nm_dhcp4_config --mode=glib-server --output=$@ $<
 
+nm-dhcp6-config-glue.h: $(top_srcdir)/introspection/nm-dhcp6-config.xml
+	dbus-binding-tool --prefix=nm_dhcp6_config --mode=glib-server --output=$@ $<
+
+nm-device-cdma-glue.h: $(top_srcdir)/introspection/nm-device-cdma.xml
+	dbus-binding-tool --prefix=nm_device_cdma --mode=glib-server --output=$@ $<
+
+nm-device-gsm-glue.h: $(top_srcdir)/introspection/nm-device-gsm.xml
+	dbus-binding-tool --prefix=nm_device_gsm --mode=glib-server --output=$@ $<
+
 BUILT_SOURCES = \
 	nm-access-point-glue.h \
 	nm-manager-glue.h \
@@ -156,10 +195,13 @@ BUILT_SOURCES = \
 	nm-device-wifi-glue.h \
 	nm-device-olpc-mesh-glue.h \
 	nm-device-bt-glue.h \
+	nm-device-cdma-glue.h \
+	nm-device-gsm-glue.h \
 	nm-ip4-config-glue.h \
 	nm-ip6-config-glue.h \
 	nm-active-connection-glue.h \
-	nm-dhcp4-config-glue.h
+	nm-dhcp4-config-glue.h \
+	nm-dhcp6-config-glue.h
 
 NetworkManager_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
@@ -182,6 +224,7 @@ NetworkManager_CPPFLAGS = \
 
 NetworkManager_LDADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	./logging/libnm-logging.la \
 	./named-manager/libnamed-manager.la \
 	./vpn-manager/libvpn-manager.la \
 	./dhcp-manager/libdhcp-manager.la \
diff --git a/src/NetworkManager.c b/src/NetworkManager.c
deleted file mode 100644
index 09a4320..0000000
--- a/src/NetworkManager.c
+++ /dev/null
@@ -1,680 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2005 - 2008 Novell, Inc.
- */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <glib.h>
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <getopt.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <glib/gi18n.h>
-#include <gmodule.h>
-#include <string.h>
-
-#include "NetworkManager.h"
-#include "nm-utils.h"
-#include "NetworkManagerUtils.h"
-#include "nm-manager.h"
-#include "NetworkManagerPolicy.h"
-#include "NetworkManagerSystem.h"
-#include "nm-named-manager.h"
-#include "nm-dbus-manager.h"
-#include "nm-supplicant-manager.h"
-#include "nm-dhcp-manager.h"
-#include "nm-hostname-provider.h"
-#include "nm-netlink-monitor.h"
-#include "nm-vpn-manager.h"
-#include "nm-logging.h"
-
-#define NM_DEFAULT_PID_FILE	LOCALSTATEDIR"/run/NetworkManager.pid"
-#define NM_DEFAULT_SYSTEM_CONF_FILE	SYSCONFDIR"/NetworkManager/nm-system-settings.conf"
-#define NM_DEFAULT_SYSTEM_STATE_FILE	LOCALSTATEDIR"/lib/NetworkManager/NetworkManager.state"
-
-/*
- * Globals
- */
-static NMManager *manager = NULL;
-static GMainLoop *main_loop = NULL;
-
-typedef struct {
-	time_t time;
-	GQuark domain;
-	guint32 code;
-	guint32 count;
-} MonitorInfo;
-
-static gboolean
-detach_monitor (gpointer data)
-{
-	nm_info ("Detaching netlink event monitor");
-	nm_netlink_monitor_detach (NM_NETLINK_MONITOR (data));
-	return FALSE;
-}
-
-static void
-nm_error_monitoring_device_link_state (NMNetlinkMonitor *monitor,
-									   GError *error,
-									   gpointer user_data)
-{
-	MonitorInfo *info = (MonitorInfo *) user_data;
-	time_t now;
-
-	now = time (NULL);
-
-	if (info->domain != error->domain || info->code != error->code || (info->time && now > info->time + 10)) {
-		/* FIXME: Try to handle the error instead of just printing it. */
-		nm_warning ("error monitoring device for netlink events: %s\n",
-					error->message);
-
-		info->time = now;
-		info->domain = error->domain;
-		info->code = error->code;
-		info->count = 0;
-	}
-
-	info->count++;
-	if (info->count > 100) {
-		/* Broken drivers will sometimes cause a flood of netlink errors.
-		 * rh #459205, novell #443429, lp #284507
-		 */
-		nm_warning ("Excessive netlink errors ocurred, disabling netlink monitor.");
-		nm_warning ("Link change events will not be processed.");
-		g_idle_add_full (G_PRIORITY_HIGH, detach_monitor, monitor, NULL);
-	}
-}
-
-static gboolean
-nm_monitor_setup (void)
-{
-	GError *error = NULL;
-	NMNetlinkMonitor *monitor;
-	MonitorInfo *info;
-
-	monitor = nm_netlink_monitor_get ();
-	nm_netlink_monitor_open_connection (monitor, &error);
-	if (error != NULL)
-	{
-		nm_warning ("could not monitor wired ethernet devices: %s",
-					error->message);
-		g_error_free (error);
-		g_object_unref (monitor);
-		return FALSE;
-	}
-
-	info = g_new0 (MonitorInfo, 1);
-	g_signal_connect_data (G_OBJECT (monitor), "error",
-						   G_CALLBACK (nm_error_monitoring_device_link_state),
-						   info,
-						   (GClosureNotify) g_free,
-						   0);
-
-	nm_netlink_monitor_attach (monitor);
-
-	/* Request initial status of cards */
-	nm_netlink_monitor_request_status (monitor, NULL);
-
-	return TRUE;
-}
-
-static gboolean quit_early = FALSE;
-
-static void
-nm_signal_handler (int signo)
-{
-	static int in_fatal = 0;
-
-	/* avoid loops */
-	if (in_fatal > 0)
-		return;
-	++in_fatal;
-
-	switch (signo)
-	{
-		case SIGSEGV:
-		case SIGBUS:
-		case SIGILL:
-		case SIGABRT:
-			nm_warning ("Caught signal %d.  Generating backtrace...", signo);
-			nm_logging_backtrace ();
-			exit (1);
-			break;
-
-		case SIGFPE:
-		case SIGPIPE:
-			/* let the fatal signals interrupt us */
-			--in_fatal;
-
-			nm_warning ("Caught signal %d, shutting down abnormally.  Generating backtrace...", signo);
-			nm_logging_backtrace ();
-			g_main_loop_quit (main_loop);
-			break;
-
-		case SIGINT:
-		case SIGTERM:
-			/* let the fatal signals interrupt us */
-			--in_fatal;
-
-			nm_warning ("Caught signal %d, shutting down normally.", signo);
-			quit_early = TRUE;
-			g_main_loop_quit (main_loop);
-			break;
-
-		case SIGHUP:
-			--in_fatal;
-			/* FIXME:
-			 * Reread config stuff like system config files, VPN service files, etc
-			 */
-			break;
-
-		case SIGUSR1:
-			--in_fatal;
-			/* FIXME:
-			 * Play with log levels or something
-			 */
-			break;
-
-		default:
-			signal (signo, nm_signal_handler);
-			break;
-	}
-}
-
-static void
-setup_signals (void)
-{
-	struct sigaction action;
-	sigset_t mask;
-
-	sigemptyset (&mask);
-	action.sa_handler = nm_signal_handler;
-	action.sa_mask = mask;
-	action.sa_flags = 0;
-	sigaction (SIGTERM,  &action, NULL);
-	sigaction (SIGINT,  &action, NULL);
-	sigaction (SIGILL,  &action, NULL);
-	sigaction (SIGBUS,  &action, NULL);
-	sigaction (SIGFPE,  &action, NULL);
-	sigaction (SIGHUP,  &action, NULL);
-	sigaction (SIGSEGV, &action, NULL);
-	sigaction (SIGABRT, &action, NULL);
-	sigaction (SIGUSR1,  &action, NULL);
-}
-
-static gboolean
-write_pidfile (const char *pidfile)
-{
- 	char pid[16];
-	int fd;
-	gboolean success = FALSE;
- 
-	if ((fd = open (pidfile, O_CREAT|O_WRONLY|O_TRUNC, 00644)) < 0) {
-		nm_warning ("Opening %s failed: %s", pidfile, strerror (errno));
-		return FALSE;
-	}
-
- 	snprintf (pid, sizeof (pid), "%d", getpid ());
-	if (write (fd, pid, strlen (pid)) < 0)
-		nm_warning ("Writing to %s failed: %s", pidfile, strerror (errno));
-	else
-		success = TRUE;
-
-	if (close (fd))
-		nm_warning ("Closing %s failed: %s", pidfile, strerror (errno));
-
-	return success;
-}
-
-/* Check whether the pidfile already exists and contains PID of a running NetworkManager
- *  Returns:  FALSE - specified pidfile doesn't exist or doesn't contain PID of a running NM process
- *            TRUE  - specified pidfile already exists and contains PID of a running NM process
- */
-static gboolean
-check_pidfile (const char *pidfile)
-{
-	char *contents = NULL;
-	gsize len = 0;
-	glong pid;
-	char *proc_cmdline = NULL;
-	gboolean nm_running = FALSE;
-	const char *process_name;
-
-	if (!g_file_get_contents (pidfile, &contents, &len, NULL))
-		return FALSE;
-
-	if (len <= 0)
-		goto done;
-
-	errno = 0;
-	pid = strtol (contents, NULL, 10);
-	if (pid <= 0 || pid > 65536 || errno)
-		goto done;
-
-	g_free (contents);
-	proc_cmdline = g_strdup_printf ("/proc/%ld/cmdline", pid);
-	if (!g_file_get_contents (proc_cmdline, &contents, &len, NULL))
-		goto done;
-
-	process_name = strrchr (contents, '/');
-	if (process_name)
-		process_name++;
-	else
-		process_name = contents;
-	if (strcmp (process_name, "NetworkManager") == 0) {
-		/* Check that the process exists */
-		if (kill (pid, 0) == 0) {
-			g_warning ("NetworkManager is already running (pid %ld)", pid);
-			nm_running = TRUE;
-		}
-	}
-
-done:
-	g_free (proc_cmdline);
-	g_free (contents);
-	return nm_running;
-}
-
-static gboolean
-parse_config_file (const char *filename, char **plugins, GError **error)
-{
-	GKeyFile *config;
-
-	config = g_key_file_new ();
-	if (!config) {
-		g_set_error (error, 0, 0,
-		             "Not enough memory to load config file.");
-		return FALSE;
-	}
-
-	g_key_file_set_list_separator (config, ',');
-	if (!g_key_file_load_from_file (config, filename, G_KEY_FILE_NONE, error))
-		return FALSE;
-
-	*plugins = g_key_file_get_value (config, "main", "plugins", error);
-	if (*error)
-		return FALSE;
-
-	g_key_file_free (config);
-	return TRUE;
-}
-
-static gboolean
-parse_state_file (const char *filename,
-                  gboolean *net_enabled,
-                  gboolean *wifi_enabled,
-                  gboolean *wwan_enabled,
-                  GError **error)
-{
-	GKeyFile *state_file;
-	GError *tmp_error = NULL;
-	gboolean wifi, net, wwan;
-
-	g_return_val_if_fail (net_enabled != NULL, FALSE);
-	g_return_val_if_fail (wifi_enabled != NULL, FALSE);
-	g_return_val_if_fail (wwan_enabled != NULL, FALSE);
-
-	state_file = g_key_file_new ();
-	if (!state_file) {
-		g_set_error (error, 0, 0,
-		             "Not enough memory to load state file.");
-		return FALSE;
-	}
-
-	g_key_file_set_list_separator (state_file, ',');
-	if (!g_key_file_load_from_file (state_file, filename, G_KEY_FILE_KEEP_COMMENTS, &tmp_error)) {
-		/* This is kinda ugly; create the file and directory if it doesn't
-		 * exist yet.  We can't rely on distros necessarily creating the
-		 * /var/lib/NetworkManager for us since we have to ensure that
-		 * users upgrading NM get this working too.
-		 */
-		if (   tmp_error->domain == G_FILE_ERROR
-		    && tmp_error->code == G_FILE_ERROR_NOENT) {
-			char *data, *dirname;
-			gsize len = 0;
-			gboolean ret = FALSE;
-
-			/* try to create the directory if it doesn't exist */
-			dirname = g_path_get_dirname (filename);
-			errno = 0;
-			if (mkdir (dirname, 0755) != 0) {
-				if (errno != EEXIST) {
-					g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_ACCES,
-					             "Error creating state directory %s: %d", dirname, errno);
-					g_free (dirname);
-					return FALSE;
-				}
-			}
-			g_free (dirname);
-
-			/* Write out the initial state to the state file */
-			g_key_file_set_boolean (state_file, "main", "NetworkingEnabled", *net_enabled);
-			g_key_file_set_boolean (state_file, "main", "WirelessEnabled", *wifi_enabled);
-			g_key_file_set_boolean (state_file, "main", "WWANEnabled", *wwan_enabled);
-
-			data = g_key_file_to_data (state_file, &len, NULL);
-			if (data)
-				ret = g_file_set_contents (filename, data, len, error);
-			g_free (data);
-
-			return ret;
-		} else {
-			g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-			g_clear_error (&tmp_error);
-		}
-
-		/* Otherwise, file probably corrupt or inaccessible */
-		return FALSE;
-	}
-
-	/* Reading state bits of NetworkManager; an error leaves the passed-in state
-	 * value unchanged.
-	 */
-	net = g_key_file_get_boolean (state_file, "main", "NetworkingEnabled", &tmp_error);
-	if (tmp_error)
-		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-	else
-		*net_enabled = net;
-	g_clear_error (&tmp_error);
-
-	wifi = g_key_file_get_boolean (state_file, "main", "WirelessEnabled", &tmp_error);
-	if (tmp_error) {
-		g_clear_error (error);
-		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-	} else
-		*wifi_enabled = wifi;
-	g_clear_error (&tmp_error);
-
-	wwan = g_key_file_get_boolean (state_file, "main", "WWANEnabled", &tmp_error);
-	if (tmp_error) {
-		g_clear_error (error);
-		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
-	} else
-		*wwan_enabled = wwan;
-	g_clear_error (&tmp_error);
-
-	g_key_file_free (state_file);
-
-	return TRUE;
-}
-
-/*
- * main
- *
- */
-int
-main (int argc, char *argv[])
-{
-	GOptionContext *opt_ctx = NULL;
-	gboolean become_daemon = FALSE;
-	gboolean g_fatal_warnings = FALSE;
-	char *pidfile = NULL, *user_pidfile = NULL;
-	char *config = NULL, *plugins = NULL;
-	char *state_file = NM_DEFAULT_SYSTEM_STATE_FILE;
-	gboolean wifi_enabled = TRUE, net_enabled = TRUE, wwan_enabled = TRUE;
-	gboolean success;
-	NMPolicy *policy = NULL;
-	NMVPNManager *vpn_manager = NULL;
-	NMNamedManager *named_mgr = NULL;
-	NMDBusManager *dbus_mgr = NULL;
-	NMSupplicantManager *sup_mgr = NULL;
-	NMDHCPManager *dhcp_mgr = NULL;
-	GError *error = NULL;
-	gboolean wrote_pidfile = FALSE;
-
-	GOptionEntry options[] = {
-		{ "no-daemon", 0, 0, G_OPTION_ARG_NONE, &become_daemon, "Don't become a daemon", NULL },
-		{ "g-fatal-warnings", 0, 0, G_OPTION_ARG_NONE, &g_fatal_warnings, "Make all warnings fatal", NULL },
-		{ "pid-file", 0, 0, G_OPTION_ARG_FILENAME, &user_pidfile, "Specify the location of a PID file", "filename" },
-		{ "state-file", 0, 0, G_OPTION_ARG_FILENAME, &state_file, "State file location", "/path/to/state.file" },
-		{ "config", 0, 0, G_OPTION_ARG_FILENAME, &config, "Config file location", "/path/to/config.file" },
-		{ "plugins", 0, 0, G_OPTION_ARG_STRING, &plugins, "List of plugins separated by ,", "plugin1,plugin2" },
-		{NULL}
-	};
-
-	if (getuid () != 0) {
-		g_printerr ("You must be root to run NetworkManager!\n");
-		exit (1);
-	}
-
-	if (!g_module_supported ()) {
-		g_printerr ("GModules are not supported on your platform!");
-		exit (1);
-	}
-
-	bindtextdomain (GETTEXT_PACKAGE, NMLOCALEDIR);
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-	textdomain (GETTEXT_PACKAGE);
-
-	/* Parse options */
-	opt_ctx = g_option_context_new ("");
-	g_option_context_set_translation_domain (opt_ctx, "UTF-8");
-	g_option_context_set_ignore_unknown_options (opt_ctx, FALSE);
-	g_option_context_set_help_enabled (opt_ctx, TRUE);
-	g_option_context_add_main_entries (opt_ctx, options, NULL);
-
-	g_option_context_set_summary (opt_ctx,
-		"NetworkManager monitors all network connections and automatically\nchooses the best connection to use.  It also allows the user to\nspecify wireless access points which wireless cards in the computer\nshould associate with.");
-
-	success = g_option_context_parse (opt_ctx, &argc, &argv, NULL);
-	g_option_context_free (opt_ctx);
-
-	if (!success) {
-		fprintf (stderr, _("Invalid option.  Please use --help to see a list of valid options.\n"));
-		exit (1);
-	}
-
-	pidfile = g_strdup (user_pidfile ? user_pidfile : NM_DEFAULT_PID_FILE);
-
-	/* check pid file */
-	if (check_pidfile (pidfile))
-		exit (1);
-
-	/* Parse the config file */
-	if (config) {
-		if (!parse_config_file (config, &plugins, &error)) {
-			g_warning ("Config file %s invalid: (%d) %s.",
-			           config,
-			           error ? error->code : -1,
-			           (error && error->message) ? error->message : "unknown");
-			exit (1);
-		}
-	} else {
-		config = NM_DEFAULT_SYSTEM_CONF_FILE;
-		if (!parse_config_file (config, &plugins, &error)) {
-			g_warning ("Default config file %s invalid: (%d) %s.",
-			           config,
-			           error ? error->code : -1,
-			           (error && error->message) ? error->message : "unknown");
-			config = NULL;
-			/* Not a hard failure */
-		}
-	}
-
-	g_clear_error (&error);
-
-	/* Parse the state file */
-	if (!parse_state_file (state_file, &net_enabled, &wifi_enabled, &wwan_enabled, &error)) {
-		g_warning ("State file %s parsing failed: (%d) %s.",
-		           state_file,
-		           error ? error->code : -1,
-		           (error && error->message) ? error->message : "unknown");
-		/* Not a hard failure */
-	}
-
-	/* Tricky: become_daemon is FALSE by default, so unless it's TRUE because
-	 * of a CLI option, it'll become TRUE after this
-	 */
-	become_daemon = !become_daemon;
-	if (become_daemon) {
-		if (daemon (0, 0) < 0) {
-			int saved_errno;
-
-			saved_errno = errno;
-			nm_error ("Could not daemonize: %s [error %u]",
-			          g_strerror (saved_errno),
-			          saved_errno);
-			exit (1);
-		}
-		if (write_pidfile (pidfile))
-			wrote_pidfile = TRUE;
-	}
-
-	if (g_fatal_warnings) {
-		GLogLevelFlags fatal_mask;
-
-		fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
-		fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
-		g_log_set_always_fatal (fatal_mask);
-	}
-
-	/*
-	 * Set the umask to 0022, which results in 0666 & ~0022 = 0644.
-	 * Otherwise, if root (or an su'ing user) has a wacky umask, we could
-	 * write out an unreadable resolv.conf.
-	 */
-	umask (022);
-
-	g_type_init ();
-	if (!g_thread_supported ())
-		g_thread_init (NULL);
-	dbus_g_thread_init ();
-
-	setup_signals ();
-
-	nm_logging_setup (become_daemon);
-
-	nm_info ("starting...");
-	success = FALSE;
-
-	main_loop = g_main_loop_new (NULL, FALSE);
-
-	/* Create watch functions that monitor cards for link status. */
-	if (!nm_monitor_setup ())
-		goto done;
-
-	/* Initialize our DBus service & connection */
-	dbus_mgr = nm_dbus_manager_get ();
-
-	vpn_manager = nm_vpn_manager_get ();
-	if (!vpn_manager) {
-		nm_warning ("Failed to start the VPN manager.");
-		goto done;
-	}
-
-	named_mgr = nm_named_manager_get ();
-	if (!named_mgr) {
-		nm_warning ("Failed to start the named manager.");
-		goto done;
-	}
-
-	manager = nm_manager_get (config,
-	                          plugins,
-	                          state_file,
-	                          net_enabled,
-	                          wifi_enabled,
-	                          wwan_enabled,
-	                          &error);
-	if (manager == NULL) {
-		nm_error ("Failed to initialize the network manager: %s",
-		          error && error->message ? error->message : "(unknown)");
-		goto done;
-	}
-
-	policy = nm_policy_new (manager, vpn_manager);
-	if (policy == NULL) {
-		nm_error ("Failed to initialize the policy.");
-		goto done;
-	}
-
-	/* Initialize the supplicant manager */
-	sup_mgr = nm_supplicant_manager_get ();
-	if (!sup_mgr) {
-		nm_error ("Failed to initialize the supplicant manager.");
-		goto done;
-	}
-
-	dhcp_mgr = nm_dhcp_manager_get ();
-	if (!dhcp_mgr) {
-		nm_warning ("Failed to start the DHCP manager.");
-		goto done;
-	}
-
-	nm_dhcp_manager_set_hostname_provider (dhcp_mgr, NM_HOSTNAME_PROVIDER (manager));
-
-	/* Start our DBus service */
-	if (!nm_dbus_manager_start_service (dbus_mgr)) {
-		nm_warning ("Failed to start the dbus service.");
-		goto done;
-	}
-
-	nm_manager_start (manager);
-
-	/* Bring up the loopback interface. */
-	nm_system_enable_loopback ();
-
-	success = TRUE;
-
-	/* Told to quit before getting to the mainloop by the signal handler */
-	if (quit_early == TRUE)
-		goto done;
-
-	g_main_loop_run (main_loop);
-
-done:
-	if (policy)
-		nm_policy_destroy (policy);
-
-	if (manager)
-		g_object_unref (manager);
-
-	if (vpn_manager)
-		g_object_unref (vpn_manager);
-
-	if (named_mgr)
-		g_object_unref (named_mgr);
-
-	if (dhcp_mgr)
-		g_object_unref (dhcp_mgr);
-
-	if (sup_mgr)
-		g_object_unref (sup_mgr);
-
-	if (dbus_mgr)
-		g_object_unref (dbus_mgr);
-
-	nm_logging_shutdown ();
-
-	if (pidfile && wrote_pidfile)
-		unlink (pidfile);
-	g_free (pidfile);
-
-	nm_info ("exiting (%s)", success ? "success" : "error");
-	exit (success ? 0 : 1);
-}
diff --git a/src/NetworkManagerAP.c b/src/NetworkManagerAP.c
deleted file mode 100644
index 9b95924..0000000
--- a/src/NetworkManagerAP.c
+++ /dev/null
@@ -1,1476 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#include "wireless-helper.h"
-
-#include <string.h>
-
-#include "NetworkManagerAP.h"
-#include "NetworkManagerUtils.h"
-#include "nm-utils.h"
-#include "nm-dbus-manager.h"
-#include "wpa.h"
-#include "nm-properties-changed-signal.h"
-#include "nm-setting-wireless.h"
-
-#include "nm-access-point-glue.h"
-
-/*
- * Encapsulates Access Point information
- */
-typedef struct
-{
-	char *dbus_path;
-
-	/* Scanned or cached values */
-	GByteArray *	ssid;
-	struct ether_addr	address;
-	NM80211Mode		mode;
-	gint8			strength;
-	guint32			freq;		/* Frequency in MHz; ie 2412 (== 2.412 GHz) */
-	guint32			max_bitrate;/* Maximum bitrate of the AP in Kbit/s (ie 54000 Kb/s == 54Mbit/s) */
-
-	guint32			flags;		/* General flags */
-	guint32			wpa_flags;	/* WPA-related flags */
-	guint32			rsn_flags;	/* RSN (WPA2) -related flags */
-
-	/* Non-scanned attributes */
-	gboolean			fake;	/* Whether or not the AP is from a scan */
-	gboolean			broadcast;	/* Whether or not the AP is broadcasting (hidden) */
-	gboolean			user_created;	/* Whether or not the AP was created
-										 * by the user with "Create network..."
-										 * A subset of Ad-Hoc mode.  user_created
-										 * implies Ad-Hoc, but not necessarily
-										 * the other way around.
-										 */
-	glong				last_seen;	/* Last time the AP was seen in a scan in seconds */
-
-	/* Things from user prefs/NetworkManagerInfo */
-	GTimeVal			timestamp;
-	GSList *			user_addresses;
-} NMAccessPointPrivate;
-
-#define NM_AP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_AP, NMAccessPointPrivate))
-
-G_DEFINE_TYPE (NMAccessPoint, nm_ap, G_TYPE_OBJECT)
-
-enum {
-	PROPERTIES_CHANGED,
-
-	LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-enum {
-	PROP_0,
-	PROP_FLAGS,
-	PROP_WPA_FLAGS,
-	PROP_RSN_FLAGS,
-	PROP_SSID,
-	PROP_FREQUENCY,
-	PROP_HW_ADDRESS,
-	PROP_MODE,
-	PROP_MAX_BITRATE,
-	PROP_STRENGTH,
-	LAST_PROP
-};
-
-static void
-nm_ap_init (NMAccessPoint *ap)
-{
-	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (ap);
-
-	priv->dbus_path = NULL;
-	priv->mode = NM_802_11_MODE_INFRA;
-	priv->flags = NM_802_11_AP_FLAGS_NONE;
-	priv->wpa_flags = NM_802_11_AP_SEC_NONE;
-	priv->rsn_flags = NM_802_11_AP_SEC_NONE;
-	priv->broadcast = TRUE;
-}
-
-static void
-finalize (GObject *object)
-{
-	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
-
-	g_free (priv->dbus_path);
-	if (priv->ssid)
-		g_byte_array_free (priv->ssid, TRUE);
-	g_slist_foreach (priv->user_addresses, (GFunc)g_free, NULL);
-	g_slist_free (priv->user_addresses);
-
-	G_OBJECT_CLASS (nm_ap_parent_class)->finalize (object);
-}
-
-static void
-set_property (GObject *object, guint prop_id,
-		    const GValue *value, GParamSpec *pspec)
-{
-	NMAccessPoint *ap = NM_AP (object);
-
-	switch (prop_id) {
-	case PROP_FLAGS:
-		nm_ap_set_flags (ap, g_value_get_uint (value));
-		break;
-	case PROP_WPA_FLAGS:
-		nm_ap_set_wpa_flags (ap, g_value_get_uint (value));
-		break;
-	case PROP_RSN_FLAGS:
-		nm_ap_set_rsn_flags (ap, g_value_get_uint (value));
-		break;
-	case PROP_SSID:
-		nm_ap_set_ssid (ap, (GByteArray *) g_value_get_boxed (value));
-		break;
-	case PROP_FREQUENCY:
-		nm_ap_set_freq (ap, g_value_get_uint (value));
-		break;
-	case PROP_MODE:
-		nm_ap_set_mode (ap, g_value_get_uint (value));
-		break;
-	case PROP_MAX_BITRATE:
-		nm_ap_set_max_bitrate (ap, g_value_get_uint (value));
-		break;
-	case PROP_STRENGTH:
-		nm_ap_set_strength (ap, g_value_get_char (value));
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-get_property (GObject *object, guint prop_id,
-			  GValue *value, GParamSpec *pspec)
-{
-	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
-	GArray * ssid;
-	int len;
-	int i;
-
-	switch (prop_id) {
-	case PROP_FLAGS:
-		g_value_set_uint (value, priv->flags);
-		break;
-	case PROP_WPA_FLAGS:
-		g_value_set_uint (value, priv->wpa_flags);
-		break;
-	case PROP_RSN_FLAGS:
-		g_value_set_uint (value, priv->rsn_flags);
-		break;
-	case PROP_SSID:
-		len = priv->ssid ? priv->ssid->len : 0;
-		ssid = g_array_sized_new (FALSE, TRUE, sizeof (unsigned char), len);
-		for (i = 0; i < len; i++)
-			g_array_append_val (ssid, priv->ssid->data[i]);
-		g_value_set_boxed (value, ssid);
-		g_array_free (ssid, TRUE);
-		break;
-	case PROP_FREQUENCY:
-		g_value_set_uint (value, priv->freq);
-		break;
-	case PROP_HW_ADDRESS:
-		g_value_take_string (value, nm_ether_ntop (&priv->address));
-		break;
-	case PROP_MODE:
-		g_value_set_uint (value, priv->mode);
-		break;
-	case PROP_MAX_BITRATE:
-		g_value_set_uint (value, priv->max_bitrate);
-		break;
-	case PROP_STRENGTH:
-		g_value_set_char (value, priv->strength);
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-nm_ap_class_init (NMAccessPointClass *ap_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (ap_class);
-	guint32 all_sec_flags;
-
-	g_type_class_add_private (ap_class, sizeof (NMAccessPointPrivate));
-
-	/* virtual methods */
-	object_class->set_property = set_property;
-	object_class->get_property = get_property;
-	object_class->finalize = finalize;
-
-	/* properties */
-
-	all_sec_flags =   NM_802_11_AP_SEC_NONE
-	                | NM_802_11_AP_SEC_PAIR_WEP40
-	                | NM_802_11_AP_SEC_PAIR_WEP104
-	                | NM_802_11_AP_SEC_PAIR_TKIP
-	                | NM_802_11_AP_SEC_PAIR_CCMP
-	                | NM_802_11_AP_SEC_GROUP_WEP40
-	                | NM_802_11_AP_SEC_GROUP_WEP104
-	                | NM_802_11_AP_SEC_GROUP_TKIP
-	                | NM_802_11_AP_SEC_GROUP_CCMP
-	                | NM_802_11_AP_SEC_KEY_MGMT_PSK
-	                | NM_802_11_AP_SEC_KEY_MGMT_802_1X;
-
-	g_object_class_install_property
-		(object_class, PROP_FLAGS,
-		 g_param_spec_uint (NM_AP_FLAGS,
-							"Flags",
-							"Flags",
-							NM_802_11_AP_FLAGS_NONE,
-							NM_802_11_AP_FLAGS_PRIVACY,
-							NM_802_11_AP_FLAGS_NONE,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_WPA_FLAGS,
-		 g_param_spec_uint (NM_AP_WPA_FLAGS,
-							"WPA Flags",
-							"WPA Flags",
-							NM_802_11_AP_SEC_NONE,
-							all_sec_flags,
-							NM_802_11_AP_SEC_NONE,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_RSN_FLAGS,
-		 g_param_spec_uint (NM_AP_RSN_FLAGS,
-							"RSN Flags",
-							"RSN Flags",
-							NM_802_11_AP_SEC_NONE,
-							all_sec_flags,
-							NM_802_11_AP_SEC_NONE,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_SSID,
-	     g_param_spec_boxed (NM_AP_SSID,
-	                         "SSID",
-	                         "SSID",
-	                         DBUS_TYPE_G_UCHAR_ARRAY,
-	                         G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_FREQUENCY,
-		 g_param_spec_uint (NM_AP_FREQUENCY,
-							"Frequency",
-							"Frequency",
-							0, 10000, 0,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_HW_ADDRESS,
-		 g_param_spec_string (NM_AP_HW_ADDRESS,
-							  "MAC Address",
-							  "Hardware MAC address",
-							  NULL,
-							  G_PARAM_READABLE));
-	
-	g_object_class_install_property
-		(object_class, PROP_MODE,
-		 g_param_spec_uint (NM_AP_MODE,
-						   "Mode",
-						   "Mode",
-						   NM_802_11_MODE_ADHOC, NM_802_11_MODE_INFRA, NM_802_11_MODE_INFRA,
-						   G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_MAX_BITRATE,
-		 g_param_spec_uint (NM_AP_MAX_BITRATE,
-							"Max Bitrate",
-							"Max Bitrate",
-							0, G_MAXUINT16, 0,
-							G_PARAM_READWRITE));
-
-	g_object_class_install_property
-		(object_class, PROP_STRENGTH,
-		 g_param_spec_char (NM_AP_STRENGTH,
-							"Strength",
-							"Strength",
-							G_MININT8, G_MAXINT8, 0,
-							G_PARAM_READWRITE));
-
-	/* Signals */
-	signals[PROPERTIES_CHANGED] = 
-		nm_properties_changed_signal_new (object_class,
-								    G_STRUCT_OFFSET (NMAccessPointClass, properties_changed));
-
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (ap_class),
-							   &dbus_glib_nm_access_point_object_info);
-}
-
-void
-nm_ap_export_to_dbus (NMAccessPoint *ap)
-{
-	NMAccessPointPrivate *priv;
-	NMDBusManager *mgr;
-	DBusGConnection *g_connection;
-	static guint32 counter = 0;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->dbus_path) {
-		nm_warning ("Tried to export AP %s twice.", priv->dbus_path);
-		return;
-	}
-
-	mgr = nm_dbus_manager_get ();
-	g_assert (mgr);
-
-	g_connection = nm_dbus_manager_get_connection (mgr);
-	g_assert (g_connection);
-
-	priv->dbus_path = g_strdup_printf (NM_DBUS_PATH_ACCESS_POINT "/%d", counter++);
-	dbus_g_connection_register_g_object (g_connection, priv->dbus_path, G_OBJECT (ap));
-
-	g_object_unref (mgr);
-}
-
-/*
- * nm_ap_new
- *
- * Create a new, blank user access point info structure
- *
- */
-NMAccessPoint *nm_ap_new (void)
-{
-	GObject *object;
-
-	object = g_object_new (NM_TYPE_AP, NULL);
-	if (!object)
-		return NULL;
-
-	return (NMAccessPoint *) object;
-}
-
-
-#define IEEE80211_CAP_ESS       0x0001
-#define IEEE80211_CAP_IBSS      0x0002
-#define IEEE80211_CAP_PRIVACY   0x0010
-
-static void
-foreach_property_cb (gpointer key, gpointer value, gpointer user_data)
-{
-	GValue *variant = (GValue *) value;
-	NMAccessPoint *ap = (NMAccessPoint *) user_data;
-
-	if (G_VALUE_HOLDS_BOXED (variant)) {
-		GArray *array = g_value_get_boxed (variant);
-
-		if (!strcmp (key, "ssid")) {
-			guint32 len = MIN (IW_ESSID_MAX_SIZE, array->len);
-			GByteArray * ssid;
-
-			/* Stupid ieee80211 layer uses <hidden> */
-			if (((len == 8) || (len == 9))
-				&& (memcmp (array->data, "<hidden>", 8) == 0))
-				return;
-
-			if (nm_utils_is_empty_ssid ((const guint8 *) array->data, len))
-				return;
-
-			ssid = g_byte_array_sized_new (len);
-			g_byte_array_append (ssid, (const guint8 *) array->data, len);
-			nm_ap_set_ssid (ap, ssid);
-			g_byte_array_free (ssid, TRUE);
-		} else if (!strcmp (key, "bssid")) {
-			struct ether_addr addr;
-
-			if (array->len != ETH_ALEN)
-				return;
-			memset (&addr, 0, sizeof (struct ether_addr));
-			memcpy (&addr, array->data, ETH_ALEN);
-			nm_ap_set_address (ap, &addr);
-		} else if (!strcmp (key, "wpaie")) {
-			guint8 * ie = (guint8 *) array->data;
-			guint32 flags = nm_ap_get_wpa_flags (ap);
-
-			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
-				return;
-			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
-			nm_ap_set_wpa_flags (ap, flags);
-		} else if (!strcmp (key, "rsnie")) {
-			guint8 * ie = (guint8 *) array->data;
-			guint32 flags = nm_ap_get_rsn_flags (ap);
-
-			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
-				return;
-			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
-			nm_ap_set_rsn_flags (ap, flags);
-		}
-	} else if (G_VALUE_HOLDS_INT (variant)) {
-		gint32 int_val = g_value_get_int (variant);
-
-		if (!strcmp (key, "frequency")) {
-			nm_ap_set_freq (ap, (guint32) int_val);
-		} else if (!strcmp (key, "maxrate")) {
-			/* Supplicant reports as b/s, we use Kb/s internally */
-			nm_ap_set_max_bitrate (ap, int_val / 1000);
-		}
-	} else if (G_VALUE_HOLDS_UINT (variant)) {
-		guint32 val = g_value_get_uint (variant);
-
-		if (!strcmp (key, "capabilities")) {
-			if (val & IEEE80211_CAP_ESS) {
-				nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
-			} else if (val & IEEE80211_CAP_IBSS) {
-				nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
-			}
-
-			if (val & IEEE80211_CAP_PRIVACY) {
-				guint32 flags = nm_ap_get_flags (ap);
-				nm_ap_set_flags (ap, flags | NM_802_11_AP_FLAGS_PRIVACY);
-			}
-		}
-	}
-}
-
-
-NMAccessPoint *
-nm_ap_new_from_properties (GHashTable *properties)
-{
-	NMAccessPoint *ap;
-	GTimeVal cur_time;
-	const struct ether_addr * addr;
-	const char bad_bssid1[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-	const char bad_bssid2[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
-
-	g_return_val_if_fail (properties != NULL, NULL);
-
-	ap = nm_ap_new ();
-
-	g_object_freeze_notify (G_OBJECT (ap));
-	g_hash_table_foreach (properties, foreach_property_cb, ap);
-
-	/* ignore APs with invalid BSSIDs */
-	addr = nm_ap_get_address (ap);
-	if (   !(memcmp (addr->ether_addr_octet, bad_bssid1, ETH_ALEN))
-	    || !(memcmp (addr->ether_addr_octet, bad_bssid2, ETH_ALEN))) {
-		g_object_unref (ap);
-		return NULL;
-	}
-
-	g_get_current_time (&cur_time);
-	nm_ap_set_last_seen (ap, cur_time.tv_sec);
-
-	if (!nm_ap_get_ssid (ap))
-		nm_ap_set_broadcast (ap, FALSE);
-
-	g_object_thaw_notify (G_OBJECT (ap));
-
-	return ap;
-}
-
-#define PROTO_WPA "wpa"
-#define PROTO_RSN "rsn"
-
-static gboolean
-has_proto (NMSettingWirelessSecurity *sec, const char *proto)
-{
-	guint32 num_protos = nm_setting_wireless_security_get_num_protos (sec);
-	guint32 i;
-
-	if (num_protos == 0)
-		return TRUE; /* interpret no protos as "all" */
-
-	for (i = 0; i < num_protos; i++) {
-		if (!strcmp (nm_setting_wireless_security_get_proto (sec, i), proto))
-			return TRUE;
-	}
-	return FALSE;
-}
-
-static void
-add_pair_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
-{
-	guint32 num = nm_setting_wireless_security_get_num_pairwise (sec);
-	guint32 flags = NM_802_11_AP_SEC_NONE;
-	guint32 i;
-
-	/* If no ciphers are specified, that means "all" WPA ciphers */
-	if (num == 0) {
-		flags |= NM_802_11_AP_SEC_PAIR_TKIP | NM_802_11_AP_SEC_PAIR_CCMP;
-	} else {
-		for (i = 0; i < num; i++) {
-			const char *cipher = nm_setting_wireless_security_get_pairwise (sec, i);
-
-			if (!strcmp (cipher, "tkip"))
-				flags |= NM_802_11_AP_SEC_PAIR_TKIP;
-			else if (!strcmp (cipher, "ccmp"))
-				flags |= NM_802_11_AP_SEC_PAIR_CCMP;
-		}
-	}
-
-	if (has_proto (sec, PROTO_WPA))
-		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
-	if (has_proto (sec, PROTO_RSN))
-		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
-}
-
-static void
-add_group_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
-{
-	guint32 num = nm_setting_wireless_security_get_num_groups (sec);
-	guint32 flags = NM_802_11_AP_SEC_NONE;
-	guint32 i;
-
-	/* If no ciphers are specified, that means "all" WPA ciphers */
-	if (num == 0) {
-		flags |= NM_802_11_AP_SEC_GROUP_TKIP | NM_802_11_AP_SEC_GROUP_CCMP;
-	} else {
-		for (i = 0; i < num; i++) {
-			const char *cipher = nm_setting_wireless_security_get_group (sec, i);
-
-			if (!strcmp (cipher, "wep40"))
-				flags |= NM_802_11_AP_SEC_GROUP_WEP40;
-			else if (!strcmp (cipher, "wep104"))
-				flags |= NM_802_11_AP_SEC_GROUP_WEP104;
-			else if (!strcmp (cipher, "tkip"))
-				flags |= NM_802_11_AP_SEC_GROUP_TKIP;
-			else if (!strcmp (cipher, "ccmp"))
-				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
-		}
-	}
-
-	if (has_proto (sec, PROTO_WPA))
-		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
-	if (has_proto (sec, PROTO_RSN))
-		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
-}
-
-NMAccessPoint *
-nm_ap_new_fake_from_connection (NMConnection *connection)
-{
-	NMAccessPoint *ap;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wireless_sec;
-	const GByteArray *ssid;
-	const char *mode, *band, *key_mgmt;
-	guint32 channel, flags;
-	gboolean psk = FALSE, eap = FALSE;
-
-	g_return_val_if_fail (connection != NULL, NULL);
-
-	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
-	g_return_val_if_fail (s_wireless != NULL, NULL);
-
-	ssid = nm_setting_wireless_get_ssid (s_wireless);
-	g_return_val_if_fail (ssid != NULL, NULL);
-	g_return_val_if_fail (ssid->len > 0, NULL);
-
-	ap = nm_ap_new ();
-	nm_ap_set_fake (ap, TRUE);
-	nm_ap_set_ssid (ap, ssid);
-
-	// FIXME: bssid too?
-
-	mode = nm_setting_wireless_get_mode (s_wireless);
-	if (mode) {
-		if (!strcmp (mode, "infrastructure"))
-			nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
-		else if (!strcmp (mode, "adhoc"))
-			nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
-		else
-			goto error;
-	} else {
-		nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
-	}
-
-	band = nm_setting_wireless_get_band (s_wireless);
-	channel = nm_setting_wireless_get_channel (s_wireless);
-
-	if (band && channel) {
-		guint32 freq = channel_to_freq (channel, band);
-
-		if (freq == 0)
-			goto error;
-
-		nm_ap_set_freq (ap, freq);
-	}
-
-	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY);
-	/* Assume presence of a security setting means the AP is encrypted */
-	if (!s_wireless_sec)
-		goto done;
-
-	key_mgmt = nm_setting_wireless_security_get_key_mgmt (s_wireless_sec);
-
-	/* Everything below here uses encryption */
-	nm_ap_set_flags (ap, nm_ap_get_flags (ap) | NM_802_11_AP_FLAGS_PRIVACY);
-
-	/* Static & Dynamic WEP */
-	if (!strcmp (key_mgmt, "none") || !strcmp (key_mgmt, "ieee8021x"))
-		goto done;
-
-	psk = !strcmp (key_mgmt, "wpa-psk");
-	eap = !strcmp (key_mgmt, "wpa-eap");
-	if (psk || eap) {
-		if (has_proto (s_wireless_sec, PROTO_WPA)) {
-			flags = nm_ap_get_wpa_flags (ap);
-			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
-			nm_ap_set_wpa_flags (ap, flags);
-		}
-		if (has_proto (s_wireless_sec, PROTO_RSN)) {
-			flags = nm_ap_get_rsn_flags (ap);
-			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
-			nm_ap_set_rsn_flags (ap, flags);
-		}
-
-		add_pair_ciphers (ap, s_wireless_sec);
-		add_group_ciphers (ap, s_wireless_sec);
-	} else if (!strcmp (key_mgmt, "wpa-none")) {
-		guint32 i;
-
-		/* Ad-Hoc has special requirements: proto=WPA, pairwise=(none), and
-		 * group=TKIP/CCMP (but not both).
-		 */
-
-		flags = nm_ap_get_wpa_flags (ap);
-		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
-
-		/* Clear ciphers; pairwise must be unset anyway, and group gets set below */
-		flags &= ~(  NM_802_11_AP_SEC_PAIR_WEP40
-		           | NM_802_11_AP_SEC_PAIR_WEP104
-		           | NM_802_11_AP_SEC_PAIR_TKIP
-		           | NM_802_11_AP_SEC_PAIR_CCMP
-		           | NM_802_11_AP_SEC_GROUP_WEP40
-		           | NM_802_11_AP_SEC_GROUP_WEP104
-		           | NM_802_11_AP_SEC_GROUP_TKIP
-		           | NM_802_11_AP_SEC_GROUP_CCMP);
-
-		for (i = 0; i < nm_setting_wireless_security_get_num_groups (s_wireless_sec); i++) {
-			if (!strcmp (nm_setting_wireless_security_get_group (s_wireless_sec, i), "ccmp")) {
-				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
-				break;
-			}
-		}
-
-		/* Default to TKIP since not all WPA-capable cards can do CCMP */
-		if (!(flags & NM_802_11_AP_SEC_GROUP_CCMP))
-			flags |= NM_802_11_AP_SEC_GROUP_TKIP;
-
-		nm_ap_set_wpa_flags (ap, flags);
-
-		/* Don't use Ad-Hoc RSN yet */
-		nm_ap_set_rsn_flags (ap, NM_802_11_AP_SEC_NONE);
-	}
-
-done:
-	return ap;
-
-error:
-	g_object_unref (ap);
-	return NULL;
-}
-
-
-#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
-#define MAC_ARG(x) ((guint8*)(x))[0],((guint8*)(x))[1],((guint8*)(x))[2],((guint8*)(x))[3],((guint8*)(x))[4],((guint8*)(x))[5]
-
-void
-nm_ap_print_self (NMAccessPoint *ap,
-                  const char * prefix)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	nm_info ("%s'%s' (%p) stamp=%ld flags=0x%X wpa-flags=0x%X rsn-flags=0x%x "
-	         "bssid=" MAC_FMT " strength=%d freq=%d rate=%d mode=%d seen=%ld",
-	         prefix,
-	         priv->ssid ? nm_utils_escape_ssid (priv->ssid->data, priv->ssid->len) : "(none)",
-	         ap,
-	         priv->timestamp.tv_sec,
-	         priv->flags,
-	         priv->wpa_flags,
-	         priv->rsn_flags,
-	         MAC_ARG (priv->address.ether_addr_octet),
-	         priv->strength,
-	         priv->freq,
-	         priv->max_bitrate,
-	         priv->mode,
-	         priv->last_seen);
-}
-
-const char *
-nm_ap_get_dbus_path (NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	return NM_AP_GET_PRIVATE (ap)->dbus_path;
-}
-
-
-/*
- * Get/set functions for timestamp
- *
- */
-const GTimeVal *nm_ap_get_timestamp (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	return (&NM_AP_GET_PRIVATE (ap)->timestamp);
-}
-
-void nm_ap_set_timestamp (NMAccessPoint *ap, glong sec, glong usec)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	priv->timestamp.tv_sec = sec;
-	priv->timestamp.tv_usec = usec;
-}
-
-void nm_ap_set_timestamp_via_timestamp (NMAccessPoint *ap, const GTimeVal *timestamp)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->timestamp = *timestamp;
-}
-
-/*
- * Get/set functions for ssid
- *
- */
-const GByteArray * nm_ap_get_ssid (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	return NM_AP_GET_PRIVATE (ap)->ssid;
-}
-
-void
-nm_ap_set_ssid (NMAccessPoint *ap, const GByteArray * ssid)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if ((ssid == priv->ssid) && ssid == NULL)
-		return;
-
-	/* same SSID */
-	if ((ssid && priv->ssid) && (ssid->len == priv->ssid->len)) {
-		if (!memcmp (ssid->data, priv->ssid->data, ssid->len))
-			return;
-	}
-
-	if (priv->ssid) {
-		g_byte_array_free (priv->ssid, TRUE);
-		priv->ssid = NULL;
-	}
-
-	if (ssid) {
-		priv->ssid = g_byte_array_sized_new (ssid->len);
-		priv->ssid->len = ssid->len;
-		memcpy (priv->ssid->data, ssid->data, ssid->len);
-	}
-
-	g_object_notify (G_OBJECT (ap), NM_AP_SSID);
-}
-
-
-guint32
-nm_ap_get_flags (NMAccessPoint *ap)
-{
-	guint32 flags;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_FLAGS_NONE);
-
-	g_object_get (ap, NM_AP_FLAGS, &flags, NULL);
-
-	return flags;
-}
-
-
-void
-nm_ap_set_flags (NMAccessPoint *ap, guint32 flags)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->flags != flags) {
-		priv->flags = flags;
-		g_object_notify (G_OBJECT (ap), NM_AP_FLAGS);
-	}
-}
-
-guint32
-nm_ap_get_wpa_flags (NMAccessPoint *ap)
-{
-	guint32 flags;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
-
-	g_object_get (ap, NM_AP_WPA_FLAGS, &flags, NULL);
-
-	return flags;
-}
-
-
-void
-nm_ap_set_wpa_flags (NMAccessPoint *ap, guint32 flags)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->wpa_flags != flags) {
-		priv->wpa_flags = flags;
-		g_object_notify (G_OBJECT (ap), NM_AP_WPA_FLAGS);
-	}
-}
-
-guint32
-nm_ap_get_rsn_flags (NMAccessPoint *ap)
-{
-	guint32 flags;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
-
-	g_object_get (ap, NM_AP_RSN_FLAGS, &flags, NULL);
-
-	return flags;
-}
-
-
-void
-nm_ap_set_rsn_flags (NMAccessPoint *ap, guint32 flags)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->rsn_flags != flags) {
-		priv->rsn_flags = flags;
-		g_object_notify (G_OBJECT (ap), NM_AP_RSN_FLAGS);
-	}
-}
-
-/*
- * Get/set functions for address
- *
- */
-const struct ether_addr * nm_ap_get_address (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	return &NM_AP_GET_PRIVATE (ap)->address;
-}
-
-void nm_ap_set_address (NMAccessPoint *ap, const struct ether_addr * addr)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-	g_return_if_fail (addr != NULL);
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (memcmp (addr, &priv->address, sizeof (priv->address))) {
-		memcpy (&NM_AP_GET_PRIVATE (ap)->address, addr, sizeof (struct ether_addr));
-		g_object_notify (G_OBJECT (ap), NM_AP_HW_ADDRESS);
-	}
-}
-
-
-/*
- * Get/set functions for mode (ie Ad-Hoc, Infrastructure, etc)
- *
- */
-NM80211Mode nm_ap_get_mode (NMAccessPoint *ap)
-{
-	NM80211Mode mode;
-
-	g_return_val_if_fail (NM_IS_AP (ap), -1);
-
-	g_object_get (ap, NM_AP_MODE, &mode, NULL);
-
-	return mode;
-}
-
-void nm_ap_set_mode (NMAccessPoint *ap, const NM80211Mode mode)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	if (mode == NM_802_11_MODE_ADHOC || mode == NM_802_11_MODE_INFRA) {
-		priv = NM_AP_GET_PRIVATE (ap);
-
-		if (priv->mode != mode) {
-			priv->mode = mode;
-			g_object_notify (G_OBJECT (ap), NM_AP_MODE);
-		}
-	} else
-		nm_warning ("Invalid AP mode '%d'", mode);
-}
-
-
-/*
- * Get/set functions for strength
- *
- */
-gint8 nm_ap_get_strength (NMAccessPoint *ap)
-{
-	gint8 strength;
-
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	g_object_get (ap, NM_AP_STRENGTH, &strength, NULL);
-
-	return strength;
-}
-
-void nm_ap_set_strength (NMAccessPoint *ap, const gint8 strength)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->strength != strength) {
-		priv->strength = strength;
-		g_object_notify (G_OBJECT (ap), NM_AP_STRENGTH);
-	}
-}
-
-
-/*
- * Get/set functions for frequency
- *
- */
-guint32
-nm_ap_get_freq (NMAccessPoint *ap)
-{
-	guint32 freq;
-
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	g_object_get (ap, NM_AP_FREQUENCY, &freq, NULL);
-
-	return freq;
-}
-
-void
-nm_ap_set_freq (NMAccessPoint *ap,
-                const guint32 freq)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->freq != freq) {
-		priv->freq = freq;
-		g_object_notify (G_OBJECT (ap), NM_AP_FREQUENCY);
-	}
-}
-
-
-/*
- * Get/set functions for max bitrate
- *
- */
-guint32 nm_ap_get_max_bitrate (NMAccessPoint *ap)
-{
-	guint32 rate;
-
-	g_return_val_if_fail (NM_IS_AP (ap), 0);
-
-	g_object_get (ap, NM_AP_MAX_BITRATE, &rate, NULL);
-
-	return rate;
-}
-
-void
-nm_ap_set_max_bitrate (NMAccessPoint *ap, guint32 bitrate)
-{
-	NMAccessPointPrivate *priv;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	if (priv->max_bitrate != bitrate) {
-		priv->max_bitrate = bitrate;
-		g_object_notify (G_OBJECT (ap), NM_AP_MAX_BITRATE);
-	}
-}
-
-/*
- * Get/Set functions to indicate that an access point is 'fake', ie whether
- * or not it was created from scan results
- */
-gboolean nm_ap_get_fake (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
-
-	return NM_AP_GET_PRIVATE (ap)->fake;
-}
-
-void nm_ap_set_fake (NMAccessPoint *ap, gboolean fake)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->fake = fake;
-}
-
-
-/*
- * Get/Set functions to indicate whether an AP broadcasts its SSID.
- */
-gboolean nm_ap_get_broadcast (NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), TRUE);
-
-	return NM_AP_GET_PRIVATE (ap)->broadcast;
-}
-
-
-void nm_ap_set_broadcast (NMAccessPoint *ap, gboolean broadcast)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->broadcast = broadcast;
-}
-
-
-/*
- * Get/Set functions for how long ago the AP was last seen in a scan.
- * APs older than a certain date are dropped from the list.
- *
- */
-glong nm_ap_get_last_seen (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
-
-	return NM_AP_GET_PRIVATE (ap)->last_seen;
-}
-
-void nm_ap_set_last_seen (NMAccessPoint *ap, const glong last_seen)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->last_seen = last_seen;
-}
-
-
-/*
- * Get/Set functions to indicate that an access point is
- * user-created, ie whether or not its a network filled with
- * information from the user and intended to create a new Ad-Hoc
- * wireless network.
- *
- */
-gboolean nm_ap_get_user_created (const NMAccessPoint *ap)
-{
-	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
-
-	return NM_AP_GET_PRIVATE (ap)->user_created;
-}
-
-void nm_ap_set_user_created (NMAccessPoint *ap, gboolean user_created)
-{
-	g_return_if_fail (NM_IS_AP (ap));
-
-	NM_AP_GET_PRIVATE (ap)->user_created = user_created;
-}
-
-
-/*
- * Get/Set functions for user address list
- *
- * The internal address list is always "owned" by the AP and
- * the list returned by nm_ap_get_user_addresses() is a deep copy.
- * Likewise, when setting the list, a deep copy is made for the
- * ap's actual list.
- *
- */
-GSList *nm_ap_get_user_addresses (const NMAccessPoint *ap)
-{
-	GSList	*new = NULL;
-	GSList	*elt = NULL;
-
-	g_return_val_if_fail (NM_IS_AP (ap), NULL);
-
-	for (elt = NM_AP_GET_PRIVATE (ap)->user_addresses; elt; elt = g_slist_next (elt))
-	{
-		if (elt->data)
-			new = g_slist_append (new, g_strdup (elt->data));
-	}
-
-	/* Return a _deep__copy_ of the address list */
-	return new;
-}
-
-void nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list)
-{
-	NMAccessPointPrivate *priv;
-	GSList	*elt = NULL;
-	GSList	*new = NULL;
-
-	g_return_if_fail (NM_IS_AP (ap));
-
-	priv = NM_AP_GET_PRIVATE (ap);
-
-	/* Free existing list */
-	g_slist_foreach (priv->user_addresses, (GFunc) g_free, NULL);
-
-	/* Copy new list and set as our own */
-	for (elt = list; elt; elt = g_slist_next (elt))
-	{
-		if (elt->data)
-			new = g_slist_append (new, g_ascii_strup (elt->data, -1));
-	}
-
-	priv->user_addresses = new;
-}
-
-
-guint32
-nm_ap_add_security_from_ie (guint32 flags,
-                            const guint8 *wpa_ie,
-                            guint32 length)
-{
-	wpa_ie_data * cap_data;
-
-	if (!(cap_data = wpa_parse_wpa_ie (wpa_ie, length)))
-		return NM_802_11_AP_SEC_NONE;
-
-	/* Pairwise cipher flags */
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP40)
-		flags |= NM_802_11_AP_SEC_PAIR_WEP40;
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP104)
-		flags |= NM_802_11_AP_SEC_PAIR_WEP104;
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_TKIP)
-		flags |= NM_802_11_AP_SEC_PAIR_TKIP;
-	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_CCMP)
-		flags |= NM_802_11_AP_SEC_PAIR_CCMP;
-
-	/* Group cipher flags */
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP40)
-		flags |= NM_802_11_AP_SEC_GROUP_WEP40;
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP104)
-		flags |= NM_802_11_AP_SEC_GROUP_WEP104;
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_TKIP)
-		flags |= NM_802_11_AP_SEC_GROUP_TKIP;
-	if (cap_data->group_cipher & IW_AUTH_CIPHER_CCMP)
-		flags |= NM_802_11_AP_SEC_GROUP_CCMP;
-
-	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_802_1X)
-		flags |= NM_802_11_AP_SEC_KEY_MGMT_802_1X;
-	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_PSK)
-		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
-
-	g_slice_free (wpa_ie_data, cap_data);
-	return flags;
-}
-
-gboolean
-nm_ap_check_compatible (NMAccessPoint *self,
-                        NMConnection *connection)
-{
-	NMAccessPointPrivate *priv;
-	NMSettingWireless *s_wireless;
-	NMSettingWirelessSecurity *s_wireless_sec;
-	const char *mode;
-	const char *band;
-	const GByteArray *bssid;
-	guint32 channel;
-
-	g_return_val_if_fail (NM_IS_AP (self), FALSE);
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
-
-	priv = NM_AP_GET_PRIVATE (self);
-
-	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
-	if (s_wireless == NULL)
-		return FALSE;
-	
-	if (!nm_utils_same_ssid (nm_setting_wireless_get_ssid (s_wireless), priv->ssid, TRUE))
-		return FALSE;
-
-	bssid = nm_setting_wireless_get_bssid (s_wireless);
-	if (bssid && memcmp (bssid->data, &priv->address, ETH_ALEN))
-		return FALSE;
-
-	mode = nm_setting_wireless_get_mode (s_wireless);
-	if (mode) {
-		if (!strcmp (mode, "infrastructure") && (priv->mode != NM_802_11_MODE_INFRA))
-			return FALSE;
-		if (!strcmp (mode, "adhoc") && (priv->mode != NM_802_11_MODE_ADHOC))
-			return FALSE;
-	}
-
-	band = nm_setting_wireless_get_band (s_wireless);
-	if (band) {
-		if (!strcmp (band, "a")) {
-			if (priv->freq < 4915 || priv->freq > 5825)
-				return FALSE;
-		} else if (!strcmp (band, "bg")) {
-			if (priv->freq < 2412 || priv->freq > 2484)
-				return FALSE;
-		}
-	}
-
-	channel = nm_setting_wireless_get_channel (s_wireless);
-	if (channel) {
-		guint32 ap_chan = freq_to_channel (priv->freq);
-
-		if (channel != ap_chan)
-			return FALSE;
-	}
-
-	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection,
-															    NM_TYPE_SETTING_WIRELESS_SECURITY);
-
-	return nm_setting_wireless_ap_security_compatible (s_wireless,
-											 s_wireless_sec,
-											 nm_ap_get_flags (self),
-											 nm_ap_get_wpa_flags (self),
-											 nm_ap_get_rsn_flags (self),
-											 nm_ap_get_mode (self));
-}
-
-static gboolean
-capabilities_compatible (guint32 a_flags, guint32 b_flags)
-{
-	if (a_flags == b_flags)
-		return TRUE;
-
-	/* Make sure there's a common key management method */
-	if (!((a_flags & 0x300) & (b_flags & 0x300)))
-		return FALSE;
-
-	/* Ensure common pairwise ciphers */
-	if (!((a_flags & 0xF) & (b_flags & 0xF)))
-		return FALSE;
-
-	/* Ensure common group ciphers */
-	if (!((a_flags & 0xF0) & (b_flags & 0xF0)))
-		return FALSE;
-
-	return TRUE;
-}
-
-NMAccessPoint *
-nm_ap_match_in_list (NMAccessPoint *find_ap,
-                     GSList *ap_list,
-                     gboolean strict_match)
-{
-	GSList *iter;
-
-	g_return_val_if_fail (find_ap != NULL, NULL);
-
-	for (iter = ap_list; iter; iter = g_slist_next (iter)) {
-		NMAccessPoint * list_ap = NM_AP (iter->data);
-		const GByteArray * list_ssid = nm_ap_get_ssid (list_ap);
-		const struct ether_addr * list_addr = nm_ap_get_address (list_ap);
-
-		const GByteArray * find_ssid = nm_ap_get_ssid (find_ap);
-		const struct ether_addr * find_addr = nm_ap_get_address (find_ap);
-
-		/* SSID match; if both APs are hiding their SSIDs,
-		 * let matching continue on BSSID and other properties
-		 */
-		if (   (!list_ssid && find_ssid)
-		    || (list_ssid && !find_ssid)
-		    || !nm_utils_same_ssid (list_ssid, find_ssid, TRUE))
-			continue;
-
-		/* BSSID match */
-		if (   (strict_match || nm_ethernet_address_is_valid (find_addr))
-		    && nm_ethernet_address_is_valid (list_addr)
-		    && memcmp (list_addr->ether_addr_octet, 
-		               find_addr->ether_addr_octet,
-		               ETH_ALEN) != 0) {
-			continue;
-		}
-
-		/* mode match */
-		if (nm_ap_get_mode (list_ap) != nm_ap_get_mode (find_ap))
-			continue;
-
-		/* Frequency match */
-		if (nm_ap_get_freq (list_ap) != nm_ap_get_freq (find_ap))
-			continue;
-
-		/* AP flags */
-		if (nm_ap_get_flags (list_ap) != nm_ap_get_flags (find_ap))
-			continue;
-
-		if (strict_match) {
-			if (nm_ap_get_wpa_flags (list_ap) != nm_ap_get_wpa_flags (find_ap))
-				continue;
-
-			if (nm_ap_get_rsn_flags (list_ap) != nm_ap_get_rsn_flags (find_ap))
-				continue;
-		} else {
-			guint32 list_wpa_flags = nm_ap_get_wpa_flags (list_ap);
-			guint32 find_wpa_flags = nm_ap_get_wpa_flags (find_ap);
-			guint32 list_rsn_flags = nm_ap_get_rsn_flags (list_ap);
-			guint32 find_rsn_flags = nm_ap_get_rsn_flags (find_ap);
-
-			/* Just ensure that there is overlap in the capabilities */
-			if (   !capabilities_compatible (list_wpa_flags, find_wpa_flags)
-			    && !capabilities_compatible (list_rsn_flags, find_rsn_flags))
-				continue;
-		}
-
-		return list_ap;
-	}
-
-	return NULL;
-}
-
-
-struct cf_pair {
-	guint32 chan;
-	guint32 freq;
-};
-
-static struct cf_pair a_table[] = {
-	/* A band */
-	{  7, 5035 },
-	{  8, 5040 },
-	{  9, 5045 },
-	{ 11, 5055 },
-	{ 12, 5060 },
-	{ 16, 5080 },
-	{ 34, 5170 },
-	{ 36, 5180 },
-	{ 38, 5190 },
-	{ 40, 5200 },
-	{ 42, 5210 },
-	{ 44, 5220 },
-	{ 46, 5230 },
-	{ 48, 5240 },
-	{ 50, 5250 },
-	{ 52, 5260 },
-	{ 56, 5280 },
-	{ 58, 5290 },
-	{ 60, 5300 },
-	{ 64, 5320 },
-	{ 100, 5500 },
-	{ 104, 5520 },
-	{ 108, 5540 },
-	{ 112, 5560 },
-	{ 116, 5580 },
-	{ 120, 5600 },
-	{ 124, 5620 },
-	{ 128, 5640 },
-	{ 132, 5660 },
-	{ 136, 5680 },
-	{ 140, 5700 },
-	{ 149, 5745 },
-	{ 152, 5760 },
-	{ 153, 5765 },
-	{ 157, 5785 },
-	{ 160, 5800 },
-	{ 161, 5805 },
-	{ 165, 5825 },
-	{ 183, 4915 },
-	{ 184, 4920 },
-	{ 185, 4925 },
-	{ 187, 4935 },
-	{ 188, 4945 },
-	{ 192, 4960 },
-	{ 196, 4980 },
-	{ 0, -1 }
-};
-
-static struct cf_pair bg_table[] = {
-	/* B/G band */
-	{ 1, 2412 },
-	{ 2, 2417 },
-	{ 3, 2422 },
-	{ 4, 2427 },
-	{ 5, 2432 },
-	{ 6, 2437 },
-	{ 7, 2442 },
-	{ 8, 2447 },
-	{ 9, 2452 },
-	{ 10, 2457 },
-	{ 11, 2462 },
-	{ 12, 2467 },
-	{ 13, 2472 },
-	{ 14, 2484 },
-	{ 0, -1 }
-};
-
-guint32
-freq_to_channel (guint32 freq)
-{
-	int i = 0;
-
-	if (freq > 4900) {
-		while (a_table[i].chan && (a_table[i].freq != freq))
-			i++;
-		return a_table[i].chan;
-	} else {
-		while (bg_table[i].chan && (bg_table[i].freq != freq))
-			i++;
-		return bg_table[i].chan;
-	}
-
-	return 0;
-}
-
-guint32
-channel_to_freq (guint32 channel, const char *band)
-{
-	int i = 0;
-
-	if (!strcmp (band, "a")) {
-		while (a_table[i].chan && (a_table[i].chan != channel))
-			i++;
-		return a_table[i].freq;
-	} else if (!strcmp (band, "bg")) {
-		while (bg_table[i].chan && (bg_table[i].chan != channel))
-			i++;
-		return a_table[i].freq;
-	}
-
-	return 0;
-}
-
diff --git a/src/NetworkManagerAP.h b/src/NetworkManagerAP.h
deleted file mode 100644
index edc9e56..0000000
--- a/src/NetworkManagerAP.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#ifndef NM_ACCESS_POINT_H
-#define NM_ACCESS_POINT_H
-
-#include <glib.h>
-#include <glib-object.h>
-#include <time.h>
-#include "NetworkManager.h"
-#include "nm-connection.h"
-
-#define NM_TYPE_AP            (nm_ap_get_type ())
-#define NM_AP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_AP, NMAccessPoint))
-#define NM_AP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_AP, NMAccessPointClass))
-#define NM_IS_AP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_AP))
-#define NM_IS_AP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_AP))
-#define NM_AP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_AP, NMAccessPointClass))
-
-#define NM_AP_FLAGS "flags"
-#define NM_AP_WPA_FLAGS "wpa-flags"
-#define NM_AP_RSN_FLAGS "rsn-flags"
-#define NM_AP_SSID "ssid"
-#define NM_AP_FREQUENCY "frequency"
-#define NM_AP_HW_ADDRESS "hw-address"
-#define NM_AP_MODE "mode"
-#define NM_AP_MAX_BITRATE "max-bitrate"
-#define NM_AP_STRENGTH "strength"
-
-typedef struct {
-	GObject parent;
-} NMAccessPoint;
-
-typedef struct {
-	GObjectClass parent;
-
-	/* Signals */
-	void (*properties_changed) (NMAccessPoint *ap, GHashTable *properties);
-} NMAccessPointClass;
-
-GType nm_ap_get_type (void);
-
-NMAccessPoint *	nm_ap_new				(void);
-NMAccessPoint * nm_ap_new_from_properties (GHashTable *properties);
-NMAccessPoint * nm_ap_new_fake_from_connection (NMConnection *connection);
-void            nm_ap_export_to_dbus    (NMAccessPoint *ap);
-
-const char *		nm_ap_get_dbus_path (NMAccessPoint *ap);
-const GTimeVal *	nm_ap_get_timestamp				(const NMAccessPoint *ap);
-void				nm_ap_set_timestamp				(NMAccessPoint *ap, glong sec, glong usec);
-void				nm_ap_set_timestamp_via_timestamp	(NMAccessPoint *ap, const GTimeVal *timestamp);
-
-const GByteArray *	nm_ap_get_ssid (const NMAccessPoint * ap);
-void				nm_ap_set_ssid (NMAccessPoint * ap, const GByteArray * ssid);
-
-guint32			nm_ap_get_flags	(NMAccessPoint *ap);
-void				nm_ap_set_flags	(NMAccessPoint *ap, guint32 flags);
-
-guint32			nm_ap_get_wpa_flags	(NMAccessPoint *ap);
-void				nm_ap_set_wpa_flags	(NMAccessPoint *ap, guint32 flags);
-
-guint32			nm_ap_get_rsn_flags	(NMAccessPoint *ap);
-void				nm_ap_set_rsn_flags	(NMAccessPoint *ap, guint32 flags);
-
-const struct ether_addr * nm_ap_get_address	(const NMAccessPoint *ap);
-void				nm_ap_set_address		(NMAccessPoint *ap, const struct ether_addr *addr);
-
-NM80211Mode			nm_ap_get_mode			(NMAccessPoint *ap);
-void				nm_ap_set_mode			(NMAccessPoint *ap, const NM80211Mode mode);
-
-gint8			nm_ap_get_strength		(NMAccessPoint *ap);
-void				nm_ap_set_strength		(NMAccessPoint *ap, gint8 strength);
-
-guint32			nm_ap_get_freq			(NMAccessPoint *ap);
-void				nm_ap_set_freq			(NMAccessPoint *ap, guint32 freq);
-
-guint32			nm_ap_get_max_bitrate			(NMAccessPoint *ap);
-void				nm_ap_set_max_bitrate		(NMAccessPoint *ap, guint32 bitrate);
-
-gboolean			nm_ap_get_fake	(const NMAccessPoint *ap);
-void				nm_ap_set_fake	(NMAccessPoint *ap, gboolean fake);
-
-gboolean			nm_ap_get_broadcast		(NMAccessPoint *ap);
-void				nm_ap_set_broadcast		(NMAccessPoint *ap, gboolean broadcast);
-
-glong			nm_ap_get_last_seen		(const NMAccessPoint *ap);
-void				nm_ap_set_last_seen		(NMAccessPoint *ap, const glong last_seen);
-
-gboolean			nm_ap_get_user_created	(const NMAccessPoint *ap);
-void				nm_ap_set_user_created	(NMAccessPoint *ap, gboolean user_created);
-
-GSList *			nm_ap_get_user_addresses	(const NMAccessPoint *ap);
-void				nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list);
-
-guint32				nm_ap_add_security_from_ie (guint32 flags,
-                                                const guint8 *wpa_ie,
-                                                guint32 length);
-
-gboolean			nm_ap_check_compatible (NMAccessPoint *self,
-                                            NMConnection *connection);
-
-NMAccessPoint *     nm_ap_match_in_list (NMAccessPoint *find_ap,
-                                         GSList *ap_list,
-                                         gboolean strict_match);
-
-void				nm_ap_print_self (NMAccessPoint *ap, const char * prefix);
-
-guint32 freq_to_channel (guint32 freq);
-guint32 channel_to_freq (guint32 channel, const char *band);
-
-#endif /* NM_ACCESS_POINT_H */
diff --git a/src/NetworkManagerPolicy.c b/src/NetworkManagerPolicy.c
deleted file mode 100644
index 1b7801c..0000000
--- a/src/NetworkManagerPolicy.c
+++ /dev/null
@@ -1,1231 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2007 - 2008 Novell, Inc.
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <netdb.h>
-#include <ctype.h>
-
-#include "NetworkManagerPolicy.h"
-#include "NetworkManagerUtils.h"
-#include "NetworkManagerAP.h"
-#include "nm-activation-request.h"
-#include "nm-utils.h"
-#include "nm-device-interface.h"
-#include "nm-device.h"
-#include "nm-device-wifi.h"
-#include "nm-device-ethernet.h"
-#include "nm-dbus-manager.h"
-#include "nm-setting-ip4-config.h"
-#include "nm-setting-connection.h"
-#include "NetworkManagerSystem.h"
-#include "nm-named-manager.h"
-#include "nm-vpn-manager.h"
-#include "nm-modem.h"
-
-typedef struct LookupThread LookupThread;
-
-typedef void (*LookupCallback) (LookupThread *thread, gpointer user_data);
-
-struct LookupThread {
-	GThread *thread;
-
-	GMutex *lock;
-	gboolean die;
-	int ret;
-
-	guint32 ip4_addr;
-	char hostname[NI_MAXHOST + 1];
-
-	LookupCallback callback;
-	gpointer user_data;
-};
-
-struct NMPolicy {
-	NMManager *manager;
-	guint update_state_id;
-	GSList *pending_activation_checks;
-	GSList *signal_ids;
-	GSList *dev_signal_ids;
-
-	NMVPNManager *vpn_manager;
-	gulong vpn_activated_id;
-	gulong vpn_deactivated_id;
-
-	NMDevice *default_device;
-
-	LookupThread *lookup;
-
-	char *orig_hostname; /* hostname at NM start time */
-};
-
-static gboolean
-lookup_thread_run_cb (gpointer user_data)
-{
-	LookupThread *thread = (LookupThread *) user_data;
-
-	(*thread->callback) (thread, thread->user_data);
-	return FALSE;
-}
-
-static gpointer
-lookup_thread_worker (gpointer data)
-{
-	LookupThread *thread = (LookupThread *) data;
-	struct sockaddr_in addr;
-
-	g_mutex_lock (thread->lock);
-	if (thread->die) {
-		g_mutex_unlock (thread->lock);
-		return (gpointer) NULL;
-	}
-	g_mutex_unlock (thread->lock);
-
-	addr.sin_family = AF_INET;
-	addr.sin_addr.s_addr = thread->ip4_addr;
-
-	thread->ret = getnameinfo ((struct sockaddr *) &addr, sizeof (struct sockaddr_in),
-	                           thread->hostname, NI_MAXHOST, NULL, 0,
-	                           NI_NAMEREQD);
-	if (thread->ret == 0) {
-		int i;
-
-		for (i = 0; i < strlen (thread->hostname); i++)
-			thread->hostname[i] = tolower (thread->hostname[i]);
-	}
-
-	/* Don't track the idle handler ID because by the time the g_idle_add()
-	 * returns the ID, the handler may already have run and freed the
-	 * LookupThread.
-	 */
-	g_idle_add (lookup_thread_run_cb, thread);
-	return (gpointer) TRUE;
-}
-
-static void
-lookup_thread_free (LookupThread *thread)
-{
-	g_return_if_fail (thread != NULL);
-
-	g_mutex_free (thread->lock);
-	memset (thread, 0, sizeof (LookupThread));
-	g_free (thread);
-}
-
-static LookupThread *
-lookup_thread_new (guint32 ip4_addr, LookupCallback callback, gpointer user_data)
-{
-	LookupThread *thread;
-
-	thread = g_malloc0 (sizeof (LookupThread));
-	if (!thread)
-		return NULL;
-
-	thread->lock = g_mutex_new ();
-	thread->callback = callback;
-	thread->user_data = user_data;
-	thread->ip4_addr = ip4_addr;
-
-	thread->thread = g_thread_create (lookup_thread_worker, thread, FALSE, NULL);
-	if (!thread->thread) {
-		lookup_thread_free (thread);
-		return NULL;
-	}
-
-	return thread;
-}
-
-static void
-lookup_thread_die (LookupThread *thread)
-{
-	g_return_if_fail (thread != NULL);
-
-	g_mutex_lock (thread->lock);
-	thread->die = TRUE;
-	g_mutex_unlock (thread->lock);
-}
-
-#define INVALID_TAG "invalid"
-
-static const char *
-get_connection_id (NMConnection *connection)
-{
-	NMSettingConnection *s_con;
-
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
-
-	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-	g_return_val_if_fail (s_con != NULL, NULL);
-
-	return nm_setting_connection_get_id (s_con);
-}
-
-static NMDevice *
-get_best_device (NMManager *manager, NMActRequest **out_req)
-{
-	GSList *devices, *iter;
-	NMDevice *best = NULL;
-	int best_prio = G_MAXINT;
-
-	g_return_val_if_fail (manager != NULL, NULL);
-	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
-	g_return_val_if_fail (out_req != NULL, NULL);
-	g_return_val_if_fail (*out_req == NULL, NULL);
-
-	devices = nm_manager_get_devices (manager);
-	for (iter = devices; iter; iter = g_slist_next (iter)) {
-		NMDevice *dev = NM_DEVICE (iter->data);
-		NMActRequest *req;
-		NMConnection *connection;
-		NMIP4Config *ip4_config;
-		NMSettingIP4Config *s_ip4;
-		int prio;
-		guint i;
-		gboolean can_default = FALSE;
-		const char *method = NULL;
-
-		if (nm_device_get_state (dev) != NM_DEVICE_STATE_ACTIVATED)
-			continue;
-
-		ip4_config = nm_device_get_ip4_config (dev);
-		if (!ip4_config)
-			continue;
-
-		req = nm_device_get_act_request (dev);
-		g_assert (req);
-		connection = nm_act_request_get_connection (req);
-		g_assert (connection);
-
-		/* Never set the default route through an IPv4LL-addressed device */
-		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-		if (s_ip4)
-			method = nm_setting_ip4_config_get_method (s_ip4);
-
-		if (s_ip4 && !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
-			continue;
-
-		/* Make sure at least one of this device's IP addresses has a gateway */
-		for (i = 0; i < nm_ip4_config_get_num_addresses (ip4_config); i++) {
-			NMIP4Address *addr;
-
-			addr = nm_ip4_config_get_address (ip4_config, i);
-			if (nm_ip4_address_get_gateway (addr)) {
-				can_default = TRUE;
-				break;
-			}
-		}
-
-		if (!can_default && !NM_IS_MODEM (dev))
-			continue;
-
-		/* 'never-default' devices can't ever be the default */
-		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
-			continue;
-
-		prio = nm_device_get_priority (dev);
-		if (prio > 0 && prio < best_prio) {
-			best = dev;
-			best_prio = prio;
-			*out_req = req;
-		}
-	}
-
-	return best;
-}
-
-static gboolean
-is_localhost_mapping (const char *str)
-{
-	return (!strncmp (str, "127.0.0.1", strlen ("127.0.0.1")) && strstr (str, "localhost"));
-}
-
-static gboolean
-find_token (const char *line, const char *token)
-{
-	const char *start = line, *p = line;
-
-	g_return_val_if_fail (line != NULL, FALSE);
-	g_return_val_if_fail (token != NULL, FALSE);
-	g_return_val_if_fail (strlen (token) > 0, FALSE);
-
-	/* Walk through the line to find the next whitespace character */
-	while (p <= line + strlen (line)) {
-		if (isblank (*p) || (*p == '\0')) {
-			/* Token starts with 'start' and ends with 'end' */
-			if ((p > start) && *start && !strncmp (start, token, (p - start)))
-				return TRUE; /* found */
-
-			/* not found; advance start and continue looking */
-			start = p + 1;
-		}
-		p++;
-	}
-
-	return FALSE;
-}
-
-#if 0
-/* Testcase for find_token; break it out and add it to the testsuite */
-
-typedef struct {
-	const char *line;
-	const char *token;
-	gboolean expected;
-} Foo;
-
-static Foo foo[] = {
-	{ "127.0.0.1\tfoobar\tblah", "blah", TRUE },
-	{ "", "blah", FALSE },
-	{ "1.1.1.1\tbork\tfoo", "blah", FALSE },
-	{ "127.0.0.1 foobar\tblah", "blah", TRUE },
-	{ "127.0.0.1 foobar blah", "blah", TRUE },
-	{ "192.168.1.1 blah borkbork", "blah", TRUE },
-	{ "192.168.1.1 foobar\tblah borkbork", "blah", TRUE },
-	{ "192.168.1.1\tfoobar\tblah\tborkbork", "blah", TRUE },
-	{ "192.168.1.1 \tfoobar \tblah \tborkbork\t ", "blah", TRUE },
-	{ "\t\t\t\t   \t\t\tasdfadf  a\t\t\t\t\t   \t\t\t\t\t ", "blah", FALSE },
-	{ NULL, NULL, FALSE }
-};
-
-int main(int argc, char **argv)
-{
-	Foo *iter = &foo[0];
-
-	while (iter->line) {
-		if (find_token (iter->line, iter->token) != iter->expected) {
-			g_message ("Failed: '%s' <= '%s' (%d)", iter->line, iter->token, iter->expected);
-			return 1;
-		}
-		iter++;
-	}
-
-	g_message ("Success");
-	return 0;
-}
-#endif
-
-#define FALLBACK_HOSTNAME "localhost.localdomain"
-
-static gboolean
-update_etc_hosts (const char *hostname)
-{
-	char *contents = NULL;
-	char **lines = NULL, **line, **host_mapping = NULL;
-	GError *error = NULL;
-	gboolean initial_comments = TRUE;
-	gboolean added = FALSE;
-	gsize contents_len = 0;
-	GString *new_contents;
-	gboolean success = FALSE;
-
-	g_return_val_if_fail (hostname != NULL, FALSE);
-
-	if (!g_file_get_contents (SYSCONFDIR "/hosts", &contents, &contents_len, &error)) {
-		nm_warning ("%s: couldn't read " SYSCONFDIR "/hosts: (%d) %s",
-		            __func__, error ? error->code : 0,
-		            (error && error->message) ? error->message : "(unknown)");
-		if (error)
-			g_error_free (error);
-	} else {
-		lines = g_strsplit_set (contents, "\n\r", 0);
-		g_free (contents);
-	}
-
-	new_contents = g_string_sized_new (contents_len ? contents_len + 100 : 200);
-	if (!new_contents) {
-		nm_warning ("%s: not enough memory to update " SYSCONFDIR "/hosts", __func__);
-		return FALSE;
-	}
-
-	/* Two-pass modification of /etc/hosts:
-	 *
-	 * 1) Look for a non-comment, non-localhost line that contains the current
-	 *    hostname.  Mark that line.
-	 *
-	 * 2) For each line in the existing /etc/hosts, add it to the new /etc/hosts
-	 *    unless it starts with 127.0.0.1 and is right after the initial comments
-	 *    (if any) and contains "localhost".
-	 */
-
-	/* Find any existing hostname mapping */
-	for (line = lines; lines && *line; line++) {
-		/* Look for any line that (a) contains the current hostname, and
-		 * (b) does not start with '127.0.0.1' and contain 'localhost'.
-		 */
-		if (   strlen (*line)
-		    && (*line[0] != '#')
-		    && find_token (*line, hostname)
-		    && !is_localhost_mapping (*line)) {
-			host_mapping = line;
-			break;
-		}
-	}
-
-	/* Construct the new hosts file; replace any 127.0.0.1 entry that is at the
-	 * beginning of the file or right after initial comments and contains
-	 * the string 'localhost'.  If there is no 127.0.0.1 entry at the beginning
-	 * or after initial comments that contains 'localhost', add one there
-	 * and ignore any other 127.0.0.1 entries that contain 'localhost'.
-	 */
-	for (line = lines, initial_comments = TRUE; lines && *line; line++) {
-		gboolean add_line = TRUE;
-
-		/* This is the first line after the initial comments */
-		if (strlen (*line) && initial_comments && (*line[0] != '#')) {
-			initial_comments = FALSE;
-
-			/* If some other line contained the hostname, make a simple
-			 * localhost mapping and assume the user knows what they are doing
-			 * with their manual hostname entry.  Otherwise if the hostname
-			 * wasn't found somewhere else, add it to the localhost mapping line
-			 * to make sure it's mapped to something.
-			 */
-			if (host_mapping)
-				g_string_append (new_contents, "127.0.0.1");
-			else
-				g_string_append_printf (new_contents, "127.0.0.1\t%s", hostname);
-
-			if (strcmp (hostname, FALLBACK_HOSTNAME))
-				g_string_append_printf (new_contents, "\t" FALLBACK_HOSTNAME);
-
-			g_string_append (new_contents, "\tlocalhost\n");
-			added = TRUE;
-
-			/* Don't add the entry if it's supposed to be the actual localhost reverse mapping */
-			if (is_localhost_mapping (*line))
-				add_line = FALSE;
-		}
-
-		if (add_line) {
-			g_string_append (new_contents, *line);
-			/* Only append the new line if this isn't the last line in the file */
-			if (*(line+1))
-				g_string_append_c (new_contents, '\n');
-		}
-	}
-
-	/* Hmm, /etc/hosts was empty for some reason */
-	if (!added) {
-		g_string_append (new_contents, "# Do not remove the following line, or various programs\n");
-		g_string_append (new_contents, "# that require network functionality will fail.\n");
-		g_string_append (new_contents, "127.0.0.1\t" FALLBACK_HOSTNAME "\tlocalhost\n");
-	}
-
-	error = NULL;
-	if (!g_file_set_contents (SYSCONFDIR "/hosts", new_contents->str, -1, &error)) {
-		nm_warning ("%s: couldn't update " SYSCONFDIR "/hosts: (%d) %s",
-		            __func__, error ? error->code : 0,
-		            (error && error->message) ? error->message : "(unknown)");
-		if (error)
-			g_error_free (error);
-	} else
-		success = TRUE;
-
-	g_string_free (new_contents, TRUE);
-	return success;
-}
-
-static void
-set_system_hostname (const char *new_hostname, const char *msg)
-{
-	char old_hostname[HOST_NAME_MAX + 1];
-	int ret = 0;
-	const char *name = new_hostname ? new_hostname : FALLBACK_HOSTNAME;
-
-	old_hostname[HOST_NAME_MAX] = '\0';
-	errno = 0;
-	ret = gethostname (old_hostname, HOST_NAME_MAX);
-	if (ret != 0) {
-		nm_warning ("%s: couldn't get the system hostname: (%d) %s",
-		            __func__, errno, strerror (errno));
-	} else {
-		/* Do nothing if the hostname isn't actually changing */
-		if (   (new_hostname && !strcmp (old_hostname, new_hostname))
-		    || (!new_hostname && !strcmp (old_hostname, FALLBACK_HOSTNAME)))
-			return;
-	}
-
-	nm_info ("Setting system hostname to '%s' (%s)", name, msg);
-
-	ret = sethostname (name, strlen (name));
-	if (ret == 0) {
-		if (!update_etc_hosts (name)) {
-			/* error updating /etc/hosts; fallback to localhost.localdomain */
-			nm_info ("Setting system hostname to '" FALLBACK_HOSTNAME "' (error updating /etc/hosts)");
-			ret = sethostname (FALLBACK_HOSTNAME, strlen (FALLBACK_HOSTNAME));
-			if (ret != 0) {
-				nm_warning ("%s: couldn't set the fallback system hostname (%s): (%d) %s",
-				            __func__, FALLBACK_HOSTNAME, errno, strerror (errno));
-			}
-		}
-		nm_utils_call_dispatcher ("hostname", NULL, NULL, NULL);
-	} else {
-		nm_warning ("%s: couldn't set the system hostname to '%s': (%d) %s",
-		            __func__, name, errno, strerror (errno));
-	}
-}
-
-static void
-lookup_callback (LookupThread *thread, gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-
-	/* If the thread was told to die or it's not the current in-progress
-	 * hostname lookup, nothing to do.
-	 */
-	if (thread->die || (thread != policy->lookup))
-		goto done;
-
-	policy->lookup = NULL;
-	if (!strlen (thread->hostname)) {
-		char *msg;
-
-		/* No valid IP4 config (!!); fall back to localhost.localdomain */
-		msg = g_strdup_printf ("address lookup failed: %d", thread->ret);
-		set_system_hostname (NULL, msg);
-		g_free (msg);
-	} else
-		set_system_hostname (thread->hostname, "from address lookup");
-
-done:
-	lookup_thread_free (thread);
-}
-
-static void
-update_system_hostname (NMPolicy *policy, NMDevice *best)
-{
-	char *configured_hostname = NULL;
-	NMActRequest *best_req = NULL;
-	NMDHCP4Config *dhcp4_config;
-	NMIP4Config *ip4_config;
-	NMIP4Address *addr;
-
-	g_return_if_fail (policy != NULL);
-
-	if (policy->lookup) {
-		lookup_thread_die (policy->lookup);
-		policy->lookup = NULL;
-	}
-
-	/* Hostname precedence order:
-	 *
-	 * 1) a configured hostname (from system-settings)
-	 * 2) automatic hostname from the default device's config (DHCP, VPN, etc)
-	 * 3) the original hostname when NM started
-	 * 4) reverse-DNS of the best device's IPv4 address
-	 *
-	 */
-
-	/* Try a persistent hostname first */
-	g_object_get (G_OBJECT (policy->manager), NM_MANAGER_HOSTNAME, &configured_hostname, NULL);
-	if (configured_hostname) {
-		set_system_hostname (configured_hostname, "from system configuration");
-		g_free (configured_hostname);
-		return;
-	}
-
-	/* Try automatically determined hostname from the best device's IP config */
-	if (!best)
-		best = get_best_device (policy->manager, &best_req);
-
-	if (!best) {
-		/* No best device; fall back to original hostname or if there wasn't
-		 * one, 'localhost.localdomain'
-		 */
-		set_system_hostname (policy->orig_hostname, "no default device");
-		return;
-	}
-
-	/* Grab a hostname out of the device's DHCP4 config */
-	dhcp4_config = nm_device_get_dhcp4_config (best);
-	if (dhcp4_config) {
-		const char *dhcp4_hostname, *p;
-
-		p = dhcp4_hostname = nm_dhcp4_config_get_option (dhcp4_config, "host_name");
-		if (dhcp4_hostname && strlen (dhcp4_hostname)) {
-			/* Sanity check */
-			while (*p) {
-				if (!isblank (*p++)) {
-					set_system_hostname (dhcp4_hostname, "from DHCP");
-					return;
-				}
-			}
-			nm_warning ("%s: DHCP-provided hostname '%s' looks invalid; ignoring it",
-			            __func__, dhcp4_hostname);
-		}
-	}
-
-	/* If no automatically-configured hostname, try using the hostname from
-	 * when NM started up.
-	 */
-	if (policy->orig_hostname) {
-		set_system_hostname (policy->orig_hostname, "from system startup");
-		return;
-	}
-
-	/* No configured hostname, no automatically determined hostname, and
-	 * no bootup hostname. Start reverse DNS of the current IP address.
-	 */
-	ip4_config = nm_device_get_ip4_config (best);
-	if (   !ip4_config
-	    || (nm_ip4_config_get_num_nameservers (ip4_config) == 0)
-	    || (nm_ip4_config_get_num_addresses (ip4_config) == 0)) {
-		/* No valid IP4 config (!!); fall back to localhost.localdomain */
-		set_system_hostname (NULL, "no IPv4 config");
-		return;
-	}
-
-	addr = nm_ip4_config_get_address (ip4_config, 0);
-	g_assert (addr); /* checked for > 1 address above */
-
-	/* Start the hostname lookup thread */
-	policy->lookup = lookup_thread_new (nm_ip4_address_get_address (addr), lookup_callback, policy);
-	if (!policy->lookup) {
-		/* Fall back to 'localhost.localdomain' */
-		set_system_hostname (NULL, "error starting hostname thread");
-	}
-}
-
-static void
-update_routing_and_dns (NMPolicy *policy, gboolean force_update)
-{
-	NMNamedIPConfigType dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
-	NMDevice *best = NULL;
-	NMActRequest *best_req = NULL;
-	NMNamedManager *named_mgr;
-	GSList *devices = NULL, *iter, *vpns;
-	NMIP4Config *ip4_config = NULL;
-	NMIP4Address *addr;
-	const char *ip_iface = NULL;
-	NMConnection *connection = NULL;
-	NMSettingConnection *s_con = NULL;
-	const char *connection_id;
-
-	best = get_best_device (policy->manager, &best_req);
-	if (!best)
-		goto out;
-	if (!force_update && (best == policy->default_device))
-		goto out;
-
-	/* If a VPN connection is active, it is preferred */
-	vpns = nm_vpn_manager_get_active_connections (policy->vpn_manager);
-	for (iter = vpns; iter; iter = g_slist_next (iter)) {
-		NMVPNConnection *candidate = NM_VPN_CONNECTION (iter->data);
-		NMConnection *vpn_connection;
-		NMSettingIP4Config *s_ip4;
-		gboolean can_default = TRUE;
-		NMVPNConnectionState vpn_state;
-
-		/* If it's marked 'never-default', don't make it default */
-		vpn_connection = nm_vpn_connection_get_connection (candidate);
-		g_assert (vpn_connection);
-		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (vpn_connection, NM_TYPE_SETTING_IP4_CONFIG);
-		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
-			can_default = FALSE;
-
-		vpn_state = nm_vpn_connection_get_vpn_state (candidate);
-		if (can_default && (vpn_state == NM_VPN_CONNECTION_STATE_ACTIVATED)) {
-			NMIP4Config *parent_ip4;
-			NMDevice *parent;
-
-			ip_iface = nm_vpn_connection_get_ip_iface (candidate);
-			connection = nm_vpn_connection_get_connection (candidate);
-			ip4_config = nm_vpn_connection_get_ip4_config (candidate);
-			addr = nm_ip4_config_get_address (ip4_config, 0);
-
-			parent = nm_vpn_connection_get_parent_device (candidate);
-			parent_ip4 = nm_device_get_ip4_config (parent);
-
-			nm_system_replace_default_ip4_route_vpn (ip_iface,
-			                                         nm_ip4_address_get_gateway (addr),
-			                                         nm_vpn_connection_get_ip4_internal_gateway (candidate),
-			                                         nm_ip4_config_get_mss (ip4_config),
-			                                         nm_device_get_ip_iface (parent),
-			                                         nm_ip4_config_get_mss (parent_ip4));
-
-			dns_type = NM_NAMED_IP_CONFIG_TYPE_VPN;
-		}
-		g_object_unref (candidate);
-	}
-	g_slist_free (vpns);
-
-	/* The best device gets the default route if a VPN connection didn't */
-	if (!ip_iface || !ip4_config) {
-		connection = nm_act_request_get_connection (best_req);
-		ip_iface = nm_device_get_ip_iface (best);
-		ip4_config = nm_device_get_ip4_config (best);
-		g_assert (ip4_config);
-		addr = nm_ip4_config_get_address (ip4_config, 0);
-
-		nm_system_replace_default_ip4_route (ip_iface, nm_ip4_address_get_gateway (addr), nm_ip4_config_get_mss (ip4_config));
-
-		dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
-	}
-
-	if (!ip_iface || !ip4_config) {
-		nm_warning ("%s: couldn't determine IP interface (%p) or IPv4 config (%p)!",
-		            __func__, ip_iface, ip4_config);
-		goto out;
-	}
-
-	/* Update the default active connection.  Only mark the new default
-	 * active connection after setting default = FALSE on all other connections
-	 * first.  The order is important, we don't want two connections marked
-	 * default at the same time ever.
-	 */
-	devices = nm_manager_get_devices (policy->manager);
-	for (iter = devices; iter; iter = g_slist_next (iter)) {
-		NMDevice *dev = NM_DEVICE (iter->data);
-		NMActRequest *req;
-
-		req = nm_device_get_act_request (dev);
-		if (req && (req != best_req))
-			nm_act_request_set_default (req, FALSE);
-	}
-
-	named_mgr = nm_named_manager_get ();
-	nm_named_manager_add_ip4_config (named_mgr, ip_iface, ip4_config, dns_type);
-	g_object_unref (named_mgr);
-
-	/* Now set new default active connection _after_ updating DNS info, so that
-	 * if the connection is shared dnsmasq picks up the right stuff.
-	 */
-	if (best_req)
-		nm_act_request_set_default (best_req, TRUE);
-
-	if (connection)
-		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-
-	connection_id = s_con ? nm_setting_connection_get_id (s_con) : NULL;
-	if (connection_id)
-		nm_info ("Policy set '%s' (%s) as default for routing and DNS.", connection_id, ip_iface);
-	else
-		nm_info ("Policy set (%s) as default for routing and DNS.", ip_iface);
-
-out:
-	/* Update the system hostname */
-	update_system_hostname (policy, best);
-
-	policy->default_device = best;	
-}
-
-typedef struct {
-	NMPolicy *policy;
-	NMDevice *device;
-	guint id;
-} ActivateData;
-
-static gboolean
-auto_activate_device (gpointer user_data)
-{
-	ActivateData *data = (ActivateData *) user_data;
-	NMPolicy *policy;
-	NMConnection *best_connection;
-	char *specific_object = NULL;
-	GSList *connections, *iter;
-
-	g_assert (data);
-	policy = data->policy;
-
-	// FIXME: if a device is already activating (or activated) with a connection
-	// but another connection now overrides the current one for that device,
-	// deactivate the device and activate the new connection instead of just
-	// bailing if the device is already active
-	if (nm_device_get_act_request (data->device))
-		goto out;
-
-	/* System connections first, then user connections */
-	connections = nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_SYSTEM);
-	connections = g_slist_concat (connections, nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_USER));
-
-	/* Remove connections that are in the invalid list. */
-	iter = connections;
-	while (iter) {
-		NMConnection *iter_connection = NM_CONNECTION (iter->data);
-		GSList *next = g_slist_next (iter);
-
-		if (g_object_get_data (G_OBJECT (iter_connection), INVALID_TAG)) {
-			connections = g_slist_remove_link (connections, iter);
-			g_object_unref (iter_connection);
-			g_slist_free (iter);
-		}
-		iter = next;
-	}
-
-	best_connection = nm_device_get_best_auto_connection (data->device, connections, &specific_object);
-	if (best_connection) {
-		GError *error = NULL;
-		const char *device_path;
-
-		device_path = nm_device_get_path (data->device);
-		if (!nm_manager_activate_connection (policy->manager,
-		                                     best_connection,
-		                                     specific_object,
-		                                     device_path,
-		                                     FALSE,
-		                                     &error)) {
-			NMSettingConnection *s_con;
-
-			s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (best_connection, NM_TYPE_SETTING_CONNECTION));
-			g_assert (s_con);
-
-			nm_warning ("Connection '%s' auto-activation failed: (%d) %s",
-			            nm_setting_connection_get_id (s_con), error->code, error->message);
-			g_error_free (error);
-		}
-	}
-
-	g_slist_foreach (connections, (GFunc) g_object_unref, NULL);
-	g_slist_free (connections);
-
- out:
-	/* Remove this call's handler ID */
-	policy->pending_activation_checks = g_slist_remove (policy->pending_activation_checks, data);
-	g_object_unref (data->device);
-	g_free (data);
-
-	return FALSE;
-}
-
-/*****************************************************************************/
-
-static void
-vpn_connection_activated (NMVPNManager *manager,
-                          NMVPNConnection *vpn,
-                          gpointer user_data)
-{
-	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
-}
-
-static void
-vpn_connection_deactivated (NMVPNManager *manager,
-                            NMVPNConnection *vpn,
-                            NMVPNConnectionState state,
-                            NMVPNConnectionStateReason reason,
-                            gpointer user_data)
-{
-	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
-}
-
-static void
-global_state_changed (NMManager *manager, NMState state, gpointer user_data)
-{
-}
-
-static void
-hostname_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
-{
-	update_system_hostname ((NMPolicy *) user_data, NULL);
-}
-
-static void
-sleeping_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
-{
-	gboolean sleeping = FALSE;
-	GSList *connections, *iter;
-
-	g_object_get (G_OBJECT (manager), NM_MANAGER_SLEEPING, &sleeping, NULL);
-
-	/* Clear the invalid flag on all connections so they'll get retried on wakeup */
-	if (sleeping) {
-		connections = nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_SYSTEM);
-		connections = g_slist_concat (connections, nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_USER));
-		for (iter = connections; iter; iter = g_slist_next (iter))
-			g_object_set_data (G_OBJECT (iter->data), INVALID_TAG, NULL);
-		g_slist_free (connections);
-	}
-}
-
-static void
-schedule_activate_check (NMPolicy *policy, NMDevice *device, guint delay_seconds)
-{
-	ActivateData *data;
-	GSList *iter;
-	NMDeviceState state;
-
-	if (nm_manager_get_state (policy->manager) == NM_STATE_ASLEEP)
-		return;
-
-	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
-	if (state < NM_DEVICE_STATE_DISCONNECTED)
-		return;
-
-	if (!nm_device_autoconnect_allowed (device))
-		return;
-
-	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
-		/* Only one pending activation check at a time */
-		if (((ActivateData *) iter->data)->device == device)
-			return;
-	}
-
-	data = g_malloc0 (sizeof (ActivateData));
-	g_return_if_fail (data != NULL);
-
-	data->policy = policy;
-	data->device = g_object_ref (device);
-	data->id = delay_seconds ? g_timeout_add_seconds (delay_seconds, auto_activate_device, data) : g_idle_add (auto_activate_device, data);
-	policy->pending_activation_checks = g_slist_append (policy->pending_activation_checks, data);
-}
-
-static NMConnection *
-get_device_connection (NMDevice *device)
-{
-	NMActRequest *req;
-
-	req = nm_device_get_act_request (device);
-	if (!req)
-		return NULL;
-
-	return nm_act_request_get_connection (req);
-}
-
-static void
-device_state_changed (NMDevice *device,
-                      NMDeviceState new_state,
-                      NMDeviceState old_state,
-                      NMDeviceStateReason reason,
-                      gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-	NMConnection *connection = get_device_connection (device);
-
-	switch (new_state) {
-	case NM_DEVICE_STATE_FAILED:
-		/* Mark the connection invalid if it failed during activation so that
-		 * it doesn't get automatically chosen over and over and over again.
-		 */
-		if (connection && IS_ACTIVATING_STATE (old_state)) {
-			g_object_set_data (G_OBJECT (connection), INVALID_TAG, GUINT_TO_POINTER (TRUE));
-			nm_info ("Marking connection '%s' invalid.", get_connection_id (connection));
-			nm_connection_clear_secrets (connection);
-		}
-		schedule_activate_check (policy, device, 3);
-		break;
-	case NM_DEVICE_STATE_ACTIVATED:
-		/* Clear the invalid tag on the connection */
-		if (connection)
-			g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
-
-		update_routing_and_dns (policy, FALSE);
-		break;
-	case NM_DEVICE_STATE_UNMANAGED:
-	case NM_DEVICE_STATE_UNAVAILABLE:
-	case NM_DEVICE_STATE_DISCONNECTED:
-		update_routing_and_dns (policy, FALSE);
-		schedule_activate_check (policy, device, 0);
-		break;
-	default:
-		break;
-	}
-}
-
-static void
-device_ip4_config_changed (NMDevice *device,
-                           GParamSpec *pspec,
-                           gpointer user_data)
-{
-	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
-}
-
-static void
-wireless_networks_changed (NMDeviceWifi *device, NMAccessPoint *ap, gpointer user_data)
-{
-	schedule_activate_check ((NMPolicy *) user_data, NM_DEVICE (device), 0);
-}
-
-typedef struct {
-	gulong id;
-	NMDevice *device;
-} DeviceSignalID;
-
-static GSList *
-add_device_signal_id (GSList *list, gulong id, NMDevice *device)
-{
-	DeviceSignalID *data;
-
-	data = g_malloc0 (sizeof (DeviceSignalID));
-	if (!data)
-		return list;
-
-	data->id = id;
-	data->device = device;
-	return g_slist_append (list, data);
-}
-
-static void
-device_added (NMManager *manager, NMDevice *device, gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-	gulong id;
-
-	id = g_signal_connect (device, "state-changed",
-	                       G_CALLBACK (device_state_changed),
-	                       policy);
-	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-
-	id = g_signal_connect (device, "notify::" NM_DEVICE_INTERFACE_IP4_CONFIG,
-	                       G_CALLBACK (device_ip4_config_changed),
-	                       policy);
-	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-
-	if (NM_IS_DEVICE_WIFI (device)) {
-		id = g_signal_connect (device, "access-point-added",
-		                       G_CALLBACK (wireless_networks_changed),
-		                       policy);
-		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-
-		id = g_signal_connect (device, "access-point-removed",
-		                       G_CALLBACK (wireless_networks_changed),
-		                       policy);
-		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
-	}
-}
-
-static void
-device_removed (NMManager *manager, NMDevice *device, gpointer user_data)
-{
-	NMPolicy *policy = (NMPolicy *) user_data;
-	GSList *iter;
-
-	/* Clear any idle callbacks for this device */
-	iter = policy->pending_activation_checks;
-	while (iter) {
-		ActivateData *data = (ActivateData *) iter->data;
-		GSList *next = g_slist_next (iter);
-
-		if (data->device == device) {
-			g_source_remove (data->id);
-			g_object_unref (data->device);
-			g_free (data);
-			policy->pending_activation_checks = g_slist_delete_link (policy->pending_activation_checks, iter);
-		}
-		iter = next;
-	}
-
-	/* Clear any signal handlers for this device */
-	iter = policy->dev_signal_ids;
-	while (iter) {
-		DeviceSignalID *data = (DeviceSignalID *) iter->data;
-		GSList *next = g_slist_next (iter);
-
-		if (data->device == device) {
-			g_signal_handler_disconnect (data->device, data->id);
-			g_free (data);
-			policy->dev_signal_ids = g_slist_delete_link (policy->dev_signal_ids, iter);
-		}
-		iter = next;
-	}
-
-	update_routing_and_dns (policy, FALSE);
-}
-
-static void
-schedule_activate_all (NMPolicy *policy)
-{
-	GSList *iter, *devices;
-
-	devices = nm_manager_get_devices (policy->manager);
-	for (iter = devices; iter; iter = g_slist_next (iter))
-		schedule_activate_check (policy, NM_DEVICE (iter->data), 0);
-}
-
-static void
-connections_added (NMManager *manager,
-                   NMConnectionScope scope,
-                   gpointer user_data)
-{
-	schedule_activate_all ((NMPolicy *) user_data);
-}
-
-static void
-connection_added (NMManager *manager,
-                  NMConnection *connection,
-                  NMConnectionScope scope,
-                  gpointer user_data)
-{
-	schedule_activate_all ((NMPolicy *) user_data);
-}
-
-static void
-connection_updated (NMManager *manager,
-                    NMConnection *connection,
-                    NMConnectionScope scope,
-                    gpointer user_data)
-{
-	/* Clear the invalid tag on the connection if it got updated. */
-	g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
-
-	schedule_activate_all ((NMPolicy *) user_data);
-}
-
-static void
-connection_removed (NMManager *manager,
-                    NMConnection *connection,
-                    NMConnectionScope scope,
-                    gpointer user_data)
-{
-	NMSettingConnection *s_con;
-	GPtrArray *list;
-	int i;
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	if (!s_con)
-		return;
-
-	list = nm_manager_get_active_connections_by_connection (manager, connection);
-	if (!list)
-		return;
-
-	for (i = 0; i < list->len; i++) {
-		char *path = g_ptr_array_index (list, i);
-		GError *error = NULL;
-
-		if (!nm_manager_deactivate_connection (manager, path, NM_DEVICE_STATE_REASON_CONNECTION_REMOVED, &error)) {
-			nm_warning ("Connection '%s' disappeared, but error deactivating it: (%d) %s",
-			            nm_setting_connection_get_id (s_con), error->code, error->message);
-			g_error_free (error);
-		}
-		g_free (path);
-	}
-	g_ptr_array_free (list, TRUE);
-}
-
-NMPolicy *
-nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager)
-{
-	NMPolicy *policy;
-	static gboolean initialized = FALSE;
-	gulong id;
-	char hostname[HOST_NAME_MAX + 2];
-
-	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
-	g_return_val_if_fail (initialized == FALSE, NULL);
-
-	policy = g_malloc0 (sizeof (NMPolicy));
-	policy->manager = g_object_ref (manager);
-	policy->update_state_id = 0;
-
-	/* Grab hostname on startup and use that if nothing provides one */
-	memset (hostname, 0, sizeof (hostname));
-	if (gethostname (&hostname[0], HOST_NAME_MAX) == 0) {
-		/* only cache it if it's a valid hostname */
-		if (strlen (hostname) && strcmp (hostname, "localhost") && strcmp (hostname, "localhost.localdomain"))
-			policy->orig_hostname = g_strdup (hostname);
-	}
-
-	policy->vpn_manager = g_object_ref (vpn_manager);
-	id = g_signal_connect (policy->vpn_manager, "connection-activated",
-	                       G_CALLBACK (vpn_connection_activated), policy);
-	policy->vpn_activated_id = id;
-	id = g_signal_connect (policy->vpn_manager, "connection-deactivated",
-	                       G_CALLBACK (vpn_connection_deactivated), policy);
-	policy->vpn_deactivated_id = id;
-
-	id = g_signal_connect (manager, "state-changed",
-	                       G_CALLBACK (global_state_changed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "notify::" NM_MANAGER_HOSTNAME,
-	                       G_CALLBACK (hostname_changed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "notify::" NM_MANAGER_SLEEPING,
-	                       G_CALLBACK (sleeping_changed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "device-added",
-	                       G_CALLBACK (device_added), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "device-removed",
-	                       G_CALLBACK (device_removed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	/* Large batch of connections added, manager doesn't want us to
-	 * process each one individually.
-	 */
-	id = g_signal_connect (manager, "connections-added",
-	                       G_CALLBACK (connections_added), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	/* Single connection added */
-	id = g_signal_connect (manager, "connection-added",
-	                       G_CALLBACK (connection_added), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "connection-updated",
-	                       G_CALLBACK (connection_updated), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	id = g_signal_connect (manager, "connection-removed",
-	                       G_CALLBACK (connection_removed), policy);
-	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
-
-	return policy;
-}
-
-void
-nm_policy_destroy (NMPolicy *policy)
-{
-	GSList *iter;
-
-	g_return_if_fail (policy != NULL);
-
-	/* Tell any existing hostname lookup thread to die, it'll get cleaned up
-	 * by the lookup thread callback.
-	  */
-	if (policy->lookup) {
-		lookup_thread_die (policy->lookup);
-		policy->lookup = NULL;
-	}
-
-	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
-		ActivateData *data = (ActivateData *) iter->data;
-
-		g_source_remove (data->id);
-		g_object_unref (data->device);
-		g_free (data);
-	}
-	g_slist_free (policy->pending_activation_checks);
-
-	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_activated_id);
-	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_deactivated_id);
-
-	for (iter = policy->signal_ids; iter; iter = g_slist_next (iter))
-		g_signal_handler_disconnect (policy->manager, (gulong) iter->data);
-	g_slist_free (policy->signal_ids);
-
-	for (iter = policy->dev_signal_ids; iter; iter = g_slist_next (iter)) {
-		DeviceSignalID *data = (DeviceSignalID *) iter->data;
-
-		g_signal_handler_disconnect (data->device, data->id);
-		g_free (data);
-	}
-	g_slist_free (policy->dev_signal_ids);
-
-	g_free (policy->orig_hostname);
-
-	g_object_unref (policy->manager);
-	g_free (policy);
-}
-
diff --git a/src/NetworkManagerPolicy.h b/src/NetworkManagerPolicy.h
deleted file mode 100644
index 7d99613..0000000
--- a/src/NetworkManagerPolicy.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2007 - 2008 Novell, Inc.
- */
-
-#ifndef NETWORK_MANAGER_POLICY_H
-#define NETWORK_MANAGER_POLICY_H
-
-#include "NetworkManager.h"
-#include "nm-manager.h"
-#include "nm-vpn-manager.h"
-#include "nm-device.h"
-#include "nm-activation-request.h"
-
-typedef struct NMPolicy NMPolicy;
-
-NMPolicy *nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager);
-void nm_policy_destroy (NMPolicy *policy);
-
-#endif /* NETWORK_MANAGER_POLICY_H */
diff --git a/src/NetworkManagerSystem.c b/src/NetworkManagerSystem.c
deleted file mode 100644
index c514a22..0000000
--- a/src/NetworkManagerSystem.c
+++ /dev/null
@@ -1,1109 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2005 - 2008 Novell, Inc.
- * Copyright (C) 1996 - 1997 Yoichi Hariguchi <yoichi@fore.com>
- * Copyright (C) January, 1998 Sergei Viznyuk <sv@phystech.com>
- */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <netinet/in.h>
-#include <net/route.h>
-#include <arpa/nameser.h>
-#include <arpa/inet.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <syslog.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <resolv.h>
-#include <netdb.h>
-#include <glib.h>
-#include <ctype.h>
-#include <net/if.h>
-
-#include "NetworkManagerSystem.h"
-#include "nm-device.h"
-#include "nm-named-manager.h"
-#include "NetworkManagerUtils.h"
-#include "nm-utils.h"
-#include "nm-netlink.h"
-
-/* Because of a bug in libnl, rtnl.h should be included before route.h */
-#include <netlink/route/rtnl.h>
-
-#include <netlink/route/addr.h>
-#include <netlink/route/route.h>
-#include <netlink/netlink.h>
-#include <netlink/utils.h>
-#include <netlink/route/link.h>
-
-static void nm_system_device_set_priority (const char *iface,
-								   NMIP4Config *config,
-								   int priority);
-
-static gboolean
-ip4_dest_in_same_subnet (NMIP4Config *config, guint32 dest, guint32 dest_prefix)
-{
-	int num;
-	int i;
-
-	num = nm_ip4_config_get_num_addresses (config);
-	for (i = 0; i < num; i++) {
-		NMIP4Address *addr = nm_ip4_config_get_address (config, i);
-		guint32 prefix = nm_ip4_address_get_prefix (addr);
-		guint32 address = nm_ip4_address_get_address (addr);
-
-		if (prefix <= dest_prefix) {
-			guint32 masked_addr = ntohl(address) >> (32 - prefix);
-			guint32 masked_dest = ntohl(dest) >> (32 - prefix);
-
-			if (masked_addr == masked_dest)
-				return TRUE;
-		}
-	}
-
-	return FALSE;
-}
-
-static struct rtnl_route *
-create_route (int iface_idx, int mss)
-{
-	struct rtnl_route *route;
-
-	route = rtnl_route_alloc ();
-	if (route) {
-		rtnl_route_set_oif (route, iface_idx);
-
-		if (mss && rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0)
-			nm_warning ("Could not set mss");
-	} else
-		nm_warning ("Could not allocate route");
-
-	return route;
-}
-
-static struct rtnl_route *
-nm_system_device_set_ip4_route (const char *iface, 
-                                guint32 ip4_dest,
-                                guint32 ip4_prefix,
-                                guint32 ip4_gateway,
-                                guint32 metric,
-                                int mss)
-{
-	struct nl_handle *nlh;
-	struct rtnl_route *route;
-	struct nl_addr *dest_addr;
-	struct nl_addr *gw_addr = NULL;
-	int err, iface_idx;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, NULL);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	g_return_val_if_fail (iface_idx >= 0, NULL);
-
-	route = create_route (iface_idx, mss);
-	g_return_val_if_fail (route != NULL, NULL);
-
-	/* Destination */
-	dest_addr = nl_addr_build (AF_INET, &ip4_dest, sizeof (ip4_dest));
-	g_return_val_if_fail (dest_addr != NULL, NULL);
-	nl_addr_set_prefixlen (dest_addr, (int) ip4_prefix);
-
-	rtnl_route_set_dst (route, dest_addr);
-	nl_addr_put (dest_addr);
-
-	/* Gateway */
-	if (ip4_gateway) {
-		gw_addr = nl_addr_build (AF_INET, &ip4_gateway, sizeof (ip4_gateway));
-		if (gw_addr) {
-			rtnl_route_set_gateway (route, gw_addr);
-			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
-		} else {
-			nm_warning ("Invalid gateway");
-			rtnl_route_put (route);
-			return NULL;
-		}
-	}
-
-	/* Metric */
-	if (metric)
-		rtnl_route_set_prio (route, metric);
-
-	/* Add the route */
-	err = rtnl_route_add (nlh, route, 0);
-	if (err == -ESRCH && ip4_gateway) {
-		/* Gateway might be over a bridge; try adding a route to gateway first */
-		struct rtnl_route *route2;
-
-		route2 = create_route (iface_idx, mss);
-		if (route2) {
-			/* Add route to gateway over bridge */
-			rtnl_route_set_dst (route2, gw_addr);
-			err = rtnl_route_add (nlh, route2, 0);
-			if (!err) {
-				/* Try adding the route again */
-				err = rtnl_route_add (nlh, route, 0);
-				if (err)
-					rtnl_route_del (nlh, route2, 0);
-			}
-			rtnl_route_put (route2);
-		}
-	}
-
-	if (gw_addr)
-		nl_addr_put (gw_addr);
-
-	if (err) {
-		nm_warning ("Failed to set IPv4 route on '%s': %s", iface, nl_geterror ());
-		rtnl_route_put (route);
-		route = NULL;
-	}
-
-	return route;
-}
-
-static gboolean
-sync_addresses (const char *iface, int ifindex, int family,
-				struct rtnl_addr **addrs, int num_addrs)
-{
-	struct nl_handle *nlh;
-	struct nl_cache *addr_cache;
-	struct rtnl_addr *filter_addr, *match_addr;
-	struct nl_object *match;
-	int i, err;
-
-	nlh = nm_netlink_get_default_handle ();
-	if (!nlh)
-		return FALSE;
-
-	addr_cache = rtnl_addr_alloc_cache (nlh);
-	if (!addr_cache)
-		return FALSE;
-
-	filter_addr = rtnl_addr_alloc ();
-	if (!filter_addr) {
-		nl_cache_free (addr_cache);
-		return FALSE;
-	}
-	rtnl_addr_set_ifindex (filter_addr, ifindex);
-	if (family)
-		rtnl_addr_set_family (filter_addr, family);
-
-	/* Walk through the cache, comparing the addresses already on
-	 * the interface to the addresses in addrs.
-	 */
-	for (match = nl_cache_get_first (addr_cache); match; match = nl_cache_get_next (match)) {
-		match_addr = (struct rtnl_addr *)match;
-
-		/* Skip addresses not on our interface */
-		if (!nl_object_match_filter (match, (struct nl_object *)filter_addr))
-			continue;
-
-		if (addrs) {
-			for (i = 0; i < num_addrs; i++) {
-				if (addrs[i] &&
-					nl_object_identical (match, (struct nl_object *)addrs[i]))
-					break;
-			}
-
-			if (addrs[i]) {
-				/* match == addrs[i], so remove it from addrs so we don't
-				 * try to add it to the interface again below.
-				 */
-				rtnl_addr_put (addrs[i]);
-				addrs[i] = NULL;
-				continue;
-			}
-		}
-
-		/* Don't delete IPv6 link-local addresses; they don't belong to NM */
-		if (rtnl_addr_get_family (match_addr) == AF_INET6 &&
-			rtnl_addr_get_scope (match_addr) == RT_SCOPE_LINK) {
-			continue;
-		}
-
-		/* Otherwise, match_addr should be removed from the interface. */
-		err = rtnl_addr_delete (nlh, match_addr, 0);
-		if (err < 0) {
-			nm_warning ("(%s) error %d returned from rtnl_addr_delete(): %s",
-						iface, err, nl_geterror ());
-		}
-	}
-
-	rtnl_addr_put (filter_addr);
-	nl_cache_free (addr_cache);
-
-	/* Now add the remaining new addresses */
-	for (i = 0; i < num_addrs; i++) {
-		if (!addrs[i])
-			continue;
-
-		err = rtnl_addr_add (nlh, addrs[i], 0);
-		if (err < 0) {
-			nm_warning ("(%s) error %d returned from rtnl_addr_add():\n%s",
-						iface, err, nl_geterror ());
-		}
-
-		rtnl_addr_put (addrs[i]);
-	}
-	g_free (addrs);
-
-	return TRUE;
-}
-
-static gboolean
-add_ip4_addresses (NMIP4Config *config, const char *iface)
-{
-	int num_addrs, i, iface_idx;
-	guint32 flags = 0;
-	gboolean did_gw = FALSE;
-	struct rtnl_addr **addrs;
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-
-	num_addrs = nm_ip4_config_get_num_addresses (config);
-	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
-
-	for (i = 0; i < num_addrs; i++) {
-		NMIP4Address *addr;
-
-		addr = nm_ip4_config_get_address (config, i);
-		g_assert (addr);
-
-		flags = NM_RTNL_ADDR_DEFAULT;
-		if (nm_ip4_address_get_gateway (addr) && !did_gw) {
-			if (nm_ip4_config_get_ptp_address (config))
-				flags |= NM_RTNL_ADDR_PTP_ADDR;
-			did_gw = TRUE;
-		}
-
-		addrs[i] = nm_ip4_config_to_rtnl_addr (config, i, flags);
-		if (!addrs[i]) {
-			nm_warning ("couldn't create rtnl address!\n");
-			continue;
-		}
-		rtnl_addr_set_ifindex (addrs[i], iface_idx);
-	}
-
-	return sync_addresses (iface, iface_idx, AF_INET, addrs, num_addrs);
-}
-
-struct rtnl_route *
-nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config)
-{
-	NMIP4Config *parent_config;
-	guint32 parent_gw = 0, parent_prefix = 0, vpn_gw = 0, i;
-	NMIP4Address *tmp;
-	struct rtnl_route *route = NULL;
-
-	g_return_val_if_fail (NM_IS_DEVICE (parent_device), NULL);
-
-	/* Set up a route to the VPN gateway's public IP address through the default
-	 * network device if the VPN gateway is on a different subnet.
-	 */
-
-	parent_config = nm_device_get_ip4_config (parent_device);
-	g_return_val_if_fail (parent_config != NULL, NULL);
-
-	for (i = 0; i < nm_ip4_config_get_num_addresses (parent_config); i++) {
-		tmp = nm_ip4_config_get_address (parent_config, i);
-		if (nm_ip4_address_get_gateway (tmp)) {
-			parent_gw = nm_ip4_address_get_gateway (tmp);
-			parent_prefix = nm_ip4_address_get_prefix (tmp);
-			break;
-		}
-	}
-
-	for (i = 0; i < nm_ip4_config_get_num_addresses (vpn_config); i++) {
-		tmp = nm_ip4_config_get_address (vpn_config, i);
-		if (nm_ip4_address_get_gateway (tmp)) {
-			vpn_gw = nm_ip4_address_get_gateway (tmp);
-			break;
-		}
-	}
-
-	if (!parent_gw || !vpn_gw)
-		return NULL;
-
-	/* If the VPN gateway is in the same subnet as one of the parent device's
-	 * IP addresses, don't add the host route to it, but a route through the
-	 * parent device.
-	 */
-	if (ip4_dest_in_same_subnet (parent_config, vpn_gw, parent_prefix)) {
-		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
-		                                        vpn_gw, 32, 0, 0, nm_ip4_config_get_mss (parent_config));
-	} else {
-		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
-		                                        vpn_gw, 32, parent_gw, 0, nm_ip4_config_get_mss (parent_config));
-	}
-
-	return route;
-}
-
-/*
- * nm_system_apply_ip4_config
- *
- * Set IPv4 configuration of the device from an NMIP4Config object.
- *
- */
-gboolean
-nm_system_apply_ip4_config (const char *iface,
-                            NMIP4Config *config,
-                            int priority,
-                            NMIP4ConfigCompareFlags flags)
-{
-	int i;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (config != NULL, FALSE);
-
-	if (flags & NM_IP4_COMPARE_FLAG_ADDRESSES) {
-		if (!add_ip4_addresses (config, iface))
-			return FALSE;
-		sleep (1);
-	}
-
-	if (flags & NM_IP4_COMPARE_FLAG_ROUTES) {
-		for (i = 0; i < nm_ip4_config_get_num_routes (config); i++) {
-			NMIP4Route *route = nm_ip4_config_get_route (config, i);
-			struct rtnl_route *tmp;
-
-			/* Don't add the route if it's more specific than one of the subnets
-			 * the device already has an IP address on.
-			 */
-			if (ip4_dest_in_same_subnet (config,
-			                             nm_ip4_route_get_dest (route),
-			                             nm_ip4_route_get_prefix (route)))
-				continue;
-
-			/* Don't add the route if it doesn't have a gateway and the connection
-			 * is never supposed to be the default connection.
-			 */
-			if (   nm_ip4_config_get_never_default (config)
-			    && nm_ip4_route_get_dest (route) == 0)
-				continue;
-
-			tmp = nm_system_device_set_ip4_route (iface,
-			                                      nm_ip4_route_get_dest (route),
-			                                      nm_ip4_route_get_prefix (route),
-			                                      nm_ip4_route_get_next_hop (route),
-			                                      nm_ip4_route_get_metric (route),
-			                                      nm_ip4_config_get_mss (config));
-			rtnl_route_put (tmp);
-		}
-	}
-
-	if (flags & NM_IP4_COMPARE_FLAG_MTU) {
-		if (nm_ip4_config_get_mtu (config))
-			nm_system_device_set_mtu (iface, nm_ip4_config_get_mtu (config));
-	}
-
-	if (priority > 0)
-		nm_system_device_set_priority (iface, config, priority);
-
-	return TRUE;
-}
-
-static struct rtnl_route *
-nm_system_device_set_ip6_route (const char *iface,
-                                const struct in6_addr *ip6_dest,
-                                guint32 ip6_prefix,
-                                const struct in6_addr *ip6_gateway,
-                                guint32 metric,
-                                int mss)
-{
-	struct nl_handle *nlh;
-	struct rtnl_route *route;
-	struct nl_addr *dest_addr;
-	struct nl_addr *gw_addr = NULL;
-	int err, iface_idx;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, NULL);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	g_return_val_if_fail (iface_idx >= 0, NULL);
-
-	route = create_route (iface_idx, mss);
-	g_return_val_if_fail (route != NULL, NULL);
-
-	/* Destination */
-	dest_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_dest, sizeof (*ip6_dest));
-	g_return_val_if_fail (dest_addr != NULL, NULL);
-	nl_addr_set_prefixlen (dest_addr, (int) ip6_prefix);
-
-	rtnl_route_set_dst (route, dest_addr);
-	nl_addr_put (dest_addr);
-
-	/* Gateway */
-	if (ip6_gateway && !IN6_IS_ADDR_UNSPECIFIED (ip6_gateway)) {
-		gw_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_gateway, sizeof (*ip6_gateway));
-		if (gw_addr) {
-			rtnl_route_set_gateway (route, gw_addr);
-			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
-		} else {
-			nm_warning ("Invalid gateway");
-			rtnl_route_put (route);
-			return NULL;
-		}
-	}
-
-	/* Metric */
-	if (metric)
-		rtnl_route_set_prio (route, metric);
-
-	/* Add the route */
-	err = rtnl_route_add (nlh, route, 0);
-	if (err == -ESRCH && ip6_gateway) {
-		/* Gateway might be over a bridge; try adding a route to gateway first */
-		struct rtnl_route *route2;
-
-		route2 = create_route (iface_idx, mss);
-		if (route2) {
-			/* Add route to gateway over bridge */
-			rtnl_route_set_dst (route2, gw_addr);
-			err = rtnl_route_add (nlh, route2, 0);
-			if (!err) {
-				/* Try adding the route again */
-				err = rtnl_route_add (nlh, route, 0);
-				if (err)
-					rtnl_route_del (nlh, route2, 0);
-			}
-			rtnl_route_put (route2);
-		}
-	}
-
-	if (gw_addr)
-		nl_addr_put (gw_addr);
-
-	if (err) {
-		nm_warning ("Failed to set IPv6 route on '%s': %s", iface, nl_geterror ());
-		rtnl_route_put (route);
-		route = NULL;
-	}
-
-	return route;
-}
-
-static gboolean
-add_ip6_addresses (NMIP6Config *config, const char *iface)
-{
-	int num_addrs, i, iface_idx;
-	struct rtnl_addr **addrs;
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-
-	num_addrs = nm_ip6_config_get_num_addresses (config);
-	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
-
-	for (i = 0; i < num_addrs; i++) {
-		NMIP6Address *addr;
-
-		addr = nm_ip6_config_get_address (config, i);
-		g_assert (addr);
-
-		addrs[i] = nm_ip6_config_to_rtnl_addr (config, i, NM_RTNL_ADDR_DEFAULT);
-		if (!addrs[i]) {
-			nm_warning ("couldn't create rtnl address!\n");
-			continue;
-		}
-		rtnl_addr_set_ifindex (addrs[i], iface_idx);
-	}
-
-	return sync_addresses (iface, iface_idx, AF_INET6, addrs, num_addrs);
-}
-
-/*
- * nm_system_apply_ip6_config
- *
- * Set IPv6 configuration of the device from an NMIP6Config object.
- *
- */
-gboolean
-nm_system_apply_ip6_config (const char *iface,
-                            NMIP6Config *config,
-                            int priority,
-                            NMIP6ConfigCompareFlags flags)
-{
-	int i;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (config != NULL, FALSE);
-
-	if (flags & NM_IP6_COMPARE_FLAG_ADDRESSES) {
-		if (!add_ip6_addresses (config, iface))
-			return FALSE;
-		sleep (1); // FIXME?
-	}
-
-	if (flags & NM_IP6_COMPARE_FLAG_ROUTES) {
-		for (i = 0; i < nm_ip6_config_get_num_routes (config); i++) {
-			NMIP6Route *route = nm_ip6_config_get_route (config, i);
-			struct rtnl_route *tmp;
-
-			/* Don't add the route if it doesn't have a gateway and the connection
-			 * is never supposed to be the default connection.
-			 */
-			if (   nm_ip6_config_get_never_default (config)
-			    && IN6_IS_ADDR_UNSPECIFIED(nm_ip6_route_get_dest (route)))
-				continue;
-
-			tmp = nm_system_device_set_ip6_route (iface,
-			                                      nm_ip6_route_get_dest (route),
-			                                      nm_ip6_route_get_prefix (route),
-			                                      nm_ip6_route_get_next_hop (route),
-			                                      nm_ip6_route_get_metric (route),
-			                                      nm_ip6_config_get_mss (config));
-			rtnl_route_put (tmp);
-		}
-	}
-
-// FIXME
-//	if (priority > 0)
-//		nm_system_device_set_priority (iface, config, priority);
-
-	return TRUE;
-}
-
-/*
- * nm_system_device_set_up_down
- *
- * Mark the device as up or down.
- *
- */
-gboolean
-nm_system_device_set_up_down (NMDevice *dev,
-                              gboolean up,
-                              gboolean *no_firmware)
-{
-	g_return_val_if_fail (dev != NULL, FALSE);
-
-	return nm_system_device_set_up_down_with_iface (nm_device_get_ip_iface (dev), up, no_firmware);
-}
-
-gboolean
-nm_system_device_set_up_down_with_iface (const char *iface,
-                                         gboolean up,
-                                         gboolean *no_firmware)
-{
-	struct rtnl_link *request = NULL, *old = NULL;
-	struct nl_handle *nlh;
-	gboolean success = FALSE;
-	guint32 idx;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	if (no_firmware)
-		g_return_val_if_fail (*no_firmware == FALSE, FALSE);
-
-	if (!(request = rtnl_link_alloc ()))
-		goto out;
-
-	if (up)
-		rtnl_link_set_flags (request, IFF_UP);
-	else
-		rtnl_link_unset_flags (request, IFF_UP);
-
-	idx = nm_netlink_iface_to_index (iface);
-	old = nm_netlink_index_to_rtnl_link (idx);
-	if (old) {
-		nlh = nm_netlink_get_default_handle ();
-		if (nlh) {
-			if (rtnl_link_change (nlh, old, request, 0) == 0)
-				success = TRUE;
-			else if ((nl_get_errno () == ENOENT) && no_firmware && up)
-				*no_firmware = TRUE;
-		}
-	}
-
-	rtnl_link_put (old);
-	rtnl_link_put (request);
-
-out:
-	return success;
-}
-
-gboolean
-nm_system_device_is_up (NMDevice *device)
-{
-	g_return_val_if_fail (device != NULL, FALSE);
-
-	return nm_system_device_is_up_with_iface (nm_device_get_ip_iface (device));
-}
-
-gboolean
-nm_system_device_is_up_with_iface (const char *iface)
-{
-	struct ifreq ifr;
-	int fd;
-	gboolean up = FALSE;
-
-	fd = socket (PF_INET, SOCK_DGRAM, 0);
-	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
-		return FALSE;
-	}
-
-	/* Get device's flags */
-	memset (&ifr, 0, sizeof (ifr));
-	strncpy (ifr.ifr_name, iface, IFNAMSIZ);
-	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0) {
-		if (errno != ENODEV) {
-			nm_warning ("%s: could not get flags for device %s.  errno = %d", 
-			            __func__, iface, errno);
-		}
-	} else {
-		up = !!(ifr.ifr_flags & IFF_UP);
-	}
-	close (fd);
-
-	return up;
-}
-
-gboolean
-nm_system_device_set_mtu (const char *iface, guint32 mtu)
-{
-	struct rtnl_link *old;
-	struct rtnl_link *new;
-	gboolean success = FALSE;
-	struct nl_handle *nlh;
-	int iface_idx;
-
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (mtu > 0, FALSE);
-
-	new = rtnl_link_alloc ();
-	if (!new)
-		return FALSE;
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	old = nm_netlink_index_to_rtnl_link (iface_idx);
-	if (old) {
-		rtnl_link_set_mtu (new, mtu);
-		nlh = nm_netlink_get_default_handle ();
-		if (nlh) {
-			rtnl_link_change (nlh, old, new, 0);
-			success = TRUE;
-		}
-		rtnl_link_put (old);
-	}
-
-	rtnl_link_put (new);
-	return success;
-}
-
-static struct rtnl_route *
-add_ip4_route_to_gateway (const char *iface, guint32 gw, guint32 mss)
-{
-	struct nl_handle *nlh;
-	struct rtnl_route *route = NULL;
-	struct nl_addr *gw_addr = NULL;
-	int iface_idx, err;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, NULL);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx < 0)
-		return NULL;
-
-	/* Gateway might be over a bridge; try adding a route to gateway first */
-	route = rtnl_route_alloc ();
-	if (route == NULL)
-		return NULL;
-
-	rtnl_route_set_family (route, AF_INET);
-	rtnl_route_set_table (route, RT_TABLE_MAIN);
-	rtnl_route_set_oif (route, iface_idx);
-	rtnl_route_set_scope (route, RT_SCOPE_LINK);
-
-	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
-	if (!gw_addr)
-		goto error;
-	nl_addr_set_prefixlen (gw_addr, 32);
-	rtnl_route_set_dst (route, gw_addr);
-	nl_addr_put (gw_addr);
-
-	if (mss) {
-		if (rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0)
-			goto error;
-	}
-
-	/* Add direct route to the gateway */
-	err = rtnl_route_add (nlh, route, 0);
-	if (err) {
-		nm_warning ("(%s): failed to add IPv4 route to gateway (%d)", iface, err);
-		goto error;
-	}
-
-	return route;
-
-error:
-	rtnl_route_put (route);
-	return NULL;
-}
-
-static int
-replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
-{
-	struct rtnl_route *route = NULL;
-	struct nl_handle *nlh;
-	struct nl_addr *dst_addr = NULL;
-	guint32 dst = 0;
-	struct nl_addr *gw_addr = NULL;
-	int iface_idx, err = -1;
-
-	g_return_val_if_fail (iface != NULL, -ENODEV);
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, -ENOMEM);
-
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx < 0)
-		return -ENODEV;
-
-	route = rtnl_route_alloc();
-	g_return_val_if_fail (route != NULL, -ENOMEM);
-
-	rtnl_route_set_family (route, AF_INET);
-	rtnl_route_set_table (route, RT_TABLE_MAIN);
-	rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
-	rtnl_route_set_oif (route, iface_idx);
-
-	/* Build up the destination address */
-	dst_addr = nl_addr_build (AF_INET, &dst, sizeof (dst));
-	if (!dst_addr) {
-		err = -ENOMEM;
-		goto out;
-	}
-	nl_addr_set_prefixlen (dst_addr, 0);
-	rtnl_route_set_dst (route, dst_addr);
-
-	/* Build up the gateway address */
-	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
-	if (!gw_addr) {
-		err = -ENOMEM;
-		goto out;
-	}
-	nl_addr_set_prefixlen (gw_addr, 0);
-	rtnl_route_set_gateway (route, gw_addr);
-
-	if (mss > 0) {
-		err = rtnl_route_set_metric (route, RTAX_ADVMSS, mss);
-		if (err < 0)
-			goto out;
-	}
-
-	/* Add the new default route */
-	err = rtnl_route_add (nlh, route, NLM_F_REPLACE);
-
-out:
-	if (dst_addr)
-		nl_addr_put (dst_addr);
-	if (gw_addr)
-		nl_addr_put (gw_addr);
-	rtnl_route_put (route);
-	return err;
-}
-
-/*
- * nm_system_replace_default_ip4_route_vpn
- *
- * Replace default IPv4 route with one via the current device
- *
- */
-gboolean
-nm_system_replace_default_ip4_route_vpn (const char *iface,
-                                         guint32 ext_gw,
-                                         guint32 int_gw,
-                                         guint32 mss,
-                                         const char *parent_iface,
-                                         guint32 parent_mss)
-{
-	struct rtnl_route *gw_route = NULL;
-	struct nl_handle *nlh;
-	gboolean success = FALSE;
-	int err;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, FALSE);
-
-	err = replace_default_ip4_route (iface, int_gw, mss);
-	if (err == 0) {
-		return TRUE;
-	} else if (err != -ESRCH) {
-		nm_warning ("(%s): failed to set IPv4 default route: %d",
-		            iface, err);
-		return FALSE;
-	}
-
-	/* Try adding a direct route to the gateway first */
-	gw_route = add_ip4_route_to_gateway (parent_iface, ext_gw, parent_mss);
-	if (!gw_route)
-		return FALSE;
-
-	/* Try adding the original route again */
-	err = replace_default_ip4_route (iface, int_gw, mss);
-	if (err != 0) {
-		rtnl_route_del (nlh, gw_route, 0);
-		nm_warning ("(%s): failed to set IPv4 default route (pass #2): %d",
-		            iface, err);
-	} else
-		success = TRUE;
-
-	rtnl_route_put (gw_route);
-	return success;
-}
-
-/*
- * nm_system_replace_default_ip4_route
- *
- * Replace default IPv4 route with one via the current device
- *
- */
-gboolean
-nm_system_replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
-{
-	struct rtnl_route *gw_route = NULL;
-	struct nl_handle *nlh;
-	gboolean success = FALSE;
-	int err;
-
-	nlh = nm_netlink_get_default_handle ();
-	g_return_val_if_fail (nlh != NULL, FALSE);
-
-	err = replace_default_ip4_route (iface, gw, mss);
-	if (err == 0) {
-		return TRUE;
-	} else if (err != -ESRCH) {
-		nm_warning ("(%s): failed to set IPv4 default route: %d",
-		            iface, err);
-		return FALSE;
-	}
-
-	/* Try adding a direct route to the gateway first */
-	gw_route = add_ip4_route_to_gateway (iface, gw, mss);
-	if (!gw_route)
-		return FALSE;
-
-	/* Try adding the original route again */
-	err = replace_default_ip4_route (iface, gw, mss);
-	if (err != 0) {
-		rtnl_route_del (nlh, gw_route, 0);
-		nm_warning ("(%s): failed to set IPv4 default route (pass #2): %d",
-		            iface, err);
-	} else
-		success = TRUE;
-
-	rtnl_route_put (gw_route);
-	return success;
-}
-
-static void flush_addresses (const char *iface, gboolean ipv4_only)
-{
-	int iface_idx;
-
-	g_return_if_fail (iface != NULL);
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx >= 0)
-		sync_addresses (iface, iface_idx, ipv4_only ? AF_INET : 0, NULL, 0);
-}
-
-/*
- * nm_system_device_flush_addresses
- *
- * Flush all network addresses associated with a network device
- *
- */
-void nm_system_device_flush_addresses (NMDevice *dev)
-{
-	g_return_if_fail (dev != NULL);
-
-	flush_addresses (nm_device_get_ip_iface (dev),
-					 nm_device_get_ip6_config (dev) == NULL);
-}
-
-
-/*
- * nm_system_device_flush_addresses_with_iface
- *
- * Flush all network addresses associated with a network device
- *
- */
-void nm_system_device_flush_addresses_with_iface (const char *iface)
-{
-	flush_addresses (iface, FALSE);
-}
-
-
-static void
-foreach_route (void (*callback)(struct nl_object *, gpointer),
-			gpointer user_data)
-{
-	struct nl_handle *nlh;
-	struct nl_cache *route_cache;
-
-	nlh = nm_netlink_get_default_handle ();
-	route_cache = rtnl_route_alloc_cache (nlh);
-	nl_cache_mngt_provide (route_cache);
-	nl_cache_foreach (route_cache, callback, user_data);
-	nl_cache_free (route_cache);
-}
-
-
-typedef struct {
-	const char *iface;
-	int iface_idx;
-	int family;
-} RouteCheckData;
-
-static void
-check_one_route (struct nl_object *object, void *user_data)
-{
-	RouteCheckData *data = (RouteCheckData *) user_data;
-	struct rtnl_route *route = (struct rtnl_route *) object;
-	int err;
-
-	/* Delete all routes from this interface */
-	if (rtnl_route_get_oif (route) != data->iface_idx)
-		return;
-	if (data->family && rtnl_route_get_family (route) != data->family)
-		return;
-
-	err = rtnl_route_del (nm_netlink_get_default_handle (), route, 0);
-	if (err < 0) {
-		nm_warning ("(%s) error %d returned from rtnl_route_del(): %s",
-		            data->iface, err, nl_geterror());
-	}
-}
-
-static void flush_routes (const char *iface, gboolean ipv4_only)
-{
-	int iface_idx;
-	RouteCheckData check_data;
-
-	g_return_if_fail (iface != NULL);
-	iface_idx = nm_netlink_iface_to_index (iface);
-	if (iface_idx >= 0) {
-		memset (&check_data, 0, sizeof (check_data));
-		check_data.iface = iface;
-		check_data.iface_idx = iface_idx;
-		check_data.family = ipv4_only ? AF_INET : 0;
-
-		foreach_route (check_one_route, &check_data);
-	}
-}
-
-/*
- * nm_system_device_flush_routes
- *
- * Flush all network addresses associated with a network device
- *
- */
-void nm_system_device_flush_routes (NMDevice *dev)
-{
-	g_return_if_fail (dev != NULL);
-
-	flush_routes (nm_device_get_ip_iface (dev),
-				  nm_device_get_ip6_config (dev) == NULL);
-}
-
-/*
- * nm_system_device_flush_routes_with_iface
- *
- * Flush all routes associated with a network device
- *
- */
-void nm_system_device_flush_routes_with_iface (const char *iface)
-{
-	flush_routes (iface, FALSE);
-}
-
-typedef struct {
-	struct rtnl_route *route;
-	NMIP4Config *config;
-	int iface;
-} SetPriorityInfo;
-
-static void
-find_route (struct nl_object *object, gpointer user_data)
-{
-	struct rtnl_route *route = (struct rtnl_route *) object;
-	SetPriorityInfo *info = (SetPriorityInfo *) user_data;
-	struct nl_addr *dst;
-	struct in_addr *dst_addr;
-	int num;
-	int i;
-
-	if (info->route ||
-	    rtnl_route_get_oif (route) != info->iface ||
-	    rtnl_route_get_scope (route) != RT_SCOPE_LINK)
-		return;
-
-	dst = rtnl_route_get_dst (route);
-	if (nl_addr_get_family (dst) != AF_INET)
-		return;
-
-	dst_addr = nl_addr_get_binary_addr (dst);
-	num = nm_ip4_config_get_num_addresses (info->config);
-	for (i = 0; i < num; i++) {
-		NMIP4Address *addr = nm_ip4_config_get_address (info->config, i);
-		guint32 prefix = nm_ip4_address_get_prefix (addr);
-		guint32 address = nm_ip4_address_get_address (addr);
-
-		if (prefix == nl_addr_get_prefixlen (dst) &&
-		    (address & nm_utils_ip4_prefix_to_netmask (prefix)) == dst_addr->s_addr) {
-
-			/* Ref the route so it sticks around after the cache is cleared */
-			rtnl_route_get (route);
-			info->route = route;
-			break;
-		}
-	}
-}
-
-static void
-nm_system_device_set_priority (const char *iface,
-						 NMIP4Config *config,
-						 int priority)
-{
-	SetPriorityInfo info;
-
-	info.route = NULL;
-	info.config = config;
-	info.iface = nm_netlink_iface_to_index (iface);
-	g_return_if_fail (info.iface >= 0);
-
-	foreach_route (find_route, &info);
-	if (info.route) {
-		struct nl_handle *nlh;
-
-		nlh = nm_netlink_get_default_handle ();
-		rtnl_route_del (nlh, info.route, 0);
-
-		rtnl_route_set_prio (info.route, priority);
-		rtnl_route_add (nlh, info.route, 0);
-		rtnl_route_put (info.route);
-	}
-}
diff --git a/src/NetworkManagerSystem.h b/src/NetworkManagerSystem.h
deleted file mode 100644
index f2c2693..0000000
--- a/src/NetworkManagerSystem.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
- * Copyright (C) 2005 - 2008 Novell, Inc.
- */
-
-#ifndef NETWORK_MANAGER_SYSTEM_H
-#define NETWORK_MANAGER_SYSTEM_H
-
-#include <netlink/route/rtnl.h>
-#include <netlink/route/route.h>
-
-#include <glib.h>
-#include "nm-device.h"
-#include "nm-ip4-config.h"
-
-/* Prototypes for system/distribution dependent functions,
- * implemented in the backend files in backends/ directory
- */
-
-void			nm_system_device_flush_routes				(NMDevice *dev);
-void			nm_system_device_flush_routes_with_iface	(const char *iface);
-
-gboolean		nm_system_replace_default_ip4_route   (const char *iface,
-                                                       guint32 gw,
-                                                       guint32 mss);
-
-gboolean		nm_system_replace_default_ip4_route_vpn (const char *iface,
-                                                         guint32 ext_gw,
-                                                         guint32 int_gw,
-                                                         guint32 mss,
-                                                         const char *parent_iface,
-                                                         guint32 parent_mss);
-
-struct rtnl_route *nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config);
-
-
-void			nm_system_device_flush_addresses			(NMDevice *dev);
-void			nm_system_device_flush_addresses_with_iface	(const char *iface);
-
-void			nm_system_enable_loopback				(void);
-void			nm_system_update_dns					(void);
-
-gboolean		nm_system_apply_ip4_config              (const char *iface,
-                                                         NMIP4Config *config,
-                                                         int priority,
-                                                         NMIP4ConfigCompareFlags flags);
-
-gboolean		nm_system_apply_ip6_config              (const char *iface,
-                                                         NMIP6Config *config,
-                                                         int priority,
-                                                         NMIP6ConfigCompareFlags flags);
-
-gboolean		nm_system_device_set_up_down				(NMDevice *dev,
-                                                             gboolean up,
-                                                             gboolean *no_firmware);
-gboolean		nm_system_device_set_up_down_with_iface		(const char *iface,
-                                                             gboolean up,
-                                                             gboolean *no_firmware);
-
-gboolean        nm_system_device_is_up (NMDevice *device);
-gboolean        nm_system_device_is_up_with_iface (const char *iface);
-
-gboolean		nm_system_device_set_mtu (const char *iface, guint32 mtu);
-
-#endif
diff --git a/src/NetworkManagerUtils.c b/src/NetworkManagerUtils.c
index 4934d46..4bd57d9 100644
--- a/src/NetworkManagerUtils.c
+++ b/src/NetworkManagerUtils.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
  * Copyright (C) 2005 - 2008 Novell, Inc.
  */
 
@@ -28,6 +28,7 @@
 
 #include "NetworkManagerUtils.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-device.h"
 #include "nm-device-wifi.h"
 #include "nm-device-ethernet.h"
@@ -85,13 +86,13 @@ nm_spawn_process (const char *args)
 	g_return_val_if_fail (args != NULL, -1);
 
 	if (!g_shell_parse_argv (args, &num_args, &argv, &error)) {
-		nm_warning ("could not parse arguments for '%s': %s", args, error->message);
+		nm_log_warn (LOGD_CORE, "could not parse arguments for '%s': %s", args, error->message);
 		g_error_free (error);
 		return -1;
 	}
 
 	if (!g_spawn_sync ("/", argv, NULL, 0, NULL, NULL, NULL, NULL, &status, &error)) {
-		nm_warning ("could not spawn process '%s': %s", args, error->message);
+		nm_log_warn (LOGD_CORE, "could not spawn process '%s': %s", args, error->message);
 		g_error_free (error);
 	}
 
@@ -394,7 +395,7 @@ nm_utils_call_dispatcher (const char *action,
 	                                   NM_DISPATCHER_DBUS_PATH,
 	                                   NM_DISPATCHER_DBUS_IFACE);
 	if (!proxy) {
-		nm_warning ("Error: could not get dispatcher proxy!");
+		nm_log_err (LOGD_CORE, "could not get dispatcher proxy!");
 		g_object_unref (dbus_mgr);
 		return;
 	}
@@ -553,6 +554,20 @@ value_hash_add_uint (GHashTable *hash,
 	value_hash_add (hash, key, value);
 }
 
+void
+value_hash_add_bool (GHashTable *hash,
+					 const char *key,
+					 gboolean val)
+{
+	GValue *value;
+
+	value = g_slice_new0 (GValue);
+	g_value_init (value, G_TYPE_BOOLEAN);
+	g_value_set_boolean (value, val);
+
+	value_hash_add (hash, key, value);
+}
+
 gboolean
 nm_utils_do_sysctl (const char *path, const char *value)
 {
diff --git a/src/NetworkManagerUtils.h b/src/NetworkManagerUtils.h
index 05f3b83..fa8b598 100644
--- a/src/NetworkManagerUtils.h
+++ b/src/NetworkManagerUtils.h
@@ -67,6 +67,10 @@ void        value_hash_add_uint        (GHashTable *hash,
 										const char *key,
 										guint32 val);
 
+void        value_hash_add_bool        (GHashTable *hash,
+					                    const char *key,
+					                    gboolean val);
+
 gboolean nm_utils_do_sysctl (const char *path, const char *value);
 
 #endif /* NETWORK_MANAGER_UTILS_H */
diff --git a/src/backends/Makefile.am b/src/backends/Makefile.am
index 0e037c4..c3485e5 100644
--- a/src/backends/Makefile.am
+++ b/src/backends/Makefile.am
@@ -1,9 +1,11 @@
-INCLUDES = -I${top_srcdir}				\
-		 -I${top_srcdir}/include			\
-		 -I${top_srcdir}/src			\
-		 -I${top_srcdir}/src/vpn-manager	\
-		 -I${top_srcdir}/src/named-manager	\
-		 -I${top_srcdir}/libnm-util
+INCLUDES = \
+	-I${top_srcdir} \
+	-I${top_srcdir}/src/logging \
+	-I${top_srcdir}/include \
+	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/vpn-manager \
+	-I${top_srcdir}/src/named-manager \
+	-I${top_srcdir}/libnm-util
 
 noinst_LTLIBRARIES = libnmbackend.la
 
@@ -53,7 +55,11 @@ if TARGET_PARDUS
 libnmbackend_la_SOURCES += NetworkManagerPardus.c
 endif
 
-libnmbackend_la_LIBADD += $(DBUS_LIBS) $(GLIB_LIBS)
+libnmbackend_la_LIBADD += \
+	$(top_builddir)/src/logging/libnm-logging.la \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS)
+
 libnmbackend_la_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
 	$(GLIB_CFLAGS) \
diff --git a/src/backends/NetworkManagerArch.c b/src/backends/NetworkManagerArch.c
index 3ed5677..c70e245 100644
--- a/src/backends/NetworkManagerArch.c
+++ b/src/backends/NetworkManagerArch.c
@@ -40,7 +40,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 /*
diff --git a/src/backends/NetworkManagerDebian.c b/src/backends/NetworkManagerDebian.c
index 2f6abd1..ef9475a 100644
--- a/src/backends/NetworkManagerDebian.c
+++ b/src/backends/NetworkManagerDebian.c
@@ -32,9 +32,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -57,7 +57,7 @@ void nm_system_enable_loopback (void)
 void nm_system_update_dns (void)
 {
 	if (g_file_test ("/usr/sbin/nscd", G_FILE_TEST_IS_EXECUTABLE)) {
-		nm_info ("Clearing nscd hosts cache.");
+		nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
 		nm_spawn_process ("/usr/sbin/nscd -i hosts");
 	}
 }
diff --git a/src/backends/NetworkManagerFrugalware.c b/src/backends/NetworkManagerFrugalware.c
index 492bf19..dfe6292 100644
--- a/src/backends/NetworkManagerFrugalware.c
+++ b/src/backends/NetworkManagerFrugalware.c
@@ -27,7 +27,7 @@
 #include <string.h>
 #include <stdlib.h>
 
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 /* Provided by the frugalwareutils package on Frugalware */
 #include <libfwnetconfig.h> 
diff --git a/src/backends/NetworkManagerGeneric.c b/src/backends/NetworkManagerGeneric.c
index 7984f2c..4f8336d 100644
--- a/src/backends/NetworkManagerGeneric.c
+++ b/src/backends/NetworkManagerGeneric.c
@@ -1,3 +1,4 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /* NetworkManager -- Network link manager
  *
  * Timothee Lecomte <timothee.lecomte@ens.fr>
@@ -33,10 +34,10 @@
 #include <string.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 #include "nm-netlink.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /* Because of a bug in libnl, rtnl.h should be included before route.h */
 #include <netlink/route/rtnl.h>
@@ -93,8 +94,9 @@ void nm_generic_enable_loopback (void)
 	rtnl_addr_set_label (addr, "lo");
 
 	if ((err = rtnl_addr_add (nlh, addr, 0)) < 0) {
-		if (err != -EEXIST)
-			nm_warning ("error %d returned from rtnl_addr_add():\n%s", err, nl_geterror());
+		if (err != -EEXIST) {
+			nm_log_warn (LOGD_CORE, "error %d returned from rtnl_addr_add():\n%s", err, nl_geterror());
+		}
 	}
 out:
 	if (addr)
diff --git a/src/backends/NetworkManagerGentoo.c b/src/backends/NetworkManagerGentoo.c
index 7fa1207..8d9e68c 100644
--- a/src/backends/NetworkManagerGentoo.c
+++ b/src/backends/NetworkManagerGentoo.c
@@ -32,8 +32,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -57,11 +58,9 @@ void nm_system_enable_loopback (void)
  */
 void nm_system_update_dns (void)
 {
- #ifdef NM_NO_NAMED
-	if (nm_spawn_process ("/etc/init.d/nscd status") == 0)
-		nm_spawn_process ("/etc/init.d/nscd restart");
- #else
-	nm_spawn_process("/usr/bin/killall -q nscd");
- #endif
+	if (g_file_test ("/usr/sbin/nscd", G_FILE_TEST_IS_EXECUTABLE)) {
+		nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
+		nm_spawn_process ("/usr/sbin/nscd -i hosts");
+	}
 }
 
diff --git a/src/backends/NetworkManagerMandriva.c b/src/backends/NetworkManagerMandriva.c
index 527a25d..8209ff4 100644
--- a/src/backends/NetworkManagerMandriva.c
+++ b/src/backends/NetworkManagerMandriva.c
@@ -30,7 +30,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 /*
diff --git a/src/backends/NetworkManagerPaldo.c b/src/backends/NetworkManagerPaldo.c
index 0147a3b..0c67e5b 100644
--- a/src/backends/NetworkManagerPaldo.c
+++ b/src/backends/NetworkManagerPaldo.c
@@ -31,9 +31,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -55,7 +55,7 @@ void nm_system_enable_loopback (void)
  */
 void nm_system_update_dns (void)
 {
-	nm_info ("Clearing nscd hosts cache.");
+	nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
 	nm_spawn_process ("/usr/sbin/nscd -i hosts");
 }
 
diff --git a/src/backends/NetworkManagerPardus.c b/src/backends/NetworkManagerPardus.c
index 52703e2..d952cf3 100644
--- a/src/backends/NetworkManagerPardus.c
+++ b/src/backends/NetworkManagerPardus.c
@@ -29,7 +29,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 /*
  * nm_system_enable_loopback
diff --git a/src/backends/NetworkManagerRedHat.c b/src/backends/NetworkManagerRedHat.c
index 1e3f7e9..954e58a 100644
--- a/src/backends/NetworkManagerRedHat.c
+++ b/src/backends/NetworkManagerRedHat.c
@@ -28,7 +28,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 /*
diff --git a/src/backends/NetworkManagerSlackware.c b/src/backends/NetworkManagerSlackware.c
index 8d7c5bf..a35e1bb 100644
--- a/src/backends/NetworkManagerSlackware.c
+++ b/src/backends/NetworkManagerSlackware.c
@@ -29,7 +29,7 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 /*
  * nm_system_enable_loopback
diff --git a/src/backends/NetworkManagerSuSE.c b/src/backends/NetworkManagerSuSE.c
index a0cd1cb..6c8ec1a 100644
--- a/src/backends/NetworkManagerSuSE.c
+++ b/src/backends/NetworkManagerSuSE.c
@@ -32,9 +32,9 @@
 #include <stdlib.h>
 
 #include "NetworkManagerGeneric.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /*
  * nm_system_enable_loopback
@@ -56,7 +56,7 @@ void nm_system_enable_loopback (void)
  */
 void nm_system_update_dns (void)
 {
-	nm_info ("Clearing nscd hosts cache.");
+	nm_log_info (LOGD_DNS, "Clearing nscd hosts cache.");
 	nm_spawn_process ("/usr/sbin/nscd -i hosts");
 }
 
diff --git a/src/bluez-manager/Makefile.am b/src/bluez-manager/Makefile.am
index a96cbe8..6c199e8 100644
--- a/src/bluez-manager/Makefile.am
+++ b/src/bluez-manager/Makefile.am
@@ -3,6 +3,7 @@ INCLUDES = \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_builddir}/marshallers \
 	-I$(top_srcdir)/src/nm-bluez-manager
 
@@ -30,6 +31,7 @@ libbluez_manager_la_CPPFLAGS = \
 
 libbluez_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS) \
 	$(BLUEZ_LIBS)
diff --git a/src/bluez-manager/nm-bluez-adapter.c b/src/bluez-manager/nm-bluez-adapter.c
index ba8f711..27a85e7 100644
--- a/src/bluez-manager/nm-bluez-adapter.c
+++ b/src/bluez-manager/nm-bluez-adapter.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <glib.h>
@@ -27,7 +27,7 @@
 #include "nm-bluez-device.h"
 #include "nm-bluez-common.h"
 #include "nm-dbus-glib-types.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 
 G_DEFINE_TYPE (NMBluezAdapter, nm_bluez_adapter, G_TYPE_OBJECT)
@@ -175,8 +175,8 @@ get_properties_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call, &err,
 	                            DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("bluez error getting adapter properties: %s",
-		            err && err->message ? err->message : "(unknown)");
+		nm_log_warn (LOGD_BT, "bluez error getting adapter properties: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		goto done;
 	}
@@ -209,8 +209,8 @@ query_properties (NMBluezAdapter *self)
 	                                self,
 	                                NULL, G_TYPE_INVALID);
 	if (!call) {
-		nm_warning ("failed to request Bluetooth adapter properties for %s.",
-		            priv->path);
+		nm_log_warn (LOGD_BT, "failed to request Bluetooth adapter properties for %s.",
+		             priv->path);
 	}
 }
 
diff --git a/src/bluez-manager/nm-bluez-device.c b/src/bluez-manager/nm-bluez-device.c
index 6ecd6b4..72acaa6 100644
--- a/src/bluez-manager/nm-bluez-device.c
+++ b/src/bluez-manager/nm-bluez-device.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <glib.h>
@@ -26,7 +26,7 @@
 #include "nm-bluez-device.h"
 #include "nm-bluez-common.h"
 #include "nm-dbus-glib-types.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 
 
@@ -228,8 +228,8 @@ get_properties_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call, &err,
 	                            DBUS_TYPE_G_MAP_OF_VARIANT, &properties,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("bluez error getting device properties: %s",
-		            err && err->message ? err->message : "(unknown)");
+		nm_log_warn (LOGD_BT, "bluez error getting device properties: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		g_signal_emit (self, signals[INITIALIZED], 0, FALSE);
 		return;
@@ -270,8 +270,8 @@ query_properties (NMBluezDevice *self)
 	                                self,
 	                                NULL, G_TYPE_INVALID);
 	if (!call) {
-		nm_warning ("failed to request Bluetooth device properties for %s.",
-		            priv->path);
+		nm_log_warn (LOGD_BT, "failed to request Bluetooth device properties for %s.",
+		             priv->path);
 	}
 }
 
diff --git a/src/bluez-manager/nm-bluez-manager.c b/src/bluez-manager/nm-bluez-manager.c
index 96cb3e7..fe027c4 100644
--- a/src/bluez-manager/nm-bluez-manager.c
+++ b/src/bluez-manager/nm-bluez-manager.c
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2008 Novell, Inc.
- * Copyright (C) 2007 - 2009 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <signal.h>
@@ -24,7 +24,7 @@
 #include <stdlib.h>
 #include <dbus/dbus-glib.h>
 
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-dbus-glib-types.h"
 #include "nm-marshal.h"
 #include "nm-bluez-manager.h"
@@ -181,8 +181,8 @@ default_adapter_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call, &err,
 	                            DBUS_TYPE_G_OBJECT_PATH, &default_adapter,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("bluez error getting default adapter: %s",
-		            err && err->message ? err->message : "(unknown)");
+		nm_log_warn (LOGD_BT, "bluez error getting default adapter: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		return;
 	}
@@ -201,7 +201,7 @@ query_default_adapter (NMBluezManager *self)
 	                                self,
 	                                NULL, G_TYPE_INVALID);
 	if (!call)
-		nm_warning ("failed to request default Bluetooth adapter.");
+		nm_log_warn (LOGD_BT, "failed to request default Bluetooth adapter.");
 }
 
 static void
diff --git a/src/dhcp-manager/Makefile.am b/src/dhcp-manager/Makefile.am
index b7b0c65..f75e6b3 100644
--- a/src/dhcp-manager/Makefile.am
+++ b/src/dhcp-manager/Makefile.am
@@ -2,6 +2,7 @@ INCLUDES = \
 	-I${top_srcdir} \
 	-I${top_srcdir}/include \
 	-I${top_builddir}/marshallers \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/libnm-util \
 	-I${top_srcdir}/src \
 	-I${top_srcdir}/src/named-manager
@@ -9,9 +10,14 @@ INCLUDES = \
 noinst_LTLIBRARIES = libdhcp-manager.la
 
 libdhcp_manager_la_SOURCES = \
+	nm-dhcp-client.c \
+	nm-dhcp-client.h \
 	nm-dhcp-manager.c \
 	nm-dhcp-manager.h \
-	nm-dhcp-@DHCP_CLIENT@.c
+	nm-dhcp-dhclient.h \
+	nm-dhcp-dhclient.c \
+	nm-dhcp-dhcpcd.h \
+	nm-dhcp-dhcpcd.c
 
 libdhcp_manager_la_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
@@ -22,13 +28,12 @@ libdhcp_manager_la_CPPFLAGS = \
 	-DSYSCONFDIR=\"$(sysconfdir)\" \
 	-DLIBEXECDIR=\"$(libexecdir)\" \
 	-DLOCALSTATEDIR=\"$(localstatedir)\" \
-	-DDHCP_CLIENT_PATH=\"$(DHCP_CLIENT_PATH)\"
+	-DDHCLIENT_PATH=\"$(DHCLIENT_PATH)\" \
+	-DDHCPCD_PATH=\"$(DHCPCD_PATH)\"
 
 libdhcp_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
 
-EXTRA_DIST = \
-	     nm-dhcp-dhclient.c \
-	     nm-dhcp-dhcpcd.c
diff --git a/src/dhcp-manager/nm-dhcp-client.c b/src/dhcp-manager/nm-dhcp-client.c
new file mode 100644
index 0000000..888e7c5
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-client.c
@@ -0,0 +1,1132 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ *
+ */
+
+#include <glib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+
+#include "nm-utils.h"
+#include "nm-logging.h"
+#include "nm-dbus-glib-types.h"
+#include "nm-dhcp-client.h"
+
+typedef struct {
+	char *       iface;
+	gboolean     ipv6;
+	char *       uuid;
+	guint32      timeout;
+
+	guchar       state;
+	GPid         pid;
+	guint        timeout_id;
+	guint        watch_id;
+	GHashTable * options;
+} NMDHCPClientPrivate;
+
+#define NM_DHCP_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_CLIENT, NMDHCPClientPrivate))
+
+G_DEFINE_TYPE_EXTENDED (NMDHCPClient, nm_dhcp_client, G_TYPE_OBJECT, G_TYPE_FLAG_ABSTRACT, {})
+
+enum {
+	STATE_CHANGED,
+	TIMEOUT,
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum {
+	PROP_0,
+	PROP_IFACE,
+	PROP_IPV6,
+	PROP_UUID,
+	PROP_TIMEOUT,
+	LAST_PROP
+};
+
+/********************************************/
+
+GPid
+nm_dhcp_client_get_pid (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, -1);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), -1);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->pid;
+}
+
+const char *
+nm_dhcp_client_get_iface (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->iface;
+}
+
+gboolean
+nm_dhcp_client_get_ipv6 (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->ipv6;
+}
+
+const char *
+nm_dhcp_client_get_uuid (NMDHCPClient *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	return NM_DHCP_CLIENT_GET_PRIVATE (self)->uuid;
+}
+
+/********************************************/
+
+static void
+timeout_cleanup (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+}
+
+static void
+watch_cleanup (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (priv->watch_id) {
+		g_source_remove (priv->watch_id);
+		priv->watch_id = 0;
+	}
+}
+
+static void
+stop_process (GPid pid, const char *iface)
+{
+	int i = 15; /* 3 seconds */
+
+	g_return_if_fail (pid > 0);
+
+	/* Tell it to quit; maybe it wants to send out a RELEASE message */
+	kill (pid, SIGTERM);
+
+	while (i-- > 0) {
+		gint child_status;
+		int ret;
+
+		ret = waitpid (pid, &child_status, WNOHANG);
+		if (ret > 0)
+			break;
+
+		if (ret == -1) {
+			/* Child already exited */
+			if (errno == ECHILD)
+				break;
+			/* Took too long; shoot it in the head */
+			i = 0;
+			break;
+		}
+		g_usleep (G_USEC_PER_SEC / 5);
+	}
+
+	if (i <= 0) {
+		if (iface) {
+			nm_log_warn (LOGD_DHCP, "(%s): DHCP client pid %d didn't exit, will kill it.",
+			             iface, pid);
+		}
+		kill (pid, SIGKILL);
+
+		nm_log_dbg (LOGD_DHCP, "waiting for DHCP client pid %d to exit", pid);
+		waitpid (pid, NULL, 0);
+		nm_log_dbg (LOGD_DHCP, "DHCP client pid %d cleaned up", pid);
+	}
+}
+
+static void
+real_stop (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DHCP_CLIENT (self));
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_if_fail (priv->pid > 0);
+
+	/* Clean up the watch handler since we're explicitly killing the daemon */
+	watch_cleanup (self);
+
+	stop_process (priv->pid, priv->iface);
+}
+
+static gboolean
+daemon_timeout (gpointer user_data)
+{
+	NMDHCPClient *self = NM_DHCP_CLIENT (user_data);
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (priv->ipv6) {
+		nm_log_warn (LOGD_DHCP6, "(%s): DHCPv6 request timed out.", priv->iface);
+	} else {
+		nm_log_warn (LOGD_DHCP4, "(%s): DHCPv4 request timed out.", priv->iface);
+	}
+	g_signal_emit (G_OBJECT (self), signals[TIMEOUT], 0);
+	return FALSE;
+}
+
+static void
+daemon_watch_cb (GPid pid, gint status, gpointer user_data)
+{
+	NMDHCPClient *self = NM_DHCP_CLIENT (user_data);
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (!WIFEXITED (status)) {
+		priv->state = DHC_ABEND;
+		nm_log_warn (LOGD_DHCP, "DHCP client died abnormally");
+	}
+	priv->pid = 0;
+
+	watch_cleanup (self);
+	timeout_cleanup (self);
+
+	g_signal_emit (G_OBJECT (self), signals[STATE_CHANGED], 0, priv->state);
+}
+
+static void
+start_monitor (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	g_return_if_fail (priv->pid > 0);
+
+	/* Set up a timeout on the transaction to kill it after the timeout */
+	priv->timeout_id = g_timeout_add_seconds (priv->timeout,
+	                                          daemon_timeout,
+	                                          self);
+	priv->watch_id = g_child_watch_add (priv->pid,
+	                                    (GChildWatchFunc) daemon_watch_cb,
+	                                    self);
+}
+
+gboolean
+nm_dhcp_client_start_ip4 (NMDHCPClient *self,
+                          NMSettingIP4Config *s_ip4,
+                          guint8 *dhcp_anycast_addr)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->pid == -1, FALSE);
+	g_return_val_if_fail (priv->ipv6 == FALSE, FALSE);
+	g_return_val_if_fail (priv->uuid != NULL, FALSE);
+
+	nm_log_info (LOGD_DHCP, "Activation (%s) Beginning DHCPv4 transaction (timeout in %d seconds)",
+	             priv->iface, priv->timeout);
+
+	priv->pid = NM_DHCP_CLIENT_GET_CLASS (self)->ip4_start (self, s_ip4, dhcp_anycast_addr);
+	if (priv->pid)
+		start_monitor (self);
+
+	return priv->pid ? TRUE : FALSE;
+}
+
+gboolean
+nm_dhcp_client_start_ip6 (NMDHCPClient *self,
+                          NMSettingIP6Config *s_ip6,
+                          guint8 *dhcp_anycast_addr,
+                          gboolean info_only)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->pid == -1, FALSE);
+	g_return_val_if_fail (priv->ipv6 == TRUE, FALSE);
+	g_return_val_if_fail (priv->uuid != NULL, FALSE);
+
+	nm_log_info (LOGD_DHCP, "Activation (%s) Beginning DHCPv6 transaction (timeout in %d seconds)",
+	             priv->iface, priv->timeout);
+
+	priv->pid = NM_DHCP_CLIENT_GET_CLASS (self)->ip6_start (self, s_ip6, dhcp_anycast_addr, info_only);
+	if (priv->pid > 0)
+		start_monitor (self);
+
+	return priv->pid ? TRUE : FALSE;
+}
+
+void
+nm_dhcp_client_stop_existing (const char *pid_file, const char *binary_name)
+{
+	char *pid_contents = NULL, *proc_contents = NULL, *proc_path = NULL;
+	long int tmp;
+
+	/* Check for an existing instance and stop it */
+	if (!g_file_get_contents (pid_file, &pid_contents, NULL, NULL))
+		return;
+
+	errno = 0;
+	tmp = strtol (pid_contents, NULL, 10);
+	if ((errno == 0) && (tmp > 1)) {
+		const char *exe;
+
+		/* Ensure the process is a DHCP client */
+		proc_path = g_strdup_printf ("/proc/%ld/cmdline", tmp);
+		if (g_file_get_contents (proc_path, &proc_contents, NULL, NULL)) {
+			exe = strrchr (proc_contents, '/');
+			if (exe)
+				exe++;
+			else
+				exe = proc_contents;
+
+			if (!strcmp (exe, binary_name))
+				stop_process ((GPid) tmp, NULL);
+		}
+	}
+
+	remove (pid_file);
+	g_free (proc_path);
+	g_free (pid_contents);
+	g_free (proc_contents);
+}
+
+void
+nm_dhcp_client_stop (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DHCP_CLIENT (self));
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	/* Kill the DHCP client */
+	if (priv->pid > 0) {
+		NM_DHCP_CLIENT_GET_CLASS (self)->stop (self);
+
+		nm_log_info (LOGD_DHCP, "(%s): canceled DHCP transaction, DHCP client pid %d",
+		             priv->iface, priv->pid);
+	}
+
+	/* And clean stuff up */
+
+	priv->pid = -1;
+	priv->state = DHC_END;
+
+	g_hash_table_remove_all (priv->options);
+
+	timeout_cleanup (self);
+	watch_cleanup (self);
+}
+
+/********************************************/
+
+static gboolean
+state_is_bound (guint32 state)
+{
+	if (   (state == DHC_BOUND4)
+	    || (state == DHC_BOUND6)
+	    || (state == DHC_RENEW4)
+	    || (state == DHC_RENEW6)
+	    || (state == DHC_REBOOT)
+	    || (state == DHC_REBIND4)
+	    || (state == DHC_REBIND6)
+	    || (state == DHC_IPV4LL))
+		return TRUE;
+
+	return FALSE;
+}
+
+typedef struct {
+	NMDHCPState state;
+	const char *name;
+} DhcState;
+
+#define STATE_TABLE_SIZE (sizeof (state_table) / sizeof (state_table[0]))
+
+static DhcState state_table[] = {
+	{ DHC_NBI,     "nbi" },
+	{ DHC_PREINIT, "preinit" },
+	{ DHC_PREINIT6,"preinit6" },
+	{ DHC_BOUND4,  "bound" },
+	{ DHC_BOUND6,  "bound6" },
+	{ DHC_IPV4LL,  "ipv4ll" },
+	{ DHC_RENEW4,  "renew" },
+	{ DHC_RENEW6,  "renew6" },
+	{ DHC_REBOOT,  "reboot" },
+	{ DHC_REBIND4, "rebind" },
+	{ DHC_REBIND6, "rebind6" },
+	{ DHC_STOP,    "stop" },
+	{ DHC_MEDIUM,  "medium" },
+	{ DHC_TIMEOUT, "timeout" },
+	{ DHC_FAIL,    "fail" },
+	{ DHC_EXPIRE,  "expire" },
+	{ DHC_RELEASE, "release" },
+	{ DHC_START,   "start" },
+	{ DHC_ABEND,   "abend" },
+	{ DHC_END,     "end" },
+	{ DHC_DEPREF6, "depref6" },
+};
+
+static inline const char *
+state_to_string (guint32 state)
+{
+	int i;
+
+	for (i = 0; i < STATE_TABLE_SIZE; i++) {
+		if (state == state_table[i].state)
+			return state_table[i].name;
+	}
+
+	return NULL;
+}
+
+static inline NMDHCPState
+string_to_state (const char *name)
+{
+	int i;
+
+	for (i = 0; i < STATE_TABLE_SIZE; i++) {
+		if (!strcasecmp (name, state_table[i].name))
+			return state_table[i].state;
+	}
+
+	return 255;
+}
+
+static char *
+garray_to_string (GArray *array, const char *key)
+{
+	GString *str;
+	int i;
+	unsigned char c;
+	char *converted = NULL;
+
+	g_return_val_if_fail (array != NULL, NULL);
+
+	/* Since the DHCP options come through environment variables, they should
+	 * already be UTF-8 safe, but just make sure.
+	 */
+	str = g_string_sized_new (array->len);
+	for (i = 0; i < array->len; i++) {
+		c = array->data[i];
+
+		/* Convert NULLs to spaces and non-ASCII characters to ? */
+		if (c == '\0')
+			c = ' ';
+		else if (c > 127)
+			c = '?';
+		str = g_string_append_c (str, c);
+	}
+	str = g_string_append_c (str, '\0');
+
+	converted = str->str;
+	if (!g_utf8_validate (converted, -1, NULL))
+		nm_log_warn (LOGD_DHCP, "DHCP option '%s' couldn't be converted to UTF-8", key);
+	g_string_free (str, FALSE);
+	return converted;
+}
+
+static void
+copy_option (gpointer key,
+             gpointer value,
+             gpointer user_data)
+{
+	GHashTable *hash = user_data;
+	const char *str_key = (const char *) key;
+	char *str_value = NULL;
+
+	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
+		nm_log_warn (LOGD_DHCP, "unexpected key %s value type was not "
+		             "DBUS_TYPE_G_UCHAR_ARRAY",
+		             str_key);
+		return;
+	}
+
+	str_value = garray_to_string ((GArray *) g_value_get_boxed (value), str_key);
+	if (str_value)
+		g_hash_table_insert (hash, g_strdup (str_key), str_value);
+}
+
+void
+nm_dhcp_client_new_options (NMDHCPClient *self,
+                            GHashTable *options,
+                            const char *reason)
+{
+	NMDHCPClientPrivate *priv;
+	guint32 old_state;
+	guint32 new_state;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DHCP_CLIENT (self));
+	g_return_if_fail (options != NULL);
+	g_return_if_fail (reason != NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	old_state = priv->state;
+	new_state = string_to_state (reason);
+
+	/* Clear old and save new DHCP options */
+	g_hash_table_remove_all (priv->options);
+	g_hash_table_foreach (options, copy_option, priv->options);
+
+	if (old_state == new_state)
+		return;
+
+	/* Handle changed device state */
+	if (state_is_bound (new_state)) {
+		/* Cancel the timeout if the DHCP client is now bound */
+		timeout_cleanup (self);
+	}
+
+	priv->state = new_state;
+	if (priv->ipv6) {
+		nm_log_info (LOGD_DHCP6, "(%s): DHCPv6 state changed %s -> %s",
+		            priv->iface,
+		            state_to_string (old_state),
+		            state_to_string (priv->state));
+	} else {
+		nm_log_info (LOGD_DHCP4, "(%s): DHCPv4 state changed %s -> %s",
+		            priv->iface,
+		            state_to_string (old_state),
+		            state_to_string (priv->state));
+	}
+
+	g_signal_emit (G_OBJECT (self),
+	               signals[STATE_CHANGED],
+	               0,
+	               priv->state);
+}
+
+#define NEW_TAG "new_"
+#define OLD_TAG "old_"
+
+typedef struct {
+	GHFunc func;
+	gpointer user_data;
+} DhcpForeachInfo;
+
+static void
+iterate_dhcp_config_option (gpointer key,
+                            gpointer value,
+                            gpointer user_data)
+{
+	DhcpForeachInfo *info = (DhcpForeachInfo *) user_data;
+	char *tmp_key = NULL;
+	const char **p;
+	static const char *filter_options[] = {
+		"interface", "pid", "reason", "dhcp_message_type", NULL
+	};
+	
+	/* Filter out stuff that's not actually new DHCP options */
+	for (p = filter_options; *p; p++) {
+		if (!strcmp (*p, (const char *) key))
+			return;
+		if (!strncmp ((const char *) key, OLD_TAG, strlen (OLD_TAG)))
+			return;
+	}
+
+	/* Remove the "new_" prefix that dhclient passes back */
+	if (!strncmp ((const char *) key, NEW_TAG, strlen (NEW_TAG)))
+		tmp_key = g_strdup ((const char *) (key + strlen (NEW_TAG)));
+	else
+		tmp_key = g_strdup ((const char *) key);
+
+	(*info->func) ((gpointer) tmp_key, value, info->user_data);
+	g_free (tmp_key);
+}
+
+gboolean
+nm_dhcp_client_foreach_option (NMDHCPClient *self,
+                               GHFunc func,
+                               gpointer user_data)
+{
+	NMDHCPClientPrivate *priv;
+	DhcpForeachInfo info = { NULL, NULL };
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), FALSE);
+	g_return_val_if_fail (func != NULL, FALSE);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (!state_is_bound (priv->state)) {
+		if (priv->ipv6) {
+			nm_log_warn (LOGD_DHCP6, "(%s): DHCPv6 client didn't bind to a lease.", priv->iface);
+		} else {
+			nm_log_warn (LOGD_DHCP4, "(%s): DHCPv4 client didn't bind to a lease.", priv->iface);
+		}
+		return FALSE;
+	}
+
+	info.func = func;
+	info.user_data = user_data;
+	g_hash_table_foreach (priv->options, iterate_dhcp_config_option, &info);
+	return TRUE;
+}
+
+/********************************************/
+
+static void
+process_classful_routes (GHashTable *options, NMIP4Config *ip4_config)
+{
+	const char *str;
+	char **searches, **s;
+
+	str = g_hash_table_lookup (options, "new_static_routes");
+	if (!str)
+		return;
+
+	searches = g_strsplit (str, " ", 0);
+	if ((g_strv_length (searches) % 2)) {
+		nm_log_info (LOGD_DHCP, "  static routes provided, but invalid");
+		goto out;
+	}
+
+	for (s = searches; *s; s += 2) {
+		NMIP4Route *route;
+		struct in_addr rt_addr;
+		struct in_addr rt_route;
+
+		if (inet_pton (AF_INET, *s, &rt_addr) <= 0) {
+			nm_log_warn (LOGD_DHCP, "DHCP provided invalid static route address: '%s'", *s);
+			continue;
+		}
+		if (inet_pton (AF_INET, *(s + 1), &rt_route) <= 0) {
+			nm_log_warn (LOGD_DHCP, "DHCP provided invalid static route gateway: '%s'", *(s + 1));
+			continue;
+		}
+
+		// FIXME: ensure the IP addresse and route are sane
+
+		route = nm_ip4_route_new ();
+		nm_ip4_route_set_dest (route, (guint32) rt_addr.s_addr);
+		nm_ip4_route_set_prefix (route, 32); /* 255.255.255.255 */
+		nm_ip4_route_set_next_hop (route, (guint32) rt_route.s_addr);
+
+		nm_ip4_config_take_route (ip4_config, route);
+		nm_log_info (LOGD_DHCP, "  static route %s gw %s", *s, *(s + 1));
+	}
+
+out:
+	g_strfreev (searches);
+}
+
+static void
+process_domain_search (const char *str, GFunc add_func, gpointer user_data)
+{
+	char **searches, **s;
+	char *unescaped, *p;
+	int i;
+
+	g_return_if_fail (str != NULL);
+	g_return_if_fail (add_func != NULL);
+
+	p = unescaped = g_strdup (str);
+	do {
+		p = strstr (p, "\\032");
+		if (!p)
+			break;
+
+		/* Clear the escaped space with real spaces */
+		for (i = 0; i < 4; i++)
+			*p++ = ' ';
+	} while (*p++);
+
+	if (strchr (unescaped, '\\')) {
+		nm_log_warn (LOGD_DHCP, "  invalid domain search: '%s'", unescaped);
+		goto out;
+	}
+
+	searches = g_strsplit (unescaped, " ", 0);
+	for (s = searches; *s; s++) {
+		if (strlen (*s)) {
+			nm_log_info (LOGD_DHCP, "  domain search '%s'", *s);
+			add_func (*s, user_data);
+		}
+	}
+	g_strfreev (searches);
+
+out:
+	g_free (unescaped);
+}
+
+static void
+ip4_add_domain_search (gpointer data, gpointer user_data)
+{
+	nm_ip4_config_add_search (NM_IP4_CONFIG (user_data), (const char *) data);
+}
+
+/* Given a table of DHCP options from the client, convert into an IP4Config */
+static NMIP4Config *
+ip4_options_to_config (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+	NMIP4Config *ip4_config = NULL;
+	struct in_addr tmp_addr;
+	NMIP4Address *addr = NULL;
+	char *str = NULL;
+	guint32 gwaddr = 0, prefix = 0;
+	gboolean have_classless = FALSE;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->options != NULL, NULL);
+
+	ip4_config = nm_ip4_config_new ();
+	if (!ip4_config) {
+		nm_log_warn (LOGD_DHCP4, "(%s): couldn't allocate memory for an IP4Config!", priv->iface);
+		return NULL;
+	}
+
+	addr = nm_ip4_address_new ();
+	if (!addr) {
+		nm_log_warn (LOGD_DHCP4, "(%s): couldn't allocate memory for an IP4 Address!", priv->iface);
+		goto error;
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_ip_address");
+	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
+		nm_ip4_address_set_address (addr, tmp_addr.s_addr);
+		nm_log_info (LOGD_DHCP4, "  address %s", str);
+	} else
+		goto error;
+
+	str = g_hash_table_lookup (priv->options, "new_subnet_mask");
+	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
+		prefix = nm_utils_ip4_netmask_to_prefix (tmp_addr.s_addr);
+		nm_log_info (LOGD_DHCP4, "  prefix %d (%s)", prefix, str);
+	} else {
+		/* Get default netmask for the IP according to appropriate class. */
+		prefix = nm_utils_ip4_get_default_prefix (nm_ip4_address_get_address (addr));
+		nm_log_info (LOGD_DHCP4, "  prefix %d (default)", prefix);
+	}
+	nm_ip4_address_set_prefix (addr, prefix);
+
+	/* Routes: if the server returns classless static routes, we MUST ignore
+	 * the 'static_routes' option.
+	 */
+	if (NM_DHCP_CLIENT_GET_CLASS (self)->ip4_process_classless_routes) {
+		have_classless = NM_DHCP_CLIENT_GET_CLASS (self)->ip4_process_classless_routes (self,
+		                                                                                priv->options,
+		                                                                                ip4_config,
+		                                                                                &gwaddr);
+	}
+
+	if (!have_classless) {
+		gwaddr = 0;  /* Ensure client code doesn't lie */
+		process_classful_routes (priv->options, ip4_config);
+	}
+
+	if (gwaddr) {
+		char buf[INET_ADDRSTRLEN + 1];
+
+		inet_ntop (AF_INET, &gwaddr, buf, sizeof (buf));
+		nm_log_info (LOGD_DHCP4, "  gateway %s", buf);
+		nm_ip4_address_set_gateway (addr, gwaddr);
+	} else {
+		/* If the gateway wasn't provided as a classless static route with a
+		 * subnet length of 0, try to find it using the old-style 'routers' option.
+		 */
+		str = g_hash_table_lookup (priv->options, "new_routers");
+		if (str) {
+			char **routers = g_strsplit (str, " ", 0);
+			char **s;
+
+			for (s = routers; *s; s++) {
+				/* FIXME: how to handle multiple routers? */
+				if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
+					nm_ip4_address_set_gateway (addr, tmp_addr.s_addr);
+					nm_log_info (LOGD_DHCP4, "  gateway %s", *s);
+					break;
+				} else
+					nm_log_warn (LOGD_DHCP4, "ignoring invalid gateway '%s'", *s);
+			}
+			g_strfreev (routers);
+		}
+	}
+
+	nm_ip4_config_take_address (ip4_config, addr);
+	addr = NULL;
+
+	str = g_hash_table_lookup (priv->options, "new_host_name");
+	if (str)
+		nm_log_info (LOGD_DHCP4, "  hostname '%s'", str);
+
+	str = g_hash_table_lookup (priv->options, "new_domain_name_servers");
+	if (str) {
+		char **searches = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = searches; *s; s++) {
+			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
+				nm_ip4_config_add_nameserver (ip4_config, tmp_addr.s_addr);
+				nm_log_info (LOGD_DHCP4, "  nameserver '%s'", *s);
+			} else
+				nm_log_warn (LOGD_DHCP4, "ignoring invalid nameserver '%s'", *s);
+		}
+		g_strfreev (searches);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_domain_name");
+	if (str) {
+		char **domains = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = domains; *s; s++) {
+			nm_log_info (LOGD_DHCP4, "  domain name '%s'", *s);
+			nm_ip4_config_add_domain (ip4_config, *s);
+		}
+		g_strfreev (domains);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_domain_search");
+	if (str)
+		process_domain_search (str, ip4_add_domain_search, ip4_config);
+
+	str = g_hash_table_lookup (priv->options, "new_netbios_name_servers");
+	if (str) {
+		char **searches = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = searches; *s; s++) {
+			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
+				nm_ip4_config_add_wins (ip4_config, tmp_addr.s_addr);
+				nm_log_info (LOGD_DHCP4, "  wins '%s'", *s);
+			} else
+				nm_log_warn (LOGD_DHCP4, "ignoring invalid WINS server '%s'", *s);
+		}
+		g_strfreev (searches);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_interface_mtu");
+	if (str) {
+		int int_mtu;
+
+		errno = 0;
+		int_mtu = strtol (str, NULL, 10);
+		if ((errno == EINVAL) || (errno == ERANGE))
+			goto error;
+
+		if (int_mtu > 576)
+			nm_ip4_config_set_mtu (ip4_config, int_mtu);
+	}
+
+	return ip4_config;
+
+error:
+	if (addr)
+		nm_ip4_address_unref (addr);
+	g_object_unref (ip4_config);
+	return NULL;
+}
+
+NMIP4Config *
+nm_dhcp_client_get_ip4_config (NMDHCPClient *self, gboolean test)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (test && !state_is_bound (priv->state)) {
+		nm_log_warn (LOGD_DHCP4, "(%s): DHCP client didn't bind to a lease.", priv->iface);
+		return NULL;
+	}
+
+	return ip4_options_to_config (self);
+}
+
+/********************************************/
+
+static void
+ip6_add_domain_search (gpointer data, gpointer user_data)
+{
+	nm_ip6_config_add_search (NM_IP6_CONFIG (user_data), (const char *) data);
+}
+
+/* Given a table of DHCP options from the client, convert into an IP6Config */
+static NMIP6Config *
+ip6_options_to_config (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv;
+	NMIP6Config *ip6_config = NULL;
+	struct in6_addr tmp_addr;
+	NMIP6Address *addr = NULL;
+	char *str = NULL;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+	g_return_val_if_fail (priv->options != NULL, NULL);
+
+	ip6_config = nm_ip6_config_new ();
+	if (!ip6_config) {
+		nm_log_warn (LOGD_DHCP6, "(%s): couldn't allocate memory for an IP6Config!", priv->iface);
+		return NULL;
+	}
+
+	addr = nm_ip6_address_new ();
+	if (!addr) {
+		nm_log_warn (LOGD_DHCP6, "(%s): couldn't allocate memory for an IP6 Address!", priv->iface);
+		goto error;
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_ip6_address");
+	if (str && (inet_pton (AF_INET6, str, &tmp_addr) > 0)) {
+		nm_ip6_address_set_address (addr, &tmp_addr);
+		nm_log_info (LOGD_DHCP6, "  address %s", str);
+	} else
+		goto error;
+
+	str = g_hash_table_lookup (priv->options, "new_ip6_prefixlen");
+	if (str) {
+		long unsigned int prefix;
+
+		errno = 0;
+		prefix = strtoul (str, NULL, 10);
+		if (errno != 0 || prefix > 128)
+			goto error;
+
+		nm_ip6_address_set_prefix (addr, (guint32) prefix);
+		nm_log_info (LOGD_DHCP6, "  prefix %lu", prefix);
+	}
+
+	nm_ip6_config_take_address (ip6_config, addr);
+	addr = NULL;
+
+	str = g_hash_table_lookup (priv->options, "new_host_name");
+	if (str)
+		nm_log_info (LOGD_DHCP6, "  hostname '%s'", str);
+
+	str = g_hash_table_lookup (priv->options, "new_dhcp6_name_servers");
+	if (str) {
+		char **searches = g_strsplit (str, " ", 0);
+		char **s;
+
+		for (s = searches; *s; s++) {
+			if (inet_pton (AF_INET6, *s, &tmp_addr) > 0) {
+				nm_ip6_config_add_nameserver (ip6_config, &tmp_addr);
+				nm_log_info (LOGD_DHCP6, "  nameserver '%s'", *s);
+			} else
+				nm_log_warn (LOGD_DHCP6, "ignoring invalid nameserver '%s'", *s);
+		}
+		g_strfreev (searches);
+	}
+
+	str = g_hash_table_lookup (priv->options, "new_dhcp6_domain_search");
+	if (str)
+		process_domain_search (str, ip6_add_domain_search, ip6_config);
+
+	return ip6_config;
+
+error:
+	if (addr)
+		nm_ip6_address_unref (addr);
+	g_object_unref (ip6_config);
+	return NULL;
+}
+
+NMIP6Config *
+nm_dhcp_client_get_ip6_config (NMDHCPClient *self, gboolean test)
+{
+	NMDHCPClientPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_CLIENT (self), NULL);
+
+	priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	if (test && !state_is_bound (priv->state)) {
+		nm_log_warn (LOGD_DHCP6, "(%s): dhcp client didn't bind to a lease.", priv->iface);
+		return NULL;
+	}
+
+	return ip6_options_to_config (self);
+}
+
+/********************************************/
+
+static void
+nm_dhcp_client_init (NMDHCPClient *self)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+	priv->pid = -1;
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_IFACE:
+		g_value_set_string (value, priv->iface);
+		break;
+	case PROP_IPV6:
+		g_value_set_boolean (value, priv->ipv6);
+		break;
+	case PROP_UUID:
+		g_value_set_string (value, priv->uuid);
+		break;
+	case PROP_TIMEOUT:
+		g_value_set_uint (value, priv->timeout);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec)
+{
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (object);
+ 
+	switch (prop_id) {
+	case PROP_IFACE:
+		/* construct-only */
+		priv->iface = g_strdup (g_value_get_string (value));
+		break;
+	case PROP_IPV6:
+		/* construct-only */
+		priv->ipv6 = g_value_get_boolean (value);
+		break;
+	case PROP_UUID:
+		/* construct-only */
+		priv->uuid = g_value_dup_string (value);
+		break;
+	case PROP_TIMEOUT:
+		priv->timeout = g_value_get_uint (value);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDHCPClient *self = NM_DHCP_CLIENT (object);
+	NMDHCPClientPrivate *priv = NM_DHCP_CLIENT_GET_PRIVATE (self);
+
+	/* Stopping the client is left up to the controlling device
+	 * explicitly since we may want to quit NetworkManager but not terminate
+	 * the DHCP client.
+	 */
+
+	g_hash_table_destroy (priv->options);
+	g_free (priv->iface);
+
+	G_OBJECT_CLASS (nm_dhcp_client_parent_class)->dispose (object);
+}
+
+static void
+nm_dhcp_client_class_init (NMDHCPClientClass *client_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (client_class);
+
+	g_type_class_add_private (client_class, sizeof (NMDHCPClientPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+
+	client_class->stop = real_stop;
+
+	g_object_class_install_property
+		(object_class, PROP_IFACE,
+		 g_param_spec_string (NM_DHCP_CLIENT_INTERFACE,
+		                      "iface",
+		                      "Interface",
+		                      NULL,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_IPV6,
+		 g_param_spec_boolean (NM_DHCP_CLIENT_IPV6,
+		                       "ipv6",
+		                       "IPv6",
+		                       FALSE,
+		                       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_UUID,
+		 g_param_spec_string (NM_DHCP_CLIENT_UUID,
+		                      "uuid",
+		                      "UUID",
+		                      NULL,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_TIMEOUT,
+		 g_param_spec_uint (NM_DHCP_CLIENT_TIMEOUT,
+		                    "timeout",
+		                    "Timeout",
+		                    0, G_MAXUINT, 45,
+		                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	/* signals */
+	signals[STATE_CHANGED] =
+		g_signal_new ("state-changed",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDHCPClientClass, state_changed),
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__UINT,
+					  G_TYPE_NONE, 1, G_TYPE_UINT);
+
+	signals[TIMEOUT] =
+		g_signal_new ("timeout",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDHCPClientClass, timeout),
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__VOID,
+					  G_TYPE_NONE, 0);
+}
+
diff --git a/src/dhcp-manager/nm-dhcp-client.h b/src/dhcp-manager/nm-dhcp-client.h
new file mode 100644
index 0000000..2ebb5a7
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-client.h
@@ -0,0 +1,138 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP_CLIENT_H
+#define NM_DHCP_CLIENT_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include <nm-setting-ip4-config.h>
+#include <nm-setting-ip6-config.h>
+#include <nm-ip4-config.h>
+#include <nm-ip6-config.h>
+
+#define NM_TYPE_DHCP_CLIENT            (nm_dhcp_client_get_type ())
+#define NM_DHCP_CLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_CLIENT, NMDHCPClient))
+#define NM_DHCP_CLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP_CLIENT, NMDHCPClientClass))
+#define NM_IS_DHCP_CLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP_CLIENT))
+#define NM_IS_DHCP_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_CLIENT))
+#define NM_DHCP_CLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_CLIENT, NMDHCPClientClass))
+
+#define NM_DHCP_CLIENT_INTERFACE "iface"
+#define NM_DHCP_CLIENT_IPV6      "ipv6"
+#define NM_DHCP_CLIENT_UUID      "uuid"
+#define NM_DHCP_CLIENT_TIMEOUT   "timeout"
+
+typedef enum {
+	DHC_NBI = 0,     /* no broadcast interfaces found */
+	DHC_PREINIT,     /* configuration started */
+	DHC_PREINIT6,    /* configuration started */
+	DHC_BOUND4,      /* IPv4 lease obtained */
+	DHC_BOUND6,      /* IPv6 lease obtained */
+	DHC_IPV4LL,      /* IPv4LL address obtained */
+	DHC_RENEW4,      /* IPv4 lease renewed */
+	DHC_RENEW6,      /* IPv6 lease renewed */
+	DHC_REBOOT,      /* have valid lease, but now obtained a different one */
+	DHC_REBIND4,     /* IPv4 new/different lease */
+	DHC_REBIND6,     /* IPv6 new/different lease */
+	DHC_DEPREF6,     /* IPv6 lease depreferred */
+	DHC_STOP,        /* remove old lease */
+	DHC_MEDIUM,      /* media selection begun */
+	DHC_TIMEOUT,     /* timed out contacting DHCP server */
+	DHC_FAIL,        /* all attempts to contact server timed out, sleeping */
+	DHC_EXPIRE,      /* lease has expired, renewing */
+	DHC_RELEASE,     /* releasing lease */
+	DHC_START,       /* sent when dhclient started OK */
+	DHC_ABEND,       /* dhclient exited abnormally */
+	DHC_END,         /* dhclient exited normally */
+	DHC_END_OPTIONS, /* last option in subscription sent */
+} NMDHCPState;
+
+typedef struct {
+	GObject parent;
+} NMDHCPClient;
+
+typedef struct {
+	GObjectClass parent;
+
+	/* Methods */
+
+	/* Given the options table, extract any classless routes, add them to
+	 * the IP4 config and return TRUE if any existed.  If a gateway was sent
+	 * as a classless route return that in out_gwaddr.
+	 */
+	gboolean (*ip4_process_classless_routes) (NMDHCPClient *self,
+	                                          GHashTable *options,
+	                                          NMIP4Config *ip4_config,
+	                                          guint32 *out_gwaddr);
+
+	GPid (*ip4_start)                        (NMDHCPClient *self,
+	                                          NMSettingIP4Config *s_ip4,
+	                                          guint8 *anycast_addr);
+
+	GPid (*ip6_start)                        (NMDHCPClient *self,
+	                                          NMSettingIP6Config *s_ip6,
+	                                          guint8 *anycast_addr,
+	                                          gboolean info_only);
+
+	void (*stop)                             (NMDHCPClient *self);
+
+	/* Signals */
+	void (*state_changed) (NMDHCPClient *self, NMDHCPState state);
+	void (*timeout)       (NMDHCPClient *self);
+} NMDHCPClientClass;
+
+GType nm_dhcp_client_get_type (void);
+
+GPid nm_dhcp_client_get_pid (NMDHCPClient *self);
+
+const char *nm_dhcp_client_get_iface (NMDHCPClient *self);
+
+gboolean nm_dhcp_client_get_ipv6 (NMDHCPClient *self);
+
+const char *nm_dhcp_client_get_uuid (NMDHCPClient *self);
+
+gboolean nm_dhcp_client_start_ip4 (NMDHCPClient *self,
+                                   NMSettingIP4Config *s_ip4,
+                                   guint8 *dhcp_anycast_addr);
+
+gboolean nm_dhcp_client_start_ip6 (NMDHCPClient *self,
+                                   NMSettingIP6Config *s_ip6,
+                                   guint8 *dhcp_anycast_addr,
+                                   gboolean info_only);
+
+void nm_dhcp_client_stop (NMDHCPClient *self);
+
+void nm_dhcp_client_new_options (NMDHCPClient *self,
+                                 GHashTable *options,
+                                 const char *reason);
+
+gboolean nm_dhcp_client_foreach_option (NMDHCPClient *self,
+                                        GHFunc func,
+                                        gpointer user_data);
+
+NMIP4Config *nm_dhcp_client_get_ip4_config   (NMDHCPClient *self, gboolean test);
+
+NMIP6Config *nm_dhcp_client_get_ip6_config   (NMDHCPClient *self, gboolean test);
+
+/* Backend helpers */
+void nm_dhcp_client_stop_existing (const char *pid_file, const char *binary_name);
+
+#endif /* NM_DHCP_CLIENT_H */
+
diff --git a/src/dhcp-manager/nm-dhcp-dhclient.c b/src/dhcp-manager/nm-dhcp-dhclient.c
index 478ac29..37543ed 100644
--- a/src/dhcp-manager/nm-dhcp-dhclient.c
+++ b/src/dhcp-manager/nm-dhcp-dhclient.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  */
 
 #define _XOPEN_SOURCE
@@ -36,46 +36,63 @@
 
 #include <config.h>
 
-#include "nm-dhcp-manager.h"
+#include "nm-dhcp-dhclient.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 
+G_DEFINE_TYPE (NMDHCPDhclient, nm_dhcp_dhclient, NM_TYPE_DHCP_CLIENT)
 
-#define NM_DHCP_MANAGER_PID_FILENAME	"dhclient"
-#define NM_DHCP_MANAGER_PID_FILE_EXT	"pid"
+#define NM_DHCP_DHCLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientPrivate))
 
 #if defined(TARGET_DEBIAN)
-#define NM_DHCP_MANAGER_LEASE_DIR       LOCALSTATEDIR "/lib/dhcp3"
+#define NM_DHCLIENT_LEASE_DIR           LOCALSTATEDIR "/lib/dhcp3"
 #elif defined(TARGET_SUSE) || defined(TARGET_MANDRIVA)
-#define NM_DHCP_MANAGER_LEASE_DIR       LOCALSTATEDIR "/lib/dhcp"
+#define NM_DHCLIENT_LEASE_DIR           LOCALSTATEDIR "/lib/dhcp"
 #else
-#define NM_DHCP_MANAGER_LEASE_DIR       LOCALSTATEDIR "/lib/dhclient"
+#define NM_DHCLIENT_LEASE_DIR           LOCALSTATEDIR "/lib/dhclient"
 #endif
-#define NM_DHCP_MANAGER_LEASE_FILENAME	"dhclient"
-#define NM_DHCP_MANAGER_LEASE_FILE_EXT	"lease"
 
 #define ACTION_SCRIPT_PATH	LIBEXECDIR "/nm-dhcp-client.action"
 
+typedef struct {
+	const char *path;
+	char *conf_file;
+	char *lease_file;
+	char *pid_file;
+} NMDHCPDhclientPrivate;
 
-static char *
-get_pidfile_for_iface (const char * iface)
+const char *
+nm_dhcp_dhclient_get_path (const char *try_first)
 {
-	return g_strdup_printf ("%s/%s-%s.%s",
-	                        NM_DHCP_MANAGER_RUN_DIR,
-	                        NM_DHCP_MANAGER_PID_FILENAME,
-	                        iface,
-	                        NM_DHCP_MANAGER_PID_FILE_EXT);
-}
+	static const char *dhclient_paths[] = {
+		"/sbin/dhclient",
+		"/usr/sbin/dhclient",
+		"/usr/pkg/sbin/dhclient",
+		"/usr/local/sbin/dhclient",
+		NULL
+	};
+	const char **path = dhclient_paths;
+
+	if (strlen (try_first) && g_file_test (try_first, G_FILE_TEST_EXISTS))
+		return try_first;
+
+	while (*path != NULL) {
+		if (g_file_test (*path, G_FILE_TEST_EXISTS))
+			break;
+		path++;
+	}
 
+	return *path;
+}
 
 static char *
-get_leasefile_for_iface (const char * iface, const char *uuid)
+get_leasefile_for_iface (const char * iface, const char *uuid, gboolean ipv6)
 {
-	return g_strdup_printf ("%s/%s-%s-%s.%s",
-	                        NM_DHCP_MANAGER_LEASE_DIR,
-	                        NM_DHCP_MANAGER_LEASE_FILENAME,
+	return g_strdup_printf ("%s/dhclient%s-%s-%s.lease",
+	                        NM_DHCLIENT_LEASE_DIR,
+	                        ipv6 ? "6" : "",
 	                        uuid,
-	                        iface,
-	                        NM_DHCP_MANAGER_LEASE_FILE_EXT);
+	                        iface);
 }
 
 static void
@@ -85,7 +102,7 @@ add_lease_option (GHashTable *hash, char *line)
 
 	spc = strchr (line, ' ');
 	if (!spc) {
-		g_warning ("%s: line '%s' did not contain a space", __func__, line);
+		nm_log_warn (LOGD_DHCP, "DHCP lease file line '%s' did not contain a space", line);
 		return;
 	}
 
@@ -93,8 +110,8 @@ add_lease_option (GHashTable *hash, char *line)
 	if (g_str_has_prefix (line, "option ")) {
 		spc = strchr (spc + 1, ' ');
 		if (!spc) {
-			g_warning ("%s: option line '%s' did not contain a second space",
-			           __func__, line);
+			nm_log_warn (LOGD_DHCP, "DHCP lease file option line '%s' did not contain a second space",
+			             line);
 			return;
 		}
 	}
@@ -119,7 +136,7 @@ add_lease_option (GHashTable *hash, char *line)
 }
 
 GSList *
-nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
+nm_dhcp_dhclient_get_lease_config (const char *iface, const char *uuid)
 {
 	GSList *parsed = NULL, *iter, *leases = NULL;
 	char *contents = NULL;
@@ -127,7 +144,7 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 	char **line, **split = NULL;
 	GHashTable *hash = NULL;
 
-	leasefile = get_leasefile_for_iface (iface, uuid);
+	leasefile = get_leasefile_for_iface (iface, uuid, FALSE);
 	if (!leasefile)
 		return NULL;
 
@@ -152,9 +169,9 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 		} else if (!strcmp (*line, "lease {")) {
 			/* Beginning of a new lease */
 			if (hash) {
-				g_warning ("%s: lease file %s malformed; new lease started "
-				           "without ending previous lease",
-				           __func__, leasefile);
+				nm_log_warn (LOGD_DHCP, "DHCP lease file %s malformed; new lease started "
+				             "without ending previous lease",
+				             leasefile);
 				g_hash_table_destroy (hash);
 			}
 
@@ -166,9 +183,9 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 
 	/* Check if the last lease in the file was properly ended */
 	if (hash) {
-		g_warning ("%s: lease file %s malformed; new lease started "
-		           "without ending previous lease",
-		           __func__, leasefile);
+		nm_log_warn (LOGD_DHCP, "DHCP lease file %s malformed; new lease started "
+		             "without ending previous lease",
+		             leasefile);
 		g_hash_table_destroy (hash);
 		hash = NULL;
 	}
@@ -195,8 +212,8 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 
 			/* Read lease expiration (in UTC) */
 			if (!strptime (data, "%w %Y/%m/%d %H:%M:%S", &expire)) {
-				g_warning ("%s: couldn't parse expire time '%s'",
-				           __func__, data);
+				nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file expire time '%s'",
+				             data);
 				continue;
 			}
 
@@ -238,27 +255,30 @@ nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
 
 		/* IP4 address */
 		if (!inet_pton (AF_INET, data, &tmp)) {
-			g_warning ("%s: couldn't parse IP4 address '%s'", __func__, data);
+			nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file IP4 address '%s'", data);
 			goto error;
 		}
 		nm_ip4_address_set_address (addr, tmp.s_addr);
 
 		/* Netmask */
 		data = g_hash_table_lookup (hash, "option subnet-mask");
-		if (!data)
-			data = "255.255.255.0"; /* FIXME: assume class C? */
-		if (!inet_pton (AF_INET, data, &tmp)) {
-			g_warning ("%s: couldn't parse IP4 subnet mask '%s'", __func__, data);
-			goto error;
+		if (data) {
+			if (!inet_pton (AF_INET, data, &tmp)) {
+				nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file IP4 subnet mask '%s'", data);
+				goto error;
+			}
+			prefix = nm_utils_ip4_netmask_to_prefix (tmp.s_addr);
+		} else {
+			/* Get default netmask for the IP according to appropriate class. */
+			prefix = nm_utils_ip4_get_default_prefix (nm_ip4_address_get_address (addr));
 		}
-		prefix = nm_utils_ip4_netmask_to_prefix (tmp.s_addr);
 		nm_ip4_address_set_prefix (addr, prefix);
 
 		/* Gateway */
 		data = g_hash_table_lookup (hash, "option routers");
 		if (data) {
 			if (!inet_pton (AF_INET, data, &tmp)) {
-				g_warning ("%s: couldn't parse IP4 gateway '%s'", __func__, data);
+				nm_log_warn (LOGD_DHCP, "couldn't parse DHCP lease file IP4 gateway '%s'", data);
 				goto error;
 			}
 			nm_ip4_address_set_gateway (addr, tmp.s_addr);
@@ -288,28 +308,39 @@ out:
 #define DHCP_HOSTNAME_FORMAT DHCP_HOSTNAME_TAG " \"%s\"; # added by NetworkManager"
 
 static gboolean
-merge_dhclient_config (NMDHCPDevice *device,
+merge_dhclient_config (const char *iface,
+                       const char *conf_file,
                        NMSettingIP4Config *s_ip4,
                        guint8 *anycast_addr,
-                       const char *contents,
-                       const char *orig,
+                       const char *orig_path,
                        GError **error)
 {
 	GString *new_contents;
+	char *orig_contents = NULL;
 	gboolean success = FALSE;
 
-	g_return_val_if_fail (device != NULL, FALSE);
-	g_return_val_if_fail (device->iface != NULL, FALSE);
-	
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (conf_file != NULL, FALSE);
+
 	new_contents = g_string_new (_("# Created by NetworkManager\n"));
 
+	if (g_file_test (orig_path, G_FILE_TEST_EXISTS)) {
+		GError *read_error = NULL;
+
+		if (!g_file_get_contents (orig_path, &orig_contents, NULL, &read_error)) {
+			nm_log_warn (LOGD_DHCP, "(%s): error reading dhclient configuration %s: %s",
+			             iface, orig_path, read_error->message);
+			g_error_free (read_error);
+		}
+	}
+
 	/* Add existing options, if any, but ignore stuff NM will replace. */
-	if (contents) {
+	if (orig_contents) {
 		char **lines = NULL, **line;
 
-		g_string_append_printf (new_contents, _("# Merged from %s\n\n"), orig);
+		g_string_append_printf (new_contents, _("# Merged from %s\n\n"), orig_path);
 
-		lines = g_strsplit_set (contents, "\n\r", 0);
+		lines = g_strsplit_set (orig_contents, "\n\r", 0);
 		for (line = lines; lines && *line; line++) {
 			gboolean ignore = FALSE;
 
@@ -334,6 +365,7 @@ merge_dhclient_config (NMDHCPDevice *device,
 
 		if (lines)
 			g_strfreev (lines);
+		g_free (orig_contents);
 	} else
 		g_string_append_c (new_contents, '\n');
 
@@ -374,14 +406,13 @@ merge_dhclient_config (NMDHCPDevice *device,
 		                        " initial-interval 1; \n"
 		                        " anycast-mac ethernet %02x:%02x:%02x:%02x:%02x:%02x;\n"
 		                        "}\n",
-		                        device->iface,
+		                        iface,
 		                        anycast_addr[0], anycast_addr[1],
 		                        anycast_addr[2], anycast_addr[3],
 		                        anycast_addr[4], anycast_addr[5]);
 	}
 
-	if (g_file_set_contents (device->conf_file, new_contents->str, -1, error))
-		success = TRUE;
+	success = g_file_set_contents (conf_file, new_contents->str, -1, error);
 
 	g_string_free (new_contents, TRUE);
 	return success;
@@ -393,17 +424,16 @@ merge_dhclient_config (NMDHCPDevice *device,
  * read their single config file and merge that into a custom per-interface
  * config file along with the NM options.
  */
-static gboolean
-create_dhclient_config (NMDHCPDevice *device,
+static char *
+create_dhclient_config (const char *iface,
                         NMSettingIP4Config *s_ip4,
                         guint8 *dhcp_anycast_addr)
 {
-	char *orig = NULL, *contents = NULL;
+	char *orig = NULL, *tmp, *conf_file = NULL;
 	GError *error = NULL;
 	gboolean success = FALSE;
-	char *tmp;
 
-	g_return_val_if_fail (device != NULL, FALSE);
+	g_return_val_if_fail (iface != NULL, FALSE);
 
 #if defined(TARGET_SUSE)
 	orig = g_strdup (SYSCONFDIR "/dhclient.conf");
@@ -412,41 +442,28 @@ create_dhclient_config (NMDHCPDevice *device,
 #elif defined(TARGET_GENTOO)
 	orig = g_strdup (SYSCONFDIR "/dhcp/dhclient.conf");
 #else
-	orig = g_strdup_printf (SYSCONFDIR "/dhclient-%s.conf", device->iface);
+	orig = g_strdup_printf (SYSCONFDIR "/dhclient-%s.conf", iface);
 #endif
 
 	if (!orig) {
-		nm_warning ("%s: not enough memory for dhclient options.", device->iface);
+		nm_log_warn (LOGD_DHCP, "(%s): not enough memory for dhclient options.", iface);
 		return FALSE;
 	}
 
-	tmp = g_strdup_printf ("nm-dhclient-%s.conf", device->iface);
-	device->conf_file = g_build_filename ("/var", "run", tmp, NULL);
+	tmp = g_strdup_printf ("nm-dhclient-%s.conf", iface);
+	conf_file = g_build_filename ("/var", "run", tmp, NULL);
 	g_free (tmp);
 
-	if (!g_file_test (orig, G_FILE_TEST_EXISTS))
-		goto out;
-
-	if (!g_file_get_contents (orig, &contents, NULL, &error)) {
-		nm_warning ("%s: error reading dhclient configuration %s: %s",
-		            device->iface, orig, error->message);
-		g_error_free (error);
-		goto out;
-	}
-
-out:
 	error = NULL;
-	if (merge_dhclient_config (device, s_ip4, dhcp_anycast_addr, contents, orig, &error))
-		success = TRUE;
-	else {
-		nm_warning ("%s: error creating dhclient configuration: %s",
-		            device->iface, error->message);
+	success = merge_dhclient_config (iface, conf_file, s_ip4, dhcp_anycast_addr, orig, &error);
+	if (!success) {
+		nm_log_warn (LOGD_DHCP, "(%s): error creating dhclient configuration: %s",
+		             iface, error->message);
 		g_error_free (error);
 	}
 
-	g_free (contents);
 	g_free (orig);
-	return success;
+	return conf_file;
 }
 
 
@@ -458,80 +475,136 @@ dhclient_child_setup (gpointer user_data G_GNUC_UNUSED)
 	setpgid (pid, pid);
 }
 
-
-GPid
-nm_dhcp_client_start (NMDHCPDevice *device,
-                      const char *uuid,
-                      NMSettingIP4Config *s_ip4,
-                      guint8 *dhcp_anycast_addr)
+static GPid
+dhclient_start (NMDHCPClient *client,
+                const char *ip_opt,
+                const char *mode_opt)
 {
-	GPtrArray *dhclient_argv = NULL;
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (client);
+	GPtrArray *argv = NULL;
 	GPid pid = 0;
 	GError *error = NULL;
-	char *pid_contents = NULL;
-
-	if (!g_file_test (DHCP_CLIENT_PATH, G_FILE_TEST_EXISTS)) {
-		nm_warning (DHCP_CLIENT_PATH " does not exist.");
-		goto out;
+	const char *iface, *uuid;
+	char *binary_name, *cmd_str;
+	gboolean ipv6;
+	guint log_domain;
+
+	g_return_val_if_fail (priv->pid_file == NULL, -1);
+	g_return_val_if_fail (ip_opt != NULL, -1);
+
+	iface = nm_dhcp_client_get_iface (client);
+	uuid = nm_dhcp_client_get_uuid (client);
+	ipv6 = nm_dhcp_client_get_ipv6 (client);
+
+	log_domain = ipv6 ? LOGD_DHCP6 : LOGD_DHCP4;
+
+	priv->pid_file = g_strdup_printf (LOCALSTATEDIR "/run/dhclient%s-%s.pid",
+	                                  ipv6 ? "6" : "",
+	                                  iface);
+	if (!priv->pid_file) {
+		nm_log_warn (log_domain, "(%s): not enough memory for dhcpcd options.", iface);
+		return -1;
 	}
 
-	device->pid_file = get_pidfile_for_iface (device->iface);
-	if (!device->pid_file) {
-		nm_warning ("%s: not enough memory for dhclient options.", device->iface);
-		goto out;
+	if (!g_file_test (priv->path, G_FILE_TEST_EXISTS)) {
+		nm_log_warn (log_domain, "%s does not exist.", priv->path);
+		return -1;
 	}
 
-	device->lease_file = get_leasefile_for_iface (device->iface, uuid);
-	if (!device->lease_file) {
-		nm_warning ("%s: not enough memory for dhclient options.", device->iface);
-		goto out;
+	/* Kill any existing dhclient from the pidfile */
+	binary_name = g_path_get_basename (priv->path);
+	nm_dhcp_client_stop_existing (priv->pid_file, binary_name);
+	g_free (binary_name);
+
+	priv->lease_file = get_leasefile_for_iface (iface, uuid, ipv6);
+	if (!priv->lease_file) {
+		nm_log_warn (log_domain, "(%s): not enough memory for dhclient options.", iface);
+		return -1;
 	}
 
-	if (!create_dhclient_config (device, s_ip4, dhcp_anycast_addr))
-		goto out;
+	argv = g_ptr_array_new ();
+	g_ptr_array_add (argv, (gpointer) priv->path);
 
-	/* Kill any existing dhclient bound to this interface */
-	if (g_file_get_contents (device->pid_file, &pid_contents, NULL, NULL)) {
-		unsigned long int tmp = strtoul (pid_contents, NULL, 10);
+	g_ptr_array_add (argv, (gpointer) "-d");
 
-		if (!((tmp == ULONG_MAX) && (errno == ERANGE)))
-			nm_dhcp_client_stop (device, (pid_t) tmp);
-		remove (device->pid_file);
-	}
+	g_ptr_array_add (argv, (gpointer) ip_opt);
 
-	dhclient_argv = g_ptr_array_new ();
-	g_ptr_array_add (dhclient_argv, (gpointer) DHCP_CLIENT_PATH);
+	if (mode_opt)
+		g_ptr_array_add (argv, (gpointer) mode_opt);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-d");
+	g_ptr_array_add (argv, (gpointer) "-sf");	/* Set script file */
+	g_ptr_array_add (argv, (gpointer) ACTION_SCRIPT_PATH );
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-sf");	/* Set script file */
-	g_ptr_array_add (dhclient_argv, (gpointer) ACTION_SCRIPT_PATH );
+	g_ptr_array_add (argv, (gpointer) "-pf");	/* Set pid file */
+	g_ptr_array_add (argv, (gpointer) priv->pid_file);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-pf");	/* Set pid file */
-	g_ptr_array_add (dhclient_argv, (gpointer) device->pid_file);
+	g_ptr_array_add (argv, (gpointer) "-lf");	/* Set lease file */
+	g_ptr_array_add (argv, (gpointer) priv->lease_file);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-lf");	/* Set lease file */
-	g_ptr_array_add (dhclient_argv, (gpointer) device->lease_file);
+	if (priv->conf_file) {
+		g_ptr_array_add (argv, (gpointer) "-cf");	/* Set interface config file */
+		g_ptr_array_add (argv, (gpointer) priv->conf_file);
+	}
 
-	g_ptr_array_add (dhclient_argv, (gpointer) "-cf");	/* Set interface config file */
-	g_ptr_array_add (dhclient_argv, (gpointer) device->conf_file);
+	g_ptr_array_add (argv, (gpointer) iface);
+	g_ptr_array_add (argv, NULL);
 
-	g_ptr_array_add (dhclient_argv, (gpointer) device->iface);
-	g_ptr_array_add (dhclient_argv, NULL);
+	cmd_str = g_strjoinv (" ", (gchar **) argv->pdata);
+	nm_log_dbg (log_domain, "running: %s", cmd_str);
+	g_free (cmd_str);
 
-	if (!g_spawn_async (NULL, (char **) dhclient_argv->pdata, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
+	if (!g_spawn_async (NULL, (char **) argv->pdata, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
 	                    &dhclient_child_setup, NULL, &pid, &error)) {
-		nm_warning ("dhclient failed to start.  error: '%s'", error->message);
+		nm_log_warn (log_domain, "dhclient failed to start: '%s'", error->message);
 		g_error_free (error);
-		goto out;
+		pid = -1;
+	} else
+		nm_log_info (log_domain, "dhclient started with pid %d", pid);
+
+	g_ptr_array_free (argv, TRUE);
+	return pid;
+}
+
+static GPid
+real_ip4_start (NMDHCPClient *client,
+                NMSettingIP4Config *s_ip4,
+                guint8 *dhcp_anycast_addr)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (client);
+	const char *iface;
+
+	iface = nm_dhcp_client_get_iface (client);
+
+	priv->conf_file = create_dhclient_config (iface, s_ip4, dhcp_anycast_addr);
+	if (!priv->conf_file) {
+		nm_log_warn (LOGD_DHCP4, "(%s): error creating dhclient configuration file.", iface);
+		return -1;
 	}
 
-	nm_info ("dhclient started with pid %d", pid);
+	return dhclient_start (client, "-4", NULL);
+}
 
-out:
-	g_free (pid_contents);
-	g_ptr_array_free (dhclient_argv, TRUE);
-	return pid;
+static GPid
+real_ip6_start (NMDHCPClient *client,
+                NMSettingIP6Config *s_ip6,
+                guint8 *dhcp_anycast_addr,
+                gboolean info_only)
+{
+	return dhclient_start (client, "-6", info_only ? "-S" : "-N");
+}
+
+static void
+real_stop (NMDHCPClient *client)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (client);
+
+	/* Chain up to parent */
+	NM_DHCP_CLIENT_CLASS (nm_dhcp_dhclient_parent_class)->stop (client);
+
+	if (priv->conf_file)
+		remove (priv->conf_file);
+	if (priv->pid_file)
+		remove (priv->pid_file);
 }
 
 static const char **
@@ -595,10 +668,11 @@ error:
 	return o;
 }
 
-gboolean
-nm_dhcp_client_process_classless_routes (GHashTable *options,
-                                         NMIP4Config *ip4_config,
-                                         guint32 *gwaddr)
+static gboolean
+real_ip4_process_classless_routes (NMDHCPClient *client,
+                                   GHashTable *options,
+                                   NMIP4Config *ip4_config,
+                                   guint32 *gwaddr)
 {
 	const char *str;
 	char **octets, **o;
@@ -624,7 +698,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 
 	o = octets = g_strsplit (str, " ", 0);
 	if (g_strv_length (octets) < 5) {
-		nm_warning ("Ignoring invalid classless static routes '%s'", str);
+		nm_log_warn (LOGD_DHCP4, "ignoring invalid classless static routes '%s'", str);
 		goto out;
 	}
 
@@ -632,7 +706,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 		route = NULL;
 		o = (char **) process_rfc3442_route ((const char **) o, &route);
 		if (!route) {
-			nm_warning ("Ignoring invalid classless static routes");
+			nm_log_warn (LOGD_DHCP4, "ignoring invalid classless static routes");
 			break;
 		}
 
@@ -653,8 +727,8 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 			inet_ntop (AF_INET, &tmp, addr, sizeof (addr));
 			tmp.s_addr = nm_ip4_route_get_next_hop (route);
 			inet_ntop (AF_INET, &tmp, nh, sizeof (nh));
-			nm_info ("  classless static route %s/%d gw %s",
-			         addr, nm_ip4_route_get_prefix (route), nh);
+			nm_log_info (LOGD_DHCP4, "  classless static route %s/%d gw %s",
+			             addr, nm_ip4_route_get_prefix (route), nh);
 		}
 	}
 
@@ -663,3 +737,42 @@ out:
 	return have_routes;
 }
 
+/***************************************************/
+
+static void
+nm_dhcp_dhclient_init (NMDHCPDhclient *self)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (self);
+
+	priv->path = nm_dhcp_dhclient_get_path (DHCLIENT_PATH);
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (object);
+
+	g_free (priv->pid_file);
+	g_free (priv->conf_file);
+	g_free (priv->lease_file);
+
+	G_OBJECT_CLASS (nm_dhcp_dhclient_parent_class)->dispose (object);
+}
+
+static void
+nm_dhcp_dhclient_class_init (NMDHCPDhclientClass *dhclient_class)
+{
+	NMDHCPClientClass *client_class = NM_DHCP_CLIENT_CLASS (dhclient_class);
+	GObjectClass *object_class = G_OBJECT_CLASS (dhclient_class);
+
+	g_type_class_add_private (dhclient_class, sizeof (NMDHCPDhclientPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+
+	client_class->ip4_start = real_ip4_start;
+	client_class->ip6_start = real_ip6_start;
+	client_class->stop = real_stop;
+	client_class->ip4_process_classless_routes = real_ip4_process_classless_routes;
+}
+
diff --git a/src/dhcp-manager/nm-dhcp-dhclient.h b/src/dhcp-manager/nm-dhcp-dhclient.h
new file mode 100644
index 0000000..be242de
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-dhclient.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP_DHCLIENT_H
+#define NM_DHCP_DHCLIENT_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nm-dhcp-client.h"
+
+#define NM_TYPE_DHCP_DHCLIENT            (nm_dhcp_dhclient_get_type ())
+#define NM_DHCP_DHCLIENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclient))
+#define NM_DHCP_DHCLIENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientClass))
+#define NM_IS_DHCP_DHCLIENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP_DHCLIENT))
+#define NM_IS_DHCP_DHCLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_DHCLIENT))
+#define NM_DHCP_DHCLIENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientClass))
+
+typedef struct {
+	NMDHCPClient parent;
+} NMDHCPDhclient;
+
+typedef struct {
+	NMDHCPClientClass parent;
+} NMDHCPDhclientClass;
+
+GType nm_dhcp_dhclient_get_type (void);
+
+GSList *nm_dhcp_dhclient_get_lease_config (const char *iface, const char *uuid);
+
+const char *nm_dhcp_dhclient_get_path (const char *try_first);
+
+#endif /* NM_DHCP_DHCLIENT_H */
+
diff --git a/src/dhcp-manager/nm-dhcp-dhcpcd.c b/src/dhcp-manager/nm-dhcp-dhcpcd.c
index a8d929a..56b7481 100644
--- a/src/dhcp-manager/nm-dhcp-dhcpcd.c
+++ b/src/dhcp-manager/nm-dhcp-dhcpcd.c
@@ -2,6 +2,7 @@
 /* nm-dhcp-dhcpcd.c - dhcpcd specific hooks for NetworkManager
  *
  * Copyright (C) 2008 Roy Marples
+ * Copyright (C) 2010 Dan Williams <dcbw@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,26 +32,47 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 
-#include "nm-dhcp-manager.h"
+#include "nm-dhcp-dhcpcd.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 
-#define NM_DHCP_MANAGER_PID_FILENAME	"dhcpcd"
-#define NM_DHCP_MANAGER_PID_FILE_EXT	"pid"
+G_DEFINE_TYPE (NMDHCPDhcpcd, nm_dhcp_dhcpcd, NM_TYPE_DHCP_DHCPCD)
+
+#define NM_DHCP_DHCPCD_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcdPrivate))
 
 #define ACTION_SCRIPT_PATH	LIBEXECDIR "/nm-dhcp-client.action"
 
+typedef struct {
+	const char *path;
+	char *pid_file;
+} NMDHCPDhcpcdPrivate;
 
-static char *
-get_pidfile_for_iface (const char * iface)
+const char *
+nm_dhcp_dhcpcd_get_path (const char *try_first)
 {
-	return g_strdup_printf ("/var/run/%s-%s.%s",
-	                        NM_DHCP_MANAGER_PID_FILENAME,
-	                        iface,
-	                        NM_DHCP_MANAGER_PID_FILE_EXT);
+	static const char *dhcpcd_paths[] = {
+		"/sbin/dhcpcd",
+		"/usr/sbin/dhcpcd",
+		"/usr/pkg/sbin/dhcpcd",
+		"/usr/local/sbin/dhcpcd",
+		NULL
+	};
+	const char **path = dhcpcd_paths;
+
+	if (strlen (try_first) && g_file_test (try_first, G_FILE_TEST_EXISTS))
+		return try_first;
+
+	while (*path != NULL) {
+		if (g_file_test (*path, G_FILE_TEST_EXISTS))
+			break;
+		path++;
+	}
+
+	return *path;
 }
 
 GSList *
-nm_dhcp_client_get_lease_ip4_config (const char *iface, const char *uuid)
+nm_dhcp_dhcpcd_get_lease_config (const char *iface, const char *uuid)
 {
 	return NULL;
 }
@@ -63,40 +85,41 @@ dhcpcd_child_setup (gpointer user_data G_GNUC_UNUSED)
 	setpgid (pid, pid);
 }
 
-
-GPid
-nm_dhcp_client_start (NMDHCPDevice *device,
-                      const char *uuid,
-                      NMSettingIP4Config *s_ip4,
-                      guint8 *dhcp_anycast_addr)
+static GPid
+real_ip4_start (NMDHCPClient *client,
+                NMSettingIP4Config *s_ip4,
+                guint8 *dhcp_anycast_addr)
 {
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (client);
 	GPtrArray *argv = NULL;
 	GPid pid = 0;
 	GError *error = NULL;
-	char *pid_contents = NULL;
+	char *pid_contents = NULL, *binary_name, *cmd_str;
+	const char *iface, *uuid, *hostname;
 
-	if (!g_file_test (DHCP_CLIENT_PATH, G_FILE_TEST_EXISTS)) {
-		nm_warning (DHCP_CLIENT_PATH " does not exist.");
-		goto out;
-	}
+	g_return_val_if_fail (priv->pid_file == NULL, -1);
 
-	device->pid_file = get_pidfile_for_iface (device->iface);
-	if (!device->pid_file) {
-		nm_warning ("%s: not enough memory for dhcpcd options.", device->iface);
-		goto out;
-	}
+	iface = nm_dhcp_client_get_iface (client);
+	uuid = nm_dhcp_client_get_uuid (client);
 
-	/* Kill any existing dhcpcd bound to this interface */
-	if (g_file_get_contents (device->pid_file, &pid_contents, NULL, NULL)) {
-		unsigned long int tmp = strtoul (pid_contents, NULL, 10);
+	priv->pid_file = g_strdup_printf (LOCALSTATEDIR "/run/dhcpcd-%s.pid", iface);
+	if (!priv->pid_file) {
+		nm_log_warn (LOGD_DHCP4, "(%s): not enough memory for dhcpcd options.", iface);
+		return -1;
+	}
 
-		if (!((tmp == ULONG_MAX) && (errno == ERANGE)))
-			nm_dhcp_client_stop (device, (pid_t) tmp);
-		remove (device->pid_file);
+	if (!g_file_test (priv->path, G_FILE_TEST_EXISTS)) {
+		nm_log_warn (LOGD_DHCP4, "%s does not exist.", priv->path);
+		return -1;
 	}
 
+	/* Kill any existing dhcpcd from the pidfile */
+	binary_name = g_path_get_basename (priv->path);
+	nm_dhcp_client_stop_existing (priv->pid_file, binary_name);
+	g_free (binary_name);
+
 	argv = g_ptr_array_new ();
-	g_ptr_array_add (argv, (gpointer) DHCP_CLIENT_PATH);
+	g_ptr_array_add (argv, (gpointer) priv->path);
 
 	g_ptr_array_add (argv, (gpointer) "-B");	/* Don't background on lease (disable fork()) */
 
@@ -107,28 +130,58 @@ nm_dhcp_client_start (NMDHCPDevice *device,
 	g_ptr_array_add (argv, (gpointer) "-c");	/* Set script file */
 	g_ptr_array_add (argv, (gpointer) ACTION_SCRIPT_PATH );
 
-	g_ptr_array_add (argv, (gpointer) device->iface);
+	hostname = nm_setting_ip4_config_get_dhcp_hostname (s_ip4);
+	if (hostname && strlen (hostname)) {
+		g_ptr_array_add (argv, (gpointer) "-h");	/* Send hostname to DHCP server */
+		g_ptr_array_add (argv, (gpointer) hostname );
+	}
+
+	g_ptr_array_add (argv, (gpointer) iface);
 	g_ptr_array_add (argv, NULL);
 
+	cmd_str = g_strjoinv (" ", (gchar **) argv->pdata);
+	nm_log_dbg (LOGD_DHCP4, "running: %s", cmd_str);
+	g_free (cmd_str);
+
 	if (!g_spawn_async (NULL, (char **) argv->pdata, NULL, G_SPAWN_DO_NOT_REAP_CHILD,
 	                    &dhcpcd_child_setup, NULL, &pid, &error)) {
-		nm_warning ("dhcpcd failed to start.  error: '%s'", error->message);
+		nm_log_warn (LOGD_DHCP4, "dhcpcd failed to start.  error: '%s'", error->message);
 		g_error_free (error);
-		goto out;
-	}
+	} else
+		nm_log_info (LOGD_DHCP4, "dhcpcd started with pid %d", pid);
 
-	nm_info ("dhcpcd started with pid %d", pid);
-
-out:
 	g_free (pid_contents);
 	g_ptr_array_free (argv, TRUE);
 	return pid;
 }
 
-gboolean
-nm_dhcp_client_process_classless_routes (GHashTable *options,
-                                         NMIP4Config *ip4_config,
-                                         guint32 *gwaddr)
+static GPid
+real_ip6_start (NMDHCPClient *client,
+                NMSettingIP6Config *s_ip6,
+                guint8 *dhcp_anycast_addr,
+                gboolean info_only)
+{
+	nm_log_warn (LOGD_DHCP6, "the dhcpcd backend does not support IPv6.");
+	return -1;
+}
+
+static void
+real_stop (NMDHCPClient *client)
+{
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (client);
+
+	/* Chain up to parent */
+	NM_DHCP_CLIENT_CLASS (nm_dhcp_dhcpcd_parent_class)->stop (client);
+
+	if (priv->pid_file)
+		remove (priv->pid_file);
+}
+
+static gboolean
+real_ip4_process_classless_routes (NMDHCPClient *client,
+                                   GHashTable *options,
+                                   NMIP4Config *ip4_config,
+                                   guint32 *gwaddr)
 {
 	const char *str;
 	char **routes, **r;
@@ -150,7 +203,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 		goto out;
 
 	if ((g_strv_length (routes) % 2) != 0) {
-		nm_info ("  classless static routes provided, but invalid");
+		nm_log_warn (LOGD_DHCP4, "  classless static routes provided, but invalid");
 		goto out;
 	}
 
@@ -167,16 +220,16 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 			errno = 0;
 			rt_cidr = strtol (slash + 1, NULL, 10);
 			if ((errno == EINVAL) || (errno == ERANGE)) {
-				nm_warning ("DHCP provided invalid classless static route cidr: '%s'", slash + 1);
+				nm_log_warn (LOGD_DHCP4, "DHCP provided invalid classless static route cidr: '%s'", slash + 1);
 				continue;
 			}
 		}
 		if (inet_pton (AF_INET, *r, &rt_addr) <= 0) {
-			nm_warning ("DHCP provided invalid classless static route address: '%s'", *r);
+			nm_log_warn (LOGD_DHCP4, "DHCP provided invalid classless static route address: '%s'", *r);
 			continue;
 		}
 		if (inet_pton (AF_INET, *(r + 1), &rt_route) <= 0) {
-			nm_warning ("DHCP provided invalid classless static route gateway: '%s'", *(r + 1));
+			nm_log_warn (LOGD_DHCP4, "DHCP provided invalid classless static route gateway: '%s'", *(r + 1));
 			continue;
 		}
 
@@ -192,7 +245,7 @@ nm_dhcp_client_process_classless_routes (GHashTable *options,
 
 
 			nm_ip4_config_take_route (ip4_config, route);
-			nm_info ("  classless static route %s/%d gw %s", *r, rt_cidr, *(r + 1));
+			nm_log_info (LOGD_DHCP4, "  classless static route %s/%d gw %s", *r, rt_cidr, *(r + 1));
 		}
 	}
 
@@ -201,3 +254,40 @@ out:
 	return have_routes;
 }
 
+/***************************************************/
+
+static void
+nm_dhcp_dhcpcd_init (NMDHCPDhcpcd *self)
+{
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (self);
+
+	priv->path = nm_dhcp_dhcpcd_get_path (DHCPCD_PATH);
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDHCPDhcpcdPrivate *priv = NM_DHCP_DHCPCD_GET_PRIVATE (object);
+
+	g_free (priv->pid_file);
+
+	G_OBJECT_CLASS (nm_dhcp_dhcpcd_parent_class)->dispose (object);
+}
+
+static void
+nm_dhcp_dhcpcd_class_init (NMDHCPDhcpcdClass *dhcpcd_class)
+{
+	NMDHCPClientClass *client_class = NM_DHCP_CLIENT_CLASS (dhcpcd_class);
+	GObjectClass *object_class = G_OBJECT_CLASS (dhcpcd_class);
+
+	g_type_class_add_private (dhcpcd_class, sizeof (NMDHCPDhcpcdPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+
+	client_class->ip4_start = real_ip4_start;
+	client_class->ip6_start = real_ip6_start;
+	client_class->stop = real_stop;
+	client_class->ip4_process_classless_routes = real_ip4_process_classless_routes;
+}
+
diff --git a/src/dhcp-manager/nm-dhcp-dhcpcd.h b/src/dhcp-manager/nm-dhcp-dhcpcd.h
new file mode 100644
index 0000000..586c569
--- /dev/null
+++ b/src/dhcp-manager/nm-dhcp-dhcpcd.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP_DHCPCD_H
+#define NM_DHCP_DHCPCD_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nm-dhcp-client.h"
+
+#define NM_TYPE_DHCP_DHCPCD            (nm_dhcp_dhcpcd_get_type ())
+#define NM_DHCP_DHCPCD(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcd))
+#define NM_DHCP_DHCPCD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcdClass))
+#define NM_IS_DHCP_DHCPCD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP_DHCPCD))
+#define NM_IS_DHCP_DHCPCD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_DHCPCD))
+#define NM_DHCP_DHCPCD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_DHCPCD, NMDHCPDhcpcdClass))
+
+typedef struct {
+	NMDHCPClient parent;
+} NMDHCPDhcpcd;
+
+typedef struct {
+	NMDHCPClientClass parent;
+} NMDHCPDhcpcdClass;
+
+GType nm_dhcp_dhcpcd_get_type (void);
+
+GSList *nm_dhcp_dhcpcd_get_lease_config (const char *iface, const char *uuid);
+
+const char *nm_dhcp_dhcpcd_get_path (const char *try_first);
+
+#endif /* NM_DHCP_DHCPCD_H */
+
diff --git a/src/dhcp-manager/nm-dhcp-manager.c b/src/dhcp-manager/nm-dhcp-manager.c
index c3ca358..94109ad 100644
--- a/src/dhcp-manager/nm-dhcp-manager.c
+++ b/src/dhcp-manager/nm-dhcp-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  *
  */
@@ -25,8 +25,6 @@
 #include <glib/gi18n.h>
 #include <dbus/dbus.h>
 #include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
 #include <sys/wait.h>
 #include <signal.h>
 #include <string.h>
@@ -37,247 +35,67 @@
 #include <stdio.h>
 
 #include "nm-dhcp-manager.h"
+#include "nm-dhcp-dhclient.h"
+#include "nm-dhcp-dhcpcd.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-dbus-manager.h"
 #include "nm-hostname-provider.h"
 #include "nm-dbus-glib-types.h"
 #include "nm-glib-compat.h"
 
-#define NM_DHCP_CLIENT_DBUS_SERVICE "org.freedesktop.nm_dhcp_client"
-#define NM_DHCP_CLIENT_DBUS_IFACE   "org.freedesktop.nm_dhcp_client"
-
-#define NM_DHCP_TIMEOUT   	45 /* DHCP timeout, in seconds */
-
-typedef struct {
-	NMDBusManager * dbus_mgr;
-	GHashTable *	devices;
-	DBusGProxy *	proxy;
-	NMHostnameProvider *hostname_provider;
-} NMDHCPManagerPrivate;
-
-
-#define NM_DHCP_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_MANAGER, NMDHCPManagerPrivate))
-
-G_DEFINE_TYPE (NMDHCPManager, nm_dhcp_manager, G_TYPE_OBJECT)
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
 
-enum {
-	STATE_CHANGED,
-	TIMEOUT,
-	LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-static NMDHCPManager *nm_dhcp_manager_new (void);
-
-static void nm_dhcp_manager_cancel_transaction_real (NMDHCPDevice *device);
-
-static void hostname_provider_destroyed (gpointer data, GObject *destroyed_object);
-
-NMDHCPManager *
-nm_dhcp_manager_get (void)
+GQuark
+nm_dhcp_manager_error_quark (void)
 {
-	static NMDHCPManager *singleton = NULL;
+    static GQuark ret = 0;
 
-	if (!singleton)
-		singleton = nm_dhcp_manager_new ();
-	else
-		g_object_ref (singleton);
+    if (ret == 0)
+        ret = g_quark_from_static_string ("nm_dhcp_manager_error");
 
-	g_assert (singleton);
-	return singleton;
+    return ret;
 }
 
-static void
-nm_dhcp_manager_init (NMDHCPManager *manager)
+GType
+nm_dhcp_manager_error_get_type (void)
 {
-}
-
-static void
-finalize (GObject *object)
-{
-	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (object);
-
-	if (priv->hostname_provider) {
-		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, object);
-		priv->hostname_provider = NULL;
-	}
+    static GType etype = 0;
 
-	g_hash_table_destroy (priv->devices);
-	g_object_unref (priv->proxy);
-	g_object_unref (priv->dbus_mgr);
-
-	G_OBJECT_CLASS (nm_dhcp_manager_parent_class)->finalize (object);
+    if (etype == 0) {
+        static const GEnumValue values[] = {
+            ENUM_ENTRY (NM_DHCP_MANAGER_ERROR_BAD_CLIENT, "BadClient"),
+            ENUM_ENTRY (NM_DHCP_MANAGER_ERROR_INTERNAL,   "InternalError"),
+            { 0, 0, 0 }
+        };
+        etype = g_enum_register_static ("NMDhcpManagerError", values);
+    }
+    return etype;
 }
 
-static void
-nm_dhcp_manager_class_init (NMDHCPManagerClass *manager_class)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (manager_class);
-
-	g_type_class_add_private (manager_class, sizeof (NMDHCPManagerPrivate));
-
-	/* virtual methods */
-	object_class->finalize = finalize;
-
-	/* signals */
-	signals[STATE_CHANGED] =
-		g_signal_new ("state-changed",
-					  G_OBJECT_CLASS_TYPE (object_class),
-					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMDHCPManagerClass, state_changed),
-					  NULL, NULL,
-					  _nm_marshal_VOID__STRING_UCHAR,
-					  G_TYPE_NONE, 2,
-					  G_TYPE_STRING,
-					  G_TYPE_UCHAR);
-
-	signals[TIMEOUT] =
-		g_signal_new ("timeout",
-					  G_OBJECT_CLASS_TYPE (object_class),
-					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMDHCPManagerClass, timeout),
-					  NULL, NULL,
-					  g_cclosure_marshal_VOID__STRING,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_STRING);
-}
-
-static gboolean state_is_bound (guint8 state)
-{
-	if ((state == DHC_BOUND)
-	    || (state == DHC_RENEW)
-	    || (state == DHC_REBOOT)
-	    || (state == DHC_REBIND)
-	    || (state == DHC_IPV4LL))
-		return TRUE;
-
-	return FALSE;
-}
-
-
-static void
-nm_dhcp_device_timeout_cleanup (NMDHCPDevice * device)
-{
-	if (device->timeout_id) {
-		g_source_remove (device->timeout_id);
-		device->timeout_id = 0;
-	}
-}
-
-static void
-nm_dhcp_device_watch_cleanup (NMDHCPDevice * device)
-{
-	if (device->watch_id) {
-		g_source_remove (device->watch_id);
-		device->watch_id = 0;
-	}
-}
-
-static void
-nm_dhcp_device_destroy (NMDHCPDevice *device)
-{
-	int ignored;
-
-	nm_dhcp_device_timeout_cleanup (device);
+#define NM_DHCP_CLIENT_DBUS_SERVICE "org.freedesktop.nm_dhcp_client"
+#define NM_DHCP_CLIENT_DBUS_IFACE   "org.freedesktop.nm_dhcp_client"
 
-	if (device->pid)
-		nm_dhcp_client_stop (device, device->pid);
+#define DHCP_TIMEOUT 45 /* default DHCP timeout, in seconds */
 
-	if (device->options)
-		g_hash_table_destroy (device->options);
+static NMDHCPManager *singleton = NULL;
 
-	if (device->conf_file) {
-		ignored = unlink (device->conf_file);
-		g_free (device->conf_file);
-	}
+typedef GSList * (*GetLeaseConfigFunc) (const char *iface, const char *uuid);
 
-	g_free (device->pid_file);
-	g_free (device->lease_file);
-	g_free (device->iface);
+typedef struct {
+	GType               client_type;
+	GetLeaseConfigFunc  get_lease_config_func;
 
-	g_slice_free (NMDHCPDevice, device);
-}
+	NMDBusManager *     dbus_mgr;
+	GHashTable *        clients;
+	DBusGProxy *        proxy;
+	NMHostnameProvider *hostname_provider;
+} NMDHCPManagerPrivate;
 
 
-static inline const char *
-state_to_string (guint32 state)
-{
-	switch (state)
-	{
-		case DHC_PREINIT:
-			return "preinit";
-		case DHC_BOUND:
-			return "bound";
-		case DHC_IPV4LL:
-			return "bound (ipv4ll)";
-		case DHC_RENEW:
-			return "renew";
-		case DHC_REBOOT:
-			return "reboot";
-		case DHC_REBIND:
-			return "rebind";
-		case DHC_STOP:
-			return "stop";
-		case DHC_MEDIUM:
-			return "medium";
-		case DHC_TIMEOUT:
-			return "timeout";
-		case DHC_FAIL:
-			return "fail";
-		case DHC_EXPIRE:
-			return "expire";
-		case DHC_RELEASE:
-			return "release";
-		case DHC_START:
-			return "successfully started";
-		case DHC_ABEND:
-			return "abnormal exit";
-		case DHC_END:
-			return "normal exit";
-		default:
-			break;
-	}
-	return NULL;
-}
+#define NM_DHCP_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_MANAGER, NMDHCPManagerPrivate))
 
-static inline guint32
-string_to_state (const char *state)
-{
-	if (strcmp("PREINIT", state) == 0)
-		return DHC_PREINIT;
-	else if (strcmp("BOUND", state) == 0)
-		return DHC_BOUND;
-	else if (strcmp("IPV4LL", state) == 0)
-		return DHC_IPV4LL;
-	else if (strcmp("RENEW", state) == 0)
-		return DHC_RENEW;
-	else if (strcmp("REBOOT", state) == 0)
-		return DHC_REBOOT;
-	else if (strcmp("REBIND", state) == 0)
-		return DHC_REBIND;
-	else if (strcmp("STOP", state) == 0)
-		return DHC_STOP;
-	else if (strcmp("MEDIUM", state) == 0)
-		return DHC_MEDIUM;
-	else if (strcmp("TIMEOUT", state) == 0)
-		return DHC_TIMEOUT;
-	else if (strcmp("FAIL", state) == 0)
-		return DHC_FAIL;
-	else if (strcmp("EXPIRE", state) == 0)
-		return DHC_EXPIRE;
-	else if (strcmp("RELEASE", state) == 0)
-		return DHC_RELEASE;
-	else if (strcmp("START", state) == 0)
-		return DHC_START;
-	else if (strcmp("ABEND", state) == 0)
-		return DHC_ABEND;
-	else if (strcmp("END", state) == 0)
-		return DHC_END;
-	else
-		return 255;
-}
+G_DEFINE_TYPE (NMDHCPManager, nm_dhcp_manager, G_TYPE_OBJECT)
 
 static char *
 garray_to_string (GArray *array, const char *key)
@@ -307,84 +125,78 @@ garray_to_string (GArray *array, const char *key)
 
 	converted = str->str;
 	if (!g_utf8_validate (converted, -1, NULL))
-		nm_warning ("%s: DHCP option '%s' couldn't be converted to UTF-8", __func__, key);
+		nm_log_warn (LOGD_DHCP, "DHCP option '%s' couldn't be converted to UTF-8", key);
 	g_string_free (str, FALSE);
 	return converted;
 }
 
-static char *
-get_option (GHashTable *hash, const char *key)
+static NMDHCPClient *
+get_client_for_pid (NMDHCPManager *manager, GPid pid)
 {
-	GValue *value;
+	NMDHCPManagerPrivate *priv;
+	GHashTableIter iter;
+	gpointer value;
 
-	value = g_hash_table_lookup (hash, key);
-	if (value == NULL)
-		return NULL;
+	g_return_val_if_fail (manager != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), NULL);
 
-	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
-		nm_warning ("Unexpected key %s value type was not "
-		            "DBUS_TYPE_G_UCHAR_ARRAY",
-		            (char *) key);
-		return NULL;
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+
+	g_hash_table_iter_init (&iter, priv->clients);
+	while (g_hash_table_iter_next (&iter, NULL, &value)) {
+		NMDHCPClient *candidate = NM_DHCP_CLIENT (value);
+
+		if (nm_dhcp_client_get_pid (candidate) == pid)
+			return candidate;
 	}
 
-	return garray_to_string ((GArray *) g_value_get_boxed (value), key);
+	return NULL;
 }
 
-static void
-copy_option (gpointer key,
-             gpointer value,
-             gpointer user_data)
+static NMDHCPClient *
+get_client_for_iface (NMDHCPManager *manager,
+                      const char *iface,
+                      gboolean ip6)
 {
-	NMDHCPDevice * device = (NMDHCPDevice *) user_data;
-	const char *str_key = (const char *) key;
-	char *str_value = NULL;
+	NMDHCPManagerPrivate *priv;
+	GHashTableIter iter;
+	gpointer value;
 
-	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
-		nm_warning ("Unexpected key %s value type was not "
-		            "DBUS_TYPE_G_UCHAR_ARRAY",
-		            str_key);
-		return;
+	g_return_val_if_fail (manager != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), NULL);
+	g_return_val_if_fail (iface, NULL);
+
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+
+	g_hash_table_iter_init (&iter, priv->clients);
+	while (g_hash_table_iter_next (&iter, NULL, &value)) {
+		NMDHCPClient *candidate = NM_DHCP_CLIENT (value);
+
+		if (   !strcmp (iface, nm_dhcp_client_get_iface (candidate))
+		    && (nm_dhcp_client_get_ipv6 (candidate) == ip6))
+			return candidate;
 	}
 
-	str_value = garray_to_string ((GArray *) g_value_get_boxed (value), str_key);
-	if (str_value)
-		g_hash_table_insert (device->options, g_strdup (str_key), str_value);
+	return NULL;
 }
 
-static void
-handle_options (NMDHCPManager * manager,
-                NMDHCPDevice * device,
-                GHashTable * options,
-                const char * reason)
+static char *
+get_option (GHashTable *hash, const char *key)
 {
-	guint32 old_state = device->state;
-	guint32 new_state = string_to_state (reason);
-
-	/* Clear old and save new DHCP options */
-	g_hash_table_remove_all (device->options);
-	g_hash_table_foreach (options, copy_option, device);
+	GValue *value;
 
-	if (old_state == new_state)
-		return;
+	value = g_hash_table_lookup (hash, key);
+	if (value == NULL)
+		return NULL;
 
-	/* Handle changed device state */
-	if (state_is_bound (new_state)) {
-		/* Cancel the timeout if the DHCP client is now bound */
-		nm_dhcp_device_timeout_cleanup (device);
+	if (G_VALUE_TYPE (value) != DBUS_TYPE_G_UCHAR_ARRAY) {
+		nm_log_warn (LOGD_DHCP, "unexpected key %s value type was not "
+		             "DBUS_TYPE_G_UCHAR_ARRAY",
+		             (char *) key);
+		return NULL;
 	}
 
-	device->state = new_state;
-	nm_info ("DHCP: device %s state changed %s -> %s",
-	         device->iface,
-	         state_to_string (old_state),
-	         state_to_string (device->state));
-
-	g_signal_emit (G_OBJECT (device->manager),
-	               signals[STATE_CHANGED],
-	               0,
-	               device->iface,
-	               device->state);
+	return garray_to_string ((GArray *) g_value_get_boxed (value), key);
 }
 
 static void
@@ -392,57 +204,54 @@ nm_dhcp_manager_handle_event (DBusGProxy *proxy,
                               GHashTable *options,
                               gpointer user_data)
 {
-	NMDHCPManager * manager;
-	NMDHCPManagerPrivate * priv;
-	NMDHCPDevice * device;
-	char * iface = NULL;
-	char * pid_str = NULL;
-	char * reason = NULL;
+	NMDHCPManager *manager;
+	NMDHCPManagerPrivate *priv;
+	NMDHCPClient *client;
+	char *iface = NULL;
+	char *pid_str = NULL;
+	char *reason = NULL;
 	unsigned long temp;
-	pid_t pid;
 
 	manager = NM_DHCP_MANAGER (user_data);
 	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
 
 	iface = get_option (options, "interface");
 	if (iface == NULL) {
-		nm_warning ("DHCP event didn't have associated interface.");
-		goto out;
-	}
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (device == NULL) {
-		nm_warning ("Unhandled DHCP event for interface %s", iface);
+		nm_log_warn (LOGD_DHCP, "DHCP event didn't have associated interface.");
 		goto out;
 	}
 
 	pid_str = get_option (options, "pid");
 	if (pid_str == NULL) {
-		nm_warning ("DHCP event didn't have associated PID.");
+		nm_log_warn (LOGD_DHCP, "DHCP event didn't have associated PID.");
 		goto out;
 	}
 
-	temp = strtoul(pid_str, NULL, 10);
+	temp = strtoul (pid_str, NULL, 10);
 	if ((temp == ULONG_MAX) && (errno == ERANGE)) {
-		nm_warning ("Couldn't convert PID");
+		nm_log_warn (LOGD_DHCP, "couldn't convert PID");
+		goto out;
+	}
+
+	client = get_client_for_pid (manager, (GPid) temp);
+	if (client == NULL) {
+		nm_log_warn (LOGD_DHCP, "unhandled DHCP event for interface %s", iface);
 		goto out;
 	}
 
-	pid = (pid_t) temp;
-	if (pid != device->pid) {
-		nm_warning ("Received DHCP event from unexpected PID %u (expected %u)",
-		            pid,
-		            device->pid);
+	if (strcmp (iface, nm_dhcp_client_get_iface (client))) {
+		nm_log_warn (LOGD_DHCP, "received DHCP event from unexpected interface '%s' (expected '%s')",
+		             iface, nm_dhcp_client_get_iface (client));
 		goto out;
 	}
 
 	reason = get_option (options, "reason");
 	if (reason == NULL) {
-		nm_warning ("DHCP event didn't have a reason");
+		nm_log_warn (LOGD_DHCP, "DHCP event didn't have a reason");
 		goto out;
 	}
 
-	handle_options (manager, device, options, reason);
+	nm_dhcp_client_new_options (client, options, reason);
 
 out:
 	g_free (iface);
@@ -450,37 +259,91 @@ out:
 	g_free (reason);
 }
 
-static NMDHCPManager *
-nm_dhcp_manager_new (void)
+static GType
+get_client_type (const char *client, GError **error)
 {
-	NMDHCPManager *manager;
-	NMDHCPManagerPrivate *priv;
-	DBusGConnection * g_connection;
+	const char *dhclient_path = NULL;
+	const char *dhcpcd_path = NULL;
 
-	manager = g_object_new (NM_TYPE_DHCP_MANAGER, NULL);
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+	dhclient_path = nm_dhcp_dhclient_get_path (DHCLIENT_PATH);
+	dhcpcd_path = nm_dhcp_dhcpcd_get_path (DHCPCD_PATH);
 
-	priv->devices = g_hash_table_new_full (g_str_hash, g_str_equal,
-										   NULL,
-										   (GDestroyNotify) nm_dhcp_device_destroy);
-	if (!priv->devices) {
-		nm_warning ("Error: not enough memory to initialize DHCP manager "
-		            "tables");
-		g_object_unref (manager);
-		manager = NULL;
-		goto out;
+	if (!client) {
+		if (dhclient_path)
+			return NM_TYPE_DHCP_DHCLIENT;
+		else if (dhcpcd_path)
+			return NM_TYPE_DHCP_DHCPCD;
+		else {
+			g_set_error_literal (error,
+			                     NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+			                     _("no usable DHCP client could be found."));
+			return 0;
+		}
+	}
+
+	if (!strcmp (client, "dhclient")) {
+		if (!dhclient_path) {
+			g_set_error_literal (error,
+			                     NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+			                     _("'dhclient' could be found."));
+			return 0;
+		}
+		return NM_TYPE_DHCP_DHCLIENT;
+	}
+
+	if (!strcmp (client, "dhcpcd")) {
+		if (!dhcpcd_path) {
+			g_set_error_literal (error,
+			                     NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+			                     _("'dhcpcd' could be found."));
+			return 0;
+		}
+		return NM_TYPE_DHCP_DHCPCD;
 	}
 
+	g_set_error (error,
+	             NM_DHCP_MANAGER_ERROR, NM_DHCP_MANAGER_ERROR_BAD_CLIENT,
+	             _("unsupported DHCP client '%s'"), client);
+	return 0;
+}
+
+NMDHCPManager *
+nm_dhcp_manager_new (const char *client, GError **error)
+{
+	NMDHCPManagerPrivate *priv;
+	DBusGConnection *g_connection;
+	GType client_type;
+
+	client_type = get_client_type (client, error);
+	if (!client_type)
+		return NULL;
+
+	g_warn_if_fail (singleton == NULL);
+
+	singleton = g_object_new (NM_TYPE_DHCP_MANAGER, NULL);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (singleton);
+
+	/* Client-specific setup */
+	priv->client_type = client_type;
+	if (priv->client_type == NM_TYPE_DHCP_DHCLIENT)
+		priv->get_lease_config_func = nm_dhcp_dhclient_get_lease_config;
+	else if (priv->client_type == NM_TYPE_DHCP_DHCPCD)
+		priv->get_lease_config_func = nm_dhcp_dhcpcd_get_lease_config;
+	else
+		g_assert_not_reached ();
+
+	priv->clients = g_hash_table_new_full (g_direct_hash, g_direct_equal,
+	                                       NULL,
+	                                       (GDestroyNotify) g_object_unref);
+	g_assert (priv->clients);
+
 	priv->dbus_mgr = nm_dbus_manager_get ();
 	g_connection = nm_dbus_manager_get_connection (priv->dbus_mgr);
 	priv->proxy = dbus_g_proxy_new_for_name (g_connection,
 	                                         NM_DHCP_CLIENT_DBUS_SERVICE,
 	                                         "/",
 	                                         NM_DHCP_CLIENT_DBUS_IFACE);
-	if (!priv->proxy) {
-		nm_warning ("Error: could not init DHCP manager proxy");
-		g_object_unref (manager);
-	}
+	g_assert (priv->proxy);
 
 	dbus_g_proxy_add_signal (priv->proxy,
 	                         "Event",
@@ -488,649 +351,303 @@ nm_dhcp_manager_new (void)
 	                         G_TYPE_INVALID);
 
 	dbus_g_proxy_connect_signal (priv->proxy, "Event",
-								 G_CALLBACK (nm_dhcp_manager_handle_event),
-								 manager,
-								 NULL);
+	                             G_CALLBACK (nm_dhcp_manager_handle_event),
+	                             singleton,
+	                             NULL);
 
-out:
-	return manager;
+	return singleton;
 }
 
+#define STATE_ID_TAG "state-id"
+#define TIMEOUT_ID_TAG "timeout-id"
 
-/*
- * nm_dhcp_manager_handle_timeout
- *
- * Called after timeout of a DHCP transaction to notify device of the failure.
- *
- */
-static gboolean
-nm_dhcp_manager_handle_timeout (gpointer user_data)
+static void
+remove_client (NMDHCPManager *self, NMDHCPClient *client)
 {
-	NMDHCPDevice *device = (NMDHCPDevice *) user_data;
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
+	guint id;
 
-	nm_info ("(%s): DHCP transaction took too long, stopping it.", device->iface);
+	id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (client), STATE_ID_TAG));
+	if (id)
+		g_signal_handler_disconnect (client, id);
 
-	nm_dhcp_manager_cancel_transaction (device->manager, device->iface);
+	id = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (client), TIMEOUT_ID_TAG));
+	if (id)
+		g_signal_handler_disconnect (client, id);
 
-	g_signal_emit (G_OBJECT (device->manager), signals[TIMEOUT], 0, device->iface);
+	/* Stopping the client is left up to the controlling device
+	 * explicitly since we may want to quit NetworkManager but not terminate
+	 * the DHCP client.
+	 */
 
-	return FALSE;
+	g_hash_table_remove (priv->clients, client);
 }
 
-static NMDHCPDevice *
-nm_dhcp_device_new (NMDHCPManager *manager, const char *iface)
+static void
+client_state_changed (NMDHCPClient *client, NMDHCPState new_state, gpointer user_data)
 {
-	NMDHCPDevice *device;
-	GHashTable * hash = NM_DHCP_MANAGER_GET_PRIVATE (manager)->devices;
-
-	device = g_slice_new0 (NMDHCPDevice);
-	if (!device) {
-		nm_warning ("%s: Out of memory creating DHCP transaction object.", iface);
-		return NULL;
-	}
-
-	device->iface = g_strdup (iface);
-	if (!device) {
-		nm_warning ("%s: Out of memory creating DHCP transaction object "
-		            "property 'iface'.",
-		            iface);
-		goto error;
-	}
-	
-	device->manager = manager;
-
-	/* Do this after the transaction cancel since that clears options out */
-	device->options = g_hash_table_new_full (g_str_hash,
-	                                         g_str_equal,
-	                                         g_free,
-	                                         g_free);
-	if (!device->options) {
-		nm_warning ("%s: Out of memory creating DHCP transaction object "
-		            "property 'options'.",
-		            iface);
-		goto error;
-	}
-
-	g_hash_table_insert (hash, device->iface, device);
-	return device;
-
-error:
-	nm_dhcp_device_destroy (device);
-	return NULL;
+	if (new_state == DHC_ABEND || new_state == DHC_END)
+		remove_client (NM_DHCP_MANAGER (user_data), client);
 }
 
+static void
+client_timeout (NMDHCPClient *client, gpointer user_data)
+{
+	remove_client (NM_DHCP_MANAGER (user_data), client);
+}
 
-/*
- * dhcp_watch_cb
- *
- * Watch our child dhclient process and get notified of events from it.
- *
- */
-static void dhcp_watch_cb (GPid pid, gint status, gpointer user_data)
+static void
+add_client (NMDHCPManager *self, NMDHCPClient *client)
 {
-	NMDHCPDevice *device = (NMDHCPDevice *)user_data;
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
+	guint id;
 
-	if (!WIFEXITED (status)) {
-		device->state = DHC_ABEND;
-		nm_warning ("dhcp client died abnormally");
-	}
-	device->pid = 0;
+	id = g_signal_connect (client, "state-changed", G_CALLBACK (client_state_changed), self);
+	g_object_set_data (G_OBJECT (client), STATE_ID_TAG, GUINT_TO_POINTER (id));
 
-	nm_dhcp_device_watch_cleanup (device);
-	nm_dhcp_device_timeout_cleanup (device);
+	id = g_signal_connect (client, "timeout", G_CALLBACK (client_timeout), self);
+	g_object_set_data (G_OBJECT (client), TIMEOUT_ID_TAG, GUINT_TO_POINTER (id));
 
-	g_signal_emit (G_OBJECT (device->manager), signals[STATE_CHANGED], 0, device->iface, device->state);
+	g_hash_table_insert (priv->clients, client, g_object_ref (client));
 }
 
-gboolean
-nm_dhcp_manager_begin_transaction (NMDHCPManager *manager,
-                                   const char *iface,
-                                   const char *uuid,
-                                   NMSettingIP4Config *s_ip4,
-                                   guint32 timeout,
-                                   guint8 *dhcp_anycast_addr)
+static NMDHCPClient *
+client_start (NMDHCPManager *self,
+              const char *iface,
+              const char *uuid,
+              gboolean ipv6,
+              NMSettingIP4Config *s_ip4,
+              NMSettingIP6Config *s_ip6,
+              guint32 timeout,
+              guint8 *dhcp_anycast_addr,
+              gboolean info_only)
 {
 	NMDHCPManagerPrivate *priv;
-	NMDHCPDevice *device;
-	NMSettingIP4Config *setting;
-
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), FALSE);
-	g_return_val_if_fail (iface != NULL, FALSE);
+	NMDHCPClient *client;
+	gboolean success = FALSE;
 
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+	g_return_val_if_fail (self, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
+	g_return_val_if_fail (iface != NULL, NULL);
+	g_return_val_if_fail (uuid != NULL, NULL);
 
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (!device)
-		device = nm_dhcp_device_new (manager, iface);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
 
-	if (device->pid && (device->state < DHC_ABEND)) {
-		/* Cancel any DHCP transaction already in progress */
-		nm_dhcp_manager_cancel_transaction_real (device);
-	}
+	/* Kill any old client instance */
+	client = get_client_for_iface (self, iface, ipv6);
+	if (client) {
+		nm_dhcp_client_stop (client);
+		remove_client (self, client);
+	}
+
+	/* And make a new one */
+	client = g_object_new (priv->client_type,
+	                       NM_DHCP_CLIENT_INTERFACE, iface,
+	                       NM_DHCP_CLIENT_IPV6, ipv6,
+	                       NM_DHCP_CLIENT_UUID, uuid,
+	                       NM_DHCP_CLIENT_TIMEOUT, timeout ? timeout : DHCP_TIMEOUT,
+	                       NULL);
+	g_return_val_if_fail (client != NULL, NULL);
+	add_client (self, client);
+
+	if (ipv6)
+		success = nm_dhcp_client_start_ip6 (client, s_ip6, dhcp_anycast_addr, info_only);
+	else
+		success = nm_dhcp_client_start_ip4 (client, s_ip4, dhcp_anycast_addr);
 
-	if (s_ip4 && 
-		nm_setting_ip4_config_get_dhcp_send_hostname (s_ip4) &&
-		nm_setting_ip4_config_get_dhcp_hostname (s_ip4) == NULL &&
-		priv->hostname_provider != NULL) {
-		/* We're asked to send the hostname to DHCP server,
-		   the hostname isn't specified,
-		   and a hostname provider is registered: use that */
-
-		setting = NM_SETTING_IP4_CONFIG (nm_setting_duplicate (NM_SETTING (s_ip4)));
-		g_object_set (G_OBJECT (setting),
-					  NM_SETTING_IP4_CONFIG_DHCP_HOSTNAME,
-					  nm_hostname_provider_get_hostname (priv->hostname_provider),
-					  NULL);
-	} else {
-		setting = s_ip4 ? g_object_ref (s_ip4) : NULL;
+	if (!success) {
+		remove_client (self, client);
+		g_object_unref (client);
+		client = NULL;
 	}
 
-	if (timeout == 0)
-		timeout = NM_DHCP_TIMEOUT;
-
-	nm_info ("Activation (%s) Beginning DHCP transaction (timeout in %d seconds)",
-	         iface, timeout);
-	device->pid = nm_dhcp_client_start (device, uuid, setting, dhcp_anycast_addr);
-
-	if (setting)
-		g_object_unref (setting);
-
-	if (device->pid == 0)
-		return FALSE;
-
-	/* Set up a timeout on the transaction to kill it after the timeout */
-	device->timeout_id = g_timeout_add_seconds (timeout,
-	                                            nm_dhcp_manager_handle_timeout,
-	                                            device);
-	device->watch_id = g_child_watch_add (device->pid,
-					      (GChildWatchFunc) dhcp_watch_cb,
-					      device);
-	return TRUE;
+	return client;
 }
 
-void
-nm_dhcp_client_stop (NMDHCPDevice *device, pid_t pid)
+/* Caller owns a reference to the NMDHCPClient on return */
+NMDHCPClient *
+nm_dhcp_manager_start_ip4 (NMDHCPManager *self,
+                           const char *iface,
+                           const char *uuid,
+                           NMSettingIP4Config *s_ip4,
+                           guint32 timeout,
+                           guint8 *dhcp_anycast_addr)
 {
-	int i = 15; /* 3 seconds */
-
-	g_return_if_fail (pid > 0);
-
-	/* Clean up the watch handler since we're explicitly killing
-	 * the daemon
-	 */
-	nm_dhcp_device_watch_cleanup (device);
-
-	/* Tell it to quit; maybe it wants to send out a RELEASE message */
-	kill (pid, SIGTERM);
-
-	while (i-- > 0) {
-		gint child_status;
-		int ret;
-
-		ret = waitpid (pid, &child_status, WNOHANG);
-		if (ret > 0)
-			break;
-
-		if (ret == -1) {
-			/* Child already exited */
-			if (errno == ECHILD)
-				break;
-			/* Took too long; shoot it in the head */
-			i = 0;
-			break;
-		}
-		g_usleep (G_USEC_PER_SEC / 5);
-	}
-
-	if (i <= 0) {
-		nm_warning ("%s: dhcp client pid %d didn't exit, will kill it.", device->iface, pid);
-		kill (pid, SIGKILL);
-
-		nm_debug ("waiting for dhcp client pid %d to exit", pid);
-		waitpid (pid, NULL, 0);
-		nm_debug ("dhcp client pid %d cleaned up", pid);
-	}
-}
+	NMDHCPManagerPrivate *priv;
+	NMDHCPClient *client = NULL;
 
-static void
-nm_dhcp_manager_cancel_transaction_real (NMDHCPDevice *device)
-{
-	g_return_if_fail (device->pid > 0);
+	g_return_val_if_fail (self, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
 
-	nm_dhcp_client_stop (device, device->pid);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
 
-	nm_info ("(%s): canceled DHCP transaction, dhcp client pid %d",
-	         device->iface,
-	         device->pid);
+	if (s_ip4) {
+		if (   nm_setting_ip4_config_get_dhcp_send_hostname (s_ip4)
+		    && (nm_setting_ip4_config_get_dhcp_hostname (s_ip4) == NULL)
+		    && priv->hostname_provider != NULL) {
 
-	device->pid = 0;
-	device->state = DHC_END;
+			s_ip4 = NM_SETTING_IP4_CONFIG (nm_setting_duplicate (NM_SETTING (s_ip4)));
 
-	/* Clean up the pidfile if it got left around */
-	if (device->pid_file) {
-		remove (device->pid_file);
-		g_free (device->pid_file);
-		device->pid_file = NULL;
+			/* We're asked to send the hostname to DHCP server, the hostname
+			 * isn't specified, and a hostname provider is registered: use that
+			 */
+			g_object_set (G_OBJECT (s_ip4),
+						  NM_SETTING_IP4_CONFIG_DHCP_HOSTNAME,
+						  nm_hostname_provider_get_hostname (priv->hostname_provider),
+						  NULL);
+		} else
+			g_object_ref (s_ip4);
 	}
 
-	/* Free leasefile (but don't delete) */
-	if (device->lease_file) {
-		g_free (device->lease_file);
-		device->lease_file = NULL;
-	}
+	client = client_start (self, iface, uuid, FALSE, s_ip4, NULL, timeout, dhcp_anycast_addr, FALSE);
 
-	/* Clean up config file if it got left around */
-	if (device->conf_file) {
-		remove (device->conf_file);
-		g_free (device->conf_file);
-		device->conf_file = NULL;
-	}
+	if (s_ip4)
+		g_object_unref (s_ip4);
 
-	nm_dhcp_device_timeout_cleanup (device);
-	g_hash_table_remove_all (device->options);
+	return client;
 }
 
-
-/*
- * nm_dhcp_manager_cancel_transaction
- *
- * Stop any in-progress DHCP transaction on a particular device.
- *
- */
-void
-nm_dhcp_manager_cancel_transaction (NMDHCPManager *manager,
-                                    const char *iface)
+/* Caller owns a reference to the NMDHCPClient on return */
+NMDHCPClient *
+nm_dhcp_manager_start_ip6 (NMDHCPManager *self,
+                           const char *iface,
+                           const char *uuid,
+                           NMSettingIP6Config *s_ip6,
+                           guint32 timeout,
+                           guint8 *dhcp_anycast_addr,
+                           gboolean info_only)
 {
-	NMDHCPDevice *device;
-	NMDHCPManagerPrivate *priv;
-
-	g_return_if_fail (NM_IS_DHCP_MANAGER (manager));
-	g_return_if_fail (iface != NULL);
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-
-	if (!device || !device->pid)
-		return;
-
-	nm_dhcp_manager_cancel_transaction_real (device);
+	return client_start (self, iface, uuid, TRUE, NULL, s_ip6, timeout, dhcp_anycast_addr, info_only);
 }
 
 static void
-process_classful_routes (GHashTable *options, NMIP4Config *ip4_config)
+hostname_provider_destroyed (gpointer data, GObject *destroyed_object)
 {
-	const char *str;
-	char **searches, **s;
-
-	str = g_hash_table_lookup (options, "new_static_routes");
-	if (!str)
-		return;
-
-	searches = g_strsplit (str, " ", 0);
-	if ((g_strv_length (searches) % 2)) {
-		nm_info ("  static routes provided, but invalid");
-		goto out;
-	}
-
-	for (s = searches; *s; s += 2) {
-		NMIP4Route *route;
-		struct in_addr rt_addr;
-		struct in_addr rt_route;
-
-		if (inet_pton (AF_INET, *s, &rt_addr) <= 0) {
-			nm_warning ("DHCP provided invalid static route address: '%s'", *s);
-			continue;
-		}
-		if (inet_pton (AF_INET, *(s + 1), &rt_route) <= 0) {
-			nm_warning ("DHCP provided invalid static route gateway: '%s'", *(s + 1));
-			continue;
-		}
-
-		// FIXME: ensure the IP addresse and route are sane
-
-		route = nm_ip4_route_new ();
-		nm_ip4_route_set_dest (route, (guint32) rt_addr.s_addr);
-		nm_ip4_route_set_prefix (route, 32); /* 255.255.255.255 */
-		nm_ip4_route_set_next_hop (route, (guint32) rt_route.s_addr);
-
-		nm_ip4_config_take_route (ip4_config, route);
-		nm_info ("  static route %s gw %s", *s, *(s + 1));
-	}
-
-out:
-	g_strfreev (searches);
+	NM_DHCP_MANAGER_GET_PRIVATE (data)->hostname_provider = NULL;
 }
 
-static void
-process_domain_search (NMIP4Config *ip4_config, const char *str)
+void
+nm_dhcp_manager_set_hostname_provider (NMDHCPManager *manager,
+									   NMHostnameProvider *provider)
 {
-	char **searches, **s;
-	char *unescaped, *p;
-	int i;
-
-	g_return_if_fail (str != NULL);
-	g_return_if_fail (ip4_config != NULL);
+	NMDHCPManagerPrivate *priv;
 
-	p = unescaped = g_strdup (str);
-	do {
-		p = strstr (p, "\\032");
-		if (!p)
-			break;
+	g_return_if_fail (NM_IS_DHCP_MANAGER (manager));
 
-		/* Clear the escaped space with real spaces */
-		for (i = 0; i < 4; i++)
-			*p++ = ' ';
-	} while (*p++);
+	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
 
-	if (strchr (unescaped, '\\')) {
-		nm_info ("  invalid domain search: '%s'", unescaped);
-		goto out;
+	if (priv->hostname_provider) {
+		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, manager);
+		priv->hostname_provider = NULL;
 	}
 
-	searches = g_strsplit (unescaped, " ", 0);
-	for (s = searches; *s; s++) {
-		if (strlen (*s)) {
-			nm_info ("  domain search '%s'", *s);
-			nm_ip4_config_add_search (ip4_config, *s);
-		}
+	if (provider) {
+		priv->hostname_provider = provider;
+		g_object_weak_ref (G_OBJECT (provider), hostname_provider_destroyed, manager);
 	}
-	g_strfreev (searches);
-
-out:
-	g_free (unescaped);
 }
 
-/* Given a table of DHCP options from the client, convert into an IP4Config */
-NMIP4Config *
-nm_dhcp_manager_options_to_ip4_config (const char *iface, GHashTable *options)
+GSList *
+nm_dhcp_manager_get_lease_config (NMDHCPManager *self,
+                                  const char *iface,
+                                  const char *uuid)
 {
-	NMIP4Config *ip4_config = NULL;
-	struct in_addr tmp_addr;
-	NMIP4Address *addr = NULL;
-	char *str = NULL;
-	guint32 gwaddr = 0;
-	gboolean have_classless = FALSE;
-
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
 	g_return_val_if_fail (iface != NULL, NULL);
-	g_return_val_if_fail (options != NULL, NULL);
-
-	ip4_config = nm_ip4_config_new ();
-	if (!ip4_config) {
-		nm_warning ("%s: couldn't allocate memory for an IP4Config!", iface);
-		return NULL;
-	}
-
-	addr = nm_ip4_address_new ();
-	if (!addr) {
-		nm_warning ("%s: couldn't allocate memory for an IP4 Address!", iface);
-		goto error;
-	}
-
-	str = g_hash_table_lookup (options, "new_ip_address");
-	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
-		nm_ip4_address_set_address (addr, tmp_addr.s_addr);
-		nm_info ("  address %s", str);
-	} else
-		goto error;
-
-	str = g_hash_table_lookup (options, "new_subnet_mask");
-	if (str && (inet_pton (AF_INET, str, &tmp_addr) > 0)) {
-		nm_ip4_address_set_prefix (addr, nm_utils_ip4_netmask_to_prefix (tmp_addr.s_addr));
-		nm_info ("  prefix %d (%s)", nm_ip4_address_get_prefix (addr), str);
-	}
-
-	/* Routes: if the server returns classless static routes, we MUST ignore
-	 * the 'static_routes' option.
-	 */
-	have_classless = nm_dhcp_client_process_classless_routes (options, ip4_config, &gwaddr);
-	if (!have_classless) {
-		gwaddr = 0;  /* Ensure client code doesn't lie */
-		process_classful_routes (options, ip4_config);
-	}
-
-	if (gwaddr) {
-		char buf[INET_ADDRSTRLEN + 1];
-
-		inet_ntop (AF_INET, &gwaddr, buf, sizeof (buf));
-		nm_info ("  gateway %s", buf);
-		nm_ip4_address_set_gateway (addr, gwaddr);
-	} else {
-		/* If the gateway wasn't provided as a classless static route with a
-		 * subnet length of 0, try to find it using the old-style 'routers' option.
-		 */
-		str = g_hash_table_lookup (options, "new_routers");
-		if (str) {
-			char **routers = g_strsplit (str, " ", 0);
-			char **s;
-
-			for (s = routers; *s; s++) {
-				/* FIXME: how to handle multiple routers? */
-				if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
-					nm_ip4_address_set_gateway (addr, tmp_addr.s_addr);
-					nm_info ("  gateway %s", *s);
-					break;
-				} else
-					nm_warning ("Ignoring invalid gateway '%s'", *s);
-			}
-			g_strfreev (routers);
-		}
-	}
-
-	nm_ip4_config_take_address (ip4_config, addr);
-	addr = NULL;
-
-	str = g_hash_table_lookup (options, "new_host_name");
-	if (str)
-		nm_info ("  hostname '%s'", str);
-
-	str = g_hash_table_lookup (options, "new_domain_name_servers");
-	if (str) {
-		char **searches = g_strsplit (str, " ", 0);
-		char **s;
-
-		for (s = searches; *s; s++) {
-			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
-				nm_ip4_config_add_nameserver (ip4_config, tmp_addr.s_addr);
-				nm_info ("  nameserver '%s'", *s);
-			} else
-				nm_warning ("Ignoring invalid nameserver '%s'", *s);
-		}
-		g_strfreev (searches);
-	}
-
-	str = g_hash_table_lookup (options, "new_domain_name");
-	if (str) {
-		char **domains = g_strsplit (str, " ", 0);
-		char **s;
-
-		for (s = domains; *s; s++) {
-			nm_info ("  domain name '%s'", *s);
-			nm_ip4_config_add_domain (ip4_config, *s);
-		}
-		g_strfreev (domains);
-	}
-
-	str = g_hash_table_lookup (options, "new_domain_search");
-	if (str)
-		process_domain_search (ip4_config, str);
-
-	str = g_hash_table_lookup (options, "new_netbios_name_servers");
-	if (str) {
-		char **searches = g_strsplit (str, " ", 0);
-		char **s;
-
-		for (s = searches; *s; s++) {
-			if (inet_pton (AF_INET, *s, &tmp_addr) > 0) {
-				nm_ip4_config_add_wins (ip4_config, tmp_addr.s_addr);
-				nm_info ("  wins '%s'", *s);
-			} else
-				nm_warning ("Ignoring invalid WINS server '%s'", *s);
-		}
-		g_strfreev (searches);
-	}
-
-	str = g_hash_table_lookup (options, "new_interface_mtu");
-	if (str) {
-		int int_mtu;
-
-		errno = 0;
-		int_mtu = strtol (str, NULL, 10);
-		if ((errno == EINVAL) || (errno == ERANGE))
-			goto error;
-
-		if (int_mtu > 576)
-			nm_ip4_config_set_mtu (ip4_config, int_mtu);
-	}
-
-	return ip4_config;
+	g_return_val_if_fail (uuid != NULL, NULL);
 
-error:
-	if (addr)
-		nm_ip4_address_unref (addr);
-	g_object_unref (ip4_config);
-	return NULL;
+	return NM_DHCP_MANAGER_GET_PRIVATE (self)->get_lease_config_func (iface, uuid);
 }
 
-/*
- * nm_dhcp_manager_get_ip4_config
- *
- * Get IP4 configuration values from the DHCP daemon
- *
- */
 NMIP4Config *
-nm_dhcp_manager_get_ip4_config (NMDHCPManager *manager,
-                                const char *iface)
-{
-	NMDHCPManagerPrivate *priv;
-	NMDHCPDevice *device;
-
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (manager), NULL);
-	g_return_val_if_fail (iface != NULL, NULL);
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (!device) {
-		nm_warning ("Device '%s' transaction not started.", iface);
+nm_dhcp_manager_test_ip4_options_to_config (const char *dhcp_client,
+                                            const char *iface,
+                                            GHashTable *options,
+                                            const char *reason)
+{
+	NMDHCPClient *client;
+	NMIP4Config *config;
+	GType client_type;
+	GError *error = NULL;
+
+	client_type = get_client_type (dhcp_client, &error);
+	if (!client_type) {
+		nm_log_err (LOGD_DHCP4, "error: %s", error ? error->message : "(unknown)");
+		g_clear_error (&error);
 		return NULL;
 	}
 
-	if (!state_is_bound (device->state)) {
-		nm_warning ("%s: dhcp client didn't bind to a lease.", device->iface);
-		return NULL;
-	}
+	client = (NMDHCPClient *) g_object_new (client_type,
+	                                        NM_DHCP_CLIENT_INTERFACE, iface,
+	                                        NULL);
+	g_return_val_if_fail (client != NULL, NULL);
+	nm_dhcp_client_new_options (client, options, reason);
+	config = nm_dhcp_client_get_ip4_config (client, TRUE);
+	g_object_unref (client);
 
-	return nm_dhcp_manager_options_to_ip4_config (iface, device->options);
+	return config;
 }
 
-#define NEW_TAG "new_"
-#define OLD_TAG "old_"
+/***************************************************/
 
-typedef struct {
-	GHFunc func;
-	gpointer user_data;
-} Dhcp4ForeachInfo;
+NMDHCPManager *
+nm_dhcp_manager_get (void)
+{
+	g_warn_if_fail (singleton != NULL);
+	return g_object_ref (singleton);
+}
 
 static void
-iterate_dhcp4_config_option (gpointer key,
-                             gpointer value,
-                             gpointer user_data)
+nm_dhcp_manager_init (NMDHCPManager *manager)
 {
-	Dhcp4ForeachInfo *info = (Dhcp4ForeachInfo *) user_data;
-	char *tmp_key = NULL;
-	const char **p;
-	static const char *filter_options[] = {
-		"interface", "pid", "reason", "dhcp_message_type", NULL
-	};
-	
-	/* Filter out stuff that's not actually new DHCP options */
-	for (p = filter_options; *p; p++) {
-		if (!strcmp (*p, (const char *) key))
-			return;
-		if (!strncmp ((const char *) key, OLD_TAG, strlen (OLD_TAG)))
-			return;
-	}
-
-	/* Remove the "new_" prefix that dhclient passes back */
-	if (!strncmp ((const char *) key, NEW_TAG, strlen (NEW_TAG)))
-		tmp_key = g_strdup ((const char *) (key + strlen (NEW_TAG)));
-	else
-		tmp_key = g_strdup ((const char *) key);
-
-	(*info->func) ((gpointer) tmp_key, value, info->user_data);
-	g_free (tmp_key);
 }
 
-gboolean
-nm_dhcp_manager_foreach_dhcp4_option (NMDHCPManager *self,
-                                      const char *iface,
-                                      GHFunc func,
-                                      gpointer user_data)
+static void
+dispose (GObject *object)
 {
-	NMDHCPManagerPrivate *priv;
-	NMDHCPDevice *device;
-	Dhcp4ForeachInfo info = { NULL, NULL };
-
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), FALSE);
-	g_return_val_if_fail (iface != NULL, FALSE);
-	g_return_val_if_fail (func != NULL, FALSE);
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (self);
-
-	device = (NMDHCPDevice *) g_hash_table_lookup (priv->devices, iface);
-	if (!device) {
-		nm_warning ("Device '%s' transaction not started.", iface);
-		return FALSE;
-	}
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (object);
+	GList *values, *iter;
 
-	if (!state_is_bound (device->state)) {
-		nm_warning ("%s: dhclient didn't bind to a lease.", device->iface);
-		return FALSE;
+	if (priv->clients) {
+		values = g_hash_table_get_values (priv->clients);
+		for (iter = values; iter; iter = g_list_next (iter))
+			remove_client (NM_DHCP_MANAGER (object), NM_DHCP_CLIENT (iter->data));
+		g_list_free (values);
 	}
 
-	info.func = func;
-	info.user_data = user_data;
-	g_hash_table_foreach (device->options, iterate_dhcp4_config_option, &info);
-	return TRUE;
+	G_OBJECT_CLASS (nm_dhcp_manager_parent_class)->dispose (object);
 }
 
 static void
-hostname_provider_destroyed (gpointer data, GObject *destroyed_object)
-{
-	NM_DHCP_MANAGER_GET_PRIVATE (data)->hostname_provider = NULL;
-}
-
-void
-nm_dhcp_manager_set_hostname_provider (NMDHCPManager *manager,
-									   NMHostnameProvider *provider)
+finalize (GObject *object)
 {
-	NMDHCPManagerPrivate *priv;
-
-	g_return_if_fail (NM_IS_DHCP_MANAGER (manager));
-
-	priv = NM_DHCP_MANAGER_GET_PRIVATE (manager);
+	NMDHCPManagerPrivate *priv = NM_DHCP_MANAGER_GET_PRIVATE (object);
 
 	if (priv->hostname_provider) {
-		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, manager);
+		g_object_weak_unref (G_OBJECT (priv->hostname_provider), hostname_provider_destroyed, object);
 		priv->hostname_provider = NULL;
 	}
 
-	if (provider) {
-		priv->hostname_provider = provider;
-		g_object_weak_ref (G_OBJECT (provider), hostname_provider_destroyed, manager);
-	}
+	if (priv->clients)
+		g_hash_table_destroy (priv->clients);
+	if (priv->proxy)
+		g_object_unref (priv->proxy);
+	if (priv->dbus_mgr)
+		g_object_unref (priv->dbus_mgr);
+
+	G_OBJECT_CLASS (nm_dhcp_manager_parent_class)->finalize (object);
 }
 
-GSList *
-nm_dhcp_manager_get_lease_ip4_config (NMDHCPManager *self,
-                                      const char *iface,
-                                      const char *uuid)
+static void
+nm_dhcp_manager_class_init (NMDHCPManagerClass *manager_class)
 {
-	g_return_val_if_fail (NM_IS_DHCP_MANAGER (self), NULL);
-	g_return_val_if_fail (iface != NULL, NULL);
-	g_return_val_if_fail (uuid != NULL, NULL);
+	GObjectClass *object_class = G_OBJECT_CLASS (manager_class);
+
+	g_type_class_add_private (manager_class, sizeof (NMDHCPManagerPrivate));
 
-	return nm_dhcp_client_get_lease_ip4_config (iface, uuid);
+	/* virtual methods */
+	object_class->finalize = finalize;
+	object_class->dispose = dispose;
 }
 
diff --git a/src/dhcp-manager/nm-dhcp-manager.h b/src/dhcp-manager/nm-dhcp-manager.h
index 1240084..9d83d09 100644
--- a/src/dhcp-manager/nm-dhcp-manager.h
+++ b/src/dhcp-manager/nm-dhcp-manager.h
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -26,12 +26,24 @@
 #include <glib-object.h>
 
 #include <nm-setting-ip4-config.h>
+#include <nm-setting-ip6-config.h>
 
+#include "nm-dhcp-client.h"
 #include "nm-ip4-config.h"
 #include "nm-dhcp4-config.h"
 #include "nm-hostname-provider.h"
 
-#define NM_DHCP_MANAGER_RUN_DIR		LOCALSTATEDIR "/run"
+enum {
+    NM_DHCP_MANAGER_ERROR_BAD_CLIENT = 0,
+    NM_DHCP_MANAGER_ERROR_INTERNAL = 1,
+};
+
+#define NM_DHCP_MANAGER_ERROR (nm_dhcp_manager_error_quark ())
+#define NN_TYPE_DHCP_MANAGER_ERROR (nm_dhcp_manager_error_get_type ())
+
+GQuark nm_dhcp_manager_error_quark    (void);
+GType  nm_dhcp_manager_error_get_type (void);
+
 
 #define NM_TYPE_DHCP_MANAGER            (nm_dhcp_manager_get_type ())
 #define NM_DHCP_MANAGER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP_MANAGER, NMDHCPManager))
@@ -40,93 +52,47 @@
 #define NM_IS_DHCP_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP_MANAGER))
 #define NM_DHCP_MANAGER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP_MANAGER, NMDHCPManagerClass))
 
-typedef enum {
-	DHC_NBI=0,		/* no broadcast interfaces found */
-	DHC_PREINIT,		/* configuration started */
-	DHC_BOUND,		/* lease obtained */
-	DHC_IPV4LL,		/* IPv4LL address obtained */
-	DHC_RENEW,		/* lease renewed */
-	DHC_REBOOT,		/* have valid lease, but now obtained a different one */
-	DHC_REBIND,		/* new, different lease */
-	DHC_STOP,		/* remove old lease */
-	DHC_MEDIUM,		/* media selection begun */
-	DHC_TIMEOUT,		/* timed out contacting DHCP server */
-	DHC_FAIL,		/* all attempts to contact server timed out, sleeping */
-	DHC_EXPIRE,		/* lease has expired, renewing */
-	DHC_RELEASE,		/* releasing lease */
-	DHC_START,		/* sent when dhclient started OK */
-	DHC_ABEND,		/* dhclient exited abnormally */
-	DHC_END,		/* dhclient exited normally */
-	DHC_END_OPTIONS,	/* last option in subscription sent */
-} NMDHCPState;
-
 typedef struct {
 	GObject parent;
 } NMDHCPManager;
 
 typedef struct {
 	GObjectClass parent;
-
-	/* Signals */
-	void (*state_changed) (NMDHCPManager *manager, char *iface, NMDHCPState state);
-	void (*timeout)       (NMDHCPManager *manager, char *iface);
 } NMDHCPManagerClass;
 
-typedef struct {
-        char *			iface;
-        guchar			state;
-        GPid			pid;
-        char *			pid_file;
-        char *			conf_file;
-        char *			lease_file;
-        guint			timeout_id;
-        guint			watch_id;
-        NMDHCPManager *		manager;
-        GHashTable *		options;
-} NMDHCPDevice;
-
 GType nm_dhcp_manager_get_type (void);
 
 NMDHCPManager *nm_dhcp_manager_get                  (void);
+
 void           nm_dhcp_manager_set_hostname_provider(NMDHCPManager *manager,
 													 NMHostnameProvider *provider);
 
-gboolean       nm_dhcp_manager_begin_transaction    (NMDHCPManager *manager,
-                                                     const char *iface,
-                                                     const char *uuid,
-                                                     NMSettingIP4Config *s_ip4,
-                                                     guint32 timeout,
-                                                     guint8 *dhcp_anycast_addr);
-void           nm_dhcp_manager_cancel_transaction   (NMDHCPManager *manager,
-                                                     const char *iface);
-NMIP4Config *  nm_dhcp_manager_get_ip4_config       (NMDHCPManager *manager, const char *iface);
-NMDHCPState    nm_dhcp_manager_get_state_for_device (NMDHCPManager *manager, const char *iface);
-
-gboolean       nm_dhcp_manager_foreach_dhcp4_option (NMDHCPManager *self,
-                                                     const char *iface,
-                                                     GHFunc func,
-                                                     gpointer user_data);
-
-GSList *       nm_dhcp_manager_get_lease_ip4_config (NMDHCPManager *self,
-                                                     const char *iface,
-                                                     const char *uuid);
-
-/* The following are implemented by the DHCP client backends */
-GPid           nm_dhcp_client_start                 (NMDHCPDevice *device,
-                                                     const char *uuid,
-                                                     NMSettingIP4Config *s_ip4,
-                                                     guint8 *anycast_addr);
-void           nm_dhcp_client_stop                  (NMDHCPDevice *device, pid_t pid);
-
-gboolean       nm_dhcp_client_process_classless_routes (GHashTable *options,
-                                                        NMIP4Config *ip4_config,
-                                                        guint32 *gwaddr);
-
-GSList *       nm_dhcp_client_get_lease_ip4_config  (const char *iface,
-                                                     const char *uuid);
-
-/* Test functions */
-NMIP4Config *nm_dhcp_manager_options_to_ip4_config (const char *iface,
-                                                    GHashTable *options);
+NMDHCPClient * nm_dhcp_manager_start_ip4     (NMDHCPManager *manager,
+                                              const char *iface,
+                                              const char *uuid,
+                                              NMSettingIP4Config *s_ip4,
+                                              guint32 timeout,
+                                              guint8 *dhcp_anycast_addr);
+
+NMDHCPClient * nm_dhcp_manager_start_ip6     (NMDHCPManager *manager,
+                                              const char *iface,
+                                              const char *uuid,
+                                              NMSettingIP6Config *s_ip6,
+                                              guint32 timeout,
+                                              guint8 *dhcp_anycast_addr,
+                                              gboolean info_only);
+
+GSList *       nm_dhcp_manager_get_lease_config (NMDHCPManager *self,
+                                                 const char *iface,
+                                                 const char *uuid);
+
+/* For testing only */
+NMIP4Config *nm_dhcp_manager_test_ip4_options_to_config (const char *dhcp_client,
+                                                         const char *iface,
+                                                         GHashTable *options,
+                                                         const char *reason);
+
+/* Only for main.c */
+NMDHCPManager *nm_dhcp_manager_new (const char *client, GError **error);
 
 #endif /* NM_DHCP_MANAGER_H */
diff --git a/src/dnsmasq-manager/Makefile.am b/src/dnsmasq-manager/Makefile.am
index 71d3873..66bbdd8 100644
--- a/src/dnsmasq-manager/Makefile.am
+++ b/src/dnsmasq-manager/Makefile.am
@@ -1,5 +1,6 @@
 INCLUDES = \
 	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/src \
 	-I${top_srcdir}/include
 
@@ -13,4 +14,6 @@ libdnsmasq_manager_la_CPPFLAGS = \
 	$(GLIB_CFLAGS) \
 	-DLOCALSTATEDIR=\"$(localstatedir)\"
 
-libdnsmasq_manager_la_LIBADD = $(GLIB_LIBS)
+libdnsmasq_manager_la_LIBADD = \
+	$(top_builddir)/src/logging/libnm-logging.la \
+	$(GLIB_LIBS)
diff --git a/src/dnsmasq-manager/nm-dnsmasq-manager.c b/src/dnsmasq-manager/nm-dnsmasq-manager.c
index 5538c82..ea529c7 100644
--- a/src/dnsmasq-manager/nm-dnsmasq-manager.c
+++ b/src/dnsmasq-manager/nm-dnsmasq-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <sys/types.h>
@@ -27,7 +27,7 @@
 #include <stdlib.h>
 
 #include "nm-dnsmasq-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-glib-compat.h"
 
 typedef struct {
@@ -168,13 +168,12 @@ nm_cmd_line_add_string (NMCmdLine *cmd, const char *str)
 static inline const char *
 nm_find_dnsmasq (void)
 {
-	static const char *dnsmasq_binary_paths[] =
-		{
-			"/usr/local/sbin/dnsmasq",
-			"/usr/sbin/dnsmasq",
-			"/sbin/dnsmasq",
-			NULL
-		};
+	static const char *dnsmasq_binary_paths[] = {
+		"/usr/local/sbin/dnsmasq",
+		"/usr/sbin/dnsmasq",
+		"/sbin/dnsmasq",
+		NULL
+	};
 
 	const char **dnsmasq_binary = dnsmasq_binary_paths;
 
@@ -214,7 +213,7 @@ dm_exit_code (guint dm_exit_status)
 		break;
 	}
 
-	g_warning ("dnsmasq exited with error: %s (%d)", msg, dm_exit_status);
+	nm_log_warn (LOGD_SHARING, "dnsmasq exited with error: %s (%d)", msg, dm_exit_status);
 }
 
 static void
@@ -228,12 +227,13 @@ dm_watch_cb (GPid pid, gint status, gpointer user_data)
 		err = WEXITSTATUS (status);
 		if (err != 0)
 			dm_exit_code (err);
-	} else if (WIFSTOPPED (status))
-		g_warning ("dnsmasq stopped unexpectedly with signal %d", WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		g_warning ("dnsmasq died with signal %d", WTERMSIG (status));
-	else
-		g_warning ("dnsmasq died from an unknown cause");
+	} else if (WIFSTOPPED (status)) {
+		nm_log_warn (LOGD_SHARING, "dnsmasq stopped unexpectedly with signal %d", WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_warn (LOGD_SHARING, "dnsmasq died with signal %d", WTERMSIG (status));
+	} else {
+		nm_log_warn (LOGD_SHARING, "dnsmasq died from an unknown cause");
+	}
   
 	priv->pid = 0;
 
@@ -288,8 +288,8 @@ create_dm_cmd_line (const char *iface,
 	s = g_string_new ("--listen-address=");
 	addr.s_addr = nm_ip4_address_get_address (tmp);
 	if (!inet_ntop (AF_INET, &addr, &localaddr[0], INET_ADDRSTRLEN)) {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (addr.s_addr));
+		nm_log_warn (LOGD_SHARING, "error converting IP4 address 0x%X",
+		             ntohl (addr.s_addr));
 		goto error;
 	}
 	g_string_append (s, localaddr);
@@ -301,8 +301,8 @@ create_dm_cmd_line (const char *iface,
 	/* Add start of address range */
 	addr.s_addr = nm_ip4_address_get_address (tmp) + htonl (9);
 	if (!inet_ntop (AF_INET, &addr, &buf[0], INET_ADDRSTRLEN)) {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (addr.s_addr));
+		nm_log_warn (LOGD_SHARING, "error converting IP4 address 0x%X",
+		             ntohl (addr.s_addr));
 		goto error;
 	}
 	g_string_append (s, buf);
@@ -312,8 +312,8 @@ create_dm_cmd_line (const char *iface,
 	/* Add end of address range */
 	addr.s_addr = nm_ip4_address_get_address (tmp) + htonl (99);
 	if (!inet_ntop (AF_INET, &addr, &buf[0], INET_ADDRSTRLEN)) {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (addr.s_addr));
+		nm_log_warn (LOGD_SHARING, "error converting IP4 address 0x%X",
+		             ntohl (addr.s_addr));
 		goto error;
 	}
 	g_string_append (s, buf);
@@ -370,7 +370,7 @@ kill_existing_for_iface (const char *iface, const char *pidfile)
 
 	if (strstr (cmdline_contents, "bin/dnsmasq")) {
 		if (kill (pid, 0)) {
-			nm_info ("Killing stale dnsmasq process %ld", pid);
+			nm_log_dbg (LOGD_SHARING, "Killing stale dnsmasq process %ld", pid);
 			kill (pid, SIGKILL);
 		}
 		unlink (pidfile);
@@ -405,10 +405,10 @@ nm_dnsmasq_manager_start (NMDnsMasqManager *manager,
 
 	g_ptr_array_add (dm_cmd->array, NULL);
 
-	nm_info ("Starting dnsmasq...");
+	nm_log_info (LOGD_SHARING, "Starting dnsmasq...");
 
 	cmd_str = nm_cmd_line_to_str (dm_cmd);
-	nm_debug ("Command line: %s", cmd_str);
+	nm_log_dbg (LOGD_SHARING, "Command line: %s", cmd_str);
 	g_free (cmd_str);
 
 	priv->pid = 0;
@@ -419,7 +419,7 @@ nm_dnsmasq_manager_start (NMDnsMasqManager *manager,
 		goto out;
 	}
 
-	nm_debug ("dnsmasq started with pid %d", priv->pid);
+	nm_log_dbg (LOGD_SHARING, "dnsmasq started with pid %d", priv->pid);
 
 	priv->dm_watch_id = g_child_watch_add (priv->pid, (GChildWatchFunc) dm_watch_cb, manager);
 
@@ -439,9 +439,9 @@ ensure_killed (gpointer data)
 		kill (pid, SIGKILL);
 
 	/* ensure the child is reaped */
-	nm_debug ("waiting for dnsmasq pid %d to exit", pid);
+	nm_log_dbg (LOGD_SHARING, "waiting for dnsmasq pid %d to exit", pid);
 	waitpid (pid, NULL, 0);
-	nm_debug ("dnsmasq pid %d cleaned up", pid);
+	nm_log_dbg (LOGD_SHARING, "dnsmasq pid %d cleaned up", pid);
 
 	return FALSE;
 }
@@ -467,9 +467,9 @@ nm_dnsmasq_manager_stop (NMDnsMasqManager *manager)
 			kill (priv->pid, SIGKILL);
 
 			/* ensure the child is reaped */
-			nm_debug ("waiting for dnsmasq pid %d to exit", priv->pid);
+			nm_log_dbg (LOGD_SHARING, "waiting for dnsmasq pid %d to exit", priv->pid);
 			waitpid (priv->pid, NULL, 0);
-			nm_debug ("dnsmasq pid %d cleaned up", priv->pid);
+			nm_log_dbg (LOGD_SHARING, "dnsmasq pid %d cleaned up", priv->pid);
 		}
 
 		priv->pid = 0;
diff --git a/src/ip6-manager/Makefile.am b/src/ip6-manager/Makefile.am
index 50db421..9f5229f 100644
--- a/src/ip6-manager/Makefile.am
+++ b/src/ip6-manager/Makefile.am
@@ -3,6 +3,7 @@ INCLUDES = \
 	-I${top_srcdir}/include \
 	-I${top_builddir}/marshallers \
 	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/src \
 	-I${top_srcdir}/src/named-manager
 
@@ -21,6 +22,8 @@ libip6_manager_la_CPPFLAGS = \
 	-DG_DISABLE_DEPRECATED
 
 libip6_manager_la_LIBADD = \
+	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
-	$(GLIB_LIBS) \
-	$(top_builddir)/marshallers/libmarshallers.la
+	$(GLIB_LIBS)
+
diff --git a/src/ip6-manager/nm-ip6-manager.c b/src/ip6-manager/nm-ip6-manager.c
index f41169c..be85ab0 100644
--- a/src/ip6-manager/nm-ip6-manager.c
+++ b/src/ip6-manager/nm-ip6-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <errno.h>
@@ -28,7 +28,7 @@
 #include "nm-netlink-listener.h"
 #include "NetworkManagerUtils.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 /* Pre-DHCP addrconf timeout, in seconds */
 #define NM_IP6_TIMEOUT 10
@@ -165,10 +165,8 @@ nm_ip6_manager_class_init (NMIP6ManagerClass *manager_class)
 					  G_SIGNAL_RUN_FIRST,
 					  G_STRUCT_OFFSET (NMIP6ManagerClass, addrconf_complete),
 					  NULL, NULL,
-					  _nm_marshal_VOID__STRING_BOOLEAN,
-					  G_TYPE_NONE, 2,
-					  G_TYPE_STRING,
-					  G_TYPE_BOOLEAN);
+					  _nm_marshal_VOID__STRING_UINT_BOOLEAN,
+					  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_BOOLEAN);
 
 	signals[CONFIG_CHANGED] =
 		g_signal_new ("config-changed",
@@ -176,9 +174,8 @@ nm_ip6_manager_class_init (NMIP6ManagerClass *manager_class)
 					  G_SIGNAL_RUN_FIRST,
 					  G_STRUCT_OFFSET (NMIP6ManagerClass, config_changed),
 					  NULL, NULL,
-					  g_cclosure_marshal_VOID__STRING,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_STRING);
+					  _nm_marshal_VOID__STRING_UINT,
+					  G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_UINT);
 }
 
 static void
@@ -216,7 +213,7 @@ nm_ip6_manager_new (void)
 	priv = NM_IP6_MANAGER_GET_PRIVATE (manager);
 
 	if (!priv->devices_by_iface || !priv->devices_by_index) {
-		nm_warning ("Error: not enough memory to initialize IP6 manager tables");
+		nm_log_err (LOGD_IP6, "not enough memory to initialize IP6 manager tables");
 		g_object_unref (manager);
 		manager = NULL;
 	}
@@ -233,10 +230,16 @@ nm_ip6_manager_get_device (NMIP6Manager *manager, int ifindex)
 								GINT_TO_POINTER (ifindex));
 }
 
+typedef struct {
+	NMIP6Device *device;
+	guint dhcp_opts;
+} CallbackInfo;
+
 static gboolean
 finish_addrconf (gpointer user_data)
 {
-	NMIP6Device *device = user_data;
+	CallbackInfo *info = user_data;
+	NMIP6Device *device = info->device;
 	NMIP6Manager *manager = device->manager;
 	char *iface_copy;
 
@@ -245,16 +248,16 @@ finish_addrconf (gpointer user_data)
 
 	if (device->state >= device->target_state) {
 		g_signal_emit (manager, signals[ADDRCONF_COMPLETE], 0,
-					   device->iface, TRUE);
+					   device->iface, info->dhcp_opts, TRUE);
 	} else {
-		nm_info ("Device '%s' IP6 addrconf timed out or failed.",
-				 device->iface);
+		nm_log_info (LOGD_IP6, "(%s): IP6 addrconf timed out or failed.",
+				     device->iface);
 
 		iface_copy = g_strdup (device->iface);
 
 		nm_ip6_manager_cancel_addrconf (manager, device->iface);
 		g_signal_emit (manager, signals[ADDRCONF_COMPLETE], 0,
-					   iface_copy, FALSE);
+					   iface_copy, info->dhcp_opts, FALSE);
 
 		g_free (iface_copy);
 	}
@@ -265,11 +268,12 @@ finish_addrconf (gpointer user_data)
 static gboolean
 emit_config_changed (gpointer user_data)
 {
-	NMIP6Device *device = user_data;
+	CallbackInfo *info = user_data;
+	NMIP6Device *device = info->device;
 	NMIP6Manager *manager = device->manager;
 
 	device->config_changed_id = 0;
-	g_signal_emit (manager, signals[CONFIG_CHANGED], 0, device->iface);
+	g_signal_emit (manager, signals[CONFIG_CHANGED], 0, device->iface, info->dhcp_opts);
 	return FALSE;
 }
 
@@ -279,9 +283,10 @@ static gboolean
 rdnss_expired (gpointer user_data)
 {
 	NMIP6Device *device = user_data;
+	CallbackInfo info = { device, IP6_DHCP_OPT_NONE };
 
 	set_rdnss_timeout (device);
-	emit_config_changed (device);
+	emit_config_changed (&info);
 	return FALSE;
 }
 
@@ -323,6 +328,18 @@ set_rdnss_timeout (NMIP6Device *device)
 	}
 }
 
+static CallbackInfo *
+callback_info_new (NMIP6Device *device, guint dhcp_opts)
+{
+	CallbackInfo *info;
+
+	info = g_malloc0 (sizeof (CallbackInfo));
+	info->device = device;
+	info->dhcp_opts = dhcp_opts;
+
+	return info;
+}
+
 static void
 nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 {
@@ -333,6 +350,8 @@ nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 	struct in6_addr *addr;
 	struct rtnl_link *link;
 	guint flags;
+	CallbackInfo *info;
+	guint dhcp_opts = IP6_DHCP_OPT_NONE;
 
 	for (rtnladdr = (struct rtnl_addr *)nl_cache_get_first (priv->addr_cache);
 		 rtnladdr;
@@ -365,8 +384,10 @@ nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 	if ((flags & IF_RA_RCVD) && device->state < NM_IP6_DEVICE_GOT_ROUTER_ADVERTISEMENT)
 		device->state = NM_IP6_DEVICE_GOT_ROUTER_ADVERTISEMENT;
 
-//	if (flags & (IF_RA_MANAGED | IF_RA_OTHERCONF))
-//		device->need_dhcp = TRUE;
+	if (flags & IF_RA_MANAGED)
+		dhcp_opts = IP6_DHCP_OPT_MANAGED;
+	else if (flags & IF_RA_OTHERCONF)
+		dhcp_opts = IP6_DHCP_OPT_OTHERCONF;
 
 	if (!device->addrconf_complete) {
 		if (device->state >= device->target_state ||
@@ -376,13 +397,20 @@ nm_ip6_device_sync_from_netlink (NMIP6Device *device, gboolean config_changed)
 			 */
 			if (device->finish_addrconf_id)
 				g_source_remove (device->finish_addrconf_id);
-			device->finish_addrconf_id = g_idle_add (finish_addrconf,
-													 device);
+
+			info = callback_info_new (device, dhcp_opts);
+			device->finish_addrconf_id = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
+			                                              finish_addrconf,
+			                                              info,
+			                                              (GDestroyNotify) g_free);
 		}
 	} else if (config_changed) {
 		if (!device->config_changed_id) {
-			device->config_changed_id = g_idle_add (emit_config_changed,
-													device);
+			info = callback_info_new (device, dhcp_opts);
+			device->config_changed_id = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
+			                                             emit_config_changed,
+			                                             info,
+			                                             (GDestroyNotify) g_free);
 		}
 	}
 }
@@ -619,13 +647,13 @@ nm_ip6_device_new (NMIP6Manager *manager, const char *iface)
 
 	device = g_slice_new0 (NMIP6Device);
 	if (!device) {
-		nm_warning ("%s: Out of memory creating IP6 addrconf object.", iface);
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 addrconf object.", iface);
 		return NULL;
 	}
 
 	device->iface = g_strdup (iface);
 	if (!device->iface) {
-		nm_warning ("%s: Out of memory creating IP6 addrconf object "
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 addrconf object "
 		            "property 'iface'.",
 		            iface);
 		goto error;
@@ -634,7 +662,7 @@ nm_ip6_device_new (NMIP6Manager *manager, const char *iface)
 
 	device->accept_ra_path = g_strdup_printf ("/proc/sys/net/ipv6/conf/%s/accept_ra", iface);
 	if (!device->accept_ra_path) {
-		nm_warning ("%s: Out of memory creating IP6 addrconf object "
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 addrconf object "
 		            "property 'accept_ra_path'.",
 		            iface);
 		goto error;
@@ -651,10 +679,10 @@ nm_ip6_device_new (NMIP6Manager *manager, const char *iface)
 	 * device is taken down.
 	 */
 	if (!g_file_get_contents (device->accept_ra_path, &contents, NULL, &error)) {
-		nm_warning ("%s: error reading %s: (%d) %s",
-		            iface, device->accept_ra_path,
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_IP6, "(%s): error reading %s: (%d) %s",
+		             iface, device->accept_ra_path,
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 		g_clear_error (&error);
 	} else {
 		long int tmp;
@@ -717,6 +745,7 @@ nm_ip6_manager_begin_addrconf (NMIP6Manager *manager,
 {
 	NMIP6ManagerPrivate *priv;
 	NMIP6Device *device;
+	CallbackInfo *info;
 
 	g_return_if_fail (NM_IS_IP6_MANAGER (manager));
 	g_return_if_fail (iface != NULL);
@@ -726,14 +755,17 @@ nm_ip6_manager_begin_addrconf (NMIP6Manager *manager,
 	device = (NMIP6Device *) g_hash_table_lookup (priv->devices_by_iface, iface);
 	g_return_if_fail (device != NULL);
 
-	nm_info ("Activation (%s) Beginning IP6 addrconf.", iface);
+	nm_log_info (LOGD_IP6, "Activation (%s) Beginning IP6 addrconf.", iface);
 
 	device->addrconf_complete = FALSE;
 
 	/* Set up a timeout on the transaction to kill it after the timeout */
-	device->finish_addrconf_id = g_timeout_add_seconds (NM_IP6_TIMEOUT,
-														finish_addrconf,
-														device);
+	info = callback_info_new (device, 0);
+	device->finish_addrconf_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
+	                                                         NM_IP6_TIMEOUT,
+	                                                         finish_addrconf,
+	                                                         info,
+	                                                         (GDestroyNotify) g_free);
 
 	/* Sync flags, etc, from netlink; this will also notice if the
 	 * device is already fully configured and schedule the
@@ -786,13 +818,13 @@ nm_ip6_manager_get_ip6_config (NMIP6Manager *manager,
 
 	device = (NMIP6Device *) g_hash_table_lookup (priv->devices_by_iface, iface);
 	if (!device) {
-		nm_warning ("Device '%s' addrconf not started.", iface);
+		nm_log_warn (LOGD_IP6, "(%s): addrconf not started.", iface);
 		return NULL;
 	}
 
 	config = nm_ip6_config_new ();
 	if (!config) {
-		nm_warning ("%s: Out of memory creating IP6 config object.",
+		nm_log_err (LOGD_IP6, "(%s): out of memory creating IP6 config object.",
 		            iface);
 		return NULL;
 	}
diff --git a/src/ip6-manager/nm-ip6-manager.h b/src/ip6-manager/nm-ip6-manager.h
index 33b2b98..d0cf4b0 100644
--- a/src/ip6-manager/nm-ip6-manager.h
+++ b/src/ip6-manager/nm-ip6-manager.h
@@ -35,6 +35,12 @@
 #define NM_IS_IP6_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_IP6_MANAGER))
 #define NM_IP6_MANAGER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_IP6_MANAGER, NMIP6ManagerClass))
 
+enum {
+	IP6_DHCP_OPT_NONE = 0,
+	IP6_DHCP_OPT_OTHERCONF,
+	IP6_DHCP_OPT_MANAGED
+};
+
 typedef struct {
 	GObject parent;
 } NMIP6Manager;
@@ -47,13 +53,18 @@ typedef struct {
 	/* addrconf_complete is emitted only during initial configuration to indicate
 	 * that the initial configuration is complete.
 	 */
-	void (*addrconf_complete) (NMIP6Manager *manager, char *iface, gboolean success);
+	void (*addrconf_complete) (NMIP6Manager *manager,
+	                           char *iface,
+	                           guint dhcp_opts,
+	                           gboolean success);
 
 	/* config_changed gets emitted only *after* initial configuration is
 	 * complete; it's like DHCP renew and indicates that the existing config
 	 * of the interface has changed.
 	 */
-	void (*config_changed)    (NMIP6Manager *manager, char *iface);
+	void (*config_changed)    (NMIP6Manager *manager,
+	                           char *iface,
+	                           guint dhcp_opts);
 } NMIP6ManagerClass;
 
 GType nm_ip6_manager_get_type (void);
diff --git a/src/ip6-manager/nm-netlink-listener.c b/src/ip6-manager/nm-netlink-listener.c
index bfcc22f..55c4d76 100644
--- a/src/ip6-manager/nm-netlink-listener.c
+++ b/src/ip6-manager/nm-netlink-listener.c
@@ -43,9 +43,8 @@
 #include <glib/gi18n.h>
 
 #include "NetworkManager.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-netlink-listener.h"
-#include "nm-utils.h"
 #include "nm-marshal.h"
 #include "nm-netlink.h"
 
diff --git a/src/logging/Makefile.am b/src/logging/Makefile.am
new file mode 100644
index 0000000..d2e3e25
--- /dev/null
+++ b/src/logging/Makefile.am
@@ -0,0 +1,14 @@
+noinst_LTLIBRARIES = libnm-logging.la
+
+libnm_logging_la_SOURCES = \
+	nm-logging.c \
+	nm-logging.h
+
+libnm_logging_la_CPPFLAGS = \
+	$(GLIB_CFLAGS) \
+	-DLIBEXECDIR=\"$(libexecdir)\" \
+	-DG_DISABLE_DEPRECATED
+
+libnm_logging_la_LIBADD = \
+	$(GLIB_LIBS)
+
diff --git a/src/logging/nm-logging.c b/src/logging/nm-logging.c
new file mode 100644
index 0000000..ac30eb4
--- /dev/null
+++ b/src/logging/nm-logging.c
@@ -0,0 +1,347 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#define _GNU_SOURCE
+#include <dlfcn.h>
+#include <syslog.h>
+#include <execinfo.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <execinfo.h>
+#include <strings.h>
+#include <string.h>
+
+#include <glib/gi18n.h>
+
+#include "nm-logging.h"
+
+static guint32 log_level = LOGL_INFO | LOGL_WARN | LOGL_ERR;
+static guint32 log_domains = \
+	LOGD_HW | LOGD_RFKILL | LOGD_ETHER | LOGD_WIFI | LOGD_BT | LOGD_MB | \
+	LOGD_DHCP4 | LOGD_DHCP6 | LOGD_PPP | LOGD_IP4 | LOGD_IP6 | LOGD_AUTOIP4 | \
+	LOGD_DNS | LOGD_VPN | LOGD_SHARING | LOGD_SUPPLICANT | LOGD_USER_SET | \
+	LOGD_SYS_SET | LOGD_SUSPEND | LOGD_CORE | LOGD_DEVICE | LOGD_OLPC_MESH;
+
+typedef struct {
+	guint32 num;
+	const char *name;
+} LogDesc;
+
+static const LogDesc level_descs[] = {
+	{ LOGL_ERR, "ERR" },
+	{ LOGL_WARN | LOGL_ERR, "WARN" },
+	{ LOGL_INFO | LOGL_WARN | LOGL_ERR, "INFO" },
+	{ LOGL_DEBUG | LOGL_INFO | LOGL_WARN | LOGL_ERR, "DEBUG" },
+	{ 0, NULL }
+};
+
+static const LogDesc domain_descs[] = {
+	{ LOGD_NONE,      "NONE" },
+	{ LOGD_HW,        "HW" },
+	{ LOGD_RFKILL,    "RFKILL" },
+	{ LOGD_ETHER,     "ETHER" },
+	{ LOGD_WIFI,      "WIFI" },
+	{ LOGD_BT,        "BT" },
+	{ LOGD_MB,        "MB" },
+	{ LOGD_DHCP4,     "DHCP4" },
+	{ LOGD_DHCP6,     "DHCP6" },
+	{ LOGD_PPP,       "PPP" },
+	{ LOGD_WIFI_SCAN, "WIFI_SCAN" },
+	{ LOGD_IP4,       "IP4" },
+	{ LOGD_IP6,       "IP6" },
+	{ LOGD_AUTOIP4,   "AUTOIP4" },
+	{ LOGD_DNS,       "DNS" },
+	{ LOGD_VPN,       "VPN" },
+	{ LOGD_SHARING,   "SHARING" },
+	{ LOGD_SUPPLICANT,"SUPPLICANT" },
+	{ LOGD_USER_SET,  "USER_SET" },
+	{ LOGD_SYS_SET,   "SYS_SET" },
+	{ LOGD_SUSPEND,   "SUSPEND" },
+	{ LOGD_CORE,      "CORE" },
+	{ LOGD_DEVICE,    "DEVICE" },
+	{ LOGD_OLPC_MESH, "OLPC" },
+	{ 0, NULL }
+};
+
+/************************************************************************/
+
+enum {
+    NM_LOGGING_ERROR_UNKNOWN_LEVEL = 0,
+    NM_LOGGING_ERROR_UNKNOWN_DOMAIN = 1,
+};
+
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+GQuark
+nm_logging_error_quark (void)
+{
+    static GQuark ret = 0;
+
+    if (ret == 0)
+        ret = g_quark_from_static_string ("nm_logging_error");
+    return ret;
+}
+
+GType
+nm_logging_error_get_type (void)
+{
+    static GType etype = 0;
+
+    if (etype == 0) {
+        static const GEnumValue values[] = {
+            ENUM_ENTRY (NM_LOGGING_ERROR_UNKNOWN_LEVEL,  "UnknownLevel"),
+            ENUM_ENTRY (NM_LOGGING_ERROR_UNKNOWN_DOMAIN, "UnknownDomain"),
+            { 0, 0, 0 }
+        };
+        etype = g_enum_register_static ("NMLoggingError", values);
+    }
+    return etype;
+}
+
+/************************************************************************/
+
+gboolean
+nm_logging_setup (const char *level, const char *domains, GError **error)
+{
+	char **tmp, **iter;
+	guint32 new_domains = 0;
+
+	/* levels */
+	if (level && strlen (level)) {
+		gboolean found = FALSE;
+		const LogDesc *diter;
+
+		for (diter = &level_descs[0]; diter->name; diter++) {
+			if (!strcasecmp (diter->name, level)) {
+				log_level = diter->num;
+				found = TRUE;
+				break;
+			}
+		}
+
+		if (!found) {
+			g_set_error (error, NM_LOGGING_ERROR, NM_LOGGING_ERROR_UNKNOWN_LEVEL,
+			             _("Unknown log level '%s'"), level);
+			return FALSE;
+		}
+	}
+
+	/* domains */
+	if (domains && strlen (domains)) {
+		tmp = g_strsplit_set (domains, ", ", 0);
+		for (iter = tmp; iter && *iter; iter++) {
+			const LogDesc *diter;
+			gboolean found = FALSE;
+
+			if (!strlen (*iter))
+				continue;
+
+			for (diter = &domain_descs[0]; diter->name; diter++) {
+				if (!strcasecmp (diter->name, *iter)) {
+					new_domains |= diter->num;
+					found = TRUE;
+					break;
+				}
+			}
+
+			if (!found) {
+				g_set_error (error, NM_LOGGING_ERROR, NM_LOGGING_ERROR_UNKNOWN_DOMAIN,
+				             _("Unknown log domain '%s'"), *iter);
+				return FALSE;
+			}
+		}
+		g_strfreev (tmp);
+		log_domains = new_domains;
+	}
+
+	return TRUE;
+}
+
+void _nm_log (const char *loc,
+              const char *func,
+              guint32 domain,
+              guint32 level,
+              const char *fmt,
+              ...)
+{
+	va_list args;
+	char *msg;
+	GTimeVal tv;
+
+	if (!(log_level & level) || !(log_domains & domain))
+		return;
+
+	va_start (args, fmt);
+	msg = g_strdup_vprintf (fmt, args);
+	va_end (args);
+
+	if ((log_level & LOGL_DEBUG) && (level == LOGL_DEBUG)) {
+		g_get_current_time (&tv);
+		syslog (LOG_INFO, "<debug> [%ld.%ld] [%s] %s(): %s\n", tv.tv_sec, tv.tv_usec, loc, func, msg);
+	} else if ((log_level & LOGL_INFO) && (level == LOGL_INFO))
+		syslog (LOG_INFO, "<info> %s\n", msg);
+	else if ((log_level & LOGL_WARN) && (level == LOGL_WARN))
+		syslog (LOG_WARNING, "<warn> %s\n", msg);
+	else if ((log_level & LOGL_ERR) && (level == LOGL_ERR)) {
+		g_get_current_time (&tv);
+		syslog (LOG_ERR, "<error> [%ld.%ld] [%s] %s(): %s\n", tv.tv_sec, tv.tv_usec, loc, func, msg);
+	}
+	g_free (msg);
+}
+
+/************************************************************************/
+
+static void
+fallback_get_backtrace (void)
+{
+	void *frames[64];
+	Dl_info info;
+	size_t size;
+	guint32 i;
+	const char *name;
+
+	size = backtrace (frames, G_N_ELEMENTS (frames));
+
+	syslog (LOG_CRIT, "******************* START **********************************");
+	for (i = 0; i < size; i++) {
+		dladdr (frames[i], &info);
+		name = (info.dli_fname && *info.dli_fname) ? info.dli_fname : "(vdso)";
+		if (info.dli_saddr) {
+			syslog (LOG_CRIT, "Frame %d: %s (%s+0x%lx) [%p]",
+			        i, name,
+			        info.dli_sname,
+			        (gulong)(frames[i] - info.dli_saddr),
+			        frames[i]);
+		} else {
+			syslog (LOG_CRIT, "Frame %d: %s (%p+0x%lx) [%p]",
+			        i, name,
+			        info.dli_fbase,
+			        (gulong)(frames[i] - info.dli_saddr),
+			        frames[i]);
+		}
+	}
+	syslog (LOG_CRIT, "******************* END **********************************");
+}
+
+
+static gboolean
+crashlogger_get_backtrace (void)
+{
+	gboolean success = FALSE;
+	int pid;	
+
+	pid = fork();
+	if (pid > 0)
+	{
+		/* Wait for the child to finish */
+		int estatus;
+		if (waitpid (pid, &estatus, 0) != -1)
+		{
+			/* Only succeed if the crashlogger succeeded */
+			if (WIFEXITED (estatus) && (WEXITSTATUS (estatus) == 0))
+				success = TRUE;
+		}
+	}
+	else if (pid == 0)
+	{
+		/* Child process */
+		execl (LIBEXECDIR"/nm-crash-logger",
+				LIBEXECDIR"/nm-crash-logger", NULL);
+	}
+
+	return success;
+}
+
+
+void
+nm_logging_backtrace (void)
+{
+	struct stat s;
+	gboolean fallback = TRUE;
+	
+	/* Try to use gdb via nm-crash-logger if it exists, since
+	 * we get much better information out of it.  Otherwise
+	 * fall back to execinfo.
+	 */
+	if (stat (LIBEXECDIR"/nm-crash-logger", &s) == 0)
+		fallback = crashlogger_get_backtrace () ? FALSE : TRUE;
+
+	if (fallback)
+		fallback_get_backtrace ();
+}
+
+
+static void
+nm_log_handler (const gchar *log_domain,
+                GLogLevelFlags level,
+                const gchar *message,
+                gpointer ignored)
+{
+	int syslog_priority;	
+
+	switch (level) {
+	case G_LOG_LEVEL_ERROR:
+		syslog_priority = LOG_CRIT;
+		break;
+	case G_LOG_LEVEL_CRITICAL:
+		syslog_priority = LOG_ERR;
+		break;
+	case G_LOG_LEVEL_WARNING:
+		syslog_priority = LOG_WARNING;
+		break;
+	case G_LOG_LEVEL_MESSAGE:
+		syslog_priority = LOG_NOTICE;
+		break;
+	case G_LOG_LEVEL_DEBUG:
+		syslog_priority = LOG_DEBUG;
+		break;
+	case G_LOG_LEVEL_INFO:
+	default:
+		syslog_priority = LOG_INFO;
+		break;
+	}
+
+	syslog (syslog_priority, "%s", message);
+}
+
+void
+nm_logging_start (gboolean become_daemon)
+{
+	if (become_daemon)
+		openlog (G_LOG_DOMAIN, 0, LOG_DAEMON);
+	else
+		openlog (G_LOG_DOMAIN, LOG_CONS | LOG_PERROR, LOG_USER);
+
+	g_log_set_handler (G_LOG_DOMAIN, 
+	                   G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION,
+	                   nm_log_handler,
+	                   NULL);
+}
+
+void
+nm_logging_shutdown (void)
+{
+	closelog ();
+}
diff --git a/src/logging/nm-logging.h b/src/logging/nm-logging.h
new file mode 100644
index 0000000..2dc52d1
--- /dev/null
+++ b/src/logging/nm-logging.h
@@ -0,0 +1,108 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#ifndef NM_LOGGING_H
+#define NM_LOGGING_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+/* Log domains */
+enum {
+	LOGD_NONE       = 0x00000000,
+	LOGD_HW         = 0x00000001, /* Hardware detection and info */
+	LOGD_RFKILL     = 0x00000002,
+	LOGD_ETHER      = 0x00000004,
+	LOGD_WIFI       = 0x00000008,
+	LOGD_BT         = 0x00000010,
+	LOGD_MB         = 0x00000020, /* mobile broadband */
+	LOGD_DHCP4      = 0x00000040,
+	LOGD_DHCP6      = 0x00000080,
+	LOGD_PPP        = 0x00000100,
+	LOGD_WIFI_SCAN  = 0x00000200,
+	LOGD_IP4        = 0x00000400,
+	LOGD_IP6        = 0x00000800,
+	LOGD_AUTOIP4    = 0x00001000,
+	LOGD_DNS        = 0x00002000,
+	LOGD_VPN        = 0x00004000,
+	LOGD_SHARING    = 0x00008000, /* Connection sharing/dnsmasq */
+	LOGD_SUPPLICANT = 0x00010000, /* WiFi and 802.1x */
+	LOGD_USER_SET   = 0x00020000, /* User settings */
+	LOGD_SYS_SET    = 0x00040000, /* System settings */
+	LOGD_SUSPEND    = 0x00080000, /* Suspend/Resume */
+	LOGD_CORE       = 0x00100000, /* Core daemon and policy stuff */
+	LOGD_DEVICE     = 0x00200000, /* Device state and activation */
+	LOGD_OLPC_MESH  = 0x00400000,
+};
+
+#define LOGD_DHCP (LOGD_DHCP4 | LOGD_DHCP6)
+
+/* Log levels */
+enum {
+	LOGL_ERR   = 0x00000001,
+	LOGL_WARN  = 0x00000002,
+	LOGL_INFO  = 0x00000004,
+	LOGL_DEBUG = 0x00000008
+};
+
+#define NM_LOGGING_ERROR (nm_logging_error_quark ())
+#define NM_TYPE_LOGGING_ERROR (nm_logging_error_get_type ())
+GQuark nm_logging_error_quark    (void);
+GType  nm_logging_error_get_type (void);
+
+
+#define nm_log_err(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_ERR, fmt, ##args); }
+
+#define nm_log_warn(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_WARN, fmt, ##args); }
+
+#define nm_log_info(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_INFO, fmt, ##args); }
+
+#define nm_log_dbg(domain, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, LOGL_DEBUG, fmt, ##args); }
+
+#define nm_log(domain, level, fmt, args...) \
+	{ _nm_log (G_STRLOC, G_STRFUNC, domain, level, fmt, ##args); }
+
+void _nm_log (const char *loc, const char *func,
+              guint32 domain, guint32 level,
+              const char *fmt, ...);
+
+/* Undefine the nm-utils.h logging stuff to ensure errors */
+#undef nm_print_backtrace
+#undef nm_get_timestamp
+#undef nm_info
+#undef nm_info_str
+#undef nm_debug
+#undef nm_debug_str
+#undef nm_warning
+#undef nm_warning_str
+#undef nm_error
+#undef nm_error_str
+
+gboolean nm_logging_setup     (const char *level, const char *domains, GError **error);
+void     nm_logging_start     (gboolean become_daemon);
+void     nm_logging_backtrace (void);
+void     nm_logging_shutdown  (void);
+
+#endif /* NM_LOGGING_H */
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 0000000..1d0ab53
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,744 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ * Copyright (C) 2005 - 2008 Novell, Inc.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <glib.h>
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib-lowlevel.h>
+#include <dbus/dbus-glib.h>
+#include <getopt.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <glib/gi18n.h>
+#include <gmodule.h>
+#include <string.h>
+
+#include "NetworkManager.h"
+#include "NetworkManagerUtils.h"
+#include "nm-manager.h"
+#include "nm-policy.h"
+#include "nm-system.h"
+#include "nm-named-manager.h"
+#include "nm-dbus-manager.h"
+#include "nm-supplicant-manager.h"
+#include "nm-dhcp-manager.h"
+#include "nm-hostname-provider.h"
+#include "nm-netlink-monitor.h"
+#include "nm-vpn-manager.h"
+#include "nm-logging.h"
+
+#if !defined(NM_DIST_VERSION)
+# define NM_DIST_VERSION VERSION
+#endif
+
+#define NM_DEFAULT_PID_FILE          LOCALSTATEDIR"/run/NetworkManager.pid"
+#define NM_DEFAULT_SYSTEM_CONF_FILE  SYSCONFDIR"/NetworkManager/NetworkManager.conf"
+#define NM_OLD_SYSTEM_CONF_FILE      SYSCONFDIR"/NetworkManager/nm-system-settings.conf"
+#define NM_DEFAULT_SYSTEM_STATE_FILE LOCALSTATEDIR"/lib/NetworkManager/NetworkManager.state"
+
+/*
+ * Globals
+ */
+static NMManager *manager = NULL;
+static GMainLoop *main_loop = NULL;
+
+typedef struct {
+	time_t time;
+	GQuark domain;
+	guint32 code;
+	guint32 count;
+} MonitorInfo;
+
+static gboolean
+detach_monitor (gpointer data)
+{
+	nm_log_warn (LOGD_HW, "detaching netlink event monitor");
+	nm_netlink_monitor_detach (NM_NETLINK_MONITOR (data));
+	return FALSE;
+}
+
+static void
+nm_error_monitoring_device_link_state (NMNetlinkMonitor *monitor,
+									   GError *error,
+									   gpointer user_data)
+{
+	MonitorInfo *info = (MonitorInfo *) user_data;
+	time_t now;
+
+	now = time (NULL);
+
+	if (   (info->domain != error->domain)
+	    || (info->code != error->code)
+	    || (info->time && now > info->time + 10)) {
+		/* FIXME: Try to handle the error instead of just printing it. */
+		nm_log_warn (LOGD_HW, "error monitoring device for netlink events: %s\n", error->message);
+
+		info->time = now;
+		info->domain = error->domain;
+		info->code = error->code;
+		info->count = 0;
+	}
+
+	info->count++;
+	if (info->count > 100) {
+		/* Broken drivers will sometimes cause a flood of netlink errors.
+		 * rh #459205, novell #443429, lp #284507
+		 */
+		nm_log_warn (LOGD_HW, "excessive netlink errors ocurred, disabling netlink monitor.");
+		nm_log_warn (LOGD_HW, "link change events will not be processed.");
+		g_idle_add_full (G_PRIORITY_HIGH, detach_monitor, monitor, NULL);
+	}
+}
+
+static gboolean
+nm_monitor_setup (GError **error)
+{
+	NMNetlinkMonitor *monitor;
+	MonitorInfo *info;
+
+	monitor = nm_netlink_monitor_get ();
+	if (!nm_netlink_monitor_open_connection (monitor, error)) {
+		g_object_unref (monitor);
+		return FALSE;
+	}
+
+	info = g_new0 (MonitorInfo, 1);
+	g_signal_connect_data (G_OBJECT (monitor), "error",
+						   G_CALLBACK (nm_error_monitoring_device_link_state),
+						   info,
+						   (GClosureNotify) g_free,
+						   0);
+	nm_netlink_monitor_attach (monitor);
+
+	/* Request initial status of cards */
+	nm_netlink_monitor_request_status (monitor, NULL);
+
+	return TRUE;
+}
+
+static gboolean quit_early = FALSE;
+
+static void
+nm_signal_handler (int signo)
+{
+	static int in_fatal = 0;
+
+	/* avoid loops */
+	if (in_fatal > 0)
+		return;
+	++in_fatal;
+
+	switch (signo)
+	{
+		case SIGSEGV:
+		case SIGBUS:
+		case SIGILL:
+		case SIGABRT:
+			nm_log_warn (LOGD_CORE, "caught signal %d. Generating backtrace...", signo);
+			nm_logging_backtrace ();
+			exit (1);
+			break;
+
+		case SIGFPE:
+		case SIGPIPE:
+			/* let the fatal signals interrupt us */
+			--in_fatal;
+
+			nm_log_warn (LOGD_CORE, "caught signal %d, shutting down abnormally. Generating backtrace...", signo);
+			nm_logging_backtrace ();
+			g_main_loop_quit (main_loop);
+			break;
+
+		case SIGINT:
+		case SIGTERM:
+			/* let the fatal signals interrupt us */
+			--in_fatal;
+
+			nm_log_info (LOGD_CORE, "caught signal %d, shutting down normally.", signo);
+			quit_early = TRUE;
+			g_main_loop_quit (main_loop);
+			break;
+
+		case SIGHUP:
+			--in_fatal;
+			/* FIXME:
+			 * Reread config stuff like system config files, VPN service files, etc
+			 */
+			break;
+
+		case SIGUSR1:
+			--in_fatal;
+			/* FIXME:
+			 * Play with log levels or something
+			 */
+			break;
+
+		default:
+			signal (signo, nm_signal_handler);
+			break;
+	}
+}
+
+static void
+setup_signals (void)
+{
+	struct sigaction action;
+	sigset_t mask;
+
+	sigemptyset (&mask);
+	action.sa_handler = nm_signal_handler;
+	action.sa_mask = mask;
+	action.sa_flags = 0;
+	sigaction (SIGTERM,  &action, NULL);
+	sigaction (SIGINT,  &action, NULL);
+	sigaction (SIGILL,  &action, NULL);
+	sigaction (SIGBUS,  &action, NULL);
+	sigaction (SIGFPE,  &action, NULL);
+	sigaction (SIGHUP,  &action, NULL);
+	sigaction (SIGSEGV, &action, NULL);
+	sigaction (SIGABRT, &action, NULL);
+	sigaction (SIGUSR1,  &action, NULL);
+}
+
+static gboolean
+write_pidfile (const char *pidfile)
+{
+ 	char pid[16];
+	int fd;
+	gboolean success = FALSE;
+ 
+	if ((fd = open (pidfile, O_CREAT|O_WRONLY|O_TRUNC, 00644)) < 0) {
+		fprintf (stderr, "Opening %s failed: %s\n", pidfile, strerror (errno));
+		return FALSE;
+	}
+
+ 	snprintf (pid, sizeof (pid), "%d", getpid ());
+	if (write (fd, pid, strlen (pid)) < 0)
+		fprintf (stderr, "Writing to %s failed: %s\n", pidfile, strerror (errno));
+	else
+		success = TRUE;
+
+	if (close (fd))
+		fprintf (stderr, "Closing %s failed: %s\n", pidfile, strerror (errno));
+
+	return success;
+}
+
+/* Check whether the pidfile already exists and contains PID of a running NetworkManager
+ *  Returns:  FALSE - specified pidfile doesn't exist or doesn't contain PID of a running NM process
+ *            TRUE  - specified pidfile already exists and contains PID of a running NM process
+ */
+static gboolean
+check_pidfile (const char *pidfile)
+{
+	char *contents = NULL;
+	gsize len = 0;
+	glong pid;
+	char *proc_cmdline = NULL;
+	gboolean nm_running = FALSE;
+	const char *process_name;
+
+	if (!g_file_get_contents (pidfile, &contents, &len, NULL))
+		return FALSE;
+
+	if (len <= 0)
+		goto done;
+
+	errno = 0;
+	pid = strtol (contents, NULL, 10);
+	if (pid <= 0 || pid > 65536 || errno)
+		goto done;
+
+	g_free (contents);
+	proc_cmdline = g_strdup_printf ("/proc/%ld/cmdline", pid);
+	if (!g_file_get_contents (proc_cmdline, &contents, &len, NULL))
+		goto done;
+
+	process_name = strrchr (contents, '/');
+	if (process_name)
+		process_name++;
+	else
+		process_name = contents;
+	if (strcmp (process_name, "NetworkManager") == 0) {
+		/* Check that the process exists */
+		if (kill (pid, 0) == 0) {
+			fprintf (stderr, "NetworkManager is already running (pid %ld)\n", pid);
+			nm_running = TRUE;
+		}
+	}
+
+done:
+	g_free (proc_cmdline);
+	g_free (contents);
+	return nm_running;
+}
+
+static gboolean
+parse_config_file (const char *filename,
+                   char **plugins,
+                   char **dhcp_client,
+                   char **log_level,
+                   char **log_domains,
+                   GError **error)
+{
+	GKeyFile *config;
+
+	config = g_key_file_new ();
+	if (!config) {
+		g_set_error (error, 0, 0,
+		             "Not enough memory to load config file.");
+		return FALSE;
+	}
+
+	g_key_file_set_list_separator (config, ',');
+	if (!g_key_file_load_from_file (config, filename, G_KEY_FILE_NONE, error))
+		return FALSE;
+
+	*plugins = g_key_file_get_value (config, "main", "plugins", error);
+	if (*error)
+		return FALSE;
+
+	*dhcp_client = g_key_file_get_value (config, "main", "dhcp", NULL);
+
+	*log_level = g_key_file_get_value (config, "logging", "level", NULL);
+	*log_domains = g_key_file_get_value (config, "logging", "domains", NULL);
+
+	g_key_file_free (config);
+	return TRUE;
+}
+
+static gboolean
+parse_state_file (const char *filename,
+                  gboolean *net_enabled,
+                  gboolean *wifi_enabled,
+                  gboolean *wwan_enabled,
+                  GError **error)
+{
+	GKeyFile *state_file;
+	GError *tmp_error = NULL;
+	gboolean wifi, net, wwan;
+
+	g_return_val_if_fail (net_enabled != NULL, FALSE);
+	g_return_val_if_fail (wifi_enabled != NULL, FALSE);
+	g_return_val_if_fail (wwan_enabled != NULL, FALSE);
+
+	state_file = g_key_file_new ();
+	if (!state_file) {
+		g_set_error (error, 0, 0,
+		             "Not enough memory to load state file.");
+		return FALSE;
+	}
+
+	g_key_file_set_list_separator (state_file, ',');
+	if (!g_key_file_load_from_file (state_file, filename, G_KEY_FILE_KEEP_COMMENTS, &tmp_error)) {
+		/* This is kinda ugly; create the file and directory if it doesn't
+		 * exist yet.  We can't rely on distros necessarily creating the
+		 * /var/lib/NetworkManager for us since we have to ensure that
+		 * users upgrading NM get this working too.
+		 */
+		if (   tmp_error->domain == G_FILE_ERROR
+		    && tmp_error->code == G_FILE_ERROR_NOENT) {
+			char *data, *dirname;
+			gsize len = 0;
+			gboolean ret = FALSE;
+
+			/* try to create the directory if it doesn't exist */
+			dirname = g_path_get_dirname (filename);
+			errno = 0;
+			if (mkdir (dirname, 0755) != 0) {
+				if (errno != EEXIST) {
+					g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_ACCES,
+					             "Error creating state directory %s: %d", dirname, errno);
+					g_free (dirname);
+					return FALSE;
+				}
+			}
+			g_free (dirname);
+
+			/* Write out the initial state to the state file */
+			g_key_file_set_boolean (state_file, "main", "NetworkingEnabled", *net_enabled);
+			g_key_file_set_boolean (state_file, "main", "WirelessEnabled", *wifi_enabled);
+			g_key_file_set_boolean (state_file, "main", "WWANEnabled", *wwan_enabled);
+
+			data = g_key_file_to_data (state_file, &len, NULL);
+			if (data)
+				ret = g_file_set_contents (filename, data, len, error);
+			g_free (data);
+
+			return ret;
+		} else {
+			g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+			g_clear_error (&tmp_error);
+		}
+
+		/* Otherwise, file probably corrupt or inaccessible */
+		return FALSE;
+	}
+
+	/* Reading state bits of NetworkManager; an error leaves the passed-in state
+	 * value unchanged.
+	 */
+	net = g_key_file_get_boolean (state_file, "main", "NetworkingEnabled", &tmp_error);
+	if (tmp_error)
+		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+	else
+		*net_enabled = net;
+	g_clear_error (&tmp_error);
+
+	wifi = g_key_file_get_boolean (state_file, "main", "WirelessEnabled", &tmp_error);
+	if (tmp_error) {
+		g_clear_error (error);
+		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+	} else
+		*wifi_enabled = wifi;
+	g_clear_error (&tmp_error);
+
+	wwan = g_key_file_get_boolean (state_file, "main", "WWANEnabled", &tmp_error);
+	if (tmp_error) {
+		g_clear_error (error);
+		g_set_error_literal (error, tmp_error->domain, tmp_error->code, tmp_error->message);
+	} else
+		*wwan_enabled = wwan;
+	g_clear_error (&tmp_error);
+
+	g_key_file_free (state_file);
+
+	return TRUE;
+}
+
+/*
+ * main
+ *
+ */
+int
+main (int argc, char *argv[])
+{
+	GOptionContext *opt_ctx = NULL;
+	gboolean become_daemon = FALSE;
+	gboolean g_fatal_warnings = FALSE;
+	char *pidfile = NULL, *state_file = NULL, *dhcp = NULL;
+	char *config = NULL, *plugins = NULL, *conf_plugins = NULL;
+	char *log_level = NULL, *log_domains = NULL;
+	gboolean wifi_enabled = TRUE, net_enabled = TRUE, wwan_enabled = TRUE;
+	gboolean success;
+	NMPolicy *policy = NULL;
+	NMVPNManager *vpn_manager = NULL;
+	NMNamedManager *named_mgr = NULL;
+	NMDBusManager *dbus_mgr = NULL;
+	NMSupplicantManager *sup_mgr = NULL;
+	NMDHCPManager *dhcp_mgr = NULL;
+	GError *error = NULL;
+	gboolean wrote_pidfile = FALSE;
+	char *cfg_log_level = NULL, *cfg_log_domains = NULL;
+
+	GOptionEntry options[] = {
+		{ "no-daemon", 0, 0, G_OPTION_ARG_NONE, &become_daemon, "Don't become a daemon", NULL },
+		{ "g-fatal-warnings", 0, 0, G_OPTION_ARG_NONE, &g_fatal_warnings, "Make all warnings fatal", NULL },
+		{ "pid-file", 0, 0, G_OPTION_ARG_FILENAME, &pidfile, "Specify the location of a PID file", "filename" },
+		{ "state-file", 0, 0, G_OPTION_ARG_FILENAME, &state_file, "State file location", "/path/to/state.file" },
+		{ "config", 0, 0, G_OPTION_ARG_FILENAME, &config, "Config file location", "/path/to/config.file" },
+		{ "plugins", 0, 0, G_OPTION_ARG_STRING, &plugins, "List of plugins separated by ','", "plugin1,plugin2" },
+		{ "log-level", 0, 0, G_OPTION_ARG_STRING, &log_level, "Log level: one of [ERR, WARN, INFO, DEBUG]", "INFO" },
+		{ "log-domains", 0, 0, G_OPTION_ARG_STRING, &log_domains,
+		        "Log domains separated by ',': any combination of [NONE,HW,RKILL,ETHER,WIFI,BT,MB,DHCP4,DHCP6,PPP,WIFI_SCAN,IP4,IP6,AUTOIP4,DNS,VPN,SHARING,SUPPLICANT,USER_SET,SYS_SET,SUSPEND,CORE,DEVICE,OLPC]",
+		        "HW,RFKILL,WIFI" },
+		{NULL}
+	};
+
+	if (getuid () != 0) {
+		fprintf (stderr, "You must be root to run NetworkManager!\n");
+		exit (1);
+	}
+
+	if (!g_module_supported ()) {
+		fprintf (stderr, "GModules are not supported on your platform!\n");
+		exit (1);
+	}
+
+	bindtextdomain (GETTEXT_PACKAGE, NMLOCALEDIR);
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+	textdomain (GETTEXT_PACKAGE);
+
+	/* Parse options */
+	opt_ctx = g_option_context_new ("");
+	g_option_context_set_translation_domain (opt_ctx, "UTF-8");
+	g_option_context_set_ignore_unknown_options (opt_ctx, FALSE);
+	g_option_context_set_help_enabled (opt_ctx, TRUE);
+	g_option_context_add_main_entries (opt_ctx, options, NULL);
+
+	g_option_context_set_summary (opt_ctx,
+		"NetworkManager monitors all network connections and automatically\nchooses the best connection to use.  It also allows the user to\nspecify wireless access points which wireless cards in the computer\nshould associate with.");
+
+	success = g_option_context_parse (opt_ctx, &argc, &argv, NULL);
+	g_option_context_free (opt_ctx);
+
+	if (!success) {
+		fprintf (stderr, _("Invalid option.  Please use --help to see a list of valid options.\n"));
+		exit (1);
+	}
+
+	pidfile = pidfile ? pidfile : g_strdup (NM_DEFAULT_PID_FILE);
+	state_file = state_file ? state_file : g_strdup (NM_DEFAULT_SYSTEM_STATE_FILE);
+
+	/* check pid file */
+	if (check_pidfile (pidfile))
+		exit (1);
+
+	/* Parse the config file */
+	if (config) {
+		if (!parse_config_file (config, &conf_plugins, &dhcp, &cfg_log_level, &cfg_log_domains, &error)) {
+			fprintf (stderr, "Config file %s invalid: (%d) %s\n",
+			         config,
+			         error ? error->code : -1,
+			         (error && error->message) ? error->message : "unknown");
+			exit (1);
+		}
+	} else {
+		gboolean parsed = FALSE;
+
+		/* Try NetworkManager.conf first */
+		if (g_file_test (NM_DEFAULT_SYSTEM_CONF_FILE, G_FILE_TEST_EXISTS)) {
+			config = g_strdup (NM_DEFAULT_SYSTEM_CONF_FILE);
+			parsed = parse_config_file (config, &conf_plugins, &dhcp, &cfg_log_level, &cfg_log_domains, &error);
+			if (!parsed) {
+				fprintf (stderr, "Default config file %s invalid: (%d) %s\n",
+				         config,
+				         error ? error->code : -1,
+				         (error && error->message) ? error->message : "unknown");
+				g_free (config);
+				config = NULL;
+				g_clear_error (&error);
+				/* Not a hard failure */
+			}
+		}
+
+		/* Try old nm-system-settings.conf next */
+		if (!parsed) {
+			config = g_strdup (NM_OLD_SYSTEM_CONF_FILE);
+			if (!parse_config_file (config, &conf_plugins, &dhcp, &cfg_log_level, &cfg_log_domains, &error)) {
+				fprintf (stderr, "Default config file %s invalid: (%d) %s\n",
+				         config,
+				         error ? error->code : -1,
+				         (error && error->message) ? error->message : "unknown");
+				g_free (config);
+				config = NULL;
+				g_clear_error (&error);
+				/* Not a hard failure */
+			}
+		}
+	}
+
+	/* Logging setup */
+	if (!nm_logging_setup (log_level ? log_level : cfg_log_level,
+	                       log_domains ? log_domains : cfg_log_domains,
+	                       &error)) {
+		fprintf (stderr,
+		         _("%s.  Please use --help to see a list of valid options.\n"),
+		         error->message);
+		exit (1);
+	}
+
+	/* Plugins specified with '--plugins' override those of config file */
+	plugins = plugins ? plugins : g_strdup (conf_plugins);
+	g_free (conf_plugins);
+
+	/* Parse the state file */
+	if (!parse_state_file (state_file, &net_enabled, &wifi_enabled, &wwan_enabled, &error)) {
+		fprintf (stderr, "State file %s parsing failed: (%d) %s\n",
+		         state_file,
+		         error ? error->code : -1,
+		         (error && error->message) ? error->message : "unknown");
+		/* Not a hard failure */
+	}
+	g_clear_error (&error);
+
+	/* Tricky: become_daemon is FALSE by default, so unless it's TRUE because
+	 * of a CLI option, it'll become TRUE after this
+	 */
+	become_daemon = !become_daemon;
+	if (become_daemon) {
+		if (daemon (0, 0) < 0) {
+			int saved_errno;
+
+			saved_errno = errno;
+			fprintf (stderr, "Could not daemonize: %s [error %u]\n",
+			         g_strerror (saved_errno),
+			         saved_errno);
+			exit (1);
+		}
+		if (write_pidfile (pidfile))
+			wrote_pidfile = TRUE;
+	}
+
+	if (g_fatal_warnings) {
+		GLogLevelFlags fatal_mask;
+
+		fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
+		fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
+		g_log_set_always_fatal (fatal_mask);
+	}
+
+	/*
+	 * Set the umask to 0022, which results in 0666 & ~0022 = 0644.
+	 * Otherwise, if root (or an su'ing user) has a wacky umask, we could
+	 * write out an unreadable resolv.conf.
+	 */
+	umask (022);
+
+	g_type_init ();
+	if (!g_thread_supported ())
+		g_thread_init (NULL);
+	dbus_g_thread_init ();
+
+	setup_signals ();
+
+	nm_logging_start (become_daemon);
+
+	nm_log_info (LOGD_CORE, "NetworkManager (version " NM_DIST_VERSION ") is starting...");
+	success = FALSE;
+
+	main_loop = g_main_loop_new (NULL, FALSE);
+
+	/* Create watch functions that monitor cards for link status. */
+	if (!nm_monitor_setup (&error)) {
+		nm_log_err (LOGD_CORE, "failed to start monitoring devices: %s.",
+		            error && error->message ? error->message : "(unknown)");
+		goto done;
+	}
+
+	/* Initialize our DBus service & connection */
+	dbus_mgr = nm_dbus_manager_get ();
+
+	vpn_manager = nm_vpn_manager_get ();
+	if (!vpn_manager) {
+		nm_log_err (LOGD_CORE, "failed to start the VPN manager.");
+		goto done;
+	}
+
+	named_mgr = nm_named_manager_get ();
+	if (!named_mgr) {
+		nm_log_err (LOGD_CORE, "failed to start the named manager.");
+		goto done;
+	}
+
+	manager = nm_manager_get (config,
+	                          plugins,
+	                          state_file,
+	                          net_enabled,
+	                          wifi_enabled,
+	                          wwan_enabled,
+	                          &error);
+	if (manager == NULL) {
+		nm_log_err (LOGD_CORE, "failed to initialize the network manager: %s",
+		          error && error->message ? error->message : "(unknown)");
+		goto done;
+	}
+
+	policy = nm_policy_new (manager, vpn_manager);
+	if (policy == NULL) {
+		nm_log_err (LOGD_CORE, "failed to initialize the policy.");
+		goto done;
+	}
+
+	/* Initialize the supplicant manager */
+	sup_mgr = nm_supplicant_manager_get ();
+	if (!sup_mgr) {
+		nm_log_err (LOGD_CORE, "failed to initialize the supplicant manager.");
+		goto done;
+	}
+
+	/* Initialize DHCP manager */
+	dhcp_mgr = nm_dhcp_manager_new (dhcp, &error);
+	if (!dhcp_mgr) {
+		nm_log_err (LOGD_CORE, "failed to start the DHCP manager: %s.", error->message);
+		goto done;
+	}
+
+	nm_dhcp_manager_set_hostname_provider (dhcp_mgr, NM_HOSTNAME_PROVIDER (manager));
+
+	/* Start our DBus service */
+	if (!nm_dbus_manager_start_service (dbus_mgr)) {
+		nm_log_err (LOGD_CORE, "failed to start the dbus service.");
+		goto done;
+	}
+
+	nm_manager_start (manager);
+
+	/* Bring up the loopback interface. */
+	nm_system_enable_loopback ();
+
+	success = TRUE;
+
+	/* Told to quit before getting to the mainloop by the signal handler */
+	if (quit_early == TRUE)
+		goto done;
+
+	g_main_loop_run (main_loop);
+
+done:
+	if (policy)
+		nm_policy_destroy (policy);
+
+	if (manager)
+		g_object_unref (manager);
+
+	if (vpn_manager)
+		g_object_unref (vpn_manager);
+
+	if (named_mgr)
+		g_object_unref (named_mgr);
+
+	if (dhcp_mgr)
+		g_object_unref (dhcp_mgr);
+
+	if (sup_mgr)
+		g_object_unref (sup_mgr);
+
+	if (dbus_mgr)
+		g_object_unref (dbus_mgr);
+
+	nm_logging_shutdown ();
+
+	if (pidfile && wrote_pidfile)
+		unlink (pidfile);
+
+	/* Free options */
+	g_free (pidfile);
+	g_free (state_file);
+	g_free (config);
+	g_free (plugins);
+	g_free (dhcp);
+	g_free (log_level);
+	g_free (log_domains);
+	g_free (cfg_log_level);
+	g_free (cfg_log_domains);
+
+	nm_log_info (LOGD_CORE, "exiting (%s)", success ? "success" : "error");
+	exit (success ? 0 : 1);
+}
diff --git a/src/modem-manager/Makefile.am b/src/modem-manager/Makefile.am
index fef879a..a0f65c1 100644
--- a/src/modem-manager/Makefile.am
+++ b/src/modem-manager/Makefile.am
@@ -1,5 +1,6 @@
 INCLUDES = \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_builddir}/marshallers
@@ -7,12 +8,12 @@ INCLUDES = \
 noinst_LTLIBRARIES = libmodem-manager.la
 
 libmodem_manager_la_SOURCES = \
+	nm-modem.c \
+	nm-modem.h \
 	nm-modem-cdma.c \
 	nm-modem-cdma.h \
 	nm-modem-gsm.c \
 	nm-modem-gsm.h \
-	nm-modem.c \
-	nm-modem.h \
 	nm-modem-manager.h \
 	nm-modem-manager.c \
 	nm-modem-types.h
@@ -22,20 +23,13 @@ libmodem_manager_la_CPPFLAGS = \
 
 libmodem_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS)
 
-nm-device-cdma-glue.h: $(top_srcdir)/introspection/nm-device-cdma.xml
-	dbus-binding-tool --prefix=nm_device_cdma --mode=glib-server --output=$@ $<
-
-nm-device-gsm-glue.h: $(top_srcdir)/introspection/nm-device-gsm.xml
-	dbus-binding-tool --prefix=nm_device_gsm --mode=glib-server --output=$@ $<
-
 nm-serial-device-glue.h: $(top_srcdir)/introspection/nm-device-serial.xml
 	dbus-binding-tool --prefix=nm_serial_device --mode=glib-server --output=$@ $<
 
 BUILT_SOURCES = \
-	nm-device-cdma-glue.h \
-	nm-device-gsm-glue.h \
 	nm-serial-device-glue.h
 
 CLEANFILES = $(BUILT_SOURCES)
diff --git a/src/modem-manager/nm-modem-cdma.c b/src/modem-manager/nm-modem-cdma.c
index 5e8405b..c32c182 100644
--- a/src/modem-manager/nm-modem-cdma.c
+++ b/src/modem-manager/nm-modem-cdma.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  */
 
@@ -24,18 +24,23 @@
 #include "nm-dbus-glib-types.h"
 #include "nm-modem-cdma.h"
 #include "nm-modem-types.h"
-#include "nm-device-interface.h"
-#include "nm-device-private.h"
+#include "nm-device.h"
 #include "nm-dbus-manager.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-cdma.h"
-#include "nm-utils.h"
 #include "NetworkManagerUtils.h"
-
-#include "nm-device-cdma-glue.h"
+#include "nm-logging.h"
 
 G_DEFINE_TYPE (NMModemCdma, nm_modem_cdma, NM_TYPE_MODEM)
 
+#define NM_MODEM_CDMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM_CDMA, NMModemCdmaPrivate))
+
+typedef struct {
+	DBusGProxyCall *call;
+
+	GHashTable *connect_properties;
+} NMModemCdmaPrivate;
+
 
 typedef enum {
 	NM_CDMA_ERROR_CONNECTION_NOT_CDMA = 0,
@@ -79,43 +84,77 @@ nm_cdma_error_get_type (void)
 }
 
 
-NMDevice *
+NMModem *
 nm_modem_cdma_new (const char *path,
                    const char *device,
                    const char *data_device,
-                   const char *driver)
+                   guint32 ip_method)
 {
 	g_return_val_if_fail (path != NULL, NULL);
 	g_return_val_if_fail (device != NULL, NULL);
 	g_return_val_if_fail (data_device != NULL, NULL);
-	g_return_val_if_fail (driver != NULL, NULL);
-
-	return (NMDevice *) g_object_new (NM_TYPE_MODEM_CDMA,
-	                                  NM_DEVICE_INTERFACE_UDI, path,
-	                                  NM_DEVICE_INTERFACE_IFACE, data_device,
-	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
-	                                  NM_MODEM_PATH, path,
-	                                  NM_MODEM_DEVICE, device,
-	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "CDMA",
-	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_CDMA,
-	                                  NULL);
+
+	return (NMModem *) g_object_new (NM_TYPE_MODEM_CDMA,
+	                                 NM_MODEM_PATH, path,
+	                                 NM_MODEM_DEVICE, device,
+	                                 NM_MODEM_IFACE, data_device,
+	                                 NM_MODEM_IP_METHOD, ip_method,
+	                                 NULL);
 }
 
 static void
-stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModemCdma *self = NM_MODEM_CDMA (user_data);
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
 	GError *error = NULL;
 
-	dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID);
-	if (!error)
-		nm_device_activate_schedule_stage2_device_config (device);
+	priv->call = NULL;
+
+	if (priv->connect_properties) {
+		g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = NULL;
+	}
+
+	if (dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID))
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, TRUE, NM_DEVICE_STATE_REASON_NONE);
 	else {
-		nm_warning ("CDMA modem connection failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_MB, "CDMA connection failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 		g_error_free (error);
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_NONE);
+	}
+}
+
+static void
+do_connect (NMModemCdma *self)
+{
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
+	DBusGProxy *proxy;
+
+	proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM_SIMPLE);
+	priv->call = dbus_g_proxy_begin_call_with_timeout (proxy,
+	                                                   "Connect", stage1_prepare_done,
+	                                                   self, NULL, 120000,
+	                                                   DBUS_TYPE_G_MAP_OF_VARIANT, priv->connect_properties,
+	                                                   G_TYPE_INVALID);
+}
+
+static void
+stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModemCdma *self = NM_MODEM_CDMA (user_data);
+	GError *error = NULL;
+
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
+		do_connect (self);
+	else {
+		nm_log_warn (LOGD_MB, "CDMA modem enable failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		g_error_free (error);
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
 	}
 }
 
@@ -136,61 +175,48 @@ create_connect_properties (NMConnection *connection)
 	return properties;
 }
 
-static void
-do_connect (NMModem *modem)
+static NMActStageReturn
+real_act_stage1_prepare (NMModem *modem,
+                         NMActRequest *req,
+                         GPtrArray **out_hints,
+                         const char **out_setting_name,
+                         NMDeviceStateReason *reason)
 {
+	NMModemCdma *self = NM_MODEM_CDMA (modem);
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
 	NMConnection *connection;
-	GHashTable *properties;
 
-	connection = nm_act_request_get_connection (nm_device_get_act_request (NM_DEVICE (modem)));
+	connection = nm_act_request_get_connection (req);
 	g_assert (connection);
 
-	properties = create_connect_properties (connection);
-	dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE),
-	                                      "Connect", stage1_prepare_done,
-	                                      modem, NULL, 120000,
-	                                      DBUS_TYPE_G_MAP_OF_VARIANT, properties,
-	                                      G_TYPE_INVALID);
-	g_hash_table_destroy (properties);
-}
-
-static void
-stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	GError *error = NULL;
-
-	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
-		do_connect (NM_MODEM (device));
-	else {
-		nm_warning ("CDMA modem enable failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
-		g_error_free (error);
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
-	}
-}
-
-static NMActStageReturn
-real_act_stage1_prepare (NMDevice *device, NMDeviceStateReason *reason)
-{
-	gboolean enabled = nm_modem_get_mm_enabled (NM_MODEM (device));
-
-	if (enabled)
-		do_connect (NM_MODEM (device));
-	else {
-		dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (NM_MODEM (device), MM_DBUS_INTERFACE_MODEM),
-		                                      "Enable", stage1_enable_done,
-		                                      device, NULL, 20000,
-		                                      G_TYPE_BOOLEAN, TRUE,
-		                                      G_TYPE_INVALID);
+	*out_setting_name = nm_connection_need_secrets (connection, out_hints);
+	if (!*out_setting_name) {
+		gboolean enabled = nm_modem_get_mm_enabled (modem);
+		DBusGProxy *proxy;
+
+		if (priv->connect_properties)
+			g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = create_connect_properties (connection);
+
+		if (enabled)
+			do_connect (self);
+		else {
+			proxy = nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM);
+			dbus_g_proxy_begin_call_with_timeout (proxy,
+			                                      "Enable", stage1_enable_done,
+			                                      modem, NULL, 20000,
+			                                      G_TYPE_BOOLEAN, TRUE,
+			                                      G_TYPE_INVALID);
+		}
+	} else {
+		/* NMModem will handle requesting secrets... */
 	}
 
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
 static NMConnection *
-real_get_best_auto_connection (NMDevice *dev,
+real_get_best_auto_connection (NMModem *modem,
 							   GSList *connections,
 							   char **specific_object)
 {
@@ -214,71 +240,8 @@ real_get_best_auto_connection (NMDevice *dev,
 	return NULL;
 }
 
-static void
-real_connection_secrets_updated (NMDevice *dev,
-								 NMConnection *connection,
-								 GSList *updated_settings,
-								 RequestSecretsCaller caller)
-{
-	NMActRequest *req;
-	gboolean found = FALSE;
-	GSList *iter;
-
-	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (dev)));
-
-	if (caller == SECRETS_CALLER_PPP) {
-		NMPPPManager *ppp_manager;
-		NMSettingCdma *s_cdma = NULL;
-
-		ppp_manager = nm_modem_get_ppp_manager (NM_MODEM (dev));
-		g_return_if_fail (ppp_manager != NULL);
-
-		s_cdma = (NMSettingCdma *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CDMA);
-		if (!s_cdma) {
-			/* Shouldn't ever happen */
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   NULL,
-										   NULL,
-										   "missing CDMA setting; no secrets could be found.");
-		} else {
-			const char *username = nm_setting_cdma_get_username (s_cdma);
-			const char *password = nm_setting_cdma_get_password (s_cdma);
-
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   username ? username : "",
-										   password ? password : "",
-										   NULL);
-		}
-		return;
-	}
-
-	g_return_if_fail (caller == SECRETS_CALLER_CDMA);
-	g_return_if_fail (nm_device_get_state (dev) == NM_DEVICE_STATE_NEED_AUTH);
-
-	for (iter = updated_settings; iter; iter = g_slist_next (iter)) {
-		const char *setting_name = (const char *) iter->data;
-
-		if (!strcmp (setting_name, NM_SETTING_CDMA_SETTING_NAME))
-			found = TRUE;
-		else
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
-	}
-
-	if (!found)
-		return;
-
-	req = nm_device_get_act_request (dev);
-	g_assert (req);
-
-	g_return_if_fail (nm_act_request_get_connection (req) == connection);
-
-	nm_device_activate_schedule_stage1_device_prepare (dev);
-}
-
 static gboolean
-real_check_connection_compatible (NMDevice *device,
+real_check_connection_compatible (NMModem *modem,
                                   NMConnection *connection,
                                   GError **error)
 {
@@ -306,15 +269,46 @@ real_check_connection_compatible (NMDevice *device,
 	return TRUE;
 }
 
-static const char *
-real_get_ppp_name (NMModem *device, NMConnection *connection)
+static gboolean
+real_get_user_pass (NMModem *modem,
+                    NMConnection *connection,
+                    const char **user,
+                    const char **pass)
 {
 	NMSettingCdma *s_cdma;
 
 	s_cdma = (NMSettingCdma *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CDMA);
-	g_assert (s_cdma);
+	if (!s_cdma)
+		return FALSE;
 
-	return nm_setting_cdma_get_username (s_cdma);
+	if (user)
+		*user = nm_setting_cdma_get_username (s_cdma);
+	if (pass)
+		*pass = nm_setting_cdma_get_password (s_cdma);
+
+	return TRUE;
+}
+
+static const char *
+real_get_setting_name (NMModem *modem)
+{
+	return NM_SETTING_CDMA_SETTING_NAME;
+}
+
+static void
+real_deactivate_quickly (NMModem *modem, NMDevice *device)
+{
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (modem);
+
+	if (priv->call) {
+		DBusGProxy *proxy;
+
+		proxy = nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE);
+		dbus_g_proxy_cancel_call (proxy, priv->call);
+		priv->call = NULL;
+	}
+
+	NM_MODEM_CLASS (nm_modem_cdma_parent_class)->deactivate_quickly (modem, device);	
 }
 
 /*****************************************************************************/
@@ -325,21 +319,33 @@ nm_modem_cdma_init (NMModemCdma *self)
 }
 
 static void
+dispose (GObject *object)
+{
+	NMModemCdma *self = NM_MODEM_CDMA (object);
+	NMModemCdmaPrivate *priv = NM_MODEM_CDMA_GET_PRIVATE (self);
+
+	if (priv->connect_properties)
+		g_hash_table_destroy (priv->connect_properties);
+
+	G_OBJECT_CLASS (nm_modem_cdma_parent_class)->dispose (object);
+}
+
+static void
 nm_modem_cdma_class_init (NMModemCdmaClass *klass)
 {
-	NMDeviceClass *device_class = NM_DEVICE_CLASS (klass);
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMModemClass *modem_class = NM_MODEM_CLASS (klass);
 
-	/* Virtual methods */
-	device_class->get_best_auto_connection = real_get_best_auto_connection;
-	device_class->connection_secrets_updated = real_connection_secrets_updated;
-	device_class->act_stage1_prepare = real_act_stage1_prepare;
-	device_class->check_connection_compatible = real_check_connection_compatible;
+	g_type_class_add_private (object_class, sizeof (NMModemCdmaPrivate));
 
-	modem_class->get_ppp_name = real_get_ppp_name;
-
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
-	                                 &dbus_glib_nm_device_cdma_object_info);
+	/* Virtual methods */
+	object_class->dispose = dispose;
+	modem_class->get_user_pass = real_get_user_pass;
+	modem_class->get_setting_name = real_get_setting_name;
+	modem_class->get_best_auto_connection = real_get_best_auto_connection;
+	modem_class->check_connection_compatible = real_check_connection_compatible;
+	modem_class->act_stage1_prepare = real_act_stage1_prepare;
+	modem_class->deactivate_quickly = real_deactivate_quickly;
 
 	dbus_g_error_domain_register (NM_CDMA_ERROR, NULL, NM_TYPE_CDMA_ERROR);
 }
diff --git a/src/modem-manager/nm-modem-cdma.h b/src/modem-manager/nm-modem-cdma.h
index 7c98ab2..0abe4e0 100644
--- a/src/modem-manager/nm-modem-cdma.h
+++ b/src/modem-manager/nm-modem-cdma.h
@@ -46,10 +46,10 @@ typedef struct {
 
 GType nm_modem_cdma_get_type (void);
 
-NMDevice *nm_modem_cdma_new (const char *path,
-                             const char *device,
-                             const char *data_device,
-                             const char *driver);
+NMModem *nm_modem_cdma_new (const char *path,
+                            const char *device,
+                            const char *data_device,
+                            guint32 ip_method);
 
 G_END_DECLS
 
diff --git a/src/modem-manager/nm-modem-gsm.c b/src/modem-manager/nm-modem-gsm.c
index fcc811f..abb96db 100644
--- a/src/modem-manager/nm-modem-gsm.c
+++ b/src/modem-manager/nm-modem-gsm.c
@@ -15,46 +15,58 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  */
 
 #include <string.h>
 #include "nm-dbus-glib-types.h"
 #include "nm-modem-gsm.h"
-#include "nm-device-private.h"
-#include "nm-device-interface.h"
+#include "nm-device.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-gsm.h"
 #include "nm-modem-types.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
 
-#include "nm-device-gsm-glue.h"
+typedef enum {
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_ANY = 0,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_GPRS,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_EDGE,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_UMTS,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSDPA,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_PREFERRED,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_PREFERRED,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_ONLY,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_ONLY,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSUPA,
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSPA,
+
+    MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_LAST = MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_HSPA
+} MMModemDeprecatedMode;
 
 typedef enum {
-    MM_MODEM_GSM_MODE_UNKNOWN      = 0x00000000,
-    MM_MODEM_GSM_MODE_ANY          = 0x00000001,
-    MM_MODEM_GSM_MODE_GPRS         = 0x00000002,
-    MM_MODEM_GSM_MODE_EDGE         = 0x00000004,
-    MM_MODEM_GSM_MODE_UMTS         = 0x00000008,
-    MM_MODEM_GSM_MODE_HSDPA        = 0x00000010,
-    MM_MODEM_GSM_MODE_2G_PREFERRED = 0x00000020,
-    MM_MODEM_GSM_MODE_3G_PREFERRED = 0x00000040,
-    MM_MODEM_GSM_MODE_2G_ONLY      = 0x00000080,
-    MM_MODEM_GSM_MODE_3G_ONLY      = 0x00000100,
-    MM_MODEM_GSM_MODE_HSUPA        = 0x00000200,
-    MM_MODEM_GSM_MODE_HSPA         = 0x00000400,
-
-    MM_MODEM_GSM_MODE_LAST = MM_MODEM_GSM_MODE_HSPA
-} MMModemGsmMode;
-
-
-#define GSM_SECRETS_TRIES "gsm-secrets-tries"
-#define PIN_TRIES "pin-tries"
+    MM_MODEM_GSM_ALLOWED_MODE_ANY          = 0,
+    MM_MODEM_GSM_ALLOWED_MODE_2G_PREFERRED = 1,
+    MM_MODEM_GSM_ALLOWED_MODE_3G_PREFERRED = 2,
+    MM_MODEM_GSM_ALLOWED_MODE_2G_ONLY      = 3,
+    MM_MODEM_GSM_ALLOWED_MODE_3G_ONLY      = 4,
+
+    MM_MODEM_GSM_ALLOWED_MODE_LAST = MM_MODEM_GSM_ALLOWED_MODE_3G_ONLY
+} MMModemGsmAllowedMode;
+
 
 G_DEFINE_TYPE (NMModemGsm, nm_modem_gsm, NM_TYPE_MODEM)
 
+#define NM_MODEM_GSM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM_GSM, NMModemGsmPrivate))
+
+typedef struct {
+	DBusGProxyCall *call;
+
+	GHashTable *connect_properties;
+	guint32 pin_tries;
+} NMModemGsmPrivate;
+
 
 typedef enum {
 	NM_GSM_ERROR_CONNECTION_NOT_GSM = 0,
@@ -98,28 +110,22 @@ nm_gsm_error_get_type (void)
 }
 
 
-NMDevice *
+NMModem *
 nm_modem_gsm_new (const char *path,
                   const char *device,
                   const char *data_device,
-                  const char *driver,
                   guint32 ip_method)
 {
 	g_return_val_if_fail (path != NULL, NULL);
 	g_return_val_if_fail (device != NULL, NULL);
 	g_return_val_if_fail (data_device != NULL, NULL);
-	g_return_val_if_fail (driver != NULL, NULL);
-
-	return (NMDevice *) g_object_new (NM_TYPE_MODEM_GSM,
-	                                  NM_DEVICE_INTERFACE_UDI, path,
-	                                  NM_DEVICE_INTERFACE_IFACE, data_device,
-	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
-	                                  NM_MODEM_PATH, path,
-	                                  NM_MODEM_IP_METHOD, ip_method,
-	                                  NM_MODEM_DEVICE, device,
-	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "GSM",
-	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_GSM,
-	                                  NULL);
+
+	return (NMModem *) g_object_new (NM_TYPE_MODEM_GSM,
+	                                 NM_MODEM_PATH, path,
+	                                 NM_MODEM_DEVICE, device,
+	                                 NM_MODEM_IFACE, data_device,
+	                                 NM_MODEM_IP_METHOD, ip_method,
+	                                 NULL);
 }
 
 static NMDeviceStateReason
@@ -158,93 +164,159 @@ translate_mm_error (GError *error)
 }
 
 static void
-clear_pin (NMDevice *device)
+ask_for_pin (NMModemGsm *self, gboolean always_ask)
 {
-	NMActRequest *req;
-	NMConnection *connection;
-	NMSettingGsm *setting;
+	NMModemGsmPrivate *priv;
+	guint32 tries = 0;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-	setting = NM_SETTING_GSM (nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM));
-	g_assert (setting);
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM_GSM (self));
+
+	priv = NM_MODEM_GSM_GET_PRIVATE (self);
 
-	g_object_set (G_OBJECT (setting), NM_SETTING_GSM_PIN, NULL, NULL);
+	if (!always_ask)
+		tries = priv->pin_tries++;
+
+	g_signal_emit_by_name (self, NM_MODEM_NEED_AUTH,
+	                       NM_SETTING_GSM_SETTING_NAME,
+	                       (tries || always_ask) ? TRUE : FALSE,
+	                       SECRETS_CALLER_MOBILE_BROADBAND,
+	                       NM_SETTING_GSM_PIN,
+	                       NULL);
 }
 
 static void
-request_secrets (NMDevice *device,
-                 const char *setting_name,
-                 const char *hint1,
-                 const char *hint2,
-                 const char *tries_tag,
-                 gboolean always_ask)
+stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 {
-	NMActRequest *req;
-	NMConnection *connection;
-	guint32 tries = 0;
+	NMModemGsm *self = NM_MODEM_GSM (user_data);
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+	GError *error = NULL;
 
-	g_return_if_fail (device != NULL);
-	g_return_if_fail (hint1 || hint2);
+	priv->call = NULL;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
+	if (priv->connect_properties) {
+		g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = NULL;
+	}
 
-	nm_device_state_changed (device, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
+	if (dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID))
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, TRUE, NM_DEVICE_STATE_REASON_NONE);
+	else {
+		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN))
+			ask_for_pin (self, FALSE);
+		else if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_WRONG))
+			ask_for_pin (self, TRUE);
+		else {
+			nm_log_warn (LOGD_MB, "GSM connection failed: (%d) %s",
+			             error ? error->code : -1,
+			             error && error->message ? error->message : "(unknown)");
 
-	if (!always_ask)
-		tries = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (connection), tries_tag));
+			g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, translate_mm_error (error));
+		}
 
-	nm_act_request_get_secrets (req,
-	                            setting_name ? setting_name : NM_SETTING_GSM_SETTING_NAME,
-	                            (tries || always_ask) ? TRUE : FALSE,
-	                            SECRETS_CALLER_GSM,
-	                            hint1,
-	                            hint2);
+		g_error_free (error);
+	}
+}
 
-	if (!always_ask)
-		g_object_set_data (G_OBJECT (connection), tries_tag, GUINT_TO_POINTER (++tries));
+static void
+do_connect (NMModemGsm *self)
+{
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+	DBusGProxy *proxy;
+
+	proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM_SIMPLE);
+	dbus_g_proxy_begin_call_with_timeout (proxy,
+	                                      "Connect", stage1_prepare_done,
+	                                      self, NULL, 120000,
+	                                      DBUS_TYPE_G_MAP_OF_VARIANT, priv->connect_properties,
+	                                      G_TYPE_INVALID);
+}
+
+static void stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data);
+
+static void
+do_enable (NMModemGsm *self)
+{
+	DBusGProxy *proxy;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM_GSM (self));
+
+	proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM);
+	dbus_g_proxy_begin_call_with_timeout (proxy,
+	                                      "Enable", stage1_enable_done,
+	                                      self, NULL, 20000,
+	                                      G_TYPE_BOOLEAN, TRUE,
+	                                      G_TYPE_INVALID);
 }
 
 static void
-stage1_prepare_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+stage1_pin_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModemGsm *self = NM_MODEM_GSM (user_data);
 	GError *error = NULL;
 
-	dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID);
-	if (!error)
-		nm_device_activate_schedule_stage2_device_config (device);
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
+		/* Success; go back and try the enable again */
+		do_enable (self);
+	} else {
+		nm_log_warn (LOGD_MB, "GSM PIN unlock failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+		g_error_free (error);
+
+		g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
+	}
+}
+
+static void
+handle_enable_pin_required (NMModemGsm *self)
+{
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+	const char *pin = NULL;
+	GValue *value;
+	DBusGProxy *proxy;
+
+	/* See if we have a PIN already */
+	value = g_hash_table_lookup (priv->connect_properties, "pin");
+	if (value && G_VALUE_HOLDS_STRING (value))
+		pin = g_value_get_string (value);
+
+	/* If we do, send it */
+	if (pin) {
+		proxy = nm_modem_get_proxy (NM_MODEM (self), MM_DBUS_INTERFACE_MODEM_GSM_CARD);
+		dbus_g_proxy_begin_call_with_timeout (proxy,
+		                                      "SendPin", stage1_pin_done,
+		                                      self, NULL, 10000,
+		                                      G_TYPE_STRING, pin,
+		                                      G_TYPE_INVALID);
+	} else
+		ask_for_pin (self, FALSE);
+}
+
+static void
+stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	NMModemGsm *self = NM_MODEM_GSM (user_data);
+	GError *error = NULL;
+
+	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
+		do_connect (self);
 	else {
-		const char *required_secret = NULL;
-		gboolean retry_secret = FALSE;
-
-		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN)) {
-			clear_pin (device);
-			required_secret = NM_SETTING_GSM_PIN;
-		} else if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_WRONG)) {
-			clear_pin (device);
-			required_secret = NM_SETTING_GSM_PIN;
-			retry_secret = TRUE;
-		} else {
-			nm_warning ("GSM modem connection failed: (%d) %s",
-			            error ? error->code : -1,
-			            error && error->message ? error->message : "(unknown)");
-		}
+		nm_log_warn (LOGD_MB, "GSM modem enable failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 
-		if (required_secret)
-			request_secrets (device, NULL, required_secret, NULL, PIN_TRIES, retry_secret);
+		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN))
+			handle_enable_pin_required (self);
 		else
-			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, translate_mm_error (error));
+			g_signal_emit_by_name (self, NM_MODEM_PREPARE_RESULT, FALSE, NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED);
 
 		g_error_free (error);
 	}
 }
 
+
 static GHashTable *
 create_connect_properties (NMConnection *connection)
 {
@@ -279,171 +351,72 @@ create_connect_properties (NMConnection *connection)
 	if (str)
 		value_hash_add_str (properties, "password", str);
 
+	/* Add both old and new preferred modes */
 	switch (nm_setting_gsm_get_network_type (setting)) {
 	case NM_SETTING_GSM_NETWORK_TYPE_UMTS_HSPA:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_3G_ONLY);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_ONLY);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_3G_ONLY);
 		break;
 	case NM_SETTING_GSM_NETWORK_TYPE_GPRS_EDGE:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_2G_ONLY);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_ONLY);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_2G_ONLY);
 		break;
 	case NM_SETTING_GSM_NETWORK_TYPE_PREFER_UMTS_HSPA:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_3G_PREFERRED);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_3G_PREFERRED);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_3G_PREFERRED);
 		break;
 	case NM_SETTING_GSM_NETWORK_TYPE_PREFER_GPRS_EDGE:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_2G_PREFERRED);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_2G_PREFERRED);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_2G_PREFERRED);
 		break;
 	default:
-		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_MODE_ANY);
+		value_hash_add_uint (properties, "network_mode", MM_MODEM_GSM_NETWORK_DEPRECATED_MODE_ANY);
+		value_hash_add_uint (properties, "allowed_mode", MM_MODEM_GSM_ALLOWED_MODE_ANY);
 		break;
 	}
 
-	/* FIXME: band */
-	return properties;
-}
-
-static void
-do_connect (NMModem *modem)
-{
-	NMConnection *connection;
-	GHashTable *properties;
-
-	connection = nm_act_request_get_connection (nm_device_get_act_request (NM_DEVICE (modem)));
-	g_assert (connection);
-
-	properties = create_connect_properties (connection);
-	dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE),
-	                                      "Connect", stage1_prepare_done,
-	                                      modem, NULL, 120000,
-	                                      DBUS_TYPE_G_MAP_OF_VARIANT, properties,
-	                                      G_TYPE_INVALID);
-	g_hash_table_destroy (properties);
-}
-
-static void
-stage1_pin_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	GError *error = NULL;
-
-	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
-		/* Success; go back and try the enable again */
-		nm_device_activate_schedule_stage1_device_prepare (device);
-	} else {
-		nm_warning ("GSM PIN unlock failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
-		g_error_free (error);
-
-		clear_pin (device);
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED);
-	}
-}
-
-static void
-handle_enable_pin_required (NMDevice *device)
-{
-	NMActRequest *req;
-	NMConnection *connection;
-	NMSettingGsm *s_gsm;
-	const char *pin = NULL;
-
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-
-	/* See if we have a PIN already */
-	s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-	if (s_gsm)
-		pin = nm_setting_gsm_get_pin (s_gsm);
-
-	/* If we do, send it */
-	if (pin) {
-		NMModem *modem = NM_MODEM (device);
-
-		dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_GSM_CARD),
-		                                      "SendPin", stage1_pin_done,
-		                                      modem, NULL, 10000,
-		                                      G_TYPE_STRING, pin,
-		                                      G_TYPE_INVALID);
-	} else {
-		/* Otherwise try to get the PIN */
-		request_secrets (device, NULL, NM_SETTING_GSM_PIN, NULL, PIN_TRIES, FALSE);
-	}
-}
-
-static void
-stage1_enable_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	GError *error = NULL;
-
-	if (dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID))
-		do_connect (NM_MODEM (device));
-	else {
-		nm_warning ("GSM modem enable failed: (%d) %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(unknown)");
+	/* Roaming */
+	if (nm_setting_gsm_get_home_only (setting))
+		value_hash_add_bool (properties, "home_only", TRUE);
 
-		if (dbus_g_error_has_name (error, MM_MODEM_ERROR_SIM_PIN))
-			handle_enable_pin_required (device);
-		else
-			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, translate_mm_error (error));
-
-		g_error_free (error);
-	}
+	return properties;
 }
 
 static NMActStageReturn
-real_act_stage1_prepare (NMDevice *device, NMDeviceStateReason *reason)
+real_act_stage1_prepare (NMModem *modem,
+                         NMActRequest *req,
+                         GPtrArray **out_hints,
+                         const char **out_setting_name,
+                         NMDeviceStateReason *reason)
 {
-	NMActRequest *req;
+	NMModemGsm *self = NM_MODEM_GSM (modem);
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
 	NMConnection *connection;
-	const char *setting_name;
-	GPtrArray *hints = NULL;
-	const char *hint1 = NULL, *hint2 = NULL;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
 	connection = nm_act_request_get_connection (req);
 	g_assert (connection);
 
-	setting_name = nm_connection_need_secrets (connection, &hints);
-	if (!setting_name) {
-		NMModem *modem = NM_MODEM (device);
+	*out_setting_name = nm_connection_need_secrets (connection, out_hints);
+	if (!*out_setting_name) {
 		gboolean enabled = nm_modem_get_mm_enabled (modem);
 
-		if (enabled)
-			do_connect (modem);
-		else {
-			dbus_g_proxy_begin_call_with_timeout (nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM),
-			                                      "Enable", stage1_enable_done,
-			                                      modem, NULL, 20000,
-			                                      G_TYPE_BOOLEAN, TRUE,
-			                                      G_TYPE_INVALID);
-		}
+		if (priv->connect_properties)
+			g_hash_table_destroy (priv->connect_properties);
+		priv->connect_properties = create_connect_properties (connection);
 
-		return NM_ACT_STAGE_RETURN_POSTPONE;
-	}
-
-	/* Get the required secrets */
-	if (hints) {
-		if (hints->len > 0)
-			hint1 = g_ptr_array_index (hints, 0);
-		if (hints->len > 1)
-			hint2 = g_ptr_array_index (hints, 1);
+		if (enabled)
+			do_connect (self);
+		else
+			do_enable (self);
+	} else {
+		/* NMModem will handle requesting secrets... */
 	}
 
-	request_secrets (device, setting_name, hint1, hint2, GSM_SECRETS_TRIES, FALSE);
-
-	if (hints)
-		g_ptr_array_free (hints, TRUE);
-
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
 static NMConnection *
-real_get_best_auto_connection (NMDevice *dev,
+real_get_best_auto_connection (NMModem *modem,
 							   GSList *connections,
 							   char **specific_object)
 {
@@ -467,112 +440,8 @@ real_get_best_auto_connection (NMDevice *dev,
 	return NULL;
 }
 
-static void
-real_connection_secrets_updated (NMDevice *dev,
-								 NMConnection *connection,
-								 GSList *updated_settings,
-								 RequestSecretsCaller caller)
-{
-	NMActRequest *req;
-	gboolean found = FALSE;
-	GSList *iter;
-
-	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (dev)));
-
-	if (caller == SECRETS_CALLER_PPP) {
-		NMPPPManager *ppp_manager;
-		NMSettingGsm *s_gsm = NULL;
-
-		ppp_manager = nm_modem_get_ppp_manager (NM_MODEM (dev));
-		g_return_if_fail (ppp_manager != NULL);
-
-		s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-		if (!s_gsm) {
-			/* Shouldn't ever happen */
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   NULL,
-										   NULL,
-										   "missing GSM setting; no secrets could be found.");
-		} else {
-			const char *username = nm_setting_gsm_get_username (s_gsm);
-			const char *password = nm_setting_gsm_get_password (s_gsm);
-
-			nm_ppp_manager_update_secrets (ppp_manager,
-										   nm_device_get_iface (dev),
-										   username ? username : "",
-										   password ? password : "",
-										   NULL);
-		}
-		return;
-	}
-
-	g_return_if_fail (caller == SECRETS_CALLER_GSM);
-	g_return_if_fail (nm_device_get_state (dev) == NM_DEVICE_STATE_NEED_AUTH);
-
-	for (iter = updated_settings; iter; iter = g_slist_next (iter)) {
-		const char *setting_name = (const char *) iter->data;
-
-		if (!strcmp (setting_name, NM_SETTING_GSM_SETTING_NAME))
-			found = TRUE;
-		else
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
-	}
-
-	if (!found)
-		return;
-
-	req = nm_device_get_act_request (dev);
-	g_assert (req);
-
-	g_return_if_fail (nm_act_request_get_connection (req) == connection);
-
-	nm_device_activate_schedule_stage1_device_prepare (dev);
-}
-
-static NMActStageReturn
-real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
-{
-	NMActRequest *req;
-	NMConnection *connection;
-
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-
-	/* Clear secrets tries counter since secrets were successfully used
-	 * already if we get here.
-	 */
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-	g_object_set_data (G_OBJECT (connection), GSM_SECRETS_TRIES, NULL);
-
-	if (NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->act_stage2_config)
-		return NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->act_stage2_config (device, reason);
-
-	return NM_ACT_STAGE_RETURN_SUCCESS;
-}
-
-static void
-real_deactivate_quickly (NMDevice *device)
-{
-	NMActRequest *req;
-	NMConnection *connection;
-
-	req = nm_device_get_act_request (device);
-	if (req) {
-		/* Clear the secrets attempts counter */
-		connection = nm_act_request_get_connection (req);
-		g_assert (connection);
-		g_object_set_data (G_OBJECT (connection), GSM_SECRETS_TRIES, NULL);
-		g_object_set_data (G_OBJECT (connection), PIN_TRIES, NULL);
-	}
-
-	if (NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->deactivate_quickly)
-		NM_DEVICE_CLASS (nm_modem_gsm_parent_class)->deactivate_quickly (device);
-}
-
 static gboolean
-real_check_connection_compatible (NMDevice *device,
+real_check_connection_compatible (NMModem *modem,
                                   NMConnection *connection,
                                   GError **error)
 {
@@ -600,17 +469,51 @@ real_check_connection_compatible (NMDevice *device,
 	return TRUE;
 }
 
-static const char *
-real_get_ppp_name (NMModem *device, NMConnection *connection)
+static gboolean
+real_get_user_pass (NMModem *modem,
+                    NMConnection *connection,
+                    const char **user,
+                    const char **pass)
 {
 	NMSettingGsm *s_gsm;
 
 	s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-	g_assert (s_gsm);
+	if (!s_gsm)
+		return FALSE;
+
+	if (user)
+		*user = nm_setting_gsm_get_username (s_gsm);
+	if (pass)
+		*pass = nm_setting_gsm_get_password (s_gsm);
+
+	return TRUE;
+}
+
+static const char *
+real_get_setting_name (NMModem *modem)
+{
+	return NM_SETTING_GSM_SETTING_NAME;
+}
+
+static void
+real_deactivate_quickly (NMModem *modem, NMDevice *device)
+{
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (modem);
+
+	if (priv->call) {
+		DBusGProxy *proxy;
 
-	return nm_setting_gsm_get_username (s_gsm);
+		proxy = nm_modem_get_proxy (modem, MM_DBUS_INTERFACE_MODEM_SIMPLE);
+		dbus_g_proxy_cancel_call (proxy, priv->call);
+		priv->call = NULL;
+	}
+
+	priv->pin_tries = 0;
+
+	NM_MODEM_CLASS (nm_modem_gsm_parent_class)->deactivate_quickly (modem, device);	
 }
 
+
 /*****************************************************************************/
 
 static void
@@ -619,23 +522,33 @@ nm_modem_gsm_init (NMModemGsm *self)
 }
 
 static void
+dispose (GObject *object)
+{
+	NMModemGsm *self = NM_MODEM_GSM (object);
+	NMModemGsmPrivate *priv = NM_MODEM_GSM_GET_PRIVATE (self);
+
+	if (priv->connect_properties)
+		g_hash_table_destroy (priv->connect_properties);
+
+	G_OBJECT_CLASS (nm_modem_gsm_parent_class)->dispose (object);
+}
+
+static void
 nm_modem_gsm_class_init (NMModemGsmClass *klass)
 {
-	NMDeviceClass *device_class = NM_DEVICE_CLASS (klass);
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMModemClass *modem_class = NM_MODEM_CLASS (klass);
 
-	/* Virtual methods */
-	device_class->get_best_auto_connection = real_get_best_auto_connection;
-	device_class->connection_secrets_updated = real_connection_secrets_updated;
-	device_class->act_stage1_prepare = real_act_stage1_prepare;
-	device_class->act_stage2_config = real_act_stage2_config;
-	device_class->deactivate_quickly = real_deactivate_quickly;
-	device_class->check_connection_compatible = real_check_connection_compatible;
-
-	modem_class->get_ppp_name = real_get_ppp_name;
+	g_type_class_add_private (object_class, sizeof (NMModemGsmPrivate));
 
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
-									 &dbus_glib_nm_device_gsm_object_info);
+	/* Virtual methods */
+	object_class->dispose = dispose;
+	modem_class->get_user_pass = real_get_user_pass;
+	modem_class->get_setting_name = real_get_setting_name;
+	modem_class->get_best_auto_connection = real_get_best_auto_connection;
+	modem_class->check_connection_compatible = real_check_connection_compatible;
+	modem_class->act_stage1_prepare = real_act_stage1_prepare;
+	modem_class->deactivate_quickly = real_deactivate_quickly;
 
 	dbus_g_error_domain_register (NM_GSM_ERROR, NULL, NM_TYPE_GSM_ERROR);
 }
diff --git a/src/modem-manager/nm-modem-gsm.h b/src/modem-manager/nm-modem-gsm.h
index 8479473..f481bdb 100644
--- a/src/modem-manager/nm-modem-gsm.h
+++ b/src/modem-manager/nm-modem-gsm.h
@@ -46,11 +46,10 @@ typedef struct {
 
 GType nm_modem_gsm_get_type (void);
 
-NMDevice *nm_modem_gsm_new (const char *path,
-                            const char *device,
-                            const char *data_device,
-                            const char *driver,
-                            guint32 ip_method);
+NMModem *nm_modem_gsm_new (const char *path,
+                           const char *device,
+                           const char *data_device,
+                           guint32 ip_method);
 
 G_END_DECLS
 
diff --git a/src/modem-manager/nm-modem-manager.c b/src/modem-manager/nm-modem-manager.c
index 94e1a11..28f7b94 100644
--- a/src/modem-manager/nm-modem-manager.c
+++ b/src/modem-manager/nm-modem-manager.c
@@ -15,19 +15,20 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  * Copyright (C) 2009 Canonical Ltd.
  */
 
 #include <string.h>
 #include "nm-modem-manager.h"
+#include "nm-logging.h"
 #include "nm-modem.h"
 #include "nm-modem-gsm.h"
 #include "nm-modem-cdma.h"
 #include "nm-dbus-manager.h"
-#include "nm-utils.h"
 #include "nm-modem-types.h"
+#include "nm-marshal.h"
 
 #define MODEM_POKE_INTERVAL 120
 
@@ -44,8 +45,8 @@ typedef struct {
 } NMModemManagerPrivate;
 
 enum {
-	DEVICE_ADDED,
-	DEVICE_REMOVED,
+	MODEM_ADDED,
+	MODEM_REMOVED,
 
 	LAST_SIGNAL
 };
@@ -67,25 +68,6 @@ nm_modem_manager_get (void)
 	return singleton;
 }
 
-gboolean
-nm_modem_manager_has_modem_for_iface (NMModemManager *manager,
-                                      const gchar *iface)
-{
-	NMModemManagerPrivate *priv = NM_MODEM_MANAGER_GET_PRIVATE (manager);
-	GList *iter;
-	g_assert (manager);
-	g_assert (NM_IS_MODEM_MANAGER(manager));
-	g_assert (iface);
-
-	for (iter = g_hash_table_get_values(priv->modems); iter != NULL; iter = iter->next) {
-		NMDevice *device = NM_DEVICE(iter->data);
-		const gchar *device_iface = nm_device_get_iface (device);
-		if (!g_strcmp0 (iface, device_iface))
-			return TRUE;
-	}
-	return FALSE;
-}
-
 static gboolean
 get_modem_properties (DBusGConnection *connection,
 					  const char *path,
@@ -113,7 +95,7 @@ get_modem_properties (DBusGConnection *connection,
 		*type = g_value_get_uint (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get device type: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get device type: %s", err->message);
 		goto out;
 	}
 
@@ -126,7 +108,7 @@ get_modem_properties (DBusGConnection *connection,
 		*device = g_value_dup_string (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get device: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get device: %s", err->message);
 		goto out;
 	}
 
@@ -139,7 +121,7 @@ get_modem_properties (DBusGConnection *connection,
 		*ip_method = g_value_get_uint (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get IP method: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get IP method: %s", err->message);
 		goto out;
 	}
 
@@ -152,7 +134,7 @@ get_modem_properties (DBusGConnection *connection,
 		*data_device = g_value_dup_string (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get modem data device: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get modem data device: %s", err->message);
 		goto out;
 	}
 
@@ -165,7 +147,7 @@ get_modem_properties (DBusGConnection *connection,
 		*driver = g_value_dup_string (&value);
 		g_value_unset (&value);
 	} else {
-		g_warning ("Could not get modem driver: %s", err->message);
+		nm_log_warn (LOGD_MB, "could not get modem driver: %s", err->message);
 		goto out;
 	}
 
@@ -182,13 +164,13 @@ static void
 create_modem (NMModemManager *manager, const char *path)
 {
 	NMModemManagerPrivate *priv = NM_MODEM_MANAGER_GET_PRIVATE (manager);
-	NMDevice *device;
+	NMModem *modem = NULL;
 	char *data_device = NULL, *driver = NULL, *master_device = NULL;
 	uint modem_type = MM_MODEM_TYPE_UNKNOWN;
 	uint ip_method = MM_MODEM_IP_METHOD_PPP;
 
 	if (g_hash_table_lookup (priv->modems, path)) {
-		nm_warning ("Modem with path %s already exists, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s already exists, ignoring", path);
 		return;
 	}
 
@@ -198,39 +180,40 @@ create_modem (NMModemManager *manager, const char *path)
 		return;
 
 	if (modem_type == MM_MODEM_TYPE_UNKNOWN) {
-		nm_warning ("Modem with path %s has unknown type, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown type, ignoring", path);
 		return;
 	}
 
 	if (!master_device || !strlen (master_device)) {
-		nm_warning ("Modem with path %s has unknown device, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown device, ignoring", path);
 		return;
 	}
 
 	if (!driver || !strlen (driver)) {
-		nm_warning ("Modem with path %s has unknown driver, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown driver, ignoring", path);
 		return;
 	}
 
 	if (!data_device || !strlen (data_device)) {
-		nm_warning ("Modem with path %s has unknown data device, ignoring", path);
+		nm_log_warn (LOGD_MB, "modem with path %s has unknown data device, ignoring", path);
 		return;
 	}
 
 	if (modem_type == MM_MODEM_TYPE_GSM)
-		device = nm_modem_gsm_new (path, master_device, data_device, driver, ip_method);
+		modem = nm_modem_gsm_new (path, master_device, data_device, ip_method);
 	else if (modem_type == MM_MODEM_TYPE_CDMA)
-		device = nm_modem_cdma_new (path, master_device, data_device, driver);
+		modem = nm_modem_cdma_new (path, master_device, data_device, ip_method);
 	else
-		g_error ("Invalid modem type");
+		nm_log_warn (LOGD_MB, "unknown modem type '%d'", modem_type);
 
 	g_free (data_device);
-	g_free (driver);
 
-	if (device) {
-		g_hash_table_insert (priv->modems, g_strdup (path), device);
-		g_signal_emit (manager, signals[DEVICE_ADDED], 0, device);
+	if (modem) {
+		g_hash_table_insert (priv->modems, g_strdup (path), modem);
+		g_signal_emit (manager, signals[MODEM_ADDED], 0, modem, driver);
 	}
+
+	g_free (driver);
 }
 
 static void
@@ -247,7 +230,7 @@ modem_removed (DBusGProxy *proxy, const char *path, gpointer user_data)
 
 	modem = (NMModem *) g_hash_table_lookup (priv->modems, path);
 	if (modem) {
-		g_signal_emit (user_data, signals[DEVICE_REMOVED], 0, modem);
+		g_signal_emit (user_data, signals[MODEM_REMOVED], 0, modem);
 		g_hash_table_remove (priv->modems, path);
 	}
 }
@@ -282,7 +265,7 @@ enumerate_devices_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer dat
 	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
 								dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &modems,
 								G_TYPE_INVALID)) {
-		nm_warning ("Could not get modem list: %s", error->message);
+		nm_log_warn (LOGD_MB, "could not get modem list: %s", error->message);
 		g_error_free (error);
 	} else {
 		int i;
@@ -308,7 +291,7 @@ modem_manager_appeared (NMModemManager *self, gboolean enumerate_devices)
 		priv->poke_id = 0;
 	}
 
-	nm_info ("modem-manager is now available");
+	nm_log_info (LOGD_MB, "modem-manager is now available");
 
 	priv->proxy = dbus_g_proxy_new_for_name (nm_dbus_manager_get_connection (priv->dbus_mgr),
 											 MM_DBUS_SERVICE, MM_DBUS_PATH, MM_DBUS_INTERFACE);
@@ -330,7 +313,7 @@ modem_manager_appeared (NMModemManager *self, gboolean enumerate_devices)
 static gboolean
 remove_one_modem (gpointer key, gpointer value, gpointer user_data)
 {
-	g_signal_emit (user_data, signals[DEVICE_REMOVED], 0, value);
+	g_signal_emit (user_data, signals[MODEM_REMOVED], 0, value);
 
 	return TRUE;
 }
@@ -348,7 +331,7 @@ modem_manager_disappeared (NMModemManager *self)
 	}
 
 	/* Try to activate the modem-manager */
-	nm_info ("Trying to start the modem-manager...");
+	nm_log_info (LOGD_MB, "trying to start the modem manager...");
 	poke_modem_cb (self);
 	priv->poke_id = g_timeout_add_seconds (MODEM_POKE_INTERVAL, poke_modem_cb, self);
 }
@@ -373,7 +356,7 @@ nm_modem_manager_name_owner_changed (NMDBusManager *dbus_mgr,
 	if (!old_owner_good && new_owner_good) {
 		modem_manager_appeared (NM_MODEM_MANAGER (user_data), FALSE);
 	} else if (old_owner_good && !new_owner_good) {
-		nm_info ("modem manager disappeared");
+		nm_log_info (LOGD_MB, "the modem manager disappeared");
 		modem_manager_disappeared (NM_MODEM_MANAGER (user_data));
 	}
 }
@@ -440,23 +423,21 @@ nm_modem_manager_class_init (NMModemManagerClass *klass)
 	object_class->dispose = dispose;
 
 	/* signals */
-	signals[DEVICE_ADDED] =
-		g_signal_new ("device-added",
+	signals[MODEM_ADDED] =
+		g_signal_new ("modem-added",
 					  G_OBJECT_CLASS_TYPE (object_class),
 					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMModemManagerClass, device_added),
+					  G_STRUCT_OFFSET (NMModemManagerClass, modem_added),
 					  NULL, NULL,
-					  g_cclosure_marshal_VOID__OBJECT,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_OBJECT);
+					  _nm_marshal_VOID__OBJECT_STRING,
+					  G_TYPE_NONE, 2, G_TYPE_OBJECT, G_TYPE_STRING);
 
-	signals[DEVICE_REMOVED] =
-		g_signal_new ("device-removed",
+	signals[MODEM_REMOVED] =
+		g_signal_new ("modem-removed",
 					  G_OBJECT_CLASS_TYPE (object_class),
 					  G_SIGNAL_RUN_FIRST,
-					  G_STRUCT_OFFSET (NMModemManagerClass, device_removed),
+					  G_STRUCT_OFFSET (NMModemManagerClass, modem_removed),
 					  NULL, NULL,
 					  g_cclosure_marshal_VOID__OBJECT,
-					  G_TYPE_NONE, 1,
-					  G_TYPE_OBJECT);
+					  G_TYPE_NONE, 1, G_TYPE_OBJECT);
 }
diff --git a/src/modem-manager/nm-modem-manager.h b/src/modem-manager/nm-modem-manager.h
index f9d8ded..56427ba 100644
--- a/src/modem-manager/nm-modem-manager.h
+++ b/src/modem-manager/nm-modem-manager.h
@@ -24,7 +24,7 @@
 #define NM_MODEM_MANAGER_H
 
 #include <glib-object.h>
-#include "nm-device.h"
+#include "nm-modem.h"
 
 #define NM_TYPE_MODEM_MANAGER				(nm_modem_manager_get_type ())
 #define NM_MODEM_MANAGER(obj)				(G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_MODEM_MANAGER, NMModemManager))
@@ -41,18 +41,13 @@ typedef struct {
 	GObjectClass parent;
 
 	/* Signals */
-	void (*device_added) (NMModemManager *manager,
-						  NMDevice *device);
+	void (*modem_added) (NMModemManager *manager, NMModem *modem, const char *driver);
 
-	void (*device_removed) (NMModemManager *manager,
-							NMDevice *device);
+	void (*modem_removed) (NMModemManager *manager, NMModem *modem);
 } NMModemManagerClass;
 
 GType nm_modem_manager_get_type (void);
 
 NMModemManager *nm_modem_manager_get (void);
 
-gboolean nm_modem_manager_has_modem_for_iface (NMModemManager *manager,
-                                               const gchar *iface);
-
 #endif /* NM_MODEM_MANAGER_H */
diff --git a/src/modem-manager/nm-modem.c b/src/modem-manager/nm-modem.c
index 5b001ee..d9413ed 100644
--- a/src/modem-manager/nm-modem.c
+++ b/src/modem-manager/nm-modem.c
@@ -15,37 +15,34 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  * Copyright (C) 2009 Novell, Inc.
  */
 
 #include <string.h>
 #include "nm-modem.h"
-#include "nm-device-private.h"
-#include "NetworkManagerSystem.h"
-#include "nm-device-interface.h"
+#include "nm-system.h"
 #include "nm-dbus-manager.h"
 #include "nm-setting-connection.h"
-#include "nm-setting-gsm.h"
-#include "nm-setting-cdma.h"
 #include "nm-marshal.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-modem-types.h"
-#include "nm-utils.h"
-#include "nm-serial-device-glue.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
+#include "nm-device-private.h"
+#include "nm-device-interface.h"
 #include "nm-dbus-glib-types.h"
 
-static void device_interface_init (NMDeviceInterface *iface_class);
+#include "nm-serial-device-glue.h"
 
-G_DEFINE_TYPE_EXTENDED (NMModem, nm_modem, NM_TYPE_DEVICE, 0,
-                        G_IMPLEMENT_INTERFACE (NM_TYPE_DEVICE_INTERFACE, device_interface_init))
+G_DEFINE_TYPE (NMModem, nm_modem, G_TYPE_OBJECT)
 
 #define NM_MODEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_MODEM, NMModemPrivate))
 
 enum {
 	PROP_0,
 	PROP_DEVICE,
+	PROP_IFACE,
 	PROP_PATH,
 	PROP_IP_METHOD,
 	PROP_ENABLED,
@@ -63,6 +60,11 @@ typedef struct {
 	NMIP4Config	 *pending_ip4_config;
 	guint32 ip_method;
 	char *device;
+	char *iface;
+
+	guint32 secrets_tries;
+
+	DBusGProxyCall *call;
 
 	gboolean mm_enabled;
 
@@ -73,7 +75,10 @@ typedef struct {
 
 enum {
 	PPP_STATS,
-	PROPERTIES_CHANGED,
+	PPP_FAILED,
+	PREPARE_RESULT,
+	IP4_CONFIG_RESULT,
+	NEED_AUTH,
 
 	LAST_SIGNAL
 };
@@ -120,17 +125,19 @@ nm_modem_get_proxy (NMModem *self,
 	return priv->proxy;
 }
 
-const char *
-nm_modem_get_ppp_name (NMModem *self,
-					   NMConnection *connection)
+static void
+merge_ip4_config (NMActRequest *req, NMIP4Config *config)
 {
-	g_return_val_if_fail (NM_IS_MODEM (self), NULL);
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+	NMConnection *connection;
+	NMSettingIP4Config *s_ip4;
 
-	if (NM_MODEM_GET_CLASS (self)->get_ppp_name)
-		return NM_MODEM_GET_CLASS (self)->get_ppp_name (self, connection);
+	/* Merge user-defined overrides into the IP4Config to be applied */
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
 
-	return NULL;
+	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
+	if (s_ip4)
+		nm_utils_merge_ip4_config (config, s_ip4);
 }
 
 /*****************************************************************************/
@@ -139,14 +146,12 @@ nm_modem_get_ppp_name (NMModem *self,
 static void
 ppp_state_changed (NMPPPManager *ppp_manager, NMPPPStatus status, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
-
 	switch (status) {
 	case NM_PPP_STATUS_DISCONNECT:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_DISCONNECT);
+		g_signal_emit (NM_MODEM (user_data), signals[PPP_FAILED], 0, NM_DEVICE_STATE_REASON_PPP_DISCONNECT);
 		break;
 	case NM_PPP_STATUS_DEAD:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_FAILED);
+		g_signal_emit (NM_MODEM (user_data), signals[PPP_FAILED], 0, NM_DEVICE_STATE_REASON_PPP_FAILED);
 		break;
 	default:
 		break;
@@ -159,7 +164,8 @@ ppp_ip4_config (NMPPPManager *ppp_manager,
 				NMIP4Config *config,
 				gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModem *self = NM_MODEM (user_data);
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	guint32 i, num;
 	guint32 bad_dns1 = htonl (0x0A0B0C0D);
 	guint32 good_dns1 = htonl (0x04020201);  /* GTE nameserver */
@@ -167,10 +173,6 @@ ppp_ip4_config (NMPPPManager *ppp_manager,
 	guint32 good_dns2 = htonl (0x04020202);  /* GTE nameserver */
 	gboolean dns_workaround = FALSE;
 
-	/* Ignore PPP IP4 events that come in after initial configuration */
-	if (nm_device_get_state (device) != NM_DEVICE_STATE_IP_CONFIG)
-		return;
-
 	/* Work around a PPP bug (#1732) which causes many mobile broadband
 	 * providers to return 10.11.12.13 and 10.11.12.14 for the DNS servers.
 	 * Apparently fixed in ppp-2.4.5 but we've had some reports that this is
@@ -201,14 +203,14 @@ ppp_ip4_config (NMPPPManager *ppp_manager,
 	}
 
 	if (!num || dns_workaround) {
+		nm_log_warn (LOGD_PPP, "compensating for invalid PPP-provided nameservers");
 		nm_ip4_config_reset_nameservers (config);
 		nm_ip4_config_add_nameserver (config, good_dns1);
 		nm_ip4_config_add_nameserver (config, good_dns2);
 	}
 
-	nm_device_set_ip_iface (device, iface);
-	NM_MODEM_GET_PRIVATE (device)->pending_ip4_config = g_object_ref (config);
-	nm_device_activate_schedule_stage4_ip4_config_get (device);
+	priv->pending_ip4_config = g_object_ref (config);
+	g_signal_emit (self, signals[IP4_CONFIG_RESULT], 0, iface, config, NULL);
 }
 
 static void
@@ -229,36 +231,47 @@ ppp_stats (NMPPPManager *ppp_manager,
 }
 
 static NMActStageReturn
-ppp_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+ppp_stage3_ip4_config_start (NMModem *self,
+                             NMActRequest *req,
+                             NMDeviceStateReason *reason)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
-	NMActRequest *req;
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	const char *ppp_name = NULL;
-	GError *err = NULL;
+	GError *error = NULL;
 	NMActStageReturn ret;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (req != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason !=	NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
-	ppp_name = nm_modem_get_ppp_name (NM_MODEM (device),
-									  nm_act_request_get_connection (req));
+	if (NM_MODEM_GET_CLASS (self)->get_user_pass) {
+		NMConnection *connection = nm_act_request_get_connection (req);
 
-	priv->ppp_manager = nm_ppp_manager_new (nm_device_get_iface (device));
-	if (nm_ppp_manager_start (priv->ppp_manager, req, ppp_name, 20, &err)) {
+		g_assert (connection);
+		if (!NM_MODEM_GET_CLASS (self)->get_user_pass (self, connection, &ppp_name, NULL))
+			return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	priv->ppp_manager = nm_ppp_manager_new (priv->iface);
+	if (nm_ppp_manager_start (priv->ppp_manager, req, ppp_name, 20, &error)) {
 		g_signal_connect (priv->ppp_manager, "state-changed",
 						  G_CALLBACK (ppp_state_changed),
-						  device);
+						  self);
 		g_signal_connect (priv->ppp_manager, "ip4-config",
 						  G_CALLBACK (ppp_ip4_config),
-						  device);
+						  self);
 		g_signal_connect (priv->ppp_manager, "stats",
 						  G_CALLBACK (ppp_stats),
-						  device);
+						  self);
 
 		ret = NM_ACT_STAGE_RETURN_POSTPONE;
 	} else {
-		nm_warning ("%s", err->message);
-		g_error_free (err);
+		nm_log_err (LOGD_PPP, "error starting PPP: (%d) %s",
+		            error ? error->code : -1,
+		            error && error->message ? error->message : "(unknown)");
+		g_error_free (error);
 
 		g_object_unref (priv->ppp_manager);
 		priv->ppp_manager = NULL;
@@ -271,20 +284,17 @@ ppp_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
 }
 
 static NMActStageReturn
-ppp_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
+ppp_stage4 (NMModem *self,
+            NMActRequest *req,
+            NMIP4Config **config,
+            NMDeviceStateReason *reason)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
-	NMConnection *connection;
-	NMSettingIP4Config *s_ip4;
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 
 	*config = priv->pending_ip4_config;
 	priv->pending_ip4_config = NULL;
 
-	/* Merge user-defined overrides into the IP4Config to be applied */
-	connection = nm_act_request_get_connection (nm_device_get_act_request (device));
-	g_assert (connection);
-	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-	nm_utils_merge_ip4_config (*config, s_ip4);
+	merge_ip4_config (req, *config);
 
 	return NM_ACT_STAGE_RETURN_SUCCESS;
 }
@@ -293,57 +303,75 @@ ppp_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
 /* IP method static */
 
 static void
-static_stage3_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+static_stage3_done (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
 {
-	NMDevice *device = NM_DEVICE (user_data);
+	NMModem *self = NM_MODEM (user_data);
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	GValueArray *ret_array = NULL;
 	GError *error = NULL;
+	NMIP4Config *config = NULL;
+
+	priv->call = NULL;
 
-	if (dbus_g_proxy_end_call (proxy, call_id, &error,
+	if (dbus_g_proxy_end_call (proxy, call, &error,
 							   G_TYPE_VALUE_ARRAY, &ret_array,
 							   G_TYPE_INVALID)) {
-
-		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
 		NMIP4Address *addr;
 		int i;
 
+		config = nm_ip4_config_new ();
+
 		addr = nm_ip4_address_new ();
 		nm_ip4_address_set_address (addr, g_value_get_uint (g_value_array_get_nth (ret_array, 0)));
 		nm_ip4_address_set_prefix (addr, 32);
+		nm_ip4_config_take_address (config, addr);
 
-		priv->pending_ip4_config = nm_ip4_config_new ();
-		nm_ip4_config_take_address (priv->pending_ip4_config, addr);
-
-		for (i = 1; i < ret_array->n_values; i++)
-			nm_ip4_config_add_nameserver (priv->pending_ip4_config,
-										  g_value_get_uint (g_value_array_get_nth (ret_array, i)));
+		for (i = 0; i < ret_array->n_values; i++) {
+			GValue *value = g_value_array_get_nth (ret_array, i);
 
+			nm_ip4_config_add_nameserver (config, g_value_get_uint (value));
+		}
 		g_value_array_free (ret_array);
-		nm_device_activate_schedule_stage4_ip4_config_get (device);
-	} else {
-		nm_warning ("Retrieving IP4 configuration failed: %s", error->message);
-		g_error_free (error);
-		nm_device_state_changed (device,
-								 NM_DEVICE_STATE_FAILED,
-								 NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);
+
+		priv->pending_ip4_config = g_object_ref (config);
+		g_signal_emit (self, signals[IP4_CONFIG_RESULT], 0, NULL, config, NULL);
 	}
+
+	g_signal_emit (self, signals[IP4_CONFIG_RESULT], 0, NULL, config, error);
+	g_clear_error (&error);
 }
 
 static NMActStageReturn
-static_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+static_stage3_ip4_config_start (NMModem *self,
+                                NMActRequest *req,
+                                NMDeviceStateReason *reason)
 {
-	dbus_g_proxy_begin_call (nm_modem_get_proxy (NM_MODEM (device), MM_DBUS_INTERFACE_MODEM),
-							 "GetIP4Config", static_stage3_done,
-							 device, NULL,
-							 G_TYPE_INVALID);
+	NMModemPrivate *priv;
+
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (req != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason !=	NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+
+	priv->call = dbus_g_proxy_begin_call (nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM),
+	                                      "GetIP4Config", static_stage3_done,
+	                                      self, NULL,
+	                                      G_TYPE_INVALID);
 
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
 static NMActStageReturn
-static_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
+static_stage4 (NMModem *self,
+               NMActRequest *req,
+               NMDevice *device,
+               NMIP4Config **config,
+               NMDeviceStateReason *reason)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	gboolean no_firmware = FALSE;
 
 	if (!nm_device_hw_bring_up (device, TRUE, &no_firmware)) {
@@ -357,28 +385,47 @@ static_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reas
 	*config = priv->pending_ip4_config;
 	priv->pending_ip4_config = NULL;
 
+	merge_ip4_config (req, *config);
+
 	return NM_ACT_STAGE_RETURN_SUCCESS;
 }
 
 /*****************************************************************************/
 
-static NMActStageReturn
-real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+NMActStageReturn
+nm_modem_stage3_ip4_config_start (NMModem *self,
+                                  NMDevice *device,
+                                  NMDeviceClass *device_class,
+                                  NMDeviceStateReason *reason)
 {
+	NMModemPrivate *priv;
+	NMActRequest *req;
 	NMActStageReturn ret;
 
-	switch (NM_MODEM_GET_PRIVATE (device)->ip_method) {
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE (device), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device_class != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE_CLASS (device_class), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+	switch (priv->ip_method) {
 	case MM_MODEM_IP_METHOD_PPP:
-		ret = ppp_stage3_ip4_config_start (device, reason);
+		ret = ppp_stage3_ip4_config_start (self, req, reason);
 		break;
 	case MM_MODEM_IP_METHOD_STATIC:
-		ret = static_stage3_ip4_config_start (device, reason);
+		ret = static_stage3_ip4_config_start (self, req, reason);
 		break;
 	case MM_MODEM_IP_METHOD_DHCP:
-		ret = NM_DEVICE_CLASS (nm_modem_parent_class)->act_stage3_ip4_config_start (device, reason);
+		ret = device_class->act_stage3_ip4_config_start (device, reason);
 		break;
 	default:
-		g_warning ("Invalid IP method");
+		nm_log_err (LOGD_MB, "unknown IP method %d", priv->ip_method);
 		ret = NM_ACT_STAGE_RETURN_FAILURE;
 		break;
 	}
@@ -386,25 +433,41 @@ real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
 	return ret;
 }
 
-static NMActStageReturn
-real_act_stage4_get_ip4_config (NMDevice *device,
+NMActStageReturn
+nm_modem_stage4_get_ip4_config (NMModem *self,
+                                NMDevice *device,
+                                NMDeviceClass *device_class,
 								NMIP4Config **config,
 								NMDeviceStateReason *reason)
 {
+	NMModemPrivate *priv;
+	NMActRequest *req;
 	NMActStageReturn ret;
 
-	switch (NM_MODEM_GET_PRIVATE (device)->ip_method) {
+	g_return_val_if_fail (self != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_MODEM (self), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE (device), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (device_class != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (NM_IS_DEVICE_CLASS (device_class), NM_ACT_STAGE_RETURN_FAILURE);
+	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+	switch (priv->ip_method) {
 	case MM_MODEM_IP_METHOD_PPP:
-		ret = ppp_stage4 (device, config, reason);
+		ret = ppp_stage4 (self, req, config, reason);
 		break;
 	case MM_MODEM_IP_METHOD_STATIC:
-		ret = static_stage4 (device, config, reason);
+		ret = static_stage4 (self, req, device, config, reason);
 		break;
 	case MM_MODEM_IP_METHOD_DHCP:
-		ret = NM_DEVICE_CLASS (nm_modem_parent_class)->act_stage4_get_ip4_config (device, config, reason);
+		ret = device_class->act_stage4_get_ip4_config (device, config, reason);
 		break;
 	default:
-		g_warning ("Invalid IP method");
+		nm_log_err (LOGD_MB, "unknown IP method %d", priv->ip_method);
 		ret = NM_ACT_STAGE_RETURN_FAILURE;
 		break;
 	}
@@ -412,12 +475,175 @@ real_act_stage4_get_ip4_config (NMDevice *device,
 	return ret;
 }
 
+gboolean
+nm_modem_connection_secrets_updated (NMModem *self,
+                                     NMActRequest *req,
+                                     NMConnection *connection,
+                                     GSList *updated_settings,
+                                     RequestSecretsCaller caller)
+{
+	NMModemPrivate *priv;
+	gboolean found = FALSE;
+	const char *setting_name;
+	GSList *iter;
+
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM (self), FALSE);
+	g_return_val_if_fail (req != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), FALSE);
+	g_return_val_if_fail (connection != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), FALSE);
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+
+	if (caller == SECRETS_CALLER_PPP) {
+		const char *user = NULL;
+		const char *pass = NULL;
+
+		g_return_val_if_fail (priv->ppp_manager != NULL, FALSE);
+
+		if (!NM_MODEM_GET_CLASS (self)->get_user_pass (self, connection, &user, &pass)) {
+			/* Shouldn't ever happen */
+			nm_ppp_manager_update_secrets (priv->ppp_manager,
+										   priv->iface,
+										   NULL,
+										   NULL,
+										   "missing GSM/CDMA setting; no secrets could be found.");
+		} else {
+			nm_ppp_manager_update_secrets (priv->ppp_manager,
+										   priv->iface,
+										   user ? user : "",
+										   pass ? pass : "",
+										   NULL);
+		}
+		return TRUE;
+	}
+
+	g_return_val_if_fail (caller == SECRETS_CALLER_MOBILE_BROADBAND, FALSE);
+
+	g_assert (NM_MODEM_GET_CLASS (self)->get_setting_name);
+	setting_name = NM_MODEM_GET_CLASS (self)->get_setting_name (self);
+
+	for (iter = updated_settings; iter; iter = g_slist_next (iter)) {
+		const char *candidate_setting_name = (const char *) iter->data;
+
+		if (!strcmp (candidate_setting_name, setting_name))
+			found = TRUE;
+		else {
+			nm_log_warn (LOGD_MB, "ignoring updated secrets for setting '%s'.",
+			            candidate_setting_name);
+		}
+	}
+
+	return found;
+}
+
+static NMActStageReturn
+real_act_stage1_prepare (NMModem *modem,
+                         NMActRequest *req,
+                         GPtrArray **out_hints,
+                         const char **out_setting_name,
+                         NMDeviceStateReason *reason)
+{
+	*reason = NM_DEVICE_STATE_REASON_UNKNOWN;
+	return NM_ACT_STAGE_RETURN_FAILURE;
+}
+
+NMActStageReturn
+nm_modem_act_stage1_prepare (NMModem *self,
+                             NMActRequest *req,
+                             NMDeviceStateReason *reason)
+{
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
+	NMActStageReturn ret;
+	GPtrArray *hints = NULL;
+	const char *setting_name = NULL;
+
+	ret = NM_MODEM_GET_CLASS (self)->act_stage1_prepare (self,
+	                                                     req,
+	                                                     &hints,
+	                                                     &setting_name,
+	                                                     reason);
+	if ((ret == NM_ACT_STAGE_RETURN_POSTPONE) && setting_name) {
+		const char *hint1 = NULL, *hint2 = NULL;
+
+		/* Need some secrets */
+		if (hints) {
+			if (hints->len > 0)
+				hint1 = g_ptr_array_index (hints, 0);
+			if (hints->len > 1)
+				hint2 = g_ptr_array_index (hints, 1);
+		}
+
+		g_signal_emit (self, signals[NEED_AUTH], 0,
+		               setting_name, 
+	                   priv->secrets_tries++ ? TRUE : FALSE,
+	                   SECRETS_CALLER_MOBILE_BROADBAND,
+	                   hint1,
+	                   hint2);
+
+		if (hints)
+			g_ptr_array_free (hints, TRUE);
+	}
+	
+	return ret;
+}
+
+NMActStageReturn
+nm_modem_act_stage2_config (NMModem *self,
+                            NMActRequest *req,
+                            NMDeviceStateReason *reason)
+{
+	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
+
+	/* Clear secrets tries counter since secrets were successfully used
+	 * already if we get here.
+	 */
+	priv->secrets_tries = 0;
+
+	return NM_ACT_STAGE_RETURN_SUCCESS;
+}
+
+NMConnection *
+nm_modem_get_best_auto_connection (NMModem *self,
+                                   GSList *connections,
+                                   char **specific_object)
+{
+	if (NM_MODEM_GET_CLASS (self)->get_best_auto_connection)
+		return NM_MODEM_GET_CLASS (self)->get_best_auto_connection (self, connections, specific_object);
+	return NULL;
+}
+
+gboolean
+nm_modem_check_connection_compatible (NMModem *self,
+                                      NMConnection *connection,
+                                      GError **error)
+{
+	if (NM_MODEM_GET_CLASS (self)->check_connection_compatible)
+		return NM_MODEM_GET_CLASS (self)->check_connection_compatible (self, connection, error);
+	return FALSE;
+}
+
 static void
-real_deactivate_quickly (NMDevice *device)
+real_deactivate_quickly (NMModem *self, NMDevice *device)
 {
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+	NMModemPrivate *priv;
 	const char *iface;
 
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM (self));
+	g_return_if_fail (device != NULL);
+	g_return_if_fail (NM_IS_DEVICE (device));
+
+	priv = NM_MODEM_GET_PRIVATE (self);
+
+	priv->secrets_tries = 0;
+
+	if (priv->call) {
+		dbus_g_proxy_cancel_call (priv->proxy, priv->call);
+		priv->call = NULL;
+	}
+
 	if (priv->pending_ip4_config) {
 		g_object_unref (priv->pending_ip4_config);
 		priv->pending_ip4_config = NULL;
@@ -425,7 +651,7 @@ real_deactivate_quickly (NMDevice *device)
 
 	priv->in_bytes = priv->out_bytes = 0;
 
-	switch (NM_MODEM_GET_PRIVATE (device)->ip_method) {
+	switch (priv->ip_method) {
 	case MM_MODEM_IP_METHOD_PPP:
 		if (priv->ppp_manager) {
 			g_object_unref (priv->ppp_manager);
@@ -434,45 +660,53 @@ real_deactivate_quickly (NMDevice *device)
 		break;
 	case MM_MODEM_IP_METHOD_STATIC:
 	case MM_MODEM_IP_METHOD_DHCP:
-		iface = nm_device_get_iface (device);
-
+		iface = nm_device_get_ip_iface (device);
 		nm_system_device_flush_routes_with_iface (iface);
 		nm_system_device_flush_addresses_with_iface (iface);
 		nm_system_device_set_up_down_with_iface (iface, FALSE, NULL);
 		break;
 	default:
-		g_warning ("Invalid IP method");
+		nm_log_err (LOGD_MB, "unknown IP method %d", priv->ip_method);
 		break;
 	}
-
-	if (NM_DEVICE_CLASS (nm_modem_parent_class)->deactivate)
-		NM_DEVICE_CLASS (nm_modem_parent_class)->deactivate (device);
 }
 
-static guint32
-real_get_generic_capabilities (NMDevice *dev)
+void
+nm_modem_deactivate_quickly (NMModem *self, NMDevice *device)
 {
-	return NM_DEVICE_CAP_NM_SUPPORTED;
+	NM_MODEM_GET_CLASS (self)->deactivate_quickly (self, device);
 }
 
 static void
-device_state_changed (NMDeviceInterface *device,
-					  NMDeviceState new_state,
-					  NMDeviceState old_state,
-					  NMDeviceStateReason reason,
-					  gpointer user_data)
+disconnect_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
+{
+	GError *error = NULL;
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
+		nm_log_info (LOGD_MB, "disconnect failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+	}
+}
+
+void
+nm_modem_device_state_changed (NMModem *self,
+                               NMDeviceState new_state,
+                               NMDeviceState old_state,
+                               NMDeviceStateReason reason)
 {
-	NMModem *self = NM_MODEM (user_data);
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 	gboolean was_connected = FALSE;
 
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM (self));
+
 	if (IS_ACTIVATING_STATE (old_state) || (old_state == NM_DEVICE_STATE_ACTIVATED))
 		was_connected = TRUE;
 
 	/* Make sure we don't leave the serial device open */
 	switch (new_state) {
 	case NM_DEVICE_STATE_NEED_AUTH:
-		if (priv->ppp_manager)
+		if (NM_MODEM_GET_PRIVATE (self)->ppp_manager)
 			break;
 		/* else fall through */
 	case NM_DEVICE_STATE_UNMANAGED:
@@ -480,9 +714,12 @@ device_state_changed (NMDeviceInterface *device,
 	case NM_DEVICE_STATE_FAILED:
 	case NM_DEVICE_STATE_DISCONNECTED:
 		if (was_connected) {
-			dbus_g_proxy_call_no_reply (nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM),
-			                            "Disconnect",
-			                            G_TYPE_INVALID);
+			dbus_g_proxy_begin_call (nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM),
+			                         "Disconnect",
+			                         disconnect_done,
+			                         self,
+			                         NULL,
+			                         G_TYPE_INVALID);
 		}
 		break;
 	default:
@@ -490,13 +727,13 @@ device_state_changed (NMDeviceInterface *device,
 	}
 }
 
-static gboolean
-real_hw_is_up (NMDevice *device)
+gboolean
+nm_modem_hw_is_up (NMModem *self, NMDevice *device)
 {
-	guint32 ip_method = NM_MODEM_GET_PRIVATE (device)->ip_method;
+	guint32 ip_method = NM_MODEM_GET_PRIVATE (self)->ip_method;
 
 	if (ip_method == MM_MODEM_IP_METHOD_STATIC || ip_method == MM_MODEM_IP_METHOD_DHCP) {
-		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 		NMDeviceState state;
 
 		state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
@@ -507,13 +744,13 @@ real_hw_is_up (NMDevice *device)
 	return TRUE;
 }
 
-static gboolean
-real_hw_bring_up (NMDevice *device, gboolean *no_firmware)
+gboolean
+nm_modem_hw_bring_up (NMModem *self, NMDevice *device, gboolean *no_firmware)
 {
-	guint32 ip_method = NM_MODEM_GET_PRIVATE (device)->ip_method;
+	guint32 ip_method = NM_MODEM_GET_PRIVATE (self)->ip_method;
 
 	if (ip_method == MM_MODEM_IP_METHOD_STATIC || ip_method == MM_MODEM_IP_METHOD_DHCP) {
-		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (device);
+		NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
 		NMDeviceState state;
 
 		state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
@@ -524,6 +761,24 @@ real_hw_bring_up (NMDevice *device, gboolean *no_firmware)
 	return TRUE;
 }
 
+const char *
+nm_modem_get_iface (NMModem *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM (self), NULL);
+
+	return NM_MODEM_GET_PRIVATE (self)->iface;
+}
+
+const char *
+nm_modem_get_path (NMModem *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM (self), NULL);
+
+	return NM_MODEM_GET_PRIVATE (self)->path;
+}
+
 static void
 get_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
@@ -534,10 +789,9 @@ get_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_d
 	if (!dbus_g_proxy_end_call (proxy, call_id, &error,
 	                            G_TYPE_VALUE, &value,
 	                            G_TYPE_INVALID)) {
-		g_warning ("%s: failed get modem enabled state: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_MB, "failed get modem enabled state: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 		return;
 	}
 
@@ -545,7 +799,7 @@ get_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_d
 		NM_MODEM_GET_PRIVATE (self)->mm_enabled = g_value_get_boolean (&value);
 		g_object_notify (G_OBJECT (self), NM_MODEM_ENABLED);
 	} else
-		g_warning ("%s: failed get modem enabled state: unexpected reply type", __func__);
+		nm_log_warn (LOGD_MB, "failed get modem enabled state: unexpected reply type");
 
 	g_value_unset (&value);
 }
@@ -567,21 +821,24 @@ set_mm_enabled_done (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_d
 	GError *error = NULL;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &error, G_TYPE_INVALID)) {
-		g_warning ("%s: failed to enable/disable modem: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
+		nm_log_warn (LOGD_MB, "failed to enable/disable modem: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 	}
 
 	/* Update enabled/disabled state again */
 	query_mm_enabled (NM_MODEM (user_data));
 }
 
-static void
-real_set_enabled (NMDeviceInterface *device, gboolean enabled)
+void
+nm_modem_set_mm_enabled (NMModem *self, gboolean enabled)
 {
-	NMModem *self = NM_MODEM (device);
-	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
+	NMModemPrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_MODEM (self));
+
+	priv = NM_MODEM_GET_PRIVATE (self);
 
 	/* FIXME: For now this just toggles the ModemManager enabled state.  In the
 	 * future we want to tie this into rfkill state instead so that the user can
@@ -591,10 +848,10 @@ real_set_enabled (NMDeviceInterface *device, gboolean enabled)
 	if (priv->mm_enabled != enabled) {
 		DBusGProxy *proxy;
 
-		proxy = nm_modem_get_proxy (NM_MODEM (device), MM_DBUS_INTERFACE_MODEM);
+		proxy = nm_modem_get_proxy (self, MM_DBUS_INTERFACE_MODEM);
 		dbus_g_proxy_begin_call (proxy,
 		                         "Enable", set_mm_enabled_done,
-		                         device, NULL,
+		                         self, NULL,
 		                         G_TYPE_BOOLEAN, enabled,
 		                         G_TYPE_INVALID);
 	}
@@ -615,31 +872,14 @@ modem_properties_changed (DBusGProxy *proxy,
 
 	value = g_hash_table_lookup (props, "Enabled");
 	if (value && G_VALUE_HOLDS_BOOLEAN (value)) {
-		NMDeviceState state;
-
 		priv->mm_enabled = g_value_get_boolean (value);
 		g_object_notify (G_OBJECT (self), NM_MODEM_ENABLED);
-
-		if (priv->mm_enabled == FALSE) {
-			state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-			if (state == NM_DEVICE_STATE_ACTIVATED) {
-				nm_device_state_changed (NM_DEVICE (self),
-				                         NM_DEVICE_STATE_DISCONNECTED,
-				                         NM_DEVICE_STATE_REASON_NONE);
-			}
-		}
 	}
 }
 
 /*****************************************************************************/
 
 static void
-device_interface_init (NMDeviceInterface *iface_class)
-{
-    iface_class->set_enabled = real_set_enabled;
-}
-
-static void
 nm_modem_init (NMModem *self)
 {
 	NMModemPrivate *priv = NM_MODEM_GET_PRIVATE (self);
@@ -665,12 +905,17 @@ constructor (GType type,
 	priv = NM_MODEM_GET_PRIVATE (object);
 
 	if (!priv->device) {
-		g_warning ("Modem device not provided");
+		nm_log_err (LOGD_HW, "modem parent device not provided");
+		goto err;
+	}
+
+	if (!priv->device) {
+		nm_log_err (LOGD_HW, "modem command interface not provided");
 		goto err;
 	}
 
 	if (!priv->path) {
-		g_warning ("DBus path not provided");
+		nm_log_err (LOGD_HW, "D-Bus path not provided");
 		goto err;
 	}
 
@@ -696,8 +941,6 @@ constructor (GType type,
 	                             object,
 	                             NULL);
 
-	g_signal_connect (object, "state-changed", G_CALLBACK (device_state_changed), object);
-
 	query_mm_enabled (NM_MODEM (object));
 
 	return object;
@@ -720,6 +963,9 @@ get_property (GObject *object, guint prop_id,
 	case PROP_DEVICE:
 		g_value_set_string (value, priv->device);
 		break;
+	case PROP_IFACE:
+		g_value_set_string (value, priv->iface);
+		break;
 	case PROP_IP_METHOD:
 		g_value_set_uint (value, priv->ip_method);
 		break;
@@ -748,7 +994,12 @@ set_property (GObject *object, guint prop_id,
 		/* Construct only */
 		priv->device = g_value_dup_string (value);
 		break;
+	case PROP_IFACE:
+		/* Construct only */
+		priv->iface = g_value_dup_string (value);
+		break;
 	case PROP_IP_METHOD:
+		/* Construct only */
 		priv->ip_method = g_value_get_uint (value);
 		break;
 	case PROP_ENABLED:
@@ -772,6 +1023,7 @@ finalize (GObject *object)
 
 	g_object_unref (priv->dbus_mgr);
 
+	g_free (priv->iface);
 	g_free (priv->path);
 	g_free (priv->device);
 
@@ -782,7 +1034,6 @@ static void
 nm_modem_class_init (NMModemClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-	NMDeviceClass *device_class = NM_DEVICE_CLASS (klass);
 
 	g_type_class_add_private (object_class, sizeof (NMModemPrivate));
 
@@ -792,12 +1043,8 @@ nm_modem_class_init (NMModemClass *klass)
 	object_class->get_property = get_property;
 	object_class->finalize = finalize;
 
-	device_class->get_generic_capabilities = real_get_generic_capabilities;
-	device_class->act_stage3_ip4_config_start = real_act_stage3_ip4_config_start;
-	device_class->act_stage4_get_ip4_config = real_act_stage4_get_ip4_config;
-	device_class->deactivate_quickly = real_deactivate_quickly;
-	device_class->hw_is_up = real_hw_is_up;
-	device_class->hw_bring_up = real_hw_bring_up;
+	klass->act_stage1_prepare = real_act_stage1_prepare;
+	klass->deactivate_quickly = real_deactivate_quickly;
 
 	/* Properties */
 	g_object_class_install_property
@@ -806,7 +1053,7 @@ nm_modem_class_init (NMModemClass *klass)
 							  "DBus path",
 							  "DBus path",
 							  NULL,
-							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
 	g_object_class_install_property
 		(object_class, PROP_DEVICE,
@@ -814,7 +1061,15 @@ nm_modem_class_init (NMModemClass *klass)
 		                      "Device",
 		                      "Master modem parent device",
 		                      NULL,
-		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	g_object_class_install_property
+		(object_class, PROP_IFACE,
+		 g_param_spec_string (NM_MODEM_IFACE,
+		                      "Interface",
+		                      "Modem command interface",
+		                      NULL,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
 	g_object_class_install_property
 		(object_class, PROP_IP_METHOD,
@@ -824,7 +1079,7 @@ nm_modem_class_init (NMModemClass *klass)
 							MM_MODEM_IP_METHOD_PPP,
 							MM_MODEM_IP_METHOD_DHCP,
 							MM_MODEM_IP_METHOD_PPP,
-							G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+							G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 
 	g_object_class_install_property
 		(object_class, PROP_ENABLED,
@@ -845,10 +1100,47 @@ nm_modem_class_init (NMModemClass *klass)
 					  G_TYPE_NONE, 2,
 					  G_TYPE_UINT, G_TYPE_UINT);
 
-	signals[PROPERTIES_CHANGED] = 
-		nm_properties_changed_signal_new (object_class,
-										  G_STRUCT_OFFSET (NMModemClass, properties_changed));
+	signals[PPP_FAILED] =
+		g_signal_new ("ppp-failed",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, ppp_failed),
+					  NULL, NULL,
+					  g_cclosure_marshal_VOID__UINT,
+					  G_TYPE_NONE, 1, G_TYPE_UINT);
+
+	signals[IP4_CONFIG_RESULT] =
+		g_signal_new (NM_MODEM_IP4_CONFIG_RESULT,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, ip4_config_result),
+					  NULL, NULL,
+					  _nm_marshal_VOID__STRING_OBJECT_POINTER,
+					  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_OBJECT, G_TYPE_POINTER);
 
-	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
-									 &dbus_glib_nm_serial_device_object_info);
+	signals[PREPARE_RESULT] =
+		g_signal_new (NM_MODEM_PREPARE_RESULT,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, prepare_result),
+					  NULL, NULL,
+					  _nm_marshal_VOID__BOOLEAN_UINT,
+					  G_TYPE_NONE, 2, G_TYPE_BOOLEAN, G_TYPE_UINT);
+
+	signals[NEED_AUTH] =
+		g_signal_new (NM_MODEM_NEED_AUTH,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMModemClass, need_auth),
+					  NULL, NULL,
+					  _nm_marshal_VOID__STRING_BOOLEAN_UINT_STRING_STRING,
+					  G_TYPE_NONE, 5,
+					  G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRING);
 }
+
+const DBusGObjectInfo *
+nm_modem_get_serial_dbus_info (void)
+{
+	return &dbus_glib_nm_serial_device_object_info;
+}
+
diff --git a/src/modem-manager/nm-modem.h b/src/modem-manager/nm-modem.h
index 0a72276..a2aed57 100644
--- a/src/modem-manager/nm-modem.h
+++ b/src/modem-manager/nm-modem.h
@@ -23,8 +23,9 @@
 #define NM_MODEM_H
 
 #include <dbus/dbus-glib.h>
-#include <nm-device.h>
+#include <glib-object.h>
 #include "ppp-manager/nm-ppp-manager.h"
+#include "nm-device.h"
 
 G_BEGIN_DECLS
 
@@ -37,36 +38,119 @@ G_BEGIN_DECLS
 
 #define NM_MODEM_PATH      "path"
 #define NM_MODEM_DEVICE    "device"
+#define NM_MODEM_IFACE     "iface"
 #define NM_MODEM_IP_METHOD "ip-method"
 #define NM_MODEM_ENABLED   "enabled"
 
+#define NM_MODEM_PPP_STATS         "ppp-stats"
+#define NM_MODEM_PPP_FAILED        "ppp-failed"
+#define NM_MODEM_PREPARE_RESULT    "prepare-result"
+#define NM_MODEM_IP4_CONFIG_RESULT "ip4-config-result"
+#define NM_MODEM_NEED_AUTH         "need-auth"
+
 typedef struct {
-	NMDevice parent;
+	GObject parent;
 } NMModem;
 
 typedef struct {
-	NMDeviceClass parent;
+	GObjectClass parent;
+
+	gboolean (*get_user_pass)                  (NMModem *modem,
+	                                            NMConnection *connection,
+	                                            const char **user,
+	                                            const char **pass);
+
+	const char * (*get_setting_name)           (NMModem *modem);
+
+	gboolean (*check_connection_compatible)    (NMModem *modem,
+	                                            NMConnection *connection,
+	                                            GError **error);
+
+	NMConnection * (*get_best_auto_connection) (NMModem *modem,
+	                                            GSList *connections,
+	                                            char **specific_object);
 
-	const char *(*get_ppp_name) (NMModem *self,
-								 NMConnection *connection);
+	NMActStageReturn (*act_stage1_prepare)     (NMModem *modem,
+	                                            NMActRequest *req,
+	                                            GPtrArray **out_hints,
+	                                            const char **out_setting_name,
+	                                            NMDeviceStateReason *reason);
+
+	void (*deactivate_quickly)                 (NMModem *self, NMDevice *device);
 
 	/* Signals */
-	void (*ppp_stats) (NMModem *self, guint32 in_bytes, guint32 out_bytes);
-	void (*properties_changed) (NMModem *self, GHashTable *properties);
+	void (*ppp_stats)  (NMModem *self, guint32 in_bytes, guint32 out_bytes);
+	void (*ppp_failed) (NMModem *self, NMDeviceStateReason reason);
+
+	void (*prepare_result)    (NMModem *self, gboolean success, NMDeviceStateReason reason);
+	void (*ip4_config_result) (NMModem *self, const char *iface, NMIP4Config *config, GError *error);
+
+	void (*need_auth)  (NMModem *self,
+	                    const char *setting_name,
+	                    gboolean retry,
+	                    RequestSecretsCaller caller,
+	                    const char *hint1,
+	                    const char *hint2);
 } NMModemClass;
 
 GType nm_modem_get_type (void);
 
 /* Protected */
 
-NMPPPManager *nm_modem_get_ppp_manager (NMModem *self);
-DBusGProxy	 *nm_modem_get_proxy	   (NMModem *self,
-										const char *interface);
+NMPPPManager *nm_modem_get_ppp_manager (NMModem *modem);
+DBusGProxy *  nm_modem_get_proxy       (NMModem *modem, const char *interface);
+const char *  nm_modem_get_iface       (NMModem *modem);
+const char *  nm_modem_get_path        (NMModem *modem);
+
+NMConnection *nm_modem_get_best_auto_connection (NMModem *self,
+                                                 GSList *connections,
+                                                 char **specific_object);
+
+gboolean nm_modem_check_connection_compatible (NMModem *self,
+                                               NMConnection *connection,
+                                               GError **error);
+
+NMActStageReturn nm_modem_act_stage1_prepare (NMModem *modem,
+                                              NMActRequest *req,
+                                              NMDeviceStateReason *reason);
+
+NMActStageReturn nm_modem_act_stage2_config (NMModem *modem,
+                                             NMActRequest *req,
+                                             NMDeviceStateReason *reason);
+
+NMActStageReturn nm_modem_stage3_ip4_config_start (NMModem *modem,
+                                                   NMDevice *device,
+                                                   NMDeviceClass *device_class,
+                                                   NMDeviceStateReason *reason);
+
+NMActStageReturn nm_modem_stage4_get_ip4_config (NMModem *modem,
+                                                 NMDevice *device,
+                                                 NMDeviceClass *device_class,
+                                                 NMIP4Config **config,
+                                                 NMDeviceStateReason *reason);
+
+void nm_modem_deactivate_quickly (NMModem *modem, NMDevice *device);
+
+void nm_modem_device_state_changed (NMModem *modem,
+                                    NMDeviceState new_state,
+                                    NMDeviceState old_state,
+                                    NMDeviceStateReason reason);
+
+gboolean nm_modem_hw_is_up (NMModem *modem, NMDevice *device);
+
+gboolean nm_modem_hw_bring_up (NMModem *modem, NMDevice *device, gboolean *no_firmware);
+
+gboolean nm_modem_connection_secrets_updated (NMModem *modem,
+                                              NMActRequest *req,
+                                              NMConnection *connection,
+                                              GSList *updated_settings,
+                                              RequestSecretsCaller caller);
+
+const DBusGObjectInfo *nm_modem_get_serial_dbus_info (void);
 
-const char	 *nm_modem_get_ppp_name	   (NMModem *self,
-										NMConnection *connection);
+gboolean      nm_modem_get_mm_enabled (NMModem *self);
 
-gboolean      nm_modem_get_mm_enabled  (NMModem *self);
+void          nm_modem_set_mm_enabled (NMModem *self, gboolean enabled);
 
 G_END_DECLS
 
diff --git a/src/named-manager/Makefile.am b/src/named-manager/Makefile.am
index fe1ec91..a33f7d5 100644
--- a/src/named-manager/Makefile.am
+++ b/src/named-manager/Makefile.am
@@ -1,4 +1,8 @@
-INCLUDES = -I${top_srcdir}/libnm-util -I${top_srcdir}/src -I${top_srcdir}/include
+INCLUDES = \
+	-I${top_srcdir}/src/logging \
+	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src \
+	-I${top_srcdir}/include
 
 noinst_LTLIBRARIES = libnamed-manager.la
 
@@ -10,4 +14,8 @@ libnamed_manager_la_CPPFLAGS = \
 	-DNM_PKGDATADIR=\"$(pkgdatadir)\" \
 	-DNM_LOCALSTATEDIR=\"$(localstatedir)\"
 
-libnamed_manager_la_LIBADD = $(DBUS_LIBS) $(GLIB_LIBS)
+libnamed_manager_la_LIBADD = \
+	$(top_builddir)/src/logging/libnm-logging.la \
+	$(DBUS_LIBS) \
+	$(GLIB_LIBS)
+
diff --git a/src/named-manager/nm-named-manager.c b/src/named-manager/nm-named-manager.c
index c96a2e6..2963652 100644
--- a/src/named-manager/nm-named-manager.c
+++ b/src/named-manager/nm-named-manager.c
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2004 - 2005 Colin Walters <walters@redhat.com>
- * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
  * Copyright (C) 2005 - 2008 Novell, Inc.
  *   and others
  */
@@ -38,8 +38,8 @@
 
 #include "nm-named-manager.h"
 #include "nm-ip4-config.h"
-#include "nm-utils.h"
-#include "NetworkManagerSystem.h"
+#include "nm-logging.h"
+#include "nm-system.h"
 #include "NetworkManagerUtils.h"
 
 #ifdef HAVE_SELINUX
@@ -60,9 +60,9 @@ G_DEFINE_TYPE(NMNamedManager, nm_named_manager, G_TYPE_OBJECT)
 
 
 struct NMNamedManagerPrivate {
-	NMIP4Config *   vpn_config;
-	NMIP4Config *   device_config;
-	GSList *        configs;
+	NMIP4Config *vpn_config;
+	NMIP4Config *device_config;
+	GSList *configs;
 };
 
 
@@ -71,11 +71,10 @@ nm_named_manager_get (void)
 {
 	static NMNamedManager * singleton = NULL;
 
-	if (!singleton) {
+	if (!singleton)
 		singleton = NM_NAMED_MANAGER (g_object_new (NM_TYPE_NAMED_MANAGER, NULL));
-	} else {
+	else
 		g_object_ref (singleton);
-	}
 
 	g_assert (singleton);
 	return singleton;
@@ -185,7 +184,7 @@ run_netconfig (GError **error, gint *stdin_fd)
 	argv[4] = NULL;
 
 	tmp = g_strjoinv (" ", argv);
-	nm_debug ("Spawning '%s'", tmp);
+	nm_log_debug (LOGD_DNS, "spawning '%s'", tmp);
 	g_free (tmp);
 
 	if (!g_spawn_async_with_pipes (NULL, argv, NULL, 0, netconfig_child_setup,
@@ -202,7 +201,7 @@ write_to_netconfig (gint fd, const char *key, const char *value)
 	int x;
 
 	str = g_strdup_printf ("%s='%s'\n", key, value);
-	nm_debug ("Writing to netconfig: %s", str);
+	nm_log_debug (LOGD_DNS, "writing to netconfig: %s", str);
 	x = write (fd, str, strlen (str));
 	g_free (str);
 }
@@ -327,7 +326,7 @@ write_resolv_conf (FILE *f, const char *domain,
 	}
 
 	if (fprintf (f, "%s%s%s",
-		     domain_str ? domain_str : "",
+	             domain_str ? domain_str : "",
 	             searches_str ? searches_str : "",
 	             nameservers_str ? nameservers_str : "") != -1)
 		retval = TRUE;
@@ -356,7 +355,7 @@ dispatch_resolvconf (const char *domain,
 
 	if (domain || searches || nameservers) {
 		cmd = g_strconcat (RESOLVCONF_PATH, " -a ", "NetworkManager", NULL);
-		nm_info ("(%s): writing resolv.conf to %s", iface, RESOLVCONF_PATH);
+		nm_log_info (LOGD_DNS, "(%s): writing resolv.conf to %s", iface, RESOLVCONF_PATH);
 		if ((f = popen (cmd, "w")) == NULL)
 			g_set_error (error,
 				     NM_NAMED_MANAGER_ERROR,
@@ -370,7 +369,7 @@ dispatch_resolvconf (const char *domain,
 		}
 	} else {
 		cmd = g_strconcat (RESOLVCONF_PATH, " -d ", "NetworkManager", NULL);
-		nm_info ("(%s): removing resolv.conf from %s", iface, RESOLVCONF_PATH);
+		nm_log_info (LOGD_DNS, "(%s): removing resolv.conf from %s", iface, RESOLVCONF_PATH);
 		if (nm_spawn_process (cmd) == 0)
 			retval = TRUE;
 	}
@@ -587,7 +586,7 @@ nm_named_manager_add_ip4_config (NMNamedManager *mgr,
 		priv->configs = g_slist_append (priv->configs, g_object_ref (config));
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		g_error_free (error);
 	}
 
@@ -623,7 +622,7 @@ nm_named_manager_remove_ip4_config (NMNamedManager *mgr,
 	g_object_unref (config);
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		if (error)
 			g_error_free (error);
 	}
@@ -653,7 +652,7 @@ nm_named_manager_add_ip6_config (NMNamedManager *mgr,
 		priv->configs = g_slist_append (priv->configs, g_object_ref (config));
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		g_error_free (error);
 	}
 
@@ -683,7 +682,7 @@ nm_named_manager_remove_ip6_config (NMNamedManager *mgr,
 	g_object_unref (config);	
 
 	if (!rewrite_resolv_conf (mgr, iface, &error)) {
-		nm_warning ("Could not commit DNS changes.  Error: '%s'", error ? error->message : "(none)");
+		nm_log_warn (LOGD_DNS, "could not commit DNS changes: '%s'", error ? error->message : "(none)");
 		if (error)
 			g_error_free (error);
 	}
diff --git a/src/nm-activation-request.c b/src/nm-activation-request.c
index f85c12d..1335c35 100644
--- a/src/nm-activation-request.c
+++ b/src/nm-activation-request.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2007 - 2008 Novell, Inc.
  */
 
@@ -27,7 +27,7 @@
 
 #include "nm-activation-request.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-setting-wireless-security.h"
 #include "nm-setting-8021x.h"
 #include "nm-dbus-manager.h"
@@ -418,9 +418,9 @@ secrets_update_setting (NMSecretsProviderInterface *interface,
 		nm_connection_add_setting (priv->connection, setting);
 	else {
 		if (!nm_connection_update_secrets (priv->connection, setting_name, new, &error)) {
-			nm_warning ("Failed to update connection secrets: %d %s",
-			            error ? error->code : -1,
-			            error && error->message ? error->message : "(none)");
+			nm_log_warn (LOGD_DEVICE, "Failed to update connection secrets: %d %s",
+			             error ? error->code : -1,
+			             error && error->message ? error->message : "(none)");
 			g_clear_error (&error);
 		}
 	}
@@ -591,15 +591,17 @@ nm_act_request_set_shared (NMActRequest *req, gboolean shared)
 			int status;
 			GError *error = NULL;
 
-			nm_info ("Executing: %s", cmd);
+			nm_log_info (LOGD_SHARING, "Executing: %s", cmd);
 			if (!g_spawn_sync ("/", argv, envp, G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
 			                   share_child_setup, NULL, NULL, NULL, &status, &error)) {
-				nm_info ("Error executing command: (%d) %s",
-				         error ? error->code : -1,
-				         (error && error->message) ? error->message : "(unknown)");
+				nm_log_warn (LOGD_SHARING, "Error executing command: (%d) %s",
+				             error ? error->code : -1,
+				             (error && error->message) ? error->message : "(unknown)");
 				g_clear_error (&error);
-			} else if (WEXITSTATUS (status))
-				nm_info ("** Command returned exit status %d.", WEXITSTATUS (status));
+			} else if (WEXITSTATUS (status)) {
+				nm_log_warn (LOGD_SHARING, "** Command returned exit status %d.",
+				             WEXITSTATUS (status));
+			}
 		}
 		g_free (cmd);
 		if (argv)
diff --git a/src/nm-active-connection.c b/src/nm-active-connection.c
index 019b5c3..4207e14 100644
--- a/src/nm-active-connection.c
+++ b/src/nm-active-connection.c
@@ -15,13 +15,14 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <glib.h>
 #include "nm-active-connection.h"
 #include "NetworkManager.h"
 #include "nm-active-connection-glue.h"
+#include "nm-logging.h"
 
 char *
 nm_active_connection_get_next_object_path (void)
@@ -54,7 +55,7 @@ nm_active_connection_scope_to_value (NMConnection *connection, GValue *value)
 		g_value_set_string (value, NM_DBUS_SERVICE_USER_SETTINGS);
 		break;
 	default:
-		g_warning ("%s: unknown connection scope!", __func__);
+		nm_log_err (LOGD_CORE, "unknown connection scope!");
 		break;
 	}
 }
diff --git a/src/nm-call-store.c b/src/nm-call-store.c
index 837edf0..df400d0 100644
--- a/src/nm-call-store.c
+++ b/src/nm-call-store.c
@@ -16,10 +16,11 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 Novell, Inc.
+ * Copyright (C) 2010 Red Hat, Inc.
  */
 
 #include "nm-call-store.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 NMCallStore *
 nm_call_store_new (void)
@@ -68,12 +69,12 @@ nm_call_store_remove (NMCallStore *store,
 
 	call_ids_hash = g_hash_table_lookup (store, object);
 	if (!call_ids_hash) {
-		nm_warning ("Trying to remove a non-existant call id.");
+		nm_log_warn (LOGD_CORE, "Trying to remove a non-existant call id.");
 		return;
 	}
 
 	if (!g_hash_table_remove (call_ids_hash, call_id))
-		nm_warning ("Trying to remove a non-existant call id.");
+		nm_log_warn (LOGD_CORE, "Trying to remove a non-existant call id.");
 
 	if (g_hash_table_size (call_ids_hash) == 0) {
 		g_hash_table_remove (store, object);
@@ -162,7 +163,7 @@ nm_call_store_foreach (NMCallStore *store,
 
 		call_ids_hash = g_hash_table_lookup (store, object);
 		if (!call_ids_hash) {
-			nm_warning ("Object not in store");
+			nm_log_warn (LOGD_CORE, "Object not in store");
 			return -1;
 		}
 
diff --git a/src/nm-dbus-manager.c b/src/nm-dbus-manager.c
index 37039f1..9b621b4 100644
--- a/src/nm-dbus-manager.c
+++ b/src/nm-dbus-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -29,7 +29,7 @@
 #include <dbus/dbus-glib.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <string.h>
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 enum {
 	DBUS_CONNECTION_CHANGED = 0,
@@ -158,7 +158,7 @@ nm_dbus_manager_reconnect (gpointer user_data)
 
 	if (nm_dbus_manager_init_bus (self)) {
 		if (nm_dbus_manager_start_service (self)) {
-			nm_info ("reconnected to the system bus.");
+			nm_log_info (LOGD_CORE, "reconnected to the system bus.");
 			g_signal_emit (self, signals[DBUS_CONNECTION_CHANGED],
 			               0, priv->connection);
 			priv->reconnect_id = 0;
@@ -223,8 +223,8 @@ nm_dbus_manager_name_has_owner (NMDBusManager *self,
 					    G_TYPE_INVALID,
 					    G_TYPE_BOOLEAN, &has_owner,
 					    G_TYPE_INVALID)) {
-		nm_warning ("NameHasOwner request failed: %s",
-		            (err && err->message) ? err->message : "(unknown)");
+		nm_log_warn (LOGD_CORE, "NameHasOwner request failed: %s",
+		             (err && err->message) ? err->message : "(unknown)");
 		g_clear_error (&err);
 	}
 
@@ -248,7 +248,7 @@ destroy_cb (DBusGProxy *proxy, gpointer user_data)
 	NMDBusManager *self = NM_DBUS_MANAGER (user_data);
 
 	/* Clean up existing connection */
-	nm_info ("disconnected by the system bus.");
+	nm_log_warn (LOGD_CORE, "disconnected by the system bus.");
 	NM_DBUS_MANAGER_GET_PRIVATE (self)->proxy = NULL;
 
 	nm_dbus_manager_cleanup (self, FALSE);
@@ -265,7 +265,7 @@ nm_dbus_manager_init_bus (NMDBusManager *self)
 	GError *err = NULL;
 
 	if (priv->connection) {
-		nm_warning ("DBus Manager already has a valid connection.");
+		nm_log_warn (LOGD_CORE, "DBus Manager already has a valid connection.");
 		return FALSE;
 	}
 
@@ -273,7 +273,7 @@ nm_dbus_manager_init_bus (NMDBusManager *self)
 
 	priv->g_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &err);
 	if (!priv->g_connection) {
-		nm_warning ("Could not get the system bus.  Make sure "
+		nm_log_err (LOGD_CORE, "Could not get the system bus.  Make sure "
 		            "the message bus daemon is running!  Message: %s",
 		            err->message);
 		g_error_free (err);
@@ -317,7 +317,7 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 	priv = NM_DBUS_MANAGER_GET_PRIVATE (self);
 
 	if (priv->started) {
-		nm_warning ("Service has already started.");
+		nm_log_err (LOGD_CORE, "Service has already started.");
 		return FALSE;
 	}
 
@@ -327,7 +327,7 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 	                        G_TYPE_INVALID,
 	                        G_TYPE_UINT, &result,
 	                        G_TYPE_INVALID)) {
-		nm_warning ("Could not acquire the NetworkManager service.\n"
+		nm_log_err (LOGD_CORE, "Could not acquire the NetworkManager service.\n"
 		            "  Error: '%s'",
 		            (err && err->message) ? err->message : "(unknown)");
 		g_error_free (err);
@@ -335,7 +335,7 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 	}
 
 	if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		nm_warning ("Could not acquire the NetworkManager service as it is already taken.");
+		nm_log_err (LOGD_CORE, "Could not acquire the NetworkManager service as it is already taken.");
 		return FALSE;
 	}
 
@@ -345,15 +345,15 @@ nm_dbus_manager_start_service (NMDBusManager *self)
 							G_TYPE_INVALID,
 							G_TYPE_UINT, &result,
 							G_TYPE_INVALID)) {
-		g_warning ("Could not acquire the NetworkManagerSystemSettings service.\n"
-		           "  Message: '%s'", err->message);
+		nm_log_warn (LOGD_CORE, "Could not acquire the NetworkManagerSystemSettings service.\n"
+		             "  Message: '%s'", err->message);
 		g_error_free (err);
 		return FALSE;
 	}
 
 	if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		g_warning ("Could not acquire the NetworkManagerSystemSettings service "
-		           "as it is already taken.");
+		nm_log_warn (LOGD_CORE, "Could not acquire the NetworkManagerSystemSettings service "
+		             "as it is already taken.");
 		return FALSE;
 	}
 
diff --git a/src/nm-device-bt.c b/src/nm-device-bt.c
index 444c7ff..8cf179e 100644
--- a/src/nm-device-bt.c
+++ b/src/nm-device-bt.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <stdio.h>
@@ -28,7 +28,7 @@
 #include "nm-device-bt.h"
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "ppp-manager/nm-ppp-manager.h"
 #include "nm-properties-changed-signal.h"
@@ -51,14 +51,16 @@ typedef struct {
 	char *name;
 	guint32 capabilities;
 
+	gboolean connected;
+	gboolean have_iface;
+
 	DBusGProxy *type_proxy;
+	DBusGProxy *dev_proxy;
 
-	NMPPPManager *ppp_manager;
 	char *rfcomm_iface;
-	guint32 in_bytes;
-	guint32 out_bytes;
+	NMModem *modem;
+	guint32 timeout_id;
 
-	NMIP4Config *pending_ip4_config;
 	guint32 bt_type;  /* BT type of the current connection */
 } NMDeviceBtPrivate;
 
@@ -122,31 +124,6 @@ nm_bt_error_get_type (void)
 }
 
 
-NMDevice *
-nm_device_bt_new (const char *udi,
-                  const char *bdaddr,
-                  const char *name,
-                  guint32 capabilities,
-                  gboolean managed)
-{
-	g_return_val_if_fail (udi != NULL, NULL);
-	g_return_val_if_fail (bdaddr != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	g_return_val_if_fail (capabilities != NM_BT_CAPABILITY_NONE, NULL);
-
-	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_BT,
-	                                  NM_DEVICE_INTERFACE_UDI, udi,
-	                                  NM_DEVICE_INTERFACE_IFACE, bdaddr,
-	                                  NM_DEVICE_INTERFACE_DRIVER, "bluez",
-	                                  NM_DEVICE_BT_HW_ADDRESS, bdaddr,
-	                                  NM_DEVICE_BT_NAME, name,
-	                                  NM_DEVICE_BT_CAPABILITIES, capabilities,
-	                                  NM_DEVICE_INTERFACE_MANAGED, managed,
-	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "Bluetooth",
-	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_BT,
-	                                  NULL);
-}
-
 guint32 nm_device_bt_get_capabilities (NMDeviceBt *self)
 {
 	g_return_val_if_fail (self != NULL, NM_BT_CAPABILITY_NONE);
@@ -281,16 +258,26 @@ real_get_generic_capabilities (NMDevice *dev)
 /* IP method PPP */
 
 static void
-ppp_state_changed (NMPPPManager *ppp_manager, NMPPPStatus status, gpointer user_data)
+ppp_stats (NMModem *modem,
+		   guint32 in_bytes,
+		   guint32 out_bytes,
+		   gpointer user_data)
+{
+	g_signal_emit (NM_DEVICE_BT (user_data), signals[PPP_STATS], 0, in_bytes, out_bytes);
+}
+
+static void
+ppp_failed (NMModem *modem, NMDeviceStateReason reason, gpointer user_data)
 {
 	NMDevice *device = NM_DEVICE (user_data);
 
-	switch (status) {
-	case NM_PPP_STATUS_DISCONNECT:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_DISCONNECT);
-		break;
-	case NM_PPP_STATUS_DEAD:
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_PPP_FAILED);
+	switch (nm_device_interface_get_state (NM_DEVICE_INTERFACE (device))) {
+	case NM_DEVICE_STATE_PREPARE:
+	case NM_DEVICE_STATE_CONFIG:
+	case NM_DEVICE_STATE_NEED_AUTH:
+	case NM_DEVICE_STATE_IP_CONFIG:
+	case NM_DEVICE_STATE_ACTIVATED:
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
 		break;
 	default:
 		break;
@@ -298,68 +285,127 @@ ppp_state_changed (NMPPPManager *ppp_manager, NMPPPStatus status, gpointer user_
 }
 
 static void
-ppp_ip4_config (NMPPPManager *ppp_manager,
-                const char *iface,
-                NMIP4Config *config,
-                gpointer user_data)
+modem_need_auth (NMModem *modem,
+	             const char *setting_name,
+	             gboolean retry,
+	             RequestSecretsCaller caller,
+	             const char *hint1,
+	             const char *hint2,
+	             gpointer user_data)
+{
+	NMDeviceBt *self = NM_DEVICE_BT (user_data);
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_assert (req);
+
+	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
+	nm_act_request_get_secrets (req, setting_name, retry, caller, hint1, hint2);
+}
+
+static void
+modem_prepare_result (NMModem *modem,
+                      gboolean success,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
 {
 	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
 
-	/* Ignore PPP IP4 events that come in after initial configuration */
-	if (nm_device_get_state (device) != NM_DEVICE_STATE_IP_CONFIG)
-		return;
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_CONFIG || state == NM_DEVICE_STATE_NEED_AUTH);
 
-	nm_device_set_ip_iface (device, iface);
-	NM_DEVICE_BT_GET_PRIVATE (device)->pending_ip4_config = g_object_ref (config);
-	nm_device_activate_schedule_stage4_ip4_config_get (device);
+	if (success) {
+		NMActRequest *req;
+		NMActStageReturn ret;
+		NMDeviceStateReason stage2_reason = NM_DEVICE_STATE_REASON_NONE;
+
+		req = nm_device_get_act_request (device);
+		g_assert (req);
+
+		ret = nm_modem_act_stage2_config (modem, req, &stage2_reason);
+		switch (ret) {
+		case NM_ACT_STAGE_RETURN_POSTPONE:
+			break;
+		case NM_ACT_STAGE_RETURN_SUCCESS:
+			nm_device_activate_schedule_stage3_ip_config_start (device);
+			break;
+		case NM_ACT_STAGE_RETURN_FAILURE:
+		default:
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, stage2_reason);
+			break;
+		}
+	} else
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
 }
 
 static void
-ppp_stats (NMPPPManager *ppp_manager,
-           guint32 in_bytes,
-           guint32 out_bytes,
-           gpointer user_data)
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
 {
-	NMDeviceBt *self = NM_DEVICE_BT (user_data);
-	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
+	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
+
+	if (priv->modem)
+		nm_modem_device_state_changed (priv->modem, new_state, old_state, reason);
+}
+
+static void
+modem_ip4_config_result (NMModem *self,
+                         const char *iface,
+                         NMIP4Config *config,
+                         GError *error,
+                         gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_IP_CONFIG);
 
-	if (priv->in_bytes != in_bytes || priv->out_bytes != out_bytes) {
-		priv->in_bytes = in_bytes;
-		priv->out_bytes = out_bytes;
+	if (error) {
+		nm_log_warn (LOGD_MB | LOGD_IP4 | LOGD_BT,
+		             "(%s): retrieving IP4 configuration failed: (%d) %s",
+		             nm_device_get_ip_iface (device),
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
 
-		g_signal_emit (self, signals[PPP_STATS], 0, in_bytes, out_bytes);
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);
+	} else {
+		if (iface)
+			nm_device_set_ip_iface (device, iface);
+
+		nm_device_activate_schedule_stage4_ip4_config_get (device);
 	}
 }
 
 static gboolean
-get_ppp_credentials (NMConnection *connection,
-                     const char **username,
-                     const char **password)
-{
-	NMSettingGsm *s_gsm;
-	NMSettingCdma *s_cdma = NULL;
-
-	s_gsm = (NMSettingGsm *) nm_connection_get_setting (connection, NM_TYPE_SETTING_GSM);
-	if (s_gsm) {
-		if (username)
-			*username = nm_setting_gsm_get_username (s_gsm);
-		if (password)
-			*password = nm_setting_gsm_get_password (s_gsm);
-	} else {
-		/* Try CDMA then */
-		s_cdma = (NMSettingCdma *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CDMA);
-		if (s_cdma) {
-			if (username)
-				*username = nm_setting_cdma_get_username (s_cdma);
-			if (password)
-				*password = nm_setting_cdma_get_password (s_cdma);
-		}
+modem_stage1 (NMDeviceBt *self, NMModem *modem, NMDeviceStateReason *reason)
+{
+	NMActRequest *req;
+	NMActStageReturn ret;
+
+	g_return_val_if_fail (reason != NULL, FALSE);
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_assert (req);
+
+	ret = nm_modem_act_stage1_prepare (modem, req, reason);
+	switch (ret) {
+	case NM_ACT_STAGE_RETURN_POSTPONE:
+	case NM_ACT_STAGE_RETURN_SUCCESS:
+		/* Success, wait for the 'prepare-result' signal */
+		return TRUE;
+	case NM_ACT_STAGE_RETURN_FAILURE:
+	default:
+		break;
 	}
 
-	return (s_cdma || s_gsm) ? TRUE : FALSE;
+	return FALSE;
 }
 
-
 static void
 real_connection_secrets_updated (NMDevice *device,
                                  NMConnection *connection,
@@ -369,111 +415,181 @@ real_connection_secrets_updated (NMDevice *device,
 	NMDeviceBt *self = NM_DEVICE_BT (device);
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
 	NMActRequest *req;
-	const char *username = NULL, *password = NULL;
-	gboolean success = FALSE;
-
-	if (caller != SECRETS_CALLER_PPP)
-		return;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
-	g_return_if_fail (priv->ppp_manager);
+	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (device)));
 
 	req = nm_device_get_act_request (device);
 	g_assert (req);
 
-	success = get_ppp_credentials (nm_act_request_get_connection (req),
-	                               &username,
-	                               &password);
-	if (success) {
-		nm_ppp_manager_update_secrets (priv->ppp_manager,
-		                               nm_device_get_ip_iface (device),
-		                               username ? username : "",
-		                               password ? password : "",
-		                               NULL);
+	if (!nm_modem_connection_secrets_updated (priv->modem,
+                                              req,
+                                              connection,
+                                              updated_settings,
+                                              caller)) {
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
 		return;
 	}
 
-	/* Shouldn't ever happen */
-	nm_ppp_manager_update_secrets (priv->ppp_manager,
-	                               nm_device_get_ip_iface (device),
-	                               NULL,
-	                               NULL,
-	                               "missing GSM/CDMA setting; no secrets could be found.");
+	/* PPP handles stuff itself... */
+	if (caller == SECRETS_CALLER_PPP)
+		return;
+
+	/* Otherwise, on success for GSM/CDMA secrets we need to schedule modem stage1 again */
+	g_return_if_fail (nm_device_get_state (device) == NM_DEVICE_STATE_NEED_AUTH);
+	if (!modem_stage1 (self, priv->modem, &reason))
+		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, reason);
 }
 
-static NMActStageReturn
-ppp_stage3_start (NMDevice *device, NMDeviceStateReason *reason)
+/*****************************************************************************/
+
+gboolean
+nm_device_bt_modem_added (NMDeviceBt *self,
+                          NMModem *modem,
+                          const char *driver)
 {
-	NMDeviceBt *self = NM_DEVICE_BT (device);
-	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
-	NMActRequest *req;
-	const char *ppp_name = NULL;
-	GError *err = NULL;
-	NMActStageReturn ret;
-	gboolean success;
+	NMDeviceBtPrivate *priv;
+	const char *modem_iface;
+	char *base;
+	NMDeviceState state;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
-	req = nm_device_get_act_request (device);
-	g_assert (req);
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DEVICE_BT (self), FALSE);
+	g_return_val_if_fail (modem != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM (modem), FALSE);
 
-	success = get_ppp_credentials (nm_act_request_get_connection (req),
-	                               &ppp_name,
-	                               NULL);
-	if (!success) {
-		// FIXME: set reason to something plausible
-		return NM_ACT_STAGE_RETURN_FAILURE;
+	priv = NM_DEVICE_BT_GET_PRIVATE (self);
+	modem_iface = nm_modem_get_iface (modem);
+	g_return_val_if_fail (modem_iface != NULL, FALSE);
+
+	if (!priv->rfcomm_iface)
+		return FALSE;
+
+	base = g_path_get_basename (priv->rfcomm_iface);
+	if (strcmp (base, modem_iface)) {
+		g_free (base);
+		return FALSE;
 	}
+	g_free (base);
 
-	priv->ppp_manager = nm_ppp_manager_new (priv->rfcomm_iface);
-	if (nm_ppp_manager_start (priv->ppp_manager, req, ppp_name, 20, &err)) {
-		g_signal_connect (priv->ppp_manager, "state-changed",
-						  G_CALLBACK (ppp_state_changed),
-						  device);
-		g_signal_connect (priv->ppp_manager, "ip4-config",
-						  G_CALLBACK (ppp_ip4_config),
-						  device);
-		g_signal_connect (priv->ppp_manager, "stats",
-						  G_CALLBACK (ppp_stats),
-						  device);
-
-		ret = NM_ACT_STAGE_RETURN_POSTPONE;
-	} else {
-		nm_warning ("%s", err->message);
-		g_error_free (err);
+	/* Got the modem */
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+
+	/* Can only accept the modem in stage2, but since the interface matched
+	 * what we were expecting, don't let anything else claim the modem either.
+	 */
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
+	if (state != NM_DEVICE_STATE_CONFIG) {
+		nm_log_warn (LOGD_BT | LOGD_MB,
+		             "(%s): modem found but device not in correct state (%d)",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             nm_device_get_state (NM_DEVICE (self)));
+		return TRUE;
+	}
 
-		g_object_unref (priv->ppp_manager);
-		priv->ppp_manager = NULL;
+	nm_log_info (LOGD_BT | LOGD_MB,
+	             "Activation (%s/bluetooth) Stage 2 of 5 (Device Configure) modem found.",
+	             nm_device_get_iface (NM_DEVICE (self)));
 
-		*reason = NM_DEVICE_STATE_REASON_PPP_START_FAILED;
-		ret = NM_ACT_STAGE_RETURN_FAILURE;
+	if (priv->modem) {
+		g_warn_if_reached ();
+		g_object_unref (priv->modem);
 	}
 
-	return ret;
+	priv->modem = g_object_ref (modem);
+	g_signal_connect (modem, NM_MODEM_PPP_STATS, G_CALLBACK (ppp_stats), self);
+	g_signal_connect (modem, NM_MODEM_PPP_FAILED, G_CALLBACK (ppp_failed), self);
+	g_signal_connect (modem, NM_MODEM_PREPARE_RESULT, G_CALLBACK (modem_prepare_result), self);
+	g_signal_connect (modem, NM_MODEM_IP4_CONFIG_RESULT, G_CALLBACK (modem_ip4_config_result), self);
+	g_signal_connect (modem, NM_MODEM_NEED_AUTH, G_CALLBACK (modem_need_auth), self);
+
+	/* Kick off the modem connection */
+	if (!modem_stage1 (self, modem, &reason))
+		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, reason);
+
+	return TRUE;
 }
 
-static NMActStageReturn
-ppp_stage4 (NMDevice *device, NMIP4Config **config, NMDeviceStateReason *reason)
+gboolean
+nm_device_bt_modem_removed (NMDeviceBt *self, NMModem *modem)
 {
-	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
-	NMConnection *connection;
-	NMSettingIP4Config *s_ip4;
+	NMDeviceBtPrivate *priv;
+	NMDeviceState state;
 
-	*config = priv->pending_ip4_config;
-	priv->pending_ip4_config = NULL;
+	g_return_val_if_fail (self != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_DEVICE_BT (self), FALSE);
+	g_return_val_if_fail (modem != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_MODEM (modem), FALSE);
 
-	/* Merge user-defined overrides into the IP4Config to be applied */
-	connection = nm_act_request_get_connection (nm_device_get_act_request (device));
-	g_assert (connection);
-	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-	nm_utils_merge_ip4_config (*config, s_ip4);
+	priv = NM_DEVICE_BT_GET_PRIVATE (self);
+
+	if (modem != priv->modem)
+		return FALSE;
 
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+	state = nm_device_get_state (NM_DEVICE (self));
+	nm_modem_device_state_changed (priv->modem,
+	                               NM_DEVICE_STATE_DISCONNECTED,
+	                               state,
+	                               NM_DEVICE_STATE_REASON_USER_REQUESTED);
+
+	g_object_unref (priv->modem);
+	priv->modem = NULL;
+	return TRUE;
 }
 
-/*****************************************************************************/
+static gboolean
+modem_find_timeout (gpointer user_data)
+{
+	NMDeviceBt *self = NM_DEVICE_BT (user_data);
+
+	NM_DEVICE_BT_GET_PRIVATE (self)->timeout_id = 0;
+	nm_device_state_changed (NM_DEVICE (self),
+	                         NM_DEVICE_STATE_FAILED,
+	                         NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND);
+	return FALSE;
+}
 
 static void
-nm_device_bt_connect_cb (DBusGProxy       *proxy,
-                         DBusGProxyCall   *call_id,
-                         void             *user_data)
+check_connect_continue (NMDeviceBt *self)
+{
+	NMDevice *device = NM_DEVICE (self);
+	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
+	gboolean pan = (priv->bt_type == NM_BT_CAPABILITY_NAP);
+	gboolean dun = (priv->bt_type == NM_BT_CAPABILITY_DUN);
+
+	if (!priv->connected || !priv->have_iface)
+		return;
+
+	nm_log_info (LOGD_BT, "Activation (%s %s/bluetooth) Stage 2 of 5 (Device Configure) "
+	             "successful.  Will connect via %s.",
+	             nm_device_get_iface (device),
+	             nm_device_get_ip_iface (device),
+	             dun ? "DUN" : (pan ? "PAN" : "unknown"));
+
+	if (pan) {
+		/* Bluez says we're connected now.  Start IP config. */
+		nm_device_activate_schedule_stage3_ip_config_start (device);
+	} else if (dun) {
+		/* Wait for ModemManager to find the modem */
+		if (priv->timeout_id)
+			g_source_remove (priv->timeout_id);
+		priv->timeout_id = g_timeout_add_seconds (20, modem_find_timeout, self);
+
+		nm_log_info (LOGD_BT | LOGD_MB, "Activation (%s/bluetooth) Stage 2 of 5 (Device Configure) "
+		             "waiting for modem to appear.",
+		             nm_device_get_iface (device));
+	} else
+		g_assert_not_reached ();
+}
+
+static void
+bluez_connect_cb (DBusGProxy *proxy,
+                  DBusGProxyCall *call_id,
+                  void *user_data)
 {
 	NMDeviceBt *self = NM_DEVICE_BT (user_data);
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (self);
@@ -481,22 +597,24 @@ nm_device_bt_connect_cb (DBusGProxy       *proxy,
 	char *device;
 
 	if (dbus_g_proxy_end_call (proxy, call_id, &error,
-				   G_TYPE_STRING, &device,
-				   G_TYPE_INVALID) == FALSE) {
-		nm_warning ("Error connecting with bluez: %s",
-		            error && error->message ? error->message : "(unknown)");
+	                           G_TYPE_STRING, &device,
+	                           G_TYPE_INVALID) == FALSE) {
+		nm_log_warn (LOGD_BT, "Error connecting with bluez: %s",
+		             error && error->message ? error->message : "(unknown)");
 		g_clear_error (&error);
 
-		// FIXME: get a better reason code
-		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
+		nm_device_state_changed (NM_DEVICE (self),
+		                         NM_DEVICE_STATE_FAILED,
+		                         NM_DEVICE_STATE_REASON_BT_FAILED);
 		return;
 	}
 
 	if (!device || !strlen (device)) {
-		nm_warning ("Invalid network device returned by bluez");
+		nm_log_warn (LOGD_BT, "Invalid network device returned by bluez");
 
-		// FIXME: get a better reason code
-		nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
+		nm_device_state_changed (NM_DEVICE (self),
+		                         NM_DEVICE_STATE_FAILED,
+		                         NM_DEVICE_STATE_REASON_BT_FAILED);
 	}
 
 	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
@@ -508,6 +626,8 @@ nm_device_bt_connect_cb (DBusGProxy       *proxy,
 	}
 
 	/* Stage 3 gets scheduled when Bluez says we're connected */
+	priv->have_iface = TRUE;
+	check_connect_continue (self);
 }
 
 static void
@@ -528,18 +648,9 @@ bluez_property_changed (DBusGProxy *proxy,
 	state = nm_device_get_state (device);
 	connected = g_value_get_boolean (value);
 	if (connected) {
-		/* Bluez says we're connected now.  Start IP config. */
-
 		if (state == NM_DEVICE_STATE_CONFIG) {
-			gboolean pan = (priv->bt_type == NM_BT_CAPABILITY_NAP);
-			gboolean dun = (priv->bt_type == NM_BT_CAPABILITY_DUN);
-
-			nm_info ("Activation (%s/bluetooth) Stage 2 of 5 (Device Configure) "
-			         "successful.  Connected via %s.",
-			         nm_device_get_iface (device),
-			         dun ? "DUN" : (pan ? "PAN" : "unknown"));
-
-			nm_device_activate_schedule_stage3_ip_config_start (device);
+			priv->connected = TRUE;
+			check_connect_continue (self);
 		}
 	} else {
 		gboolean fail = FALSE;
@@ -547,19 +658,35 @@ bluez_property_changed (DBusGProxy *proxy,
 		/* Bluez says we're disconnected from the device.  Suck. */
 
 		if (nm_device_is_activating (device)) {
-			nm_info ("Activation (%s/bluetooth): bluetooth link disconnected.",
-			         nm_device_get_iface (device));
+			nm_log_info (LOGD_BT,
+			             "Activation (%s/bluetooth): bluetooth link disconnected.",
+			             nm_device_get_iface (device));
 			fail = TRUE;
 		} else if (state == NM_DEVICE_STATE_ACTIVATED) {
-			nm_info ("%s: bluetooth link disconnected.", nm_device_get_iface (device));
+			nm_log_info (LOGD_BT, "(%s): bluetooth link disconnected.",
+			             nm_device_get_iface (device));
 			fail = TRUE;
 		}
 
-		if (fail)
+		if (fail) {
 			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_CARRIER);
+			priv->connected = FALSE;
+		}
 	}
 }
 
+static gboolean
+bt_connect_timeout (gpointer user_data)
+{
+	NMDeviceBt *self = NM_DEVICE_BT (user_data);
+
+	NM_DEVICE_BT_GET_PRIVATE (self)->timeout_id = 0;
+	nm_device_state_changed (NM_DEVICE (self),
+	                         NM_DEVICE_STATE_FAILED,
+	                         NM_DEVICE_STATE_REASON_BT_FAILED);
+	return FALSE;
+}
+
 static NMActStageReturn
 real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
 {
@@ -567,6 +694,7 @@ real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
 	NMActRequest *req;
 	NMDBusManager *dbus_mgr;
 	DBusGConnection *g_connection;
+	gboolean dun = FALSE;
 
 	req = nm_device_get_act_request (device);
 	g_assert (req);
@@ -581,53 +709,54 @@ real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
 	g_connection = nm_dbus_manager_get_connection (dbus_mgr);
 	g_object_unref (dbus_mgr);
 
-	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
-		priv->type_proxy = dbus_g_proxy_new_for_name (g_connection,
-							      BLUEZ_SERVICE,
-							      nm_device_get_udi (device),
-							      BLUEZ_SERIAL_INTERFACE);
-		if (!priv->type_proxy) {
-			// FIXME: set a reason code
-			return NM_ACT_STAGE_RETURN_FAILURE;
-		}
-
-		dbus_g_proxy_begin_call_with_timeout (priv->type_proxy, "Connect",
-		                                      nm_device_bt_connect_cb,
-		                                      device,
-		                                      NULL,
-		                                      20000,
-		                                      G_TYPE_STRING, BLUETOOTH_DUN_UUID,
-		                                      G_TYPE_INVALID);
-	} else if (priv->bt_type == NM_BT_CAPABILITY_NAP) {
-		priv->type_proxy = dbus_g_proxy_new_for_name (g_connection,
-							      BLUEZ_SERVICE,
-							      nm_device_get_udi (device),
-							      BLUEZ_NETWORK_INTERFACE);
-		if (!priv->type_proxy) {
-			// FIXME: set a reason code
-			return NM_ACT_STAGE_RETURN_FAILURE;
-		}
-
-		dbus_g_proxy_begin_call_with_timeout (priv->type_proxy, "Connect",
-		                                      nm_device_bt_connect_cb,
-		                                      device,
-		                                      NULL,
-		                                      20000,
-		                                      G_TYPE_STRING, BLUETOOTH_NAP_UUID,
-		                                      G_TYPE_INVALID);
-	} else
+	if (priv->bt_type == NM_BT_CAPABILITY_DUN)
+		dun = TRUE;
+	else if (priv->bt_type == NM_BT_CAPABILITY_NAP)
+		dun = FALSE;
+	else
 		g_assert_not_reached ();
 
+	priv->dev_proxy = dbus_g_proxy_new_for_name (g_connection,
+	                                               BLUEZ_SERVICE,
+	                                               nm_device_get_udi (device),
+	                                               BLUEZ_DEVICE_INTERFACE);
+	if (!priv->dev_proxy) {
+		// FIXME: set a reason code
+		return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
 	/* Watch for BT device property changes */
 	dbus_g_object_register_marshaller (_nm_marshal_VOID__STRING_BOXED,
 	                                   G_TYPE_NONE,
 	                                   G_TYPE_STRING, G_TYPE_VALUE,
 	                                   G_TYPE_INVALID);
-	dbus_g_proxy_add_signal (priv->type_proxy, "PropertyChanged",
+	dbus_g_proxy_add_signal (priv->dev_proxy, "PropertyChanged",
 	                         G_TYPE_STRING, G_TYPE_VALUE, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (priv->type_proxy, "PropertyChanged",
+	dbus_g_proxy_connect_signal (priv->dev_proxy, "PropertyChanged",
 	                             G_CALLBACK (bluez_property_changed), device, NULL);
 
+	priv->type_proxy = dbus_g_proxy_new_for_name (g_connection,
+	                                              BLUEZ_SERVICE,
+	                                              nm_device_get_udi (device),
+	                                              dun ? BLUEZ_SERIAL_INTERFACE : BLUEZ_NETWORK_INTERFACE);
+	if (!priv->type_proxy) {
+		// FIXME: set a reason code
+		return NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	/* Connect to the BT device */
+	dbus_g_proxy_begin_call_with_timeout (priv->type_proxy, "Connect",
+	                                      bluez_connect_cb,
+	                                      device,
+	                                      NULL,
+	                                      20000,
+	                                      G_TYPE_STRING, dun ? BLUETOOTH_DUN_UUID : BLUETOOTH_NAP_UUID,
+	                                      G_TYPE_INVALID);
+
+	if (priv->timeout_id)
+		g_source_remove (priv->timeout_id);
+	priv->timeout_id = g_timeout_add_seconds (30, bt_connect_timeout, device);
+
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
 
@@ -637,9 +766,12 @@ real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
 	NMActStageReturn ret;
 
-	if (priv->bt_type == NM_BT_CAPABILITY_DUN)
-		ret = ppp_stage3_start (device, reason);
-	else
+	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
+		ret = nm_modem_stage3_ip4_config_start (NM_DEVICE_BT_GET_PRIVATE (device)->modem,
+		                                        device,
+		                                        NM_DEVICE_CLASS (nm_device_bt_parent_class),
+		                                        reason);
+	} else
 		ret = NM_DEVICE_CLASS (nm_device_bt_parent_class)->act_stage3_ip4_config_start (device, reason);
 
 	return ret;
@@ -653,9 +785,13 @@ real_act_stage4_get_ip4_config (NMDevice *device,
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
 	NMActStageReturn ret;
 
-	if (priv->bt_type == NM_BT_CAPABILITY_DUN)
-		ret = ppp_stage4 (device, config, reason);
-	else
+	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
+		ret = nm_modem_stage4_get_ip4_config (NM_DEVICE_BT_GET_PRIVATE (device)->modem,
+		                                      device,
+		                                      NM_DEVICE_CLASS (nm_device_bt_parent_class),
+		                                      config,
+		                                      reason);
+	} else
 		ret = NM_DEVICE_CLASS (nm_device_bt_parent_class)->act_stage4_get_ip4_config (device, config, reason);
 
 	return ret;
@@ -666,17 +802,23 @@ real_deactivate_quickly (NMDevice *device)
 {
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (device);
 
-	if (priv->pending_ip4_config) {
-		g_object_unref (priv->pending_ip4_config);
-		priv->pending_ip4_config = NULL;
-	}
-
-	priv->in_bytes = priv->out_bytes = 0;
+	priv->have_iface = FALSE;
+	priv->connected = FALSE;
 
 	if (priv->bt_type == NM_BT_CAPABILITY_DUN) {
-		if (priv->ppp_manager) {
-			g_object_unref (priv->ppp_manager);
-			priv->ppp_manager = NULL;
+
+		if (priv->modem) {
+			nm_modem_deactivate_quickly (priv->modem, device);
+
+			/* Since we're killing the Modem object before it'll get the
+			 * state change signal, simulate the state change here.
+			 */
+			nm_modem_device_state_changed (priv->modem,
+			                               NM_DEVICE_STATE_DISCONNECTED,
+			                               NM_DEVICE_STATE_ACTIVATED,
+			                               NM_DEVICE_STATE_REASON_USER_REQUESTED);
+			g_object_unref (priv->modem);
+			priv->modem = NULL;
 		}
 
 		if (priv->type_proxy) {
@@ -700,6 +842,16 @@ real_deactivate_quickly (NMDevice *device)
 		}
 	}
 
+	if (priv->dev_proxy) {
+		g_object_unref (priv->dev_proxy);
+		priv->dev_proxy = NULL;
+	}
+
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+
 	priv->bt_type = NM_BT_CAPABILITY_NONE;
 
 	g_free (priv->rfcomm_iface);
@@ -709,6 +861,39 @@ real_deactivate_quickly (NMDevice *device)
 		NM_DEVICE_CLASS (nm_device_bt_parent_class)->deactivate_quickly (device);
 }
 
+/*****************************************************************************/
+
+NMDevice *
+nm_device_bt_new (const char *udi,
+                  const char *bdaddr,
+                  const char *name,
+                  guint32 capabilities,
+                  gboolean managed)
+{
+	NMDevice *device;
+
+	g_return_val_if_fail (udi != NULL, NULL);
+	g_return_val_if_fail (bdaddr != NULL, NULL);
+	g_return_val_if_fail (name != NULL, NULL);
+	g_return_val_if_fail (capabilities != NM_BT_CAPABILITY_NONE, NULL);
+
+	device = (NMDevice *) g_object_new (NM_TYPE_DEVICE_BT,
+	                                    NM_DEVICE_INTERFACE_UDI, udi,
+	                                    NM_DEVICE_INTERFACE_IFACE, bdaddr,
+	                                    NM_DEVICE_INTERFACE_DRIVER, "bluez",
+	                                    NM_DEVICE_BT_HW_ADDRESS, bdaddr,
+	                                    NM_DEVICE_BT_NAME, name,
+	                                    NM_DEVICE_BT_CAPABILITIES, capabilities,
+	                                    NM_DEVICE_INTERFACE_MANAGED, managed,
+	                                    NM_DEVICE_INTERFACE_TYPE_DESC, "Bluetooth",
+	                                    NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_BT,
+	                                    NULL);
+	if (device)
+		g_signal_connect (device, "state-changed", G_CALLBACK (device_state_changed), device);
+
+	return device;
+}
+
 static void
 nm_device_bt_init (NMDeviceBt *self)
 {
@@ -766,9 +951,21 @@ finalize (GObject *object)
 {
 	NMDeviceBtPrivate *priv = NM_DEVICE_BT_GET_PRIVATE (object);
 
+	if (priv->timeout_id) {
+		g_source_remove (priv->timeout_id);
+		priv->timeout_id = 0;
+	}
+
 	if (priv->type_proxy)
 		g_object_unref (priv->type_proxy);
 
+	if (priv->dev_proxy)
+		g_object_unref (priv->dev_proxy);
+
+	if (priv->modem)
+		g_object_unref (priv->modem);
+
+	g_free (priv->rfcomm_iface);
 	g_free (priv->bdaddr);
 	g_free (priv->name);
 
diff --git a/src/nm-device-bt.h b/src/nm-device-bt.h
index 67ef6f5..d3187d7 100644
--- a/src/nm-device-bt.h
+++ b/src/nm-device-bt.h
@@ -22,6 +22,7 @@
 #define NM_DEVICE_BT_H
 
 #include <nm-device.h>
+#include "nm-modem.h"
 
 G_BEGIN_DECLS
 
@@ -60,6 +61,12 @@ guint32 nm_device_bt_get_capabilities (NMDeviceBt *device);
 
 const char *nm_device_bt_get_hw_address (NMDeviceBt *device);
 
+gboolean nm_device_bt_modem_added (NMDeviceBt *device,
+                                   NMModem *modem,
+                                   const char *driver);
+
+gboolean nm_device_bt_modem_removed (NMDeviceBt *device, NMModem *modem);
+
 G_END_DECLS
 
 #endif /* NM_GSM_DEVICE_H */
diff --git a/src/nm-device-cdma.c b/src/nm-device-cdma.c
new file mode 100644
index 0000000..45771f4
--- /dev/null
+++ b/src/nm-device-cdma.c
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+
+#include "nm-modem-cdma.h"
+#include "nm-device-interface.h"
+#include "nm-device-cdma.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-rfkill.h"
+
+#include "nm-device-cdma-glue.h"
+
+G_DEFINE_TYPE (NMDeviceCdma, nm_device_cdma, NM_TYPE_DEVICE_MODEM)
+
+enum {
+	PROPERTIES_CHANGED,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+NMDevice *
+nm_device_cdma_new (NMModemCdma *modem, const char *driver)
+{
+	g_return_val_if_fail (modem != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM_CDMA (modem), NULL);
+	g_return_val_if_fail (driver != NULL, NULL);
+
+	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_CDMA,
+	                                  NM_DEVICE_INTERFACE_UDI, nm_modem_get_path (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_IFACE, nm_modem_get_iface (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
+	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "CDMA",
+	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_CDMA,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE, RFKILL_TYPE_WWAN,
+	                                  NM_DEVICE_MODEM_MODEM, modem,
+	                                  NULL);
+}
+
+static void
+nm_device_cdma_init (NMDeviceCdma *self)
+{
+}
+
+static void
+nm_device_cdma_class_init (NMDeviceCdmaClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+		                                  G_STRUCT_OFFSET (NMDeviceCdmaClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
+	                                 &dbus_glib_nm_device_cdma_object_info);
+}
+
diff --git a/src/nm-device-cdma.h b/src/nm-device-cdma.h
new file mode 100644
index 0000000..f0bf345
--- /dev/null
+++ b/src/nm-device-cdma.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_CDMA_H
+#define NM_DEVICE_CDMA_H
+
+#include "nm-device-modem.h"
+#include "nm-modem-cdma.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_CDMA            (nm_device_cdma_get_type ())
+#define NM_DEVICE_CDMA(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_CDMA, NMDeviceCdma))
+#define NM_DEVICE_CDMA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_DEVICE_CDMA, NMDeviceCdmaClass))
+#define NM_IS_DEVICE_CDMA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_CDMA))
+#define NM_IS_DEVICE_CDMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_DEVICE_CDMA))
+#define NM_DEVICE_CDMA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_DEVICE_CDMA, NMDeviceCdmaClass))
+
+typedef struct {
+	NMDeviceModem parent;
+} NMDeviceCdma;
+
+typedef struct {
+	NMDeviceModemClass parent;
+
+	/* Signals */
+	void (*signal_quality) (NMDeviceCdma *self, guint32 quality);
+
+	void (*properties_changed) (NMDeviceCdma *self, GHashTable *properties);
+} NMDeviceCdmaClass;
+
+GType nm_device_cdma_get_type (void);
+
+NMDevice *nm_device_cdma_new (NMModemCdma *modem, const char *driver);
+
+G_END_DECLS
+
+#endif /* NM_DEVICE_CDMA_H */
diff --git a/src/nm-device-ethernet.c b/src/nm-device-ethernet.c
index 037d603..f4581e9 100644
--- a/src/nm-device-ethernet.c
+++ b/src/nm-device-ethernet.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -45,13 +45,13 @@
 #include "nm-supplicant-config.h"
 #include "nm-netlink.h"
 #include "nm-netlink-monitor.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-wired.h"
 #include "nm-setting-8021x.h"
 #include "nm-setting-pppoe.h"
 #include "ppp-manager/nm-ppp-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-dhcp-manager.h"
 
@@ -227,11 +227,11 @@ set_carrier (NMDeviceEthernet *self,
 	g_object_notify (G_OBJECT (self), NM_DEVICE_ETHERNET_CARRIER);
 
 	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-	nm_info ("(%s): carrier now %s (device state %d%s)",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         carrier ? "ON" : "OFF",
-	         state,
-	         defer_action ? ", deferring action for 4 seconds" : "");
+	nm_log_info (LOGD_HW | LOGD_ETHER, "(%s): carrier now %s (device state %d%s)",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             carrier ? "ON" : "OFF",
+	             state,
+	             defer_action ? ", deferring action for 4 seconds" : "");
 
 	if (defer_action)
 		priv->carrier_action_defer_id = g_timeout_add_seconds (4, carrier_action_defer_cb, self);
@@ -311,6 +311,9 @@ constructor (GType type,
 	self = NM_DEVICE (object);
 	priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_HW | LOGD_OLPC_MESH, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (self)), priv->ifindex);
+
 	caps = nm_device_get_capabilities (self);
 	if (caps & NM_DEVICE_CAP_CARRIER_DETECT) {
 		GError *error = NULL;
@@ -331,30 +334,36 @@ constructor (GType type,
 		                                        priv->ifindex,
 		                                        &ifflags,
 		                                        &error)) {
-			nm_warning ("couldn't get initial carrier state: (%d) %s",
-			            error ? error->code : -1,
-			            (error && error->message) ? error->message : "unknown");
+			nm_log_warn (LOGD_HW | LOGD_ETHER,
+			             "(%s): couldn't get initial carrier state: (%d) %s",
+			             nm_device_get_iface (NM_DEVICE (self)),
+			             error ? error->code : -1,
+			             (error && error->message) ? error->message : "unknown");
 			g_clear_error (&error);
 		} else
 			priv->carrier = !!(ifflags & IFF_LOWER_UP);
 
-		nm_info ("(%s): carrier is %s",
-		         nm_device_get_iface (NM_DEVICE (self)),
-		         priv->carrier ? "ON" : "OFF");
+		nm_log_info (LOGD_HW | LOGD_ETHER,
+		             "(%s): carrier is %s",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             priv->carrier ? "ON" : "OFF");
 
 		/* Request link state again just in case an error occurred getting the
 		 * initial link state.
 		 */
 		if (!nm_netlink_monitor_request_status (priv->monitor, &error)) {
-			nm_warning ("couldn't request carrier state: (%d) %s",
-			            error ? error->code : -1,
-			            (error && error->message) ? error->message : "unknown");
+			nm_log_warn (LOGD_HW | LOGD_ETHER,
+			             "(%s): couldn't request carrier state: (%d) %s",
+			             nm_device_get_iface (NM_DEVICE (self)),
+			             error ? error->code : -1,
+			             (error && error->message) ? error->message : "unknown");
 			g_clear_error (&error);
 		}
 	} else {
-		nm_info ("(%s): driver '%s' does not support carrier detection.",
-		         nm_device_get_iface (self),
-		         nm_device_get_driver (self));
+		nm_log_info (LOGD_HW | LOGD_ETHER,
+		             "(%s): driver '%s' does not support carrier detection.",
+		             nm_device_get_iface (self),
+		             nm_device_get_driver (self));
 		priv->carrier = TRUE;
 	}
 
@@ -473,7 +482,7 @@ nm_device_ethernet_get_speed (NMDeviceEthernet *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_warn (LOGD_HW, "couldn't open control socket.");
 		return 0;
 	}
 
@@ -508,15 +517,16 @@ real_update_hw_address (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_warn (LOGD_HW, "couldn't open control socket.");
 		return;
 	}
 
 	memset (&req, 0, sizeof (struct ifreq));
 	strncpy (req.ifr_name, nm_device_get_iface (dev), IFNAMSIZ);
 	if (ioctl (fd, SIOCGIFHWADDR, &req) < 0) {
-		nm_warning ("%s: (%s) error getting hardware address: %d",
-		            __func__, nm_device_get_iface (dev), errno);
+		nm_log_err (LOGD_HW | LOGD_ETHER,
+		            "(%s) error getting hardware address: %d",
+		            nm_device_get_iface (dev), errno);
 		goto out;
 	}
 
@@ -670,7 +680,8 @@ real_connection_secrets_updated (NMDevice *dev,
 		if (!strcmp (setting_name, NM_SETTING_802_1X_SETTING_NAME)) {
 			valid = TRUE;
 		} else {
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
+			nm_log_warn (LOGD_DEVICE, "Ignoring updated secrets for setting '%s'.",
+			             setting_name);
 		}
 	}
 
@@ -827,8 +838,10 @@ link_timeout_cb (gpointer user_data)
 	if (!setting_name)
 		goto time_out;
 
-	nm_info ("Activation (%s/wired): disconnected during authentication,"
-	         " asking for new key.", nm_device_get_iface (dev));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "Activation (%s/wired): disconnected during authentication,"
+	             " asking for new key.",
+	             nm_device_get_iface (dev));
 	supplicant_interface_release (self);
 
 	nm_device_state_changed (dev, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
@@ -842,7 +855,8 @@ link_timeout_cb (gpointer user_data)
 	return FALSE;
 
 time_out:
-	nm_info ("%s: link timed out.", nm_device_get_iface (dev));
+	nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s): link timed out.", nm_device_get_iface (dev));
 	nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
 
 	return FALSE;
@@ -863,7 +877,7 @@ schedule_state_handler (NMDeviceEthernet *self,
 
 	task = g_slice_new0 (SupplicantStateTask);
 	if (!task) {
-		nm_warning ("Not enough memory to process supplicant manager state change.");
+		nm_log_err (LOGD_DEVICE, "Not enough memory to process supplicant manager state change.");
 		return FALSE;
 	}
 
@@ -906,10 +920,11 @@ supplicant_mgr_state_cb (NMSupplicantInterface * iface,
                          guint32 old_state,
                          gpointer user_data)
 {
-	nm_info ("(%s): supplicant manager state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (user_data)),
-	         nm_supplicant_manager_state_to_string (old_state),
-	         nm_supplicant_manager_state_to_string (new_state));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s): supplicant manager state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (user_data)),
+	             nm_supplicant_manager_state_to_string (old_state),
+	             nm_supplicant_manager_state_to_string (new_state));
 
 	schedule_state_handler (NM_DEVICE_ETHERNET (user_data),
 	                        supplicant_mgr_state_cb_handler,
@@ -936,7 +951,7 @@ build_supplicant_config (NMDeviceEthernet *self)
 
 	security = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));
 	if (!nm_supplicant_config_add_setting_8021x (config, security, con_path, TRUE)) {
-		nm_warning ("Couldn't add 802.1X security setting to supplicant config.");
+		nm_log_warn (LOGD_DEVICE, "Couldn't add 802.1X security setting to supplicant config.");
 		g_object_unref (config);
 		config = NULL;
 	}
@@ -962,11 +977,17 @@ supplicant_iface_state_cb_handler (gpointer user_data)
 			success = nm_supplicant_interface_set_config (priv->supplicant.iface, config);
 			g_object_unref (config);
 
-			if (!success)
-				nm_warning ("Activation (%s/wired): couldn't send security "
-						  "configuration to the supplicant.", iface);
-		} else
-			nm_warning ("Activation (%s/wired): couldn't build security configuration.", iface);
+			if (!success) {
+				nm_log_err (LOGD_DEVICE | LOGD_ETHER,
+				            "Activation (%s/wired): couldn't send security "
+						    "configuration to the supplicant.",
+						    iface);
+			}
+		} else {
+			nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+			             "Activation (%s/wired): couldn't build security configuration.",
+			             iface);
+		}
 
 		if (!success)
 			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED);
@@ -990,10 +1011,11 @@ supplicant_iface_state_cb (NMSupplicantInterface * iface,
                            gpointer user_data)
 {
 
-	nm_info ("(%s): supplicant interface state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (user_data)),
-	         nm_supplicant_interface_state_to_string (old_state),
-	         nm_supplicant_interface_state_to_string (new_state));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s): supplicant interface state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (user_data)),
+	             nm_supplicant_interface_state_to_string (old_state),
+	             nm_supplicant_interface_state_to_string (new_state));
 
 	schedule_state_handler (NM_DEVICE_ETHERNET (user_data),
 	                        supplicant_iface_state_cb_handler,
@@ -1016,8 +1038,9 @@ supplicant_iface_connection_state_cb_handler (gpointer user_data)
 		 * schedule the next activation stage.
 		 */
 		if (nm_device_get_state (dev) == NM_DEVICE_STATE_CONFIG) {
-			nm_info ("Activation (%s/wired) Stage 2 of 5 (Device Configure) successful.",
-				    nm_device_get_iface (dev));
+			nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+			             "Activation (%s/wired) Stage 2 of 5 (Device Configure) successful.",
+				         nm_device_get_iface (dev));
 			nm_device_activate_schedule_stage3_ip_config_start (dev);
 		}
 	} else if (task->new_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED) {
@@ -1040,10 +1063,11 @@ supplicant_iface_connection_state_cb (NMSupplicantInterface * iface,
                                       guint32 old_state,
                                       gpointer user_data)
 {
-	nm_info ("(%s) supplicant connection state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (user_data)),
-	         nm_supplicant_interface_connection_state_to_string (old_state),
-	         nm_supplicant_interface_connection_state_to_string (new_state));
+	nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+	             "(%s) supplicant connection state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (user_data)),
+	             nm_supplicant_interface_connection_state_to_string (old_state),
+	             nm_supplicant_interface_connection_state_to_string (new_state));
 
 	schedule_state_handler (NM_DEVICE_ETHERNET (user_data),
 	                        supplicant_iface_connection_state_cb_handler,
@@ -1075,8 +1099,9 @@ supplicant_iface_connection_error_cb (NMSupplicantInterface *iface,
 	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
 	guint id;
 
-	nm_info ("Activation (%s/wired): association request to the supplicant failed: %s - %s",
-	         nm_device_get_iface (NM_DEVICE (self)), name, message);
+	nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+	             "Activation (%s/wired): association request to the supplicant failed: %s - %s",
+	             nm_device_get_iface (NM_DEVICE (self)), name, message);
 
 	if (priv->supplicant.iface_con_error_cb_id)
 		g_source_remove (priv->supplicant.iface_con_error_cb_id);
@@ -1120,8 +1145,9 @@ handle_auth_or_fail (NMDeviceEthernet *self,
 		                            NULL);
 
 		g_object_set_data (G_OBJECT (connection), WIRED_SECRETS_TRIES, GUINT_TO_POINTER (++tries));
-	} else
-		nm_warning ("Cleared secrets, but setting didn't need any secrets.");
+	} else {
+		nm_log_info (LOGD_DEVICE, "Cleared secrets, but setting didn't need any secrets.");
+	}
 
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
@@ -1140,15 +1166,17 @@ supplicant_connection_timeout_cb (gpointer user_data)
 	iface = nm_device_get_iface (device);
 
 	/* Authentication failed, encryption key is probably bad */
-	nm_info ("Activation (%s/wired): association took too long.", iface);
+	nm_log_warn (LOGD_DEVICE | LOGD_ETHER,
+	             "Activation (%s/wired): association took too long.", iface);
 
 	supplicant_interface_release (self);
 	req = nm_device_get_act_request (device);
 	g_assert (req);
 
-	if (handle_auth_or_fail (self, req, TRUE) == NM_ACT_STAGE_RETURN_POSTPONE)
-		nm_info ("Activation (%s/wired): asking for new secrets", iface);
-	else
+	if (handle_auth_or_fail (self, req, TRUE) == NM_ACT_STAGE_RETURN_POSTPONE) {
+		nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+		             "Activation (%s/wired): asking for new secrets", iface);
+	} else
 		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
 
 	return FALSE;
@@ -1165,7 +1193,9 @@ supplicant_interface_init (NMDeviceEthernet *self)
 	/* Create supplicant interface */
 	priv->supplicant.iface = nm_supplicant_manager_get_iface (priv->supplicant.mgr, iface, FALSE);
 	if (!priv->supplicant.iface) {
-		nm_warning ("Couldn't initialize supplicant interface for %s.", iface);
+		nm_log_err (LOGD_DEVICE | LOGD_ETHER,
+		            "Couldn't initialize supplicant interface for %s.",
+		            iface);
 		supplicant_interface_release (self);
 
 		return FALSE;
@@ -1213,7 +1243,7 @@ nm_8021x_stage2_config (NMDeviceEthernet *self, NMDeviceStateReason *reason)
 	connection = nm_act_request_get_connection (nm_device_get_act_request (NM_DEVICE (self)));
 	security = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));
 	if (!security) {
-		nm_warning ("Invalid or missing 802.1X security");
+		nm_log_err (LOGD_DEVICE, "Invalid or missing 802.1X security");
 		*reason = NM_DEVICE_STATE_REASON_CONFIG_FAILED;
 		return ret;
 	}
@@ -1226,15 +1256,17 @@ nm_8021x_stage2_config (NMDeviceEthernet *self, NMDeviceStateReason *reason)
 	if (setting_name) {
 		NMActRequest *req = nm_device_get_act_request (NM_DEVICE (self));
 
-		nm_info ("Activation (%s/wired): connection '%s' has security, but secrets are required.",
-				 iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+		             "Activation (%s/wired): connection '%s' has security, but secrets are required.",
+				     iface, nm_setting_connection_get_id (s_connection));
 
 		ret = handle_auth_or_fail (self, req, FALSE);
 		if (ret != NM_ACT_STAGE_RETURN_POSTPONE)
 			*reason = NM_DEVICE_STATE_REASON_NO_SECRETS;
 	} else {
-		nm_info ("Activation (%s/wired): connection '%s' requires no security. No secrets needed.",
-				 iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_ETHER,
+		             "Activation (%s/wired): connection '%s' requires no security. No secrets needed.",
+				     iface, nm_setting_connection_get_id (s_connection));
 
 		if (supplicant_interface_init (self))
 			ret = NM_ACT_STAGE_RETURN_POSTPONE;
@@ -1311,8 +1343,8 @@ pppoe_stage3_ip4_config_start (NMDeviceEthernet *self, NMDeviceStateReason *reas
 					   self);
 		ret = NM_ACT_STAGE_RETURN_POSTPONE;
 	} else {
-		nm_warning ("(%s): PPPoE failed to start: %s",
-		            nm_device_get_iface (NM_DEVICE (self)), err->message);
+		nm_log_warn (LOGD_DEVICE, "(%s): PPPoE failed to start: %s",
+		             nm_device_get_iface (NM_DEVICE (self)), err->message);
 		g_error_free (err);
 
 		g_object_unref (priv->ppp_manager);
@@ -1608,9 +1640,9 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 
 	/* Get any saved leases that apply to this connection */
 	dhcp_mgr = nm_dhcp_manager_get ();
-	leases = nm_dhcp_manager_get_lease_ip4_config (dhcp_mgr,
-	                                               nm_device_get_iface (self),
-	                                               nm_setting_connection_get_uuid (s_con));
+	leases = nm_dhcp_manager_get_lease_config (dhcp_mgr,
+	                                           nm_device_get_iface (self),
+	                                           nm_setting_connection_get_uuid (s_con));
 	g_object_unref (dhcp_mgr);
 
 	method = nm_setting_ip4_config_get_method (s_ip4);
@@ -1880,7 +1912,7 @@ supports_ethtool_carrier_detect (NMDeviceEthernet *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_err (LOGD_HW, "couldn't open control socket.");
 		return FALSE;
 	}
 
@@ -1890,13 +1922,18 @@ supports_ethtool_carrier_detect (NMDeviceEthernet *self)
 	edata.cmd = ETHTOOL_GLINK;
 	ifr.ifr_data = (char *) &edata;
 
-	if (ioctl (fd, SIOCETHTOOL, &ifr) < 0)
+	errno = 0;
+	if (ioctl (fd, SIOCETHTOOL, &ifr) < 0) {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCETHTOOL failed: %d", errno);
 		goto out;
+	}
 
 	supports_ethtool = TRUE;
 
 out:
 	close (fd);
+	nm_log_dbg (LOGD_HW | LOGD_ETHER, "ethtool %s supported",
+	            supports_ethtool ? "is" : "not");
 	return supports_ethtool;
 }
 
@@ -1920,8 +1957,13 @@ mdio_read (NMDeviceEthernet *self, int fd, struct ifreq *ifr, int location)
 	mii = (struct mii_ioctl_data *) &ifr->ifr_ifru;
 	mii->reg_num = location;
 
-	if (ioctl (fd, SIOCGMIIREG, ifr) == 0)
+	errno = 0;
+	if (ioctl (fd, SIOCGMIIREG, ifr) == 0) {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCGMIIREG result 0x%X", mii->val_out);
 		val = mii->val_out;
+	} else {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCGMIIREG failed: %d", errno);
+	}
 
 	return val;
 }
@@ -1937,19 +1979,24 @@ supports_mii_carrier_detect (NMDeviceEthernet *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_err (LOGD_HW, "couldn't open control socket.");
 		return 0;
 	}
 
 	memset (&ifr, 0, sizeof (struct ifreq));
 	strncpy (ifr.ifr_name, nm_device_get_iface (NM_DEVICE (self)), IFNAMSIZ);
 
-	if (ioctl (fd, SIOCGMIIPHY, &ifr) < 0)
+	errno = 0;
+	if (ioctl (fd, SIOCGMIIPHY, &ifr) < 0) {
+		nm_log_dbg (LOGD_HW | LOGD_ETHER, "SIOCGMIIPHY failed: %d", errno);
 		goto out;
+	}
 
 	/* If we can read the BMSR register, we assume that the card supports MII link detection */
 	bmsr = mdio_read (self, fd, &ifr, MII_BMSR);
 	supports_mii = (bmsr != -1) ? TRUE : FALSE;
+	nm_log_dbg (LOGD_HW | LOGD_ETHER, "MII %s supported",
+	            supports_mii ? "is" : "not");
 
 out:
 	close (fd);
diff --git a/src/nm-device-gsm.c b/src/nm-device-gsm.c
new file mode 100644
index 0000000..2a98a41
--- /dev/null
+++ b/src/nm-device-gsm.c
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+
+#include "nm-modem-gsm.h"
+#include "nm-device-interface.h"
+#include "nm-device-gsm.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-rfkill.h"
+
+#include "nm-device-gsm-glue.h"
+
+G_DEFINE_TYPE (NMDeviceGsm, nm_device_gsm, NM_TYPE_DEVICE_MODEM)
+
+enum {
+	PROPERTIES_CHANGED,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+NMDevice *
+nm_device_gsm_new (NMModemGsm *modem, const char *driver)
+{
+	g_return_val_if_fail (modem != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MODEM_GSM (modem), NULL);
+	g_return_val_if_fail (driver != NULL, NULL);
+
+	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_GSM,
+	                                  NM_DEVICE_INTERFACE_UDI, nm_modem_get_path (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_IFACE, nm_modem_get_iface (NM_MODEM (modem)),
+	                                  NM_DEVICE_INTERFACE_DRIVER, driver,
+	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "GSM",
+	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_GSM,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE, RFKILL_TYPE_WWAN,
+	                                  NM_DEVICE_MODEM_MODEM, modem,
+	                                  NULL);
+}
+
+static void
+nm_device_gsm_init (NMDeviceGsm *self)
+{
+}
+
+static void
+nm_device_gsm_class_init (NMDeviceGsmClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+		                                  G_STRUCT_OFFSET (NMDeviceGsmClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
+	                                 &dbus_glib_nm_device_gsm_object_info);
+}
+
diff --git a/src/nm-device-gsm.h b/src/nm-device-gsm.h
new file mode 100644
index 0000000..9b403c6
--- /dev/null
+++ b/src/nm-device-gsm.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_GSM_H
+#define NM_DEVICE_GSM_H
+
+#include "nm-device-modem.h"
+#include "nm-modem-gsm.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_GSM            (nm_device_gsm_get_type ())
+#define NM_DEVICE_GSM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_GSM, NMDeviceGsm))
+#define NM_DEVICE_GSM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_DEVICE_GSM, NMDeviceGsmClass))
+#define NM_IS_DEVICE_GSM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_GSM))
+#define NM_IS_DEVICE_GSM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_DEVICE_GSM))
+#define NM_DEVICE_GSM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_DEVICE_GSM, NMDeviceGsmClass))
+
+typedef struct {
+	NMDeviceModem parent;
+} NMDeviceGsm;
+
+typedef struct {
+	NMDeviceModemClass parent;
+
+	/* Signals */
+	void (*signal_quality) (NMDeviceGsm *self, guint32 quality);
+
+	void (*properties_changed) (NMDeviceGsm *self, GHashTable *properties);
+} NMDeviceGsmClass;
+
+GType nm_device_gsm_get_type (void);
+
+NMDevice *nm_device_gsm_new (NMModemGsm *modem, const char *driver);
+
+G_END_DECLS
+
+#endif /* NM_DEVICE_GSM_H */
diff --git a/src/nm-device-interface.c b/src/nm-device-interface.c
index 70cce8b..4040626 100644
--- a/src/nm-device-interface.c
+++ b/src/nm-device-interface.c
@@ -22,8 +22,9 @@
 #include "nm-marshal.h"
 #include "nm-setting-connection.h"
 #include "nm-device-interface.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-properties-changed-signal.h"
+#include "nm-rfkill.h"
 
 static gboolean impl_device_disconnect (NMDeviceInterface *device,
                                         GError **error);
@@ -139,6 +140,14 @@ nm_device_interface_init (gpointer g_iface)
 
 	g_object_interface_install_property
 		(g_iface,
+		 g_param_spec_boxed (NM_DEVICE_INTERFACE_DHCP6_CONFIG,
+							  "DHCP6 Config",
+							  "DHCP6 Config",
+							  DBUS_TYPE_G_OBJECT_PATH,
+							  G_PARAM_READWRITE));
+
+	g_object_interface_install_property
+		(g_iface,
 		 g_param_spec_uint (NM_DEVICE_INTERFACE_STATE,
 							"State",
 							"State",
@@ -168,6 +177,15 @@ nm_device_interface_init (gpointer g_iface)
 							  NULL,
 							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
 
+	g_object_interface_install_property
+		(g_iface, g_param_spec_uint (NM_DEVICE_INTERFACE_RFKILL_TYPE,
+	                                 "Rfkill Type",
+	                                 "Type of rfkill switch (if any) supported by this device",
+	                                 RFKILL_TYPE_WLAN,
+	                                 RFKILL_TYPE_MAX,
+	                                 RFKILL_TYPE_UNKNOWN,
+	                                 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+
 	/* Signals */
 	g_signal_new ("state-changed",
 				  iface_type,
@@ -264,8 +282,8 @@ nm_device_interface_activate (NMDeviceInterface *device,
 	g_assert (s_con);
 
 	iface = nm_device_interface_get_iface (device);
-	nm_info ("Activation (%s) starting connection '%s'", iface,
-			 nm_setting_connection_get_id (s_con));
+	nm_log_info (LOGD_DEVICE, "Activation (%s) starting connection '%s'", iface,
+			     nm_setting_connection_get_id (s_con));
 	g_free (iface);
 
 	success = NM_DEVICE_INTERFACE_GET_INTERFACE (device)->activate (device, req, error);
@@ -361,6 +379,16 @@ nm_device_interface_set_enabled (NMDeviceInterface *device, gboolean enabled)
 	g_return_if_fail (NM_IS_DEVICE_INTERFACE (device));
 
 	if (NM_DEVICE_INTERFACE_GET_INTERFACE (device)->set_enabled)
-		return NM_DEVICE_INTERFACE_GET_INTERFACE (device)->set_enabled (device, enabled);
+		NM_DEVICE_INTERFACE_GET_INTERFACE (device)->set_enabled (device, enabled);
+}
+
+gboolean
+nm_device_interface_get_enabled (NMDeviceInterface *device)
+{
+	g_return_val_if_fail (NM_IS_DEVICE_INTERFACE (device), FALSE);
+
+	if (NM_DEVICE_INTERFACE_GET_INTERFACE (device)->get_enabled)
+		return NM_DEVICE_INTERFACE_GET_INTERFACE (device)->get_enabled (device);
+	return TRUE;
 }
 
diff --git a/src/nm-device-interface.h b/src/nm-device-interface.h
index 0ec5e3d..adbafca 100644
--- a/src/nm-device-interface.h
+++ b/src/nm-device-interface.h
@@ -53,10 +53,12 @@ typedef enum
 #define NM_DEVICE_INTERFACE_IP4_CONFIG   "ip4-config"
 #define NM_DEVICE_INTERFACE_DHCP4_CONFIG "dhcp4-config"
 #define NM_DEVICE_INTERFACE_IP6_CONFIG   "ip6-config"
+#define NM_DEVICE_INTERFACE_DHCP6_CONFIG "dhcp6-config"
 #define NM_DEVICE_INTERFACE_STATE        "state"
 #define NM_DEVICE_INTERFACE_DEVICE_TYPE  "device-type" /* ugh */
 #define NM_DEVICE_INTERFACE_MANAGED      "managed"
 #define NM_DEVICE_INTERFACE_TYPE_DESC    "type-desc"  /* Internal only */
+#define NM_DEVICE_INTERFACE_RFKILL_TYPE  "rfkill-type"  /* Internal only */
 
 typedef enum {
 	NM_DEVICE_INTERFACE_PROP_FIRST = 0x1000,
@@ -69,10 +71,12 @@ typedef enum {
 	NM_DEVICE_INTERFACE_PROP_IP4_CONFIG,
 	NM_DEVICE_INTERFACE_PROP_DHCP4_CONFIG,
 	NM_DEVICE_INTERFACE_PROP_IP6_CONFIG,
+	NM_DEVICE_INTERFACE_PROP_DHCP6_CONFIG,
 	NM_DEVICE_INTERFACE_PROP_STATE,
 	NM_DEVICE_INTERFACE_PROP_DEVICE_TYPE,
 	NM_DEVICE_INTERFACE_PROP_MANAGED,
 	NM_DEVICE_INTERFACE_PROP_TYPE_DESC,
+	NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE,
 } NMDeviceInterfaceProp;
 
 
@@ -99,6 +103,8 @@ struct _NMDeviceInterface {
 
 	void (*set_enabled) (NMDeviceInterface *device, gboolean enabled);
 
+	gboolean (*get_enabled) (NMDeviceInterface *device);
+
 	/* Signals */
 	void (*state_changed) (NMDeviceInterface *device,
 	                       NMDeviceState new_state,
@@ -133,6 +139,8 @@ NMConnection * nm_device_interface_connection_match_config (NMDeviceInterface *d
 
 gboolean nm_device_interface_can_assume_connection (NMDeviceInterface *device);
 
+gboolean nm_device_interface_get_enabled (NMDeviceInterface *device);
+
 void nm_device_interface_set_enabled (NMDeviceInterface *device, gboolean enabled);
 
 #endif /* NM_DEVICE_INTERFACE_H */
diff --git a/src/nm-device-modem.c b/src/nm-device-modem.c
new file mode 100644
index 0000000..b13ce6c
--- /dev/null
+++ b/src/nm-device-modem.c
@@ -0,0 +1,453 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
+ */
+
+#include <glib.h>
+
+#include "nm-device-modem.h"
+#include "nm-device-interface.h"
+#include "nm-modem.h"
+#include "nm-device-private.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-marshal.h"
+#include "nm-logging.h"
+
+static void device_interface_init (NMDeviceInterface *iface_class);
+
+G_DEFINE_TYPE_EXTENDED (NMDeviceModem, nm_device_modem, NM_TYPE_DEVICE, G_TYPE_FLAG_ABSTRACT,
+                        G_IMPLEMENT_INTERFACE (NM_TYPE_DEVICE_INTERFACE, device_interface_init))
+
+#define NM_DEVICE_MODEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE_MODEM, NMDeviceModemPrivate))
+
+typedef struct {
+	NMModem *modem;
+} NMDeviceModemPrivate;
+
+enum {
+	PROP_0,
+	PROP_MODEM
+};
+
+enum {
+	PPP_STATS,
+	LAST_SIGNAL
+};
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static void real_set_enabled (NMDeviceInterface *device, gboolean enabled);
+
+/*****************************************************************************/
+
+static void
+ppp_stats (NMModem *modem,
+		   guint32 in_bytes,
+		   guint32 out_bytes,
+		   gpointer user_data)
+{
+	g_signal_emit (G_OBJECT (user_data), signals[PPP_STATS], 0, in_bytes, out_bytes);
+}
+
+static void
+ppp_failed (NMModem *modem, NMDeviceStateReason reason, gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+
+	switch (nm_device_interface_get_state (NM_DEVICE_INTERFACE (device))) {
+	case NM_DEVICE_STATE_PREPARE:
+	case NM_DEVICE_STATE_CONFIG:
+	case NM_DEVICE_STATE_NEED_AUTH:
+	case NM_DEVICE_STATE_IP_CONFIG:
+	case NM_DEVICE_STATE_ACTIVATED:
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+modem_prepare_result (NMModem *modem,
+                      gboolean success,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_PREPARE);
+
+	if (success)
+		nm_device_activate_schedule_stage2_device_config (device);
+	else
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+}
+
+static void
+modem_need_auth (NMModem *modem,
+	             const char *setting_name,
+	             gboolean retry,
+	             RequestSecretsCaller caller,
+	             const char *hint1,
+	             const char *hint2,
+	             gpointer user_data)
+{
+	NMDeviceModem *self = NM_DEVICE_MODEM (user_data);
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_assert (req);
+
+	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
+	nm_act_request_get_secrets (req, setting_name, retry, caller, hint1, hint2);
+}
+
+static void
+modem_ip4_config_result (NMModem *self,
+                         const char *iface,
+                         NMIP4Config *config,
+                         GError *error,
+                         gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceState state;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	g_return_if_fail (state == NM_DEVICE_STATE_IP_CONFIG);
+
+	if (error) {
+		nm_log_warn (LOGD_MB | LOGD_IP4, "retrieving IP4 configuration failed: (%d) %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(unknown)");
+
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);
+	} else {
+		if (iface)
+			nm_device_set_ip_iface (device, iface);
+
+		nm_device_activate_schedule_stage4_ip4_config_get (device);
+	}
+}
+
+static void
+modem_enabled_cb (NMModem *modem, GParamSpec *pspec, gpointer user_data)
+{
+	NMDeviceModem *self = NM_DEVICE_MODEM (user_data);
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (self);
+
+	real_set_enabled (NM_DEVICE_INTERFACE (self), nm_modem_get_mm_enabled (priv->modem));
+}
+
+/*****************************************************************************/
+
+NMModem *
+nm_device_modem_get_modem (NMDeviceModem *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE_MODEM (self), NULL);
+
+	return NM_DEVICE_MODEM_GET_PRIVATE (self)->modem;
+}
+
+/*****************************************************************************/
+
+static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	nm_modem_device_state_changed (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem,
+	                               new_state,
+	                               old_state,
+	                               reason);
+}
+
+static guint32
+real_get_generic_capabilities (NMDevice *device)
+{
+	return NM_DEVICE_CAP_NM_SUPPORTED;
+}
+
+static NMConnection *
+real_get_best_auto_connection (NMDevice *device,
+							   GSList *connections,
+							   char **specific_object)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (device);
+
+	return nm_modem_get_best_auto_connection (priv->modem, connections, specific_object);
+}
+
+static void
+real_connection_secrets_updated (NMDevice *device,
+								 NMConnection *connection,
+								 GSList *updated_settings,
+								 RequestSecretsCaller caller)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (device);
+	NMActRequest *req;
+
+	g_return_if_fail (IS_ACTIVATING_STATE (nm_device_get_state (device)));
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	if (!nm_modem_connection_secrets_updated (priv->modem,
+                                              req,
+                                              connection,
+                                              updated_settings,
+                                              caller)) {
+		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
+		return;
+	}
+
+	/* PPP handles stuff itself... */
+	if (caller == SECRETS_CALLER_PPP)
+		return;
+
+	/* Otherwise, on success for modem secrets we need to schedule stage1 again */
+	g_return_if_fail (nm_device_get_state (device) == NM_DEVICE_STATE_NEED_AUTH);
+	nm_device_activate_schedule_stage1_device_prepare (device);
+}
+
+static gboolean
+real_check_connection_compatible (NMDevice *device,
+                                  NMConnection *connection,
+                                  GError **error)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (device);
+
+	return nm_modem_check_connection_compatible (priv->modem, connection, error);
+}
+
+static gboolean
+real_hw_is_up (NMDevice *device)
+{
+	return nm_modem_hw_is_up (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, device);
+}
+
+static gboolean
+real_hw_bring_up (NMDevice *device, gboolean *no_firmware)
+{
+	return nm_modem_hw_bring_up (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, device, no_firmware);
+}
+
+static void
+real_deactivate_quickly (NMDevice *device)
+{
+	nm_modem_deactivate_quickly (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, device);
+}
+
+static NMActStageReturn
+real_act_stage1_prepare (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	return nm_modem_act_stage1_prepare (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, req, reason);
+}
+
+static NMActStageReturn
+real_act_stage2_config (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+
+	return nm_modem_act_stage2_config (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem, req, reason);
+}
+
+static NMActStageReturn
+real_act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+{
+	return nm_modem_stage3_ip4_config_start (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem,
+	                                         device,
+	                                         NM_DEVICE_CLASS (nm_device_modem_parent_class),
+	                                         reason);
+}
+
+static NMActStageReturn
+real_act_stage4_get_ip4_config (NMDevice *device,
+                                NMIP4Config **config,
+                                NMDeviceStateReason *reason)
+{
+	return nm_modem_stage4_get_ip4_config (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem,
+	                                       device,
+	                                       NM_DEVICE_CLASS (nm_device_modem_parent_class),
+	                                       config,
+	                                       reason);
+}
+
+/*****************************************************************************/
+
+static gboolean
+real_get_enabled (NMDeviceInterface *device)
+{
+	return nm_modem_get_mm_enabled (NM_DEVICE_MODEM_GET_PRIVATE (device)->modem);
+}
+
+static void
+real_set_enabled (NMDeviceInterface *device, gboolean enabled)
+{
+	NMDeviceModem *self = NM_DEVICE_MODEM (device);
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (self);
+	NMDeviceState state;
+
+	if (priv->modem) {
+		nm_modem_set_mm_enabled (priv->modem, enabled);
+
+		if (enabled == FALSE) {
+			state = nm_device_interface_get_state (device);
+			if (state == NM_DEVICE_STATE_ACTIVATED) {
+				nm_device_state_changed (NM_DEVICE (device),
+				                         NM_DEVICE_STATE_DISCONNECTED,
+				                         NM_DEVICE_STATE_REASON_NONE);
+			}
+		}
+	}
+}
+
+/*****************************************************************************/
+
+static void
+device_interface_init (NMDeviceInterface *iface_class)
+{
+    iface_class->get_enabled = real_get_enabled;
+    iface_class->set_enabled = real_set_enabled;
+}
+
+static void
+nm_device_modem_init (NMDeviceModem *self)
+{
+	g_signal_connect (self, "state-changed", G_CALLBACK (device_state_changed), self);
+}
+
+static void
+set_modem (NMDeviceModem *self, NMModem *modem)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (self);
+
+	g_return_if_fail (modem != NULL);
+
+	priv->modem = g_object_ref (modem);
+
+	g_signal_connect (modem, NM_MODEM_PPP_STATS, G_CALLBACK (ppp_stats), self);
+	g_signal_connect (modem, NM_MODEM_PPP_FAILED, G_CALLBACK (ppp_failed), self);
+	g_signal_connect (modem, NM_MODEM_PREPARE_RESULT, G_CALLBACK (modem_prepare_result), self);
+	g_signal_connect (modem, NM_MODEM_IP4_CONFIG_RESULT, G_CALLBACK (modem_ip4_config_result), self);
+	g_signal_connect (modem, NM_MODEM_NEED_AUTH, G_CALLBACK (modem_need_auth), self);
+	g_signal_connect (modem, "notify::" NM_MODEM_ENABLED, G_CALLBACK (modem_enabled_cb), self);
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	case PROP_MODEM:
+		/* construct-only */
+		set_modem (NM_DEVICE_MODEM (object), g_value_get_object (value));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_MODEM:
+		g_value_set_object (value, priv->modem);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDeviceModemPrivate *priv = NM_DEVICE_MODEM_GET_PRIVATE (object);
+
+	g_object_unref (priv->modem);
+	priv->modem = NULL;
+
+	G_OBJECT_CLASS (nm_device_modem_parent_class)->finalize (object);
+}
+
+static void
+nm_device_modem_class_init (NMDeviceModemClass *mclass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (mclass);
+	NMDeviceClass *device_class = NM_DEVICE_CLASS (mclass);
+
+	g_type_class_add_private (object_class, sizeof (NMDeviceModemPrivate));
+
+	/* Virtual methods */
+	object_class->finalize = finalize;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+
+	device_class->get_generic_capabilities = real_get_generic_capabilities;
+	device_class->get_best_auto_connection = real_get_best_auto_connection;
+	device_class->connection_secrets_updated = real_connection_secrets_updated;
+	device_class->check_connection_compatible = real_check_connection_compatible;
+	device_class->hw_is_up = real_hw_is_up;
+	device_class->hw_bring_up = real_hw_bring_up;
+	device_class->deactivate_quickly = real_deactivate_quickly;
+	device_class->act_stage1_prepare = real_act_stage1_prepare;
+	device_class->act_stage2_config = real_act_stage2_config;
+	device_class->act_stage3_ip4_config_start = real_act_stage3_ip4_config_start;
+	device_class->act_stage4_get_ip4_config = real_act_stage4_get_ip4_config;
+
+	/* Properties */
+	g_object_class_install_property
+		(object_class, PROP_MODEM,
+		 g_param_spec_object (NM_DEVICE_MODEM_MODEM,
+		                      "Modem",
+		                      "Modem",
+		                      NM_TYPE_MODEM,
+		                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | NM_PROPERTY_PARAM_NO_EXPORT));
+
+	/* Signals */
+	signals[PPP_STATS] =
+		g_signal_new ("ppp-stats",
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  G_STRUCT_OFFSET (NMDeviceModemClass, ppp_stats),
+					  NULL, NULL,
+					  _nm_marshal_VOID__UINT_UINT,
+					  G_TYPE_NONE, 2,
+					  G_TYPE_UINT, G_TYPE_UINT);
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (mclass),
+	                                 nm_modem_get_serial_dbus_info ());
+}
+
diff --git a/src/nm-device-modem.h b/src/nm-device-modem.h
new file mode 100644
index 0000000..40e89d4
--- /dev/null
+++ b/src/nm-device-modem.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_MODEM_H
+#define NM_DEVICE_MODEM_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nm-device.h"
+#include "nm-modem.h"
+
+#define NM_TYPE_DEVICE_MODEM            (nm_device_modem_get_type ())
+#define NM_DEVICE_MODEM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_MODEM, NMDeviceModem))
+#define NM_DEVICE_MODEM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DEVICE_MODEM, NMDeviceModemClass))
+#define NM_IS_DEVICE_MODEM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_MODEM))
+#define NM_IS_DEVICE_MODEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DEVICE_MODEM))
+#define NM_DEVICE_MODEM_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DEVICE_MODEM, NMDeviceModemClass))
+
+#define NM_DEVICE_MODEM_MODEM "modem"
+
+typedef struct {
+	NMDevice parent;
+} NMDeviceModem;
+
+typedef struct {
+	NMDeviceClass parent;
+
+	void (*ppp_stats) (NMDeviceModem *self, guint32 in_bytes, guint32 out_bytes);
+} NMDeviceModemClass;
+
+GType nm_device_modem_get_type (void);
+
+/* Private for subclases */
+NMModem *nm_device_modem_get_modem (NMDeviceModem *self);
+
+#endif /* NM_DEVICE_MODEM_H */
diff --git a/src/nm-device-olpc-mesh.c b/src/nm-device-olpc-mesh.c
index 8be4632..2093a8e 100644
--- a/src/nm-device-olpc-mesh.c
+++ b/src/nm-device-olpc-mesh.c
@@ -19,7 +19,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2005 - 2008 Red Hat, Inc.
+ * (C) Copyright 2005 - 2010 Red Hat, Inc.
  * (C) Copyright 2008 Collabora Ltd.
  * (C) Copyright 2009 One Laptop per Child
  */
@@ -42,15 +42,19 @@
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
-#include "NetworkManagerPolicy.h"
 #include "nm-activation-request.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-olpc-mesh.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-manager.h"
 
+/* This is a bug; but we can't really change API now... */
+#include "NetworkManagerVPN.h"
+
+
 #include "nm-device-olpc-mesh-glue.h"
 
 static void nm_device_olpc_mesh_set_ssid (NMDeviceOlpcMesh *self, const GByteArray * ssid);
@@ -106,7 +110,7 @@ struct _NMDeviceOlpcMeshPrivate
 
 	NMDevice *        companion;
 	gboolean          stage1_waiting;
-	guint             device_added_cb;
+	guint             device_added_id;
 };
 
 static GQuark
@@ -154,7 +158,7 @@ real_get_generic_capabilities (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_warn (LOGD_OLPC_MESH, "couldn't open control socket.");
 		goto out;
 	}
 
@@ -165,13 +169,14 @@ real_get_generic_capabilities (NMDevice *dev)
 	wrq.u.data.length = sizeof (struct iw_range);
 
 	if (ioctl (fd, SIOCGIWRANGE, &wrq) < 0) {
-		nm_warning ("couldn't get driver range information.");
+		nm_log_warn (LOGD_OLPC_MESH, "couldn't get driver range information.");
 		goto out;
 	}
 
 	if ((wrq.u.data.length < 300) || (range.we_version_compiled < 16)) {
-		nm_warning ("%s: driver's Wireless Extensions version (%d) is too old.",
-		            iface, range.we_version_compiled);
+		nm_log_warn (LOGD_OLPC_MESH,
+		             "(%s): driver's Wireless Extensions version (%d) is too old.",
+		             iface, range.we_version_compiled);
 		goto out;
 	} else {
 		caps |= NM_DEVICE_CAP_NM_SUPPORTED;
@@ -257,6 +262,9 @@ constructor (GType type,
 	self = NM_DEVICE_OLPC_MESH (object);
 	priv = NM_DEVICE_OLPC_MESH_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_HW | LOGD_OLPC_MESH, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (self)), priv->ifindex);
+
 	iface = nm_device_get_iface (NM_DEVICE (self));
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0)
@@ -342,9 +350,7 @@ device_cleanup (NMDeviceOlpcMesh *self)
 static void
 real_take_down (NMDevice *dev)
 {
-	NMDeviceOlpcMesh *self = NM_DEVICE_OLPC_MESH (dev);
-
-	device_cleanup (self);
+	device_cleanup (NM_DEVICE_OLPC_MESH (dev));
 }
 
 static gboolean
@@ -403,7 +409,7 @@ create_socket_with_request (NMDevice *self, struct iwreq *req)
 
 	sk = socket (AF_INET, SOCK_DGRAM, 0);
 	if (!sk) {
-		nm_error ("Couldn't create socket: %d.", errno);
+		nm_log_err (LOGD_OLPC_MESH, "Couldn't create socket: %d.", errno);
 		return -1;
 	}
 
@@ -429,8 +435,8 @@ nm_device_olpc_mesh_get_channel (NMDeviceOlpcMesh *self)
 		return 0;
 
 	if ((ioctl (sk, SIOCGIWFREQ, &req)) != 0) {
-		nm_warning ("%s: failed to get channel (errno: %d))",
-		            nm_device_get_iface (NM_DEVICE (self)), errno);
+		nm_log_warn (LOGD_OLPC_MESH, "(%s): failed to get channel (errno: %d)",
+		             nm_device_get_iface (NM_DEVICE (self)), errno);
 		goto out;
 	}
 
@@ -468,10 +474,10 @@ nm_device_olpc_mesh_set_channel (NMDeviceOlpcMesh *self, guint32 channel)
 		req.u.freq.m = channel;
 	}
 
-	if (ioctl (sk, SIOCSIWFREQ, &req) != 0)
-		nm_warning ("%s: failed to set to channel %d (errno: %d))",
-		            nm_device_get_iface (NM_DEVICE (self)), channel, errno);
-	else
+	if (ioctl (sk, SIOCSIWFREQ, &req) != 0) {
+		nm_log_warn (LOGD_OLPC_MESH, "(%s): failed to set to channel %d (errno: %d)",
+		             nm_device_get_iface (NM_DEVICE (self)), channel, errno);
+	} else
 		g_object_notify (G_OBJECT (self), NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL);
 
 	close (sk);
@@ -491,7 +497,7 @@ nm_device_olpc_mesh_set_ssid (NMDeviceOlpcMesh *self, const GByteArray * ssid)
 
 	sk = socket (AF_INET, SOCK_DGRAM, 0);
 	if (!sk) {
-		nm_error ("Couldn't create socket: %d.", errno);
+		nm_log_err (LOGD_OLPC_MESH, "Couldn't create socket: %d.", errno);
 		return;
 	}
 
@@ -523,9 +529,10 @@ nm_device_olpc_mesh_set_ssid (NMDeviceOlpcMesh *self, const GByteArray * ssid)
 
 	if (ioctl (sk, SIOCSIWESSID, &wrq) < 0) {
 		if (errno != ENODEV) {
-			nm_warning ("error setting SSID to '%s' for device %s: %s",
+			nm_log_err (LOGD_OLPC_MESH, "(%s): error setting SSID to '%s': %s",
+			            iface,
 			            ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(null)",
-			            iface, strerror (errno));
+			            strerror (errno));
 		}
     }
 
@@ -553,7 +560,7 @@ real_update_hw_address (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		g_warning ("could not open control socket.");
+		nm_log_warn (LOGD_OLPC_MESH, "could not open control socket.");
 		return;
 	}
 
@@ -561,8 +568,8 @@ real_update_hw_address (NMDevice *dev)
 	strncpy (req.ifr_name, nm_device_get_iface (dev), IFNAMSIZ);
 	ret = ioctl (fd, SIOCGIFHWADDR, &req);
 	if (ret) {
-		nm_warning ("%s: (%s) error getting hardware address: %d",
-		            __func__, nm_device_get_iface (dev), errno);
+		nm_log_warn (LOGD_OLPC_MESH, "(%s): error getting hardware address: %d",
+		             nm_device_get_iface (dev), errno);
 		goto out;
 	}
 
@@ -584,16 +591,20 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 
 	/* disconnect companion device, if it is connected */
 	if (nm_device_get_act_request (NM_DEVICE (priv->companion))) {
-		nm_warning ("disconnecting companion device");
+		nm_log_info (LOGD_OLPC_MESH, "(%s): disconnecting companion device %s",
+		             nm_device_get_iface (dev),
+		             nm_device_get_iface (priv->companion));
+		/* FIXME: VPN stuff here is a bug; but we can't really change API now... */
 		nm_device_state_changed (NM_DEVICE (priv->companion),
 		                         NM_DEVICE_STATE_DISCONNECTED,
 		                         NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED);
-		nm_warning ("companion disconnected");
+		nm_log_info (LOGD_OLPC_MESH, "(%s): companion %s disconnected",
+		             nm_device_get_iface (dev),
+		             nm_device_get_iface (priv->companion));
 	}
 
 
-	/* wait with continuing configuration untill the companion device is done
-	 * scanning */
+	/* wait with continuing configuration untill the companion device is done scanning */
 	g_object_get (priv->companion, "scanning", &scanning, NULL);
 	if (scanning) {
 		priv->stage1_waiting = TRUE;
@@ -646,24 +657,24 @@ real_act_stage4_ip4_config_timeout (NMDevice *dev,
 
 
 static void
-nm_device_olpc_mesh_dispose (GObject *object)
+dispose (GObject *object)
 {
 	NMDeviceOlpcMesh *self = NM_DEVICE_OLPC_MESH (object);
 	NMDeviceOlpcMeshPrivate *priv = NM_DEVICE_OLPC_MESH_GET_PRIVATE (self);
+	NMManager *manager;
 
 	if (priv->dispose_has_run) {
 		G_OBJECT_CLASS (nm_device_olpc_mesh_parent_class)->dispose (object);
 		return;
 	}
-
 	priv->dispose_has_run = TRUE;
 
 	device_cleanup (self);
 
-	if (priv->device_added_cb != 0)
-		g_source_remove (priv->device_added_cb);
-
-	priv->device_added_cb = 0;
+	manager = nm_manager_get (NULL, NULL, NULL, FALSE, FALSE, FALSE, NULL);
+	if (priv->device_added_id)
+		g_signal_handler_disconnect (manager, priv->device_added_id);
+	g_object_unref (manager);
 
 	G_OBJECT_CLASS (nm_device_olpc_mesh_parent_class)->dispose (object);
 }
@@ -727,7 +738,7 @@ nm_device_olpc_mesh_class_init (NMDeviceOlpcMeshClass *klass)
 	object_class->constructor = constructor;
 	object_class->get_property = get_property;
 	object_class->set_property = set_property;
-	object_class->dispose = nm_device_olpc_mesh_dispose;
+	object_class->dispose = dispose;
 
 	parent_class->get_type_capabilities = NULL;
 	parent_class->get_generic_capabilities = real_get_generic_capabilities;
@@ -821,7 +832,9 @@ companion_state_changed_cb (NMDeviceWifi *companion,
 	    || state > NM_DEVICE_STATE_ACTIVATED)
 		return;
 
-	nm_debug ("disconnecting mesh due to companion connectivity");
+	nm_log_dbg (LOGD_OLPC_MESH, "(%s): disconnecting mesh due to companion connectivity",
+	            nm_device_get_iface (NM_DEVICE (self)));
+	/* FIXME: VPN stuff here is a bug; but we can't really change API now... */
 	nm_device_state_changed (NM_DEVICE (self),
 	                         NM_DEVICE_STATE_DISCONNECTED,
 	                         NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED);
@@ -857,6 +870,7 @@ is_companion (NMDeviceOlpcMesh *self, NMDevice *other)
 {
 	NMDeviceOlpcMeshPrivate *priv = NM_DEVICE_OLPC_MESH_GET_PRIVATE (self);
 	struct ether_addr their_addr;
+	NMManager *manager;
 
 	if (!NM_IS_DEVICE_WIFI (other))
 		return FALSE;
@@ -871,14 +885,21 @@ is_companion (NMDeviceOlpcMesh *self, NMDevice *other)
 	/* FIXME detect when our companion leaves */
 	priv->companion = other;
 
-	g_source_remove (priv->device_added_cb);
-	priv->device_added_cb = 0;
+	/* When we've found the companion, stop listening for other devices */
+	manager = nm_manager_get (NULL, NULL, NULL, FALSE, FALSE, FALSE, NULL);
+	if (priv->device_added_id) {
+		g_signal_handler_disconnect (manager, priv->device_added_id);
+		priv->device_added_id = 0;
+	}
+	g_object_unref (manager);
 
 	nm_device_state_changed (NM_DEVICE (self),
 	                         NM_DEVICE_STATE_DISCONNECTED,
 	                         NM_DEVICE_STATE_REASON_NONE);
 
-	nm_debug ("Found companion device: %s", nm_device_get_iface (other));
+	nm_log_info (LOGD_OLPC_MESH, "(%s): found companion WiFi device %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             nm_device_get_iface (other));
 
 	g_signal_connect (G_OBJECT (other), "state-changed",
 	                  G_CALLBACK (companion_state_changed_cb), self);
@@ -917,18 +938,19 @@ check_companion_cb (gpointer user_data)
 		return FALSE;
 	}
 
-	if (priv->device_added_cb != 0)
+	if (priv->device_added_id != 0)
 		return FALSE;
 
 	manager = nm_manager_get (NULL, NULL, NULL, FALSE, FALSE, FALSE, NULL);
 
-	priv->device_added_cb = g_signal_connect (manager, "device-added",
+	priv->device_added_id = g_signal_connect (manager, "device-added",
 	                                          G_CALLBACK (device_added_cb), self);
 
-	list = nm_manager_get_devices (manager);
-	for (; list != NULL ; list = list->next)
+	/* Try to find the companion if it's already known to the NMManager */
+	for (list = nm_manager_get_devices (manager); list ; list = g_slist_next (list)) {
 		if (is_companion (self, NM_DEVICE (list->data)))
 			break;
+	}
 
 	g_object_unref (manager);
 
diff --git a/src/nm-device-wifi.c b/src/nm-device-wifi.c
index e44ac96..cccaf11 100644
--- a/src/nm-device-wifi.c
+++ b/src/nm-device-wifi.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2009 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -37,9 +37,9 @@
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "NetworkManagerUtils.h"
-#include "NetworkManagerPolicy.h"
 #include "nm-activation-request.h"
 #include "nm-supplicant-manager.h"
 #include "nm-supplicant-interface.h"
@@ -51,7 +51,7 @@
 #include "nm-setting-8021x.h"
 #include "nm-setting-ip4-config.h"
 #include "nm-setting-ip6-config.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 
 static gboolean impl_device_get_access_points (NMDeviceWifi *device,
                                                GPtrArray **aps,
@@ -60,8 +60,6 @@ static gboolean impl_device_get_access_points (NMDeviceWifi *device,
 #include "nm-device-wifi-glue.h"
 
 
-/* #define IW_QUAL_DEBUG */
-
 /* All of these are in seconds */
 #define SCAN_INTERVAL_MIN 0
 #define SCAN_INTERVAL_STEP 20
@@ -183,10 +181,6 @@ struct _NMDeviceWifiPrivate {
 
 static guint32 nm_device_wifi_get_frequency (NMDeviceWifi *self);
 
-#if DEBUG
-static void nm_device_wifi_ap_list_print (NMDeviceWifi *self);
-#endif
-
 static gboolean request_wireless_scan (gpointer user_data);
 
 static void schedule_scan (NMDeviceWifi *self, gboolean backoff);
@@ -275,6 +269,7 @@ nm_device_wifi_get_ipw_rfkill_state (NMDeviceWifi *self)
 	NMDeviceWifiPrivate *priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 	char *contents = NULL;
 	RfKillState state = RFKILL_UNBLOCKED;
+	const char *str_state = NULL;
 
 	if (   priv->ipw_rfkill_path
 	    && g_file_get_contents (priv->ipw_rfkill_path, &contents, NULL, NULL)) {
@@ -288,16 +283,23 @@ nm_device_wifi_get_ipw_rfkill_state (NMDeviceWifi *self)
 		switch (contents[0]) {
 		case '1':
 			state = RFKILL_SOFT_BLOCKED;
+			str_state = "soft-blocked";
 			break;
 		case '2':
 		case '3':
 			state = RFKILL_HARD_BLOCKED;
+			str_state = "hard-blocked";
 			break;
 		case '0':
+			str_state = "unblocked";
 		default:
 			break;
 		}
 		g_free (contents);
+
+		nm_log_dbg (LOGD_RFKILL, "(%s): ipw rfkill state '%s'",
+		            nm_device_get_iface (NM_DEVICE (self)),
+		            str_state ? str_state : "(unknown)");
 	}
 
 	return state;
@@ -377,7 +379,7 @@ wireless_get_range (NMDeviceWifi *self,
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("(%s): couldn't open control socket.", iface);
+		nm_log_err (LOGD_HW, "(%s): couldn't open control socket.", iface);
 		return FALSE;
 	}
 
@@ -397,15 +399,20 @@ wireless_get_range (NMDeviceWifi *self,
 			success = TRUE;
 			break;
 		} else if (errno != EAGAIN) {
-			nm_warning ("(%s): couldn't get driver range information (%d).", iface, errno);
+			nm_log_err (LOGD_HW | LOGD_WIFI,
+			            "(%s): couldn't get driver range information (%d).",
+			            iface, errno);
 			break;
 		}
 
 		g_usleep (G_USEC_PER_SEC / 4);
 	}
 
-	if (i <= 0)
-		nm_warning ("(%s): driver took too long to respond to IWRANGE query.", iface);
+	if (i <= 0) {
+		nm_log_warn (LOGD_HW | LOGD_WIFI,
+		             "(%s): driver took too long to respond to IWRANGE query.",
+		             iface);
+	}
 
 	close (fd);
 	return success;
@@ -428,14 +435,15 @@ real_get_generic_capabilities (NMDevice *dev)
 
 	/* Check for Wireless Extensions support >= 16 for wireless devices */
 	if ((response_len < 300) || (range.we_version_compiled < 16)) {
-		nm_warning ("(%s): driver's Wireless Extensions version (%d) is too old.",
+		nm_log_err (LOGD_HW | LOGD_WIFI,
+		            "(%s): driver's Wireless Extensions version (%d) is too old.",
 					iface, range.we_version_compiled);
 		return NM_DEVICE_CAP_NONE;
 	}
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("(%s): couldn't open control socket.", iface);
+		nm_log_err (LOGD_HW, "(%s): couldn't open control socket.", iface);
 		goto out;
 	}
 
@@ -493,16 +501,16 @@ get_wireless_capabilities (NMDeviceWifi *self,
 		/* Check for cipher support but not WPA support */
 		if (    (caps & (NM_WIFI_DEVICE_CAP_CIPHER_TKIP | NM_WIFI_DEVICE_CAP_CIPHER_CCMP))
 		    && !(caps & (NM_WIFI_DEVICE_CAP_WPA | NM_WIFI_DEVICE_CAP_RSN))) {
-			nm_warning ("%s: device supports WPA ciphers but not WPA protocol; "
-			            "WPA unavailable.", iface);
+			nm_log_warn (LOGD_WIFI, "%s: device supports WPA ciphers but not WPA protocol; "
+			             "WPA unavailable.", iface);
 			caps &= ~WPA_CAPS;
 		}
 
 		/* Check for WPA support but not cipher support */
 		if (    (caps & (NM_WIFI_DEVICE_CAP_WPA | NM_WIFI_DEVICE_CAP_RSN))
 		    && !(caps & (NM_WIFI_DEVICE_CAP_CIPHER_TKIP | NM_WIFI_DEVICE_CAP_CIPHER_CCMP))) {
-			nm_warning ("%s: device supports WPA protocol but not WPA ciphers; "
-			            "WPA unavailable.", iface);
+			nm_log_warn (LOGD_WIFI, "%s: device supports WPA protocol but not WPA ciphers; "
+			             "WPA unavailable.", iface);
 			caps &= ~WPA_CAPS;
 		}
 	}
@@ -570,6 +578,9 @@ constructor (GType type,
 	self = NM_DEVICE_WIFI (object);
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_HW | LOGD_WIFI, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (self)), priv->ifindex);
+
 	memset (&range, 0, sizeof (struct iw_range));
 	success = wireless_get_range (NM_DEVICE_WIFI (object), &range, &response_len);
 	if (!success)
@@ -593,13 +604,15 @@ constructor (GType type,
 	scan_capa_range = (struct iw_range_with_scan_capa *) &range;
 	if (scan_capa_range->scan_capa & NM_IW_SCAN_CAPA_ESSID) {
 		priv->has_scan_capa_ssid = TRUE;
-		nm_info ("(%s): driver supports SSID scans (scan_capa 0x%02X).",
-		         nm_device_get_iface (NM_DEVICE (self)),
-		         scan_capa_range->scan_capa);
+		nm_log_info (LOGD_HW | LOGD_WIFI,
+		             "(%s): driver supports SSID scans (scan_capa 0x%02X).",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             scan_capa_range->scan_capa);
 	} else {
-		nm_info ("(%s): driver does not support SSID scans (scan_capa 0x%02X).",
-		         nm_device_get_iface (NM_DEVICE (self)),
-		         scan_capa_range->scan_capa);
+		nm_log_info (LOGD_HW | LOGD_WIFI,
+		             "(%s): driver does not support SSID scans (scan_capa 0x%02X).",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             scan_capa_range->scan_capa);
 	}
 
 	/* 802.11 wireless-specific capabilities */
@@ -653,7 +666,7 @@ supplicant_interface_acquire (NMDeviceWifi *self)
 	                                                          nm_device_get_iface (NM_DEVICE (self)),
 	                                                          TRUE);
 	if (priv->supplicant.iface == NULL) {
-		nm_warning ("Couldn't initialize supplicant interface for %s.",
+		nm_log_err (LOGD_WIFI, "Couldn't initialize supplicant interface for %s.",
 		            nm_device_get_iface (NM_DEVICE (self)));
 		return FALSE;
 	}
@@ -753,6 +766,8 @@ supplicant_interface_release (NMDeviceWifi *self)
 
 	/* Reset the scan interval to be pretty frequent when disconnected */
 	priv->scan_interval = SCAN_INTERVAL_MIN + SCAN_INTERVAL_STEP;
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): reset scanning interval to %d seconds",
+	            nm_device_get_iface (NM_DEVICE (self)));
 
 	remove_supplicant_interface_error_handler (self);
 
@@ -810,35 +825,30 @@ get_active_ap (NMDeviceWifi *self,
 	const GByteArray *ssid;
 	GSList *iter;
 	int i = 0;
-	gboolean ap_debug = getenv ("NM_ACTIVE_AP_DEBUG") ? TRUE : FALSE;
 
 	nm_device_wifi_get_bssid (self, &bssid);
-	if (G_UNLIKELY (ap_debug)) {
-		nm_debug ("(%s) BSSID: %02x:%02x:%02x:%02x:%02x:%02x",
-		          iface,
-		          bssid.ether_addr_octet[0], bssid.ether_addr_octet[1],
-		          bssid.ether_addr_octet[2], bssid.ether_addr_octet[3],
-		          bssid.ether_addr_octet[4], bssid.ether_addr_octet[5]);
-	}
+	nm_log_dbg (LOGD_WIFI, "(%s): active BSSID: %02x:%02x:%02x:%02x:%02x:%02x",
+	            iface,
+	            bssid.ether_addr_octet[0], bssid.ether_addr_octet[1],
+	            bssid.ether_addr_octet[2], bssid.ether_addr_octet[3],
+	            bssid.ether_addr_octet[4], bssid.ether_addr_octet[5]);
+
 	if (!nm_ethernet_address_is_valid (&bssid))
 		return NULL;
 
 	ssid = nm_device_wifi_get_ssid (self);
-	if G_UNLIKELY (ap_debug) {
-		nm_debug ("(%s) SSID: %s%s%s",
-		          iface,
-		          ssid ? "'" : "",
-		          ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)",
-		          ssid ? "'" : "");
-	}
+	nm_log_dbg (LOGD_WIFI, "(%s): active SSID: %s%s%s",
+	            iface,
+	            ssid ? "'" : "",
+	            ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)",
+	            ssid ? "'" : "");
 
 	/* When matching hidden APs, do a second pass that ignores the SSID check,
 	 * because NM might not yet know the SSID of the hidden AP in the scan list
 	 * and therefore it won't get matched the first time around.
 	 */
 	while (i++ < (match_hidden ? 2 : 1)) {
-		if G_UNLIKELY (ap_debug)
-			nm_debug ("  Pass #%d %s", i, i > 1 ? "(ignoring SSID)" : "");
+		nm_log_dbg (LOGD_WIFI, "  Pass #%d %s", i, i > 1 ? "(ignoring SSID)" : "");
 
 		/* Find this SSID + BSSID in the device's AP list */
 		for (iter = priv->ap_list; iter; iter = g_slist_next (iter)) {
@@ -848,63 +858,52 @@ get_active_ap (NMDeviceWifi *self,
 			NM80211Mode devmode, apmode;
 			guint32 devfreq, apfreq;
 
-			if G_UNLIKELY (ap_debug) {
-				nm_debug ("    AP: %s%s%s  %02x:%02x:%02x:%02x:%02x:%02x",
-				          ap_ssid ? "'" : "",
-				          ap_ssid ? nm_utils_escape_ssid (ap_ssid->data, ap_ssid->len) : "(none)",
-				          ap_ssid ? "'" : "",
-				          ap_bssid->ether_addr_octet[0], ap_bssid->ether_addr_octet[1],
-				          ap_bssid->ether_addr_octet[2], ap_bssid->ether_addr_octet[3],
-				          ap_bssid->ether_addr_octet[4], ap_bssid->ether_addr_octet[5]);
-			}
+			nm_log_dbg (LOGD_WIFI, "    AP: %s%s%s  %02x:%02x:%02x:%02x:%02x:%02x",
+			            ap_ssid ? "'" : "",
+			            ap_ssid ? nm_utils_escape_ssid (ap_ssid->data, ap_ssid->len) : "(none)",
+			            ap_ssid ? "'" : "",
+			            ap_bssid->ether_addr_octet[0], ap_bssid->ether_addr_octet[1],
+			            ap_bssid->ether_addr_octet[2], ap_bssid->ether_addr_octet[3],
+			            ap_bssid->ether_addr_octet[4], ap_bssid->ether_addr_octet[5]);
 
 			if (ignore_ap && (ap == ignore_ap)) {
-				if G_UNLIKELY (ap_debug)
-					nm_debug ("      ignored");
+				nm_log_dbg (LOGD_WIFI, "      ignored");
 				continue;
 			}
 
 			if (memcmp (bssid.ether_addr_octet, ap_bssid->ether_addr_octet, ETH_ALEN)) {
-				if G_UNLIKELY (ap_debug)
-					nm_debug ("      BSSID mismatch");
+				nm_log_dbg (LOGD_WIFI, "      BSSID mismatch");
 				continue;
 			}
 
 			if ((i == 0) && !nm_utils_same_ssid (ssid, ap_ssid, TRUE)) {
-				if G_UNLIKELY (ap_debug)
-					nm_debug ("      SSID mismatch");
+				nm_log_dbg (LOGD_WIFI, "      SSID mismatch");
 				continue;
 			}
 
 			devmode = nm_device_wifi_get_mode (self);
 			apmode = nm_ap_get_mode (ap);
 			if (devmode != apmode) {
-				if G_UNLIKELY (ap_debug) {
-					nm_debug ("      mode mismatch (device %d, ap %d)",
-					          devmode, apmode);
-				}
+				nm_log_dbg (LOGD_WIFI, "      mode mismatch (device %d, ap %d)",
+				            devmode, apmode);
 				continue;
 			}
 
 			devfreq = nm_device_wifi_get_frequency (self);
 			apfreq = nm_ap_get_freq (ap);
 			if (devfreq != apfreq) {
-				if G_UNLIKELY (ap_debug) {
-					nm_debug ("      frequency mismatch (device %u, ap %u)",
-					          devfreq, apfreq);
-				}
+				nm_log_dbg (LOGD_WIFI, "      frequency mismatch (device %u, ap %u)",
+				            devfreq, apfreq);
 				continue;
 			}
 
 			// FIXME: handle security settings here too
-			if G_UNLIKELY (ap_debug)
-				nm_debug ("      matched");
+			nm_log_dbg (LOGD_WIFI, "      matched");
 			return ap;
 		}
 	}
 
-	if G_UNLIKELY (ap_debug)
-		nm_debug ("  No matching AP found.");
+	nm_log_dbg (LOGD_WIFI, "  No matching AP found.");
 	return NULL;
 }
 
@@ -997,11 +996,12 @@ periodic_update (NMDeviceWifi *self)
 			old_ssid = nm_ap_get_ssid (priv->current_ap);
 		}
 
-		nm_debug ("Roamed from BSSID %s (%s) to %s (%s)",
-		          old_addr ? old_addr : "(none)",
-		          old_ssid ? nm_utils_escape_ssid (old_ssid->data, old_ssid->len) : "(none)",
-		          new_addr ? new_addr : "(none)",
-		          new_ssid ? nm_utils_escape_ssid (new_ssid->data, new_ssid->len) : "(none)");
+		nm_log_info (LOGD_WIFI, "(%s): roamed from BSSID %s (%s) to %s (%s)",
+		             nm_device_get_iface (NM_DEVICE (self)),
+		             old_addr ? old_addr : "(none)",
+		             old_ssid ? nm_utils_escape_ssid (old_ssid->data, old_ssid->len) : "(none)",
+		             new_addr ? new_addr : "(none)",
+		             new_ssid ? nm_utils_escape_ssid (new_ssid->data, new_ssid->len) : "(none)");
 		g_free (old_addr);
 		g_free (new_addr);
 
@@ -1211,16 +1211,25 @@ real_is_available (NMDevice *dev)
 	NMSupplicantInterface *sup_iface;
 	guint32 state;
 
-	if (!priv->enabled)
+	if (!priv->enabled) {
+		nm_log_dbg (LOGD_WIFI, "(%s): not available because not enabled",
+		            nm_device_get_iface (dev));
 		return FALSE;
+	}
 
 	sup_iface = priv->supplicant.iface;
-	if (!sup_iface)
+	if (!sup_iface) {
+		nm_log_dbg (LOGD_WIFI, "(%s): not available because supplicant not running",
+		            nm_device_get_iface (dev));
 		return FALSE;
+	}
 
 	state = nm_supplicant_interface_get_state (sup_iface);
-	if (state != NM_SUPPLICANT_INTERFACE_STATE_READY)
+	if (state != NM_SUPPLICANT_INTERFACE_STATE_READY) {
+		nm_log_dbg (LOGD_WIFI, "(%s): not available because supplicant interface not ready",
+		            nm_device_get_iface (dev));
 		return FALSE;
+	}
 
 	return TRUE;
 }
@@ -1298,7 +1307,6 @@ nm_device_wifi_get_address (NMDeviceWifi *self,
 	memcpy (addr, &(priv->hw_addr), sizeof (struct ether_addr));
 }
 
-#if DEBUG
 static void
 nm_device_wifi_ap_list_print (NMDeviceWifi *self)
 {
@@ -1308,14 +1316,13 @@ nm_device_wifi_ap_list_print (NMDeviceWifi *self)
 
 	g_return_if_fail (NM_IS_DEVICE_WIFI (self));
 
-	nm_info ("AP_LIST_PRINT:");
+	nm_log_dbg (LOGD_WIFI_SCAN, "Current AP list:");
 	for (elt = priv->ap_list; elt; elt = g_slist_next (elt), i++) {
 		NMAccessPoint * ap = NM_AP (elt->data);
-		nm_ap_print_self (ap, "::\t");
+		nm_ap_print_self (ap, "AP: ");
 	}
-	nm_info ("AP_LIST_PRINT: done");
+	nm_log_dbg (LOGD_WIFI_SCAN, "Current AP list: done");
 }
-#endif
 
 static gboolean
 impl_device_get_access_points (NMDeviceWifi *self,
@@ -1372,8 +1379,11 @@ nm_device_wifi_get_mode (NMDeviceWifi *self)
 			break;
 		}
 	} else {
-		if (errno != ENODEV)
-			nm_warning ("error getting card mode on %s: %s", iface, strerror (errno));
+		if (errno != ENODEV) {
+			nm_log_warn (LOGD_HW | LOGD_WIFI,
+			             "(%s): error %d getting card mode",
+			             iface, strerror (errno));
+		}
 	}
 	close (fd);
 
@@ -1423,7 +1433,8 @@ nm_device_wifi_set_mode (NMDeviceWifi *self, const NM80211Mode mode)
 
 	if (ioctl (fd, SIOCSIWMODE, &wrq) < 0) {
 		if (errno != ENODEV) {
-			nm_warning ("error setting card %s to mode %d: %s",
+			nm_log_err (LOGD_HW | LOGD_WIFI,
+			            "(%s): error setting mode %d",
 			            iface, mode, strerror (errno));
 		}
 	} else
@@ -1459,9 +1470,11 @@ nm_device_wifi_get_frequency (NMDeviceWifi *self)
 	iface = nm_device_get_iface (NM_DEVICE (self));
 	strncpy (wrq.ifr_name, iface, IFNAMSIZ);
 
-	if (ioctl (fd, SIOCGIWFREQ, &wrq) < 0)
-		nm_warning ("(%s): error getting frequency: %s", iface, strerror (errno));
-	else
+	if (ioctl (fd, SIOCGIWFREQ, &wrq) < 0) {
+		nm_log_warn (LOGD_HW | LOGD_WIFI,
+		             "(%s): error getting frequency: %s",
+		             iface, strerror (errno));
+	} else
 		freq = iw_freq_to_uint32 (&wrq.u.freq);
 
 	close (fd);
@@ -1485,17 +1498,16 @@ wireless_qual_to_percent (const struct iw_quality *qual,
 	g_return_val_if_fail (qual != NULL, -1);
 	g_return_val_if_fail (max_qual != NULL, -1);
 
-#ifdef IW_QUAL_DEBUG
-nm_debug ("QL: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X  ** MAX: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X",
-(__s8)qual->qual, qual->qual, qual->qual,
-(__s8)qual->level, qual->level, qual->level,
-(__s8)qual->noise, qual->noise, qual->noise,
-qual->updated,
-(__s8)max_qual->qual, max_qual->qual, max_qual->qual,
-(__s8)max_qual->level, max_qual->level, max_qual->level,
-(__s8)max_qual->noise, max_qual->noise, max_qual->noise,
-max_qual->updated);
-#endif
+	nm_log_dbg (LOGD_WIFI,
+	            "QL: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X  ** MAX: qual %d/%u/0x%X, level %d/%u/0x%X, noise %d/%u/0x%X, updated: 0x%X",
+	            (__s8) qual->qual, qual->qual, qual->qual,
+	            (__s8) qual->level, qual->level, qual->level,
+	            (__s8) qual->noise, qual->noise, qual->noise,
+	            qual->updated,
+	            (__s8) max_qual->qual, max_qual->qual, max_qual->qual,
+	            (__s8) max_qual->level, max_qual->level, max_qual->level,
+	            (__s8) max_qual->noise, max_qual->noise, max_qual->noise,
+	            max_qual->updated);
 
 	/* Try using the card's idea of the signal quality first as long as it tells us what the max quality is.
 	 * Drivers that fill in quality values MUST treat them as percentages, ie the "Link Quality" MUST be 
@@ -1520,8 +1532,7 @@ max_qual->updated);
 		&& !(qual->updated & IW_QUAL_LEVEL_INVALID)                                     /* Must have valid qual->level */
 		&& (    ((max_qual->noise > 0) && !(max_qual->updated & IW_QUAL_NOISE_INVALID)) /* Must have valid max_qual->noise */
 			|| ((qual->noise > 0) && !(qual->updated & IW_QUAL_NOISE_INVALID)))     /*    OR valid qual->noise */
-	   )
-	{
+	   ) {
 		/* Absolute power values (dBm) */
 
 		/* Reasonable fallbacks for dumb drivers that don't specify either level. */
@@ -1543,9 +1554,8 @@ max_qual->updated);
 		level_percent = (int)(100 - 70 *(
 		                                ((double)max_level - (double)level) /
 		                                ((double)max_level - (double)noise)));
-#ifdef IW_QUAL_DEBUG
-		nm_debug ("QL1: level_percent is %d.  max_level %d, level %d, noise_floor %d.", level_percent, max_level, level, noise);
-#endif
+		nm_log_dbg (LOGD_WIFI, "QL1: level_percent is %d.  max_level %d, level %d, noise_floor %d.",
+		            level_percent, max_level, level, noise);
 	} else if (   (max_qual->level != 0)
 	           && !(max_qual->updated & IW_QUAL_LEVEL_INVALID) /* Valid max_qual->level as upper bound */
 	           && !(qual->updated & IW_QUAL_LEVEL_INVALID)) {
@@ -1556,24 +1566,18 @@ max_qual->updated);
 		/* Signal level is relavtive (0 -> max_qual->level) */
 		level = CLAMP (level, 0, max_qual->level);
 		level_percent = (int)(100 * ((double)level / (double)max_qual->level));
-#ifdef IW_QUAL_DEBUG
-		nm_debug ("QL2: level_percent is %d.  max_level %d, level %d.", level_percent, max_qual->level, level);
-#endif
-	}
-	else if (percent == -1)
-	{
-#ifdef IW_QUAL_DEBUG
-		nm_debug ("QL: Could not get quality %% value from driver.  Driver is probably buggy.");
-#endif
+		nm_log_dbg (LOGD_WIFI, "QL2: level_percent is %d.  max_level %d, level %d.",
+		            level_percent, max_qual->level, level);
+	} else if (percent == -1) {
+		nm_log_dbg (LOGD_WIFI, "QL: Could not get quality %% value from driver.  Driver is probably buggy.");
 	}
 
 	/* If the quality percent was 0 or doesn't exist, then try to use signal levels instead */
 	if ((percent < 1) && (level_percent >= 0))
 		percent = level_percent;
 
-#ifdef IW_QUAL_DEBUG
-	nm_debug ("QL: Final quality percent is %d (%d).", percent, CLAMP (percent, 0, 100));
-#endif
+	nm_log_dbg (LOGD_WIFI, "QL: Final quality percent is %d (%d).",
+	            percent, CLAMP (percent, 0, 100));
 	return (CLAMP (percent, 0, 100));
 }
 
@@ -1598,7 +1602,7 @@ nm_device_wifi_get_ssid (NMDeviceWifi *self)
 
 	sk = socket (AF_INET, SOCK_DGRAM, 0);
 	if (!sk) {
-		nm_error ("Couldn't create socket: %d.", errno);
+		nm_log_err (LOGD_HW, "couldn't create socket: %d.", errno);
 		return NULL;
 	}
 
@@ -1609,7 +1613,8 @@ nm_device_wifi_get_ssid (NMDeviceWifi *self)
 	strncpy (wrq.ifr_name, nm_device_get_iface (NM_DEVICE (self)), IFNAMSIZ);
 
 	if (ioctl (sk, SIOCGIWESSID, &wrq) < 0) {
-		nm_warning ("Couldn't get SSID: %d", errno);
+		nm_log_err (LOGD_HW | LOGD_WIFI, "(%s): couldn't get SSID: %d",
+		            nm_device_get_iface (NM_DEVICE (self)), errno);
 		goto out;
 	}
 
@@ -1684,7 +1689,7 @@ nm_device_wifi_get_bssid (NMDeviceWifi *self,
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		g_warning ("failed to open control socket.");
+		nm_log_err (LOGD_WIFI, "failed to open control socket.");
 		return;
 	}
 
@@ -1791,10 +1796,16 @@ request_wireless_scan (gpointer user_data)
 	gboolean backoff = FALSE;
 
 	if (check_scanning_allowed (self)) {
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scanning requested",
+		            nm_device_get_iface (NM_DEVICE (self)));
+
 		if (nm_supplicant_interface_request_scan (priv->supplicant.iface)) {
 			/* success */
 			backoff = TRUE;
 		}
+	} else {
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scan requested but not allowed at this time",
+		            nm_device_get_iface (NM_DEVICE (self)));
 	}
 
 	priv->pending_scan_id = 0;
@@ -1824,13 +1835,13 @@ schedule_scan (NMDeviceWifi *self, gboolean backoff)
 	}
 
 	if (!priv->pending_scan_id) {
-		guint factor = 2;
+		guint factor = 2, next_scan = priv->scan_interval;
 
 		if (    nm_device_is_activating (NM_DEVICE (self))
 		    || (nm_device_get_state (NM_DEVICE (self)) == NM_DEVICE_STATE_ACTIVATED))
 			factor = 1;
 
-		priv->pending_scan_id = g_timeout_add_seconds (priv->scan_interval,
+		priv->pending_scan_id = g_timeout_add_seconds (next_scan,
 		                                               request_wireless_scan,
 		                                               self);
 
@@ -1847,6 +1858,12 @@ schedule_scan (NMDeviceWifi *self, gboolean backoff)
 			 */
 			priv->scan_interval = 5;
 		}
+
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scheduled scan in %d seconds (interval now %d seconds)",
+		            nm_device_get_iface (NM_DEVICE (self)),
+		            next_scan,
+		            priv->scan_interval);
+
 	}
 }
 
@@ -1868,6 +1885,10 @@ supplicant_iface_scan_request_result_cb (NMSupplicantInterface *iface,
                                          gboolean success,
                                          NMDeviceWifi *self)
 {
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scan request %s",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            success ? "successful" : "failed");
+
 	if (check_scanning_allowed (self))
 		schedule_scan (self, TRUE);
 }
@@ -1877,11 +1898,15 @@ supplicant_iface_scan_results_cb (NMSupplicantInterface *iface,
                                   guint32 num_results,
                                   NMDeviceWifi *self)
 {
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): scan results available (%d APs found)",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            num_results);
 	if (num_results == 0) {
 		/* ensure that old APs get culled, which otherwise only
 		 * happens when there are actual scan results to process.
 		 */
 		cull_scan_list (self);
+		nm_device_wifi_ap_list_print (self);
 	}
 }
 
@@ -2035,11 +2060,12 @@ static void
 cull_scan_list (NMDeviceWifi *self)
 {
 	NMDeviceWifiPrivate *priv;
-	GTimeVal        cur_time;
-	GSList *        outdated_list = NULL;
-	GSList *        elt;
-	NMActRequest *  req;
-	const char *    cur_ap_path = NULL;
+	GTimeVal cur_time;
+	GSList *outdated_list = NULL;
+	GSList *elt;
+	NMActRequest *req;
+	const char *cur_ap_path = NULL;
+	guint32 removed = 0, total = 0;
 
 	g_return_if_fail (self != NULL);
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
@@ -2050,10 +2076,13 @@ cull_scan_list (NMDeviceWifi *self)
 	if (req)
 		cur_ap_path = nm_act_request_get_specific_object (req);
 
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): checking scan list for outdated APs",
+	            nm_device_get_iface (NM_DEVICE (self)));
+
 	/* Walk the access point list and remove any access points older than
 	 * three times the inactive scan interval.
 	 */
-	for (elt = priv->ap_list; elt; elt = g_slist_next (elt)) {
+	for (elt = priv->ap_list; elt; elt = g_slist_next (elt), total++) {
 		NMAccessPoint * ap = NM_AP (elt->data);
 		const glong     ap_time = nm_ap_get_last_seen (ap);
 		gboolean        keep = FALSE;
@@ -2071,13 +2100,31 @@ cull_scan_list (NMDeviceWifi *self)
 
 	/* Remove outdated APs */
 	for (elt = outdated_list; elt; elt = g_slist_next (elt)) {
-		NMAccessPoint * outdated_ap = NM_AP (elt->data);
+		NMAccessPoint *outdated_ap = NM_AP (elt->data);
+		const struct ether_addr *bssid;
+		const GByteArray *ssid;
+
+		bssid = nm_ap_get_address (outdated_ap);
+		ssid = nm_ap_get_ssid (outdated_ap);
+		nm_log_dbg (LOGD_WIFI_SCAN,
+		            "   removing %02x:%02x:%02x:%02x:%02x:%02x (%s%s%s)",
+		            bssid->ether_addr_octet[0], bssid->ether_addr_octet[1],
+		            bssid->ether_addr_octet[2], bssid->ether_addr_octet[3],
+		            bssid->ether_addr_octet[4], bssid->ether_addr_octet[5],
+		            ssid ? "'" : "",
+		            ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)",
+		            ssid ? "'" : "");
 
 		access_point_removed (self, outdated_ap);
 		priv->ap_list = g_slist_remove (priv->ap_list, outdated_ap);
 		g_object_unref (outdated_ap);
+		removed++;
 	}
 	g_slist_free (outdated_list);
+
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): removed %d APs (of %d)",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            removed, total);
 }
 
 #define SET_QUALITY_MEMBER(qual_item, lc_member, uc_member) \
@@ -2136,18 +2183,23 @@ supplicant_iface_scanned_ap_cb (NMSupplicantInterface *iface,
 		return;
 
 	ap = nm_ap_new_from_properties (properties);
-	if (!ap)
-		return;
+	if (ap) {
+		set_ap_strength_from_properties (self, ap, properties);
 
-	set_ap_strength_from_properties (self, ap, properties);
+		nm_ap_print_self (ap, "AP: ");
 
-	/* Add the AP to the device's AP list */
-	merge_scanned_ap (self, ap);
+		/* Add the AP to the device's AP list */
+		merge_scanned_ap (self, ap);
+		g_object_unref (ap);
 
-	/* Remove outdated access points */
-	cull_scan_list (self);
+		/* Remove outdated access points */
+		cull_scan_list (self);
 
-	g_object_unref (ap);
+		nm_device_wifi_ap_list_print (self);
+	} else {
+		nm_log_warn (LOGD_WIFI_SCAN, "(%s): invalid AP properties received",
+		             nm_device_get_iface (NM_DEVICE (self)));
+	}
 }
 
 
@@ -2204,7 +2256,7 @@ link_timeout_cb (gpointer user_data)
 	ap = nm_device_wifi_get_activation_ap (self);
 	if (req == NULL || ap == NULL) {
 		/* shouldn't ever happen */
-		nm_warning ("couldn't get activation request or activation AP.");
+		nm_log_err (LOGD_WIFI, "couldn't get activation request or activation AP.");
 		if (nm_device_is_activating (dev)) {
 			cleanup_association_attempt (self, TRUE);
 			nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NONE);
@@ -2251,8 +2303,9 @@ link_timeout_cb (gpointer user_data)
 		 * bad encryption key and the authenticating entity (AP, RADIUS server, etc)
 		 * denied the association due to bad credentials.
 		 */
-		nm_info ("Activation (%s/wireless): disconnected during association,"
-		         " asking for new key.", nm_device_get_iface (dev));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): disconnected during association,"
+		             " asking for new key.", nm_device_get_iface (dev));
 		cleanup_association_attempt (self, TRUE);
 		nm_device_state_changed (dev, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
 		nm_act_request_get_secrets (req,
@@ -2266,7 +2319,7 @@ link_timeout_cb (gpointer user_data)
 	}
 
 time_out:
-	nm_info ("%s: link timed out.", nm_device_get_iface (dev));
+	nm_log_warn (LOGD_WIFI, "(%s): link timed out.", nm_device_get_iface (dev));
 	return FALSE;
 }
 
@@ -2290,7 +2343,7 @@ schedule_state_handler (NMDeviceWifi *self,
 
 	task = g_slice_new0 (SupplicantStateTask);
 	if (!task) {
-		nm_warning ("Not enough memory to process supplicant manager state change.");
+		nm_log_err (LOGD_WIFI, "Not enough memory to process supplicant manager state change.");
 		return FALSE;
 	}
 
@@ -2320,10 +2373,10 @@ supplicant_iface_state_cb_handler (gpointer user_data)
 	self = task->self;
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 
-	nm_info ("(%s): supplicant interface state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         nm_supplicant_interface_state_to_string (task->old_state),
-	         nm_supplicant_interface_state_to_string (task->new_state));
+	nm_log_info (LOGD_WIFI, "(%s): supplicant interface state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             nm_supplicant_interface_state_to_string (task->old_state),
+	             nm_supplicant_interface_state_to_string (task->new_state));
 
 	if (task->new_state == NM_SUPPLICANT_INTERFACE_STATE_READY) {
 		priv->scan_interval = SCAN_INTERVAL_MIN;
@@ -2337,6 +2390,9 @@ supplicant_iface_state_cb_handler (gpointer user_data)
 			                         NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE);
 		}
 
+		nm_log_dbg (LOGD_WIFI_SCAN, "(%s): supplicant ready, requesting initial scan",
+		            nm_device_get_iface (NM_DEVICE (self)));
+
 		/* Request a scan to get latest results */
 		cancel_pending_scan (self);
 		request_wireless_scan (self);
@@ -2382,10 +2438,10 @@ supplicant_iface_connection_state_cb_handler (gpointer user_data)
 		goto out;
 	}
 
-	nm_info ("(%s): supplicant connection state:  %s -> %s",
-	         nm_device_get_iface (dev),
-	         nm_supplicant_interface_connection_state_to_string (task->old_state),
-	         nm_supplicant_interface_connection_state_to_string (task->new_state));
+	nm_log_info (LOGD_WIFI, "(%s): supplicant connection state:  %s -> %s",
+	             nm_device_get_iface (dev),
+	             nm_supplicant_interface_connection_state_to_string (task->old_state),
+	             nm_supplicant_interface_connection_state_to_string (task->new_state));
 
 	scanning = nm_supplicant_interface_get_scanning (priv->supplicant.iface);
 
@@ -2400,10 +2456,11 @@ supplicant_iface_connection_state_cb_handler (gpointer user_data)
 			NMAccessPoint *ap = nm_device_wifi_get_activation_ap (self);
 			const GByteArray * ssid = nm_ap_get_ssid (ap);
 
-			nm_info ("Activation (%s/wireless) Stage 2 of 5 (Device Configure) "
-			         "successful.  Connected to wireless network '%s'.",
-			         nm_device_get_iface (dev),
-			         ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
+			nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+			             "Activation (%s/wireless) Stage 2 of 5 (Device Configure) "
+			             "successful.  Connected to wireless network '%s'.",
+			             nm_device_get_iface (dev),
+			             ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
 			nm_device_activate_schedule_stage3_ip_config_start (dev);
 		}
 	} else if (task->new_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED) {
@@ -2456,10 +2513,10 @@ supplicant_mgr_state_cb_handler (gpointer user_data)
 	priv = NM_DEVICE_WIFI_GET_PRIVATE (self);
 	dev = NM_DEVICE (self);
 
-	nm_info ("(%s): supplicant manager state:  %s -> %s",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         nm_supplicant_manager_state_to_string (task->old_state),
-	         nm_supplicant_manager_state_to_string (task->new_state));
+	nm_log_info (LOGD_WIFI, "(%s): supplicant manager state:  %s -> %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             nm_supplicant_manager_state_to_string (task->old_state),
+	             nm_supplicant_manager_state_to_string (task->new_state));
 
 	/* If the supplicant went away, release the supplicant interface */
 	if (task->new_state == NM_SUPPLICANT_MANAGER_STATE_DOWN) {
@@ -2530,11 +2587,12 @@ supplicant_iface_connection_error_cb_handler (gpointer user_data)
 	if (!nm_device_is_activating (NM_DEVICE (self)))
 		goto out;
 
-	nm_info ("Activation (%s/wireless): association request to the supplicant "
-	         "failed: %s - %s",
-	         nm_device_get_iface (NM_DEVICE (self)),
-	         cb_data->name,
-	         cb_data->message);
+	nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+	             "Activation (%s/wireless): association request to the supplicant "
+	             "failed: %s - %s",
+	             nm_device_get_iface (NM_DEVICE (self)),
+	             cb_data->name,
+	             cb_data->message);
 
 	cleanup_association_attempt (self, TRUE);
 	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED);
@@ -2563,7 +2621,7 @@ supplicant_iface_connection_error_cb (NMSupplicantInterface * iface,
 
 	cb_data = g_slice_new0 (struct iface_con_error_cb_data);
 	if (cb_data == NULL) {
-		nm_warning ("Not enough memory to process supplicant connection error.");
+		nm_log_err (LOGD_WIFI, "Not enough memory to process supplicant connection error.");
 		return;
 	}
 
@@ -2579,10 +2637,17 @@ supplicant_iface_connection_error_cb (NMSupplicantInterface * iface,
 }
 
 static void
-supplicant_iface_notify_scanning_cb (NMSupplicantInterface * iface,
-                                     GParamSpec * pspec,
-                                     NMDeviceWifi * self)
+supplicant_iface_notify_scanning_cb (NMSupplicantInterface *iface,
+                                     GParamSpec *pspec,
+                                     NMDeviceWifi *self)
 {
+	gboolean scanning;
+
+	scanning = nm_supplicant_interface_get_scanning (iface);
+	nm_log_dbg (LOGD_WIFI_SCAN, "(%s): now %s",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            scanning ? "scanning" : "not scanning");
+
 	g_object_notify (G_OBJECT (self), "scanning");
 }
 
@@ -2644,7 +2709,7 @@ handle_auth_or_fail (NMDeviceWifi *self,
 
 		g_object_set_data (G_OBJECT (connection), WIRELESS_SECRETS_TRIES, GUINT_TO_POINTER (++tries));
 	} else {
-		nm_warning ("Cleared secrets, but setting didn't need any secrets.");
+		nm_log_warn (LOGD_DEVICE, "Cleared secrets, but setting didn't need any secrets.");
 	}
 	return NM_ACT_STAGE_RETURN_POSTPONE;
 }
@@ -2687,19 +2752,22 @@ supplicant_connection_timeout_cb (gpointer user_data)
 
 	auth_enforced = ap_auth_enforced (connection, ap, &encrypted);
 	if (!encrypted) {
-		nm_info ("Activation (%s/wireless): association took too long, "
-		         "failing activation.",
-		         nm_device_get_iface (dev));
+		nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): association took too long, "
+		             "failing activation.",
+		             nm_device_get_iface (dev));
 		nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED,
 		                         NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT);
 	} else {
 		/* Authentication failed, encryption key is probably bad */
-		nm_info ("Activation (%s/wireless): association took too long.",
-		         nm_device_get_iface (dev));
+		nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): association took too long.",
+		             nm_device_get_iface (dev));
 
 		if (handle_auth_or_fail (self, req, TRUE) == NM_ACT_STAGE_RETURN_POSTPONE) {
-			nm_info ("Activation (%s/wireless): asking for new secrets",
-			         nm_device_get_iface (dev));
+			nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+			             "Activation (%s/wireless): asking for new secrets",
+			             nm_device_get_iface (dev));
 		} else {
 			nm_device_state_changed (dev, NM_DEVICE_STATE_FAILED,
 			                         NM_DEVICE_STATE_REASON_NO_SECRETS);
@@ -2722,8 +2790,9 @@ start_supplicant_connection_timeout (NMDeviceWifi *self)
 
 	/* Set up a timeout on the connection attempt to fail it after 25 seconds */
 	id = g_timeout_add_seconds (25, supplicant_connection_timeout_cb, self);
-	if (id <= 0) {
-		nm_warning ("Activation (%s/wireless): couldn't start supplicant "
+	if (id == 0) {
+		nm_log_err (LOGD_DEVICE | LOGD_WIFI,
+		            "Activation (%s/wireless): couldn't start supplicant "
 		            "timeout timer.",
 		            nm_device_get_iface (NM_DEVICE (self)));
 		return FALSE;
@@ -2809,7 +2878,7 @@ build_supplicant_config (NMDeviceWifi *self,
 	                                                nm_ap_get_broadcast (ap),
 	                                                adhoc_freq,
 	                                                priv->has_scan_capa_ssid)) {
-		nm_warning ("Couldn't add 802-11-wireless setting to supplicant config.");
+		nm_log_err (LOGD_WIFI, "Couldn't add 802-11-wireless setting to supplicant config.");
 		goto error;
 	}
 
@@ -2824,13 +2893,13 @@ build_supplicant_config (NMDeviceWifi *self,
 		                                                         s_wireless_sec,
 		                                                         s_8021x,
 		                                                         con_path)) {
-			nm_warning ("Couldn't add 802-11-wireless-security setting to "
+			nm_log_err (LOGD_WIFI, "Couldn't add 802-11-wireless-security setting to "
 			            "supplicant config.");
 			goto error;
 		}
 	} else {
 		if (!nm_supplicant_config_add_no_security (config)) {
-			nm_warning ("Couldn't add unsecured option to supplicant config.");
+			nm_log_err (LOGD_WIFI, "Couldn't add unsecured option to supplicant config.");
 			goto error;
 		}
 	}
@@ -2854,15 +2923,15 @@ real_update_hw_address (NMDevice *dev)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		g_warning ("could not open control socket.");
+		nm_log_err (LOGD_HW, "could not open control socket.");
 		return;
 	}
 
 	memset (&req, 0, sizeof (struct ifreq));
 	strncpy (req.ifr_name, nm_device_get_iface (dev), IFNAMSIZ);
 	if (ioctl (fd, SIOCGIFHWADDR, &req) < 0) {
-		nm_warning ("%s: (%s) error getting hardware address: %d",
-		            __func__, nm_device_get_iface (dev), errno);
+		nm_log_err (LOGD_HW | LOGD_WIFI, "(%s) error getting hardware address: %d",
+		            nm_device_get_iface (dev), errno);
 		goto out;
 	}
 
@@ -2963,7 +3032,8 @@ real_connection_secrets_updated (NMDevice *dev,
 		    || !strcmp (setting_name, NM_SETTING_802_1X_SETTING_NAME)) {
 			valid = TRUE;
 		} else {
-			nm_warning ("Ignoring updated secrets for setting '%s'.", setting_name);
+			nm_log_warn (LOGD_DEVICE, "Ignoring updated secrets for setting '%s'.",
+			             setting_name);
 		}
 	}
 
@@ -3013,9 +3083,10 @@ real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 	/* If we need secrets, get them */
 	setting_name = nm_connection_need_secrets (connection, NULL);
 	if (setting_name) {
-		nm_info ("Activation (%s/wireless): access point '%s' has security,"
-		         " but secrets are required.",
-		         iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): access point '%s' has security,"
+		             " but secrets are required.",
+		             iface, nm_setting_connection_get_id (s_connection));
 
 		ret = handle_auth_or_fail (self, req, FALSE);
 		if (ret == NM_ACT_STAGE_RETURN_FAILURE)
@@ -3025,19 +3096,22 @@ real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 
 	/* have secrets, or no secrets required */
 	if (nm_setting_wireless_get_security (s_wireless)) {
-		nm_info ("Activation (%s/wireless): connection '%s' has security"
-		         ", and secrets exist.  No new secrets needed.",
-		         iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): connection '%s' has security"
+		             ", and secrets exist.  No new secrets needed.",
+		             iface, nm_setting_connection_get_id (s_connection));
 	} else {
-		nm_info ("Activation (%s/wireless): connection '%s' requires no "
-		         "security.  No secrets needed.",
-		         iface, nm_setting_connection_get_id (s_connection));
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): connection '%s' requires no "
+		             "security.  No secrets needed.",
+		             iface, nm_setting_connection_get_id (s_connection));
 	}
 
 	config = build_supplicant_config (self, connection, ap);
 	if (config == NULL) {
-		nm_warning ("Activation (%s/wireless): couldn't build wireless "
-			"configuration.", iface);
+		nm_log_err (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): couldn't build wireless configuration.",
+		             iface);
 		*reason = NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED;
 		goto out;
 	}
@@ -3050,8 +3124,9 @@ real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 	priv->supplicant.iface_error_id = id;
 
 	if (!nm_supplicant_interface_set_config (priv->supplicant.iface, config)) {
-		nm_warning ("Activation (%s/wireless): couldn't send wireless "
-			"configuration to the supplicant.", iface);
+		nm_log_err (LOGD_DEVICE | LOGD_WIFI,
+		            "Activation (%s/wireless): couldn't send wireless "
+		            "configuration to the supplicant.", iface);
 		*reason = NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED;
 		goto out;
 	}
@@ -3143,14 +3218,16 @@ real_act_stage4_ip4_config_timeout (NMDevice *dev,
 		s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
 
 		/* Activation failed, we must have bad encryption key */
-		nm_info ("Activation (%s/wireless): could not get IP configuration for "
-		          "connection '%s'.",
-				 nm_device_get_iface (dev), nm_setting_connection_get_id (s_con));
+		nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): could not get IP configuration for "
+		             "connection '%s'.",
+				     nm_device_get_iface (dev), nm_setting_connection_get_id (s_con));
 
 		ret = handle_auth_or_fail (self, req, TRUE);
 		if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
-			nm_info ("Activation (%s/wireless): asking for new secrets",
-			         nm_device_get_iface (dev));
+			nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+			             "Activation (%s/wireless): asking for new secrets",
+			             nm_device_get_iface (dev));
 		} else {
 			*reason = NM_DEVICE_STATE_REASON_NO_SECRETS;
 		}
@@ -3277,9 +3354,10 @@ activation_failure_handler (NMDevice *dev)
 	}
 
 	ssid = nm_ap_get_ssid (ap);
-	nm_info ("Activation (%s) failed for access point (%s)",
-	         nm_device_get_iface (dev),
-	         ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
+	nm_log_warn (LOGD_DEVICE | LOGD_WIFI,
+	             "Activation (%s) failed for access point (%s)",
+	             nm_device_get_iface (dev),
+	             ssid ? nm_utils_escape_ssid (ssid->data, ssid->len) : "(none)");
 }
 
 static gboolean
@@ -3433,18 +3511,29 @@ real_set_enabled (NMDeviceInterface *device, gboolean enabled)
 
 	priv->enabled = enabled;
 
+	nm_log_dbg (LOGD_WIFI, "(%s): device now %s",
+	            nm_device_get_iface (NM_DEVICE (device)),
+	            enabled ? "enabled" : "disabled");
+
 	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-	if (state < NM_DEVICE_STATE_UNAVAILABLE)
+	if (state < NM_DEVICE_STATE_UNAVAILABLE) {
+		nm_log_dbg (LOGD_WIFI, "(%s): %s blocked by UNMANAGED state",
+		            enabled ? "enable" : "disable",
+		            nm_device_get_iface (NM_DEVICE (device)));
 		return;
+	}
 
 	if (enabled) {
 		gboolean no_firmware = FALSE, success;
 		struct iw_range range;
 
 		if (state != NM_DEVICE_STATE_UNAVAILABLE)
-			nm_warning ("not in expected unavailable state!");
+			nm_log_warn (LOGD_CORE, "not in expected unavailable state!");
 
 		if (!nm_device_hw_bring_up (NM_DEVICE (self), TRUE, &no_firmware)) {
+			nm_log_dbg (LOGD_WIFI, "(%s): enable blocked by failure to bring device up",
+			            nm_device_get_iface (NM_DEVICE (device)));
+
 			/* The device sucks, or HAL was lying to us about the killswitch state */
 			priv->enabled = FALSE;
 			return;
@@ -3459,6 +3548,8 @@ real_set_enabled (NMDeviceInterface *device, gboolean enabled)
 			supplicant_interface_release (self);
 
 		supplicant_interface_acquire (self);
+		nm_log_dbg (LOGD_WIFI, "(%s): enable waiting on supplicant state",
+		            nm_device_get_iface (NM_DEVICE (device)));
 	} else {
 		nm_device_state_changed (NM_DEVICE (self),
 		                         NM_DEVICE_STATE_UNAVAILABLE,
@@ -3486,6 +3577,7 @@ nm_device_wifi_new (const char *udi,
 	                                  NM_DEVICE_WIFI_IFINDEX, ifindex,
 	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "802.11 WiFi",
 	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_WIFI,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE, RFKILL_TYPE_WLAN,
 	                                  NULL);
 }
 
diff --git a/src/nm-device-wifi.h b/src/nm-device-wifi.h
index c793844..45b573a 100644
--- a/src/nm-device-wifi.h
+++ b/src/nm-device-wifi.h
@@ -28,7 +28,7 @@
 
 #include "nm-rfkill.h"
 #include "nm-device.h"
-#include "NetworkManagerAP.h"
+#include "nm-wifi-ap.h"
 
 struct NMAccessPointList;
 
diff --git a/src/nm-device.c b/src/nm-device.c
index 6c0f99c..280d4e4 100644
--- a/src/nm-device.c
+++ b/src/nm-device.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -38,13 +38,13 @@
 #include "nm-device-interface.h"
 #include "nm-device.h"
 #include "nm-device-private.h"
-#include "NetworkManagerPolicy.h"
 #include "NetworkManagerUtils.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-dhcp-manager.h"
 #include "nm-dbus-manager.h"
 #include "nm-named-manager.h"
 #include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-netlink.h"
 #include "nm-setting-ip4-config.h"
 #include "nm-setting-ip6-config.h"
@@ -53,6 +53,7 @@
 #include "nm-dhcp4-config.h"
 #include "nm-ip6-manager.h"
 #include "nm-marshal.h"
+#include "nm-rfkill.h"
 
 #define NM_ACT_REQUEST_IP4_CONFIG "nm-act-request-ip4-config"
 #define NM_ACT_REQUEST_IP6_CONFIG "nm-act-request-ip6-config"
@@ -88,6 +89,7 @@ typedef struct {
 	guint32       capabilities;
 	char *        driver;
 	gboolean      managed; /* whether managed by NM or not */
+	RfKillType    rfkill_type;
 
 	guint32         ip4_address;
 
@@ -102,13 +104,16 @@ typedef struct {
 	gboolean        ip4_ready;
 	gboolean        ip6_ready;
 
-	/* IP4 configuration info */
-	NMIP4Config *   ip4_config;			/* Config from DHCP, PPP, or system config files */
+	/* Generic DHCP stuff */
 	NMDHCPManager * dhcp_manager;
 	guint32         dhcp_timeout;
-	gulong          dhcp_state_sigid;
-	gulong          dhcp_timeout_sigid;
 	GByteArray *    dhcp_anycast_address;
+
+	/* IP4 configuration info */
+	NMIP4Config *   ip4_config;			/* Config from DHCP, PPP, or system config files */
+	NMDHCPClient *  dhcp4_client;
+	gulong          dhcp4_state_sigid;
+	gulong          dhcp4_timeout_sigid;
 	NMDHCP4Config * dhcp4_config;
 
 	/* dnsmasq stuff for shared connections */
@@ -127,6 +132,12 @@ typedef struct {
 	gulong         ip6_addrconf_sigid;
 	gulong         ip6_config_changed_sigid;
 	gboolean       ip6_waiting_for_config;
+	guint32        ip6_dhcp_opt;
+
+	NMDHCPClient *  dhcp6_client;
+	gulong          dhcp6_state_sigid;
+	gulong          dhcp6_timeout_sigid;
+	NMDHCP6Config * dhcp6_config;
 
 	/* inhibit autoconnect feature */
 	gboolean	autoconnect_inhibit;
@@ -159,6 +170,11 @@ static gboolean nm_device_set_ip6_config (NMDevice *dev,
                                           gboolean assumed,
                                           NMDeviceStateReason *reason);
 
+static NMActStageReturn dhcp6_start (NMDevice *self,
+                                     NMConnection *connection,
+                                     guint32 dhcp_opt,
+                                     NMDeviceStateReason *reason);
+
 static void
 device_interface_init (NMDeviceInterface *device_interface_class)
 {
@@ -181,6 +197,7 @@ nm_device_init (NMDevice *self)
 	priv->capabilities = NM_DEVICE_CAP_NONE;
 	priv->state = NM_DEVICE_STATE_UNMANAGED;
 	priv->dhcp_timeout = 0;
+	priv->rfkill_type = RFKILL_TYPE_UNKNOWN;
 }
 
 static GObject*
@@ -202,24 +219,26 @@ constructor (GType type,
 	priv = NM_DEVICE_GET_PRIVATE (dev);
 
 	if (!priv->udi) {
-		nm_warning ("No device udi provided, ignoring");
+		nm_log_err (LOGD_DEVICE, "No device udi provided, ignoring");
 		goto error;
 	}
 
 	if (!priv->iface) {
-		nm_warning ("No device interface provided, ignoring");
+		nm_log_err (LOGD_DEVICE, "No device interface provided, ignoring");
 		goto error;
 	}
 
 	priv->capabilities |= NM_DEVICE_GET_CLASS (dev)->get_generic_capabilities (dev);
 	if (!(priv->capabilities & NM_DEVICE_CAP_NM_SUPPORTED)) {
-		nm_warning ("(%s): Device unsupported, ignoring.", priv->iface);
+		nm_log_warn (LOGD_DEVICE, "(%s): Device unsupported, ignoring.", priv->iface);
 		goto error;
 	}
 
 	if (NM_DEVICE_GET_CLASS (dev)->update_hw_address)
 		NM_DEVICE_GET_CLASS (dev)->update_hw_address (dev);
 
+	priv->dhcp_manager = nm_dhcp_manager_get ();
+
 	priv->initialized = TRUE;
 	return object;
 
@@ -508,8 +527,9 @@ activation_source_schedule (NMDevice *self, GSourceFunc func, int family)
 		act_source_func = &priv->act_source_func;
 	}
 
-	if (*act_source_id)
-		nm_warning ("activation stage already scheduled");
+	if (*act_source_id) {
+		nm_log_err (LOGD_DEVICE, "activation stage already scheduled");
+	}
 
 	/* Don't bother rescheduling the same function that's about to
 	 * run anyway.  Fixes issues with crappy wireless drivers sending
@@ -525,31 +545,78 @@ activation_source_schedule (NMDevice *self, GSourceFunc func, int family)
 
 static void
 ip6_addrconf_complete (NMIP6Manager *ip6_manager,
-					   const char *iface,
-					   gboolean success,
-					   gpointer user_data)
+                       const char *iface,
+                       guint dhcp_opts,
+                       gboolean success,
+                       gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActRequest *req;
+	NMConnection *connection;
+	NMActStageReturn ret;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+	NMDeviceState state;
 
 	if (strcmp (nm_device_get_ip_iface (self), iface) != 0)
 		return;
-	if (!nm_device_get_act_request (self))
+	req = nm_device_get_act_request (self);
+	if (!req)
 		return;
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
 
-	if (priv->ip6_waiting_for_config) {
-		priv->ip6_waiting_for_config = FALSE;
-		if (success)
-			nm_device_activate_schedule_stage4_ip6_config_get (self);
-		else
-			nm_device_activate_schedule_stage4_ip6_config_timeout (self);
+	if (!priv->ip6_waiting_for_config)
+		return;
+
+	priv->ip6_waiting_for_config = FALSE;
+
+	if (!success) {
+		nm_device_activate_schedule_stage4_ip6_config_timeout (self);
+		return;
+	}
+
+	priv->ip6_dhcp_opt = dhcp_opts;
+
+	/* If addrconf is all that's required, we're done */
+	if (dhcp_opts == IP6_DHCP_OPT_NONE) {
+		nm_device_activate_schedule_stage4_ip6_config_get (self);
+		return;
+	}
+
+	/* If the router said to use DHCP for managed or otherconf, do it */
+
+	/* Don't re-start DHCPv6 if it's already in progress */
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
+	if ((state != NM_DEVICE_STATE_IP_CONFIG) || priv->dhcp6_client)
+		return;
+
+	nm_log_info (LOGD_DEVICE | LOGD_DHCP6,
+	             "Activation (%s) Stage 3 of 5 (IP Configure Start) starting DHCPv6"
+	             " as requested by IPv6 router...",
+	             priv->iface);
+
+	ret = dhcp6_start (self, connection, dhcp_opts, &reason);
+	switch (ret) {
+	case NM_ACT_STAGE_RETURN_SUCCESS:
+		/* Shouldn't get this, but handle it anyway */
+		g_warn_if_reached ();
+		nm_device_activate_schedule_stage4_ip6_config_get (self);
+		break;
+	case NM_ACT_STAGE_RETURN_POSTPONE:
+		/* Success; wait for DHCPv6 to complete */
+		break;
+	default:
+		nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);
+		break;
 	}
 }
 
 static void
 ip6_config_changed (NMIP6Manager *ip6_manager,
-					const char *iface,
-					gpointer user_data)
+                    const char *iface,
+                    guint dhcp_opts,
+                    gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
 
@@ -561,49 +628,58 @@ ip6_config_changed (NMIP6Manager *ip6_manager,
 	nm_device_activate_schedule_stage4_ip6_config_get (self);
 }
 
+static gboolean
+ip6_method_matches (NMConnection *connection, const char *match)
+{
+	NMSettingIP6Config *s_ip6;
+	const char *method = NULL;
+
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
+	if (s_ip6)
+		method = nm_setting_ip6_config_get_method (s_ip6);
+
+	return method && !strcmp (method, match);
+}
+
 static void
-nm_device_setup_ip6 (NMDevice *self)
+addrconf6_setup (NMDevice *self)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	NMActRequest *req;
 	NMConnection *connection;
-	const char *ip_iface, *method = NULL;
+	const char *ip_iface;
 	NMSettingIP6Config *s_ip6;
 
+	priv->ip6_waiting_for_config = FALSE;
+	priv->ip6_dhcp_opt = IP6_DHCP_OPT_NONE;
+
 	req = nm_device_get_act_request (self);
-	if (!req)
-		return;
+	g_assert (req);
 	connection = nm_act_request_get_connection (req);
-	if (!connection)
-		return;
-
-	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
-	if (s_ip6)
-		method = nm_setting_ip6_config_get_method (s_ip6);
+	g_assert (connection);
 
-	if (!method || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE))
+	if (!ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_AUTO))
 		return;
 
 	if (!priv->ip6_manager) {
 		priv->ip6_manager = nm_ip6_manager_get ();
 		priv->ip6_addrconf_sigid = g_signal_connect (priv->ip6_manager,
-													 "addrconf-complete",
-													 G_CALLBACK (ip6_addrconf_complete),
-													 self);
+		                                             "addrconf-complete",
+		                                             G_CALLBACK (ip6_addrconf_complete),
+		                                             self);
 		priv->ip6_config_changed_sigid = g_signal_connect (priv->ip6_manager,
-														   "config-changed",
-														   G_CALLBACK (ip6_config_changed),
-														   self);
+		                                                   "config-changed",
+		                                                   G_CALLBACK (ip6_config_changed),
+		                                                   self);
 	}
 
-	priv->ip6_waiting_for_config = FALSE;
-
 	ip_iface = nm_device_get_ip_iface (self);
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
 	nm_ip6_manager_prepare_interface (priv->ip6_manager, ip_iface, s_ip6);
 }
 
 static void
-nm_device_cleanup_ip6 (NMDevice *self)
+addrconf6_cleanup (NMDevice *self)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
@@ -625,6 +701,13 @@ nm_device_cleanup_ip6 (NMDevice *self)
 	priv->ip6_manager = NULL;
 }
 
+static NMActStageReturn
+real_act_stage1_prepare (NMDevice *self, NMDeviceStateReason *reason)
+{
+	addrconf6_setup (self);
+	return NM_ACT_STAGE_RETURN_SUCCESS;
+}
+
 /*
  * nm_device_activate_stage1_device_prepare
  *
@@ -635,6 +718,7 @@ static gboolean
 nm_device_activate_stage1_device_prepare (gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	const char *iface;
 	NMActStageReturn ret;
 	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
@@ -642,12 +726,12 @@ nm_device_activate_stage1_device_prepare (gpointer user_data)
 	/* Clear the activation source ID now that this stage has run */
 	activation_source_clear (self, FALSE, 0);
 
+	priv->ip4_ready = priv->ip6_ready = FALSE;
+
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 1 of 5 (Device Prepare) started...", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 1 of 5 (Device Prepare) started...", iface);
 	nm_device_state_changed (self, NM_DEVICE_STATE_PREPARE, NM_DEVICE_STATE_REASON_NONE);
 
-	nm_device_setup_ip6 (self);
-
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage1_prepare (self, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
 		goto out;
@@ -660,7 +744,7 @@ nm_device_activate_stage1_device_prepare (gpointer user_data)
 	nm_device_activate_schedule_stage2_device_config (self);
 
 out:
-	nm_info ("Activation (%s) Stage 1 of 5 (Device Prepare) complete.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 1 of 5 (Device Prepare) complete.", iface);
 	return FALSE;
 }
 
@@ -683,15 +767,8 @@ nm_device_activate_schedule_stage1_device_prepare (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage1_device_prepare, 0);
 
-	nm_info ("Activation (%s) Stage 1 of 5 (Device Prepare) scheduled...",
-	         nm_device_get_iface (self));
-}
-
-static NMActStageReturn
-real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
-{
-	/* Nothing to do */
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 1 of 5 (Device Prepare) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 static NMActStageReturn
@@ -721,7 +798,7 @@ nm_device_activate_stage2_device_config (gpointer user_data)
 	activation_source_clear (self, FALSE, 0);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) starting...", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) starting...", iface);
 	nm_device_state_changed (self, NM_DEVICE_STATE_CONFIG, NM_DEVICE_STATE_REASON_NONE);
 
 	if (!nm_device_bring_up (self, FALSE, &no_firmware)) {
@@ -742,12 +819,12 @@ nm_device_activate_stage2_device_config (gpointer user_data)
 	}
 	g_assert (ret == NM_ACT_STAGE_RETURN_SUCCESS);	
 
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) successful.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) successful.", iface);
 
 	nm_device_activate_schedule_stage3_ip_config_start (self);
 
 out:
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) complete.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) complete.", iface);
 	return FALSE;
 }
 
@@ -770,7 +847,7 @@ nm_device_activate_schedule_stage2_device_config (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage2_device_config, 0);
 
-	nm_info ("Activation (%s) Stage 2 of 5 (Device Configure) scheduled...",
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 2 of 5 (Device Configure) scheduled...",
 	         nm_device_get_iface (self));
 }
 
@@ -799,9 +876,9 @@ aipd_cleanup (NMDevice *self)
 		kill (priv->aipd_pid, SIGKILL);
 
 		/* ensure the child is reaped */
-		nm_debug ("waiting for ppp pid %d to exit", priv->aipd_pid);
+		nm_log_dbg (LOGD_AUTOIP4, "waiting for avahi-autoipd pid %d to exit", priv->aipd_pid);
 		waitpid (priv->aipd_pid, NULL, 0);
-		nm_debug ("ppp pid %d cleaned up", priv->aipd_pid);
+		nm_log_dbg (LOGD_AUTOIP4, "avahi-autoip pid %d cleaned up", priv->aipd_pid);
 
 		priv->aipd_pid = -1;
 	}
@@ -845,7 +922,7 @@ handle_autoip_change (NMDevice *self, NMDeviceStateReason *reason)
 
 	config = aipd_get_ip4_config (self, reason);
 	if (!config) {
-		nm_warning ("failed to get autoip config for rebind");
+		nm_log_err (LOGD_AUTOIP4, "failed to get autoip config for rebind");
 		return FALSE;
 	}
 
@@ -857,7 +934,7 @@ handle_autoip_change (NMDevice *self, NMDeviceStateReason *reason)
 	g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP4_CONFIG, config);
 
 	if (!nm_device_set_ip4_config (self, config, FALSE, reason)) {
-		nm_warning ("(%s): failed to update IP4 config in response to autoip event.",
+		nm_log_err (LOGD_AUTOIP4, "(%s): failed to update IP4 config in response to autoip event.",
 		            nm_device_get_iface (self));
 		return FALSE;
 	}
@@ -906,14 +983,14 @@ nm_device_handle_autoip4_event (NMDevice *self,
 		NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
 		if (inet_pton (AF_INET, address, &ip) <= 0) {
-			nm_warning ("(%s): invalid address %s received from avahi-autoipd.",
+			nm_log_err (LOGD_AUTOIP4, "(%s): invalid address %s received from avahi-autoipd.",
 			            iface, address);
 			nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_ERROR);
 			return;
 		}
 
 		if ((ip.s_addr & IPV4LL_NETMASK) != IPV4LL_NETWORK) {
-			nm_warning ("(%s): invalid address %s received from avahi-autoipd.",
+			nm_log_err (LOGD_AUTOIP4, "(%s): invalid address %s received from avahi-autoipd (not link-local).",
 			            iface, address);
 			nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_ERROR);
 			return;
@@ -922,7 +999,7 @@ nm_device_handle_autoip4_event (NMDevice *self,
 		switch (state) {
 		case NM_DEVICE_STATE_IP_CONFIG:
 			if (priv->aipd_addr) {
-				nm_warning ("(%s): already have autoip address!", iface);
+				nm_log_warn (LOGD_AUTOIP4, "(%s): already have autoip address!", iface);
 				return;
 			}
 
@@ -936,12 +1013,12 @@ nm_device_handle_autoip4_event (NMDevice *self,
 				nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);
 			break;
 		default:
-			nm_warning ("(%s): unexpected avahi-autoip event %s for %s.",
+			nm_log_warn (LOGD_AUTOIP4, "(%s): unexpected avahi-autoip event %s for %s.",
 			            iface, event, address);
 			break;
 		}
 	} else {
-		nm_warning ("%s: autoip address %s no longer valid because '%s'.",
+		nm_log_warn (LOGD_AUTOIP4, "(%s): autoip address %s no longer valid because '%s'.",
 		            iface, address, event);
 
 		/* The address is gone; terminate the connection or fail activation */
@@ -963,14 +1040,18 @@ aipd_watch_cb (GPid pid, gint status, gpointer user_data)
 
 	iface = nm_device_get_iface (self);
 
-	if (WIFEXITED (status))
-		nm_warning ("%s: avahi-autoipd exited with error code %d", iface, WEXITSTATUS (status));
-	else if (WIFSTOPPED (status)) 
-		nm_warning ("%s: avahi-autoipd stopped unexpectedly with signal %d", iface, WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		nm_warning ("%s: avahi-autoipd died with signal %d", iface, WTERMSIG (status));
-	else
-		nm_warning ("%s: avahi-autoipd died from an unknown cause", iface);
+	if (WIFEXITED (status)) {
+		nm_log_dbg (LOGD_AUTOIP4, "(%s): avahi-autoipd exited with error code %d",
+		            iface, WEXITSTATUS (status));
+	} else if (WIFSTOPPED (status)) {
+		nm_log_warn (LOGD_AUTOIP4, "(%s): avahi-autoipd stopped unexpectedly with signal %d",
+		            iface, WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_warn (LOGD_AUTOIP4, "(%s): avahi-autoipd died with signal %d",
+		             iface, WTERMSIG (status));
+	} else {
+		nm_log_warn (LOGD_AUTOIP4, "(%s): avahi-autoipd died from an unknown cause", iface);
+	}
 
 	aipd_cleanup (self);
 
@@ -989,7 +1070,7 @@ aipd_timeout_cb (gpointer user_data)
 		return FALSE;
 	priv->aipd_timeout = 0;
 
-	nm_info ("%s: avahi-autoipd timed out.", nm_device_get_iface (self));
+	nm_log_info (LOGD_AUTOIP4, "(%s): avahi-autoipd timed out.", nm_device_get_iface (self));
 	aipd_cleanup (self);
 
 	if (nm_device_get_state (self) == NM_DEVICE_STATE_IP_CONFIG)
@@ -1057,6 +1138,169 @@ aipd_exec (NMDevice *self, GError **error)
 	return TRUE;
 }
 
+static void
+dhcp4_add_option_cb (gpointer key, gpointer value, gpointer user_data)
+{
+	nm_dhcp4_config_add_option (NM_DHCP4_CONFIG (user_data),
+	                            (const char *) key,
+	                            (const char *) value);
+}
+
+static void
+dhcp6_add_option_cb (gpointer key, gpointer value, gpointer user_data)
+{
+	nm_dhcp6_config_add_option (NM_DHCP6_CONFIG (user_data),
+	                            (const char *) key,
+	                            (const char *) value);
+}
+
+static void
+handle_dhcp_lease_change (NMDevice *device, gboolean ipv6)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
+	NMIP4Config *ip4_config;
+	NMSettingIP4Config *s_ip4;
+	NMIP6Config *ip6_config;
+	NMSettingIP6Config *s_ip6;
+	NMConnection *connection;
+	NMActRequest *req;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+	gboolean assumed;
+
+	req = nm_device_get_act_request (device);
+	g_assert (req);
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
+	assumed = nm_act_request_get_assumed (req);
+
+	if (ipv6) {
+		ip6_config = nm_dhcp_client_get_ip6_config (priv->dhcp6_client, FALSE);
+		if (!ip6_config) {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to get DHCPv6 config for rebind",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
+			return;
+		}
+
+		s_ip6 = NM_SETTING_IP6_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG));
+		nm_utils_merge_ip6_config (ip6_config, s_ip6);
+
+		g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP6_CONFIG, ip6_config);
+
+		if (nm_device_set_ip6_config (device, ip6_config, assumed, &reason)) {
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+			nm_dhcp_client_foreach_option (priv->dhcp6_client,
+			                               dhcp6_add_option_cb,
+			                               priv->dhcp6_config);
+		} else {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to update IPv6 config in response to DHCP event.",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+		}
+	} else {
+		ip4_config = nm_dhcp_client_get_ip4_config (priv->dhcp4_client, FALSE);
+		if (!ip4_config) {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to get DHCPv4 config for rebind",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
+			return;
+		}
+
+		s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
+		nm_utils_merge_ip4_config (ip4_config, s_ip4);
+
+		g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP4_CONFIG, ip4_config);
+
+		if (nm_device_set_ip4_config (device, ip4_config, assumed, &reason)) {
+			nm_dhcp4_config_reset (priv->dhcp4_config);
+			nm_dhcp_client_foreach_option (priv->dhcp4_client,
+			                               dhcp4_add_option_cb,
+			                               priv->dhcp4_config);
+		} else {
+			nm_log_warn (LOGD_DHCP6, "(%s): failed to update IPv4 config in response to DHCP event.",
+			             nm_device_get_ip_iface (device));
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
+		}
+	}
+}
+
+static void
+dhcp_state_changed (NMDHCPClient *client,
+					NMDHCPState state,
+					gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
+	NMDeviceState dev_state;
+	gboolean ipv6;
+
+	ipv6 = nm_dhcp_client_get_ipv6 (client);
+	dev_state = nm_device_get_state (device);
+
+	switch (state) {
+	case DHC_BOUND4:     /* lease obtained */
+	case DHC_BOUND6:
+	case DHC_RENEW4:     /* lease renewed */
+	case DHC_RENEW6:     /* lease renewed */
+	case DHC_REBOOT:     /* have valid lease, but now obtained a different one */
+	case DHC_REBIND4:    /* new, different lease */
+	case DHC_REBIND6:    /* new, different lease */
+		if (dev_state == NM_DEVICE_STATE_IP_CONFIG) {
+			if (ipv6)
+				nm_device_activate_schedule_stage4_ip6_config_get (device);
+			else
+				nm_device_activate_schedule_stage4_ip4_config_get (device);
+		} else if (dev_state == NM_DEVICE_STATE_ACTIVATED)
+			handle_dhcp_lease_change (device, ipv6);
+		break;
+	case DHC_TIMEOUT: /* timed out contacting DHCP server */
+		if (ipv6) {
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+			if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
+				nm_device_activate_schedule_stage4_ip6_config_timeout (device);
+		} else {
+			nm_dhcp4_config_reset (priv->dhcp4_config);
+			if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
+				nm_device_activate_schedule_stage4_ip4_config_timeout (device);
+		}
+		break;
+	case DHC_FAIL: /* all attempts to contact server timed out, sleeping */
+	case DHC_ABEND: /* dhclient exited abnormally */
+	case DHC_END: /* dhclient exited normally */
+		if (ipv6)
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+		else
+			nm_dhcp4_config_reset (priv->dhcp4_config);
+
+		/* dhclient quit and can't get/renew a lease; so kill the connection */
+		if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DHCP_FAILED);
+		else if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED)
+			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+dhcp_timeout (NMDHCPClient *client, gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+
+	if (!nm_device_get_act_request (device))
+		return;
+
+	nm_dhcp_client_stop (client);
+
+	if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG) {
+		if (nm_dhcp_client_get_ipv6 (client))
+			nm_device_activate_schedule_stage4_ip6_config_timeout (device);
+		else
+			nm_device_activate_schedule_stage4_ip4_config_timeout (device);
+	}
+}
+
 static NMActStageReturn
 real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 {
@@ -1090,22 +1334,34 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 
 	if (!s_ip4 || !method || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)) {
 		NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-		gboolean success;
 		guint8 *anycast = NULL;
 
+		/* Begin a DHCP transaction on the interface */
+
 		if (priv->dhcp_anycast_address)
 			anycast = priv->dhcp_anycast_address->data;
 
-		/* Begin a DHCP transaction on the interface */
-		nm_device_set_use_dhcp (self, TRUE);
+		/* Clear old exported DHCP options */
+		if (priv->dhcp4_config)
+			g_object_unref (priv->dhcp4_config);
+		priv->dhcp4_config = nm_dhcp4_config_new ();
 
-		/* DHCP manager will cancel any transaction already in progress and we do not
-		   want to cancel this activation if we get "down" state from that. */
-		g_signal_handler_block (priv->dhcp_manager, priv->dhcp_state_sigid);
-		success = nm_dhcp_manager_begin_transaction (priv->dhcp_manager, ip_iface, uuid, s_ip4, priv->dhcp_timeout, anycast);
-		g_signal_handler_unblock (priv->dhcp_manager, priv->dhcp_state_sigid);
+		priv->dhcp4_client = nm_dhcp_manager_start_ip4 (priv->dhcp_manager,
+		                                                ip_iface,
+		                                                uuid,
+		                                                s_ip4,
+		                                                priv->dhcp_timeout,
+		                                                anycast);
+		if (priv->dhcp4_client) {
+			priv->dhcp4_state_sigid = g_signal_connect (priv->dhcp4_client,
+			                                            "state-changed",
+			                                            G_CALLBACK (dhcp_state_changed),
+			                                            self);
+			priv->dhcp4_timeout_sigid = g_signal_connect (priv->dhcp4_client,
+			                                              "timeout",
+			                                              G_CALLBACK (dhcp_timeout),
+			                                              self);
 
-		if (success) {
 			/* DHCP devices will be notified by the DHCP manager when
 			 * stuff happens.	
 			 */
@@ -1120,12 +1376,14 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 
 		/* Start avahi-autoipd */
 		if (aipd_exec (self, &error)) {
-			nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) started"
-			         " avahi-autoipd...", iface);
+			nm_log_info (LOGD_DEVICE | LOGD_AUTOIP4,
+			             "Activation (%s) Stage 3 of 5 (IP Configure Start) started"
+			             " avahi-autoipd...", iface);
 			ret = NM_ACT_STAGE_RETURN_POSTPONE;
 		} else {
-			nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) failed"
-			         " to start avahi-autoipd: %s", iface, error->message);
+			nm_log_info (LOGD_DEVICE | LOGD_AUTOIP4,
+			             "Activation (%s) Stage 3 of 5 (IP Configure Start) failed"
+			             " to start avahi-autoipd: %s", iface, error->message);
 			g_error_free (error);
 			aipd_cleanup (self);
 			*reason = NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED;
@@ -1137,23 +1395,98 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 }
 
 static NMActStageReturn
+dhcp6_start (NMDevice *self,
+             NMConnection *connection,
+             guint32 dhcp_opt,
+             NMDeviceStateReason *reason)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;
+	guint8 *anycast = NULL;
+	NMSettingIP6Config *s_ip6;
+	NMSettingConnection *s_con;
+	const char *uuid;
+	const char *ip_iface;
+
+	if (!connection) {
+		NMActRequest *req;
+
+		req = nm_device_get_act_request (self);
+		g_assert (req);
+		connection = nm_act_request_get_connection (req);
+		g_assert (connection);
+	}
+
+	/* Begin a DHCP transaction on the interface */
+
+	if (priv->dhcp_anycast_address)
+		anycast = priv->dhcp_anycast_address->data;
+
+	/* Clear old exported DHCP options */
+	if (priv->dhcp6_config)
+		g_object_unref (priv->dhcp6_config);
+	priv->dhcp6_config = nm_dhcp6_config_new ();
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_assert (s_con);
+	uuid = nm_setting_connection_get_uuid (s_con);
+
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
+
+	ip_iface = nm_device_get_ip_iface (self);
+	priv->dhcp6_client = nm_dhcp_manager_start_ip6 (priv->dhcp_manager,
+	                                                ip_iface,
+	                                                uuid,
+	                                                s_ip6,
+	                                                priv->dhcp_timeout,
+	                                                anycast,
+	                                                (dhcp_opt == IP6_DHCP_OPT_OTHERCONF) ? TRUE : FALSE);
+	if (priv->dhcp6_client) {
+		priv->dhcp6_state_sigid = g_signal_connect (priv->dhcp6_client,
+		                                            "state-changed",
+		                                            G_CALLBACK (dhcp_state_changed),
+		                                            self);
+		priv->dhcp6_timeout_sigid = g_signal_connect (priv->dhcp6_client,
+		                                              "timeout",
+		                                              G_CALLBACK (dhcp_timeout),
+		                                              self);
+
+		/* DHCP devices will be notified by the DHCP manager when stuff happens */
+		ret = NM_ACT_STAGE_RETURN_POSTPONE;
+	} else {
+		*reason = NM_DEVICE_STATE_REASON_DHCP_START_FAILED;
+		ret = NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	return ret;
+}
+
+static NMActStageReturn
 real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-	const char *ip_iface = nm_device_get_ip_iface (self);
+	const char *ip_iface;
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
+	NMActRequest *req;
+	NMConnection *connection;
 
 	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
-	/* If we are ignoring IPv6 on this interface then we can go right
-	 * to stage 4.
-	 */
-	if (!priv->ip6_manager)
-		return NM_ACT_STAGE_RETURN_SUCCESS;
+	req = nm_device_get_act_request (self);
+	g_assert (req);
+	connection = nm_act_request_get_connection (req);
+	g_assert (connection);
 
-	priv->ip6_waiting_for_config = TRUE;
-	nm_ip6_manager_begin_addrconf (priv->ip6_manager, ip_iface);
+	ip_iface = nm_device_get_ip_iface (self);
+
+	if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
+		priv->ip6_waiting_for_config = TRUE;
+		nm_ip6_manager_begin_addrconf (priv->ip6_manager, ip_iface);
+		ret = NM_ACT_STAGE_RETURN_POSTPONE;
+	} else if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_DHCP))
+		ret = dhcp6_start (self, connection, IP6_DHCP_OPT_MANAGED, reason);
 
-	return NM_ACT_STAGE_RETURN_POSTPONE;
+	return ret;
 }
 
 
@@ -1167,7 +1500,6 @@ static gboolean
 nm_device_activate_stage3_ip_config_start (gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	const char *iface;
 	NMActStageReturn ret;
 	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
@@ -1175,10 +1507,8 @@ nm_device_activate_stage3_ip_config_start (gpointer user_data)
 	/* Clear the activation source ID now that this stage has run */
 	activation_source_clear (self, FALSE, 0);
 
-	priv->ip4_ready = priv->ip6_ready = FALSE;
-
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) started...", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) started...", iface);
 	nm_device_state_changed (self, NM_DEVICE_STATE_IP_CONFIG, NM_DEVICE_STATE_REASON_NONE);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage3_ip4_config_start (self, &reason);
@@ -1200,7 +1530,7 @@ nm_device_activate_stage3_ip_config_start (gpointer user_data)
 		g_assert (ret == NM_ACT_STAGE_RETURN_POSTPONE);
 
 out:
-	nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
 	return FALSE;
 }
 
@@ -1222,8 +1552,8 @@ nm_device_activate_schedule_stage3_ip_config_start (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage3_ip_config_start, 0);
 
-	nm_info ("Activation (%s) Stage 3 of 5 (IP Configure Start) scheduled.",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) scheduled.",
+	             nm_device_get_iface (self));
 }
 
 static GHashTable *shared_ips = NULL;
@@ -1243,7 +1573,7 @@ reserve_shared_ip (void)
 	while (g_hash_table_lookup (shared_ips, GUINT_TO_POINTER (start + count))) {
 		count += ntohl (0x100);
 		if (count > ntohl (0xFE00)) {
-			nm_warning ("%s: ran out of shared IP addresses!", __func__);
+			nm_log_err (LOGD_SHARING, "ran out of shared IP addresses!");
 			return 0;
 		}
 	}
@@ -1283,14 +1613,6 @@ nm_device_new_ip4_shared_config (NMDevice *self, NMDeviceStateReason *reason)
 	return config;
 }
 
-static void
-dhcp4_add_option_cb (gpointer key, gpointer value, gpointer user_data)
-{
-	nm_dhcp4_config_add_option (NM_DHCP4_CONFIG (user_data),
-	                            (const char *) key,
-	                            (const char *) value);
-}
-
 static NMActStageReturn
 real_act_stage4_get_ip4_config (NMDevice *self,
                                 NMIP4Config **config,
@@ -1314,23 +1636,24 @@ real_act_stage4_get_ip4_config (NMDevice *self,
 
 	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
 
-	if (nm_device_get_use_dhcp (self)) {
-		*config = nm_dhcp_manager_get_ip4_config (priv->dhcp_manager, ip_iface);
+	if (priv->dhcp4_client) {
+		/* DHCP */
+		*config = nm_dhcp_client_get_ip4_config (priv->dhcp4_client, FALSE);
 		if (*config) {
 			/* Merge user-defined overrides into the IP4Config to be applied */
 			nm_utils_merge_ip4_config (*config, s_ip4);
 
 			nm_dhcp4_config_reset (priv->dhcp4_config);
-			nm_dhcp_manager_foreach_dhcp4_option (priv->dhcp_manager,
-			                                      ip_iface,
-			                                      dhcp4_add_option_cb,
-			                                      priv->dhcp4_config);
+			nm_dhcp_client_foreach_option (priv->dhcp4_client,
+			                               dhcp4_add_option_cb,
+			                               priv->dhcp4_config);
 
 			/* Notify of new DHCP4 config */
 			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
 		} else
 			*reason = NM_DEVICE_STATE_REASON_DHCP_ERROR;
 	} else {
+		/* Not DHCP */
 		const char *method;
 
 		g_assert (s_ip4);
@@ -1382,7 +1705,9 @@ nm_device_activate_stage4_ip4_config_get (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Get) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Get) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_get_ip4_config (self, &ip4_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE)
@@ -1400,7 +1725,9 @@ nm_device_activate_stage4_ip4_config_get (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Get) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Get) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1423,8 +1750,9 @@ nm_device_activate_schedule_stage4_ip4_config_get (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip4_config_get, AF_INET);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Get) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Get) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 
@@ -1464,7 +1792,9 @@ nm_device_activate_stage4_ip4_config_timeout (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_ip4_config_timeout (self, &ip4_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
@@ -1482,7 +1812,9 @@ nm_device_activate_stage4_ip4_config_timeout (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1505,8 +1837,9 @@ nm_device_activate_schedule_stage4_ip4_config_timeout (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip4_config_timeout, AF_INET);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP4,
+	             "Activation (%s) Stage 4 of 5 (IP4 Configure Timeout) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 static NMActStageReturn
@@ -1514,11 +1847,11 @@ real_act_stage4_get_ip6_config (NMDevice *self,
                                 NMIP6Config **config,
                                 NMDeviceStateReason *reason)
 {
-	NMDevicePrivate *priv;
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;
 	NMConnection *connection;
 	NMSettingIP6Config *s_ip6;
 	const char *ip_iface;
-	const char *method = NULL;
 
 	g_return_val_if_fail (config != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 	g_return_val_if_fail (*config == NULL, NM_ACT_STAGE_RETURN_FAILURE);
@@ -1531,25 +1864,45 @@ real_act_stage4_get_ip6_config (NMDevice *self,
 	g_assert (connection);
 
 	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
-	if (s_ip6)
-		method = nm_setting_ip6_config_get_method (s_ip6);
 
-	if (!method || !strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
-		*config = NULL;
-		return NM_ACT_STAGE_RETURN_SUCCESS;
-	}
+	if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
+		*config = nm_ip6_manager_get_ip6_config (priv->ip6_manager, ip_iface);
+		if (*config) {
+			/* Merge user-defined overrides into the IP6Config to be applied */
+			nm_utils_merge_ip6_config (*config, s_ip6);
+			ret = NM_ACT_STAGE_RETURN_SUCCESS;
+		} else {
+			*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
+			goto out;
+		}
+	} else if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_DHCP))
+		g_assert (priv->dhcp6_client);  /* sanity check */
 
-	priv = NM_DEVICE_GET_PRIVATE (self);
-	*config = nm_ip6_manager_get_ip6_config (priv->ip6_manager, ip_iface);
-	if (!*config) {
-		*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
-		return NM_ACT_STAGE_RETURN_FAILURE;
-	}
+	/* Autoconf might have triggered DHCPv6 too */
+	if (priv->dhcp6_client) {
+		*config = nm_dhcp_client_get_ip6_config (priv->dhcp6_client, FALSE);
+		if (*config) {
+			/* Merge user-defined overrides into the IP4Config to be applied */
+			nm_utils_merge_ip6_config (*config, s_ip6);
 
-	/* Merge user-defined overrides into the IP6Config to be applied */
-	nm_utils_merge_ip6_config (*config, s_ip6);
+			nm_dhcp6_config_reset (priv->dhcp6_config);
+			nm_dhcp_client_foreach_option (priv->dhcp6_client,
+			                               dhcp6_add_option_cb,
+			                               priv->dhcp6_config);
 
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+			/* Notify of new DHCP4 config */
+			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+			ret = NM_ACT_STAGE_RETURN_SUCCESS;
+		} else {
+			*reason = NM_DEVICE_STATE_REASON_DHCP_ERROR;
+		}
+	} else {
+		*config = NULL;
+		ret = NM_ACT_STAGE_RETURN_SUCCESS;
+	}
+
+out:
+	return ret;
 }
 
 /*
@@ -1571,7 +1924,9 @@ nm_device_activate_stage4_ip6_config_get (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET6);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Get) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Get) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_get_ip6_config (self, &ip6_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE)
@@ -1589,7 +1944,9 @@ nm_device_activate_stage4_ip6_config_get (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET6);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Get) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Get) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1612,8 +1969,9 @@ nm_device_activate_schedule_stage4_ip6_config_get (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip6_config_get, AF_INET6);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Get) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Get) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 
@@ -1625,6 +1983,9 @@ real_act_stage4_ip6_config_timeout (NMDevice *self,
 	g_return_val_if_fail (config != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 	g_return_val_if_fail (*config == NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
+	/* Notify of invalid DHCP6 config object */
+	g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+
 	*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;
 	return NM_ACT_STAGE_RETURN_FAILURE;
 }
@@ -1649,7 +2010,9 @@ nm_device_activate_stage4_ip6_config_timeout (gpointer user_data)
 	activation_source_clear (self, FALSE, AF_INET6);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) started...", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) started...",
+	             iface);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage4_ip6_config_timeout (self, &ip6_config, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_POSTPONE) {
@@ -1667,7 +2030,9 @@ nm_device_activate_stage4_ip6_config_timeout (gpointer user_data)
 	nm_device_activate_schedule_stage5_ip_config_commit (self, AF_INET6);
 
 out:
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) complete.", iface);
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) complete.",
+	             iface);
 	return FALSE;
 }
 
@@ -1690,8 +2055,9 @@ nm_device_activate_schedule_stage4_ip6_config_timeout (NMDevice *self)
 
 	activation_source_schedule (self, nm_device_activate_stage4_ip6_config_timeout, AF_INET6);
 
-	nm_info ("Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE | LOGD_IP6,
+	             "Activation (%s) Stage 4 of 5 (IP6 Configure Timeout) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 static void
@@ -1712,14 +2078,14 @@ share_init (void)
 	char **iter;
 
 	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_forward", "1\n")) {
-		nm_warning ("%s: Error starting IP forwarding: (%d) %s",
-					__func__, errno, strerror (errno));
+		nm_log_err (LOGD_SHARING, "Error starting IP forwarding: (%d) %s",
+					errno, strerror (errno));
 		return FALSE;
 	}
 
 	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_dynaddr", "1\n")) {
-		nm_warning ("%s: Error starting IP forwarding: (%d) %s",
-					__func__, errno, strerror (errno));
+		nm_log_err (LOGD_SHARING, "error starting IP forwarding: (%d) %s",
+					errno, strerror (errno));
 	}
 
 	for (iter = modules; *iter; iter++) {
@@ -1729,9 +2095,9 @@ share_init (void)
 
 		if (!g_spawn_sync ("/", argv, envp, G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,
 		                   share_child_setup, NULL, NULL, NULL, &status, &error)) {
-			nm_info ("%s: Error loading NAT module %s: (%d) %s",
-			         __func__, *iter, error ? error->code : 0,
-			         (error && error->message) ? error->message : "unknown");
+			nm_log_err (LOGD_SHARING, "error loading NAT module %s: (%d) %s",
+			            *iter, error ? error->code : 0,
+			            (error && error->message) ? error->message : "unknown");
 			if (error)
 				g_error_free (error);
 		}
@@ -1805,7 +2171,7 @@ start_sharing (NMDevice *self)
 	nm_act_request_set_shared (req, TRUE);
 
 	if (!nm_dnsmasq_manager_start (priv->dnsmasq_manager, ip4_config, &error)) {
-		nm_warning ("(%s/%s): failed to start dnsmasq: %s",
+		nm_log_err (LOGD_SHARING, "(%s/%s): failed to start dnsmasq: %s",
 		            nm_device_get_iface (self), ip_iface, error->message);
 		g_error_free (error);
 		nm_act_request_set_shared (req, FALSE);
@@ -1859,8 +2225,8 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 	activation_source_clear (self, FALSE, 0);
 
 	iface = nm_device_get_iface (self);
-	nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) started...",
-	         iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 5 of 5 (IP Configure Commit) started...",
+	             iface);
 
 	assumed = nm_act_request_get_assumed (priv->act_request);
 
@@ -1870,8 +2236,9 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 	}
 
 	if (ip6_config && !nm_device_set_ip6_config (self, ip6_config, assumed, &reason)) {
-		nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) IPv6 failed",
-				 iface);
+		nm_log_info (LOGD_DEVICE | LOGD_IP6,
+		             "Activation (%s) Stage 5 of 5 (IP Configure Commit) IPv6 failed",
+				     iface);
 	}
 
 	connection = nm_act_request_get_connection (nm_device_get_act_request (self));
@@ -1883,7 +2250,7 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 
 		if (s_ip4 && !strcmp (method, "shared")) {
 			if (!start_sharing (self)) {
-				nm_warning ("Activation (%s) Stage 5 of 5 (IP Configure Commit) start sharing failed.", iface);
+				nm_log_warn (LOGD_SHARING, "Activation (%s) Stage 5 of 5 (IP Configure Commit) start sharing failed.", iface);
 				nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SHARED_START_FAILED);
 				goto out;
 			}
@@ -1893,8 +2260,8 @@ nm_device_activate_stage5_ip_config_commit (gpointer user_data)
 	nm_device_state_changed (self, NM_DEVICE_STATE_ACTIVATED, NM_DEVICE_STATE_REASON_NONE);
 
 out:
-	nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) complete.",
-	         iface);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 5 of 5 (IP Configure Commit) complete.",
+	             iface);
 
 	/* Balance IP config creation; device takes ownership in set_ip*_config() */
 	if (ip4_config)
@@ -1936,8 +2303,9 @@ nm_device_activate_schedule_stage5_ip_config_commit (NMDevice *self, int family)
 
 	activation_source_schedule (self, nm_device_activate_stage5_ip_config_commit, 0);
 
-	nm_info ("Activation (%s) Stage 5 of 5 (IP Configure Commit) scheduled...",
-	         nm_device_get_iface (self));
+	nm_log_info (LOGD_DEVICE,
+	             "Activation (%s) Stage 5 of 5 (IP Configure Commit) scheduled...",
+	             nm_device_get_iface (self));
 }
 
 
@@ -1977,15 +2345,98 @@ delayed_transitions_clear (NMDevice *self)
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
 	if (priv->failed_to_disconnected_id) {
+		nm_log_dbg (LOGD_DEVICE, "(%s): clearing failed->disconnected transition",
+		            nm_device_get_iface (self));
 		g_source_remove (priv->failed_to_disconnected_id);
 		priv->failed_to_disconnected_id = 0;
 	}
 	if (priv->unavailable_to_disconnected_id) {
+		nm_log_dbg (LOGD_DEVICE, "(%s): clearing unavailable->disconnected transition",
+		            nm_device_get_iface (self));
 		g_source_remove (priv->unavailable_to_disconnected_id);
 		priv->unavailable_to_disconnected_id = 0;
 	}
 }
 
+static void
+dhcp4_cleanup (NMDevice *self, gboolean stop)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (priv->dhcp4_config) {
+		g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
+		g_object_unref (priv->dhcp4_config);
+		priv->dhcp4_config = NULL;
+	}
+
+	if (priv->dhcp4_client) {
+		/* Stop any ongoing DHCP transaction on this device */
+		if (priv->dhcp4_state_sigid) {
+			g_signal_handler_disconnect (priv->dhcp4_client, priv->dhcp4_state_sigid);
+			priv->dhcp4_state_sigid = 0;
+		}
+
+		if (priv->dhcp4_timeout_sigid) {
+			g_signal_handler_disconnect (priv->dhcp4_client, priv->dhcp4_timeout_sigid);
+			priv->dhcp4_timeout_sigid = 0;
+		}
+
+		if (stop)
+			nm_dhcp_client_stop (priv->dhcp4_client);
+
+		g_object_unref (priv->dhcp4_client);
+		priv->dhcp4_client = NULL;
+	}
+}
+
+static void
+dhcp6_cleanup (NMDevice *self, gboolean stop)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (priv->dhcp6_config) {
+		g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+		g_object_unref (priv->dhcp6_config);
+		priv->dhcp6_config = NULL;
+	}
+
+	if (priv->dhcp6_client) {
+		if (priv->dhcp6_state_sigid) {
+			g_signal_handler_disconnect (priv->dhcp6_client, priv->dhcp6_state_sigid);
+			priv->dhcp6_state_sigid = 0;
+		}
+
+		if (priv->dhcp6_timeout_sigid) {
+			g_signal_handler_disconnect (priv->dhcp6_client, priv->dhcp6_timeout_sigid);
+			priv->dhcp6_timeout_sigid = 0;
+		}
+
+		if (stop)
+			nm_dhcp_client_stop (priv->dhcp6_client);
+
+		g_object_unref (priv->dhcp6_client);
+		priv->dhcp6_client = NULL;
+	}
+}
+
+static void
+dnsmasq_cleanup (NMDevice *self)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (!priv->dnsmasq_manager)
+		return;
+
+	if (priv->dnsmasq_state_id) {
+		g_signal_handler_disconnect (priv->dnsmasq_manager, priv->dnsmasq_state_id);
+		priv->dnsmasq_state_id = 0;
+	}
+
+	nm_dnsmasq_manager_stop (priv->dnsmasq_manager);
+	g_object_unref (priv->dnsmasq_manager);
+	priv->dnsmasq_manager = NULL;
+}
+
 /*
  * nm_device_deactivate_quickly
  *
@@ -2010,27 +2461,11 @@ nm_device_deactivate_quickly (NMDevice *self)
 	/* Clear any delayed transitions */
 	delayed_transitions_clear (self);
 
-	/* Stop any ongoing DHCP transaction on this device */
-	if (nm_device_get_act_request (self)) {
-		if (nm_device_get_use_dhcp (self)) {
-			nm_dhcp_manager_cancel_transaction (priv->dhcp_manager, nm_device_get_ip_iface (self));
-			nm_device_set_use_dhcp (self, FALSE);
-			/* Notify of invalid DHCP4 config */
-			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
-		} else if (priv->dnsmasq_manager) {
-			if (priv->dnsmasq_state_id) {
-				g_signal_handler_disconnect (priv->dnsmasq_manager, priv->dnsmasq_state_id);
-				priv->dnsmasq_state_id = 0;
-			}
-
-			nm_dnsmasq_manager_stop (priv->dnsmasq_manager);
-			g_object_unref (priv->dnsmasq_manager);
-			priv->dnsmasq_manager = NULL;
-		}
-	}
-
+	dhcp4_cleanup (self, TRUE);
+	dhcp6_cleanup (self, TRUE);
+	addrconf6_cleanup (self);
+	dnsmasq_cleanup (self);
 	aipd_cleanup (self);
-	nm_device_cleanup_ip6 (self);
 
 	/* Call device type-specific deactivation */
 	if (NM_DEVICE_GET_CLASS (self)->deactivate_quickly)
@@ -2056,9 +2491,8 @@ nm_device_deactivate (NMDeviceInterface *device, NMDeviceStateReason reason)
 
 	g_return_if_fail (self != NULL);
 
-	nm_info ("(%s): deactivating device (reason: %d).",
-	         nm_device_get_iface (self),
-	         reason);
+	nm_log_info (LOGD_DEVICE, "(%s): deactivating device (reason: %d).",
+	             nm_device_get_iface (self), reason);
 
 	nm_device_deactivate_quickly (self);
 
@@ -2246,193 +2680,20 @@ nm_device_can_interrupt_activation (NMDevice *self)
 
 /* IP Configuration stuff */
 
-static void
-handle_dhcp_lease_change (NMDevice *device)
-{
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
-	NMIP4Config *config;
-	NMSettingIP4Config *s_ip4;
-	NMConnection *connection;
-	NMActRequest *req;
-	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
-	const char *ip_iface;
-	gboolean assumed;
-
-	if (!nm_device_get_use_dhcp (device)) {
-		nm_warning ("got DHCP rebind for device that wasn't using DHCP.");
-		return;
-	}
-
-	ip_iface = nm_device_get_ip_iface (device);
-
-	config = nm_dhcp_manager_get_ip4_config (priv->dhcp_manager, ip_iface);
-	if (!config) {
-		nm_warning ("failed to get DHCP config for rebind");
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
-		return;
-	}
-
-	req = nm_device_get_act_request (device);
-	g_assert (req);
-	connection = nm_act_request_get_connection (req);
-	g_assert (connection);
-
-	s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
-	nm_utils_merge_ip4_config (config, s_ip4);
-
-	g_object_set_data (G_OBJECT (req), NM_ACT_REQUEST_IP4_CONFIG, config);
-
-	assumed = nm_act_request_get_assumed (req);
-	if (nm_device_set_ip4_config (device, config, assumed, &reason)) {
-		nm_dhcp4_config_reset (priv->dhcp4_config);
-		nm_dhcp_manager_foreach_dhcp4_option (priv->dhcp_manager,
-		                                      ip_iface,
-		                                      dhcp4_add_option_cb,
-		                                      priv->dhcp4_config);
-	} else {
-		nm_warning ("Failed to update IP4 config in response to DHCP event.");
-		nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, reason);
-	}
-}
-
-static void
-dhcp_state_changed (NMDHCPManager *dhcp_manager,
-					const char *iface,
-					NMDHCPState state,
-					gpointer user_data)
-{
-	NMDevice *device = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (device);
-	NMDeviceState dev_state;
-
-	if (strcmp (nm_device_get_ip_iface (device), iface) != 0)
-		return;
-
-	if (!nm_device_get_act_request (device))
-		return;
-
-	dev_state = nm_device_get_state (device);
-
-	switch (state) {
-	case DHC_BOUND:	/* lease obtained */
-	case DHC_RENEW:	/* lease renewed */
-	case DHC_REBOOT:	/* have valid lease, but now obtained a different one */
-	case DHC_REBIND:	/* new, different lease */
-		if (dev_state == NM_DEVICE_STATE_IP_CONFIG)
-			nm_device_activate_schedule_stage4_ip4_config_get (device);
-		else if (dev_state == NM_DEVICE_STATE_ACTIVATED)
-			handle_dhcp_lease_change (device);
-		break;
-	case DHC_TIMEOUT: /* timed out contacting DHCP server */
-		nm_dhcp4_config_reset (priv->dhcp4_config);
-
-		if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
-			nm_device_activate_schedule_stage4_ip4_config_timeout (device);
-		break;
-	case DHC_FAIL: /* all attempts to contact server timed out, sleeping */
-	case DHC_ABEND: /* dhclient exited abnormally */
-	case DHC_END: /* dhclient exited normally */
-		nm_dhcp4_config_reset (priv->dhcp4_config);
-
-		if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG) {
-			nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DHCP_FAILED);
-		} else if (nm_device_get_state (device) == NM_DEVICE_STATE_ACTIVATED) {
-			if (nm_device_get_use_dhcp (device)) {
-				/* dhclient quit and therefore can't renew our lease, kill the conneciton */
-				nm_device_state_changed (device, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);
-			}
-		}
-		break;
-	default:
-		break;
-	}
-}
-
-static void
-dhcp_timeout (NMDHCPManager *dhcp_manager,
-              const char *iface,
-              gpointer user_data)
-{
-	NMDevice * device = NM_DEVICE (user_data);
-
-	if (strcmp (nm_device_get_ip_iface (device), iface) != 0)
-		return;
-
-	if (nm_device_get_state (device) == NM_DEVICE_STATE_IP_CONFIG)
-		nm_device_activate_schedule_stage4_ip4_config_timeout (device);
-}
-
-gboolean
-nm_device_get_use_dhcp (NMDevice *self)
-{
-	g_return_val_if_fail (NM_IS_DEVICE (self), FALSE);
-
-	return NM_DEVICE_GET_PRIVATE (self)->dhcp_manager ? TRUE : FALSE;
-}
-
-void
-nm_device_set_use_dhcp (NMDevice *self,
-                        gboolean use_dhcp)
-{
-	NMDevicePrivate *priv;
-
-	g_return_if_fail (NM_IS_DEVICE (self));
-
-	priv = NM_DEVICE_GET_PRIVATE (self);
-
-	if (use_dhcp) {
-		/* New exported DHCP4 config */
-		if (priv->dhcp4_config)
-			g_object_unref (priv->dhcp4_config);
-		priv->dhcp4_config = nm_dhcp4_config_new ();
-
-		if (!priv->dhcp_manager) {
-			priv->dhcp_manager = nm_dhcp_manager_get ();
-			priv->dhcp_state_sigid = g_signal_connect (priv->dhcp_manager,
-			                                           "state-changed",
-			                                           G_CALLBACK (dhcp_state_changed),
-			                                           self);
-			priv->dhcp_timeout_sigid = g_signal_connect (priv->dhcp_manager,
-			                                             "timeout",
-			                                             G_CALLBACK (dhcp_timeout),
-			                                             self);
-		}
-	} else {
-		if (priv->dhcp4_config) {
-			g_object_notify (G_OBJECT (self), NM_DEVICE_INTERFACE_DHCP4_CONFIG);
-			g_object_unref (priv->dhcp4_config);
-			priv->dhcp4_config = NULL;
-		}
-
-		if (priv->dhcp_manager) {
-			g_signal_handler_disconnect (priv->dhcp_manager, priv->dhcp_state_sigid);
-			priv->dhcp_state_sigid = 0;
-			g_signal_handler_disconnect (priv->dhcp_manager, priv->dhcp_timeout_sigid);
-			priv->dhcp_timeout_sigid = 0;
-			g_object_unref (priv->dhcp_manager);
-			priv->dhcp_manager = NULL;
-		}
-	}
-}
-
 NMDHCP4Config *
 nm_device_get_dhcp4_config (NMDevice *self)
 {
-	NMDevicePrivate *priv;
-
-	g_return_val_if_fail (NM_IS_DEVICE (self), FALSE);
-
-	priv = NM_DEVICE_GET_PRIVATE (self);
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
 
-	if (priv->dhcp_manager)
-		return priv->dhcp4_config;
-	return NULL;
+	return NM_DEVICE_GET_PRIVATE (self)->dhcp4_config;
 }
 
 NMIP4Config *
 nm_device_get_ip4_config (NMDevice *self)
 {
 	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
 
 	return NM_DEVICE_GET_PRIVATE (self)->ip4_config;
 }
@@ -2527,7 +2788,7 @@ nm_device_update_ip4_address (NMDevice *self)
 
 	fd = socket (PF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
-		nm_warning ("couldn't open control socket.");
+		nm_log_err (LOGD_IP4, "couldn't open control socket.");
 		return;
 	}
 
@@ -2602,10 +2863,20 @@ nm_device_set_ip6_config (NMDevice *self,
 	return success;
 }
 
+NMDHCP6Config *
+nm_device_get_dhcp6_config (NMDevice *self)
+{
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
+
+	return NM_DEVICE_GET_PRIVATE (self)->dhcp6_config;
+}
+
 NMIP6Config *
 nm_device_get_ip6_config (NMDevice *self)
 {
 	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (NM_IS_DEVICE (self), NULL);
 
 	return NM_DEVICE_GET_PRIVATE (self)->ip6_config;
 }
@@ -2632,7 +2903,7 @@ nm_device_hw_bring_up (NMDevice *self, gboolean block, gboolean *no_firmware)
 	if (nm_device_hw_is_up (self))
 		goto out;
 
-	nm_info ("(%s): bringing up device.", nm_device_get_iface (self));
+	nm_log_info (LOGD_HW, "(%s): bringing up device.", nm_device_get_iface (self));
 
 	if (NM_DEVICE_GET_CLASS (self)->hw_bring_up) {
 		success = NM_DEVICE_GET_CLASS (self)->hw_bring_up (self, no_firmware);
@@ -2645,7 +2916,7 @@ nm_device_hw_bring_up (NMDevice *self, gboolean block, gboolean *no_firmware)
 		g_usleep (200);
 
 	if (!nm_device_hw_is_up (self)) {
-		nm_warning ("(%s): device not up after timeout!", nm_device_get_iface (self));
+		nm_log_warn (LOGD_HW, "(%s): device not up after timeout!", nm_device_get_iface (self));
 		return FALSE;
 	}
 
@@ -2668,7 +2939,7 @@ nm_device_hw_take_down (NMDevice *self, gboolean block)
 	if (!nm_device_hw_is_up (self))
 		return;
 
-	nm_info ("(%s): taking down device.", nm_device_get_iface (self));
+	nm_log_info (LOGD_HW, "(%s): taking down device.", nm_device_get_iface (self));
 
 	if (NM_DEVICE_GET_CLASS (self)->hw_take_down)
 		NM_DEVICE_GET_CLASS (self)->hw_take_down (self);
@@ -2691,7 +2962,7 @@ nm_device_bring_up (NMDevice *self, gboolean block, gboolean *no_firmware)
 	if (nm_device_is_up (self))
 		return TRUE;
 
-	nm_info ("(%s): preparing device.", nm_device_get_iface (self));
+	nm_log_info (LOGD_HW, "(%s): preparing device.", nm_device_get_iface (self));
 
 	if (NM_DEVICE_GET_CLASS (self)->bring_up)
 		success = NM_DEVICE_GET_CLASS (self)->bring_up (self);
@@ -2708,7 +2979,7 @@ nm_device_take_down (NMDevice *self, gboolean block, NMDeviceStateReason reason)
 		nm_device_interface_deactivate (NM_DEVICE_INTERFACE (self), reason);
 
 	if (nm_device_is_up (self)) {
-		nm_info ("(%s): cleaning up...", nm_device_get_iface (self));
+		nm_log_info (LOGD_HW, "(%s): cleaning up...", nm_device_get_iface (self));
 
 		if (NM_DEVICE_GET_CLASS (self)->take_down)
 			NM_DEVICE_GET_CLASS (self)->take_down (self);
@@ -2761,6 +3032,13 @@ dispose (GObject *object)
 	/* Clear any delayed transitions */
 	delayed_transitions_clear (self);
 
+	/* Clean up and stop DHCP */
+	dhcp4_cleanup (self, take_down);
+	dhcp6_cleanup (self, take_down);
+	addrconf6_cleanup (self);
+	dnsmasq_cleanup (self);
+
+	/* Take the device itself down and clear its IPv4 configuration */
 	if (priv->managed && take_down) {
 		NMDeviceStateReason ignored = NM_DEVICE_STATE_REASON_NONE;
 
@@ -2768,26 +3046,10 @@ dispose (GObject *object)
 		nm_device_set_ip4_config (self, NULL, FALSE, &ignored);
 	}
 
-	clear_act_request (self);
-
 	activation_source_clear (self, TRUE, AF_INET);
 	activation_source_clear (self, TRUE, AF_INET6);
 
-	if (!take_down) {
-		nm_device_set_use_dhcp (self, FALSE);
-		nm_device_cleanup_ip6 (self);
-	}
-
-	if (priv->dnsmasq_manager) {
-		if (priv->dnsmasq_state_id) {
-			g_signal_handler_disconnect (priv->dnsmasq_manager, priv->dnsmasq_state_id);
-			priv->dnsmasq_state_id = 0;
-		}
-
-		nm_dnsmasq_manager_stop (priv->dnsmasq_manager);
-		g_object_unref (priv->dnsmasq_manager);
-		priv->dnsmasq_manager = NULL;
-	}
+	clear_act_request (self);
 
 out:
 	G_OBJECT_CLASS (nm_device_parent_class)->dispose (object);
@@ -2799,6 +3061,8 @@ finalize (GObject *object)
 	NMDevice *self = NM_DEVICE (object);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	g_object_unref (priv->dhcp_manager);
+
 	g_free (priv->udi);
 	g_free (priv->iface);
 	g_free (priv->ip_iface);
@@ -2846,6 +3110,9 @@ set_property (GObject *object, guint prop_id,
 		g_free (priv->type_desc);
 		priv->type_desc = g_value_dup_string (value);
 		break;
+	case NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE:
+		priv->rfkill_type = g_value_get_uint (value);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -2889,7 +3156,7 @@ get_property (GObject *object, guint prop_id,
 		break;
 	case NM_DEVICE_INTERFACE_PROP_DHCP4_CONFIG:
 		if (   ((state == NM_DEVICE_STATE_ACTIVATED) || (state == NM_DEVICE_STATE_IP_CONFIG))
-		    && nm_device_get_use_dhcp (self))
+		    && priv->dhcp4_client)
 			g_value_set_boxed (value, nm_dhcp4_config_get_dbus_path (priv->dhcp4_config));
 		else
 			g_value_set_boxed (value, "/");
@@ -2903,6 +3170,13 @@ get_property (GObject *object, guint prop_id,
 		}
 		g_value_set_boxed (value, "/");
 		break;
+	case NM_DEVICE_INTERFACE_PROP_DHCP6_CONFIG:
+		if (   ((state == NM_DEVICE_STATE_ACTIVATED) || (state == NM_DEVICE_STATE_IP_CONFIG))
+		    && priv->dhcp6_client)
+			g_value_set_boxed (value, nm_dhcp6_config_get_dbus_path (priv->dhcp6_config));
+		else
+			g_value_set_boxed (value, "/");
+		break;
 	case NM_DEVICE_INTERFACE_PROP_STATE:
 		g_value_set_uint (value, priv->state);
 		break;
@@ -2915,6 +3189,9 @@ get_property (GObject *object, guint prop_id,
 	case NM_DEVICE_INTERFACE_PROP_TYPE_DESC:
 		g_value_set_string (value, priv->type_desc);
 		break;
+	case NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE:
+		g_value_set_uint (value, priv->rfkill_type);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -2982,6 +3259,10 @@ nm_device_class_init (NMDeviceClass *klass)
 									  NM_DEVICE_INTERFACE_IP6_CONFIG);
 
 	g_object_class_override_property (object_class,
+	                                  NM_DEVICE_INTERFACE_PROP_DHCP6_CONFIG,
+	                                  NM_DEVICE_INTERFACE_DHCP6_CONFIG);
+
+	g_object_class_override_property (object_class,
 									  NM_DEVICE_INTERFACE_PROP_STATE,
 									  NM_DEVICE_INTERFACE_STATE);
 
@@ -2997,6 +3278,10 @@ nm_device_class_init (NMDeviceClass *klass)
 									  NM_DEVICE_INTERFACE_PROP_TYPE_DESC,
 									  NM_DEVICE_INTERFACE_TYPE_DESC);
 
+	g_object_class_override_property (object_class,
+	                                  NM_DEVICE_INTERFACE_PROP_RFKILL_TYPE,
+	                                  NM_DEVICE_INTERFACE_RFKILL_TYPE);
+
 	signals[AUTOCONNECT_ALLOWED] =
 		g_signal_new ("autoconnect-allowed",
 		              G_OBJECT_CLASS_TYPE (object_class),
@@ -3013,6 +3298,8 @@ failed_to_disconnected (gpointer user_data)
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_DEVICE, "(%s): running failed->disconnected transition",
+	            nm_device_get_iface (self));
 	priv->failed_to_disconnected_id = 0;
 	nm_device_state_changed (self, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
 	return FALSE;
@@ -3024,6 +3311,8 @@ unavailable_to_disconnected (gpointer user_data)
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	nm_log_dbg (LOGD_DEVICE, "(%s): running unavailable->disconnected transition",
+	            nm_device_get_iface (self));
 	priv->unavailable_to_disconnected_id = 0;
 	nm_device_state_changed (self, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
 	return FALSE;
@@ -3047,8 +3336,8 @@ nm_device_state_changed (NMDevice *device,
 	old_state = priv->state;
 	priv->state = state;
 
-	nm_info ("(%s): device state change: %d -> %d (reason %d)",
-	         nm_device_get_iface (device), old_state, state, reason);
+	nm_log_info (LOGD_DEVICE, "(%s): device state change: %d -> %d (reason %d)",
+	             nm_device_get_iface (device), old_state, state, reason);
 
 	/* Clear any delayed transitions */
 	delayed_transitions_clear (device);
@@ -3066,8 +3355,9 @@ nm_device_state_changed (NMDevice *device,
 		break;
 	case NM_DEVICE_STATE_UNAVAILABLE:
 		if (old_state == NM_DEVICE_STATE_UNMANAGED) {
-			if (!nm_device_bring_up (device, TRUE, &no_firmware) && no_firmware)
-				nm_warning ("%s: firmware may be missing.", nm_device_get_iface (device));
+			if (!nm_device_bring_up (device, TRUE, &no_firmware) && no_firmware) {
+				nm_log_warn (LOGD_HW, "%s: firmware may be missing.", nm_device_get_iface (device));
+			}
 		}
 		/* Ensure the device gets deactivated in response to stuff like
 		 * carrier changes or rfkill.  But don't deactivate devices that are
@@ -3099,15 +3389,22 @@ nm_device_state_changed (NMDevice *device,
 		 * we can't change states again from the state handler for a variety of
 		 * reasons.
 		 */
-		if (nm_device_is_available (device))
+		if (nm_device_is_available (device)) {
+			nm_log_dbg (LOGD_DEVICE, "(%s): device is available, will transition to DISCONNECTED",
+			            nm_device_get_iface (device));
 			priv->unavailable_to_disconnected_id = g_idle_add (unavailable_to_disconnected, device);
+		} else {
+			nm_log_dbg (LOGD_DEVICE, "(%s): device not yet available for transition to DISCONNECTED",
+			            nm_device_get_iface (device));
+		}
 		break;
 	case NM_DEVICE_STATE_ACTIVATED:
-		nm_info ("Activation (%s) successful, device activated.", nm_device_get_iface (device));
+		nm_log_info (LOGD_DEVICE, "Activation (%s) successful, device activated.",
+		             nm_device_get_iface (device));
 		nm_utils_call_dispatcher ("up", nm_act_request_get_connection (req), device, NULL);
 		break;
 	case NM_DEVICE_STATE_FAILED:
-		nm_info ("Activation (%s) failed.", nm_device_get_iface (device));
+		nm_log_warn (LOGD_DEVICE, "Activation (%s) failed.", nm_device_get_iface (device));
 		/* Schedule the transition to DISCONNECTED.  The device can't transition
 		 * immediately becuase we can't change states again from the state
 		 * handler for a variety of reasons.
@@ -3156,7 +3453,9 @@ nm_device_set_managed (NMDevice *device,
 		return;
 
 	priv->managed = managed;
-	nm_info ("(%s): now %s", nm_device_get_iface (device), managed ? "managed" : "unmanaged");
+	nm_log_info (LOGD_DEVICE, "(%s): now %s",
+	             nm_device_get_iface (device),
+	             managed ? "managed" : "unmanaged");
 
 	g_object_notify (G_OBJECT (device), NM_DEVICE_INTERFACE_MANAGED);
 
diff --git a/src/nm-device.h b/src/nm-device.h
index b81c460..5fcde5c 100644
--- a/src/nm-device.h
+++ b/src/nm-device.h
@@ -31,6 +31,7 @@
 #include "nm-ip4-config.h"
 #include "nm-ip6-config.h"
 #include "nm-dhcp4-config.h"
+#include "nm-dhcp6-config.h"
 #include "nm-connection.h"
 
 typedef enum NMActStageReturn
@@ -140,10 +141,8 @@ int			nm_device_get_priority (NMDevice *dev);
 guint32			nm_device_get_ip4_address	(NMDevice *dev);
 void				nm_device_update_ip4_address	(NMDevice *dev);
 
-gboolean		nm_device_get_use_dhcp	(NMDevice *dev);
-void			nm_device_set_use_dhcp	(NMDevice *dev,
-								 gboolean use_dhcp);
 NMDHCP4Config * nm_device_get_dhcp4_config (NMDevice *dev);
+NMDHCP6Config * nm_device_get_dhcp6_config (NMDevice *dev);
 
 NMIP4Config *	nm_device_get_ip4_config	(NMDevice *dev);
 NMIP6Config *	nm_device_get_ip6_config	(NMDevice *dev);
diff --git a/src/nm-dhcp6-config.c b/src/nm-dhcp6-config.c
new file mode 100644
index 0000000..fb6ccce
--- /dev/null
+++ b/src/nm-dhcp6-config.c
@@ -0,0 +1,192 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ */
+
+#include <glib.h>
+#include <string.h>
+
+#include "NetworkManager.h"
+#include "nm-dbus-manager.h"
+#include "nm-dhcp6-config.h"
+#include "nm-dhcp6-config-glue.h"
+#include "nm-dbus-glib-types.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-utils.h"
+
+
+G_DEFINE_TYPE (NMDHCP6Config, nm_dhcp6_config, G_TYPE_OBJECT)
+
+#define NM_DHCP6_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigPrivate))
+
+typedef struct {
+	char *dbus_path;
+	GHashTable *options;
+} NMDHCP6ConfigPrivate;
+
+
+enum {
+	PROP_0,
+	PROP_OPTIONS,
+
+	LAST_PROP
+};
+
+enum {
+	PROPERTIES_CHANGED,
+
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+
+NMDHCP6Config *
+nm_dhcp6_config_new (void)
+{
+	return NM_DHCP6_CONFIG (g_object_new (NM_TYPE_DHCP6_CONFIG, NULL));
+}
+
+void
+nm_dhcp6_config_add_option (NMDHCP6Config *self,
+                            const char *key,
+                            const char *option)
+{
+	GValue *svalue;
+
+	g_return_if_fail (NM_IS_DHCP6_CONFIG (self));
+	g_return_if_fail (key != NULL);
+	g_return_if_fail (option != NULL);
+
+	svalue = g_slice_new0 (GValue);
+	g_value_init (svalue, G_TYPE_STRING);
+	g_value_set_string (svalue, option);
+	g_hash_table_insert (NM_DHCP6_CONFIG_GET_PRIVATE (self)->options, g_strdup (key), svalue);
+	g_object_notify (G_OBJECT (self), NM_DHCP6_CONFIG_OPTIONS);
+}
+
+void
+nm_dhcp6_config_reset (NMDHCP6Config *self)
+{
+	g_return_if_fail (NM_IS_DHCP6_CONFIG (self));
+
+	g_hash_table_remove_all (NM_DHCP6_CONFIG_GET_PRIVATE (self)->options);
+	g_object_notify (G_OBJECT (self), NM_DHCP6_CONFIG_OPTIONS);
+}
+
+const char *
+nm_dhcp6_config_get_option (NMDHCP6Config *self, const char *key)
+{
+	GValue *value;
+
+	g_return_val_if_fail (NM_IS_DHCP6_CONFIG (self), NULL);
+	g_return_val_if_fail (key != NULL, NULL);
+
+	value = g_hash_table_lookup (NM_DHCP6_CONFIG_GET_PRIVATE (self)->options, key);
+	return value ? g_value_get_string (value) : NULL;
+}
+
+const char *
+nm_dhcp6_config_get_dbus_path (NMDHCP6Config *self)
+{
+	g_return_val_if_fail (NM_IS_DHCP6_CONFIG (self), NULL);
+
+	return NM_DHCP6_CONFIG_GET_PRIVATE (self)->dbus_path;
+}
+
+static void
+nm_gvalue_destroy (gpointer data)
+{
+	GValue *value = (GValue *) data;
+
+	g_value_unset (value);
+	g_slice_free (GValue, value);
+}
+
+static void
+nm_dhcp6_config_init (NMDHCP6Config *self)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (self);
+	static guint32 counter = 0;
+	DBusGConnection *connection;
+	NMDBusManager *dbus_mgr;
+
+	dbus_mgr = nm_dbus_manager_get ();
+	connection = nm_dbus_manager_get_connection (dbus_mgr);
+	priv->dbus_path = g_strdup_printf (NM_DBUS_PATH "/DHCP6Config/%d", counter++);
+	dbus_g_connection_register_g_object (connection, priv->dbus_path, G_OBJECT (self));
+	g_object_unref (dbus_mgr);
+
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, nm_gvalue_destroy);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+
+	g_free (priv->dbus_path);
+	g_hash_table_destroy (priv->options);
+
+	G_OBJECT_CLASS (nm_dhcp6_config_parent_class)->finalize (object);
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMDHCP6ConfigPrivate *priv = NM_DHCP6_CONFIG_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_OPTIONS:
+		g_value_set_boxed (value, priv->options);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_dhcp6_config_class_init (NMDHCP6ConfigClass *config_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (config_class);
+
+	g_type_class_add_private (config_class, sizeof (NMDHCP6ConfigPrivate));
+
+	/* virtual methods */
+	object_class->get_property = get_property;
+	object_class->finalize = finalize;
+
+	/* properties */
+	g_object_class_install_property
+		(object_class, PROP_OPTIONS,
+		 g_param_spec_boxed (NM_DHCP6_CONFIG_OPTIONS,
+		                     "Options",
+		                     "DHCP configuration options returned by the server",
+		                     DBUS_TYPE_G_MAP_OF_VARIANT,
+		                     G_PARAM_READABLE));
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+								    G_STRUCT_OFFSET (NMDHCP6ConfigClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (config_class),
+									 &dbus_glib_nm_dhcp6_config_object_info);
+}
diff --git a/src/nm-dhcp6-config.h b/src/nm-dhcp6-config.h
new file mode 100644
index 0000000..90eb10f
--- /dev/null
+++ b/src/nm-dhcp6-config.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ */
+
+#ifndef NM_DHCP6_CONFIG_H
+#define NM_DHCP6_CONFIG_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define NM_TYPE_DHCP6_CONFIG            (nm_dhcp6_config_get_type ())
+#define NM_DHCP6_CONFIG(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DHCP6_CONFIG, NMDHCP6Config))
+#define NM_DHCP6_CONFIG_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigClass))
+#define NM_IS_DHCP6_CONFIG(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+#define NM_IS_DHCP6_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DHCP6_CONFIG))
+#define NM_DHCP6_CONFIG_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DHCP6_CONFIG, NMDHCP6ConfigClass))
+
+typedef struct {
+	GObject parent;
+} NMDHCP6Config;
+
+typedef struct {
+	GObjectClass parent;
+
+	/* Signals */
+	void (*properties_changed) (NMDHCP6Config *config, GHashTable *properties);
+} NMDHCP6ConfigClass;
+
+#define NM_DHCP6_CONFIG_OPTIONS "options"
+
+GType nm_dhcp6_config_get_type (void);
+
+NMDHCP6Config *nm_dhcp6_config_new (void);
+
+const char *nm_dhcp6_config_get_dbus_path (NMDHCP6Config *config);
+
+void nm_dhcp6_config_add_option (NMDHCP6Config *config,
+                                 const char *key,
+                                 const char *option);
+
+void nm_dhcp6_config_reset (NMDHCP6Config *config);
+
+const char *nm_dhcp6_config_get_option (NMDHCP6Config *config, const char *option);
+
+#endif /* NM_DHCP6_CONFIG_H */
diff --git a/src/nm-logging.c b/src/nm-logging.c
deleted file mode 100644
index f474615..0000000
--- a/src/nm-logging.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#define _GNU_SOURCE
-#include <dlfcn.h>
-#include <syslog.h>
-#include <execinfo.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/wait.h>
-#include <sys/stat.h>
-#include <execinfo.h>
-
-#include "nm-logging.h"
-#include "nm-utils.h"
-
-static void
-fallback_get_backtrace (void)
-{
-	void *frames[64];
-	Dl_info info;
-	size_t size;
-	guint32 i;
-	const char *name;
-
-	size = backtrace (frames, G_N_ELEMENTS (frames));
-
-	syslog (LOG_CRIT, "******************* START **********************************");
-	for (i = 0; i < size; i++) {
-		dladdr (frames[i], &info);
-		name = (info.dli_fname && *info.dli_fname) ? info.dli_fname : "(vdso)";
-		if (info.dli_saddr) {
-			syslog (LOG_CRIT, "Frame %d: %s (%s+0x%lx) [%p]",
-			        i, name,
-			        info.dli_sname,
-			        (gulong)(frames[i] - info.dli_saddr),
-			        frames[i]);
-		} else {
-			syslog (LOG_CRIT, "Frame %d: %s (%p+0x%lx) [%p]",
-			        i, name,
-			        info.dli_fbase,
-			        (gulong)(frames[i] - info.dli_saddr),
-			        frames[i]);
-		}
-	}
-	syslog (LOG_CRIT, "******************* END **********************************");
-}
-
-
-static gboolean
-crashlogger_get_backtrace (void)
-{
-	gboolean success = FALSE;
-	int pid;	
-
-	pid = fork();
-	if (pid > 0)
-	{
-		/* Wait for the child to finish */
-		int estatus;
-		if (waitpid (pid, &estatus, 0) != -1)
-		{
-			/* Only succeed if the crashlogger succeeded */
-			if (WIFEXITED (estatus) && (WEXITSTATUS (estatus) == 0))
-				success = TRUE;
-		}
-	}
-	else if (pid == 0)
-	{
-		/* Child process */
-		execl (LIBEXECDIR"/nm-crash-logger",
-				LIBEXECDIR"/nm-crash-logger", NULL);
-	}
-
-	return success;
-}
-
-
-void
-nm_logging_backtrace (void)
-{
-	struct stat s;
-	gboolean fallback = TRUE;
-	
-	/* Try to use gdb via nm-crash-logger if it exists, since
-	 * we get much better information out of it.  Otherwise
-	 * fall back to execinfo.
-	 */
-	if (stat (LIBEXECDIR"/nm-crash-logger", &s) == 0)
-		fallback = crashlogger_get_backtrace () ? FALSE : TRUE;
-
-	if (fallback)
-		fallback_get_backtrace ();
-}
-
-
-static void
-nm_log_handler (const gchar *		log_domain,
-			  GLogLevelFlags	log_level,
-			  const gchar *	message,
-			  gpointer		ignored)
-{
-	int syslog_priority;	
-
-	switch (log_level)
-	{
-		case G_LOG_LEVEL_ERROR:
-			syslog_priority = LOG_CRIT;
-			break;
-
-		case G_LOG_LEVEL_CRITICAL:
-			syslog_priority = LOG_ERR;
-			break;
-
-		case G_LOG_LEVEL_WARNING:
-			syslog_priority = LOG_WARNING;
-			break;
-
-		case G_LOG_LEVEL_MESSAGE:
-			syslog_priority = LOG_NOTICE;
-			break;
-
-		case G_LOG_LEVEL_DEBUG:
-			syslog_priority = LOG_DEBUG;
-			break;
-
-		case G_LOG_LEVEL_INFO:
-		default:
-			syslog_priority = LOG_INFO;
-			break;
-	}
-
-	syslog (syslog_priority, "%s", message);
-}
-
-
-void
-nm_logging_setup (gboolean become_daemon)
-{
-	if (become_daemon)
-		openlog (G_LOG_DOMAIN, 0, LOG_DAEMON);
-	else
-		openlog (G_LOG_DOMAIN, LOG_CONS | LOG_PERROR, LOG_USER);
-
-	g_log_set_handler (G_LOG_DOMAIN, 
-				    G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION,
-				    nm_log_handler,
-				    NULL);
-}
-
-void
-nm_logging_shutdown (void)
-{
-	closelog ();
-}
diff --git a/src/nm-logging.h b/src/nm-logging.h
deleted file mode 100644
index 70979fa..0000000
--- a/src/nm-logging.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager -- Network link manager
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
- * Copyright (C) 2006 - 2008 Novell, Inc.
- */
-
-#ifndef NM_LOGGING_H
-#define NM_LOGGING_H
-
-#include <glib.h>
-
-void nm_logging_setup     (gboolean become_daemon);
-void nm_logging_backtrace (void);
-void nm_logging_shutdown  (void);
-
-#endif /* NM_LOGGING_H */
diff --git a/src/nm-manager.c b/src/nm-manager.c
index ff75355..6eaf6a5 100644
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Copyright (C) 2007 - 2009 Novell, Inc.
- * Copyright (C) 2007 - 2009 Red Hat, Inc.
+ * Copyright (C) 2007 - 2010 Red Hat, Inc.
  */
 
 #include <netinet/ether.h>
@@ -26,18 +26,19 @@
 
 #include "nm-glib-compat.h"
 #include "nm-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-dbus-manager.h"
 #include "nm-vpn-manager.h"
 #include "nm-modem-manager.h"
-#include "nm-modem.h"
 #include "nm-device-bt.h"
 #include "nm-device-interface.h"
 #include "nm-device-private.h"
 #include "nm-device-ethernet.h"
 #include "nm-device-wifi.h"
 #include "nm-device-olpc-mesh.h"
-#include "NetworkManagerSystem.h"
+#include "nm-device-cdma.h"
+#include "nm-device-gsm.h"
+#include "nm-system.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-setting-bluetooth.h"
 #include "nm-setting-connection.h"
@@ -78,6 +79,11 @@ static gboolean impl_manager_deactivate_connection (NMManager *manager,
 
 static gboolean impl_manager_sleep (NMManager *manager, gboolean sleep, GError **err);
 
+static gboolean impl_manager_set_logging (NMManager *manager,
+                                          const char *level,
+                                          const char *domains,
+                                          GError **error);
+
 /* Legacy 0.6 compatibility interface */
 
 static gboolean impl_manager_legacy_sleep (NMManager *manager, GError **err);
@@ -127,15 +133,15 @@ static const char *internal_activate_device (NMManager *manager,
                                              gboolean assumed,
                                              GError **error);
 
-static NMDevice *
-find_device_by_iface (NMManager *self, const gchar *iface);
+static NMDevice *find_device_by_iface (NMManager *self, const gchar *iface);
 
-static GSList *
-remove_one_device (NMManager *manager,
-                   GSList *list,
-                   NMDevice *device,
-                   gboolean quitting,
-                   gboolean force_unmanage);
+static GSList * remove_one_device (NMManager *manager,
+                                   GSList *list,
+                                   NMDevice *device,
+                                   gboolean quitting,
+                                   gboolean force_unmanage);
+
+static NMDevice *nm_manager_get_device_by_udi (NMManager *manager, const char *udi);
 
 #define SSD_POKE_INTERVAL 120
 #define ORIGDEV_TAG "originating-device"
@@ -152,16 +158,12 @@ typedef struct {
 typedef struct {
 	gboolean enabled;
 	gboolean hw_enabled;
+	RfKillType rtype;
 	const char *desc;
 	const char *key;
 	const char *prop;
 	const char *hw_prop;
-	/* Hack for WWAN for 0.8 release; we'll start using udev
-	 * after 0.8 gets out.
-	 */
-	gboolean ignore_udev;
 	RfKillState (*other_enabled_func) (NMManager *);
-	gboolean (*object_filter_func) (GObject *);
 } RadioState;
 
 typedef struct {
@@ -310,26 +312,17 @@ vpn_manager_connection_deactivated_cb (NMVPNManager *manager,
 
 static void
 modem_added (NMModemManager *modem_manager,
-			 NMDevice *modem,
+			 NMModem *modem,
+			 const char *driver,
 			 gpointer user_data)
 {
-	NMManagerPrivate *priv;
-	NMDeviceType type;
-	NMDevice *replace_device;
-	const char *type_name;
+	NMManager *self = NM_MANAGER (user_data);
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMDevice *replace_device, *device = NULL;
 	const char *ip_iface;
+	GSList *iter;
 
-	priv = NM_MANAGER_GET_PRIVATE (user_data);
-
-	type = nm_device_get_device_type (NM_DEVICE (modem));
-	if (type == NM_DEVICE_TYPE_GSM)
-		type_name = "GSM modem";
-	else if (type == NM_DEVICE_TYPE_CDMA)
-		type_name = "CDMA modem";
-	else
-		type_name = "Unknown modem";
-
-	ip_iface = nm_device_get_ip_iface (modem);
+	ip_iface = nm_modem_get_iface (modem);
 
 	replace_device = find_device_by_iface (NM_MANAGER (user_data), ip_iface);
 	if (replace_device) {
@@ -340,7 +333,33 @@ modem_added (NMModemManager *modem_manager,
 		                                   TRUE);
 	}
 
-	add_device (NM_MANAGER (user_data), NM_DEVICE (g_object_ref (modem)));
+	/* Give Bluetooth DUN devices first chance to claim the modem */
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		if (NM_IS_DEVICE_BT (iter->data)) {
+			if (nm_device_bt_modem_added (NM_DEVICE_BT (iter->data), modem, driver))
+				return;
+		}
+	}
+
+	/* If it was a Bluetooth modem and no bluetooth device claimed it, ignore
+	 * it.  The rfcomm port (and thus the modem) gets created automatically
+	 * by the Bluetooth code during the connection process.
+	 */
+	if (driver && !strcmp (driver, "bluetooth")) {
+		nm_log_info (LOGD_MB, "ignoring modem '%s' (no associated Bluetooth device)", ip_iface);
+		return;
+	}
+
+	/* Otherwise make a new top-level NMDevice for it */
+	if (NM_IS_MODEM_GSM (modem))
+		device = nm_device_gsm_new (NM_MODEM_GSM (modem), driver);
+	else if (NM_IS_MODEM_CDMA (modem))
+		device = nm_device_cdma_new (NM_MODEM_CDMA (modem), driver);
+	else
+		nm_log_info (LOGD_MB, "unhandled modem '%s'", ip_iface);
+
+	if (device)
+		add_device (self, device);
 }
 
 static void
@@ -438,13 +457,26 @@ remove_one_device (NMManager *manager,
 
 static void
 modem_removed (NMModemManager *modem_manager,
-			   NMDevice *modem,
+			   NMModem *modem,
 			   gpointer user_data)
 {
 	NMManager *self = NM_MANAGER (user_data);
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMDevice *found;
+	GSList *iter;
+
+	/* Give Bluetooth DUN devices first chance to handle the modem removal */
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		if (NM_IS_DEVICE_BT (iter->data)) {
+			if (nm_device_bt_modem_removed (NM_DEVICE_BT (iter->data), modem))
+				return;
+		}
+	}
 
-	priv->devices = remove_one_device (self, priv->devices, modem, FALSE, TRUE);
+	/* Otherwise remove the standalone modem */
+	found = nm_manager_get_device_by_udi (self, nm_modem_get_path (modem));
+	if (found)
+		priv->devices = remove_one_device (self, priv->devices, found, FALSE, TRUE);
 }
 
 static void
@@ -460,7 +492,7 @@ aipd_handle_event (DBusGProxy *proxy,
 	gboolean handled = FALSE;
 
 	if (!event || !iface) {
-		nm_warning ("Incomplete message received from avahi-autoipd");
+		nm_log_warn (LOGD_AUTOIP4, "incomplete message received from avahi-autoipd");
 		return;
 	}
 
@@ -468,7 +500,7 @@ aipd_handle_event (DBusGProxy *proxy,
 	    && (strcmp (event, "CONFLICT") != 0)
 	    && (strcmp (event, "UNBIND") != 0)
 	    && (strcmp (event, "STOP") != 0)) {
-		nm_warning ("Unknown event '%s' received from avahi-autoipd", event);
+		nm_log_warn (LOGD_AUTOIP4, "unknown event '%s' received from avahi-autoipd", event);
 		return;
 	}
 
@@ -483,7 +515,7 @@ aipd_handle_event (DBusGProxy *proxy,
 	}
 
 	if (!handled)
-		nm_warning ("Unhandled avahi-autoipd event for '%s'", iface);
+		nm_log_warn (LOGD_AUTOIP4, "(%s): unhandled avahi-autoipd event", iface);
 }
 
 static const char *
@@ -665,7 +697,8 @@ user_connection_get_settings_cb  (DBusGProxy *proxy,
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, &settings,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("Couldn't retrieve connection settings: %s.", err->message);
+		nm_log_info (LOGD_USER_SET, "couldn't retrieve connection settings: %s.",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		goto out;
 	}
@@ -680,10 +713,9 @@ user_connection_get_settings_cb  (DBusGProxy *proxy,
 
 		connection = nm_connection_new_from_hash (settings, &error);
 		if (connection == NULL) {
-			nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-			            __func__,
-			            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
-			            error->message, error->code);
+			nm_log_warn (LOGD_USER_SET, "invalid connection: '%s' / '%s' invalid: %d",
+			             g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+			             error->message, error->code);
 			g_error_free (error);
 			goto out;
 		}
@@ -726,7 +758,7 @@ user_connection_get_settings_cb  (DBusGProxy *proxy,
 		}
 	} else {
 		// FIXME: merge settings? or just replace?
-		nm_warning ("%s (#%d): implement merge settings", __func__, __LINE__);
+		nm_log_dbg (LOGD_USER_SET, "implement merge settings");
 	}
 
 out:
@@ -774,10 +806,9 @@ user_connection_updated_cb (DBusGProxy *proxy,
 	new_connection = nm_connection_new_from_hash (settings, &error);
 	if (!new_connection) {
 		/* New connection invalid, remove existing connection */
-		nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-		            __func__,
-		            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
-		            error->message, error->code);
+		nm_log_warn (LOGD_USER_SET, "invalid connection: '%s' / '%s' invalid: %d",
+		             g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+		             error->message, error->code);
 		g_error_free (error);
 		remove_connection (manager, old_connection, priv->user_connections);
 		return;
@@ -814,7 +845,7 @@ user_internal_new_connection_cb (DBusGProxy *proxy,
 	                                       path,
 	                                       NM_DBUS_IFACE_SETTINGS_CONNECTION);
 	if (!con_proxy) {
-		nm_warning ("Error: could not init user connection proxy");
+		nm_log_err (LOGD_USER_SET, "could not init user connection proxy");
 		return;
 	}
 
@@ -860,7 +891,8 @@ user_list_connections_cb  (DBusGProxy *proxy,
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_ARRAY_OF_OBJECT_PATH, &ops,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("Couldn't retrieve connections: %s.", err->message);
+		nm_log_warn (LOGD_USER_SET, "couldn't retrieve connections: %s",
+		             err && err->message ? err->message : "(unknown)");
 		g_error_free (err);
 		goto out;
 	}
@@ -906,7 +938,7 @@ user_query_connections (NMManager *manager)
 		                                              NM_DBUS_PATH_SETTINGS,
 		                                              NM_DBUS_IFACE_SETTINGS);
 		if (!priv->user_proxy) {
-			nm_warning ("Error: could not init settings proxy");
+			nm_log_err (LOGD_USER_SET, "could not init user settings proxy");
 			return;
 		}
 
@@ -949,16 +981,15 @@ system_connection_updated_cb (NMSettingsConnectionInterface *connection,
 	if (!existing)
 		return;
 	if (existing != connection) {
-		g_warning ("%s: existing connection didn't matched updated.", __func__);
+		nm_log_warn (LOGD_SYS_SET, "existing connection didn't matched updated.");
 		return;
 	}
 
 	if (!nm_connection_verify (NM_CONNECTION (existing), &error)) {
 		/* Updated connection invalid, remove existing connection */
-		nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-		            __func__,
-		            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
-		            error->message, error->code);
+		nm_log_warn (LOGD_SYS_SET, "invalid connection: '%s' / '%s' invalid: %d",
+		             g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+		             error->message, error->code);
 		g_error_free (error);
 		remove_connection (manager, NM_CONNECTION (existing), priv->system_connections);
 		return;
@@ -1200,10 +1231,10 @@ manager_set_radio_enabled (NMManager *manager,
 		                                "main", rstate->key,
 		                                G_TYPE_BOOLEAN, (gpointer) &enabled,
 		                                &error)) {
-			g_warning ("Writing to state file %s failed: (%d) %s.",
-			           priv->state_file,
-			           error ? error->code : -1,
-			           (error && error->message) ? error->message : "unknown");
+			nm_log_warn (LOGD_CORE, "writing to state file %s failed: (%d) %s.",
+			             priv->state_file,
+			             error ? error->code : -1,
+			             (error && error->message) ? error->message : "unknown");
 		}
 	}
 
@@ -1213,9 +1244,15 @@ manager_set_radio_enabled (NMManager *manager,
 
 	/* enable/disable wireless devices as required */
 	for (iter = priv->devices; iter; iter = iter->next) {
-		if (   rstate->object_filter_func
-			&& rstate->object_filter_func (G_OBJECT (iter->data)))
+		RfKillType devtype = RFKILL_TYPE_UNKNOWN;
+
+		g_object_get (G_OBJECT (iter->data), NM_DEVICE_INTERFACE_RFKILL_TYPE, &devtype, NULL);
+		if (devtype == rstate->rtype) {
+			nm_log_dbg (LOGD_RFKILL, "(%s): setting radio %s",
+			            nm_device_get_iface (NM_DEVICE (iter->data)),
+			            enabled ? "enabled" : "disabled");
 			nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (iter->data), enabled);
+		}
 	}
 }
 
@@ -1314,9 +1351,11 @@ nm_manager_get_modem_enabled_state (NMManager *self)
 	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
 		NMDevice *candidate = NM_DEVICE (iter->data);
 		RfKillState candidate_state = RFKILL_UNBLOCKED;
+		RfKillType devtype = RFKILL_TYPE_UNKNOWN;
 
-		if (NM_IS_MODEM (candidate)) {
-			if (nm_modem_get_mm_enabled (NM_MODEM (candidate)) == FALSE)
+		g_object_get (G_OBJECT (candidate), NM_DEVICE_INTERFACE_RFKILL_TYPE, &devtype, NULL);
+		if (devtype == RFKILL_TYPE_WWAN) {
+			if (!nm_device_interface_get_enabled (NM_DEVICE_INTERFACE (candidate)))
 				candidate_state = RFKILL_SOFT_BLOCKED;
 
 			if (candidate_state > wwan_state)
@@ -1327,18 +1366,6 @@ nm_manager_get_modem_enabled_state (NMManager *self)
 	return wwan_state;
 }
 
-static gboolean
-rfkill_wlan_filter (GObject *object)
-{
-	return NM_IS_DEVICE_WIFI (object);
-}
-
-static gboolean
-rfkill_wwan_filter (GObject *object)
-{
-	return NM_IS_MODEM (object);
-}
-
 static void
 manager_rfkill_update_one_type (NMManager *self,
                                 RadioState *rstate,
@@ -1350,8 +1377,7 @@ manager_rfkill_update_one_type (NMManager *self,
 	RfKillState composite;
 	gboolean new_e = TRUE, new_he = TRUE;
 
-	if (!rstate->ignore_udev)
-		udev_state = nm_udev_manager_get_rfkill_state (priv->udev_mgr, rtype);
+	udev_state = nm_udev_manager_get_rfkill_state (priv->udev_mgr, rtype);
 
 	if (rstate->other_enabled_func)
 		other_state = rstate->other_enabled_func (self);
@@ -1381,13 +1407,19 @@ manager_rfkill_update_one_type (NMManager *self,
 		break;
 	}
 
+	if (rstate->desc) {
+		nm_log_dbg (LOGD_RFKILL, "%s hw-enabled %d enabled %d",
+		            rstate->desc, new_he, new_e);
+	}
+
 	if (new_he != rstate->hw_enabled) {
-		nm_info ("%s now %s by radio killswitch",
-		         rstate->desc,
-		         (new_e && new_he) ? "enabled" : "disabled");
+		nm_log_info (LOGD_RFKILL, "%s now %s by radio killswitch",
+		             rstate->desc,
+		             (new_e && new_he) ? "enabled" : "disabled");
 
 		rstate->hw_enabled = new_he;
-		g_object_notify (G_OBJECT (self), rstate->hw_prop);
+		if (rstate->hw_prop)
+			g_object_notify (G_OBJECT (self), rstate->hw_prop);
 	}
 	manager_set_radio_enabled (self, rstate, new_e);
 }
@@ -1440,7 +1472,7 @@ add_device (NMManager *self, NMDevice *device)
 	iface = nm_device_get_ip_iface (device);
 	g_assert (iface);
 
-	if (!NM_IS_MODEM(device) && nm_modem_manager_has_modem_for_iface (priv->modem_manager, iface)) {
+	if (!NM_IS_DEVICE_MODEM (device) && find_device_by_iface (self, iface)) {
 		g_object_unref (device);
 		return;
 	}
@@ -1472,7 +1504,7 @@ add_device (NMManager *self, NMDevice *device)
 		nm_manager_rfkill_update (self, RFKILL_TYPE_WLAN);
 		nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (device),
 		                                 priv->radio_states[RFKILL_TYPE_WLAN].enabled);
-	} else if (NM_IS_MODEM (device)) {
+	} else if (NM_IS_DEVICE_MODEM (device)) {
 		g_signal_connect (device, "notify::" NM_MODEM_ENABLED,
 		                  G_CALLBACK (manager_modem_enabled_changed),
 		                  self);
@@ -1491,14 +1523,14 @@ add_device (NMManager *self, NMDevice *device)
 	driver = nm_device_get_driver (device);
 	if (!driver)
 		driver = "unknown";
-	nm_info ("(%s): new %s device (driver: '%s')", iface, type_desc, driver);
+	nm_log_info (LOGD_HW, "(%s): new %s device (driver: '%s')", iface, type_desc, driver);
 
 	path = g_strdup_printf ("/org/freedesktop/NetworkManager/Devices/%d", devcount++);
 	nm_device_set_path (device, path);
 	dbus_g_connection_register_g_object (nm_dbus_manager_get_connection (priv->dbus_mgr),
 	                                     path,
 	                                     G_OBJECT (device));
-	nm_info ("(%s): exported as %s", iface, path);
+	nm_log_info (LOGD_CORE, "(%s): exported as %s", iface, path);
 	g_free (path);
 
 	/* Check if we should assume the device's active connection by matching its
@@ -1513,6 +1545,15 @@ add_device (NMManager *self, NMDevice *device)
 		existing = nm_device_interface_connection_match_config (NM_DEVICE_INTERFACE (device),
 		                                                        (const GSList *) connections);
 		g_slist_free (connections);
+
+		if (existing) {
+			NMSettingConnection *s_con;
+
+			s_con = (NMSettingConnection *) nm_connection_get_setting (existing, NM_TYPE_SETTING_CONNECTION);
+			nm_log_dbg (LOGD_DEVICE, "(%s): found existing device connection '%s'",
+			            nm_device_get_iface (device),
+			            nm_setting_connection_get_id (s_con));
+		}
 	}
 
 	/* Start the device if it's supposed to be managed */
@@ -1534,15 +1575,18 @@ add_device (NMManager *self, NMDevice *device)
 		const char *ac_path;
 		GError *error = NULL;
 
+		nm_log_dbg (LOGD_DEVICE, "(%s): will attempt to assume existing connection",
+		            nm_device_get_iface (device));
+
 		ac_path = internal_activate_device (self, device, existing, NULL, FALSE, TRUE, &error);
 		if (ac_path)
 			g_object_notify (G_OBJECT (self), NM_MANAGER_ACTIVE_CONNECTIONS);
 		else {
-			nm_warning ("Assumed connection (%d) %s failed to activate: (%d) %s",
-			            nm_connection_get_scope (existing),
-			            nm_connection_get_path (existing),
-			            error ? error->code : -1,
-			            error && error->message ? error->message : "(unknown)");
+			nm_log_warn (LOGD_DEVICE, "assumed connection (%d) %s failed to activate: (%d) %s",
+			             nm_connection_get_scope (existing),
+			             nm_connection_get_path (existing),
+			             error ? error->code : -1,
+			             error && error->message ? error->message : "(unknown)");
 			g_error_free (error);
 		}
 	}
@@ -1691,13 +1735,12 @@ bluez_manager_bdaddr_added_cb (NMBluezManager *bluez_mgr,
 
 	device = nm_device_bt_new (object_path, bdaddr, name, capabilities, FALSE);
 	if (device) {
-		g_message ("%s: BT device %s (%s) added (%s%s%s)",
-		           __func__,
-		           name,
-		           bdaddr,
-		           has_dun ? "DUN" : "",
-		           has_dun && has_nap ? " " : "",
-		           has_nap ? "NAP" : "");
+		nm_log_info (LOGD_HW, "BT device %s (%s) added (%s%s%s)",
+		             name,
+		             bdaddr,
+		             has_dun ? "DUN" : "",
+		             has_dun && has_nap ? " " : "",
+		             has_nap ? "NAP" : "");
 
 		add_device (manager, device);
 	}
@@ -1716,7 +1759,7 @@ bluez_manager_bdaddr_removed_cb (NMBluezManager *bluez_mgr,
 	g_return_if_fail (bdaddr != NULL);
 	g_return_if_fail (object_path != NULL);
 
-	g_message ("%s: BT device %s removed", __func__, bdaddr);
+	nm_log_info (LOGD_HW, "BT device %s removed", bdaddr);
 
 	for (iter = priv->devices; iter; iter = iter->next) {
 		NMDevice *device = NM_DEVICE (iter->data);
@@ -1733,12 +1776,14 @@ find_device_by_iface (NMManager *self, const gchar *iface)
 {
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
 	GSList *iter;
+
 	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
 		NMDevice *device = NM_DEVICE (iter->data);
 		const gchar *d_iface = nm_device_get_ip_iface (device);
 		if (!strcmp (d_iface, iface))
 			return device;
 	}
+
 	return NULL;
 }
 
@@ -1989,7 +2034,7 @@ user_get_secrets (NMManager *self,
 	                                         nm_connection_get_path (connection),
 	                                         NM_DBUS_IFACE_SETTINGS_CONNECTION_SECRETS);
 	if (!info->proxy) {
-		nm_warning ("%s: could not create user connection secrets proxy", __func__);
+		nm_log_warn (LOGD_USER_SET, "could not create user connection secrets proxy");
 		g_free (info);
 		return NULL;
 	}
@@ -2054,7 +2099,9 @@ system_get_secrets_idle_cb (gpointer user_data)
 	connection = nm_settings_interface_get_connection_by_path (NM_SETTINGS_INTERFACE (priv->sys_settings), 
 	                                                           info->connection_path);
 	if (!connection) {
-		error = g_error_new_literal (0, 0, "unknown connection (not exported by system settings)");
+		error = g_error_new_literal (NM_MANAGER_ERROR,
+		                             NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
+		                             "unknown connection (not exported by system settings)");
 		nm_secrets_provider_interface_get_secrets_result (info->provider,
 		                                                  info->setting_name,
 		                                                  info->caller,
@@ -2204,8 +2251,8 @@ wait_for_connection_expired (gpointer data)
 	g_set_error (&error,
 	             NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
 	             "%s", "Connection was not provided by any settings service");
-	nm_warning ("Connection (%d) %s failed to activate (timeout): (%d) %s",
-	            info->scope, info->connection_path, error->code, error->message);
+	nm_log_warn (LOGD_CORE, "connection (%d) %s failed to activate (timeout): (%d) %s",
+	             info->scope, info->connection_path, error->code, error->message);
 	dbus_g_method_return_error (info->context, error);
 	g_error_free (error);
 
@@ -2356,8 +2403,8 @@ connection_added_default_handler (NMManager *manager,
 		g_object_notify (G_OBJECT (manager), NM_MANAGER_ACTIVE_CONNECTIONS);
 	} else {
 		dbus_g_method_return_error (info->context, error);
-		nm_warning ("Connection (%d) %s failed to activate: (%d) %s",
-		            scope, info->connection_path, error->code, error->message);
+		nm_log_warn (LOGD_CORE, "connection (%d) %s failed to activate: (%d) %s",
+		             scope, info->connection_path, error->code, error->message);
 		g_error_free (error);
 	}
 
@@ -2540,8 +2587,8 @@ impl_manager_activate_connection (NMManager *manager,
  err:
 	if (error) {
 		dbus_g_method_return_error (context, error);
-		nm_warning ("Connection (%d) %s failed to activate: (%d) %s",
-		            scope, connection_path, error->code, error->message);
+		nm_log_warn (LOGD_CORE, "connection (%d) %s failed to activate: (%d) %s",
+		             scope, connection_path, error->code, error->message);
 		g_error_free (error);
 	}
 
@@ -2635,16 +2682,16 @@ impl_manager_sleep (NMManager *self, gboolean sleep, GError **error)
 		                                "main", "NetworkingEnabled",
 		                                G_TYPE_BOOLEAN, (gpointer) &networking_enabled,
 		                                &err)) {
-			g_warning ("Writing to state file %s failed: (%d) %s.",
-			           priv->state_file,
-			           err ? err->code : -1,
-			           (err && err->message) ? err->message : "unknown");
+			nm_log_warn (LOGD_SUSPEND, "writing to state file %s failed: (%d) %s.",
+			             priv->state_file,
+			             err ? err->code : -1,
+			             (err && err->message) ? err->message : "unknown");
 		}
 
 	}
 
 	if (sleep) {
-		nm_info ("Sleeping...");
+		nm_log_info (LOGD_SUSPEND, "sleeping...");
 
 		/* Just deactivate and down all devices from the device list,
 		 * we'll remove them in 'wake' for speed's sake.
@@ -2654,7 +2701,7 @@ impl_manager_sleep (NMManager *self, gboolean sleep, GError **error)
 	} else {
 		const GSList *unmanaged_specs;
 
-		nm_info  ("Waking up...");
+		nm_log_info (LOGD_SUSPEND, "waking up...");
 
 		unmanaged_specs = nm_sysconfig_settings_get_unmanaged_specs (priv->sys_settings);
 
@@ -2674,11 +2721,17 @@ impl_manager_sleep (NMManager *self, gboolean sleep, GError **error)
 			for (i = 0; i < RFKILL_TYPE_MAX; i++) {
 				RadioState *rstate = &priv->radio_states[i];
 				gboolean enabled = (rstate->hw_enabled && rstate->enabled);
+				RfKillType devtype = RFKILL_TYPE_UNKNOWN;
 
-				if (   rstate->object_filter_func
-				    && rstate->object_filter_func (G_OBJECT (device))) {
-					nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (device), enabled);
+				if (rstate->desc) {
+					nm_log_dbg (LOGD_RFKILL, "%s %s devices (hw_enabled %d, enabled %d)",
+					            enabled ? "enabling" : "disabling",
+					            rstate->desc, rstate->hw_enabled, rstate->enabled);
 				}
+
+				g_object_get (G_OBJECT (device), NM_DEVICE_INTERFACE_RFKILL_TYPE, &devtype, NULL);
+				if (devtype == rstate->rtype)
+					nm_device_interface_set_enabled (NM_DEVICE_INTERFACE (device), enabled);
 			}
 
 			nm_device_clear_autoconnect_inhibit (device);
@@ -2722,6 +2775,18 @@ impl_manager_legacy_state (NMManager *manager, guint32 *state, GError **err)
 	return TRUE;
 }
 
+static gboolean
+impl_manager_set_logging (NMManager *manager,
+                          const char *level,
+                          const char *domains,
+                          GError **error)
+{
+	if (nm_logging_setup (level, domains, error)) {
+		nm_log_info (LOGD_CORE, "logging: level '%s' domains '%s'", level, domains);
+		return TRUE;
+	}
+	return FALSE;
+}
 
 /* Connections */
 
@@ -2777,7 +2842,7 @@ nm_manager_get_connections (NMManager *manager,
 	else if (scope == NM_CONNECTION_SCOPE_SYSTEM)
 		g_hash_table_foreach (priv->system_connections, connections_to_slist, &list);
 	else
-		nm_warning ("Unknown NMConnectionScope %d", scope);	
+		nm_log_err (LOGD_CORE, "unknown NMConnectionScope %d", scope);
 	return list;
 }
 
@@ -2798,7 +2863,7 @@ nm_manager_get_connection_by_object_path (NMManager *manager,
 	else if (scope == NM_CONNECTION_SCOPE_SYSTEM)
 		connection = (NMConnection *) g_hash_table_lookup (priv->system_connections, path);
 	else
-		nm_warning ("Unknown NMConnectionScope %d", scope);
+		nm_log_err (LOGD_CORE, "unknown NMConnectionScope %d", scope);
 	return connection;
 }
 
@@ -2823,33 +2888,35 @@ nm_manager_start (NMManager *self)
 		if (!rstate->desc)
 			continue;
 
-		if (!rstate->ignore_udev) {
-			switch (nm_udev_manager_get_rfkill_state (priv->udev_mgr, i)) {
-			case RFKILL_UNBLOCKED:
-				enabled = TRUE;
-				hw_enabled = TRUE;
-				break;
-			case RFKILL_SOFT_BLOCKED:
-				enabled = FALSE;
-				hw_enabled = TRUE;
-				break;
-			case RFKILL_HARD_BLOCKED:
-				enabled = FALSE;
-				hw_enabled = FALSE;
-				break;
-			default:
-				break;
-			}
+		switch (nm_udev_manager_get_rfkill_state (priv->udev_mgr, i)) {
+		case RFKILL_UNBLOCKED:
+			enabled = TRUE;
+			hw_enabled = TRUE;
+			break;
+		case RFKILL_SOFT_BLOCKED:
+			enabled = FALSE;
+			hw_enabled = TRUE;
+			break;
+		case RFKILL_HARD_BLOCKED:
+			enabled = FALSE;
+			hw_enabled = FALSE;
+			break;
+		default:
+			break;
 		}
 
 		rstate->hw_enabled = hw_enabled;
-		nm_info ("%s %s by radio killswitch; %s by state file",
-		         rstate->desc,
-		         (rstate->hw_enabled && enabled) ? "enabled" : "disabled",
-		         (rstate->enabled) ? "enabled" : "disabled");
+		nm_log_info (LOGD_RFKILL, "%s %s by radio killswitch; %s by state file",
+		             rstate->desc,
+		             (rstate->hw_enabled && enabled) ? "enabled" : "disabled",
+		             (rstate->enabled) ? "enabled" : "disabled");
 		manager_set_radio_enabled (self, rstate, rstate->enabled && enabled);
 	}
 
+	/* Log overall networking status - asleep/running */
+	nm_log_info (LOGD_CORE, "Networking is %s by state file",
+	             priv->sleeping ? "disabled" : "enabled");
+
 	system_unmanaged_devices_changed_cb (priv->sys_settings, NULL, self);
 	system_hostname_changed_cb (priv->sys_settings, NULL, self);
 	system_query_connections (self);
@@ -3095,7 +3162,7 @@ nm_manager_init (NMManager *manager)
 	priv->radio_states[RFKILL_TYPE_WLAN].hw_prop = NM_MANAGER_WIRELESS_HARDWARE_ENABLED;
 	priv->radio_states[RFKILL_TYPE_WLAN].desc = "WiFi";
 	priv->radio_states[RFKILL_TYPE_WLAN].other_enabled_func = nm_manager_get_ipw_rfkill_state;
-	priv->radio_states[RFKILL_TYPE_WLAN].object_filter_func = rfkill_wlan_filter;
+	priv->radio_states[RFKILL_TYPE_WLAN].rtype = RFKILL_TYPE_WLAN;
 
 	priv->radio_states[RFKILL_TYPE_WWAN].enabled = TRUE;
 	priv->radio_states[RFKILL_TYPE_WWAN].key = "WWANEnabled";
@@ -3103,7 +3170,15 @@ nm_manager_init (NMManager *manager)
 	priv->radio_states[RFKILL_TYPE_WWAN].hw_prop = NM_MANAGER_WWAN_HARDWARE_ENABLED;
 	priv->radio_states[RFKILL_TYPE_WWAN].desc = "WWAN";
 	priv->radio_states[RFKILL_TYPE_WWAN].other_enabled_func = nm_manager_get_modem_enabled_state;
-	priv->radio_states[RFKILL_TYPE_WWAN].object_filter_func = rfkill_wwan_filter;
+	priv->radio_states[RFKILL_TYPE_WWAN].rtype = RFKILL_TYPE_WWAN;
+
+	priv->radio_states[RFKILL_TYPE_WIMAX].enabled = TRUE;
+	priv->radio_states[RFKILL_TYPE_WIMAX].key = "WiMAXEnabled";
+	priv->radio_states[RFKILL_TYPE_WIMAX].prop = NULL;
+	priv->radio_states[RFKILL_TYPE_WIMAX].hw_prop = NULL;
+	priv->radio_states[RFKILL_TYPE_WIMAX].desc = "WiMAX";
+	priv->radio_states[RFKILL_TYPE_WIMAX].other_enabled_func = NULL;
+	priv->radio_states[RFKILL_TYPE_WIMAX].rtype = RFKILL_TYPE_WIMAX;
 
 	for (i = 0; i < RFKILL_TYPE_MAX; i++)
 		priv->radio_states[i].hw_enabled = TRUE;
@@ -3124,9 +3199,9 @@ nm_manager_init (NMManager *manager)
 	                                                  g_object_unref);
 
 	priv->modem_manager = nm_modem_manager_get ();
-	priv->modem_added_id = g_signal_connect (priv->modem_manager, "device-added",
+	priv->modem_added_id = g_signal_connect (priv->modem_manager, "modem-added",
 	                                         G_CALLBACK (modem_added), manager);
-	priv->modem_removed_id = g_signal_connect (priv->modem_manager, "device-removed",
+	priv->modem_removed_id = g_signal_connect (priv->modem_manager, "modem-removed",
 	                                           G_CALLBACK (modem_removed), manager);
 
 	priv->vpn_manager = nm_vpn_manager_get ();
@@ -3157,7 +3232,7 @@ nm_manager_init (NMManager *manager)
 		                             manager,
 		                             NULL);
 	} else
-		nm_warning ("%s: could not initialize avahi-autoipd D-Bus proxy", __func__);
+		nm_log_warn (LOGD_AUTOIP4, "could not initialize avahi-autoipd D-Bus proxy");
 }
 
 static void
@@ -3321,5 +3396,6 @@ nm_manager_class_init (NMManagerClass *manager_class)
 	                                 &dbus_glib_nm_manager_object_info);
 
 	dbus_g_error_domain_register (NM_MANAGER_ERROR, NULL, NM_TYPE_MANAGER_ERROR);
+	dbus_g_error_domain_register (NM_LOGGING_ERROR, "org.freedesktop.NetworkManager.Logging", NM_TYPE_LOGGING_ERROR);
 }
 
diff --git a/src/nm-netlink-monitor.c b/src/nm-netlink-monitor.c
index 2c3987c..918d637 100644
--- a/src/nm-netlink-monitor.c
+++ b/src/nm-netlink-monitor.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2005 - 2008 Novell, Inc.
  * Copyright (C) 2005 Ray Strode
  *
@@ -41,9 +41,9 @@
 #include <glib/gi18n.h>
 
 #include "NetworkManager.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
 #include "nm-netlink-monitor.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "nm-netlink.h"
 
@@ -186,6 +186,7 @@ netlink_object_message_handler (struct nl_object *obj, void *arg)
 	struct rtnl_link *filter;
 	struct rtnl_link *link_obj;
 	guint flags;
+	guint ifidx;
 
 	filter = rtnl_link_alloc ();
 	if (!filter) {
@@ -206,19 +207,17 @@ netlink_object_message_handler (struct nl_object *obj, void *arg)
 
 	link_obj = (struct rtnl_link *) obj;
 	flags = rtnl_link_get_flags (link_obj);
+	ifidx = rtnl_link_get_ifindex (link_obj);
+
+	nm_log_dbg (LOGD_HW, "netlink link message: iface idx %d flags 0x%X", ifidx, flags);
 
 	/* IFF_LOWER_UP is the indicator of carrier status since kernel commit
 	 * b00055aacdb172c05067612278ba27265fcd05ce in 2.6.17.
 	 */
-	if (flags & IFF_LOWER_UP) {
-		g_signal_emit (G_OBJECT (monitor),
-		               signals[CARRIER_ON],
-		               0, rtnl_link_get_ifindex (link_obj));
-	} else {
-		g_signal_emit (G_OBJECT (monitor),
-		               signals[CARRIER_OFF],
-		               0, rtnl_link_get_ifindex (link_obj));
-	}
+	if (flags & IFF_LOWER_UP)
+		g_signal_emit (G_OBJECT (monitor), signals[CARRIER_ON], 0, ifidx);
+	else
+		g_signal_emit (G_OBJECT (monitor), signals[CARRIER_OFF], 0, ifidx);
 
 out:
 	rtnl_link_put (filter);
@@ -407,9 +406,9 @@ deferred_emit_carrier_state (gpointer user_data)
 	/* Update the link cache with latest state, and if there are no errors
 	 * emit the link states for all the interfaces in the cache.
 	 */
-	if (nl_cache_refill (priv->nlh, priv->nlh_link_cache))
-		nm_warning ("error updating link cache: %s", nl_geterror ());
-	else {
+	if (nl_cache_refill (priv->nlh, priv->nlh_link_cache)) {
+		nm_log_err (LOGD_HW, "error updating link cache: %s", nl_geterror ());
+	} else {
 		nl_cache_foreach_filter (priv->nlh_link_cache,
 		                         NULL,
 		                         netlink_object_message_handler,
diff --git a/src/nm-netlink.c b/src/nm-netlink.c
index ad68790..c55c093 100644
--- a/src/nm-netlink.c
+++ b/src/nm-netlink.c
@@ -21,7 +21,7 @@
 #include "config.h"
 
 #include "nm-netlink.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 #include <glib.h>
 #include <signal.h>
@@ -40,7 +40,7 @@ get_link_cache (void)
 
 	nlh = nm_netlink_get_default_handle ();
 	if (G_UNLIKELY (!nlh)) {
-		nm_warning ("couldn't allocate netlink handle.");
+		nm_log_err (LOGD_HW, "couldn't allocate netlink handle.");
 		return NULL;
 	}
 
@@ -48,7 +48,7 @@ get_link_cache (void)
 		link_cache = rtnl_link_alloc_cache (nlh);
 
 	if (G_UNLIKELY (!link_cache)) {
-		nm_warning ("couldn't allocate netlink link cache: %s", nl_geterror ());
+		nm_log_err (LOGD_HW, "couldn't allocate netlink link cache: %s", nl_geterror ());
 		return NULL;
 	}
 
@@ -71,12 +71,12 @@ nm_netlink_get_default_handle (void)
 	cb = nl_cb_alloc(NL_CB_VERBOSE);
 	def_nl_handle = nl_handle_alloc_cb (cb);
 	if (!def_nl_handle) {
-		nm_warning ("couldn't allocate netlink handle.");
+		nm_log_err (LOGD_HW, "couldn't allocate netlink handle.");
 		return NULL;
 	}
 
 	if (nl_connect (def_nl_handle, NETLINK_ROUTE) < 0) {
-		nm_error ("couldn't connect to netlink: %s", nl_geterror ());
+		nm_log_err (LOGD_HW, "couldn't connect to netlink: %s", nl_geterror ());
 		return NULL;
 	}
 
@@ -123,7 +123,7 @@ nm_netlink_index_to_iface (int idx)
 
 	buf = g_malloc0 (MAX_IFACE_LEN);
 	if (buf == NULL) {
-		nm_warning ("Not enough memory to allocate interface name buffer.");
+		nm_log_warn (LOGD_HW, "Not enough memory to allocate interface name buffer.");
 		return NULL;
 	}
 
diff --git a/src/nm-policy-hosts.c b/src/nm-policy-hosts.c
new file mode 100644
index 0000000..35a0b9d
--- /dev/null
+++ b/src/nm-policy-hosts.c
@@ -0,0 +1,173 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <netdb.h>
+#include <ctype.h>
+
+#include "nm-policy-hosts.h"
+
+gboolean
+nm_policy_hosts_find_token (const char *line, const char *token)
+{
+	const char *start = line, *p = line;
+
+	g_return_val_if_fail (line != NULL, FALSE);
+	g_return_val_if_fail (token != NULL, FALSE);
+	g_return_val_if_fail (strlen (token) > 0, FALSE);
+
+	/* Walk through the line to find the next whitespace character */
+	while (p <= line + strlen (line)) {
+		if (isblank (*p) || (*p == '\0')) {
+			/* Token starts with 'start' and ends with 'end' */
+			if ((p > start) && *start && (p - start == strlen (token)) && !strncmp (start, token, (p - start)))
+				return TRUE; /* found */
+
+			/* not found; advance start and continue looking */
+			start = p + 1;
+		}
+		p++;
+	}
+
+	return FALSE;
+}
+
+static gboolean
+is_local_mapping (const char *str, const char *hostname)
+{
+	return (   !strncmp (str, "127.0.0.1", strlen ("127.0.0.1"))
+	        && nm_policy_hosts_find_token (str, hostname ? hostname : "localhost"));
+}
+
+GString *
+nm_policy_get_etc_hosts (const char **lines,
+                         gsize existing_len,
+                         const char *hostname,
+                         const char *fallback_hostname,
+                         GError **error)
+{
+	GString *contents = NULL;
+	const char **line;
+	gboolean found_host_nonlocal = FALSE;
+	gboolean found_host = FALSE;
+	gboolean found_localhost = FALSE;
+	gboolean initial_comments = TRUE;
+	gboolean added = FALSE;
+
+	g_return_val_if_fail (lines != NULL, FALSE);
+	g_return_val_if_fail (hostname != NULL, FALSE);
+
+	/* /etc/hosts needs at least two things:
+	 *
+	 * 1) current hostname mapped to any address
+	 * 2) 'localhost' mapped to 127.0.0.1
+	 *
+	 * If both these conditions exist in /etc/hosts, we don't need to bother
+	 * updating the file.
+	 */
+
+	/* Look for the two cases from above */
+	for (line = lines; lines && *line; line++) {
+		if (strlen (*line) && (*line[0] != '#')) {
+			if (nm_policy_hosts_find_token (*line, hostname)) {
+				if (!is_local_mapping (*line, "localhost")) {
+					/* hostname is not on a 127.0.0.1 line or the line does not
+					 * contain 'localhost'.
+					 */
+					found_host_nonlocal = TRUE;
+				}
+				found_host = TRUE;
+			}
+
+			if (is_local_mapping (*line, "localhost")) {
+				/* a 127.0.0.1 line containing 'localhost' */
+				found_localhost = TRUE;
+			}
+		}
+
+		if (found_localhost && found_host)
+			return NULL;  /* No update required */
+	}
+
+	contents = g_string_sized_new (existing_len ? existing_len + 100 : 200);
+	if (!contents) {
+		g_set_error_literal (error, 0, 0, "not enough memory");
+		return NULL;
+	}
+
+	/* Construct the new hosts file; replace any 127.0.0.1 entry that is at the
+	 * beginning of the file or right after initial comments and contains
+	 * the string 'localhost'.  If there is no 127.0.0.1 entry at the beginning
+	 * or after initial comments that contains 'localhost', add one there
+	 * and ignore any other 127.0.0.1 entries that contain 'localhost'.
+	 */
+	for (line = lines, initial_comments = TRUE; lines && *line; line++) {
+		gboolean add_line = TRUE;
+
+		/* This is the first line after the initial comments */
+		if (strlen (*line) && initial_comments && (*line[0] != '#')) {
+			initial_comments = FALSE;
+
+			/* If some other line contained the hostname but not 'localhost',
+			 * make a simple localhost mapping and assume the user knows what
+			 * they are doing with their manual hostname entry.  Otherwise if
+			 * the hostname wasn't found somewhere else, add it to the localhost
+			 * mapping line to make sure it's mapped to something.
+			 */
+			if (found_host_nonlocal)
+				g_string_append (contents, "127.0.0.1");
+			else
+				g_string_append_printf (contents, "127.0.0.1\t%s", hostname);
+
+			if (strcmp (hostname, fallback_hostname)) {
+				g_string_append_printf (contents, "\t%s", fallback_hostname);
+				/* Don't add a standalone 'localhost.localdomain' 127 mapping */
+				if (is_local_mapping (*line, fallback_hostname))
+					add_line = FALSE;
+			}
+
+			g_string_append (contents, "\tlocalhost\n");
+			added = TRUE;
+
+			/* Don't add the original line if it is a 'localhost' mapping */
+			if (is_local_mapping (*line, "localhost"))
+				add_line = FALSE;
+		}
+
+		if (add_line) {
+			g_string_append (contents, *line);
+			/* Only append the new line if this isn't the last line in the file */
+			if (*(line+1))
+				g_string_append_c (contents, '\n');
+		}
+	}
+
+	/* Hmm, /etc/hosts was empty for some reason */
+	if (!added) {
+		g_string_append (contents, "# Do not remove the following line, or various programs\n");
+		g_string_append (contents, "# that require network functionality will fail.\n");
+		g_string_append_printf (contents, "127.0.0.1\t%s\tlocalhost\n", fallback_hostname);
+	}
+
+	return contents;
+}
+
diff --git a/src/nm-policy-hosts.h b/src/nm-policy-hosts.h
new file mode 100644
index 0000000..4130ad0
--- /dev/null
+++ b/src/nm-policy-hosts.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ */
+
+#ifndef NM_POLICY_HOSTS_H
+#define NM_POLICT_HOSTS_H
+
+#include <glib.h>
+
+GString *nm_policy_get_etc_hosts (const char **lines,
+                                  gsize existing_len,
+                                  const char *hostname,
+                                  const char *fallback_hostname,
+                                  GError **error);
+
+/* Only for testcases; don't use outside of nm-policy-hosts.c */
+gboolean nm_policy_hosts_find_token (const char *line, const char *token);
+
+#endif /* NM_POLICY_HOSTS_H */
+
diff --git a/src/nm-policy.c b/src/nm-policy.c
new file mode 100644
index 0000000..7159eaf
--- /dev/null
+++ b/src/nm-policy.c
@@ -0,0 +1,1119 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ * Copyright (C) 2007 - 2008 Novell, Inc.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <netdb.h>
+#include <ctype.h>
+
+#include "nm-policy.h"
+#include "NetworkManagerUtils.h"
+#include "nm-wifi-ap.h"
+#include "nm-activation-request.h"
+#include "nm-logging.h"
+#include "nm-device-interface.h"
+#include "nm-device.h"
+#include "nm-device-wifi.h"
+#include "nm-device-ethernet.h"
+#include "nm-device-modem.h"
+#include "nm-dbus-manager.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-connection.h"
+#include "nm-system.h"
+#include "nm-named-manager.h"
+#include "nm-vpn-manager.h"
+#include "nm-policy-hosts.h"
+
+typedef struct LookupThread LookupThread;
+
+typedef void (*LookupCallback) (LookupThread *thread, gpointer user_data);
+
+struct LookupThread {
+	GThread *thread;
+
+	GMutex *lock;
+	gboolean die;
+	int ret;
+
+	guint32 ip4_addr;
+	char hostname[NI_MAXHOST + 1];
+
+	LookupCallback callback;
+	gpointer user_data;
+};
+
+struct NMPolicy {
+	NMManager *manager;
+	guint update_state_id;
+	GSList *pending_activation_checks;
+	GSList *signal_ids;
+	GSList *dev_signal_ids;
+
+	NMVPNManager *vpn_manager;
+	gulong vpn_activated_id;
+	gulong vpn_deactivated_id;
+
+	NMDevice *default_device;
+
+	LookupThread *lookup;
+
+	char *orig_hostname; /* hostname at NM start time */
+};
+
+static gboolean
+lookup_thread_run_cb (gpointer user_data)
+{
+	LookupThread *thread = (LookupThread *) user_data;
+
+	(*thread->callback) (thread, thread->user_data);
+	return FALSE;
+}
+
+static gpointer
+lookup_thread_worker (gpointer data)
+{
+	LookupThread *thread = (LookupThread *) data;
+	struct sockaddr_in addr;
+
+	g_mutex_lock (thread->lock);
+	if (thread->die) {
+		g_mutex_unlock (thread->lock);
+		return (gpointer) NULL;
+	}
+	g_mutex_unlock (thread->lock);
+
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = thread->ip4_addr;
+
+	thread->ret = getnameinfo ((struct sockaddr *) &addr, sizeof (struct sockaddr_in),
+	                           thread->hostname, NI_MAXHOST, NULL, 0,
+	                           NI_NAMEREQD);
+	if (thread->ret == 0) {
+		int i;
+
+		for (i = 0; i < strlen (thread->hostname); i++)
+			thread->hostname[i] = tolower (thread->hostname[i]);
+	}
+
+	/* Don't track the idle handler ID because by the time the g_idle_add()
+	 * returns the ID, the handler may already have run and freed the
+	 * LookupThread.
+	 */
+	g_idle_add (lookup_thread_run_cb, thread);
+	return (gpointer) TRUE;
+}
+
+static void
+lookup_thread_free (LookupThread *thread)
+{
+	g_return_if_fail (thread != NULL);
+
+	g_mutex_free (thread->lock);
+	memset (thread, 0, sizeof (LookupThread));
+	g_free (thread);
+}
+
+static LookupThread *
+lookup_thread_new (guint32 ip4_addr, LookupCallback callback, gpointer user_data)
+{
+	LookupThread *thread;
+
+	thread = g_malloc0 (sizeof (LookupThread));
+	if (!thread)
+		return NULL;
+
+	thread->lock = g_mutex_new ();
+	thread->callback = callback;
+	thread->user_data = user_data;
+	thread->ip4_addr = ip4_addr;
+
+	thread->thread = g_thread_create (lookup_thread_worker, thread, FALSE, NULL);
+	if (!thread->thread) {
+		lookup_thread_free (thread);
+		return NULL;
+	}
+
+	return thread;
+}
+
+static void
+lookup_thread_die (LookupThread *thread)
+{
+	g_return_if_fail (thread != NULL);
+
+	g_mutex_lock (thread->lock);
+	thread->die = TRUE;
+	g_mutex_unlock (thread->lock);
+}
+
+#define INVALID_TAG "invalid"
+
+static const char *
+get_connection_id (NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+	g_return_val_if_fail (s_con != NULL, NULL);
+
+	return nm_setting_connection_get_id (s_con);
+}
+
+static NMDevice *
+get_best_device (NMManager *manager, NMActRequest **out_req)
+{
+	GSList *devices, *iter;
+	NMDevice *best = NULL;
+	int best_prio = G_MAXINT;
+
+	g_return_val_if_fail (manager != NULL, NULL);
+	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
+	g_return_val_if_fail (out_req != NULL, NULL);
+	g_return_val_if_fail (*out_req == NULL, NULL);
+
+	devices = nm_manager_get_devices (manager);
+	for (iter = devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *dev = NM_DEVICE (iter->data);
+		NMActRequest *req;
+		NMConnection *connection;
+		NMIP4Config *ip4_config;
+		NMSettingIP4Config *s_ip4;
+		int prio;
+		guint i;
+		gboolean can_default = FALSE;
+		const char *method = NULL;
+
+		if (nm_device_get_state (dev) != NM_DEVICE_STATE_ACTIVATED)
+			continue;
+
+		ip4_config = nm_device_get_ip4_config (dev);
+		if (!ip4_config)
+			continue;
+
+		req = nm_device_get_act_request (dev);
+		g_assert (req);
+		connection = nm_act_request_get_connection (req);
+		g_assert (connection);
+
+		/* Never set the default route through an IPv4LL-addressed device */
+		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
+		if (s_ip4)
+			method = nm_setting_ip4_config_get_method (s_ip4);
+
+		if (s_ip4 && !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL))
+			continue;
+
+		/* Make sure at least one of this device's IP addresses has a gateway */
+		for (i = 0; i < nm_ip4_config_get_num_addresses (ip4_config); i++) {
+			NMIP4Address *addr;
+
+			addr = nm_ip4_config_get_address (ip4_config, i);
+			if (nm_ip4_address_get_gateway (addr)) {
+				can_default = TRUE;
+				break;
+			}
+		}
+
+		if (!can_default && !NM_IS_DEVICE_MODEM (dev))
+			continue;
+
+		/* 'never-default' devices can't ever be the default */
+		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
+			continue;
+
+		prio = nm_device_get_priority (dev);
+		if (prio > 0 && prio < best_prio) {
+			best = dev;
+			best_prio = prio;
+			*out_req = req;
+		}
+	}
+
+	return best;
+}
+
+#define FALLBACK_HOSTNAME "localhost.localdomain"
+
+static gboolean
+update_etc_hosts (const char *hostname, gboolean *out_changed)
+{
+	char *contents = NULL;
+	char **lines = NULL;
+	GError *error = NULL;
+	GString *new_contents = NULL;
+	gsize contents_len = 0;
+	gboolean success = FALSE;
+
+	g_return_val_if_fail (hostname != NULL, FALSE);
+	g_return_val_if_fail (out_changed != NULL, FALSE);
+
+	if (!g_file_get_contents (SYSCONFDIR "/hosts", &contents, &contents_len, &error)) {
+		nm_log_warn (LOGD_DNS, "couldn't read " SYSCONFDIR "/hosts: (%d) %s",
+		             error ? error->code : 0,
+		             (error && error->message) ? error->message : "(unknown)");
+		g_clear_error (&error);
+		return FALSE;
+	}
+
+	/* Get the new /etc/hosts contents */
+	lines = g_strsplit_set (contents, "\n\r", 0);
+	new_contents = nm_policy_get_etc_hosts ((const char **) lines,
+	                                        contents_len,
+	                                        hostname,
+	                                        FALLBACK_HOSTNAME,
+	                                        &error);
+	g_strfreev (lines);
+	g_free (contents);
+
+	if (new_contents) {
+		nm_log_info (LOGD_DNS, "Updating /etc/hosts with new system hostname");
+
+		g_clear_error (&error);
+		/* And actually update /etc/hosts */
+		if (!g_file_set_contents (SYSCONFDIR "/hosts", new_contents->str, -1, &error)) {
+			nm_log_warn (LOGD_DNS, "couldn't update " SYSCONFDIR "/hosts: (%d) %s",
+			             error ? error->code : 0,
+			             (error && error->message) ? error->message : "(unknown)");
+			g_clear_error (&error);
+		} else {
+			success = TRUE;
+			*out_changed = TRUE;
+		}
+
+		g_string_free (new_contents, TRUE);
+	} else if (!error) {
+		/* No change required */
+		success = TRUE;
+	} else {
+		nm_log_warn (LOGD_DNS, "couldn't read " SYSCONFDIR "/hosts: (%d) %s",
+		             error->code, error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+	}
+
+	return success;
+}
+
+static void
+set_system_hostname (const char *new_hostname, const char *msg)
+{
+	char old_hostname[HOST_NAME_MAX + 1];
+	int ret = 0;
+	const char *name = new_hostname ? new_hostname : FALLBACK_HOSTNAME;
+	gboolean set_hostname = TRUE, changed = FALSE;
+
+	old_hostname[HOST_NAME_MAX] = '\0';
+	errno = 0;
+	ret = gethostname (old_hostname, HOST_NAME_MAX);
+	if (ret != 0) {
+		nm_log_warn (LOGD_DNS, "couldn't get the system hostname: (%d) %s",
+		             errno, strerror (errno));
+	} else {
+		/* Don't set the hostname if it isn't actually changing */
+		if (   (new_hostname && !strcmp (old_hostname, new_hostname))
+		    || (!new_hostname && !strcmp (old_hostname, FALLBACK_HOSTNAME)))
+			set_hostname = FALSE;
+	}
+
+	if (set_hostname) {
+		nm_log_info (LOGD_DNS, "Setting system hostname to '%s' (%s)", name, msg);
+		ret = sethostname (name, strlen (name));
+		if (ret != 0) {
+			nm_log_warn (LOGD_DNS, "couldn't set the system hostname to '%s': (%d) %s",
+			             name, errno, strerror (errno));
+			return;
+		}
+	}
+
+	/* But still always try updating /etc/hosts just in case the hostname
+	 * changed while NM wasn't running; we need to make sure that /etc/hosts
+	 * has valid mappings for '127.0.0.1' and the current system hostname.  If
+	 * those exist, update_etc_hosts() will just return and won't touch
+	 * /etc/hosts at all.
+	 */
+	if (!update_etc_hosts (name, &changed)) {
+		/* error updating /etc/hosts; fallback to localhost.localdomain */
+		nm_log_info (LOGD_DNS, "Setting system hostname to '" FALLBACK_HOSTNAME "' (error updating /etc/hosts)");
+		ret = sethostname (FALLBACK_HOSTNAME, strlen (FALLBACK_HOSTNAME));
+		if (ret != 0) {
+			nm_log_warn (LOGD_DNS, "couldn't set the fallback system hostname (%s): (%d) %s",
+			             FALLBACK_HOSTNAME, errno, strerror (errno));
+		}
+	}
+
+	if (changed)
+		nm_utils_call_dispatcher ("hostname", NULL, NULL, NULL);
+}
+
+static void
+lookup_callback (LookupThread *thread, gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+
+	/* If the thread was told to die or it's not the current in-progress
+	 * hostname lookup, nothing to do.
+	 */
+	if (thread->die || (thread != policy->lookup))
+		goto done;
+
+	policy->lookup = NULL;
+	if (!strlen (thread->hostname)) {
+		char *msg;
+
+		/* No valid IP4 config (!!); fall back to localhost.localdomain */
+		msg = g_strdup_printf ("address lookup failed: %d", thread->ret);
+		set_system_hostname (NULL, msg);
+		g_free (msg);
+	} else
+		set_system_hostname (thread->hostname, "from address lookup");
+
+done:
+	lookup_thread_free (thread);
+}
+
+static void
+update_system_hostname (NMPolicy *policy, NMDevice *best)
+{
+	char *configured_hostname = NULL;
+	NMActRequest *best_req = NULL;
+	NMDHCP4Config *dhcp4_config;
+	NMIP4Config *ip4_config;
+	NMIP4Address *addr;
+
+	g_return_if_fail (policy != NULL);
+
+	if (policy->lookup) {
+		lookup_thread_die (policy->lookup);
+		policy->lookup = NULL;
+	}
+
+	/* Hostname precedence order:
+	 *
+	 * 1) a configured hostname (from system-settings)
+	 * 2) automatic hostname from the default device's config (DHCP, VPN, etc)
+	 * 3) the original hostname when NM started
+	 * 4) reverse-DNS of the best device's IPv4 address
+	 *
+	 */
+
+	/* Try a persistent hostname first */
+	g_object_get (G_OBJECT (policy->manager), NM_MANAGER_HOSTNAME, &configured_hostname, NULL);
+	if (configured_hostname) {
+		set_system_hostname (configured_hostname, "from system configuration");
+		g_free (configured_hostname);
+		return;
+	}
+
+	/* Try automatically determined hostname from the best device's IP config */
+	if (!best)
+		best = get_best_device (policy->manager, &best_req);
+
+	if (!best) {
+		/* No best device; fall back to original hostname or if there wasn't
+		 * one, 'localhost.localdomain'
+		 */
+		set_system_hostname (policy->orig_hostname, "no default device");
+		return;
+	}
+
+	/* Grab a hostname out of the device's DHCP4 config */
+	dhcp4_config = nm_device_get_dhcp4_config (best);
+	if (dhcp4_config) {
+		const char *dhcp4_hostname, *p;
+
+		p = dhcp4_hostname = nm_dhcp4_config_get_option (dhcp4_config, "host_name");
+		if (dhcp4_hostname && strlen (dhcp4_hostname)) {
+			/* Sanity check */
+			while (*p) {
+				if (!isblank (*p++)) {
+					set_system_hostname (dhcp4_hostname, "from DHCP");
+					return;
+				}
+			}
+			nm_log_warn (LOGD_DNS, "DHCP-provided hostname '%s' looks invalid; ignoring it",
+			             dhcp4_hostname);
+		}
+	}
+
+	/* If no automatically-configured hostname, try using the hostname from
+	 * when NM started up.
+	 */
+	if (policy->orig_hostname) {
+		set_system_hostname (policy->orig_hostname, "from system startup");
+		return;
+	}
+
+	/* No configured hostname, no automatically determined hostname, and
+	 * no bootup hostname. Start reverse DNS of the current IP address.
+	 */
+	ip4_config = nm_device_get_ip4_config (best);
+	if (   !ip4_config
+	    || (nm_ip4_config_get_num_nameservers (ip4_config) == 0)
+	    || (nm_ip4_config_get_num_addresses (ip4_config) == 0)) {
+		/* No valid IP4 config (!!); fall back to localhost.localdomain */
+		set_system_hostname (NULL, "no IPv4 config");
+		return;
+	}
+
+	addr = nm_ip4_config_get_address (ip4_config, 0);
+	g_assert (addr); /* checked for > 1 address above */
+
+	/* Start the hostname lookup thread */
+	policy->lookup = lookup_thread_new (nm_ip4_address_get_address (addr), lookup_callback, policy);
+	if (!policy->lookup) {
+		/* Fall back to 'localhost.localdomain' */
+		set_system_hostname (NULL, "error starting hostname thread");
+	}
+}
+
+static void
+update_routing_and_dns (NMPolicy *policy, gboolean force_update)
+{
+	NMNamedIPConfigType dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
+	NMDevice *best = NULL;
+	NMActRequest *best_req = NULL;
+	NMNamedManager *named_mgr;
+	GSList *devices = NULL, *iter, *vpns;
+	NMIP4Config *ip4_config = NULL;
+	NMIP4Address *addr;
+	const char *ip_iface = NULL;
+	NMConnection *connection = NULL;
+	NMSettingConnection *s_con = NULL;
+	const char *connection_id;
+
+	best = get_best_device (policy->manager, &best_req);
+	if (!best)
+		goto out;
+	if (!force_update && (best == policy->default_device))
+		goto out;
+
+	/* If a VPN connection is active, it is preferred */
+	vpns = nm_vpn_manager_get_active_connections (policy->vpn_manager);
+	for (iter = vpns; iter; iter = g_slist_next (iter)) {
+		NMVPNConnection *candidate = NM_VPN_CONNECTION (iter->data);
+		NMConnection *vpn_connection;
+		NMSettingIP4Config *s_ip4;
+		gboolean can_default = TRUE;
+		NMVPNConnectionState vpn_state;
+
+		/* If it's marked 'never-default', don't make it default */
+		vpn_connection = nm_vpn_connection_get_connection (candidate);
+		g_assert (vpn_connection);
+		s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (vpn_connection, NM_TYPE_SETTING_IP4_CONFIG);
+		if (s_ip4 && nm_setting_ip4_config_get_never_default (s_ip4))
+			can_default = FALSE;
+
+		vpn_state = nm_vpn_connection_get_vpn_state (candidate);
+		if (can_default && (vpn_state == NM_VPN_CONNECTION_STATE_ACTIVATED)) {
+			NMIP4Config *parent_ip4;
+			NMDevice *parent;
+
+			ip_iface = nm_vpn_connection_get_ip_iface (candidate);
+			connection = nm_vpn_connection_get_connection (candidate);
+			ip4_config = nm_vpn_connection_get_ip4_config (candidate);
+			addr = nm_ip4_config_get_address (ip4_config, 0);
+
+			parent = nm_vpn_connection_get_parent_device (candidate);
+			parent_ip4 = nm_device_get_ip4_config (parent);
+
+			nm_system_replace_default_ip4_route_vpn (ip_iface,
+			                                         nm_ip4_address_get_gateway (addr),
+			                                         nm_vpn_connection_get_ip4_internal_gateway (candidate),
+			                                         nm_ip4_config_get_mss (ip4_config),
+			                                         nm_device_get_ip_iface (parent),
+			                                         nm_ip4_config_get_mss (parent_ip4));
+
+			dns_type = NM_NAMED_IP_CONFIG_TYPE_VPN;
+		}
+		g_object_unref (candidate);
+	}
+	g_slist_free (vpns);
+
+	/* The best device gets the default route if a VPN connection didn't */
+	if (!ip_iface || !ip4_config) {
+		connection = nm_act_request_get_connection (best_req);
+		ip_iface = nm_device_get_ip_iface (best);
+		ip4_config = nm_device_get_ip4_config (best);
+		g_assert (ip4_config);
+		addr = nm_ip4_config_get_address (ip4_config, 0);
+
+		nm_system_replace_default_ip4_route (ip_iface, nm_ip4_address_get_gateway (addr), nm_ip4_config_get_mss (ip4_config));
+
+		dns_type = NM_NAMED_IP_CONFIG_TYPE_BEST_DEVICE;
+	}
+
+	if (!ip_iface || !ip4_config) {
+		nm_log_warn (LOGD_CORE, "couldn't determine IP interface (%p) or IPv4 config (%p)!",
+		             ip_iface, ip4_config);
+		goto out;
+	}
+
+	/* Update the default active connection.  Only mark the new default
+	 * active connection after setting default = FALSE on all other connections
+	 * first.  The order is important, we don't want two connections marked
+	 * default at the same time ever.
+	 */
+	devices = nm_manager_get_devices (policy->manager);
+	for (iter = devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *dev = NM_DEVICE (iter->data);
+		NMActRequest *req;
+
+		req = nm_device_get_act_request (dev);
+		if (req && (req != best_req))
+			nm_act_request_set_default (req, FALSE);
+	}
+
+	named_mgr = nm_named_manager_get ();
+	nm_named_manager_add_ip4_config (named_mgr, ip_iface, ip4_config, dns_type);
+	g_object_unref (named_mgr);
+
+	/* Now set new default active connection _after_ updating DNS info, so that
+	 * if the connection is shared dnsmasq picks up the right stuff.
+	 */
+	if (best_req)
+		nm_act_request_set_default (best_req, TRUE);
+
+	if (connection)
+		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+
+	connection_id = s_con ? nm_setting_connection_get_id (s_con) : NULL;
+	if (connection_id) {
+		nm_log_info (LOGD_CORE, "Policy set '%s' (%s) as default for routing and DNS.", connection_id, ip_iface);
+	} else {
+		nm_log_info (LOGD_CORE, "Policy set (%s) as default for routing and DNS.", ip_iface);
+	}
+
+out:
+	/* Update the system hostname */
+	update_system_hostname (policy, best);
+
+	policy->default_device = best;	
+}
+
+typedef struct {
+	NMPolicy *policy;
+	NMDevice *device;
+	guint id;
+} ActivateData;
+
+static gboolean
+auto_activate_device (gpointer user_data)
+{
+	ActivateData *data = (ActivateData *) user_data;
+	NMPolicy *policy;
+	NMConnection *best_connection;
+	char *specific_object = NULL;
+	GSList *connections, *iter;
+
+	g_assert (data);
+	policy = data->policy;
+
+	// FIXME: if a device is already activating (or activated) with a connection
+	// but another connection now overrides the current one for that device,
+	// deactivate the device and activate the new connection instead of just
+	// bailing if the device is already active
+	if (nm_device_get_act_request (data->device))
+		goto out;
+
+	/* System connections first, then user connections */
+	connections = nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_SYSTEM);
+	connections = g_slist_concat (connections, nm_manager_get_connections (policy->manager, NM_CONNECTION_SCOPE_USER));
+
+	/* Remove connections that are in the invalid list. */
+	iter = connections;
+	while (iter) {
+		NMConnection *iter_connection = NM_CONNECTION (iter->data);
+		GSList *next = g_slist_next (iter);
+
+		if (g_object_get_data (G_OBJECT (iter_connection), INVALID_TAG)) {
+			connections = g_slist_remove_link (connections, iter);
+			g_object_unref (iter_connection);
+			g_slist_free (iter);
+		}
+		iter = next;
+	}
+
+	best_connection = nm_device_get_best_auto_connection (data->device, connections, &specific_object);
+	if (best_connection) {
+		GError *error = NULL;
+		const char *device_path;
+
+		device_path = nm_device_get_path (data->device);
+		if (!nm_manager_activate_connection (policy->manager,
+		                                     best_connection,
+		                                     specific_object,
+		                                     device_path,
+		                                     FALSE,
+		                                     &error)) {
+			NMSettingConnection *s_con;
+
+			s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (best_connection, NM_TYPE_SETTING_CONNECTION));
+			g_assert (s_con);
+
+			nm_log_info (LOGD_DEVICE, "Connection '%s' auto-activation failed: (%d) %s",
+			             nm_setting_connection_get_id (s_con), error->code, error->message);
+			g_error_free (error);
+		}
+	}
+
+	g_slist_foreach (connections, (GFunc) g_object_unref, NULL);
+	g_slist_free (connections);
+
+ out:
+	/* Remove this call's handler ID */
+	policy->pending_activation_checks = g_slist_remove (policy->pending_activation_checks, data);
+	g_object_unref (data->device);
+	g_free (data);
+
+	return FALSE;
+}
+
+/*****************************************************************************/
+
+static void
+vpn_connection_activated (NMVPNManager *manager,
+                          NMVPNConnection *vpn,
+                          gpointer user_data)
+{
+	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
+}
+
+static void
+vpn_connection_deactivated (NMVPNManager *manager,
+                            NMVPNConnection *vpn,
+                            NMVPNConnectionState state,
+                            NMVPNConnectionStateReason reason,
+                            gpointer user_data)
+{
+	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
+}
+
+static void
+global_state_changed (NMManager *manager, NMState state, gpointer user_data)
+{
+}
+
+static void
+hostname_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
+{
+	update_system_hostname ((NMPolicy *) user_data, NULL);
+}
+
+static void
+sleeping_changed (NMManager *manager, GParamSpec *pspec, gpointer user_data)
+{
+	gboolean sleeping = FALSE;
+	GSList *connections, *iter;
+
+	g_object_get (G_OBJECT (manager), NM_MANAGER_SLEEPING, &sleeping, NULL);
+
+	/* Clear the invalid flag on all connections so they'll get retried on wakeup */
+	if (sleeping) {
+		connections = nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_SYSTEM);
+		connections = g_slist_concat (connections, nm_manager_get_connections (manager, NM_CONNECTION_SCOPE_USER));
+		for (iter = connections; iter; iter = g_slist_next (iter))
+			g_object_set_data (G_OBJECT (iter->data), INVALID_TAG, NULL);
+		g_slist_free (connections);
+	}
+}
+
+static void
+schedule_activate_check (NMPolicy *policy, NMDevice *device, guint delay_seconds)
+{
+	ActivateData *data;
+	GSList *iter;
+	NMDeviceState state;
+
+	if (nm_manager_get_state (policy->manager) == NM_STATE_ASLEEP)
+		return;
+
+	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
+	if (state < NM_DEVICE_STATE_DISCONNECTED)
+		return;
+
+	if (!nm_device_autoconnect_allowed (device))
+		return;
+
+	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
+		/* Only one pending activation check at a time */
+		if (((ActivateData *) iter->data)->device == device)
+			return;
+	}
+
+	data = g_malloc0 (sizeof (ActivateData));
+	g_return_if_fail (data != NULL);
+
+	data->policy = policy;
+	data->device = g_object_ref (device);
+	data->id = delay_seconds ? g_timeout_add_seconds (delay_seconds, auto_activate_device, data) : g_idle_add (auto_activate_device, data);
+	policy->pending_activation_checks = g_slist_append (policy->pending_activation_checks, data);
+}
+
+static NMConnection *
+get_device_connection (NMDevice *device)
+{
+	NMActRequest *req;
+
+	req = nm_device_get_act_request (device);
+	if (!req)
+		return NULL;
+
+	return nm_act_request_get_connection (req);
+}
+
+static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+	NMConnection *connection = get_device_connection (device);
+
+	switch (new_state) {
+	case NM_DEVICE_STATE_FAILED:
+		/* Mark the connection invalid if it failed during activation so that
+		 * it doesn't get automatically chosen over and over and over again.
+		 */
+		if (connection && IS_ACTIVATING_STATE (old_state)) {
+			g_object_set_data (G_OBJECT (connection), INVALID_TAG, GUINT_TO_POINTER (TRUE));
+			nm_log_info (LOGD_DEVICE, "Marking connection '%s' invalid.", get_connection_id (connection));
+			nm_connection_clear_secrets (connection);
+		}
+		schedule_activate_check (policy, device, 3);
+		break;
+	case NM_DEVICE_STATE_ACTIVATED:
+		if (connection) {
+			/* Clear the invalid tag on the connection */
+			g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
+
+			/* And clear secrets so they will always be requested from the
+			 * settings service when the next connection is made.
+			 */
+			nm_connection_clear_secrets (connection);
+		}
+
+		update_routing_and_dns (policy, FALSE);
+		break;
+	case NM_DEVICE_STATE_UNMANAGED:
+	case NM_DEVICE_STATE_UNAVAILABLE:
+	case NM_DEVICE_STATE_DISCONNECTED:
+		update_routing_and_dns (policy, FALSE);
+		schedule_activate_check (policy, device, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+device_ip4_config_changed (NMDevice *device,
+                           GParamSpec *pspec,
+                           gpointer user_data)
+{
+	update_routing_and_dns ((NMPolicy *) user_data, TRUE);
+}
+
+static void
+wireless_networks_changed (NMDeviceWifi *device, NMAccessPoint *ap, gpointer user_data)
+{
+	schedule_activate_check ((NMPolicy *) user_data, NM_DEVICE (device), 0);
+}
+
+typedef struct {
+	gulong id;
+	NMDevice *device;
+} DeviceSignalID;
+
+static GSList *
+add_device_signal_id (GSList *list, gulong id, NMDevice *device)
+{
+	DeviceSignalID *data;
+
+	data = g_malloc0 (sizeof (DeviceSignalID));
+	if (!data)
+		return list;
+
+	data->id = id;
+	data->device = device;
+	return g_slist_append (list, data);
+}
+
+static void
+device_added (NMManager *manager, NMDevice *device, gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+	gulong id;
+
+	id = g_signal_connect (device, "state-changed",
+	                       G_CALLBACK (device_state_changed),
+	                       policy);
+	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+
+	id = g_signal_connect (device, "notify::" NM_DEVICE_INTERFACE_IP4_CONFIG,
+	                       G_CALLBACK (device_ip4_config_changed),
+	                       policy);
+	policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+
+	if (NM_IS_DEVICE_WIFI (device)) {
+		id = g_signal_connect (device, "access-point-added",
+		                       G_CALLBACK (wireless_networks_changed),
+		                       policy);
+		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+
+		id = g_signal_connect (device, "access-point-removed",
+		                       G_CALLBACK (wireless_networks_changed),
+		                       policy);
+		policy->dev_signal_ids = add_device_signal_id (policy->dev_signal_ids, id, device);
+	}
+}
+
+static void
+device_removed (NMManager *manager, NMDevice *device, gpointer user_data)
+{
+	NMPolicy *policy = (NMPolicy *) user_data;
+	GSList *iter;
+
+	/* Clear any idle callbacks for this device */
+	iter = policy->pending_activation_checks;
+	while (iter) {
+		ActivateData *data = (ActivateData *) iter->data;
+		GSList *next = g_slist_next (iter);
+
+		if (data->device == device) {
+			g_source_remove (data->id);
+			g_object_unref (data->device);
+			g_free (data);
+			policy->pending_activation_checks = g_slist_delete_link (policy->pending_activation_checks, iter);
+		}
+		iter = next;
+	}
+
+	/* Clear any signal handlers for this device */
+	iter = policy->dev_signal_ids;
+	while (iter) {
+		DeviceSignalID *data = (DeviceSignalID *) iter->data;
+		GSList *next = g_slist_next (iter);
+
+		if (data->device == device) {
+			g_signal_handler_disconnect (data->device, data->id);
+			g_free (data);
+			policy->dev_signal_ids = g_slist_delete_link (policy->dev_signal_ids, iter);
+		}
+		iter = next;
+	}
+
+	update_routing_and_dns (policy, FALSE);
+}
+
+static void
+schedule_activate_all (NMPolicy *policy)
+{
+	GSList *iter, *devices;
+
+	devices = nm_manager_get_devices (policy->manager);
+	for (iter = devices; iter; iter = g_slist_next (iter))
+		schedule_activate_check (policy, NM_DEVICE (iter->data), 0);
+}
+
+static void
+connections_added (NMManager *manager,
+                   NMConnectionScope scope,
+                   gpointer user_data)
+{
+	schedule_activate_all ((NMPolicy *) user_data);
+}
+
+static void
+connection_added (NMManager *manager,
+                  NMConnection *connection,
+                  NMConnectionScope scope,
+                  gpointer user_data)
+{
+	schedule_activate_all ((NMPolicy *) user_data);
+}
+
+static void
+connection_updated (NMManager *manager,
+                    NMConnection *connection,
+                    NMConnectionScope scope,
+                    gpointer user_data)
+{
+	/* Clear the invalid tag on the connection if it got updated. */
+	g_object_set_data (G_OBJECT (connection), INVALID_TAG, NULL);
+
+	schedule_activate_all ((NMPolicy *) user_data);
+}
+
+static void
+connection_removed (NMManager *manager,
+                    NMConnection *connection,
+                    NMConnectionScope scope,
+                    gpointer user_data)
+{
+	NMSettingConnection *s_con;
+	GPtrArray *list;
+	int i;
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	if (!s_con)
+		return;
+
+	list = nm_manager_get_active_connections_by_connection (manager, connection);
+	if (!list)
+		return;
+
+	for (i = 0; i < list->len; i++) {
+		char *path = g_ptr_array_index (list, i);
+		GError *error = NULL;
+
+		if (!nm_manager_deactivate_connection (manager, path, NM_DEVICE_STATE_REASON_CONNECTION_REMOVED, &error)) {
+			nm_log_warn (LOGD_DEVICE, "Connection '%s' disappeared, but error deactivating it: (%d) %s",
+			             nm_setting_connection_get_id (s_con), error->code, error->message);
+			g_error_free (error);
+		}
+		g_free (path);
+	}
+	g_ptr_array_free (list, TRUE);
+}
+
+NMPolicy *
+nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager)
+{
+	NMPolicy *policy;
+	static gboolean initialized = FALSE;
+	gulong id;
+	char hostname[HOST_NAME_MAX + 2];
+
+	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
+	g_return_val_if_fail (initialized == FALSE, NULL);
+
+	policy = g_malloc0 (sizeof (NMPolicy));
+	policy->manager = g_object_ref (manager);
+	policy->update_state_id = 0;
+
+	/* Grab hostname on startup and use that if nothing provides one */
+	memset (hostname, 0, sizeof (hostname));
+	if (gethostname (&hostname[0], HOST_NAME_MAX) == 0) {
+		/* only cache it if it's a valid hostname */
+		if (strlen (hostname) && strcmp (hostname, "localhost") && strcmp (hostname, "localhost.localdomain"))
+			policy->orig_hostname = g_strdup (hostname);
+	}
+
+	policy->vpn_manager = g_object_ref (vpn_manager);
+	id = g_signal_connect (policy->vpn_manager, "connection-activated",
+	                       G_CALLBACK (vpn_connection_activated), policy);
+	policy->vpn_activated_id = id;
+	id = g_signal_connect (policy->vpn_manager, "connection-deactivated",
+	                       G_CALLBACK (vpn_connection_deactivated), policy);
+	policy->vpn_deactivated_id = id;
+
+	id = g_signal_connect (manager, "state-changed",
+	                       G_CALLBACK (global_state_changed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "notify::" NM_MANAGER_HOSTNAME,
+	                       G_CALLBACK (hostname_changed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "notify::" NM_MANAGER_SLEEPING,
+	                       G_CALLBACK (sleeping_changed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "device-added",
+	                       G_CALLBACK (device_added), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "device-removed",
+	                       G_CALLBACK (device_removed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	/* Large batch of connections added, manager doesn't want us to
+	 * process each one individually.
+	 */
+	id = g_signal_connect (manager, "connections-added",
+	                       G_CALLBACK (connections_added), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	/* Single connection added */
+	id = g_signal_connect (manager, "connection-added",
+	                       G_CALLBACK (connection_added), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "connection-updated",
+	                       G_CALLBACK (connection_updated), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	id = g_signal_connect (manager, "connection-removed",
+	                       G_CALLBACK (connection_removed), policy);
+	policy->signal_ids = g_slist_append (policy->signal_ids, (gpointer) id);
+
+	return policy;
+}
+
+void
+nm_policy_destroy (NMPolicy *policy)
+{
+	GSList *iter;
+
+	g_return_if_fail (policy != NULL);
+
+	/* Tell any existing hostname lookup thread to die, it'll get cleaned up
+	 * by the lookup thread callback.
+	  */
+	if (policy->lookup) {
+		lookup_thread_die (policy->lookup);
+		policy->lookup = NULL;
+	}
+
+	for (iter = policy->pending_activation_checks; iter; iter = g_slist_next (iter)) {
+		ActivateData *data = (ActivateData *) iter->data;
+
+		g_source_remove (data->id);
+		g_object_unref (data->device);
+		g_free (data);
+	}
+	g_slist_free (policy->pending_activation_checks);
+
+	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_activated_id);
+	g_signal_handler_disconnect (policy->vpn_manager, policy->vpn_deactivated_id);
+
+	for (iter = policy->signal_ids; iter; iter = g_slist_next (iter))
+		g_signal_handler_disconnect (policy->manager, (gulong) iter->data);
+	g_slist_free (policy->signal_ids);
+
+	for (iter = policy->dev_signal_ids; iter; iter = g_slist_next (iter)) {
+		DeviceSignalID *data = (DeviceSignalID *) iter->data;
+
+		g_signal_handler_disconnect (data->device, data->id);
+		g_free (data);
+	}
+	g_slist_free (policy->dev_signal_ids);
+
+	g_free (policy->orig_hostname);
+
+	g_object_unref (policy->manager);
+	g_free (policy);
+}
+
diff --git a/src/nm-policy.h b/src/nm-policy.h
new file mode 100644
index 0000000..7d99613
--- /dev/null
+++ b/src/nm-policy.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2007 - 2008 Novell, Inc.
+ */
+
+#ifndef NETWORK_MANAGER_POLICY_H
+#define NETWORK_MANAGER_POLICY_H
+
+#include "NetworkManager.h"
+#include "nm-manager.h"
+#include "nm-vpn-manager.h"
+#include "nm-device.h"
+#include "nm-activation-request.h"
+
+typedef struct NMPolicy NMPolicy;
+
+NMPolicy *nm_policy_new (NMManager *manager, NMVPNManager *vpn_manager);
+void nm_policy_destroy (NMPolicy *policy);
+
+#endif /* NETWORK_MANAGER_POLICY_H */
diff --git a/src/nm-properties-changed-signal.c b/src/nm-properties-changed-signal.c
index 8d6c3a4..4a9db8a 100644
--- a/src/nm-properties-changed-signal.c
+++ b/src/nm-properties-changed-signal.c
@@ -106,7 +106,7 @@ properties_changed (gpointer data)
 	{
 		char buf[2048] = { 0, };
 		g_hash_table_foreach (info->hash, add_to_string, &buf);
-		g_message ("%s: %s -> %s", __func__, G_OBJECT_TYPE_NAME (object), buf);
+		nm_log_dbg (LOGD_CORE, "%s -> %s", G_OBJECT_TYPE_NAME (object), buf);
 	}
 #endif
 
diff --git a/src/nm-secrets-provider-interface.c b/src/nm-secrets-provider-interface.c
index 9bbde7a..47b8e57 100644
--- a/src/nm-secrets-provider-interface.c
+++ b/src/nm-secrets-provider-interface.c
@@ -25,7 +25,7 @@
 
 #include <nm-setting-8021x.h>
 #include <nm-setting-wireless-security.h>
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 static void
 nm_secrets_provider_interface_init (gpointer g_iface)
@@ -108,7 +108,7 @@ nm_secrets_provider_interface_get_secrets (NMSecretsProviderInterface *self,
 	                       connection, setting_name, request_new, caller, hint1, hint2,
 	                       &success);
 	if (!success) {
-		nm_warning ("failed to get connection secrets.");
+		nm_log_warn (LOGD_CORE, "failed to get connection secrets.");
 		return FALSE;
 	}
 
@@ -193,7 +193,7 @@ nm_secrets_provider_interface_get_secrets_result (NMSecretsProviderInterface *se
 
 		hash = g_hash_table_lookup (settings, name);
 		if (!hash) {
-			nm_warning ("couldn't get setting secrets for '%s'", name);
+			nm_log_warn (LOGD_CORE, "couldn't get setting secrets for '%s'", name);
 			continue;
 		}
 
diff --git a/src/nm-secrets-provider-interface.h b/src/nm-secrets-provider-interface.h
index 299e8c2..3d9e08b 100644
--- a/src/nm-secrets-provider-interface.h
+++ b/src/nm-secrets-provider-interface.h
@@ -28,8 +28,7 @@ typedef enum {
 	SECRETS_CALLER_NONE = 0,
 	SECRETS_CALLER_ETHERNET,
 	SECRETS_CALLER_WIFI,
-	SECRETS_CALLER_GSM,
-	SECRETS_CALLER_CDMA,
+	SECRETS_CALLER_MOBILE_BROADBAND,
 	SECRETS_CALLER_PPP,
 	SECRETS_CALLER_VPN
 } RequestSecretsCaller;
diff --git a/src/nm-system.c b/src/nm-system.c
new file mode 100644
index 0000000..bd5f57f
--- /dev/null
+++ b/src/nm-system.c
@@ -0,0 +1,1130 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2010 Red Hat, Inc.
+ * Copyright (C) 2005 - 2008 Novell, Inc.
+ * Copyright (C) 1996 - 1997 Yoichi Hariguchi <yoichi@fore.com>
+ * Copyright (C) January, 1998 Sergei Viznyuk <sv@phystech.com>
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+#include <net/route.h>
+#include <arpa/nameser.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <resolv.h>
+#include <netdb.h>
+#include <glib.h>
+#include <ctype.h>
+#include <net/if.h>
+
+#include "nm-system.h"
+#include "nm-device.h"
+#include "nm-named-manager.h"
+#include "NetworkManagerUtils.h"
+#include "nm-utils.h"
+#include "nm-logging.h"
+#include "nm-netlink.h"
+
+/* Because of a bug in libnl, rtnl.h should be included before route.h */
+#include <netlink/route/rtnl.h>
+
+#include <netlink/route/addr.h>
+#include <netlink/route/route.h>
+#include <netlink/netlink.h>
+#include <netlink/utils.h>
+#include <netlink/route/link.h>
+
+static void nm_system_device_set_priority (const char *iface,
+								   NMIP4Config *config,
+								   int priority);
+
+static gboolean
+ip4_dest_in_same_subnet (NMIP4Config *config, guint32 dest, guint32 dest_prefix)
+{
+	int num;
+	int i;
+
+	num = nm_ip4_config_get_num_addresses (config);
+	for (i = 0; i < num; i++) {
+		NMIP4Address *addr = nm_ip4_config_get_address (config, i);
+		guint32 prefix = nm_ip4_address_get_prefix (addr);
+		guint32 address = nm_ip4_address_get_address (addr);
+
+		if (prefix <= dest_prefix) {
+			guint32 masked_addr = ntohl(address) >> (32 - prefix);
+			guint32 masked_dest = ntohl(dest) >> (32 - prefix);
+
+			if (masked_addr == masked_dest)
+				return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static struct rtnl_route *
+create_route (int iface_idx, int mss)
+{
+	struct rtnl_route *route;
+
+	route = rtnl_route_alloc ();
+	if (route) {
+		rtnl_route_set_oif (route, iface_idx);
+
+		if (mss && rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0) {
+			nm_log_warn (LOGD_DEVICE, "could not set mss");
+		}
+	} else
+		nm_log_err (LOGD_DEVICE, "could not allocate route");
+
+	return route;
+}
+
+static struct rtnl_route *
+nm_system_device_set_ip4_route (const char *iface, 
+                                guint32 ip4_dest,
+                                guint32 ip4_prefix,
+                                guint32 ip4_gateway,
+                                guint32 metric,
+                                int mss)
+{
+	struct nl_handle *nlh;
+	struct rtnl_route *route;
+	struct nl_addr *dest_addr;
+	struct nl_addr *gw_addr = NULL;
+	int err, iface_idx;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, NULL);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	g_return_val_if_fail (iface_idx >= 0, NULL);
+
+	route = create_route (iface_idx, mss);
+	g_return_val_if_fail (route != NULL, NULL);
+
+	/* Destination */
+	dest_addr = nl_addr_build (AF_INET, &ip4_dest, sizeof (ip4_dest));
+	g_return_val_if_fail (dest_addr != NULL, NULL);
+	nl_addr_set_prefixlen (dest_addr, (int) ip4_prefix);
+
+	rtnl_route_set_dst (route, dest_addr);
+	nl_addr_put (dest_addr);
+
+	/* Gateway */
+	if (ip4_gateway) {
+		gw_addr = nl_addr_build (AF_INET, &ip4_gateway, sizeof (ip4_gateway));
+		if (gw_addr) {
+			rtnl_route_set_gateway (route, gw_addr);
+			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
+		} else {
+			nm_log_err (LOGD_DEVICE | LOGD_IP4, "Invalid gateway 0x%X", ip4_gateway);
+			rtnl_route_put (route);
+			return NULL;
+		}
+	}
+
+	/* Metric */
+	if (metric)
+		rtnl_route_set_prio (route, metric);
+
+	/* Add the route */
+	err = rtnl_route_add (nlh, route, 0);
+	if (err == -ESRCH && ip4_gateway) {
+		/* Gateway might be over a bridge; try adding a route to gateway first */
+		struct rtnl_route *route2;
+
+		route2 = create_route (iface_idx, mss);
+		if (route2) {
+			/* Add route to gateway over bridge */
+			rtnl_route_set_dst (route2, gw_addr);
+			err = rtnl_route_add (nlh, route2, 0);
+			if (!err) {
+				/* Try adding the route again */
+				err = rtnl_route_add (nlh, route, 0);
+				if (err)
+					rtnl_route_del (nlh, route2, 0);
+			}
+			rtnl_route_put (route2);
+		}
+	}
+
+	if (gw_addr)
+		nl_addr_put (gw_addr);
+
+	if (err) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 route: %s",
+		            iface, nl_geterror ());
+		rtnl_route_put (route);
+		route = NULL;
+	}
+
+	return route;
+}
+
+static gboolean
+sync_addresses (const char *iface, int ifindex, int family,
+				struct rtnl_addr **addrs, int num_addrs)
+{
+	struct nl_handle *nlh;
+	struct nl_cache *addr_cache;
+	struct rtnl_addr *filter_addr, *match_addr;
+	struct nl_object *match;
+	int i, err;
+	guint32 log_domain = (family == AF_INET) ? LOGD_IP4 : LOGD_IP6;
+
+	log_domain |= LOGD_DEVICE;
+
+	nlh = nm_netlink_get_default_handle ();
+	if (!nlh)
+		return FALSE;
+
+	addr_cache = rtnl_addr_alloc_cache (nlh);
+	if (!addr_cache)
+		return FALSE;
+
+	filter_addr = rtnl_addr_alloc ();
+	if (!filter_addr) {
+		nl_cache_free (addr_cache);
+		return FALSE;
+	}
+	rtnl_addr_set_ifindex (filter_addr, ifindex);
+	if (family)
+		rtnl_addr_set_family (filter_addr, family);
+
+	/* Walk through the cache, comparing the addresses already on
+	 * the interface to the addresses in addrs.
+	 */
+	for (match = nl_cache_get_first (addr_cache); match; match = nl_cache_get_next (match)) {
+		match_addr = (struct rtnl_addr *)match;
+
+		/* Skip addresses not on our interface */
+		if (!nl_object_match_filter (match, (struct nl_object *)filter_addr))
+			continue;
+
+		if (addrs) {
+			for (i = 0; i < num_addrs; i++) {
+				if (addrs[i] &&
+					nl_object_identical (match, (struct nl_object *)addrs[i]))
+					break;
+			}
+
+			if (addrs[i]) {
+				/* match == addrs[i], so remove it from addrs so we don't
+				 * try to add it to the interface again below.
+				 */
+				rtnl_addr_put (addrs[i]);
+				addrs[i] = NULL;
+				continue;
+			}
+		}
+
+		/* Don't delete IPv6 link-local addresses; they don't belong to NM */
+		if (rtnl_addr_get_family (match_addr) == AF_INET6 &&
+			rtnl_addr_get_scope (match_addr) == RT_SCOPE_LINK) {
+			continue;
+		}
+
+		/* Otherwise, match_addr should be removed from the interface. */
+		err = rtnl_addr_delete (nlh, match_addr, 0);
+		if (err < 0) {
+			nm_log_err (log_domain, "(%s): error %d returned from rtnl_addr_delete(): %s",
+						iface, err, nl_geterror ());
+		}
+	}
+
+	rtnl_addr_put (filter_addr);
+	nl_cache_free (addr_cache);
+
+	/* Now add the remaining new addresses */
+	for (i = 0; i < num_addrs; i++) {
+		if (!addrs[i])
+			continue;
+
+		err = rtnl_addr_add (nlh, addrs[i], 0);
+		if (err < 0) {
+			nm_log_err (log_domain,
+			            "(%s): error %d returned from rtnl_addr_add():\n%s",
+						iface, err, nl_geterror ());
+		}
+
+		rtnl_addr_put (addrs[i]);
+	}
+	g_free (addrs);
+
+	return TRUE;
+}
+
+static gboolean
+add_ip4_addresses (NMIP4Config *config, const char *iface)
+{
+	int num_addrs, i, iface_idx;
+	guint32 flags = 0;
+	gboolean did_gw = FALSE;
+	struct rtnl_addr **addrs;
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+
+	num_addrs = nm_ip4_config_get_num_addresses (config);
+	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
+
+	for (i = 0; i < num_addrs; i++) {
+		NMIP4Address *addr;
+
+		addr = nm_ip4_config_get_address (config, i);
+		g_assert (addr);
+
+		flags = NM_RTNL_ADDR_DEFAULT;
+		if (nm_ip4_address_get_gateway (addr) && !did_gw) {
+			if (nm_ip4_config_get_ptp_address (config))
+				flags |= NM_RTNL_ADDR_PTP_ADDR;
+			did_gw = TRUE;
+		}
+
+		addrs[i] = nm_ip4_config_to_rtnl_addr (config, i, flags);
+		if (!addrs[i]) {
+			nm_log_warn (LOGD_DEVICE | LOGD_IP4,
+			             "(%s): couldn't create rtnl address!",
+			             iface);
+			continue;
+		}
+		rtnl_addr_set_ifindex (addrs[i], iface_idx);
+	}
+
+	return sync_addresses (iface, iface_idx, AF_INET, addrs, num_addrs);
+}
+
+struct rtnl_route *
+nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config)
+{
+	NMIP4Config *parent_config;
+	guint32 parent_gw = 0, parent_prefix = 0, vpn_gw = 0, i;
+	NMIP4Address *tmp;
+	struct rtnl_route *route = NULL;
+
+	g_return_val_if_fail (NM_IS_DEVICE (parent_device), NULL);
+
+	/* Set up a route to the VPN gateway's public IP address through the default
+	 * network device if the VPN gateway is on a different subnet.
+	 */
+
+	parent_config = nm_device_get_ip4_config (parent_device);
+	g_return_val_if_fail (parent_config != NULL, NULL);
+
+	for (i = 0; i < nm_ip4_config_get_num_addresses (parent_config); i++) {
+		tmp = nm_ip4_config_get_address (parent_config, i);
+		if (nm_ip4_address_get_gateway (tmp)) {
+			parent_gw = nm_ip4_address_get_gateway (tmp);
+			parent_prefix = nm_ip4_address_get_prefix (tmp);
+			break;
+		}
+	}
+
+	for (i = 0; i < nm_ip4_config_get_num_addresses (vpn_config); i++) {
+		tmp = nm_ip4_config_get_address (vpn_config, i);
+		if (nm_ip4_address_get_gateway (tmp)) {
+			vpn_gw = nm_ip4_address_get_gateway (tmp);
+			break;
+		}
+	}
+
+	if (!parent_gw || !vpn_gw)
+		return NULL;
+
+	/* If the VPN gateway is in the same subnet as one of the parent device's
+	 * IP addresses, don't add the host route to it, but a route through the
+	 * parent device.
+	 */
+	if (ip4_dest_in_same_subnet (parent_config, vpn_gw, parent_prefix)) {
+		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
+		                                        vpn_gw, 32, 0, 0, nm_ip4_config_get_mss (parent_config));
+	} else {
+		route = nm_system_device_set_ip4_route (nm_device_get_ip_iface (parent_device),
+		                                        vpn_gw, 32, parent_gw, 0, nm_ip4_config_get_mss (parent_config));
+	}
+
+	return route;
+}
+
+/*
+ * nm_system_apply_ip4_config
+ *
+ * Set IPv4 configuration of the device from an NMIP4Config object.
+ *
+ */
+gboolean
+nm_system_apply_ip4_config (const char *iface,
+                            NMIP4Config *config,
+                            int priority,
+                            NMIP4ConfigCompareFlags flags)
+{
+	int i;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (config != NULL, FALSE);
+
+	if (flags & NM_IP4_COMPARE_FLAG_ADDRESSES) {
+		if (!add_ip4_addresses (config, iface))
+			return FALSE;
+		sleep (1);
+	}
+
+	if (flags & NM_IP4_COMPARE_FLAG_ROUTES) {
+		for (i = 0; i < nm_ip4_config_get_num_routes (config); i++) {
+			NMIP4Route *route = nm_ip4_config_get_route (config, i);
+			struct rtnl_route *tmp;
+
+			/* Don't add the route if it's more specific than one of the subnets
+			 * the device already has an IP address on.
+			 */
+			if (ip4_dest_in_same_subnet (config,
+			                             nm_ip4_route_get_dest (route),
+			                             nm_ip4_route_get_prefix (route)))
+				continue;
+
+			/* Don't add the route if it doesn't have a gateway and the connection
+			 * is never supposed to be the default connection.
+			 */
+			if (   nm_ip4_config_get_never_default (config)
+			    && nm_ip4_route_get_dest (route) == 0)
+				continue;
+
+			tmp = nm_system_device_set_ip4_route (iface,
+			                                      nm_ip4_route_get_dest (route),
+			                                      nm_ip4_route_get_prefix (route),
+			                                      nm_ip4_route_get_next_hop (route),
+			                                      nm_ip4_route_get_metric (route),
+			                                      nm_ip4_config_get_mss (config));
+			rtnl_route_put (tmp);
+		}
+	}
+
+	if (flags & NM_IP4_COMPARE_FLAG_MTU) {
+		if (nm_ip4_config_get_mtu (config))
+			nm_system_device_set_mtu (iface, nm_ip4_config_get_mtu (config));
+	}
+
+	if (priority > 0)
+		nm_system_device_set_priority (iface, config, priority);
+
+	return TRUE;
+}
+
+static struct rtnl_route *
+nm_system_device_set_ip6_route (const char *iface,
+                                const struct in6_addr *ip6_dest,
+                                guint32 ip6_prefix,
+                                const struct in6_addr *ip6_gateway,
+                                guint32 metric,
+                                int mss)
+{
+	struct nl_handle *nlh;
+	struct rtnl_route *route;
+	struct nl_addr *dest_addr;
+	struct nl_addr *gw_addr = NULL;
+	int err, iface_idx;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, NULL);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	g_return_val_if_fail (iface_idx >= 0, NULL);
+
+	route = create_route (iface_idx, mss);
+	g_return_val_if_fail (route != NULL, NULL);
+
+	/* Destination */
+	dest_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_dest, sizeof (*ip6_dest));
+	g_return_val_if_fail (dest_addr != NULL, NULL);
+	nl_addr_set_prefixlen (dest_addr, (int) ip6_prefix);
+
+	rtnl_route_set_dst (route, dest_addr);
+	nl_addr_put (dest_addr);
+
+	/* Gateway */
+	if (ip6_gateway && !IN6_IS_ADDR_UNSPECIFIED (ip6_gateway)) {
+		gw_addr = nl_addr_build (AF_INET6, (struct in6_addr *)ip6_gateway, sizeof (*ip6_gateway));
+		if (gw_addr) {
+			rtnl_route_set_gateway (route, gw_addr);
+			rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
+		} else {
+			nm_log_warn (LOGD_DEVICE | LOGD_IP6, "Invalid gateway");
+			rtnl_route_put (route);
+			return NULL;
+		}
+	}
+
+	/* Metric */
+	if (metric)
+		rtnl_route_set_prio (route, metric);
+
+	/* Add the route */
+	err = rtnl_route_add (nlh, route, 0);
+	if (err == -ESRCH && ip6_gateway) {
+		/* Gateway might be over a bridge; try adding a route to gateway first */
+		struct rtnl_route *route2;
+
+		route2 = create_route (iface_idx, mss);
+		if (route2) {
+			/* Add route to gateway over bridge */
+			rtnl_route_set_dst (route2, gw_addr);
+			err = rtnl_route_add (nlh, route2, 0);
+			if (!err) {
+				/* Try adding the route again */
+				err = rtnl_route_add (nlh, route, 0);
+				if (err)
+					rtnl_route_del (nlh, route2, 0);
+			}
+			rtnl_route_put (route2);
+		}
+	}
+
+	if (gw_addr)
+		nl_addr_put (gw_addr);
+
+	if (err) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP6,
+		            "(%s): failed to set IPv6 route: %s",
+		            iface, nl_geterror ());
+		rtnl_route_put (route);
+		route = NULL;
+	}
+
+	return route;
+}
+
+static gboolean
+add_ip6_addresses (NMIP6Config *config, const char *iface)
+{
+	int num_addrs, i, iface_idx;
+	struct rtnl_addr **addrs;
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+
+	num_addrs = nm_ip6_config_get_num_addresses (config);
+	addrs = g_new0 (struct rtnl_addr *, num_addrs + 1);
+
+	for (i = 0; i < num_addrs; i++) {
+		NMIP6Address *addr;
+
+		addr = nm_ip6_config_get_address (config, i);
+		g_assert (addr);
+
+		addrs[i] = nm_ip6_config_to_rtnl_addr (config, i, NM_RTNL_ADDR_DEFAULT);
+		if (!addrs[i]) {
+			nm_log_warn (LOGD_DEVICE | LOGD_IP6,
+			             "(%s): couldn't create rtnl address!",
+			             iface);
+			continue;
+		}
+		rtnl_addr_set_ifindex (addrs[i], iface_idx);
+	}
+
+	return sync_addresses (iface, iface_idx, AF_INET6, addrs, num_addrs);
+}
+
+/*
+ * nm_system_apply_ip6_config
+ *
+ * Set IPv6 configuration of the device from an NMIP6Config object.
+ *
+ */
+gboolean
+nm_system_apply_ip6_config (const char *iface,
+                            NMIP6Config *config,
+                            int priority,
+                            NMIP6ConfigCompareFlags flags)
+{
+	int i;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (config != NULL, FALSE);
+
+	if (flags & NM_IP6_COMPARE_FLAG_ADDRESSES) {
+		if (!add_ip6_addresses (config, iface))
+			return FALSE;
+		sleep (1); // FIXME?
+	}
+
+	if (flags & NM_IP6_COMPARE_FLAG_ROUTES) {
+		for (i = 0; i < nm_ip6_config_get_num_routes (config); i++) {
+			NMIP6Route *route = nm_ip6_config_get_route (config, i);
+			struct rtnl_route *tmp;
+
+			/* Don't add the route if it doesn't have a gateway and the connection
+			 * is never supposed to be the default connection.
+			 */
+			if (   nm_ip6_config_get_never_default (config)
+			    && IN6_IS_ADDR_UNSPECIFIED(nm_ip6_route_get_dest (route)))
+				continue;
+
+			tmp = nm_system_device_set_ip6_route (iface,
+			                                      nm_ip6_route_get_dest (route),
+			                                      nm_ip6_route_get_prefix (route),
+			                                      nm_ip6_route_get_next_hop (route),
+			                                      nm_ip6_route_get_metric (route),
+			                                      nm_ip6_config_get_mss (config));
+			rtnl_route_put (tmp);
+		}
+	}
+
+// FIXME
+//	if (priority > 0)
+//		nm_system_device_set_priority (iface, config, priority);
+
+	return TRUE;
+}
+
+/*
+ * nm_system_device_set_up_down
+ *
+ * Mark the device as up or down.
+ *
+ */
+gboolean
+nm_system_device_set_up_down (NMDevice *dev,
+                              gboolean up,
+                              gboolean *no_firmware)
+{
+	g_return_val_if_fail (dev != NULL, FALSE);
+
+	return nm_system_device_set_up_down_with_iface (nm_device_get_ip_iface (dev), up, no_firmware);
+}
+
+gboolean
+nm_system_device_set_up_down_with_iface (const char *iface,
+                                         gboolean up,
+                                         gboolean *no_firmware)
+{
+	struct rtnl_link *request = NULL, *old = NULL;
+	struct nl_handle *nlh;
+	gboolean success = FALSE;
+	guint32 idx;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	if (no_firmware)
+		g_return_val_if_fail (*no_firmware == FALSE, FALSE);
+
+	if (!(request = rtnl_link_alloc ()))
+		goto out;
+
+	if (up)
+		rtnl_link_set_flags (request, IFF_UP);
+	else
+		rtnl_link_unset_flags (request, IFF_UP);
+
+	idx = nm_netlink_iface_to_index (iface);
+	old = nm_netlink_index_to_rtnl_link (idx);
+	if (old) {
+		nlh = nm_netlink_get_default_handle ();
+		if (nlh) {
+			if (rtnl_link_change (nlh, old, request, 0) == 0)
+				success = TRUE;
+			else if ((nl_get_errno () == ENOENT) && no_firmware && up)
+				*no_firmware = TRUE;
+		}
+	}
+
+	rtnl_link_put (old);
+	rtnl_link_put (request);
+
+out:
+	return success;
+}
+
+gboolean
+nm_system_device_is_up (NMDevice *device)
+{
+	g_return_val_if_fail (device != NULL, FALSE);
+
+	return nm_system_device_is_up_with_iface (nm_device_get_ip_iface (device));
+}
+
+gboolean
+nm_system_device_is_up_with_iface (const char *iface)
+{
+	struct ifreq ifr;
+	int fd;
+	gboolean up = FALSE;
+
+	fd = socket (PF_INET, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		nm_log_err (LOGD_HW, "couldn't open control socket.");
+		return FALSE;
+	}
+
+	/* Get device's flags */
+	memset (&ifr, 0, sizeof (ifr));
+	strncpy (ifr.ifr_name, iface, IFNAMSIZ);
+	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0) {
+		if (errno != ENODEV) {
+			nm_log_err (LOGD_HW, "(%s): could not get flags: errno %d",
+			            iface, errno);
+		}
+	} else {
+		up = !!(ifr.ifr_flags & IFF_UP);
+	}
+	close (fd);
+
+	return up;
+}
+
+gboolean
+nm_system_device_set_mtu (const char *iface, guint32 mtu)
+{
+	struct rtnl_link *old;
+	struct rtnl_link *new;
+	gboolean success = FALSE;
+	struct nl_handle *nlh;
+	int iface_idx;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+	g_return_val_if_fail (mtu > 0, FALSE);
+
+	new = rtnl_link_alloc ();
+	if (!new)
+		return FALSE;
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	old = nm_netlink_index_to_rtnl_link (iface_idx);
+	if (old) {
+		rtnl_link_set_mtu (new, mtu);
+		nlh = nm_netlink_get_default_handle ();
+		if (nlh) {
+			rtnl_link_change (nlh, old, new, 0);
+			success = TRUE;
+		}
+		rtnl_link_put (old);
+	}
+
+	rtnl_link_put (new);
+	return success;
+}
+
+static struct rtnl_route *
+add_ip4_route_to_gateway (const char *iface, guint32 gw, guint32 mss)
+{
+	struct nl_handle *nlh;
+	struct rtnl_route *route = NULL;
+	struct nl_addr *gw_addr = NULL;
+	int iface_idx, err;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, NULL);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx < 0)
+		return NULL;
+
+	/* Gateway might be over a bridge; try adding a route to gateway first */
+	route = rtnl_route_alloc ();
+	if (route == NULL)
+		return NULL;
+
+	rtnl_route_set_family (route, AF_INET);
+	rtnl_route_set_table (route, RT_TABLE_MAIN);
+	rtnl_route_set_oif (route, iface_idx);
+	rtnl_route_set_scope (route, RT_SCOPE_LINK);
+
+	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
+	if (!gw_addr)
+		goto error;
+	nl_addr_set_prefixlen (gw_addr, 32);
+	rtnl_route_set_dst (route, gw_addr);
+	nl_addr_put (gw_addr);
+
+	if (mss) {
+		if (rtnl_route_set_metric (route, RTAX_ADVMSS, mss) < 0)
+			goto error;
+	}
+
+	/* Add direct route to the gateway */
+	err = rtnl_route_add (nlh, route, 0);
+	if (err) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to add IPv4 route to gateway (%d)",
+		            iface, err);
+		goto error;
+	}
+
+	return route;
+
+error:
+	rtnl_route_put (route);
+	return NULL;
+}
+
+static int
+replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
+{
+	struct rtnl_route *route = NULL;
+	struct nl_handle *nlh;
+	struct nl_addr *dst_addr = NULL;
+	guint32 dst = 0;
+	struct nl_addr *gw_addr = NULL;
+	int iface_idx, err = -1;
+
+	g_return_val_if_fail (iface != NULL, -ENODEV);
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, -ENOMEM);
+
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx < 0)
+		return -ENODEV;
+
+	route = rtnl_route_alloc();
+	g_return_val_if_fail (route != NULL, -ENOMEM);
+
+	rtnl_route_set_family (route, AF_INET);
+	rtnl_route_set_table (route, RT_TABLE_MAIN);
+	rtnl_route_set_scope (route, RT_SCOPE_UNIVERSE);
+	rtnl_route_set_oif (route, iface_idx);
+
+	/* Build up the destination address */
+	dst_addr = nl_addr_build (AF_INET, &dst, sizeof (dst));
+	if (!dst_addr) {
+		err = -ENOMEM;
+		goto out;
+	}
+	nl_addr_set_prefixlen (dst_addr, 0);
+	rtnl_route_set_dst (route, dst_addr);
+
+	/* Build up the gateway address */
+	gw_addr = nl_addr_build (AF_INET, &gw, sizeof (gw));
+	if (!gw_addr) {
+		err = -ENOMEM;
+		goto out;
+	}
+	nl_addr_set_prefixlen (gw_addr, 0);
+	rtnl_route_set_gateway (route, gw_addr);
+
+	if (mss > 0) {
+		err = rtnl_route_set_metric (route, RTAX_ADVMSS, mss);
+		if (err < 0)
+			goto out;
+	}
+
+	/* Add the new default route */
+	err = rtnl_route_add (nlh, route, NLM_F_REPLACE);
+
+out:
+	if (dst_addr)
+		nl_addr_put (dst_addr);
+	if (gw_addr)
+		nl_addr_put (gw_addr);
+	rtnl_route_put (route);
+	return err;
+}
+
+/*
+ * nm_system_replace_default_ip4_route_vpn
+ *
+ * Replace default IPv4 route with one via the current device
+ *
+ */
+gboolean
+nm_system_replace_default_ip4_route_vpn (const char *iface,
+                                         guint32 ext_gw,
+                                         guint32 int_gw,
+                                         guint32 mss,
+                                         const char *parent_iface,
+                                         guint32 parent_mss)
+{
+	struct rtnl_route *gw_route = NULL;
+	struct nl_handle *nlh;
+	gboolean success = FALSE;
+	int err;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, FALSE);
+
+	err = replace_default_ip4_route (iface, int_gw, mss);
+	if (err == 0) {
+		return TRUE;
+	} else if (err != -ESRCH) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route: %d",
+		            iface, err);
+		return FALSE;
+	}
+
+	/* Try adding a direct route to the gateway first */
+	gw_route = add_ip4_route_to_gateway (parent_iface, ext_gw, parent_mss);
+	if (!gw_route)
+		return FALSE;
+
+	/* Try adding the original route again */
+	err = replace_default_ip4_route (iface, int_gw, mss);
+	if (err != 0) {
+		rtnl_route_del (nlh, gw_route, 0);
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route (pass #2): %d",
+		            iface, err);
+	} else
+		success = TRUE;
+
+	rtnl_route_put (gw_route);
+	return success;
+}
+
+/*
+ * nm_system_replace_default_ip4_route
+ *
+ * Replace default IPv4 route with one via the current device
+ *
+ */
+gboolean
+nm_system_replace_default_ip4_route (const char *iface, guint32 gw, guint32 mss)
+{
+	struct rtnl_route *gw_route = NULL;
+	struct nl_handle *nlh;
+	gboolean success = FALSE;
+	int err;
+
+	nlh = nm_netlink_get_default_handle ();
+	g_return_val_if_fail (nlh != NULL, FALSE);
+
+	err = replace_default_ip4_route (iface, gw, mss);
+	if (err == 0) {
+		return TRUE;
+	} else if (err != -ESRCH) {
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route: %d",
+		            iface, err);
+		return FALSE;
+	}
+
+	/* Try adding a direct route to the gateway first */
+	gw_route = add_ip4_route_to_gateway (iface, gw, mss);
+	if (!gw_route)
+		return FALSE;
+
+	/* Try adding the original route again */
+	err = replace_default_ip4_route (iface, gw, mss);
+	if (err != 0) {
+		rtnl_route_del (nlh, gw_route, 0);
+		nm_log_err (LOGD_DEVICE | LOGD_IP4,
+		            "(%s): failed to set IPv4 default route (pass #2): %d",
+		            iface, err);
+	} else
+		success = TRUE;
+
+	rtnl_route_put (gw_route);
+	return success;
+}
+
+static void flush_addresses (const char *iface, gboolean ipv4_only)
+{
+	int iface_idx;
+
+	g_return_if_fail (iface != NULL);
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx >= 0)
+		sync_addresses (iface, iface_idx, ipv4_only ? AF_INET : 0, NULL, 0);
+}
+
+/*
+ * nm_system_device_flush_addresses
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_addresses (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	flush_addresses (nm_device_get_ip_iface (dev),
+					 nm_device_get_ip6_config (dev) == NULL);
+}
+
+
+/*
+ * nm_system_device_flush_addresses_with_iface
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_addresses_with_iface (const char *iface)
+{
+	flush_addresses (iface, FALSE);
+}
+
+
+static void
+foreach_route (void (*callback)(struct nl_object *, gpointer),
+			gpointer user_data)
+{
+	struct nl_handle *nlh;
+	struct nl_cache *route_cache;
+
+	nlh = nm_netlink_get_default_handle ();
+	route_cache = rtnl_route_alloc_cache (nlh);
+	nl_cache_mngt_provide (route_cache);
+	nl_cache_foreach (route_cache, callback, user_data);
+	nl_cache_free (route_cache);
+}
+
+
+typedef struct {
+	const char *iface;
+	int iface_idx;
+	int family;
+} RouteCheckData;
+
+static void
+check_one_route (struct nl_object *object, void *user_data)
+{
+	RouteCheckData *data = (RouteCheckData *) user_data;
+	struct rtnl_route *route = (struct rtnl_route *) object;
+	int err;
+
+	/* Delete all routes from this interface */
+	if (rtnl_route_get_oif (route) != data->iface_idx)
+		return;
+	if (data->family && rtnl_route_get_family (route) != data->family)
+		return;
+
+	err = rtnl_route_del (nm_netlink_get_default_handle (), route, 0);
+	if (err < 0) {
+		nm_log_err (LOGD_DEVICE,
+		            "(%s): error %d returned from rtnl_route_del(): %s",
+		            data->iface, err, nl_geterror());
+	}
+}
+
+static void flush_routes (const char *iface, gboolean ipv4_only)
+{
+	int iface_idx;
+	RouteCheckData check_data;
+
+	g_return_if_fail (iface != NULL);
+	iface_idx = nm_netlink_iface_to_index (iface);
+	if (iface_idx >= 0) {
+		memset (&check_data, 0, sizeof (check_data));
+		check_data.iface = iface;
+		check_data.iface_idx = iface_idx;
+		check_data.family = ipv4_only ? AF_INET : 0;
+
+		foreach_route (check_one_route, &check_data);
+	}
+}
+
+/*
+ * nm_system_device_flush_routes
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_routes (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	flush_routes (nm_device_get_ip_iface (dev),
+				  nm_device_get_ip6_config (dev) == NULL);
+}
+
+/*
+ * nm_system_device_flush_routes_with_iface
+ *
+ * Flush all routes associated with a network device
+ *
+ */
+void nm_system_device_flush_routes_with_iface (const char *iface)
+{
+	flush_routes (iface, FALSE);
+}
+
+typedef struct {
+	struct rtnl_route *route;
+	NMIP4Config *config;
+	int iface;
+} SetPriorityInfo;
+
+static void
+find_route (struct nl_object *object, gpointer user_data)
+{
+	struct rtnl_route *route = (struct rtnl_route *) object;
+	SetPriorityInfo *info = (SetPriorityInfo *) user_data;
+	struct nl_addr *dst;
+	struct in_addr *dst_addr;
+	int num;
+	int i;
+
+	if (info->route ||
+	    rtnl_route_get_oif (route) != info->iface ||
+	    rtnl_route_get_scope (route) != RT_SCOPE_LINK)
+		return;
+
+	dst = rtnl_route_get_dst (route);
+	if (nl_addr_get_family (dst) != AF_INET)
+		return;
+
+	dst_addr = nl_addr_get_binary_addr (dst);
+	num = nm_ip4_config_get_num_addresses (info->config);
+	for (i = 0; i < num; i++) {
+		NMIP4Address *addr = nm_ip4_config_get_address (info->config, i);
+		guint32 prefix = nm_ip4_address_get_prefix (addr);
+		guint32 address = nm_ip4_address_get_address (addr);
+
+		if (prefix == nl_addr_get_prefixlen (dst) &&
+		    (address & nm_utils_ip4_prefix_to_netmask (prefix)) == dst_addr->s_addr) {
+
+			/* Ref the route so it sticks around after the cache is cleared */
+			rtnl_route_get (route);
+			info->route = route;
+			break;
+		}
+	}
+}
+
+static void
+nm_system_device_set_priority (const char *iface,
+						 NMIP4Config *config,
+						 int priority)
+{
+	SetPriorityInfo info;
+
+	info.route = NULL;
+	info.config = config;
+	info.iface = nm_netlink_iface_to_index (iface);
+	g_return_if_fail (info.iface >= 0);
+
+	foreach_route (find_route, &info);
+	if (info.route) {
+		struct nl_handle *nlh;
+
+		nlh = nm_netlink_get_default_handle ();
+		rtnl_route_del (nlh, info.route, 0);
+
+		rtnl_route_set_prio (info.route, priority);
+		rtnl_route_add (nlh, info.route, 0);
+		rtnl_route_put (info.route);
+	}
+}
diff --git a/src/nm-system.h b/src/nm-system.h
new file mode 100644
index 0000000..f2c2693
--- /dev/null
+++ b/src/nm-system.h
@@ -0,0 +1,81 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2005 - 2008 Novell, Inc.
+ */
+
+#ifndef NETWORK_MANAGER_SYSTEM_H
+#define NETWORK_MANAGER_SYSTEM_H
+
+#include <netlink/route/rtnl.h>
+#include <netlink/route/route.h>
+
+#include <glib.h>
+#include "nm-device.h"
+#include "nm-ip4-config.h"
+
+/* Prototypes for system/distribution dependent functions,
+ * implemented in the backend files in backends/ directory
+ */
+
+void			nm_system_device_flush_routes				(NMDevice *dev);
+void			nm_system_device_flush_routes_with_iface	(const char *iface);
+
+gboolean		nm_system_replace_default_ip4_route   (const char *iface,
+                                                       guint32 gw,
+                                                       guint32 mss);
+
+gboolean		nm_system_replace_default_ip4_route_vpn (const char *iface,
+                                                         guint32 ext_gw,
+                                                         guint32 int_gw,
+                                                         guint32 mss,
+                                                         const char *parent_iface,
+                                                         guint32 parent_mss);
+
+struct rtnl_route *nm_system_add_ip4_vpn_gateway_route (NMDevice *parent_device, NMIP4Config *vpn_config);
+
+
+void			nm_system_device_flush_addresses			(NMDevice *dev);
+void			nm_system_device_flush_addresses_with_iface	(const char *iface);
+
+void			nm_system_enable_loopback				(void);
+void			nm_system_update_dns					(void);
+
+gboolean		nm_system_apply_ip4_config              (const char *iface,
+                                                         NMIP4Config *config,
+                                                         int priority,
+                                                         NMIP4ConfigCompareFlags flags);
+
+gboolean		nm_system_apply_ip6_config              (const char *iface,
+                                                         NMIP6Config *config,
+                                                         int priority,
+                                                         NMIP6ConfigCompareFlags flags);
+
+gboolean		nm_system_device_set_up_down				(NMDevice *dev,
+                                                             gboolean up,
+                                                             gboolean *no_firmware);
+gboolean		nm_system_device_set_up_down_with_iface		(const char *iface,
+                                                             gboolean up,
+                                                             gboolean *no_firmware);
+
+gboolean        nm_system_device_is_up (NMDevice *device);
+gboolean        nm_system_device_is_up_with_iface (const char *iface);
+
+gboolean		nm_system_device_set_mtu (const char *iface, guint32 mtu);
+
+#endif
diff --git a/src/nm-udev-manager.c b/src/nm-udev-manager.c
index 956068d..1e84c04 100644
--- a/src/nm-udev-manager.c
+++ b/src/nm-udev-manager.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <signal.h>
@@ -33,7 +33,7 @@
 
 #include "nm-udev-manager.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "NetworkManagerUtils.h"
 #include "nm-device-wifi.h"
 #include "nm-device-olpc-mesh.h"
@@ -82,6 +82,30 @@ nm_udev_manager_get_rfkill_state (NMUdevManager *self, RfKillType rtype)
 	return NM_UDEV_MANAGER_GET_PRIVATE (self)->rfkill_states[rtype];
 }
 
+static const char *
+rfkill_type_to_desc (RfKillType rtype)
+{
+	if (rtype == 0)
+		return "WiFi";
+	else if (rtype == 1)
+		return "WWan";
+	else if (rtype == 2)
+		return "WiMAX";
+	return "unknown";
+}
+
+static const char *
+rfkill_state_to_desc (RfKillState rstate)
+{
+	if (rstate == 0)
+		return "unblocked";
+	else if (rstate == 1)
+		return "soft-blocked";
+	else if (rstate == 2)
+		return "hard-blocked";
+	return "unknown";
+}
+
 static Killswitch *
 killswitch_new (GUdevDevice *device, RfKillType rtype)
 {
@@ -139,7 +163,7 @@ sysfs_state_to_nm_state (gint sysfs_state)
 	case 2:
 		return RFKILL_HARD_BLOCKED;
 	default:
-		g_warning ("%s: Unhandled rfkill state %d", __func__, sysfs_state);
+		nm_log_warn (LOGD_RFKILL, "unhandled rfkill state %d", sysfs_state);
 		break;
 	}
 	return RFKILL_UNBLOCKED;
@@ -175,6 +199,10 @@ recheck_killswitches (NMUdevManager *self)
 
 	for (i = 0; i < RFKILL_TYPE_MAX; i++) {
 		if (poll_states[i] != priv->rfkill_states[i]) {
+			nm_log_dbg (LOGD_RFKILL, "%s rfkill state now '%s'",
+			            rfkill_type_to_desc (i),
+			            rfkill_state_to_desc (poll_states[i]));
+
 			priv->rfkill_states[i] = poll_states[i];
 			g_signal_emit (self, signals[RFKILL_CHANGED], 0, i, priv->rfkill_states[i]);
 		}
@@ -229,11 +257,11 @@ add_one_killswitch (NMUdevManager *self, GUdevDevice *device)
 	ks = killswitch_new (device, rtype);
 	priv->killswitches = g_slist_prepend (priv->killswitches, ks);
 
-	nm_info ("Found %s radio killswitch %s (at %s) (driver %s)",
-	         str_type,
-	         ks->name,
-	         ks->path,
-	         ks->driver ? ks->driver : "<unknown>");
+	nm_log_info (LOGD_RFKILL, "found %s radio killswitch %s (at %s) (driver %s)",
+	             rfkill_type_to_desc (rtype),
+	             ks->name,
+	             ks->path,
+	             ks->driver ? ks->driver : "<unknown>");
 }
 
 static void
@@ -265,7 +293,7 @@ rfkill_remove (NMUdevManager *self,
 		Killswitch *ks = iter->data;
 
 		if (!strcmp (ks->name, name)) {
-			nm_info ("Radio killswitch %s disappeared", ks->path);
+			nm_log_info (LOGD_RFKILL, "radio killswitch %s disappeared", ks->path);
 			priv->killswitches = g_slist_remove (priv->killswitches, ks);
 			killswitch_destroy (ks);
 			break;
@@ -322,7 +350,7 @@ device_creator (NMUdevManager *manager,
 
 	path = g_udev_device_get_sysfs_path (udev_device);
 	if (!path) {
-		nm_warning ("couldn't determine device path; ignoring...");
+		nm_log_warn (LOGD_HW, "couldn't determine device path; ignoring...");
 		return NULL;
 	}
 
@@ -345,13 +373,13 @@ device_creator (NMUdevManager *manager,
 	}
 
 	if (!driver) {
-		nm_warning ("%s: couldn't determine device driver; ignoring...", path);
+		nm_log_warn (LOGD_HW, "%s: couldn't determine device driver; ignoring...", path);
 		goto out;
 	}
 
 	ifindex = g_udev_device_get_sysfs_attr_as_int (udev_device, "ifindex");
 	if (ifindex <= 0) {
-		nm_warning ("%s: device had invalid ifindex %d; ignoring...", path, (guint32) ifindex);
+		nm_log_warn (LOGD_HW, "%s: device had invalid ifindex %d; ignoring...", path, (guint32) ifindex);
 		goto out;
 	}
 
@@ -373,18 +401,36 @@ out:
 static void
 net_add (NMUdevManager *self, GUdevDevice *device)
 {
-	gint devtype;
+	gint etype;
 	const char *iface;
+	const char *devtype;
 
 	g_return_if_fail (device != NULL);
 
-	devtype = g_udev_device_get_sysfs_attr_as_int (device, "type");
-	if (devtype != 1)
+	etype = g_udev_device_get_sysfs_attr_as_int (device, "type");
+	if (etype != 1) {
+		nm_log_dbg (LOGD_HW, "ignoring interface with type %d", etype);
 		return; /* Not using ethernet encapsulation, don't care */
+	}
+
+	/* Not all ethernet devices are immediately usable; newer mobile broadband
+	 * devices (Ericsson, Option, Sierra) require setup on the tty before the
+	 * ethernet device is usable.  2.6.33 and later kernels set the 'DEVTYPE'
+	 * uevent variable which we can use to ignore the interface as a NMDevice
+	 * subclass.  ModemManager will pick it up though and so we'll handle it
+	 * through the mobile broadband stuff.
+	 */
+	devtype = g_udev_device_get_property (device, "DEVTYPE");
+	if (devtype && !strcmp (devtype, "wwan")) {
+		nm_log_dbg (LOGD_HW, "ignoring interface with devtype '%s'", devtype);
+		return;
+	}
 
 	iface = g_udev_device_get_name (device);
-	if (!iface)
+	if (!iface) {
+		nm_log_dbg (LOGD_HW, "failed to get device's interface");
 		return;
+	}
 
 	g_signal_emit (self, signals[DEVICE_ADDED], 0, device, device_creator);
 }
@@ -427,6 +473,9 @@ handle_uevent (GUdevClient *client,
 	subsys = g_udev_device_get_subsystem (device);
 	g_return_if_fail (subsys != NULL);
 
+	nm_log_dbg (LOGD_HW, "UDEV event: action '%s' subsys '%s' device '%s'",
+	            action, subsys, g_udev_device_get_name (device));
+
 	g_return_if_fail (!strcmp (subsys, "rfkill") || !strcmp (subsys, "net"));
 
 	if (!strcmp (action, "add")) {
diff --git a/src/nm-wifi-ap.c b/src/nm-wifi-ap.c
new file mode 100644
index 0000000..c7b5d8a
--- /dev/null
+++ b/src/nm-wifi-ap.c
@@ -0,0 +1,1477 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#include "wireless-helper.h"
+
+#include <string.h>
+
+#include "nm-wifi-ap.h"
+#include "NetworkManagerUtils.h"
+#include "nm-utils.h"
+#include "nm-logging.h"
+#include "nm-dbus-manager.h"
+#include "wpa.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-setting-wireless.h"
+
+#include "nm-access-point-glue.h"
+
+/*
+ * Encapsulates Access Point information
+ */
+typedef struct
+{
+	char *dbus_path;
+
+	/* Scanned or cached values */
+	GByteArray *	ssid;
+	struct ether_addr	address;
+	NM80211Mode		mode;
+	gint8			strength;
+	guint32			freq;		/* Frequency in MHz; ie 2412 (== 2.412 GHz) */
+	guint32			max_bitrate;/* Maximum bitrate of the AP in Kbit/s (ie 54000 Kb/s == 54Mbit/s) */
+
+	guint32			flags;		/* General flags */
+	guint32			wpa_flags;	/* WPA-related flags */
+	guint32			rsn_flags;	/* RSN (WPA2) -related flags */
+
+	/* Non-scanned attributes */
+	gboolean			fake;	/* Whether or not the AP is from a scan */
+	gboolean			broadcast;	/* Whether or not the AP is broadcasting (hidden) */
+	gboolean			user_created;	/* Whether or not the AP was created
+										 * by the user with "Create network..."
+										 * A subset of Ad-Hoc mode.  user_created
+										 * implies Ad-Hoc, but not necessarily
+										 * the other way around.
+										 */
+	glong				last_seen;	/* Last time the AP was seen in a scan in seconds */
+
+	/* Things from user prefs/NetworkManagerInfo */
+	GTimeVal			timestamp;
+	GSList *			user_addresses;
+} NMAccessPointPrivate;
+
+#define NM_AP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_AP, NMAccessPointPrivate))
+
+G_DEFINE_TYPE (NMAccessPoint, nm_ap, G_TYPE_OBJECT)
+
+enum {
+	PROPERTIES_CHANGED,
+
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum {
+	PROP_0,
+	PROP_FLAGS,
+	PROP_WPA_FLAGS,
+	PROP_RSN_FLAGS,
+	PROP_SSID,
+	PROP_FREQUENCY,
+	PROP_HW_ADDRESS,
+	PROP_MODE,
+	PROP_MAX_BITRATE,
+	PROP_STRENGTH,
+	LAST_PROP
+};
+
+static void
+nm_ap_init (NMAccessPoint *ap)
+{
+	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (ap);
+
+	priv->dbus_path = NULL;
+	priv->mode = NM_802_11_MODE_INFRA;
+	priv->flags = NM_802_11_AP_FLAGS_NONE;
+	priv->wpa_flags = NM_802_11_AP_SEC_NONE;
+	priv->rsn_flags = NM_802_11_AP_SEC_NONE;
+	priv->broadcast = TRUE;
+}
+
+static void
+finalize (GObject *object)
+{
+	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
+
+	g_free (priv->dbus_path);
+	if (priv->ssid)
+		g_byte_array_free (priv->ssid, TRUE);
+	g_slist_foreach (priv->user_addresses, (GFunc)g_free, NULL);
+	g_slist_free (priv->user_addresses);
+
+	G_OBJECT_CLASS (nm_ap_parent_class)->finalize (object);
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+		    const GValue *value, GParamSpec *pspec)
+{
+	NMAccessPoint *ap = NM_AP (object);
+
+	switch (prop_id) {
+	case PROP_FLAGS:
+		nm_ap_set_flags (ap, g_value_get_uint (value));
+		break;
+	case PROP_WPA_FLAGS:
+		nm_ap_set_wpa_flags (ap, g_value_get_uint (value));
+		break;
+	case PROP_RSN_FLAGS:
+		nm_ap_set_rsn_flags (ap, g_value_get_uint (value));
+		break;
+	case PROP_SSID:
+		nm_ap_set_ssid (ap, (GByteArray *) g_value_get_boxed (value));
+		break;
+	case PROP_FREQUENCY:
+		nm_ap_set_freq (ap, g_value_get_uint (value));
+		break;
+	case PROP_MODE:
+		nm_ap_set_mode (ap, g_value_get_uint (value));
+		break;
+	case PROP_MAX_BITRATE:
+		nm_ap_set_max_bitrate (ap, g_value_get_uint (value));
+		break;
+	case PROP_STRENGTH:
+		nm_ap_set_strength (ap, g_value_get_char (value));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+			  GValue *value, GParamSpec *pspec)
+{
+	NMAccessPointPrivate *priv = NM_AP_GET_PRIVATE (object);
+	GArray * ssid;
+	int len;
+	int i;
+
+	switch (prop_id) {
+	case PROP_FLAGS:
+		g_value_set_uint (value, priv->flags);
+		break;
+	case PROP_WPA_FLAGS:
+		g_value_set_uint (value, priv->wpa_flags);
+		break;
+	case PROP_RSN_FLAGS:
+		g_value_set_uint (value, priv->rsn_flags);
+		break;
+	case PROP_SSID:
+		len = priv->ssid ? priv->ssid->len : 0;
+		ssid = g_array_sized_new (FALSE, TRUE, sizeof (unsigned char), len);
+		for (i = 0; i < len; i++)
+			g_array_append_val (ssid, priv->ssid->data[i]);
+		g_value_set_boxed (value, ssid);
+		g_array_free (ssid, TRUE);
+		break;
+	case PROP_FREQUENCY:
+		g_value_set_uint (value, priv->freq);
+		break;
+	case PROP_HW_ADDRESS:
+		g_value_take_string (value, nm_ether_ntop (&priv->address));
+		break;
+	case PROP_MODE:
+		g_value_set_uint (value, priv->mode);
+		break;
+	case PROP_MAX_BITRATE:
+		g_value_set_uint (value, priv->max_bitrate);
+		break;
+	case PROP_STRENGTH:
+		g_value_set_char (value, priv->strength);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_ap_class_init (NMAccessPointClass *ap_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (ap_class);
+	guint32 all_sec_flags;
+
+	g_type_class_add_private (ap_class, sizeof (NMAccessPointPrivate));
+
+	/* virtual methods */
+	object_class->set_property = set_property;
+	object_class->get_property = get_property;
+	object_class->finalize = finalize;
+
+	/* properties */
+
+	all_sec_flags =   NM_802_11_AP_SEC_NONE
+	                | NM_802_11_AP_SEC_PAIR_WEP40
+	                | NM_802_11_AP_SEC_PAIR_WEP104
+	                | NM_802_11_AP_SEC_PAIR_TKIP
+	                | NM_802_11_AP_SEC_PAIR_CCMP
+	                | NM_802_11_AP_SEC_GROUP_WEP40
+	                | NM_802_11_AP_SEC_GROUP_WEP104
+	                | NM_802_11_AP_SEC_GROUP_TKIP
+	                | NM_802_11_AP_SEC_GROUP_CCMP
+	                | NM_802_11_AP_SEC_KEY_MGMT_PSK
+	                | NM_802_11_AP_SEC_KEY_MGMT_802_1X;
+
+	g_object_class_install_property
+		(object_class, PROP_FLAGS,
+		 g_param_spec_uint (NM_AP_FLAGS,
+							"Flags",
+							"Flags",
+							NM_802_11_AP_FLAGS_NONE,
+							NM_802_11_AP_FLAGS_PRIVACY,
+							NM_802_11_AP_FLAGS_NONE,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_WPA_FLAGS,
+		 g_param_spec_uint (NM_AP_WPA_FLAGS,
+							"WPA Flags",
+							"WPA Flags",
+							NM_802_11_AP_SEC_NONE,
+							all_sec_flags,
+							NM_802_11_AP_SEC_NONE,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_RSN_FLAGS,
+		 g_param_spec_uint (NM_AP_RSN_FLAGS,
+							"RSN Flags",
+							"RSN Flags",
+							NM_802_11_AP_SEC_NONE,
+							all_sec_flags,
+							NM_802_11_AP_SEC_NONE,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_SSID,
+	     g_param_spec_boxed (NM_AP_SSID,
+	                         "SSID",
+	                         "SSID",
+	                         DBUS_TYPE_G_UCHAR_ARRAY,
+	                         G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_FREQUENCY,
+		 g_param_spec_uint (NM_AP_FREQUENCY,
+							"Frequency",
+							"Frequency",
+							0, 10000, 0,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_HW_ADDRESS,
+		 g_param_spec_string (NM_AP_HW_ADDRESS,
+							  "MAC Address",
+							  "Hardware MAC address",
+							  NULL,
+							  G_PARAM_READABLE));
+	
+	g_object_class_install_property
+		(object_class, PROP_MODE,
+		 g_param_spec_uint (NM_AP_MODE,
+						   "Mode",
+						   "Mode",
+						   NM_802_11_MODE_ADHOC, NM_802_11_MODE_INFRA, NM_802_11_MODE_INFRA,
+						   G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_MAX_BITRATE,
+		 g_param_spec_uint (NM_AP_MAX_BITRATE,
+							"Max Bitrate",
+							"Max Bitrate",
+							0, G_MAXUINT16, 0,
+							G_PARAM_READWRITE));
+
+	g_object_class_install_property
+		(object_class, PROP_STRENGTH,
+		 g_param_spec_char (NM_AP_STRENGTH,
+							"Strength",
+							"Strength",
+							G_MININT8, G_MAXINT8, 0,
+							G_PARAM_READWRITE));
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] = 
+		nm_properties_changed_signal_new (object_class,
+								    G_STRUCT_OFFSET (NMAccessPointClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (ap_class),
+							   &dbus_glib_nm_access_point_object_info);
+}
+
+void
+nm_ap_export_to_dbus (NMAccessPoint *ap)
+{
+	NMAccessPointPrivate *priv;
+	NMDBusManager *mgr;
+	DBusGConnection *g_connection;
+	static guint32 counter = 0;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->dbus_path) {
+		nm_log_err (LOGD_CORE, "Tried to export AP %s twice.", priv->dbus_path);
+		return;
+	}
+
+	mgr = nm_dbus_manager_get ();
+	g_assert (mgr);
+
+	g_connection = nm_dbus_manager_get_connection (mgr);
+	g_assert (g_connection);
+
+	priv->dbus_path = g_strdup_printf (NM_DBUS_PATH_ACCESS_POINT "/%d", counter++);
+	dbus_g_connection_register_g_object (g_connection, priv->dbus_path, G_OBJECT (ap));
+
+	g_object_unref (mgr);
+}
+
+/*
+ * nm_ap_new
+ *
+ * Create a new, blank user access point info structure
+ *
+ */
+NMAccessPoint *nm_ap_new (void)
+{
+	GObject *object;
+
+	object = g_object_new (NM_TYPE_AP, NULL);
+	if (!object)
+		return NULL;
+
+	return (NMAccessPoint *) object;
+}
+
+
+#define IEEE80211_CAP_ESS       0x0001
+#define IEEE80211_CAP_IBSS      0x0002
+#define IEEE80211_CAP_PRIVACY   0x0010
+
+static void
+foreach_property_cb (gpointer key, gpointer value, gpointer user_data)
+{
+	GValue *variant = (GValue *) value;
+	NMAccessPoint *ap = (NMAccessPoint *) user_data;
+
+	if (G_VALUE_HOLDS_BOXED (variant)) {
+		GArray *array = g_value_get_boxed (variant);
+
+		if (!strcmp (key, "ssid")) {
+			guint32 len = MIN (IW_ESSID_MAX_SIZE, array->len);
+			GByteArray * ssid;
+
+			/* Stupid ieee80211 layer uses <hidden> */
+			if (((len == 8) || (len == 9))
+				&& (memcmp (array->data, "<hidden>", 8) == 0))
+				return;
+
+			if (nm_utils_is_empty_ssid ((const guint8 *) array->data, len))
+				return;
+
+			ssid = g_byte_array_sized_new (len);
+			g_byte_array_append (ssid, (const guint8 *) array->data, len);
+			nm_ap_set_ssid (ap, ssid);
+			g_byte_array_free (ssid, TRUE);
+		} else if (!strcmp (key, "bssid")) {
+			struct ether_addr addr;
+
+			if (array->len != ETH_ALEN)
+				return;
+			memset (&addr, 0, sizeof (struct ether_addr));
+			memcpy (&addr, array->data, ETH_ALEN);
+			nm_ap_set_address (ap, &addr);
+		} else if (!strcmp (key, "wpaie")) {
+			guint8 * ie = (guint8 *) array->data;
+			guint32 flags = nm_ap_get_wpa_flags (ap);
+
+			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
+				return;
+			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
+			nm_ap_set_wpa_flags (ap, flags);
+		} else if (!strcmp (key, "rsnie")) {
+			guint8 * ie = (guint8 *) array->data;
+			guint32 flags = nm_ap_get_rsn_flags (ap);
+
+			if (array->len <= 0 || array->len > WPA_MAX_IE_LEN)
+				return;
+			flags = nm_ap_add_security_from_ie (flags, ie, array->len);
+			nm_ap_set_rsn_flags (ap, flags);
+		}
+	} else if (G_VALUE_HOLDS_INT (variant)) {
+		gint32 int_val = g_value_get_int (variant);
+
+		if (!strcmp (key, "frequency")) {
+			nm_ap_set_freq (ap, (guint32) int_val);
+		} else if (!strcmp (key, "maxrate")) {
+			/* Supplicant reports as b/s, we use Kb/s internally */
+			nm_ap_set_max_bitrate (ap, int_val / 1000);
+		}
+	} else if (G_VALUE_HOLDS_UINT (variant)) {
+		guint32 val = g_value_get_uint (variant);
+
+		if (!strcmp (key, "capabilities")) {
+			if (val & IEEE80211_CAP_ESS) {
+				nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
+			} else if (val & IEEE80211_CAP_IBSS) {
+				nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
+			}
+
+			if (val & IEEE80211_CAP_PRIVACY) {
+				guint32 flags = nm_ap_get_flags (ap);
+				nm_ap_set_flags (ap, flags | NM_802_11_AP_FLAGS_PRIVACY);
+			}
+		}
+	}
+}
+
+
+NMAccessPoint *
+nm_ap_new_from_properties (GHashTable *properties)
+{
+	NMAccessPoint *ap;
+	GTimeVal cur_time;
+	const struct ether_addr * addr;
+	const char bad_bssid1[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	const char bad_bssid2[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+	g_return_val_if_fail (properties != NULL, NULL);
+
+	ap = nm_ap_new ();
+
+	g_object_freeze_notify (G_OBJECT (ap));
+	g_hash_table_foreach (properties, foreach_property_cb, ap);
+
+	/* ignore APs with invalid BSSIDs */
+	addr = nm_ap_get_address (ap);
+	if (   !(memcmp (addr->ether_addr_octet, bad_bssid1, ETH_ALEN))
+	    || !(memcmp (addr->ether_addr_octet, bad_bssid2, ETH_ALEN))) {
+		g_object_unref (ap);
+		return NULL;
+	}
+
+	g_get_current_time (&cur_time);
+	nm_ap_set_last_seen (ap, cur_time.tv_sec);
+
+	if (!nm_ap_get_ssid (ap))
+		nm_ap_set_broadcast (ap, FALSE);
+
+	g_object_thaw_notify (G_OBJECT (ap));
+
+	return ap;
+}
+
+#define PROTO_WPA "wpa"
+#define PROTO_RSN "rsn"
+
+static gboolean
+has_proto (NMSettingWirelessSecurity *sec, const char *proto)
+{
+	guint32 num_protos = nm_setting_wireless_security_get_num_protos (sec);
+	guint32 i;
+
+	if (num_protos == 0)
+		return TRUE; /* interpret no protos as "all" */
+
+	for (i = 0; i < num_protos; i++) {
+		if (!strcmp (nm_setting_wireless_security_get_proto (sec, i), proto))
+			return TRUE;
+	}
+	return FALSE;
+}
+
+static void
+add_pair_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
+{
+	guint32 num = nm_setting_wireless_security_get_num_pairwise (sec);
+	guint32 flags = NM_802_11_AP_SEC_NONE;
+	guint32 i;
+
+	/* If no ciphers are specified, that means "all" WPA ciphers */
+	if (num == 0) {
+		flags |= NM_802_11_AP_SEC_PAIR_TKIP | NM_802_11_AP_SEC_PAIR_CCMP;
+	} else {
+		for (i = 0; i < num; i++) {
+			const char *cipher = nm_setting_wireless_security_get_pairwise (sec, i);
+
+			if (!strcmp (cipher, "tkip"))
+				flags |= NM_802_11_AP_SEC_PAIR_TKIP;
+			else if (!strcmp (cipher, "ccmp"))
+				flags |= NM_802_11_AP_SEC_PAIR_CCMP;
+		}
+	}
+
+	if (has_proto (sec, PROTO_WPA))
+		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
+	if (has_proto (sec, PROTO_RSN))
+		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
+}
+
+static void
+add_group_ciphers (NMAccessPoint *ap, NMSettingWirelessSecurity *sec)
+{
+	guint32 num = nm_setting_wireless_security_get_num_groups (sec);
+	guint32 flags = NM_802_11_AP_SEC_NONE;
+	guint32 i;
+
+	/* If no ciphers are specified, that means "all" WPA ciphers */
+	if (num == 0) {
+		flags |= NM_802_11_AP_SEC_GROUP_TKIP | NM_802_11_AP_SEC_GROUP_CCMP;
+	} else {
+		for (i = 0; i < num; i++) {
+			const char *cipher = nm_setting_wireless_security_get_group (sec, i);
+
+			if (!strcmp (cipher, "wep40"))
+				flags |= NM_802_11_AP_SEC_GROUP_WEP40;
+			else if (!strcmp (cipher, "wep104"))
+				flags |= NM_802_11_AP_SEC_GROUP_WEP104;
+			else if (!strcmp (cipher, "tkip"))
+				flags |= NM_802_11_AP_SEC_GROUP_TKIP;
+			else if (!strcmp (cipher, "ccmp"))
+				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
+		}
+	}
+
+	if (has_proto (sec, PROTO_WPA))
+		nm_ap_set_wpa_flags (ap, nm_ap_get_wpa_flags (ap) | flags);
+	if (has_proto (sec, PROTO_RSN))
+		nm_ap_set_rsn_flags (ap, nm_ap_get_rsn_flags (ap) | flags);
+}
+
+NMAccessPoint *
+nm_ap_new_fake_from_connection (NMConnection *connection)
+{
+	NMAccessPoint *ap;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wireless_sec;
+	const GByteArray *ssid;
+	const char *mode, *band, *key_mgmt;
+	guint32 channel, flags;
+	gboolean psk = FALSE, eap = FALSE;
+
+	g_return_val_if_fail (connection != NULL, NULL);
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	g_return_val_if_fail (s_wireless != NULL, NULL);
+
+	ssid = nm_setting_wireless_get_ssid (s_wireless);
+	g_return_val_if_fail (ssid != NULL, NULL);
+	g_return_val_if_fail (ssid->len > 0, NULL);
+
+	ap = nm_ap_new ();
+	nm_ap_set_fake (ap, TRUE);
+	nm_ap_set_ssid (ap, ssid);
+
+	// FIXME: bssid too?
+
+	mode = nm_setting_wireless_get_mode (s_wireless);
+	if (mode) {
+		if (!strcmp (mode, "infrastructure"))
+			nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
+		else if (!strcmp (mode, "adhoc"))
+			nm_ap_set_mode (ap, NM_802_11_MODE_ADHOC);
+		else
+			goto error;
+	} else {
+		nm_ap_set_mode (ap, NM_802_11_MODE_INFRA);
+	}
+
+	band = nm_setting_wireless_get_band (s_wireless);
+	channel = nm_setting_wireless_get_channel (s_wireless);
+
+	if (band && channel) {
+		guint32 freq = channel_to_freq (channel, band);
+
+		if (freq == 0)
+			goto error;
+
+		nm_ap_set_freq (ap, freq);
+	}
+
+	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY);
+	/* Assume presence of a security setting means the AP is encrypted */
+	if (!s_wireless_sec)
+		goto done;
+
+	key_mgmt = nm_setting_wireless_security_get_key_mgmt (s_wireless_sec);
+
+	/* Everything below here uses encryption */
+	nm_ap_set_flags (ap, nm_ap_get_flags (ap) | NM_802_11_AP_FLAGS_PRIVACY);
+
+	/* Static & Dynamic WEP */
+	if (!strcmp (key_mgmt, "none") || !strcmp (key_mgmt, "ieee8021x"))
+		goto done;
+
+	psk = !strcmp (key_mgmt, "wpa-psk");
+	eap = !strcmp (key_mgmt, "wpa-eap");
+	if (psk || eap) {
+		if (has_proto (s_wireless_sec, PROTO_WPA)) {
+			flags = nm_ap_get_wpa_flags (ap);
+			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
+			nm_ap_set_wpa_flags (ap, flags);
+		}
+		if (has_proto (s_wireless_sec, PROTO_RSN)) {
+			flags = nm_ap_get_rsn_flags (ap);
+			flags |= eap ? NM_802_11_AP_SEC_KEY_MGMT_802_1X : NM_802_11_AP_SEC_KEY_MGMT_PSK;
+			nm_ap_set_rsn_flags (ap, flags);
+		}
+
+		add_pair_ciphers (ap, s_wireless_sec);
+		add_group_ciphers (ap, s_wireless_sec);
+	} else if (!strcmp (key_mgmt, "wpa-none")) {
+		guint32 i;
+
+		/* Ad-Hoc has special requirements: proto=WPA, pairwise=(none), and
+		 * group=TKIP/CCMP (but not both).
+		 */
+
+		flags = nm_ap_get_wpa_flags (ap);
+		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
+
+		/* Clear ciphers; pairwise must be unset anyway, and group gets set below */
+		flags &= ~(  NM_802_11_AP_SEC_PAIR_WEP40
+		           | NM_802_11_AP_SEC_PAIR_WEP104
+		           | NM_802_11_AP_SEC_PAIR_TKIP
+		           | NM_802_11_AP_SEC_PAIR_CCMP
+		           | NM_802_11_AP_SEC_GROUP_WEP40
+		           | NM_802_11_AP_SEC_GROUP_WEP104
+		           | NM_802_11_AP_SEC_GROUP_TKIP
+		           | NM_802_11_AP_SEC_GROUP_CCMP);
+
+		for (i = 0; i < nm_setting_wireless_security_get_num_groups (s_wireless_sec); i++) {
+			if (!strcmp (nm_setting_wireless_security_get_group (s_wireless_sec, i), "ccmp")) {
+				flags |= NM_802_11_AP_SEC_GROUP_CCMP;
+				break;
+			}
+		}
+
+		/* Default to TKIP since not all WPA-capable cards can do CCMP */
+		if (!(flags & NM_802_11_AP_SEC_GROUP_CCMP))
+			flags |= NM_802_11_AP_SEC_GROUP_TKIP;
+
+		nm_ap_set_wpa_flags (ap, flags);
+
+		/* Don't use Ad-Hoc RSN yet */
+		nm_ap_set_rsn_flags (ap, NM_802_11_AP_SEC_NONE);
+	}
+
+done:
+	return ap;
+
+error:
+	g_object_unref (ap);
+	return NULL;
+}
+
+
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((guint8*)(x))[0],((guint8*)(x))[1],((guint8*)(x))[2],((guint8*)(x))[3],((guint8*)(x))[4],((guint8*)(x))[5]
+
+void
+nm_ap_print_self (NMAccessPoint *ap,
+                  const char * prefix)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (ap != NULL);
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	nm_log_dbg (LOGD_WIFI_SCAN, "%s'%s' (%p)",
+	            prefix,
+	            priv->ssid ? nm_utils_escape_ssid (priv->ssid->data, priv->ssid->len) : "(none)",
+	            ap);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    BSSID     " MAC_FMT, MAC_ARG (priv->address.ether_addr_octet));
+	nm_log_dbg (LOGD_WIFI_SCAN, "    mode      %d", priv->mode);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    timestamp %ld", priv->timestamp.tv_sec);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    flags     0x%X", priv->flags);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    wpa flags 0x%X", priv->wpa_flags);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    rsn flags 0x%X", priv->rsn_flags);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    quality   %d", priv->strength);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    frequency %d", priv->freq);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    max rate  %d", priv->max_bitrate);
+	nm_log_dbg (LOGD_WIFI_SCAN, "    last-seen %ld", priv->last_seen);
+}
+
+const char *
+nm_ap_get_dbus_path (NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	return NM_AP_GET_PRIVATE (ap)->dbus_path;
+}
+
+
+/*
+ * Get/set functions for timestamp
+ *
+ */
+const GTimeVal *nm_ap_get_timestamp (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	return (&NM_AP_GET_PRIVATE (ap)->timestamp);
+}
+
+void nm_ap_set_timestamp (NMAccessPoint *ap, glong sec, glong usec)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	priv->timestamp.tv_sec = sec;
+	priv->timestamp.tv_usec = usec;
+}
+
+void nm_ap_set_timestamp_via_timestamp (NMAccessPoint *ap, const GTimeVal *timestamp)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->timestamp = *timestamp;
+}
+
+/*
+ * Get/set functions for ssid
+ *
+ */
+const GByteArray * nm_ap_get_ssid (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	return NM_AP_GET_PRIVATE (ap)->ssid;
+}
+
+void
+nm_ap_set_ssid (NMAccessPoint *ap, const GByteArray * ssid)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if ((ssid == priv->ssid) && ssid == NULL)
+		return;
+
+	/* same SSID */
+	if ((ssid && priv->ssid) && (ssid->len == priv->ssid->len)) {
+		if (!memcmp (ssid->data, priv->ssid->data, ssid->len))
+			return;
+	}
+
+	if (priv->ssid) {
+		g_byte_array_free (priv->ssid, TRUE);
+		priv->ssid = NULL;
+	}
+
+	if (ssid) {
+		priv->ssid = g_byte_array_sized_new (ssid->len);
+		priv->ssid->len = ssid->len;
+		memcpy (priv->ssid->data, ssid->data, ssid->len);
+	}
+
+	g_object_notify (G_OBJECT (ap), NM_AP_SSID);
+}
+
+
+guint32
+nm_ap_get_flags (NMAccessPoint *ap)
+{
+	guint32 flags;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_FLAGS_NONE);
+
+	g_object_get (ap, NM_AP_FLAGS, &flags, NULL);
+
+	return flags;
+}
+
+
+void
+nm_ap_set_flags (NMAccessPoint *ap, guint32 flags)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->flags != flags) {
+		priv->flags = flags;
+		g_object_notify (G_OBJECT (ap), NM_AP_FLAGS);
+	}
+}
+
+guint32
+nm_ap_get_wpa_flags (NMAccessPoint *ap)
+{
+	guint32 flags;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
+
+	g_object_get (ap, NM_AP_WPA_FLAGS, &flags, NULL);
+
+	return flags;
+}
+
+
+void
+nm_ap_set_wpa_flags (NMAccessPoint *ap, guint32 flags)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->wpa_flags != flags) {
+		priv->wpa_flags = flags;
+		g_object_notify (G_OBJECT (ap), NM_AP_WPA_FLAGS);
+	}
+}
+
+guint32
+nm_ap_get_rsn_flags (NMAccessPoint *ap)
+{
+	guint32 flags;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NM_802_11_AP_SEC_NONE);
+
+	g_object_get (ap, NM_AP_RSN_FLAGS, &flags, NULL);
+
+	return flags;
+}
+
+
+void
+nm_ap_set_rsn_flags (NMAccessPoint *ap, guint32 flags)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->rsn_flags != flags) {
+		priv->rsn_flags = flags;
+		g_object_notify (G_OBJECT (ap), NM_AP_RSN_FLAGS);
+	}
+}
+
+/*
+ * Get/set functions for address
+ *
+ */
+const struct ether_addr * nm_ap_get_address (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	return &NM_AP_GET_PRIVATE (ap)->address;
+}
+
+void nm_ap_set_address (NMAccessPoint *ap, const struct ether_addr * addr)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+	g_return_if_fail (addr != NULL);
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (memcmp (addr, &priv->address, sizeof (priv->address))) {
+		memcpy (&NM_AP_GET_PRIVATE (ap)->address, addr, sizeof (struct ether_addr));
+		g_object_notify (G_OBJECT (ap), NM_AP_HW_ADDRESS);
+	}
+}
+
+
+/*
+ * Get/set functions for mode (ie Ad-Hoc, Infrastructure, etc)
+ *
+ */
+NM80211Mode nm_ap_get_mode (NMAccessPoint *ap)
+{
+	NM80211Mode mode;
+
+	g_return_val_if_fail (NM_IS_AP (ap), -1);
+
+	g_object_get (ap, NM_AP_MODE, &mode, NULL);
+
+	return mode;
+}
+
+void nm_ap_set_mode (NMAccessPoint *ap, const NM80211Mode mode)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	if (mode == NM_802_11_MODE_ADHOC || mode == NM_802_11_MODE_INFRA) {
+		priv = NM_AP_GET_PRIVATE (ap);
+
+		if (priv->mode != mode) {
+			priv->mode = mode;
+			g_object_notify (G_OBJECT (ap), NM_AP_MODE);
+		}
+	} else
+		nm_log_warn (LOGD_WIFI, "Invalid AP mode '%d'", mode);
+}
+
+
+/*
+ * Get/set functions for strength
+ *
+ */
+gint8 nm_ap_get_strength (NMAccessPoint *ap)
+{
+	gint8 strength;
+
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	g_object_get (ap, NM_AP_STRENGTH, &strength, NULL);
+
+	return strength;
+}
+
+void nm_ap_set_strength (NMAccessPoint *ap, const gint8 strength)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->strength != strength) {
+		priv->strength = strength;
+		g_object_notify (G_OBJECT (ap), NM_AP_STRENGTH);
+	}
+}
+
+
+/*
+ * Get/set functions for frequency
+ *
+ */
+guint32
+nm_ap_get_freq (NMAccessPoint *ap)
+{
+	guint32 freq;
+
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	g_object_get (ap, NM_AP_FREQUENCY, &freq, NULL);
+
+	return freq;
+}
+
+void
+nm_ap_set_freq (NMAccessPoint *ap,
+                const guint32 freq)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->freq != freq) {
+		priv->freq = freq;
+		g_object_notify (G_OBJECT (ap), NM_AP_FREQUENCY);
+	}
+}
+
+
+/*
+ * Get/set functions for max bitrate
+ *
+ */
+guint32 nm_ap_get_max_bitrate (NMAccessPoint *ap)
+{
+	guint32 rate;
+
+	g_return_val_if_fail (NM_IS_AP (ap), 0);
+
+	g_object_get (ap, NM_AP_MAX_BITRATE, &rate, NULL);
+
+	return rate;
+}
+
+void
+nm_ap_set_max_bitrate (NMAccessPoint *ap, guint32 bitrate)
+{
+	NMAccessPointPrivate *priv;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	if (priv->max_bitrate != bitrate) {
+		priv->max_bitrate = bitrate;
+		g_object_notify (G_OBJECT (ap), NM_AP_MAX_BITRATE);
+	}
+}
+
+/*
+ * Get/Set functions to indicate that an access point is 'fake', ie whether
+ * or not it was created from scan results
+ */
+gboolean nm_ap_get_fake (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
+
+	return NM_AP_GET_PRIVATE (ap)->fake;
+}
+
+void nm_ap_set_fake (NMAccessPoint *ap, gboolean fake)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->fake = fake;
+}
+
+
+/*
+ * Get/Set functions to indicate whether an AP broadcasts its SSID.
+ */
+gboolean nm_ap_get_broadcast (NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), TRUE);
+
+	return NM_AP_GET_PRIVATE (ap)->broadcast;
+}
+
+
+void nm_ap_set_broadcast (NMAccessPoint *ap, gboolean broadcast)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->broadcast = broadcast;
+}
+
+
+/*
+ * Get/Set functions for how long ago the AP was last seen in a scan.
+ * APs older than a certain date are dropped from the list.
+ *
+ */
+glong nm_ap_get_last_seen (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
+
+	return NM_AP_GET_PRIVATE (ap)->last_seen;
+}
+
+void nm_ap_set_last_seen (NMAccessPoint *ap, const glong last_seen)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->last_seen = last_seen;
+}
+
+
+/*
+ * Get/Set functions to indicate that an access point is
+ * user-created, ie whether or not its a network filled with
+ * information from the user and intended to create a new Ad-Hoc
+ * wireless network.
+ *
+ */
+gboolean nm_ap_get_user_created (const NMAccessPoint *ap)
+{
+	g_return_val_if_fail (NM_IS_AP (ap), FALSE);
+
+	return NM_AP_GET_PRIVATE (ap)->user_created;
+}
+
+void nm_ap_set_user_created (NMAccessPoint *ap, gboolean user_created)
+{
+	g_return_if_fail (NM_IS_AP (ap));
+
+	NM_AP_GET_PRIVATE (ap)->user_created = user_created;
+}
+
+
+/*
+ * Get/Set functions for user address list
+ *
+ * The internal address list is always "owned" by the AP and
+ * the list returned by nm_ap_get_user_addresses() is a deep copy.
+ * Likewise, when setting the list, a deep copy is made for the
+ * ap's actual list.
+ *
+ */
+GSList *nm_ap_get_user_addresses (const NMAccessPoint *ap)
+{
+	GSList	*new = NULL;
+	GSList	*elt = NULL;
+
+	g_return_val_if_fail (NM_IS_AP (ap), NULL);
+
+	for (elt = NM_AP_GET_PRIVATE (ap)->user_addresses; elt; elt = g_slist_next (elt))
+	{
+		if (elt->data)
+			new = g_slist_append (new, g_strdup (elt->data));
+	}
+
+	/* Return a _deep__copy_ of the address list */
+	return new;
+}
+
+void nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list)
+{
+	NMAccessPointPrivate *priv;
+	GSList	*elt = NULL;
+	GSList	*new = NULL;
+
+	g_return_if_fail (NM_IS_AP (ap));
+
+	priv = NM_AP_GET_PRIVATE (ap);
+
+	/* Free existing list */
+	g_slist_foreach (priv->user_addresses, (GFunc) g_free, NULL);
+
+	/* Copy new list and set as our own */
+	for (elt = list; elt; elt = g_slist_next (elt))
+	{
+		if (elt->data)
+			new = g_slist_append (new, g_ascii_strup (elt->data, -1));
+	}
+
+	priv->user_addresses = new;
+}
+
+
+guint32
+nm_ap_add_security_from_ie (guint32 flags,
+                            const guint8 *wpa_ie,
+                            guint32 length)
+{
+	wpa_ie_data * cap_data;
+
+	if (!(cap_data = wpa_parse_wpa_ie (wpa_ie, length)))
+		return NM_802_11_AP_SEC_NONE;
+
+	/* Pairwise cipher flags */
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP40)
+		flags |= NM_802_11_AP_SEC_PAIR_WEP40;
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_WEP104)
+		flags |= NM_802_11_AP_SEC_PAIR_WEP104;
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_TKIP)
+		flags |= NM_802_11_AP_SEC_PAIR_TKIP;
+	if (cap_data->pairwise_cipher & IW_AUTH_CIPHER_CCMP)
+		flags |= NM_802_11_AP_SEC_PAIR_CCMP;
+
+	/* Group cipher flags */
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP40)
+		flags |= NM_802_11_AP_SEC_GROUP_WEP40;
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_WEP104)
+		flags |= NM_802_11_AP_SEC_GROUP_WEP104;
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_TKIP)
+		flags |= NM_802_11_AP_SEC_GROUP_TKIP;
+	if (cap_data->group_cipher & IW_AUTH_CIPHER_CCMP)
+		flags |= NM_802_11_AP_SEC_GROUP_CCMP;
+
+	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_802_1X)
+		flags |= NM_802_11_AP_SEC_KEY_MGMT_802_1X;
+	if (cap_data->key_mgmt & IW_AUTH_KEY_MGMT_PSK)
+		flags |= NM_802_11_AP_SEC_KEY_MGMT_PSK;
+
+	g_slice_free (wpa_ie_data, cap_data);
+	return flags;
+}
+
+gboolean
+nm_ap_check_compatible (NMAccessPoint *self,
+                        NMConnection *connection)
+{
+	NMAccessPointPrivate *priv;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wireless_sec;
+	const char *mode;
+	const char *band;
+	const GByteArray *bssid;
+	guint32 channel;
+
+	g_return_val_if_fail (NM_IS_AP (self), FALSE);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
+
+	priv = NM_AP_GET_PRIVATE (self);
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	if (s_wireless == NULL)
+		return FALSE;
+	
+	if (!nm_utils_same_ssid (nm_setting_wireless_get_ssid (s_wireless), priv->ssid, TRUE))
+		return FALSE;
+
+	bssid = nm_setting_wireless_get_bssid (s_wireless);
+	if (bssid && memcmp (bssid->data, &priv->address, ETH_ALEN))
+		return FALSE;
+
+	mode = nm_setting_wireless_get_mode (s_wireless);
+	if (mode) {
+		if (!strcmp (mode, "infrastructure") && (priv->mode != NM_802_11_MODE_INFRA))
+			return FALSE;
+		if (!strcmp (mode, "adhoc") && (priv->mode != NM_802_11_MODE_ADHOC))
+			return FALSE;
+	}
+
+	band = nm_setting_wireless_get_band (s_wireless);
+	if (band) {
+		if (!strcmp (band, "a")) {
+			if (priv->freq < 4915 || priv->freq > 5825)
+				return FALSE;
+		} else if (!strcmp (band, "bg")) {
+			if (priv->freq < 2412 || priv->freq > 2484)
+				return FALSE;
+		}
+	}
+
+	channel = nm_setting_wireless_get_channel (s_wireless);
+	if (channel) {
+		guint32 ap_chan = freq_to_channel (priv->freq);
+
+		if (channel != ap_chan)
+			return FALSE;
+	}
+
+	s_wireless_sec = (NMSettingWirelessSecurity *) nm_connection_get_setting (connection,
+															    NM_TYPE_SETTING_WIRELESS_SECURITY);
+
+	return nm_setting_wireless_ap_security_compatible (s_wireless,
+											 s_wireless_sec,
+											 nm_ap_get_flags (self),
+											 nm_ap_get_wpa_flags (self),
+											 nm_ap_get_rsn_flags (self),
+											 nm_ap_get_mode (self));
+}
+
+static gboolean
+capabilities_compatible (guint32 a_flags, guint32 b_flags)
+{
+	if (a_flags == b_flags)
+		return TRUE;
+
+	/* Make sure there's a common key management method */
+	if (!((a_flags & 0x300) & (b_flags & 0x300)))
+		return FALSE;
+
+	/* Ensure common pairwise ciphers */
+	if (!((a_flags & 0xF) & (b_flags & 0xF)))
+		return FALSE;
+
+	/* Ensure common group ciphers */
+	if (!((a_flags & 0xF0) & (b_flags & 0xF0)))
+		return FALSE;
+
+	return TRUE;
+}
+
+NMAccessPoint *
+nm_ap_match_in_list (NMAccessPoint *find_ap,
+                     GSList *ap_list,
+                     gboolean strict_match)
+{
+	GSList *iter;
+
+	g_return_val_if_fail (find_ap != NULL, NULL);
+
+	for (iter = ap_list; iter; iter = g_slist_next (iter)) {
+		NMAccessPoint * list_ap = NM_AP (iter->data);
+		const GByteArray * list_ssid = nm_ap_get_ssid (list_ap);
+		const struct ether_addr * list_addr = nm_ap_get_address (list_ap);
+
+		const GByteArray * find_ssid = nm_ap_get_ssid (find_ap);
+		const struct ether_addr * find_addr = nm_ap_get_address (find_ap);
+
+		/* SSID match; if both APs are hiding their SSIDs,
+		 * let matching continue on BSSID and other properties
+		 */
+		if (   (!list_ssid && find_ssid)
+		    || (list_ssid && !find_ssid)
+		    || !nm_utils_same_ssid (list_ssid, find_ssid, TRUE))
+			continue;
+
+		/* BSSID match */
+		if (   (strict_match || nm_ethernet_address_is_valid (find_addr))
+		    && nm_ethernet_address_is_valid (list_addr)
+		    && memcmp (list_addr->ether_addr_octet, 
+		               find_addr->ether_addr_octet,
+		               ETH_ALEN) != 0) {
+			continue;
+		}
+
+		/* mode match */
+		if (nm_ap_get_mode (list_ap) != nm_ap_get_mode (find_ap))
+			continue;
+
+		/* Frequency match */
+		if (nm_ap_get_freq (list_ap) != nm_ap_get_freq (find_ap))
+			continue;
+
+		/* AP flags */
+		if (nm_ap_get_flags (list_ap) != nm_ap_get_flags (find_ap))
+			continue;
+
+		if (strict_match) {
+			if (nm_ap_get_wpa_flags (list_ap) != nm_ap_get_wpa_flags (find_ap))
+				continue;
+
+			if (nm_ap_get_rsn_flags (list_ap) != nm_ap_get_rsn_flags (find_ap))
+				continue;
+		} else {
+			guint32 list_wpa_flags = nm_ap_get_wpa_flags (list_ap);
+			guint32 find_wpa_flags = nm_ap_get_wpa_flags (find_ap);
+			guint32 list_rsn_flags = nm_ap_get_rsn_flags (list_ap);
+			guint32 find_rsn_flags = nm_ap_get_rsn_flags (find_ap);
+
+			/* Just ensure that there is overlap in the capabilities */
+			if (   !capabilities_compatible (list_wpa_flags, find_wpa_flags)
+			    && !capabilities_compatible (list_rsn_flags, find_rsn_flags))
+				continue;
+		}
+
+		return list_ap;
+	}
+
+	return NULL;
+}
+
+
+struct cf_pair {
+	guint32 chan;
+	guint32 freq;
+};
+
+static struct cf_pair a_table[] = {
+	/* A band */
+	{  7, 5035 },
+	{  8, 5040 },
+	{  9, 5045 },
+	{ 11, 5055 },
+	{ 12, 5060 },
+	{ 16, 5080 },
+	{ 34, 5170 },
+	{ 36, 5180 },
+	{ 38, 5190 },
+	{ 40, 5200 },
+	{ 42, 5210 },
+	{ 44, 5220 },
+	{ 46, 5230 },
+	{ 48, 5240 },
+	{ 50, 5250 },
+	{ 52, 5260 },
+	{ 56, 5280 },
+	{ 58, 5290 },
+	{ 60, 5300 },
+	{ 64, 5320 },
+	{ 100, 5500 },
+	{ 104, 5520 },
+	{ 108, 5540 },
+	{ 112, 5560 },
+	{ 116, 5580 },
+	{ 120, 5600 },
+	{ 124, 5620 },
+	{ 128, 5640 },
+	{ 132, 5660 },
+	{ 136, 5680 },
+	{ 140, 5700 },
+	{ 149, 5745 },
+	{ 152, 5760 },
+	{ 153, 5765 },
+	{ 157, 5785 },
+	{ 160, 5800 },
+	{ 161, 5805 },
+	{ 165, 5825 },
+	{ 183, 4915 },
+	{ 184, 4920 },
+	{ 185, 4925 },
+	{ 187, 4935 },
+	{ 188, 4945 },
+	{ 192, 4960 },
+	{ 196, 4980 },
+	{ 0, -1 }
+};
+
+static struct cf_pair bg_table[] = {
+	/* B/G band */
+	{ 1, 2412 },
+	{ 2, 2417 },
+	{ 3, 2422 },
+	{ 4, 2427 },
+	{ 5, 2432 },
+	{ 6, 2437 },
+	{ 7, 2442 },
+	{ 8, 2447 },
+	{ 9, 2452 },
+	{ 10, 2457 },
+	{ 11, 2462 },
+	{ 12, 2467 },
+	{ 13, 2472 },
+	{ 14, 2484 },
+	{ 0, -1 }
+};
+
+guint32
+freq_to_channel (guint32 freq)
+{
+	int i = 0;
+
+	if (freq > 4900) {
+		while (a_table[i].chan && (a_table[i].freq != freq))
+			i++;
+		return a_table[i].chan;
+	} else {
+		while (bg_table[i].chan && (bg_table[i].freq != freq))
+			i++;
+		return bg_table[i].chan;
+	}
+
+	return 0;
+}
+
+guint32
+channel_to_freq (guint32 channel, const char *band)
+{
+	int i = 0;
+
+	if (!strcmp (band, "a")) {
+		while (a_table[i].chan && (a_table[i].chan != channel))
+			i++;
+		return a_table[i].freq;
+	} else if (!strcmp (band, "bg")) {
+		while (bg_table[i].chan && (bg_table[i].chan != channel))
+			i++;
+		return bg_table[i].freq;
+	}
+
+	return 0;
+}
+
diff --git a/src/nm-wifi-ap.h b/src/nm-wifi-ap.h
new file mode 100644
index 0000000..edc9e56
--- /dev/null
+++ b/src/nm-wifi-ap.h
@@ -0,0 +1,129 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2004 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2008 Novell, Inc.
+ */
+
+#ifndef NM_ACCESS_POINT_H
+#define NM_ACCESS_POINT_H
+
+#include <glib.h>
+#include <glib-object.h>
+#include <time.h>
+#include "NetworkManager.h"
+#include "nm-connection.h"
+
+#define NM_TYPE_AP            (nm_ap_get_type ())
+#define NM_AP(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_AP, NMAccessPoint))
+#define NM_AP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_AP, NMAccessPointClass))
+#define NM_IS_AP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_AP))
+#define NM_IS_AP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_AP))
+#define NM_AP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_AP, NMAccessPointClass))
+
+#define NM_AP_FLAGS "flags"
+#define NM_AP_WPA_FLAGS "wpa-flags"
+#define NM_AP_RSN_FLAGS "rsn-flags"
+#define NM_AP_SSID "ssid"
+#define NM_AP_FREQUENCY "frequency"
+#define NM_AP_HW_ADDRESS "hw-address"
+#define NM_AP_MODE "mode"
+#define NM_AP_MAX_BITRATE "max-bitrate"
+#define NM_AP_STRENGTH "strength"
+
+typedef struct {
+	GObject parent;
+} NMAccessPoint;
+
+typedef struct {
+	GObjectClass parent;
+
+	/* Signals */
+	void (*properties_changed) (NMAccessPoint *ap, GHashTable *properties);
+} NMAccessPointClass;
+
+GType nm_ap_get_type (void);
+
+NMAccessPoint *	nm_ap_new				(void);
+NMAccessPoint * nm_ap_new_from_properties (GHashTable *properties);
+NMAccessPoint * nm_ap_new_fake_from_connection (NMConnection *connection);
+void            nm_ap_export_to_dbus    (NMAccessPoint *ap);
+
+const char *		nm_ap_get_dbus_path (NMAccessPoint *ap);
+const GTimeVal *	nm_ap_get_timestamp				(const NMAccessPoint *ap);
+void				nm_ap_set_timestamp				(NMAccessPoint *ap, glong sec, glong usec);
+void				nm_ap_set_timestamp_via_timestamp	(NMAccessPoint *ap, const GTimeVal *timestamp);
+
+const GByteArray *	nm_ap_get_ssid (const NMAccessPoint * ap);
+void				nm_ap_set_ssid (NMAccessPoint * ap, const GByteArray * ssid);
+
+guint32			nm_ap_get_flags	(NMAccessPoint *ap);
+void				nm_ap_set_flags	(NMAccessPoint *ap, guint32 flags);
+
+guint32			nm_ap_get_wpa_flags	(NMAccessPoint *ap);
+void				nm_ap_set_wpa_flags	(NMAccessPoint *ap, guint32 flags);
+
+guint32			nm_ap_get_rsn_flags	(NMAccessPoint *ap);
+void				nm_ap_set_rsn_flags	(NMAccessPoint *ap, guint32 flags);
+
+const struct ether_addr * nm_ap_get_address	(const NMAccessPoint *ap);
+void				nm_ap_set_address		(NMAccessPoint *ap, const struct ether_addr *addr);
+
+NM80211Mode			nm_ap_get_mode			(NMAccessPoint *ap);
+void				nm_ap_set_mode			(NMAccessPoint *ap, const NM80211Mode mode);
+
+gint8			nm_ap_get_strength		(NMAccessPoint *ap);
+void				nm_ap_set_strength		(NMAccessPoint *ap, gint8 strength);
+
+guint32			nm_ap_get_freq			(NMAccessPoint *ap);
+void				nm_ap_set_freq			(NMAccessPoint *ap, guint32 freq);
+
+guint32			nm_ap_get_max_bitrate			(NMAccessPoint *ap);
+void				nm_ap_set_max_bitrate		(NMAccessPoint *ap, guint32 bitrate);
+
+gboolean			nm_ap_get_fake	(const NMAccessPoint *ap);
+void				nm_ap_set_fake	(NMAccessPoint *ap, gboolean fake);
+
+gboolean			nm_ap_get_broadcast		(NMAccessPoint *ap);
+void				nm_ap_set_broadcast		(NMAccessPoint *ap, gboolean broadcast);
+
+glong			nm_ap_get_last_seen		(const NMAccessPoint *ap);
+void				nm_ap_set_last_seen		(NMAccessPoint *ap, const glong last_seen);
+
+gboolean			nm_ap_get_user_created	(const NMAccessPoint *ap);
+void				nm_ap_set_user_created	(NMAccessPoint *ap, gboolean user_created);
+
+GSList *			nm_ap_get_user_addresses	(const NMAccessPoint *ap);
+void				nm_ap_set_user_addresses (NMAccessPoint *ap, GSList *list);
+
+guint32				nm_ap_add_security_from_ie (guint32 flags,
+                                                const guint8 *wpa_ie,
+                                                guint32 length);
+
+gboolean			nm_ap_check_compatible (NMAccessPoint *self,
+                                            NMConnection *connection);
+
+NMAccessPoint *     nm_ap_match_in_list (NMAccessPoint *find_ap,
+                                         GSList *ap_list,
+                                         gboolean strict_match);
+
+void				nm_ap_print_self (NMAccessPoint *ap, const char * prefix);
+
+guint32 freq_to_channel (guint32 freq);
+guint32 channel_to_freq (guint32 channel, const char *band);
+
+#endif /* NM_ACCESS_POINT_H */
diff --git a/src/ppp-manager/Makefile.am b/src/ppp-manager/Makefile.am
index 41cb537..2dc7ad9 100644
--- a/src/ppp-manager/Makefile.am
+++ b/src/ppp-manager/Makefile.am
@@ -3,6 +3,7 @@ INCLUDES = \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_builddir}/marshallers
 
 noinst_LTLIBRARIES = libppp-manager.la
@@ -28,6 +29,7 @@ libppp_manager_la_CPPFLAGS = \
 
 libppp_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
 
diff --git a/src/ppp-manager/nm-ppp-manager.c b/src/ppp-manager/nm-ppp-manager.c
index d3c9f6e..de905b4 100644
--- a/src/ppp-manager/nm-ppp-manager.c
+++ b/src/ppp-manager/nm-ppp-manager.c
@@ -49,7 +49,7 @@
 #include "nm-setting-gsm.h"
 #include "nm-setting-cdma.h"
 #include "nm-dbus-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 
 static void impl_ppp_manager_need_secrets (NMPPPManager *manager,
@@ -296,12 +296,13 @@ monitor_cb (gpointer user_data)
 	req.stats_ptr = (caddr_t) &req.stats;
 
 	strncpy (req.ifr__name, priv->ip_iface, sizeof (req.ifr__name));
-	if (ioctl (priv->monitor_fd, SIOCGPPPSTATS, &req) < 0)
-		nm_warning ("Could not read ppp stats: %s", strerror (errno));
-	else
+	if (ioctl (priv->monitor_fd, SIOCGPPPSTATS, &req) < 0) {
+		nm_log_warn (LOGD_PPP, "could not read ppp stats: %s", strerror (errno));
+	} else {
 		g_signal_emit (manager, signals[STATS], 0, 
-					req.stats.p.ppp_ibytes,
-					req.stats.p.ppp_obytes);
+		               req.stats.p.ppp_ibytes,
+		               req.stats.p.ppp_obytes);
+	}
 
 	return TRUE;
 }
@@ -315,7 +316,7 @@ monitor_stats (NMPPPManager *manager)
 	if (priv->monitor_fd > 0)
 		priv->monitor_id = g_timeout_add_seconds (5, monitor_cb, manager);
 	else
-		nm_warning ("Could not open pppd monitor: %s", strerror (errno));
+		nm_log_warn (LOGD_PPP, "could not monitor PPP stats: %s", strerror (errno));
 }
 
 /*******************************************/
@@ -387,8 +388,8 @@ impl_ppp_manager_need_secrets (NMPPPManager *manager,
 			GError *err = NULL;
 
 			g_set_error (&err, NM_PPP_MANAGER_ERROR, NM_PPP_MANAGER_ERROR_UNKOWN,
-					   "Missing type-specific setting; no secrets could be found.");
-			nm_warning ("%s", err->message);
+			             "Missing type-specific setting; no secrets could be found.");
+			nm_log_warn (LOGD_PPP, "%s", err->message);
 			dbus_g_method_return_error (context, err);
 		}
 		return;
@@ -442,7 +443,7 @@ impl_ppp_manager_set_ip4_config (NMPPPManager *manager,
 	GValue *val;
 	int i;
 
-	nm_info ("PPP manager(IP Config Get) reply received.");
+	nm_log_info (LOGD_PPP, "PPP manager(IP Config Get) reply received.");
 
 	remove_timeout_handler (manager);
 
@@ -467,7 +468,7 @@ impl_ppp_manager_set_ip4_config (NMPPPManager *manager,
 	if (nm_ip4_address_get_address (addr) && nm_ip4_address_get_prefix (addr)) {
 		nm_ip4_config_take_address (config, addr);
 	} else {
-		nm_warning ("%s: invalid IPv4 address received!", __func__);
+		nm_log_err (LOGD_PPP, "invalid IPv4 address received!");
 		nm_ip4_address_unref (addr);
 		goto out;
 	}
@@ -490,7 +491,7 @@ impl_ppp_manager_set_ip4_config (NMPPPManager *manager,
 
 	val = (GValue *) g_hash_table_lookup (config_hash, NM_PPP_IP4_CONFIG_INTERFACE);
 	if (!val || !G_VALUE_HOLDS_STRING (val)) {
-		nm_warning ("No interface");
+		nm_log_err (LOGD_PPP, "no interface received!");
 		goto out;
 	}
 	priv->ip_iface = g_value_dup_string (val);
@@ -582,13 +583,12 @@ nm_cmd_line_add_int (NMCmdLine *cmd, int i)
 static inline const char *
 nm_find_pppd (void)
 {
-	static const char *pppd_binary_paths[] =
-		{
-			"/usr/local/sbin/pppd",
-			"/usr/sbin/pppd",
-			"/sbin/pppd",
-			NULL
-		};
+	static const char *pppd_binary_paths[] = {
+		"/usr/local/sbin/pppd",
+		"/usr/sbin/pppd",
+		"/sbin/pppd",
+		NULL
+	};
 
 	const char  **pppd_binary = pppd_binary_paths;
 
@@ -670,7 +670,7 @@ ppp_exit_code (guint pppd_exit_status, GPid pid)
 		msg = "Unknown error";
 	}
 
-	nm_warning ("ppp pid %d exited with error: %s", pid, msg);
+	nm_log_warn (LOGD_PPP, "pppd pid %d exited with error: %s", pid, msg);
 }
 
 static void
@@ -686,14 +686,14 @@ ppp_watch_cb (GPid pid, gint status, gpointer user_data)
 		err = WEXITSTATUS (status);
 		if (err != 0)
 			ppp_exit_code (err, priv->pid);
-	} else if (WIFSTOPPED (status))
-		nm_warning ("ppp pid %d stopped unexpectedly with signal %d", priv->pid, WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		nm_warning ("ppp pid %d died with signal %d", priv->pid, WTERMSIG (status));
-	else
-		nm_warning ("ppp pid %d died from an unknown cause", priv->pid);
-
-	nm_debug ("ppp pid %d cleaned up", priv->pid);
+	} else if (WIFSTOPPED (status)) {
+		nm_log_info (LOGD_PPP, "pppd pid %d stopped unexpectedly with signal %d", priv->pid, WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_info (LOGD_PPP, "pppd pid %d died with signal %d", priv->pid, WTERMSIG (status));
+	} else
+		nm_log_info (LOGD_PPP, "pppd pid %d died from an unknown cause", priv->pid);
+
+	nm_log_dbg (LOGD_PPP, "pppd pid %d cleaned up", priv->pid);
 	priv->pid = 0;
 	g_signal_emit (manager, signals[STATE_CHANGED], 0, NM_PPP_STATUS_DEAD);
 }
@@ -703,7 +703,7 @@ pppd_timed_out (gpointer data)
 {
 	NMPPPManager *manager = NM_PPP_MANAGER (data);
 
-	nm_warning ("Looks like pppd didn't initialize our dbus module");
+	nm_log_warn (LOGD_PPP, "pppd timed out or didn't initialize our dbus module");
 	nm_ppp_manager_stop (manager);
 
 	g_signal_emit (manager, signals[STATE_CHANGED], 0, NM_PPP_STATUS_DEAD);
@@ -913,10 +913,10 @@ nm_ppp_manager_start (NMPPPManager *manager,
 
 	priv = NM_PPP_MANAGER_GET_PRIVATE (manager);
 
-	nm_info ("Starting pppd connection");
+	nm_log_info (LOGD_PPP, "starting PPP connection");
 
 	cmd_str = nm_cmd_line_to_str (ppp_cmd);
-	nm_debug ("Command line: %s", cmd_str);
+	nm_log_dbg (LOGD_PPP, "command line: %s", cmd_str);
 	g_free (cmd_str);
 
 	priv->pid = 0;
@@ -927,7 +927,7 @@ nm_ppp_manager_start (NMPPPManager *manager,
 		goto out;
 	}
 
-	nm_debug ("ppp started with pid %d", priv->pid);
+	nm_log_info (LOGD_PPP, "pppd started with pid %d", priv->pid);
 
 	priv->ppp_watch_id = g_child_watch_add (priv->pid, (GChildWatchFunc) ppp_watch_cb, manager);
 	priv->ppp_timeout_handler = g_timeout_add_seconds (timeout_secs, pppd_timed_out, manager);
@@ -965,7 +965,7 @@ nm_ppp_manager_update_secrets (NMPPPManager *manager,
 		GError *err = NULL;
 
 		g_set_error (&err, NM_PPP_MANAGER_ERROR, NM_PPP_MANAGER_ERROR_UNKOWN, "%s", error_message);
-		nm_warning ("%s", error_message);
+		nm_log_warn (LOGD_PPP, "%s", error_message);
 		dbus_g_method_return_error (priv->pending_secrets_context, err);
 		g_error_free (err);
 	} else {
@@ -989,9 +989,9 @@ ensure_killed (gpointer data)
 		kill (pid, SIGKILL);
 
 	/* ensure the child is reaped */
-	nm_debug ("waiting for ppp pid %d to exit", pid);
+	nm_log_dbg (LOGD_PPP, "waiting for pppd pid %d to exit", pid);
 	waitpid (pid, NULL, 0);
-	nm_debug ("ppp pid %d cleaned up", pid);
+	nm_log_dbg (LOGD_PPP, "pppd pid %d cleaned up", pid);
 
 	return FALSE;
 }
@@ -1034,9 +1034,9 @@ nm_ppp_manager_stop (NMPPPManager *manager)
 			kill (priv->pid, SIGKILL);
 
 			/* ensure the child is reaped */
-			nm_debug ("waiting for ppp pid %d to exit", priv->pid);
+			nm_log_dbg (LOGD_PPP, "waiting for pppd pid %d to exit", priv->pid);
 			waitpid (priv->pid, NULL, 0);
-			nm_debug ("ppp pid %d cleaned up", priv->pid);
+			nm_log_dbg (LOGD_PPP, "pppd pid %d cleaned up", priv->pid);
 		}
 
 		priv->pid = 0;
diff --git a/src/ppp-manager/nm-pppd-plugin.c b/src/ppp-manager/nm-pppd-plugin.c
index b98ec28..c64bb87 100644
--- a/src/ppp-manager/nm-pppd-plugin.c
+++ b/src/ppp-manager/nm-pppd-plugin.c
@@ -34,7 +34,6 @@
 #include "nm-pppd-plugin.h"
 #include "nm-ppp-status.h"
 #include "nm-dbus-glib-types.h"
-#include "nm-utils.h"
 
 int plugin_init (void);
 
diff --git a/src/supplicant-manager/Makefile.am b/src/supplicant-manager/Makefile.am
index 540ef76..e59ae84 100644
--- a/src/supplicant-manager/Makefile.am
+++ b/src/supplicant-manager/Makefile.am
@@ -2,6 +2,7 @@ SUBDIRS=. tests
 
 INCLUDES = \
 	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
 	-I${top_builddir}/marshallers \
@@ -28,6 +29,7 @@ libsupplicant_manager_la_CPPFLAGS = \
 
 libsupplicant_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
 
diff --git a/src/supplicant-manager/nm-supplicant-config.c b/src/supplicant-manager/nm-supplicant-config.c
index 5f8c4f4..b516de5 100644
--- a/src/supplicant-manager/nm-supplicant-config.c
+++ b/src/supplicant-manager/nm-supplicant-config.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2006 - 2008 Red Hat, Inc.
+ * Copyright (C) 2006 - 2010 Red Hat, Inc.
  * Copyright (C) 2007 - 2008 Novell, Inc.
  */
 
@@ -31,7 +31,7 @@
 
 #include "nm-supplicant-config.h"
 #include "nm-supplicant-settings-verify.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-setting.h"
 #include "NetworkManagerUtils.h"
 
@@ -123,26 +123,26 @@ nm_supplicant_config_add_option_with_type (NMSupplicantConfig *self,
 			char buf[255];
 			memset (&buf[0], 0, sizeof (buf));
 			memcpy (&buf[0], value, len > 254 ? 254 : len);
-			nm_debug ("Key '%s' and/or value '%s' invalid.", key, buf);
+			nm_log_warn (LOGD_SUPPLICANT, "Key '%s' and/or value '%s' invalid.", key, buf);
 			return FALSE;
 		}
 	}
 
 	old_opt = (ConfigOption *) g_hash_table_lookup (priv->config, key);
 	if (old_opt) {
-		nm_debug ("Key '%s' already in table.", key);
+		nm_log_warn (LOGD_SUPPLICANT, "Key '%s' already in table.", key);
 		return FALSE;
 	}
 
 	opt = g_slice_new0 (ConfigOption);
 	if (opt == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option.");
 		return FALSE;
 	}
 
 	opt->value = g_malloc0 ((sizeof (char) * len) + 1);
 	if (opt->value == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option value.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option value.");
 		g_slice_free (ConfigOption, opt);
 		return FALSE;
 	}
@@ -151,12 +151,13 @@ nm_supplicant_config_add_option_with_type (NMSupplicantConfig *self,
 	opt->len = len;
 	opt->type = type;	
 
-{
-char buf[255];
-memset (&buf[0], 0, sizeof (buf));
-memcpy (&buf[0], opt->value, opt->len > 254 ? 254 : opt->len);
-nm_info ("Config: added '%s' value '%s'", key, secret ? "<omitted>" : &buf[0]);
-}
+	{
+		char buf[255];
+		memset (&buf[0], 0, sizeof (buf));
+		memcpy (&buf[0], opt->value, opt->len > 254 ? 254 : opt->len);
+		nm_log_info (LOGD_SUPPLICANT, "Config: added '%s' value '%s'", key, secret ? "<omitted>" : &buf[0]);
+	}
+
 	g_hash_table_insert (priv->config, g_strdup (key), opt);
 
 	return TRUE;
@@ -194,33 +195,33 @@ nm_supplicant_config_add_blob (NMSupplicantConfig *self,
 
 	type = nm_supplicant_settings_verify_setting (key, (const char *) value->data, value->len);
 	if (type == TYPE_INVALID) {
-		nm_debug ("Key '%s' and/or it's contained value is invalid.", key);
+		nm_log_warn (LOGD_SUPPLICANT, "Key '%s' and/or it's contained value is invalid.", key);
 		return FALSE;
 	}
 
 	old_opt = (ConfigOption *) g_hash_table_lookup (priv->config, key);
 	if (old_opt) {
-		nm_debug ("Key '%s' already in table.", key);
+		nm_log_warn (LOGD_SUPPLICANT, "Key '%s' already in table.", key);
 		return FALSE;
 	}
 
 	blob = g_byte_array_sized_new (value->len);
 	if (!blob) {
-		nm_debug ("Couldn't allocate memory for new config blob.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config blob.");
 		return FALSE;
 	}
 	g_byte_array_append (blob, value->data, value->len);
 
 	opt = g_slice_new0 (ConfigOption);
 	if (opt == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option.");
 		g_byte_array_free (blob, TRUE);
 		return FALSE;
 	}
 
 	opt->value = g_strdup_printf ("blob://%s", blobid);
 	if (opt->value == NULL) {
-		nm_debug ("Couldn't allocate memory for new config option value.");
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't allocate memory for new config option value.");
 		g_byte_array_free (blob, TRUE);
 		g_slice_free (ConfigOption, opt);
 		return FALSE;
@@ -229,7 +230,7 @@ nm_supplicant_config_add_blob (NMSupplicantConfig *self,
 	opt->len = strlen (opt->value);
 	opt->type = type;	
 
-nm_info ("Config: added '%s' value '%s'", key, opt->value);
+	nm_log_info (LOGD_SUPPLICANT, "Config: added '%s' value '%s'", key, opt->value);
 
 	g_hash_table_insert (priv->config, g_strdup (key), opt);
 	g_hash_table_insert (priv->blobs, g_strdup (blobid), blob);
@@ -378,13 +379,13 @@ nm_supplicant_config_add_setting_wireless (NMSupplicantConfig * self,
 
 	id = nm_setting_wireless_get_ssid (setting);
 	if (!nm_supplicant_config_add_option (self, "ssid", (char *) id->data, id->len, FALSE)) {
-		nm_warning ("Error adding SSID to supplicant config.");
+		nm_log_warn (LOGD_SUPPLICANT, "Error adding SSID to supplicant config.");
 		return FALSE;
 	}
 
 	if (is_adhoc) {
 		if (!nm_supplicant_config_add_option (self, "mode", "1", -1, FALSE)) {
-			nm_warning ("Error adding mode to supplicant config.");
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding mode to supplicant config.");
 			return FALSE;
 		}
 
@@ -394,7 +395,7 @@ nm_supplicant_config_add_setting_wireless (NMSupplicantConfig * self,
 			str_freq = g_strdup_printf ("%u", adhoc_freq);
 			if (!nm_supplicant_config_add_option (self, "frequency", str_freq, -1, FALSE)) {
 				g_free (str_freq);
-				nm_warning ("Error adding Ad-Hoc frequency to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding Ad-Hoc frequency to supplicant config.");
 				return FALSE;
 			}
 			g_free (str_freq);
@@ -418,7 +419,7 @@ nm_supplicant_config_add_setting_wireless (NMSupplicantConfig * self,
 		                                      str_bssid, strlen (str_bssid),
 		                                      FALSE)) {
 			g_free (str_bssid);
-			nm_warning ("Error adding BSSID to supplicant config.");
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding BSSID to supplicant config.");
 			return FALSE;
 		}
 		g_free (str_bssid);
@@ -445,7 +446,7 @@ add_string_val (NMSupplicantConfig *self,
 	value = ucase ? g_ascii_strup (field, -1) : g_strdup (field);
 	success = nm_supplicant_config_add_option (self, name, value, strlen (field), secret);
 	if (!success)
-		nm_warning ("Error adding %s to supplicant config.", name);
+		nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 	g_free (value);
 	return success;
 }
@@ -471,7 +472,7 @@ add_string_val (NMSupplicantConfig *self,
 			success = TRUE; \
 		g_string_free (str, TRUE); \
 		if (!success) { \
-			nm_warning ("Error adding %s to supplicant config.", name); \
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name); \
 			return FALSE; \
 		} \
 	}
@@ -494,7 +495,7 @@ get_blob_id (const char *name, const char *seed_uid)
 		success = nm_supplicant_config_add_blob (self, name, field, uid); \
 		g_free (uid); \
 		if (!success) { \
-			nm_warning ("Error adding %s to supplicant config.", name); \
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name); \
 			return FALSE; \
 		} \
 	}
@@ -550,16 +551,16 @@ add_wep_key (NMSupplicantConfig *self,
 			success = nm_supplicant_config_add_option (self, name, value, key_len / 2, TRUE);
 			g_free (value);
 			if (!success) {
-				nm_warning ("Error adding %s to supplicant config.", name);
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 				return FALSE;
 			}
 		} else if ((key_len == 5) || (key_len == 13)) {
 			if (!nm_supplicant_config_add_option (self, name, key, key_len, TRUE)) {
-				nm_warning ("Error adding %s to supplicant config.", name);
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 				return FALSE;
 			}
 		} else {
-			nm_warning ("Invalid WEP key '%s'", name);
+			nm_log_warn (LOGD_SUPPLICANT, "Invalid WEP key '%s'", name);
 			return FALSE;
 		}
 	} else if (wep_type == NM_WEP_KEY_TYPE_PASSPHRASE) {
@@ -570,7 +571,7 @@ add_wep_key (NMSupplicantConfig *self,
 		if (success)
 			success = nm_supplicant_config_add_option (self, name, (const char *) digest, digest_len, TRUE);
 		if (!success) {
-			nm_warning ("Error adding %s to supplicant config.", name);
+			nm_log_warn (LOGD_SUPPLICANT, "Error adding %s to supplicant config.", name);
 			return FALSE;
 		}
 	}
@@ -611,7 +612,7 @@ nm_supplicant_config_add_setting_wireless_security (NMSupplicantConfig *self,
 			success = nm_supplicant_config_add_option (self, "psk", value, psk_len / 2, TRUE);
 			g_free (value);
 			if (!success) {
-				nm_warning ("Error adding 'psk' to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding 'psk' to supplicant config.");
 				return FALSE;
 			}
 		} else if (psk_len >= 8 && psk_len <= 63) {
@@ -621,12 +622,12 @@ nm_supplicant_config_add_setting_wireless_security (NMSupplicantConfig *self,
 			 * passphrase and not a hex key.
 			 */
 			if (!nm_supplicant_config_add_option_with_type (self, "psk", psk, -1, TYPE_STRING, TRUE)) {
-				nm_warning ("Error adding 'psk' to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding 'psk' to supplicant config.");
 				return FALSE;
 			}
 		} else {
 			/* Invalid PSK */
-			nm_warning ("Invalid PSK length %u: not between 8 and 63 characters inclusive.", (guint32) psk_len);
+			nm_log_warn (LOGD_SUPPLICANT, "Invalid PSK length %u: not between 8 and 63 characters inclusive.", (guint32) psk_len);
 			return FALSE;
 		}
 	}
@@ -662,7 +663,7 @@ nm_supplicant_config_add_setting_wireless_security (NMSupplicantConfig *self,
 			success = nm_supplicant_config_add_option (self, "wep_tx_keyidx", value, -1, FALSE);
 			g_free (value);
 			if (!success) {
-				nm_warning ("Error adding wep_tx_keyidx to supplicant config.");
+				nm_log_warn (LOGD_SUPPLICANT, "Error adding wep_tx_keyidx to supplicant config.");
 				return FALSE;
 			}
 		}
diff --git a/src/supplicant-manager/nm-supplicant-interface.c b/src/supplicant-manager/nm-supplicant-interface.c
index 00f0c30..a65a458 100644
--- a/src/supplicant-manager/nm-supplicant-interface.c
+++ b/src/supplicant-manager/nm-supplicant-interface.c
@@ -25,7 +25,7 @@
 
 #include "nm-supplicant-interface.h"
 #include "nm-supplicant-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-marshal.h"
 #include "nm-supplicant-config.h"
 #include "nm-dbus-manager.h"
@@ -144,6 +144,7 @@ typedef struct {
 	DBusGProxy *proxy;
 	NMCallStore *store;
 	DBusGProxyCall *call;
+	gboolean disposing;
 } NMSupplicantInfo;
 
 static NMSupplicantInfo *
@@ -164,10 +165,11 @@ nm_supplicant_info_new (NMSupplicantInterface *interface,
 static void
 nm_supplicant_info_set_call (NMSupplicantInfo *info, DBusGProxyCall *call)
 {
-	if (call) {
-		nm_call_store_add (info->store, G_OBJECT (info->proxy), (gpointer) call);
-		info->call = call;
-	}
+	g_return_if_fail (info != NULL);
+	g_return_if_fail (call != NULL);
+
+	nm_call_store_add (info->store, G_OBJECT (info->proxy), (gpointer) call);
+	info->call = call;
 }
 
 static void
@@ -175,13 +177,30 @@ nm_supplicant_info_destroy (gpointer user_data)
 {
 	NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
 
-	if (info->call)
-		nm_call_store_remove (info->store, G_OBJECT (info->proxy), info->call);
+	/* Guard against double-disposal; since DBusGProxy doesn't guard against
+	 * double-disposal, we could infinite loop here if we're in the middle of
+	 * some wpa_supplicant D-Bus calls.  When the supplicant dies we'll dispose
+	 * of the proxy, which kills all its pending calls, which brings us here.
+	 * Then when we unref the proxy here, its dispose() function will get called
+	 * again, and we get right back here until we segfault because our callstack
+	 * is too long.
+	 */
+	if (!info->disposing) {
+		info->disposing = TRUE;
 
-	g_object_unref (info->proxy);
-	g_object_unref (info->interface);
+		if (info->call) {
+			nm_call_store_remove (info->store, G_OBJECT (info->proxy), info->call);
+			info->call = NULL;
+		}
 
-	g_slice_free (NMSupplicantInfo, info);
+		g_object_unref (info->proxy);
+		info->proxy = NULL;
+		g_object_unref (info->interface);
+		info->interface = NULL;
+
+		memset (info, 0, sizeof (NMSupplicantInfo));
+		g_slice_free (NMSupplicantInfo, info);
+	}
 }
 
 
@@ -498,8 +517,10 @@ bssid_properties_cb  (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_MAP_OF_VARIANT, &hash,
 	                            G_TYPE_INVALID)) {
-		if (!strstr (err->message, "The BSSID requested was invalid"))
-			nm_warning ("Couldn't retrieve BSSID properties: %s.", err->message);
+		if (!strstr (err->message, "The BSSID requested was invalid")) {
+			nm_log_warn (LOGD_SUPPLICANT, "Couldn't retrieve BSSID properties: %s.",
+			             err->message);
+		}
 		g_error_free (err);
 	} else {
 		g_signal_emit (info->interface,
@@ -543,7 +564,7 @@ scan_results_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_ARRAY_OF_OBJECT_PATH, &array,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("could not get scan results: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "could not get scan results: %s.", err->message);
 		g_error_free (err);
 	} else {
 		int i;
@@ -672,7 +693,7 @@ iface_state_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            G_TYPE_STRING, &state_str,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("could not get interface state: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "could not get interface state: %s.", err->message);
 		g_error_free (err);
 	} else {
 		NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
@@ -766,6 +787,7 @@ static void
 nm_supplicant_interface_add_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
 	NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
 	GError *err = NULL;
 	char *path = NULL;
 
@@ -780,12 +802,13 @@ nm_supplicant_interface_add_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpoi
 			/* Interface already added, just try to get the interface */
 			nm_supplicant_interface_add_to_supplicant (info->interface, TRUE);
 		} else {
-			nm_warning ("Unexpected supplicant error getting interface: %s", err->message);
+			nm_log_err (LOGD_SUPPLICANT, "(%s): error getting interface: %s",
+			            priv->dev, err->message);
 		}
 
 		g_error_free (err);
 	} else {
-		NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
+		nm_log_dbg (LOGD_SUPPLICANT, "(%s): interface added to supplicant", priv->dev);
 
 		priv->object_path = path;
 
@@ -884,6 +907,8 @@ nm_supplicant_interface_start (NMSupplicantInterface * self)
 	/* Can only start the interface from INIT state */
 	g_return_if_fail (priv->state == NM_SUPPLICANT_INTERFACE_STATE_INIT);
 
+	nm_log_dbg (LOGD_SUPPLICANT, "(%s): adding interface to supplicant", priv->dev);
+
 	state = nm_supplicant_manager_get_state (priv->smgr);
 	if (state == NM_SUPPLICANT_MANAGER_STATE_IDLE) {
 		nm_supplicant_interface_set_state (self, NM_SUPPLICANT_INTERFACE_STATE_STARTING);
@@ -893,7 +918,7 @@ nm_supplicant_interface_start (NMSupplicantInterface * self)
 		 * that its state has changed.
 		 */
 	} else
-		nm_warning ("Unknown supplicant manager state!");
+		nm_log_warn (LOGD_SUPPLICANT, "Unknown supplicant manager state!");
 }
 
 static void
@@ -914,7 +939,7 @@ nm_supplicant_interface_handle_supplicant_manager_idle_state (NMSupplicantInterf
 			/* Don't do anything here; interface can't get out of DOWN state */
 			break;
 		default:
-			nm_warning ("Unknown supplicant interface state!");
+			nm_log_warn (LOGD_SUPPLICANT, "Unknown supplicant interface state!");
 			break;
 	}
 }
@@ -970,7 +995,7 @@ nm_supplicant_interface_smgr_state_changed (NMSupplicantManager * smgr,
 			nm_supplicant_interface_handle_supplicant_manager_idle_state (self);
 			break;
 		default:
-			nm_warning ("Unknown supplicant manager state!");
+			nm_log_warn (LOGD_SUPPLICANT, "Unknown supplicant manager state!");
 			break;
 	}
 }
@@ -983,7 +1008,8 @@ remove_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_dat
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't remove network from supplicant interface: %s.", err->message);
+		nm_log_dbg (LOGD_SUPPLICANT, "Couldn't remove network from supplicant interface: %s.",
+		            err->message);
 		g_error_free (err);
 	}
 }
@@ -995,7 +1021,8 @@ disconnect_cb  (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't disconnect supplicant interface: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't disconnect supplicant interface: %s.",
+		             err->message);
 		g_error_free (err);
 	}
 }
@@ -1057,7 +1084,7 @@ select_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_dat
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't select network config: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't select network config: %s.", err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	}
@@ -1072,7 +1099,7 @@ set_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't set network config: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't set network config: %s.", err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	} else {
@@ -1116,7 +1143,7 @@ set_blobs_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	guint tmp;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't set network blobs: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't set network certificates: %s.", err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	} else {
@@ -1165,7 +1192,8 @@ call_set_blobs (NMSupplicantInfo *info, GHashTable *orig_blobs)
 	                               (GDestroyNotify) blob_free);
 	if (!blobs) {
 		const char *msg = "Not enough memory to create blob table.";
-		nm_warning ("%s", msg);
+
+		nm_log_warn (LOGD_SUPPLICANT, "%s", msg);
 		g_signal_emit (info->interface,
 		               nm_supplicant_interface_signals[CONNECTION_ERROR],
 		               0, "SendBlobError", msg);
@@ -1194,7 +1222,8 @@ add_network_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            DBUS_TYPE_G_OBJECT_PATH, &path,
 	                            G_TYPE_INVALID)) {
-		nm_warning ("Couldn't add a network to the supplicant interface: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't add a network to the supplicant interface: %s.",
+		             err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 	} else {
@@ -1225,22 +1254,21 @@ static void
 set_ap_scan_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 {
 	NMSupplicantInfo *info = (NMSupplicantInfo *) user_data;
+	NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
 	GError *err = NULL;
 	guint32 tmp;
 	DBusGProxyCall *call;
 
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err, G_TYPE_UINT, &tmp, G_TYPE_INVALID)) {
-		nm_warning ("Couldn't send AP scan mode to the supplicant interface: %s.", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Couldn't send AP scan mode to the supplicant interface: %s.",
+		             err->message);
 		emit_error_helper (info->interface, err);
 		g_error_free (err);
 		return;
 	}
 
-{
-NMSupplicantInterfacePrivate *priv = NM_SUPPLICANT_INTERFACE_GET_PRIVATE (info->interface);
-int ap_scan = nm_supplicant_config_get_ap_scan (priv->cfg);
-nm_info ("Config: set interface ap_scan to %d", ap_scan);
-}
+	nm_log_info (LOGD_SUPPLICANT, "Config: set interface ap_scan to %d",
+	             nm_supplicant_config_get_ap_scan (priv->cfg));
 
 	info = nm_supplicant_info_new (info->interface, proxy, info->store);
 	call = dbus_g_proxy_begin_call (proxy, "addNetwork",
@@ -1306,7 +1334,7 @@ scan_request_cb (DBusGProxy *proxy, DBusGProxyCall *call_id, gpointer user_data)
 	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
 	                            G_TYPE_UINT, &success,
 	                            G_TYPE_INVALID)) {
-		nm_warning  ("Could not get scan request result: %s", err->message);
+		nm_log_warn (LOGD_SUPPLICANT, "Could not get scan request result: %s", err->message);
 		g_error_free (err);
 	} 
 
diff --git a/src/supplicant-manager/nm-supplicant-manager.c b/src/supplicant-manager/nm-supplicant-manager.c
index 7a177ab..a2cf58e 100644
--- a/src/supplicant-manager/nm-supplicant-manager.c
+++ b/src/supplicant-manager/nm-supplicant-manager.c
@@ -27,7 +27,7 @@
 #include "nm-supplicant-interface.h"
 #include "nm-dbus-manager.h"
 #include "nm-marshal.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-glib-compat.h"
 
 #define SUPPLICANT_POKE_INTERVAL 120
@@ -97,11 +97,11 @@ poke_supplicant_cb (gpointer user_data)
 	                                   WPAS_DBUS_PATH,
 	                                   WPAS_DBUS_INTERFACE);
 	if (!proxy) {
-		nm_warning ("Error: could not init wpa_supplicant proxy");
+		nm_log_warn (LOGD_SUPPLICANT, "Error: could not init wpa_supplicant proxy");
 		goto out;
 	}
 
-	nm_info ("Trying to start the supplicant...");
+	nm_log_info (LOGD_SUPPLICANT, "Trying to start the supplicant...");
 	dbus_g_proxy_call_no_reply (proxy, "getInterface", G_TYPE_STRING, tmp, G_TYPE_INVALID);
 	g_object_unref (proxy);
 
@@ -288,9 +288,12 @@ nm_supplicant_manager_get_iface (NMSupplicantManager * self,
 	}
 
 	if (!iface) {
+		nm_log_dbg (LOGD_SUPPLICANT, "(%s): creating new supplicant interface", ifname);
 		iface = nm_supplicant_interface_new (self, ifname, is_wireless);
 		if (iface)
 			priv->ifaces = g_slist_append (priv->ifaces, iface);
+	} else {
+		nm_log_dbg (LOGD_SUPPLICANT, "(%s): returning existing supplicant interface", ifname);
 	}
 
 	return iface;
diff --git a/src/system-settings/Makefile.am b/src/system-settings/Makefile.am
index baec814..3b616b9 100644
--- a/src/system-settings/Makefile.am
+++ b/src/system-settings/Makefile.am
@@ -2,6 +2,7 @@ INCLUDES = -I${top_srcdir} \
            -I${top_srcdir}/include \
            -I${top_srcdir}/libnm-util \
            -I${top_srcdir}/libnm-glib \
+           -I${top_srcdir}/src/logging \
            -I${top_srcdir}/src \
            -I${top_builddir}/marshallers
 
@@ -44,6 +45,7 @@ libsystem_settings_la_LIBADD = \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(top_builddir)/libnm-glib/libnm-glib.la \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS) \
 	$(GMODULE_LIBS) \
diff --git a/src/system-settings/nm-inotify-helper.c b/src/system-settings/nm-inotify-helper.c
index 589dbd6..0ee168e 100644
--- a/src/system-settings/nm-inotify-helper.c
+++ b/src/system-settings/nm-inotify-helper.c
@@ -25,6 +25,7 @@
 
 #include "nm-marshal.h"
 #include "nm-inotify-helper.h"
+#include "nm-logging.h"
 
 G_DEFINE_TYPE (NMInotifyHelper, nm_inotify_helper, G_TYPE_OBJECT)
 
@@ -122,14 +123,14 @@ init_inotify (NMInotifyHelper *self)
 
 	priv->ifd = inotify_init ();
 	if (priv->ifd == -1) {
-		g_warning ("%s: couldn't initialize inotify", __func__);
+		nm_log_warn (LOGD_SYS_SET, "couldn't initialize inotify");
 		return FALSE;
 	}
 
 	/* Watch the inotify descriptor for file/directory change events */
 	channel = g_io_channel_unix_new (priv->ifd);
 	if (!channel) {
-		g_warning ("%s: couldn't create new GIOChannel", __func__);
+		nm_log_warn (LOGD_SYS_SET, "couldn't create new GIOChannel");
 		close (priv->ifd);
 		priv->ifd = -1;
 		return FALSE;
diff --git a/src/system-settings/nm-sysconfig-connection.c b/src/system-settings/nm-sysconfig-connection.c
index 7d6074c..09cec40 100644
--- a/src/system-settings/nm-sysconfig-connection.c
+++ b/src/system-settings/nm-sysconfig-connection.c
@@ -28,6 +28,7 @@
 #include "nm-settings-connection-interface.h"
 #include "nm-settings-interface.h"
 #include "nm-polkit-helpers.h"
+#include "nm-logging.h"
 
 
 static void settings_connection_interface_init (NMSettingsConnectionInterface *klass);
@@ -613,8 +614,9 @@ nm_sysconfig_connection_init (NMSysconfigConnection *self)
 	NMSysconfigConnectionPrivate *priv = NM_SYSCONFIG_CONNECTION_GET_PRIVATE (self);
 
 	priv->authority = polkit_authority_get ();
-	if (!priv->authority)
-		g_warning ("%s: error creating PolicyKit authority", __func__);
+	if (!priv->authority) {
+		nm_log_err (LOGD_SYS_SET, "%s: error creating PolicyKit authority");
+	}
 }
 
 static void
diff --git a/src/system-settings/nm-sysconfig-settings.c b/src/system-settings/nm-sysconfig-settings.c
index 5336906..4bcfb04 100644
--- a/src/system-settings/nm-sysconfig-settings.c
+++ b/src/system-settings/nm-sysconfig-settings.c
@@ -19,7 +19,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * (C) Copyright 2007 - 2009 Red Hat, Inc.
+ * (C) Copyright 2007 - 2010 Red Hat, Inc.
  * (C) Copyright 2008 Novell, Inc.
  */
 
@@ -57,8 +57,8 @@
 #include "nm-sysconfig-connection.h"
 #include "nm-polkit-helpers.h"
 #include "nm-system-config-error.h"
-#include "nm-utils.h"
 #include "nm-default-wired-connection.h"
+#include "nm-logging.h"
 
 #define CONFIG_KEY_NO_AUTO_DEFAULT "no-auto-default"
 
@@ -357,8 +357,6 @@ add_plugin (NMSysconfigSettings *self, NMSystemConfigInterface *plugin)
 
 	g_signal_connect (plugin, NM_SYSTEM_CONFIG_INTERFACE_CONNECTION_ADDED,
 	                  G_CALLBACK (plugin_connection_added), self);
-	g_signal_connect (plugin, NM_SYSTEM_CONFIG_INTERFACE_UNMANAGED_SPECS_CHANGED,
-	                  G_CALLBACK (unmanaged_specs_changed), self);
 	g_signal_connect (plugin, "notify::hostname", G_CALLBACK (hostname_changed), self);
 
 	nm_system_config_interface_init (plugin, NULL);
@@ -368,7 +366,10 @@ add_plugin (NMSysconfigSettings *self, NMSystemConfigInterface *plugin)
 	              NM_SYSTEM_CONFIG_INTERFACE_INFO, &pinfo,
 	              NULL);
 
-	g_message ("Loaded plugin %s: %s", pname, pinfo);
+	g_signal_connect (plugin, NM_SYSTEM_CONFIG_INTERFACE_UNMANAGED_SPECS_CHANGED,
+	                  G_CALLBACK (unmanaged_specs_changed), self);
+
+	nm_log_info (LOGD_SYS_SET, "Loaded plugin %s: %s", pname, pinfo);
 	g_free (pname);
 	g_free (pinfo);
 }
@@ -859,11 +860,11 @@ permission_call_done (GObject *object, GAsyncResult *result, gpointer user_data)
 	                                                         &error);
 	/* Some random error happened */
 	if (error) {
-		g_warning ("%s.%d (%s): error checking '%s' permission: (%d) %s",
-		           __FILE__, __LINE__, __func__,
-		           call->pk_action,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
+		nm_log_err (LOGD_SYS_SET, "error checking '%s' permission: (%d) %s",
+		            __FILE__, __LINE__, __func__,
+		            call->pk_action,
+		            error ? error->code : -1,
+		            error && error->message ? error->message : "(unknown)");
 		if (error)
 			g_error_free (error);
 	} else {
@@ -1064,7 +1065,7 @@ is_mac_auto_wired_blacklisted (NMSysconfigSettings *self, const GByteArray *mac)
 
 	config = g_key_file_new ();
 	if (!config) {
-		g_warning ("%s: not enough memory to load config file.", __func__);
+		nm_log_warn (LOGD_SYS_SET, "not enough memory to load config file.");
 		return FALSE;
 	}
 
@@ -1216,14 +1217,14 @@ default_wired_try_update (NMDefaultWiredConnection *wired,
 		g_object_set_data (G_OBJECT (nm_default_wired_connection_get_device (wired)),
 		                   DEFAULT_WIRED_TAG,
 		                   NULL);
-		g_message ("Saved default wired connection '%s' to persistent storage", id);
+		nm_log_info (LOGD_SYS_SET, "Saved default wired connection '%s' to persistent storage", id);
 		return FALSE;
 	}
 
-	g_warning ("%s: couldn't save default wired connection '%s': %d / %s",
-	           __func__, id,
-	           error ? error->code : -1,
-	           (error && error->message) ? error->message : "(unknown)");
+	nm_log_warn (LOGD_SYS_SET, "couldn't save default wired connection '%s': %d / %s",
+	             id,
+	             error ? error->code : -1,
+	             (error && error->message) ? error->message : "(unknown)");
 
 	/* If there was an error, don't destroy the default wired connection,
 	 * but add it back to the system settings service. Connection is already
@@ -1275,7 +1276,8 @@ nm_sysconfig_settings_device_added (NMSysconfigSettings *self, NMDevice *device)
 	id = nm_setting_connection_get_id (s_con);
 	g_assert (id);
 
-	g_message ("Added default wired connection '%s' for %s", id, nm_device_get_udi (device));
+	nm_log_info (LOGD_SYS_SET, "Added default wired connection '%s' for %s",
+	             id, nm_device_get_udi (device));
 
 	g_signal_connect (wired, "try-update", (GCallback) default_wired_try_update, self);
 	g_signal_connect (wired, "deleted", (GCallback) default_wired_deleted, self);
@@ -1327,6 +1329,7 @@ nm_sysconfig_settings_new (const char *config_file,
 			g_object_unref (self);
 			return NULL;
 		}
+		unmanaged_specs_changed (NULL, self);
 	}
 
 	return self;
@@ -1474,7 +1477,12 @@ nm_sysconfig_settings_class_init (NMSysconfigSettingsClass *class)
 	                              NM_DBUS_IFACE_SETTINGS_SYSTEM,
 	                              NM_TYPE_SYSCONFIG_SETTINGS_ERROR);
 
+	dbus_g_error_domain_register (NM_SETTINGS_INTERFACE_ERROR,
+	                              NM_DBUS_IFACE_SETTINGS,
+	                              NM_TYPE_SETTINGS_INTERFACE_ERROR);
+
 	/* And register all the settings errors with D-Bus */
+	dbus_g_error_domain_register (NM_CONNECTION_ERROR, NULL, NM_TYPE_CONNECTION_ERROR);
 	dbus_g_error_domain_register (NM_SETTING_802_1X_ERROR, NULL, NM_TYPE_SETTING_802_1X_ERROR);
 	dbus_g_error_domain_register (NM_SETTING_BLUETOOTH_ERROR, NULL, NM_TYPE_SETTING_BLUETOOTH_ERROR);
 	dbus_g_error_domain_register (NM_SETTING_CDMA_ERROR, NULL, NM_TYPE_SETTING_CDMA_ERROR);
@@ -1507,6 +1515,6 @@ nm_sysconfig_settings_init (NMSysconfigSettings *self)
 		                                          G_CALLBACK (pk_authority_changed_cb),
 		                                          self);
 	} else
-		g_warning ("%s: failed to create PolicyKit authority.", __func__);
+		nm_log_warn (LOGD_SYS_SET, "failed to create PolicyKit authority.");
 }
 
diff --git a/src/tests/Makefile.am b/src/tests/Makefile.am
index 398042c..39a994c 100644
--- a/src/tests/Makefile.am
+++ b/src/tests/Makefile.am
@@ -6,14 +6,18 @@ INCLUDES = \
 	-I$(top_srcdir)/src \
 	-I$(top_builddir)/src
 
-noinst_PROGRAMS = test-dhcp-options
+noinst_PROGRAMS = test-dhcp-options test-policy-hosts
+
+####### DHCP options test #######
 
 test_dhcp_options_SOURCES = \
 	test-dhcp-options.c
 
 test_dhcp_options_CPPFLAGS = \
 	$(GLIB_CFLAGS) \
-	$(DBUS_CFLAGS)
+	$(DBUS_CFLAGS) \
+	-DDHCLIENT_PATH=\"$(DHCLIENT_PATH)\" \
+	-DDHCPCD_PATH=\"$(DHCPCD_PATH)\"
 
 test_dhcp_options_LDADD = \
 	$(top_builddir)/libnm-util/libnm-util.la \
@@ -22,10 +26,23 @@ test_dhcp_options_LDADD = \
 	$(GLIB_LIBS) \
 	$(DBUS_LIBS)
 
+####### policy /etc/hosts test #######
+
+test_policy_hosts_SOURCES = \
+	test-policy-hosts.c
+
+test_policy_hosts_CPPFLAGS = \
+	$(GLIB_CFLAGS)
+
+test_policy_hosts_LDADD = \
+	$(top_builddir)/src/libtest-policy-hosts.la \
+	$(GLIB_LIBS)
+
 if WITH_TESTS
 
 check-local: test-dhcp-options
 	$(abs_builddir)/test-dhcp-options
+	$(abs_builddir)/test-policy-hosts
 
 endif
 
diff --git a/src/tests/test-dhcp-options.c b/src/tests/test-dhcp-options.c
index 90828d9..dd1f914 100644
--- a/src/tests/test-dhcp-options.c
+++ b/src/tests/test-dhcp-options.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  *
  */
 
@@ -35,15 +35,43 @@ typedef struct {
 	const char *value;
 } Option;
 
+static void
+destroy_gvalue (gpointer data)
+{
+	GValue *value = (GValue *) data;
+
+	g_value_unset (value);
+	g_slice_free (GValue, value);
+}
+
+static GValue *
+string_to_byte_array_gvalue (const char *str)
+{
+	GByteArray *array;
+	GValue *val;
+
+	array = g_byte_array_sized_new (strlen (str));
+	g_byte_array_append (array, (const guint8 *) str, strlen (str));
+
+	val = g_slice_new0 (GValue);
+	g_value_init (val, DBUS_TYPE_G_UCHAR_ARRAY);
+	g_value_take_boxed (val, array);
+
+	return val;
+}
+
 static GHashTable *
 fill_table (Option *test_options, GHashTable *table)
 {
 	Option *opt;
 
 	if (!table)
-		table = g_hash_table_new (g_str_hash, g_str_equal);
-	for (opt = test_options; opt->name; opt++)
-		g_hash_table_insert (table, (gpointer) opt->name, (gpointer) opt->value);
+		table = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, destroy_gvalue);
+	for (opt = test_options; opt->name; opt++) {
+		g_hash_table_insert (table,
+		                     (gpointer) opt->name,
+		                     string_to_byte_array_gvalue (opt->value));
+	}
 	return table;
 }
 
@@ -69,7 +97,7 @@ static Option generic_options[] = {
 };
 
 static void
-test_generic_options (void)
+test_generic_options (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -88,7 +116,7 @@ test_generic_options (void)
 	const char *expected_route2_gw = "10.1.1.1";
 
 	options = fill_table (generic_options, NULL);
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-generic", "failed to parse DHCP4 options");
 
@@ -187,7 +215,7 @@ static Option wins_options[] = {
 };
 
 static void
-test_wins_options (void)
+test_wins_options (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -199,7 +227,7 @@ test_wins_options (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (wins_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-wins", "failed to parse DHCP4 options");
 
@@ -231,7 +259,7 @@ static Option classless_routes_options[] = {
 };
 
 static void
-test_classless_static_routes (void)
+test_classless_static_routes (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -245,7 +273,7 @@ test_classless_static_routes (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (classless_routes_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442", "failed to parse DHCP4 options");
 
@@ -299,7 +327,7 @@ static Option invalid_classless_routes1[] = {
 };
 
 static void
-test_invalid_classless_routes1 (void)
+test_invalid_classless_routes1 (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -311,7 +339,7 @@ test_invalid_classless_routes1 (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_classless_routes1, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-invalid-1", "failed to parse DHCP4 options");
 
@@ -348,7 +376,7 @@ static Option invalid_classless_routes2[] = {
 };
 
 static void
-test_invalid_classless_routes2 (void)
+test_invalid_classless_routes2 (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -362,7 +390,7 @@ test_invalid_classless_routes2 (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_classless_routes2, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-invalid-2", "failed to parse DHCP4 options");
 
@@ -420,7 +448,7 @@ static Option invalid_classless_routes3[] = {
 };
 
 static void
-test_invalid_classless_routes3 (void)
+test_invalid_classless_routes3 (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -432,7 +460,7 @@ test_invalid_classless_routes3 (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_classless_routes3, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-invalid-3", "failed to parse DHCP4 options");
 
@@ -469,7 +497,7 @@ static Option gw_in_classless_routes[] = {
 };
 
 static void
-test_gateway_in_classless_routes (void)
+test_gateway_in_classless_routes (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -483,7 +511,7 @@ test_gateway_in_classless_routes (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (gw_in_classless_routes, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-rfc3442-gateway", "failed to parse DHCP4 options");
 
@@ -526,7 +554,7 @@ static Option escaped_searches_options[] = {
 };
 
 static void
-test_escaped_domain_searches (void)
+test_escaped_domain_searches (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -537,7 +565,7 @@ test_escaped_domain_searches (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (escaped_searches_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-escaped-domain-searches", "failed to parse DHCP4 options");
 
@@ -560,7 +588,7 @@ static Option invalid_escaped_searches_options[] = {
 };
 
 static void
-test_invalid_escaped_domain_searches (void)
+test_invalid_escaped_domain_searches (const char *client)
 {
 	GHashTable *options;
 	NMIP4Config *ip4_config;
@@ -568,7 +596,7 @@ test_invalid_escaped_domain_searches (void)
 	options = fill_table (generic_options, NULL);
 	options = fill_table (invalid_escaped_searches_options, options);
 
-	ip4_config = nm_dhcp_manager_options_to_ip4_config ("eth0", options);
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
 	ASSERT (ip4_config != NULL,
 	        "dhcp-invalid-escaped-domain-searches", "failed to parse DHCP4 options");
 
@@ -579,11 +607,76 @@ test_invalid_escaped_domain_searches (void)
 	g_hash_table_destroy (options);
 }
 
+static void
+test_ip4_missing_prefix (const char *client, const char *ip, guint32 expected_prefix)
+{
+	GHashTable *options;
+	NMIP4Config *ip4_config;
+	NMIP4Address *addr;
+
+	options = fill_table (generic_options, NULL);
+	g_hash_table_insert (options, "new_ip_address", string_to_byte_array_gvalue (ip));
+	g_hash_table_remove (options, "new_subnet_mask");
+
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
+	ASSERT (ip4_config != NULL,
+	        "dhcp-ip4-missing-prefix", "failed to parse DHCP4 options");
+
+	ASSERT (nm_ip4_config_get_num_addresses (ip4_config) == 1,
+	        "dhcp-ip4-missing-prefix", "unexpected number of IP4 addresses (not 1)");
+
+	addr = nm_ip4_config_get_address (ip4_config, 0);
+	ASSERT (addr != NULL,
+	        "dhcp-ip4-missing-prefix", "missing IP4 address #1");
+
+	ASSERT (nm_ip4_address_get_prefix (addr) == expected_prefix,
+	        "dhcp-ip4-missing-prefix", "unexpected IP4 address prefix %d (expected %d)",
+	        nm_ip4_address_get_prefix (addr), expected_prefix);
+
+	g_hash_table_destroy (options);
+}
+
+static void
+test_ip4_prefix_classless (const char *client)
+{
+	GHashTable *options;
+	NMIP4Config *ip4_config;
+	NMIP4Address *addr;
+
+	/* Ensure that the missing-subnet-mask handler doesn't mangle classless
+	 * subnet masks at all.  The handler should trigger only if the server
+	 * doesn't send the subnet mask.
+	 */
+
+	options = fill_table (generic_options, NULL);
+	g_hash_table_insert (options, "new_ip_address", string_to_byte_array_gvalue ("172.16.54.22"));
+	g_hash_table_insert (options, "new_subnet_mask", string_to_byte_array_gvalue ("255.255.252.0"));
+
+	ip4_config = nm_dhcp_manager_test_ip4_options_to_config (client, "eth0", options, "rebind");
+	ASSERT (ip4_config != NULL,
+	        "dhcp-ip4-prefix-classless", "failed to parse DHCP4 options");
+
+	ASSERT (nm_ip4_config_get_num_addresses (ip4_config) == 1,
+	        "dhcp-ip4-prefix-classless", "unexpected number of IP4 addresses (not 1)");
+
+	addr = nm_ip4_config_get_address (ip4_config, 0);
+	ASSERT (addr != NULL,
+	        "dhcp-ip4-prefix-classless", "missing IP4 address #1");
+
+	ASSERT (nm_ip4_address_get_prefix (addr) == 22,
+	        "dhcp-ip4-prefix-classless", "unexpected IP4 address prefix %d (expected 22)",
+	        nm_ip4_address_get_prefix (addr));
+
+	g_hash_table_destroy (options);
+}
+
 int main (int argc, char **argv)
 {
 	GError *error = NULL;
 	DBusGConnection *bus;
 	char *base;
+	const char *clients[2][2] = { {DHCLIENT_PATH, "dhclient"}, {DHCPCD_PATH, "dhcpcd"} };
+	guint32 i;
 
 	g_type_init ();
 	bus = dbus_g_bus_get (DBUS_BUS_SESSION, NULL);
@@ -592,15 +685,27 @@ int main (int argc, char **argv)
 		FAIL ("nm-utils-init", "failed to initialize libnm-util: %s", error->message);
 
 	/* The tests */
-	test_generic_options ();
-	test_wins_options ();
-	test_classless_static_routes ();
-	test_invalid_classless_routes1 ();
-	test_invalid_classless_routes2 ();
-	test_invalid_classless_routes3 ();
-	test_gateway_in_classless_routes ();
-	test_escaped_domain_searches ();
-	test_invalid_escaped_domain_searches ();
+	for (i = 0; i < 2; i++) {
+		const char *client_path = clients[i][0];
+		const char *client = clients[i][1];
+
+		if (!client_path || !strlen (client_path))
+			continue;
+
+		test_generic_options (client);
+		test_wins_options (client);
+		test_classless_static_routes (client);
+		test_invalid_classless_routes1 (client);
+		test_invalid_classless_routes2 (client);
+		test_invalid_classless_routes3 (client);
+		test_gateway_in_classless_routes (client);
+		test_escaped_domain_searches (client);
+		test_invalid_escaped_domain_searches (client);
+		test_ip4_missing_prefix (client, "192.168.1.10", 24);
+		test_ip4_missing_prefix (client, "172.16.54.50", 16);
+		test_ip4_missing_prefix (client, "10.1.2.3", 8);
+		test_ip4_prefix_classless (client);
+	}
 
 	base = g_path_get_basename (argv[0]);
 	fprintf (stdout, "%s: SUCCESS\n", base);
diff --git a/src/tests/test-policy-hosts.c b/src/tests/test-policy-hosts.c
new file mode 100644
index 0000000..e14f15e
--- /dev/null
+++ b/src/tests/test-policy-hosts.c
@@ -0,0 +1,394 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ */
+
+#include <glib.h>
+#include <string.h>
+
+#include "nm-policy-hosts.h"
+
+#define FALLBACK_HOSTNAME "localhost.localdomain"
+
+static void
+test_generic (const char *before,
+              const char *after,
+              const char *hostname,
+              gboolean expect_error)
+{
+	char **lines;
+	GString *newc;
+	GError *error = NULL;
+
+	/* Get the new /etc/hosts contents */
+	lines = g_strsplit_set (before, "\n\r", 0);
+	newc = nm_policy_get_etc_hosts ((const char **) lines,
+	                                strlen (before),
+	                                hostname,
+	                                FALLBACK_HOSTNAME,
+	                                &error);
+	g_strfreev (lines);
+
+	if (expect_error) {
+		g_assert (newc == NULL);
+		g_assert (error != NULL);
+		g_clear_error (&error);
+	} else if (after == NULL) {
+		/* No change to /etc/hosts required */
+		g_assert (newc == NULL);
+		g_assert (error == NULL);
+	} else {
+		g_assert (newc != NULL);
+		g_assert (error == NULL);
+
+#if 0
+		g_message ("\n--------------------------------------\n"
+		           "%s"
+		           "--------------------------------------",
+		           newc->str);
+#endif
+		g_assert (strlen (newc->str) == strlen (after));
+		g_assert (strcmp (newc->str, after) == 0);
+		g_string_free (newc, TRUE);
+	}
+}
+
+/*******************************************/
+
+static const char *generic_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic (void)
+{
+	test_generic (generic_before, NULL, "localhost.localdomain", FALSE);
+}
+
+/*******************************************/
+
+static const char *generic_no_boilerplate_before = \
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic_no_boilerplate (void)
+{
+	test_generic (generic_no_boilerplate_before, NULL, "localhost.localdomain", FALSE);
+}
+
+/*******************************************/
+
+static const char *generic_no_boilerplate_no_lh_before = \
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static const char *generic_no_boilerplate_no_lh_after = \
+	"127.0.0.1	localhost\n"
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic_no_boilerplate_no_lh (void)
+{
+	test_generic (generic_no_boilerplate_no_lh_before,
+	              generic_no_boilerplate_no_lh_after,
+	              "localhost.localdomain",
+	              FALSE);
+}
+
+/*******************************************/
+
+
+static const char *generic_no_boilerplate_no_lh_no_host_before = \
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static const char *generic_no_boilerplate_no_lh_no_host_after = \
+	"127.0.0.1	comet	localhost.localdomain	localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_generic_no_boilerplate_no_lh_no_host (void)
+{
+	test_generic (generic_no_boilerplate_no_lh_no_host_before,
+	              generic_no_boilerplate_no_lh_no_host_after,
+	              "comet",
+	              FALSE);
+}
+
+/*******************************************/
+static const char *named_generic_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	playboy localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_named_generic (void)
+{
+	test_generic (named_generic_before, NULL, "playboy", FALSE);
+}
+
+/*******************************************/
+
+static const char *named_non127_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n";
+
+static void
+test_hosts_named_non127 (void)
+{
+	test_generic (named_non127_before, NULL, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *named2_non127_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n";
+
+static void
+test_hosts_named2_non127 (void)
+{
+	test_generic (named2_non127_before, NULL, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *named_no_lh_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n";
+
+static const char *named_no_lh_after = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain	localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"192.168.1.2	tomcat\n";
+
+static void
+test_hosts_named_no_localhost (void)
+{
+	test_generic (named_no_lh_before, named_no_lh_after, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *no_lh_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	tomcat\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static const char *no_lh_after = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain	localhost\n"
+	"127.0.0.1	tomcat\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n";
+
+static void
+test_hosts_no_localhost (void)
+{
+	test_generic (no_lh_before, no_lh_after, "tomcat", FALSE);
+}
+
+/*******************************************/
+
+static const char *named_last_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 sparcbook.ausil.us\n"
+	"::1         localhost localhost.localdomain localhost6 localhost6.localdomain6 sparcbook.ausil.us\n";
+
+static void
+test_hosts_named_last (void)
+{
+	test_generic (named_last_before, NULL, "sparcbook.ausil.us", FALSE);
+}
+
+/*******************************************/
+
+static const char *no_host_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n"
+	"127.0.0.1	a.tribalfusion.com\n";
+
+static const char *no_host_after = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	comet	localhost.localdomain	localhost\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n"
+	"127.0.0.1	a.tribalfusion.com\n";
+
+static void
+test_hosts_no_host (void)
+{
+	test_generic (no_host_before, no_host_after, "comet", FALSE);
+}
+
+/*******************************************/
+
+static const char *long_before = \
+	"# Do not remove the following line, or various programs\n"
+	"# that require network functionality will fail.\n"
+	"127.0.0.1	localhost.localdomain	localhost	comet\n"
+	"::1		localhost6.localdomain6 localhost6\n"
+	"\n"
+	"127.0.0.1	lcmd.us.intellitxt.com\n"
+	"127.0.0.1	adserver.adtech.de\n"
+	"127.0.0.1	a.as-us.falkag.net\n"
+	"127.0.0.1	a.as-eu.falkag.net\n"
+	"127.0.0.1	ads.doubleclick.com\n"
+	"\n"
+	"# random comment\n"
+	"127.0.0.1	m1.2mdn.net\n"
+	"127.0.0.1	ds.serving-sys.com\n"
+	"127.0.0.1	pagead2.googlesyndication.com\n"
+	"127.0.0.1	ad.doubleclick.com\n"
+	"127.0.0.1	ad.doubleclick.net\n"
+	"127.0.0.1	oascentral.movietickets.com\n"
+	"127.0.0.1	view.atdmt.com\n"
+	"127.0.0.1	ads.chumcity.com\n"
+	"127.0.0.1	ads.as4x.tmcs.net\n"
+	"127.0.0.1	n4403ad.doubleclick.net\n"
+	"127.0.0.1	www.assoc-amazon.com\n"
+	"127.0.0.1	s25.sitemeter.com\n"
+	"127.0.0.1	adlog.com.com\n"
+	"127.0.0.1	ahs.laptopmag.com\n"
+	"127.0.0.1	altfarm.mediaplex.com\n"
+	"127.0.0.1	ads.addynamix.com\n"
+	"127.0.0.1	srx.main.ebayrtm.com\n"
+	"127.0.0.1	cdn5.tribalfusion.com\n"
+	"127.0.0.1	a.tribalfusion.com\n";
+
+
+static void
+test_hosts_long (void)
+{
+	test_generic (long_before, NULL, "comet", FALSE);
+}
+
+/*******************************************/
+
+typedef struct {
+	const char *line;
+	const char *token;
+	gboolean expected;
+} Foo;
+
+static Foo foo[] = {
+	/* Using \t here to easily differentiate tabs vs. spaces for testing */
+	{ "127.0.0.1\tfoobar\tblah", "blah", TRUE },
+	{ "", "blah", FALSE },
+	{ "1.1.1.1\tbork\tfoo", "blah", FALSE },
+	{ "127.0.0.1 foobar\tblah", "blah", TRUE },
+	{ "127.0.0.1 foobar blah", "blah", TRUE },
+	{ "127.0.0.1 localhost", "localhost.localdomain", FALSE },
+	{ "192.168.1.1 blah borkbork", "blah", TRUE },
+	{ "192.168.1.1 foobar\tblah borkbork", "blah", TRUE },
+	{ "192.168.1.1\tfoobar\tblah\tborkbork", "blah", TRUE },
+	{ "192.168.1.1 \tfoobar \tblah \tborkbork\t ", "blah", TRUE },
+	{ "\t\t\t\t   \t\t\tasdfadf  a\t\t\t\t\t   \t\t\t\t\t ", "blah", FALSE },
+	{ NULL, NULL, FALSE }
+};
+
+static void
+test_find_token (void)
+{
+	Foo *iter = &foo[0];
+
+	while (iter->line) {
+		gboolean found;
+
+		found = nm_policy_hosts_find_token (iter->line, iter->token);
+		if (found != iter->expected) {
+			g_warning ("find-token: unexpected token result %d for '%s' <= '%s' (expected %d)",
+			           found, iter->line, iter->token, iter->expected);
+		}
+		g_assert (found == iter->expected);
+		iter++;
+	}
+}
+
+typedef void (*TCFunc)(void);
+
+#define TESTCASE(t, d) g_test_create_case (#t, 0, d, NULL, (TCFunc) t, NULL)
+
+int main (int argc, char **argv)
+{
+	GTestSuite *suite;
+
+	g_test_init (&argc, &argv, NULL);
+
+	suite = g_test_get_root ();
+
+	g_test_suite_add (suite, TESTCASE (test_find_token, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic_no_boilerplate, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic_no_boilerplate_no_lh, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_generic_no_boilerplate_no_lh_no_host, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_generic, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_non127, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named2_non127, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_no_localhost, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_no_localhost, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_named_last, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_no_host, NULL));
+	g_test_suite_add (suite, TESTCASE (test_hosts_long, NULL));
+
+	return g_test_run ();
+}
+
diff --git a/src/vpn-manager/Makefile.am b/src/vpn-manager/Makefile.am
index 1078603..56e4a4c 100644
--- a/src/vpn-manager/Makefile.am
+++ b/src/vpn-manager/Makefile.am
@@ -2,6 +2,7 @@ INCLUDES = \
 	-I${top_srcdir} \
 	-I${top_srcdir}/include \
 	-I${top_srcdir}/libnm-util \
+	-I${top_srcdir}/src/logging \
 	-I${top_srcdir}/src \
 	-I${top_builddir}/marshallers \
 	-I${top_srcdir}/src/named-manager \
@@ -25,6 +26,7 @@ libvpn_manager_la_CPPFLAGS =	\
 
 libvpn_manager_la_LIBADD = \
 	$(top_builddir)/marshallers/libmarshallers.la \
+	$(top_builddir)/src/logging/libnm-logging.la \
 	$(top_builddir)/libnm-util/libnm-util.la \
 	$(DBUS_LIBS) \
 	$(GLIB_LIBS)
diff --git a/src/vpn-manager/nm-vpn-connection.c b/src/vpn-manager/nm-vpn-connection.c
index f8360dc..01f639a 100644
--- a/src/vpn-manager/nm-vpn-connection.c
+++ b/src/vpn-manager/nm-vpn-connection.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2005 - 2009 Red Hat, Inc.
+ * Copyright (C) 2005 - 2010 Red Hat, Inc.
  * Copyright (C) 2006 - 2008 Novell, Inc.
  */
 
@@ -35,7 +35,8 @@
 #include "nm-setting-ip4-config.h"
 #include "nm-dbus-manager.h"
 #include "nm-manager.h"
-#include "NetworkManagerSystem.h"
+#include "nm-system.h"
+#include "nm-logging.h"
 #include "nm-utils.h"
 #include "nm-vpn-plugin-bindings.h"
 #include "nm-marshal.h"
@@ -269,7 +270,7 @@ plugin_failed (DBusGProxy *proxy,
 {
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (user_data);
 
-	nm_info ("VPN plugin failed: %d", plugin_failure);
+	nm_log_warn (LOGD_VPN, "VPN plugin failed: %d", plugin_failure);
 
 	switch (plugin_failure) {
 	case NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED:
@@ -291,7 +292,7 @@ plugin_state_changed (DBusGProxy *proxy,
 	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
 
-	nm_info ("VPN plugin state changed: %d", state);
+	nm_log_info (LOGD_VPN, "VPN plugin state changed: %d", state);
 
 	if (state == NM_VPN_SERVICE_STATE_STOPPED) {
 		/* Clear connection secrets to ensure secrets get requested each time the
@@ -305,7 +306,7 @@ plugin_state_changed (DBusGProxy *proxy,
 		case NM_VPN_CONNECTION_STATE_CONNECT:
 		case NM_VPN_CONNECTION_STATE_IP_CONFIG_GET:
 		case NM_VPN_CONNECTION_STATE_ACTIVATED:
-			nm_info ("VPN plugin state change reason: %d", priv->failure_reason);
+			nm_log_info (LOGD_VPN, "VPN plugin state change reason: %d", priv->failure_reason);
 			nm_vpn_connection_set_vpn_state (connection,
 			                                 NM_VPN_CONNECTION_STATE_FAILED,
 											 priv->failure_reason);
@@ -331,8 +332,8 @@ ip_address_to_string (guint32 numeric)
 	if (inet_ntop (AF_INET, &temp_addr, buf, INET_ADDRSTRLEN)) {
 		return buf;
 	} else {
-		nm_warning ("%s: error converting IP4 address 0x%X",
-		            __func__, ntohl (temp_addr.s_addr));
+		nm_log_warn (LOGD_VPN, "error converting IP4 address 0x%X",
+		             ntohl (temp_addr.s_addr));
 		return NULL;
 	}
 }
@@ -351,38 +352,44 @@ print_vpn_config (NMIP4Config *config,
 
 	addr = nm_ip4_config_get_address (config, 0);
 
-	nm_info ("VPN Gateway: %s", ip_address_to_string (nm_ip4_address_get_gateway (addr)));
+	nm_log_info (LOGD_VPN, "VPN Gateway: %s", ip_address_to_string (nm_ip4_address_get_gateway (addr)));
 	if (internal_gw)
-		nm_info ("Internal Gateway: %s", ip_address_to_string (internal_gw));
-	nm_info ("Tunnel Device: %s", tundev);
-	nm_info ("Internal IP4 Address: %s", ip_address_to_string (nm_ip4_address_get_address (addr)));
-	nm_info ("Internal IP4 Prefix: %d", nm_ip4_address_get_prefix (addr));
-	nm_info ("Internal IP4 Point-to-Point Address: %s",
-		    ip_address_to_string (nm_ip4_config_get_ptp_address (config)));
-	nm_info ("Maximum Segment Size (MSS): %d", nm_ip4_config_get_mss (config));
+		nm_log_info (LOGD_VPN, "Internal Gateway: %s", ip_address_to_string (internal_gw));
+	nm_log_info (LOGD_VPN, "Tunnel Device: %s", tundev);
+	nm_log_info (LOGD_VPN, "Internal IP4 Address: %s", ip_address_to_string (nm_ip4_address_get_address (addr)));
+	nm_log_info (LOGD_VPN, "Internal IP4 Prefix: %d", nm_ip4_address_get_prefix (addr));
+	nm_log_info (LOGD_VPN, "Internal IP4 Point-to-Point Address: %s",
+	             ip_address_to_string (nm_ip4_config_get_ptp_address (config)));
+	nm_log_info (LOGD_VPN, "Maximum Segment Size (MSS): %d", nm_ip4_config_get_mss (config));
 
 	num = nm_ip4_config_get_num_routes (config);
 	for (i = 0; i < num; i++) {
 		NMIP4Route *route;
 
 		route = nm_ip4_config_get_route (config, i);
-		nm_info ("Static Route: %s/%d   Next Hop: %s",
-			    ip_address_to_string (nm_ip4_route_get_dest (route)),
-			    nm_ip4_route_get_prefix (route),
-			    ip_address_to_string (nm_ip4_route_get_next_hop (route)));
+		nm_log_info (LOGD_VPN, "Static Route: %s/%d   Next Hop: %s",
+		             ip_address_to_string (nm_ip4_route_get_dest (route)),
+		             nm_ip4_route_get_prefix (route),
+		             ip_address_to_string (nm_ip4_route_get_next_hop (route)));
 	}
 
 	num = nm_ip4_config_get_num_nameservers (config);
-	for (i = 0; i < num; i++)
-		nm_info ("Internal IP4 DNS: %s", ip_address_to_string (nm_ip4_config_get_nameserver (config, i)));
+	for (i = 0; i < num; i++) {
+		nm_log_info (LOGD_VPN, "Internal IP4 DNS: %s",
+		             ip_address_to_string (nm_ip4_config_get_nameserver (config, i)));
+	}
 
 	if (nm_ip4_config_get_num_domains (config) > 0)
 		dns_domain = (char *) nm_ip4_config_get_domain (config, 0);
-	nm_info ("DNS Domain: '%s'", dns_domain ? dns_domain : "(none)");
-	nm_info ("Login Banner:");
-	nm_info ("-----------------------------------------");
-	nm_info ("%s", banner);
-	nm_info ("-----------------------------------------");
+
+	nm_log_info (LOGD_VPN, "DNS Domain: '%s'", dns_domain ? dns_domain : "(none)");
+
+	if (banner && strlen (banner)) {
+		nm_log_info (LOGD_VPN, "Login Banner:");
+		nm_log_info (LOGD_VPN, "-----------------------------------------");
+		nm_log_info (LOGD_VPN, "%s", banner);
+		nm_log_info (LOGD_VPN, "-----------------------------------------");
+	}
 }
 
 static void
@@ -399,8 +406,8 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	int i;
 	guint32 vpn_ext_gw = 0;
 
-	nm_info ("VPN connection '%s' (IP Config Get) reply received.",
-		    nm_vpn_connection_get_name (connection));
+	nm_log_info (LOGD_VPN, "VPN connection '%s' (IP Config Get) reply received.",
+	             nm_vpn_connection_get_name (connection));
 
 	g_source_remove (priv->ipconfig_timeout);
 	priv->ipconfig_timeout = 0;
@@ -411,7 +418,7 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	if (val)
 		priv->tundev = g_strdup (g_value_get_string (val));
 	else {
-		nm_warning ("%s: invalid or missing tunnel device received!", __func__);
+		nm_log_err (LOGD_VPN, "invalid or missing tunnel device received!");
 		goto error;
 	}
 
@@ -445,7 +452,7 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	if (nm_ip4_address_get_address (addr) && nm_ip4_address_get_prefix (addr)) {
 		nm_ip4_config_take_address (config, addr);
 	} else {
-		nm_warning ("%s: invalid IP4 config received!", __func__);
+		nm_log_err (LOGD_VPN, "invalid IP4 config received!");
 		nm_ip4_address_unref (addr);
 		goto error;
 	}
@@ -532,8 +539,8 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 
 		priv->ip4_config = config;
 
-		nm_info ("VPN connection '%s' (IP Config Get) complete.",
-			    nm_vpn_connection_get_name (connection));
+		nm_log_info (LOGD_VPN, "VPN connection '%s' (IP Config Get) complete.",
+		             nm_vpn_connection_get_name (connection));
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_ACTIVATED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_NONE);
@@ -541,8 +548,8 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	}
 
 error:
-	nm_warning ("VPN connection '%s' did not receive valid IP config information.",
-	            nm_vpn_connection_get_name (connection));
+	nm_log_warn (LOGD_VPN, "VPN connection '%s' did not receive valid IP config information.",
+	             nm_vpn_connection_get_name (connection));
 	nm_vpn_connection_set_vpn_state (connection,
 	                                 NM_VPN_CONNECTION_STATE_FAILED,
 	                                 NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID);
@@ -561,8 +568,8 @@ nm_vpn_connection_ip_config_timeout (gpointer user_data)
 	 * in this timeout, cancel activation because it's taken too long.
 	 */
 	if (nm_vpn_connection_get_vpn_state (connection) == NM_VPN_CONNECTION_STATE_IP_CONFIG_GET) {
-		nm_info ("VPN connection '%s' (IP Config Get) timeout exceeded.",
-		         nm_vpn_connection_get_name (connection));
+		nm_log_warn (LOGD_VPN, "VPN connection '%s' (IP Config Get) timeout exceeded.",
+		             nm_vpn_connection_get_name (connection));
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_FAILED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT);
@@ -577,12 +584,12 @@ nm_vpn_connection_connect_cb (DBusGProxy *proxy, GError *err, gpointer user_data
 	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
 
-	nm_info ("VPN connection '%s' (Connect) reply received.",
-		    nm_vpn_connection_get_name (connection));
+	nm_log_info (LOGD_VPN, "VPN connection '%s' (Connect) reply received.",
+	             nm_vpn_connection_get_name (connection));
 
 	if (err) {
-		nm_warning ("VPN connection '%s' failed to connect: '%s'.", 
-				  nm_vpn_connection_get_name (connection), err->message);
+		nm_log_warn (LOGD_VPN, "VPN connection '%s' failed to connect: '%s'.", 
+		             nm_vpn_connection_get_name (connection), err->message);
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_FAILED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED);
@@ -777,9 +784,9 @@ secrets_update_setting (NMSecretsProviderInterface *interface,
 		return FALSE;
 
 	if (!nm_connection_update_secrets (priv->connection, NM_SETTING_VPN_SETTING_NAME, new, &error)) {
-		nm_warning ("Failed to update VPN secrets: %d %s",
-		            error ? error->code : -1,
-		            error && error->message ? error->message : "(none)");
+		nm_log_warn (LOGD_VPN, "Failed to update VPN secrets: %d %s",
+		             error ? error->code : -1,
+		             error && error->message ? error->message : "(none)");
 		g_clear_error (&error);
 		return FALSE;
 	}
@@ -823,9 +830,9 @@ connection_need_secrets_cb  (DBusGProxy *proxy,
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (self);
 
 	if (error) {
-		g_warning ("%s.%d: NeedSecrets failed: %s %s",
-		           __FILE__, __LINE__,
-		           g_quark_to_string (error->domain), error->message);
+		nm_log_err (LOGD_VPN, "NeedSecrets failed: %s %s",
+		            g_quark_to_string (error->domain),
+		            error->message);
 		nm_vpn_connection_fail (self, NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS);
 		return;
 	}
@@ -893,7 +900,7 @@ vpn_cleanup (NMVPNConnection *connection)
 			                                 nm_device_get_ip4_config (priv->parent_dev),
 			                                 nm_device_get_priority (priv->parent_dev),
 			                                 NM_IP4_COMPARE_FLAG_ADDRESSES | NM_IP4_COMPARE_FLAG_ROUTES)) {
-				nm_warning ("%s: failed to re-apply VPN parent device addresses and routes.", __func__);
+				nm_log_err (LOGD_VPN, "failed to re-apply VPN parent device addresses and routes.");
 			}
 		}
 	}
@@ -940,7 +947,7 @@ connection_state_changed (NMVPNConnection *connection,
 
 			org_freedesktop_NetworkManager_VPN_Plugin_disconnect (priv->proxy, &err);
 			if (err) {
-				nm_warning ("%s", err->message);
+				nm_log_warn (LOGD_VPN, "error disconnecting VPN: %s", err->message);
 				g_error_free (err);
 			}
 
diff --git a/src/vpn-manager/nm-vpn-manager.c b/src/vpn-manager/nm-vpn-manager.c
index e8fa24c..221a8b5 100644
--- a/src/vpn-manager/nm-vpn-manager.c
+++ b/src/vpn-manager/nm-vpn-manager.c
@@ -27,7 +27,6 @@
 #include "nm-setting-vpn.h"
 #include "nm-dbus-manager.h"
 #include "NetworkManagerVPN.h"
-#include "nm-utils.h"
 #include "nm-marshal.h"
 
 G_DEFINE_TYPE (NMVPNManager, nm_vpn_manager, G_TYPE_OBJECT)
diff --git a/src/vpn-manager/nm-vpn-service.c b/src/vpn-manager/nm-vpn-service.c
index 15aa56d..bdbb377 100644
--- a/src/vpn-manager/nm-vpn-service.c
+++ b/src/vpn-manager/nm-vpn-service.c
@@ -29,7 +29,7 @@
 
 #include "nm-vpn-service.h"
 #include "nm-dbus-manager.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 #include "nm-vpn-manager.h"
 #include "nm-glib-compat.h"
 
@@ -198,18 +198,20 @@ vpn_service_watch_cb (GPid pid, gint status, gpointer user_data)
 	if (WIFEXITED (status)) {
 		guint err = WEXITSTATUS (status);
 
-		if (err != 0)
-			nm_warning ("VPN service '%s' exited with error: %d",
-					  nm_vpn_service_get_name (service), WSTOPSIG (status));
-	} else if (WIFSTOPPED (status))
-		nm_warning ("VPN service '%s' stopped unexpectedly with signal %d",
-				  nm_vpn_service_get_name (service), WSTOPSIG (status));
-	else if (WIFSIGNALED (status))
-		nm_warning ("VPN service '%s' died with signal %d",
-				  nm_vpn_service_get_name (service), WTERMSIG (status));
-	else
-		nm_warning ("VPN service '%s' died from an unknown cause", 
-				  nm_vpn_service_get_name (service));
+		if (err != 0) {
+			nm_log_warn (LOGD_VPN, "VPN service '%s' exited with error: %d",
+			             nm_vpn_service_get_name (service), WSTOPSIG (status));
+		}
+	} else if (WIFSTOPPED (status)) {
+		nm_log_warn (LOGD_VPN, "VPN service '%s' stopped unexpectedly with signal %d",
+		             nm_vpn_service_get_name (service), WSTOPSIG (status));
+	} else if (WIFSIGNALED (status)) {
+		nm_log_warn (LOGD_VPN, "VPN service '%s' died with signal %d",
+		             nm_vpn_service_get_name (service), WTERMSIG (status));
+	} else {
+		nm_log_warn (LOGD_VPN, "VPN service '%s' died from an unknown cause", 
+		             nm_vpn_service_get_name (service));
+	}
 
 	priv->pid = 0;
 	priv->service_child_watch = 0;
@@ -222,8 +224,8 @@ nm_vpn_service_timeout (gpointer data)
 {
 	NMVPNService *service = NM_VPN_SERVICE (data);
 
-	nm_info ("VPN service '%s' did not start in time, cancelling connections",
-		    nm_vpn_service_get_name (service));
+	nm_log_warn (LOGD_VPN, "VPN service '%s' did not start in time, cancelling connections",
+	             nm_vpn_service_get_name (service));
 
 	NM_VPN_SERVICE_GET_PRIVATE (service)->service_start_timeout = 0;
 	nm_vpn_service_connections_stop (service, TRUE, NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT);
@@ -250,14 +252,14 @@ nm_vpn_service_daemon_exec (NMVPNService *service, GError **error)
 	                         nm_vpn_service_child_setup, NULL, &priv->pid,
 	                         &spawn_error);
 	if (success) {
-		nm_info ("VPN service '%s' started (%s), PID %d", 
-		         nm_vpn_service_get_name (service), priv->dbus_service, priv->pid);
+		nm_log_info (LOGD_VPN, "VPN service '%s' started (%s), PID %d", 
+		             nm_vpn_service_get_name (service), priv->dbus_service, priv->pid);
 
 		priv->service_child_watch = g_child_watch_add (priv->pid, vpn_service_watch_cb, service);
 		priv->service_start_timeout = g_timeout_add_seconds (5, nm_vpn_service_timeout, service);
 	} else {
-		nm_warning ("VPN service '%s': could not launch the VPN service. error: (%d) %s.",
-		            nm_vpn_service_get_name (service), spawn_error->code, spawn_error->message);
+		nm_log_warn (LOGD_VPN, "VPN service '%s': could not launch the VPN service. error: (%d) %s.",
+		             nm_vpn_service_get_name (service), spawn_error->code, spawn_error->message);
 
 		g_set_error (error,
 		             NM_VPN_MANAGER_ERROR, NM_VPN_MANAGER_ERROR_SERVICE_START_FAILED,
@@ -334,7 +336,8 @@ nm_vpn_service_activate (NMVPNService *service,
 		// FIXME: fill in error when errors happen
 		nm_vpn_connection_activate (vpn);
 	} else if (priv->service_start_timeout == 0) {
-		nm_info ("Starting VPN service '%s'...", nm_vpn_service_get_name (service));
+		nm_log_info (LOGD_VPN, "Starting VPN service '%s'...",
+		             nm_vpn_service_get_name (service));
 		if (!nm_vpn_service_daemon_exec (service, error))
 			vpn = NULL;
 	}
@@ -378,16 +381,16 @@ nm_vpn_service_name_owner_changed (NMDBusManager *mgr,
 		/* service just appeared */
 		GSList *iter;
 
-		nm_info ("VPN service '%s' just appeared, activating connections",
-			    nm_vpn_service_get_name (service));
+		nm_log_info (LOGD_VPN, "VPN service '%s' appeared, activating connections",
+		             nm_vpn_service_get_name (service));
 
 		for (iter = priv->connections; iter; iter = iter->next)
 			nm_vpn_connection_activate (NM_VPN_CONNECTION (iter->data));
 
 	} else if (old_owner_good && !new_owner_good) {
 		/* service went away */
-		nm_info ("VPN service '%s' disappeared, cancelling connections",
-			    nm_vpn_service_get_name (service));
+		nm_log_info (LOGD_VPN, "VPN service '%s' disappeared, cancelling connections",
+		             nm_vpn_service_get_name (service));
 		nm_vpn_service_connections_stop (service, TRUE, NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED);
 	}
 }
@@ -415,9 +418,9 @@ ensure_killed (gpointer data)
 		kill (pid, SIGKILL);
 
 	/* ensure the child is reaped */
-	nm_debug ("waiting for vpn service pid %d to exit", pid);
+	nm_log_dbg (LOGD_VPN, "waiting for VPN service pid %d to exit", pid);
 	waitpid (pid, NULL, 0);
-	nm_debug ("vpn service pid %d cleaned up", pid);
+	nm_log_dbg (LOGD_VPN, "VPN service pid %d cleaned up", pid);
 
 	return FALSE;
 }
@@ -446,9 +449,9 @@ finalize (GObject *object)
 			kill (priv->pid, SIGKILL);
 
 			/* ensure the child is reaped */
-			nm_debug ("waiting for vpn service pid %d to exit", priv->pid);
+			nm_log_dbg (LOGD_VPN, "waiting for VPN service pid %d to exit", priv->pid);
 			waitpid (priv->pid, NULL, 0);
-			nm_debug ("vpn service pid %d cleaned up", priv->pid);
+			nm_log_dbg (LOGD_VPN, "VPN service pid %d cleaned up", priv->pid);
 		}
 
 		priv->pid = 0;
diff --git a/src/wpa.c b/src/wpa.c
index 8f50047..5f4fd02 100644
--- a/src/wpa.c
+++ b/src/wpa.c
@@ -1,3 +1,4 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /*
  * WPA Supplicant - WPA state machine and EAPOL-Key processing
  * Copyright (c) 2003-2005, Jouni Malinen <jkmaline@cc.hut.fi>
@@ -19,7 +20,7 @@
 #include <glib.h>
 
 #include "wpa.h"
-#include "nm-utils.h"
+#include "nm-logging.h"
 
 typedef guint16 u16;
 typedef guint8 u8;
@@ -207,8 +208,8 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 	}
 
 	if (wpa_ie_len < sizeof(struct wpa_ie_hdr)) {
-		nm_debug ("%s: ie len too short %lu",
-			   __func__, (unsigned long) wpa_ie_len);
+		nm_log_dbg (LOGD_WIFI, "IE len too short %lu",
+			    (unsigned long) wpa_ie_len);
 		return -1;
 	}
 
@@ -218,8 +219,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 	    hdr->len != wpa_ie_len - 2 ||
 	    memcmp(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN) != 0 ||
 	    WPA_GET_LE16(hdr->version) != WPA_VERSION) {
-		nm_debug ("%s: malformed ie or unknown version",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "malformed IE or unknown version");
 		return -1;
 	}
 
@@ -231,8 +231,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 		pos += WPA_SELECTOR_LEN;
 		left -= WPA_SELECTOR_LEN;
 	} else if (left > 0) {
-		nm_debug ("%s: ie length mismatch, %u too much",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE length mismatch, %u too much", left);
 		return -1;
 	}
 
@@ -242,8 +241,8 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (pairwise), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (pairwise), "
+			            "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -252,8 +251,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 			left -= WPA_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for key mgmt)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for key mgmt)");
 		return -1;
 	}
 
@@ -263,8 +261,8 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (key mgmt), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (key mgmt), "
+				   "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -273,8 +271,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 			left -= WPA_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for capabilities)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for capabilities)");
 		return -1;
 	}
 
@@ -286,8 +283,7 @@ static int wpa_parse_wpa_ie_wpa(const u8 *wpa_ie, size_t wpa_ie_len,
 	}
 
 	if (left > 0) {
-		nm_debug ("%s: ie has %u trailing bytes",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE has %u trailing bytes", left);
 		return -1;
 	}
 
@@ -317,8 +313,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 	}
 
 	if (rsn_ie_len < sizeof(struct rsn_ie_hdr)) {
-		nm_debug ("%s: ie len too short %lu",
-			   __func__, (unsigned long) rsn_ie_len);
+		nm_log_dbg (LOGD_WIFI, "IE len too short %lu",
+			    (unsigned long) rsn_ie_len);
 		return -1;
 	}
 
@@ -327,8 +323,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 	if (hdr->elem_id != WPA_RSN_INFO_ELEM ||
 	    hdr->len != rsn_ie_len - 2 ||
 	    WPA_GET_LE16(hdr->version) != RSN_VERSION) {
-		nm_debug ("%s: malformed ie or unknown version",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "malformed IE or unknown version");
 		return -1;
 	}
 
@@ -340,8 +335,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += RSN_SELECTOR_LEN;
 		left -= RSN_SELECTOR_LEN;
 	} else if (left > 0) {
-		nm_debug ("%s: ie length mismatch, %u too much",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE length mismatch, %u too much", left);
 		return -1;
 	}
 
@@ -351,8 +345,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (pairwise), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (pairwise), "
+				    "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -361,8 +355,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 			left -= RSN_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for key mgmt)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for key mgmt)");
 		return -1;
 	}
 
@@ -372,8 +365,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += 2;
 		left -= 2;
 		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
-			nm_debug ("%s: ie count botch (key mgmt), "
-				   "count %u left %u", __func__, count, left);
+			nm_log_dbg (LOGD_WIFI, "IE count botch (key mgmt), "
+				   "count %u left %u", count, left);
 			return -1;
 		}
 		for (i = 0; i < count; i++) {
@@ -382,8 +375,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 			left -= RSN_SELECTOR_LEN;
 		}
 	} else if (left == 1) {
-		nm_debug ("%s: ie too short (for capabilities)",
-			   __func__);
+		nm_log_dbg (LOGD_WIFI, "IE too short (for capabilities)");
 		return -1;
 	}
 
@@ -399,9 +391,9 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 		pos += 2;
 		left -= 2;
 		if (left < data->num_pmkid * PMKID_LEN) {
-			nm_debug ("%s: PMKID underflow "
-				   "(num_pmkid=%d left=%d)",
-				   __func__, data->num_pmkid, left);
+			nm_log_dbg (LOGD_WIFI, "PMKID underflow "
+				    "(num_pmkid=%d left=%d)",
+				    data->num_pmkid, left);
 			data->num_pmkid = 0;
 		} else {
 			data->pmkid = pos;
@@ -411,8 +403,7 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
 	}
 
 	if (left > 0) {
-		nm_debug ("%s: ie has %u trailing bytes - ignored",
-			   __func__, left);
+		nm_log_dbg (LOGD_WIFI, "IE has %u trailing bytes - ignored", left);
 	}
 
 	return 0;
@@ -430,8 +421,8 @@ static int wpa_parse_wpa_ie_rsn(const u8 *rsn_ie, size_t rsn_ie_len,
  */
 wpa_ie_data * wpa_parse_wpa_ie(const u8 *wpa_ie, size_t wpa_ie_len)
 {
-	wpa_ie_data *	data = NULL;
-	int			err = -1;
+	wpa_ie_data *data = NULL;
+	int err = -1;
 
 	if (!wpa_ie || wpa_ie_len <= 0)
 		return NULL;
@@ -443,25 +434,21 @@ wpa_ie_data * wpa_parse_wpa_ie(const u8 *wpa_ie, size_t wpa_ie_len)
 	else
 		err = wpa_parse_wpa_ie_wpa(wpa_ie, wpa_ie_len, data);
 
-	if (err != 0)
-	{
+	if (err != 0) {
 		g_slice_free (wpa_ie_data, data);
 		data = NULL;
 	}
 
-#if 0
-	if (data)
-	{
-		nm_debug ("WPA IE: -------------------");
-		nm_debug ("   proto        0x%X", data->proto);
-		nm_debug ("   pw cipher    0x%X", data->pairwise_cipher);
-		nm_debug ("   gr cipher    0x%X", data->group_cipher);
-		nm_debug ("   key mgmt     0x%X", data->key_mgmt);
-		nm_debug ("   capabilities 0x%X", data->capabilities);
-		nm_debug ("   # pmkid      0x%X", data->num_pmkid);
-		nm_debug ("");
+	if (data) {
+		nm_log_dbg (LOGD_WIFI, "WPA IE: -------------------");
+		nm_log_dbg (LOGD_WIFI, "   proto        0x%X", data->proto);
+		nm_log_dbg (LOGD_WIFI, "   pw cipher    0x%X", data->pairwise_cipher);
+		nm_log_dbg (LOGD_WIFI, "   gr cipher    0x%X", data->group_cipher);
+		nm_log_dbg (LOGD_WIFI, "   key mgmt     0x%X", data->key_mgmt);
+		nm_log_dbg (LOGD_WIFI, "   capabilities 0x%X", data->capabilities);
+		nm_log_dbg (LOGD_WIFI, "   # pmkid      0x%X", data->num_pmkid);
+		nm_log_dbg (LOGD_WIFI, "");
 	}
-#endif
 
 	return data;
 }
diff --git a/system-settings/plugins/ifcfg-rh/plugin.c b/system-settings/plugins/ifcfg-rh/plugin.c
index a272728..47ce007 100644
--- a/system-settings/plugins/ifcfg-rh/plugin.c
+++ b/system-settings/plugins/ifcfg-rh/plugin.c
@@ -38,6 +38,7 @@
 #include <dbus/dbus-glib-lowlevel.h>
 
 #include <nm-setting-connection.h>
+#include <nm-settings-interface.h>
 
 #include "common.h"
 #include "nm-dbus-glib-types.h"
@@ -535,31 +536,46 @@ impl_ifcfgrh_get_ifcfg_details (SCPluginIfcfg *plugin,
 	const char *path;
 
 	if (!g_path_is_absolute (in_ifcfg)) {
-		g_set_error (error, 0, 0, "ifcfg path '%s' is not absolute", in_ifcfg);
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INVALID_CONNECTION,
+		             "ifcfg path '%s' is not absolute", in_ifcfg);
 		return FALSE;
 	}
 
 	connection = g_hash_table_lookup (priv->connections, in_ifcfg);
 	if (!connection) {
-		g_set_error (error, 0, 0, "ifcfg file '%s' unknown", in_ifcfg);
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INVALID_CONNECTION,
+		             "ifcfg file '%s' unknown", in_ifcfg);
 		return FALSE;
 	}
 
 	s_con = (NMSettingConnection *) nm_connection_get_setting (NM_CONNECTION (connection), NM_TYPE_SETTING_CONNECTION);
 	if (!s_con) {
-		g_set_error_literal (error, 0, 0, "unable to retrieve the connection setting");
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		             "unable to retrieve the connection setting");
 		return FALSE;
 	}
 
 	uuid = nm_setting_connection_get_uuid (s_con);
 	if (!uuid) {
-		g_set_error_literal (error, 0, 0, "unable to get the UUID");
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		             "unable to get the UUID");
 		return FALSE;
 	}
 	
 	path = nm_connection_get_path (NM_CONNECTION (connection));
 	if (!path) {
-		g_set_error_literal (error, 0, 0, "unable to get the connection D-Bus path");
+		g_set_error (error,
+		             NM_SETTINGS_INTERFACE_ERROR,
+		             NM_SETTINGS_INTERFACE_ERROR_INTERNAL_ERROR,
+		             "unable to get the connection D-Bus path");
 		return FALSE;
 	}
 
diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index afe35bd..4149e6c 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 - 2009 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <stdlib.h>
@@ -606,16 +606,9 @@ read_full_ip4_address (shvarFile *ifcfg,
 
 	/* Try to autodetermine the prefix for the address' class */
 	if (!nm_ip4_address_get_prefix (addr)) {
-		guint32 tmp_addr, prefix = 0;
-
-		tmp_addr = nm_ip4_address_get_address (addr);
-		if (((ntohl(tmp_addr) & 0xFF000000) >> 24) <= 127)
-			prefix = 8;
-		else if (((ntohl(tmp_addr) & 0xFF000000) >> 24) <= 191)
-			prefix = 16;
-		else
-			prefix = 24;
+		guint32 prefix = 0;
 
+		prefix = nm_utils_ip4_get_default_prefix (nm_ip4_address_get_address (addr));
 		nm_ip4_address_set_prefix (addr, prefix);
 
 		value = svGetValue (ifcfg, ip_tag, FALSE);
@@ -1122,6 +1115,7 @@ static NMSetting *
 make_ip4_setting (shvarFile *ifcfg,
                   const char *network_file,
                   const char *iscsiadm_path,
+                  gboolean valid_ip6_config,
                   GError **error)
 {
 	NMSettingIP4Config *s_ip4 = NULL;
@@ -1199,14 +1193,17 @@ make_ip4_setting (shvarFile *ifcfg,
 			g_set_error (error, ifcfg_plugin_error_quark (), 0,
 			             "Unknown BOOTPROTO '%s'", value);
 			g_free (value);
-			goto error;
+			goto done;
 		}
 		g_free (value);
 	} else {
 		char *tmp_ip4, *tmp_prefix, *tmp_netmask;
 
-		/* If there is no BOOTPROTO, no IPADDR, no PREFIX, and no NETMASK,
-		 * assume DHCP is to be used.  Happens with minimal ifcfg files like:
+		/* If there is no BOOTPROTO, no IPADDR, no PREFIX, no NETMASK, but
+		 * valid IPv6 configuration, assume that IPv4 is disabled.  Otherwise,
+		 * if there is no IPv6 configuration, assume DHCP is to be used.
+		 * Happens with minimal ifcfg files like the following that anaconda
+		 * sometimes used to write out:
 		 *
 		 * DEVICE=eth0
 		 * HWADDR=11:22:33:44:55:66
@@ -1215,8 +1212,14 @@ make_ip4_setting (shvarFile *ifcfg,
 		tmp_ip4 = svGetValue (ifcfg, "IPADDR", FALSE);
 		tmp_prefix = svGetValue (ifcfg, "PREFIX", FALSE);
 		tmp_netmask = svGetValue (ifcfg, "NETMASK", FALSE);
-		if (!tmp_ip4 && !tmp_prefix && !tmp_netmask)
+		if (!tmp_ip4 && !tmp_prefix && !tmp_netmask) {
+			if (valid_ip6_config) {
+				/* Nope, no IPv4 */
+				goto done;
+			}
+
 			method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+		}
 		g_free (tmp_ip4);
 		g_free (tmp_prefix);
 		g_free (tmp_netmask);
@@ -1236,7 +1239,7 @@ make_ip4_setting (shvarFile *ifcfg,
 		for (i = 1; i < 256; i++) {
 			addr = read_full_ip4_address (ifcfg, network_file, i, error);
 			if (error && *error)
-				goto error;
+				goto done;
 			if (!addr)
 				break;
 
@@ -1278,7 +1281,7 @@ make_ip4_setting (shvarFile *ifcfg,
 			}
 			if (!tmp_success) {
 				g_free (tag);
-				goto error;
+				goto done;
 			}
 			g_clear_error (error);
 		}
@@ -1312,7 +1315,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	if (!route_path) {
 		g_set_error (error, ifcfg_plugin_error_quark (), 0,
 		             "Could not get route file path for '%s'", ifcfg->fileName);
-		goto error;
+		goto done;
 	}
 
 	/* First test new/legacy syntax */
@@ -1326,7 +1329,7 @@ make_ip4_setting (shvarFile *ifcfg,
 				route = read_one_ip4_route (route_ifcfg, network_file, i, error);
 				if (error && *error) {
 					svCloseFile (route_ifcfg);
-					goto error;
+					goto done;
 				}
 				if (!route)
 					break;
@@ -1341,7 +1344,7 @@ make_ip4_setting (shvarFile *ifcfg,
 		read_route_file_legacy (route_path, s_ip4, error);
 		g_free (route_path);
 		if (error && *error)
-			goto error;
+			goto done;
 	}
 
 	/* Legacy value NM used for a while but is incorrect (rh #459370) */
@@ -1367,7 +1370,7 @@ make_ip4_setting (shvarFile *ifcfg,
 
 	return NM_SETTING (s_ip4);
 
-error:
+done:
 	g_object_unref (s_ip4);
 	return NULL;
 }
@@ -1382,7 +1385,7 @@ make_ip6_setting (shvarFile *ifcfg,
 	char *value = NULL;
 	char *str_value;
 	char *route6_path = NULL;
-	gboolean bool_value, ipv6forwarding, ipv6_autoconf;
+	gboolean bool_value, ipv6forwarding, ipv6_autoconf, dhcp6 = FALSE;
 	char *method = NM_SETTING_IP6_CONFIG_METHOD_MANUAL;
 	guint32 i;
 	shvarFile *network_ifcfg;
@@ -1459,9 +1462,12 @@ make_ip6_setting (shvarFile *ifcfg,
 	/* Find out method property */
 	ipv6forwarding = svTrueValue (ifcfg, "IPV6FORWARDING", FALSE);
 	ipv6_autoconf = svTrueValue (ifcfg, "IPV6_AUTOCONF", !ipv6forwarding);
+	dhcp6 = svTrueValue (ifcfg, "DHCPV6C", FALSE);
 
 	if (ipv6_autoconf)
 		method = NM_SETTING_IP6_CONFIG_METHOD_AUTO;
+	else if (dhcp6)
+		method = NM_SETTING_IP6_CONFIG_METHOD_DHCP;
 	else {
 		/* IPV6_AUTOCONF=no and no IPv6 address -> method 'link-local' */
 		str_value = svGetValue (ifcfg, "IPV6ADDR", FALSE);
@@ -1572,6 +1578,7 @@ static gboolean
 add_one_wep_key (shvarFile *ifcfg,
                  const char *shvar_key,
                  guint8 key_idx,
+                 gboolean passphrase,
                  NMSettingWirelessSecurity *s_wsec,
                  GError **error)
 {
@@ -1591,42 +1598,51 @@ add_one_wep_key (shvarFile *ifcfg,
 	}
 
 	/* Validate keys */
-	if (strlen (value) == 10 || strlen (value) == 26) {
-		/* Hexadecimal WEP key */
-		char *p = value;
+	if (passphrase) {
+		if (strlen (value) && strlen (value) < 64) {
+			key = g_strdup (value);
+			g_object_set (G_OBJECT (s_wsec),
+			              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE,
+			              NM_WEP_KEY_TYPE_PASSPHRASE,
+			              NULL);
+		}
+	} else {
+		if (strlen (value) == 10 || strlen (value) == 26) {
+			/* Hexadecimal WEP key */
+			char *p = value;
 
-		while (*p) {
-			if (!g_ascii_isxdigit (*p)) {
-				g_set_error (error, ifcfg_plugin_error_quark (), 0,
-				             "Invalid hexadecimal WEP key.");
-				goto out;
+			while (*p) {
+				if (!g_ascii_isxdigit (*p)) {
+					g_set_error (error, ifcfg_plugin_error_quark (), 0,
+					             "Invalid hexadecimal WEP key.");
+					goto out;
+				}
+				p++;
 			}
-			p++;
-		}
-		key = g_strdup (value);
-	} else if (   strncmp (value, "s:", 2)
-	           && (strlen (value) == 7 || strlen (value) == 15)) {
-		/* ASCII passphrase */
-		char *p = value + 2;
+			key = g_strdup (value);
+		} else if (   strncmp (value, "s:", 2)
+		           && (strlen (value) == 7 || strlen (value) == 15)) {
+			/* ASCII passphrase */
+			char *p = value + 2;
 
-		while (*p) {
-			if (!isascii ((int) (*p))) {
-				g_set_error (error, ifcfg_plugin_error_quark (), 0,
-				             "Invalid ASCII WEP passphrase.");
-				goto out;
+			while (*p) {
+				if (!isascii ((int) (*p))) {
+					g_set_error (error, ifcfg_plugin_error_quark (), 0,
+					             "Invalid ASCII WEP passphrase.");
+					goto out;
+				}
+				p++;
 			}
-			p++;
-		}
 
-		key = utils_bin2hexstr (value, strlen (value), strlen (value) * 2);
-	} else {
-		g_set_error (error, ifcfg_plugin_error_quark (), 0, "Invalid WEP key length.");
+			key = utils_bin2hexstr (value, strlen (value), strlen (value) * 2);
+		}
 	}
 
 	if (key) {
 		nm_setting_wireless_security_set_wep_key (s_wsec, key_idx, key);
 		success = TRUE;
-	}
+	} else
+		g_set_error (error, ifcfg_plugin_error_quark (), 0, "Invalid WEP key length.");
 
 out:
 	g_free (value);
@@ -1639,15 +1655,26 @@ read_wep_keys (shvarFile *ifcfg,
                NMSettingWirelessSecurity *s_wsec,
                GError **error)
 {
-	if (!add_one_wep_key (ifcfg, "KEY1", 0, s_wsec, error))
+	/* Try hex/ascii keys first */
+	if (!add_one_wep_key (ifcfg, "KEY1", 0, FALSE, s_wsec, error))
+		return FALSE;
+	if (!add_one_wep_key (ifcfg, "KEY2", 1, FALSE, s_wsec, error))
+		return FALSE;
+	if (!add_one_wep_key (ifcfg, "KEY3", 2, FALSE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY2", 1, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY4", 3, FALSE, s_wsec, error))
+		return FALSE;
+	if (!add_one_wep_key (ifcfg, "KEY", def_idx, FALSE, s_wsec, error))
+		return FALSE;
+
+	/* And then passphrases */
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE1", 0, TRUE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY3", 2, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE2", 1, TRUE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY4", 3, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE3", 2, TRUE, s_wsec, error))
 		return FALSE;
-	if (!add_one_wep_key (ifcfg, "KEY", def_idx, s_wsec, error))
+	if (!add_one_wep_key (ifcfg, "KEY_PASSPHRASE4", 3, TRUE, s_wsec, error))
 		return FALSE;
 
 	return TRUE;
@@ -1695,6 +1722,7 @@ make_wep_setting (shvarFile *ifcfg,
 			goto error;
 		}
 		svCloseFile (keys_ifcfg);
+		g_assert (error == NULL || *error == NULL);
 	}
 
 	/* If there's a default key, ensure that key exists */
@@ -3062,6 +3090,7 @@ connection_from_file (const char *filename,
 	NMSetting *s_ip4, *s_ip6;
 	const char *ifcfg_name = NULL;
 	gboolean nm_controlled = TRUE;
+	gboolean ip6_used = FALSE;
 
 	g_return_val_if_fail (filename != NULL, NULL);
 	g_return_val_if_fail (unmanaged != NULL, NULL);
@@ -3165,22 +3194,27 @@ connection_from_file (const char *filename,
 	if (!connection || *unmanaged)
 		goto done;
 
-	s_ip4 = make_ip4_setting (parsed, network_file, iscsiadm_path, error);
+	s_ip6 = make_ip6_setting (parsed, network_file, iscsiadm_path, error);
 	if (*error) {
 		g_object_unref (connection);
 		connection = NULL;
 		goto done;
-	} else if (s_ip4) {
-		nm_connection_add_setting (connection, s_ip4);
+	} else if (s_ip6) {
+		const char *method;
+
+		nm_connection_add_setting (connection, s_ip6);
+		method = nm_setting_ip6_config_get_method (NM_SETTING_IP6_CONFIG (s_ip6));
+		if (method && strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE))
+			ip6_used = TRUE;
 	}
 
-	s_ip6 = make_ip6_setting (parsed, network_file, iscsiadm_path, error);
+	s_ip4 = make_ip4_setting (parsed, network_file, iscsiadm_path, ip6_used, error);
 	if (*error) {
 		g_object_unref (connection);
 		connection = NULL;
 		goto done;
-	} else if (s_ip6)
-		nm_connection_add_setting (connection, s_ip6);
+	} else if (s_ip4)
+		nm_connection_add_setting (connection, s_ip4);
 
 	/* iSCSI / ibft connections are read-only since their settings are
 	 * stored in NVRAM and can only be changed in BIOS.
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am b/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am
index b5c94dd..66435ac 100644
--- a/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/Makefile.am
@@ -57,7 +57,10 @@ EXTRA_DIST = \
 	route6-test-wired-ipv6-manual \
 	ifcfg-test-wired-static-no-prefix-8 \
 	ifcfg-test-wired-static-no-prefix-16 \
-	ifcfg-test-wired-static-no-prefix-24
+	ifcfg-test-wired-static-no-prefix-24 \
+	ifcfg-test-wired-ipv6-only \
+	ifcfg-test-wifi-wep-passphrase \
+	keys-test-wifi-wep-passphrase
 
 check-local:
 	@for f in $(EXTRA_DIST); do \
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wifi-wep-passphrase b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wifi-wep-passphrase
new file mode 100644
index 0000000..250efa1
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wifi-wep-passphrase
@@ -0,0 +1,14 @@
+TYPE=Wireless
+DEVICE=eth2
+HWADDR=00:16:41:11:22:33
+NM_CONTROLLED=yes
+BOOTPROTO=dhcp
+ESSID=blahblah
+CHANNEL=1
+MODE=Managed
+RATE=auto
+ONBOOT=yes
+USERCTL=yes
+PEERDNS=yes
+IPV6INIT=no
+SECURITYMODE=open
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wired-ipv6-only b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wired-ipv6-only
new file mode 100644
index 0000000..59ec32e
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-wired-ipv6-only
@@ -0,0 +1,14 @@
+# Intel Corporation 82567LM Gigabit Network Connection
+TYPE=Ethernet
+DEVICE=eth2
+HWADDR=00:11:22:33:44:ee
+ONBOOT=yes
+USERCTL=yes
+NM_CONTROLLED=yes
+PEERDNS=yes
+DNS1=1:2:3:4::a
+DOMAIN="lorem.com ipsum.org dolor.edu"
+IPV6INIT=yes
+IPV6_AUTOCONF=no
+IPV6ADDR="1001:abba::1234/56"
+
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/keys-test-wifi-wep-passphrase b/system-settings/plugins/ifcfg-rh/tests/network-scripts/keys-test-wifi-wep-passphrase
new file mode 100644
index 0000000..d45c0ea
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/keys-test-wifi-wep-passphrase
@@ -0,0 +1 @@
+KEY_PASSPHRASE1="foobar222blahblah"
diff --git a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
index 8855a32..c96d13a 100644
--- a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
+++ b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2008 - 2009 Red Hat, Inc.
+ * Copyright (C) 2008 - 2010 Red Hat, Inc.
  */
 
 #include <stdio.h>
@@ -2142,6 +2142,155 @@ test_read_wired_ipv6_manual (void)
 	g_object_unref (connection);
 }
 
+#define TEST_IFCFG_WIRED_IPV6_ONLY TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wired-ipv6-only"
+
+static void
+test_read_wired_ipv6_only (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GError *error = NULL;
+	const char *tmp;
+	const char *expected_id = "System test-wired-ipv6-only";
+	const char *expected_address1 = "1001:abba::1234";
+	guint32 expected_prefix1 = 56;
+	const char *expected_dns1 = "1:2:3:4::a";
+	NMIP6Address *ip6_addr;
+	struct in6_addr addr;
+
+	connection = connection_from_file (TEST_IFCFG_WIRED_IPV6_ONLY,
+	                                   NULL,
+	                                   TYPE_ETHERNET,
+	                                   NULL,
+	                                   &unmanaged,
+	                                   &keyfile,
+	                                   &routefile,
+	                                   &route6file,
+	                                   &error,
+	                                   &ignore_error);
+	ASSERT (connection != NULL,
+	        "wired-ipv6-only-read", "failed to read %s: %s", TEST_IFCFG_WIRED_IPV6_ONLY, error->message);
+
+	ASSERT (nm_connection_verify (connection, &error),
+	        "wired-ipv6-only-verify", "failed to verify %s: %s", TEST_IFCFG_WIRED_IPV6_ONLY, error->message);
+
+	ASSERT (unmanaged == FALSE,
+	        "wired-ipv6-only-verify", "failed to verify %s: unexpected unmanaged value", TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	ASSERT (s_con != NULL,
+	        "wired-ipv6-only-verify-connection", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+
+	/* ID */
+	tmp = nm_setting_connection_get_id (s_con);
+	ASSERT (tmp != NULL,
+	        "wired-ipv6-only-verify-connection", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_CONNECTION_SETTING_NAME,
+	        NM_SETTING_CONNECTION_ID);
+	ASSERT (strcmp (tmp, expected_id) == 0,
+	        "wired-ipv6-only-verify-connection", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_CONNECTION_SETTING_NAME,
+	        NM_SETTING_CONNECTION_ID);
+
+	/* ===== WIRED SETTING ===== */
+
+	s_wired = NM_SETTING_WIRED (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED));
+	ASSERT (s_wired != NULL,
+	        "wired-ipv6-only-verify-wired", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_WIRED_SETTING_NAME);
+
+	/* ===== IPv4 SETTING ===== */
+
+	s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
+	ASSERT (s_ip4 == NULL,
+	        "wired-ipv6-only-verify-ip4", "failed to verify %s: unexpected %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP4_CONFIG_SETTING_NAME);
+
+	/* ===== IPv6 SETTING ===== */
+
+	s_ip6 = NM_SETTING_IP6_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG));
+	ASSERT (s_ip6 != NULL,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+
+	/* Method */
+	tmp = nm_setting_ip6_config_get_method (s_ip6);
+	ASSERT (strcmp (tmp, NM_SETTING_IP6_CONFIG_METHOD_MANUAL) == 0,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME,
+	        NM_SETTING_IP6_CONFIG_METHOD);
+
+	/* IP addresses */
+	ASSERT (nm_setting_ip6_config_get_num_addresses (s_ip6) == 1,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+		TEST_IFCFG_WIRED_IPV6_MANUAL,
+		NM_SETTING_IP6_CONFIG_SETTING_NAME,
+		NM_SETTING_IP6_CONFIG_ADDRESSES);
+
+	/* Address #1 */
+	ip6_addr = nm_setting_ip6_config_get_address (s_ip6, 0);
+	ASSERT (ip6_addr,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: missing IP6 address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	ASSERT (nm_ip6_address_get_prefix (ip6_addr) == expected_prefix1,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected IP6 address #1 prefix",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	ASSERT (inet_pton (AF_INET6, expected_address1, &addr) > 0,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: couldn't convert IP address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+	ASSERT (IN6_ARE_ADDR_EQUAL (nm_ip6_address_get_address (ip6_addr), &addr),
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected IP6 address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+
+	/* DNS Addresses */
+	ASSERT (nm_setting_ip6_config_get_num_dns (s_ip6) == 1,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME,
+	        NM_SETTING_IP6_CONFIG_DNS);
+
+	ASSERT (inet_pton (AF_INET6, expected_dns1, &addr) > 0,
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: couldn't convert DNS IP address #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL);
+	ASSERT (IN6_ARE_ADDR_EQUAL (nm_setting_ip6_config_get_dns (s_ip6, 0), &addr),
+		"wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value #1",
+		TEST_IFCFG_WIRED_IPV6_MANUAL,
+		NM_SETTING_IP6_CONFIG_SETTING_NAME,
+		NM_SETTING_IP6_CONFIG_DNS);
+
+	/* DNS domains - none as domains are stuffed to 'ipv4' setting */
+	ASSERT (nm_setting_ip6_config_get_num_dns_searches (s_ip6) == 0,
+	        "wired-ipv6-only-verify-ip6", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIRED_IPV6_MANUAL,
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME,
+	        NM_SETTING_IP6_CONFIG_DNS);
+
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+}
+
 #define TEST_IFCFG_ONBOOT_NO TEST_IFCFG_DIR"/network-scripts/ifcfg-test-onboot-no"
 
 static void
@@ -2855,6 +3004,7 @@ test_read_wifi_wep (void)
 	const char *expected_mode = "infrastructure";
 	const guint32 expected_channel = 1;
 	const char *expected_wep_key0 = "0123456789abcdef0123456789";
+	NMWepKeyType key_type;
 
 	connection = connection_from_file (TEST_IFCFG_WIFI_WEP,
 	                                   NULL,
@@ -3026,6 +3176,13 @@ test_read_wifi_wep (void)
 	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
 	        NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX);
 
+	/* WEP key type */
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	ASSERT (key_type == NM_WEP_KEY_TYPE_UNKNOWN || key_type == NM_WEP_KEY_TYPE_KEY,
+	        "wifi-wep-verify-wireless", "failed to verify %s: unexpected WEP key type %d",
+	        TEST_IFCFG_WIFI_WEP,
+	        key_type);
+
 	/* WEP key index 0 */
 	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 0);
 	ASSERT (tmp != NULL,
@@ -3359,6 +3516,142 @@ test_read_wifi_wep_adhoc (void)
 	g_object_unref (connection);
 }
 
+#define TEST_IFCFG_WIFI_WEP_PASSPHRASE TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-wep-passphrase"
+
+static void
+test_read_wifi_wep_passphrase (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wireless;
+	NMSettingWirelessSecurity *s_wsec;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GError *error = NULL;
+	const char *tmp;
+	const char *expected_wep_key0 = "foobar222blahblah";
+	NMWepKeyType key_type;
+
+	connection = connection_from_file (TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	                                   NULL,
+	                                   TYPE_WIRELESS,
+	                                   NULL,
+	                                   &unmanaged,
+	                                   &keyfile,
+	                                   &routefile,
+	                                   &route6file,
+	                                   &error,
+	                                   &ignore_error);
+	ASSERT (connection != NULL,
+	        "wifi-wep-passphrase-read", "failed to read %s: %s",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE, error->message);
+
+	ASSERT (nm_connection_verify (connection, &error),
+	        "wifi-wep-passphrase-verify", "failed to verify %s: %s",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE, error->message);
+
+	/* ===== CONNECTION SETTING ===== */
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	ASSERT (s_con != NULL,
+	        "wifi-wep-passphrase-verify-connection", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+
+	/* ===== WIRELESS SETTING ===== */
+
+	s_wireless = NM_SETTING_WIRELESS (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS));
+	ASSERT (s_wireless != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SETTING_NAME);
+
+	/* Security */
+	tmp = nm_setting_wireless_get_security (s_wireless);
+	ASSERT (tmp != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SEC);
+	ASSERT (strcmp (tmp, NM_SETTING_WIRELESS_SECURITY_SETTING_NAME) == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SEC);
+
+
+	/* ===== WIRELESS SECURITY SETTING ===== */
+
+	s_wsec = NM_SETTING_WIRELESS_SECURITY (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRELESS_SECURITY));
+	ASSERT (s_wsec != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+
+	/* Key management */
+	ASSERT (strcmp (nm_setting_wireless_security_get_key_mgmt (s_wsec), "none") == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_KEY_MGMT);
+
+	/* WEP key index */
+	ASSERT (nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec) == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX);
+
+	/* WEP key type */
+	key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+	ASSERT (key_type == NM_WEP_KEY_TYPE_PASSPHRASE,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected WEP key type %d",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        key_type);
+
+	/* WEP key index 0 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 0);
+	ASSERT (tmp != NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: missing %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY0);
+	ASSERT (strcmp (tmp, expected_wep_key0) == 0,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key value",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY0);
+
+	/* WEP key index 1 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 1);
+	ASSERT (tmp == NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY1);
+
+	/* WEP key index 2 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 2);
+	ASSERT (tmp == NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY2);
+
+	/* WEP key index 3 */
+	tmp = nm_setting_wireless_security_get_wep_key (s_wsec, 3);
+	ASSERT (tmp == NULL,
+	        "wifi-wep-passphrase-verify-wireless", "failed to verify %s: unexpected %s / %s key",
+	        TEST_IFCFG_WIFI_WEP_PASSPHRASE,
+	        NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	        NM_SETTING_WIRELESS_SECURITY_WEP_KEY3);
+
+	g_object_unref (connection);
+}
+
 #define TEST_IFCFG_WIFI_LEAP TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-leap"
 
 static void
@@ -5108,6 +5401,140 @@ test_write_wired_dhcp (void)
 	g_object_unref (reread);
 }
 
+static void
+test_write_wired_static_ip6_only (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP6Config *s_ip6;
+	static unsigned char tmpmac[] = { 0x31, 0x33, 0x33, 0x37, 0xbe, 0xcd };
+	GByteArray *mac;
+	char *uuid;
+	guint64 timestamp = 0x12344433L;
+	struct in6_addr ip6;
+	struct in6_addr dns6;
+	NMIP6Address *addr6;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+
+	inet_pton (AF_INET6, "1003:1234:abcd::1", &ip6);
+	inet_pton (AF_INET6, "fade:0102:0103::face", &dns6);
+
+	connection = nm_connection_new ();
+	ASSERT (connection != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new connection");
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	ASSERT (s_con != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new %s setting",
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wired Static IP6 Only",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_TIMESTAMP, timestamp,
+	              NULL);
+	g_free (uuid);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	ASSERT (s_wired != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new %s setting",
+	        NM_SETTING_WIRED_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	mac = g_byte_array_sized_new (sizeof (tmpmac));
+	g_byte_array_append (mac, &tmpmac[0], sizeof (tmpmac));
+	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, mac, NULL);
+	g_byte_array_free (mac, TRUE);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	ASSERT (s_ip6 != NULL,
+	        "wired-static-ip6-only-write", "failed to allocate new %s setting",
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_MANUAL,
+	              NULL);
+
+	/* Add addresses */
+	addr6 = nm_ip6_address_new ();
+	nm_ip6_address_set_address (addr6, &ip6);
+	nm_ip6_address_set_prefix (addr6, 11);
+	nm_setting_ip6_config_add_address (s_ip6, addr6);
+	nm_ip6_address_unref (addr6);
+
+	/* DNS server */
+	nm_setting_ip6_config_add_dns (s_ip6, &dns6);
+
+	ASSERT (nm_connection_verify (connection, &error) == TRUE,
+	        "wired-static-ip6-only-write", "failed to verify connection: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	ASSERT (success == TRUE,
+	        "wired-static-ip6-only-write", "failed to write connection to disk: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	ASSERT (testfile != NULL,
+	        "wired-static-ip6-only-write", "didn't get ifcfg file path back after writing connection");
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_ETHERNET,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	ASSERT (reread != NULL,
+	        "wired-static-ip6-only-write-reread", "failed to read %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_verify (reread, &error),
+	        "wired-static-ip6-only-write-reread-verify", "failed to verify %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_get_setting (reread, NM_TYPE_SETTING_IP4_CONFIG) == NULL,
+	        "wired-static-ip6-only-write-reread-verify", "unexpected IPv4 setting");
+
+	ASSERT (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT) == TRUE,
+	        "wired-static-ip6-only-write", "written and re-read connection weren't the same.");
+
+	if (route6file)
+		unlink (route6file);
+
+	g_free (testfile);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
+
 #define TEST_IFCFG_READ_WRITE_STATIC_ROUTES_LEGACY TEST_IFCFG_DIR"/network-scripts/ifcfg-test-static-routes-legacy"
 
 static void
@@ -6137,6 +6564,155 @@ test_write_wifi_wep_adhoc (void)
 }
 
 static void
+test_write_wifi_wep_passphrase (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingWireless *s_wifi;
+	NMSettingWirelessSecurity *s_wsec;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	char *uuid;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GByteArray *ssid;
+	const unsigned char ssid_data[] = "blahblah";
+	struct stat statbuf;
+
+	connection = nm_connection_new ();
+	ASSERT (connection != NULL,
+	        "wifi-wep-passphrase-write", "failed to allocate new connection");
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	ASSERT (s_con != NULL,
+	        "wifi-wep-passphrase-write", "failed to allocate new %s setting",
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Wifi WEP Passphrase",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRELESS_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Wifi setting */
+	s_wifi = (NMSettingWireless *) nm_setting_wireless_new ();
+	ASSERT (s_wifi != NULL,
+	        "wifi-wep-passphrase-write", "failed to allocate new %s setting",
+	        NM_SETTING_WIRELESS_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wifi));
+
+	ssid = g_byte_array_sized_new (sizeof (ssid_data));
+	g_byte_array_append (ssid, ssid_data, sizeof (ssid_data));
+
+	g_object_set (s_wifi,
+	              NM_SETTING_WIRELESS_SSID, ssid,
+	              NM_SETTING_WIRELESS_MODE, "infrastructure",
+	              NM_SETTING_WIRELESS_SEC, NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
+	              NULL);
+
+	g_byte_array_free (ssid, TRUE);
+
+	/* Wireless security setting */
+	s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
+	ASSERT (s_wsec != NULL,
+			"wifi-wep-passphrase-write", "failed to allocate new %s setting",
+			NM_SETTING_WIRELESS_SECURITY_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wsec));
+
+	g_object_set (s_wsec,
+	              NM_SETTING_WIRELESS_SECURITY_KEY_MGMT, "none",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX, 0,
+	              NM_SETTING_WIRELESS_SECURITY_AUTH_ALG, "shared",
+	              NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE, NM_WEP_KEY_TYPE_PASSPHRASE,
+	              NULL);
+	nm_setting_wireless_security_set_wep_key (s_wsec, 0, "asdfdjaslfjasd;flasjdfl;aksdf");
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+	ASSERT (s_ip4 != NULL,
+			"wifi-wep-passphrase-write", "failed to allocate new %s setting",
+			NM_SETTING_IP4_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	ASSERT (s_ip6 != NULL,
+	        "wifi-wep-adhoc-write", "failed to allocate new %s setting",
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE, NULL);
+
+	ASSERT (nm_connection_verify (connection, &error) == TRUE,
+	        "wifi-wep-passphrase-write", "failed to verify connection: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	ASSERT (success == TRUE,
+	        "wifi-wep-passphrase-write", "failed to write connection to disk: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	ASSERT (testfile != NULL,
+	        "wifi-wep-passphrase-write", "didn't get ifcfg file path back after writing connection");
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_WIRELESS,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	ASSERT (keyfile != NULL,
+	        "wifi-wep-passphrase-write-reread", "expected keyfile for '%s'", testfile);
+
+	ASSERT (stat (keyfile, &statbuf) == 0,
+	        "wifi-wep-passphrase-write-reread", "couldn't stat() '%s'", keyfile);
+	ASSERT (S_ISREG (statbuf.st_mode),
+	        "wifi-wep-passphrase-write-reread", "keyfile '%s' wasn't a normal file", keyfile);
+	ASSERT ((statbuf.st_mode & 0077) == 0,
+	        "wifi-wep-passphrase-write-reread", "keyfile '%s' wasn't readable only by its owner", keyfile);
+
+	unlink (keyfile);
+
+	ASSERT (reread != NULL,
+	        "wifi-wep-passphrase-write-reread", "failed to read %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_verify (reread, &error),
+	        "wifi-wep-passphrase-write-reread-verify", "failed to verify %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT) == TRUE,
+	        "wifi-wep-passphrase-write", "written and re-read connection weren't the same.");
+
+	g_free (testfile);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
+static void
 test_write_wifi_leap (void)
 {
 	NMConnection *connection;
@@ -7813,6 +8389,7 @@ int main (int argc, char **argv)
 	test_read_wired_static_routes ();
 	test_read_wired_static_routes_legacy ();
 	test_read_wired_ipv6_manual ();
+	test_read_wired_ipv6_only ();
 	test_read_onboot_no ();
 	test_read_wired_8021x_peap_mschapv2 ();
 	test_read_wifi_open ();
@@ -7824,6 +8401,7 @@ int main (int argc, char **argv)
 	test_read_wifi_open_ssid_quoted ();
 	test_read_wifi_wep ();
 	test_read_wifi_wep_adhoc ();
+	test_read_wifi_wep_passphrase ();
 	test_read_wifi_leap ();
 	test_read_wifi_wpa_psk ();
 	test_read_wifi_wpa_psk_unquoted ();
@@ -7835,6 +8413,7 @@ int main (int argc, char **argv)
 	test_read_wifi_wep_eap_ttls_chap ();
 
 	test_write_wired_static ();
+	test_write_wired_static_ip6_only ();
 	test_write_wired_static_routes ();
 	test_read_write_static_routes_legacy ();
 	test_write_wired_dhcp ();
@@ -7843,6 +8422,7 @@ int main (int argc, char **argv)
 	test_write_wifi_open_hex_ssid ();
 	test_write_wifi_wep ();
 	test_write_wifi_wep_adhoc ();
+	test_write_wifi_wep_passphrase ();
 	test_write_wifi_leap ();
 	test_write_wifi_wpa_psk ("Test Write Wifi WPA PSK",
 	                         "wifi-wpa-psk-write",
diff --git a/system-settings/plugins/ifcfg-rh/writer.c b/system-settings/plugins/ifcfg-rh/writer.c
index 4ded5c6..d8df2d3 100644
--- a/system-settings/plugins/ifcfg-rh/writer.c
+++ b/system-settings/plugins/ifcfg-rh/writer.c
@@ -15,7 +15,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * Copyright (C) 2009 Red Hat, Inc.
+ * Copyright (C) 2009 - 2010 Red Hat, Inc.
  */
 
 #include <ctype.h>
@@ -579,20 +579,46 @@ write_wireless_security_setting (NMConnection *connection,
 		}
 	}
 
+	/* WEP keys */
+
+	/* Clear existing keys */
+	set_secret (ifcfg, "KEY", NULL, FALSE); /* Clear any default key */
+	for (i = 0; i < 4; i++) {
+		tmp = g_strdup_printf ("KEY_PASSPHRASE%d", i + 1);
+		set_secret (ifcfg, tmp, NULL, FALSE);
+		g_free (tmp);
+
+		tmp = g_strdup_printf ("KEY%d", i + 1);
+		set_secret (ifcfg, tmp, NULL, FALSE);
+		g_free (tmp);
+	}
+
+	/* And write the new ones out */
 	if (wep) {
 		/* Default WEP TX key index */
 		tmp = g_strdup_printf ("%d", nm_setting_wireless_security_get_wep_tx_keyidx (s_wsec) + 1);
 		svSetValue (ifcfg, "DEFAULTKEY", tmp, FALSE);
 		g_free (tmp);
-	}
 
-	/* WEP keys */
-	set_secret (ifcfg, "KEY", NULL, FALSE); /* Clear any default key */
-	for (i = 0; i < 4; i++) {
-		key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
-		tmp = g_strdup_printf ("KEY%d", i + 1);
-		set_secret (ifcfg, tmp, (wep && key) ? key : NULL, FALSE);
-		g_free (tmp);
+		for (i = 0; i < 4; i++) {
+			NMWepKeyType key_type;
+
+			key = nm_setting_wireless_security_get_wep_key (s_wsec, i);
+			if (key) {
+				/* Passphrase needs a different ifcfg key since with WEP, there
+				 * are some passphrases that are indistinguishable from WEP hex
+				 * keys.
+				 */
+				key_type = nm_setting_wireless_security_get_wep_key_type (s_wsec);
+				if (key_type == NM_WEP_KEY_TYPE_PASSPHRASE)
+					tmp = g_strdup_printf ("KEY_PASSPHRASE%d", i + 1);
+				else
+					tmp = g_strdup_printf ("KEY%d", i + 1);
+
+				set_secret (ifcfg, tmp, key, FALSE);
+				g_free (tmp);
+			}
+		}
 	}
 
 	/* WPA protos */
@@ -807,6 +833,7 @@ write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 		g_free (tmp);
 	}
 
+	svSetValue (ifcfg, "MTU", NULL, FALSE);
 	mtu = nm_setting_wired_get_mtu (s_wired);
 	if (mtu) {
 		tmp = g_strdup_printf ("%u", mtu);
@@ -910,9 +937,30 @@ write_ip4_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 
 	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
 	if (!s_ip4) {
-		g_set_error (error, ifcfg_plugin_error_quark (), 0,
-		             "Missing '%s' setting", NM_SETTING_IP4_CONFIG_SETTING_NAME);
-		return FALSE;
+		int result;
+
+		/* IPv4 disabled, clear IPv4 related parameters */
+		svSetValue (ifcfg, "BOOTPROTO", NULL, FALSE);
+		for (i = 0; i < 254; i++) {
+			if (i == 0) {
+				addr_key = g_strdup ("IPADDR");
+				prefix_key = g_strdup ("PREFIX");
+				gw_key = g_strdup ("GATEWAY");
+			} else {
+				addr_key = g_strdup_printf ("IPADDR%d", i + 1);
+				prefix_key = g_strdup_printf ("PREFIX%d", i + 1);
+				gw_key = g_strdup_printf ("GATEWAY%d", i + 1);
+			}
+
+			svSetValue (ifcfg, addr_key, NULL, FALSE);
+			svSetValue (ifcfg, prefix_key, NULL, FALSE);
+			svSetValue (ifcfg, gw_key, NULL, FALSE);
+		}
+
+		route_path = utils_get_route_path (ifcfg->fileName);
+		result = unlink (route_path);
+		g_free (route_path);
+		return TRUE;
 	}
 
 	value = nm_setting_ip4_config_get_method (s_ip4);
@@ -1205,18 +1253,27 @@ write_ip6_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 	g_assert (value);
 	if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
 		svSetValue (ifcfg, "IPV6INIT", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 		return TRUE;
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_AUTO)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
 		svSetValue (ifcfg, "IPV6_AUTOCONF", "yes", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
+	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
+		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
+		svSetValue (ifcfg, "IPV6_AUTOCONF", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", "yes", FALSE);
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_MANUAL)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
 		svSetValue (ifcfg, "IPV6_AUTOCONF", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
 		svSetValue (ifcfg, "IPV6_AUTOCONF", "no", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 	} else if (!strcmp (value, NM_SETTING_IP6_CONFIG_METHOD_SHARED)) {
 		svSetValue (ifcfg, "IPV6INIT", "yes", FALSE);
+		svSetValue (ifcfg, "DHCPV6C", NULL, FALSE);
 		/* TODO */
 	}
 
diff --git a/system-settings/plugins/ifupdown/plugin.c b/system-settings/plugins/ifupdown/plugin.c
index d725bd9..e2358b9 100644
--- a/system-settings/plugins/ifupdown/plugin.c
+++ b/system-settings/plugins/ifupdown/plugin.c
@@ -59,7 +59,9 @@
 #define IFUPDOWN_PLUGIN_INFO "(C) 2008 Canonical Ltd.  To report bugs please use the NetworkManager mailing list."
 #define IFUPDOWN_SYSTEM_HOSTNAME_FILE "/etc/hostname"
 
-#define IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
+#define IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE SYSCONFDIR "/NetworkManager/NetworkManager.conf"
+#define IFUPDOWN_OLD_SYSTEM_SETTINGS_KEY_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
+
 #define IFUPDOWN_KEY_FILE_GROUP "ifupdown"
 #define IFUPDOWN_KEY_FILE_KEY_MANAGED "managed"
 #define IFUPDOWN_UNMANAGE_WELL_KNOWN_DEFAULT TRUE
@@ -78,6 +80,7 @@ typedef struct {
 	GHashTable *well_known_interfaces;
 	GHashTable *well_known_ifaces;
 	gboolean unmanage_well_known;
+	const char *conf_file;
 
 	gulong inotify_event_id;
 	int inotify_system_hostname_wd;
@@ -403,13 +406,19 @@ SCPluginIfupdown_init (NMSystemConfigInterface *config)
 	g_list_free (keys);
 	g_hash_table_destroy (auto_ifaces);
 
+	/* Find the config file */
+	if (g_file_test (IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE, G_FILE_TEST_EXISTS))
+		priv->conf_file = IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE;
+	else
+		priv->conf_file = IFUPDOWN_OLD_SYSTEM_SETTINGS_KEY_FILE;
+
 	keyfile = g_key_file_new ();
 	if (!g_key_file_load_from_file (keyfile,
-	                                IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE,
+	                                priv->conf_file,
 	                                G_KEY_FILE_NONE,
 	                                &error)) {
 		nm_info ("loading system config file (%s) caused error: (%d) %s",
-		         IFUPDOWN_SYSTEM_SETTINGS_KEY_FILE,
+		         priv->conf_file,
 		         error ? error->code : -1,
 		         error && error->message ? error->message : "(unknown)");
 	} else {
diff --git a/system-settings/plugins/keyfile/nm-keyfile-connection.c b/system-settings/plugins/keyfile/nm-keyfile-connection.c
index b64c2f9..ed56d69 100644
--- a/system-settings/plugins/keyfile/nm-keyfile-connection.c
+++ b/system-settings/plugins/keyfile/nm-keyfile-connection.c
@@ -88,7 +88,8 @@ update (NMSettingsConnectionInterface *connection,
 		success = parent_settings_connection_iface->update (connection, callback, user_data);
 	} else {
 		callback (connection, error, user_data);
-		g_error_free (error);
+		if (error)
+			g_error_free (error);
 		g_free (filename);
 	}
 
diff --git a/system-settings/plugins/keyfile/plugin.c b/system-settings/plugins/keyfile/plugin.c
index 40f0960..36f47cc 100644
--- a/system-settings/plugins/keyfile/plugin.c
+++ b/system-settings/plugins/keyfile/plugin.c
@@ -42,7 +42,8 @@
 #define KEYFILE_PLUGIN_NAME "keyfile"
 #define KEYFILE_PLUGIN_INFO "(c) 2007 - 2008 Red Hat, Inc.  To report bugs please use the NetworkManager mailing list."
 
-#define CONF_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
+#define CONF_FILE SYSCONFDIR "/NetworkManager/NetworkManager.conf"
+#define OLD_CONF_FILE SYSCONFDIR "/NetworkManager/nm-system-settings.conf"
 
 static char *plugin_get_hostname (SCPluginKeyfile *plugin);
 static void system_config_interface_init (NMSystemConfigInterface *system_config_interface_class);
@@ -59,6 +60,7 @@ typedef struct {
 	GFileMonitor *monitor;
 	guint monitor_id;
 
+	const char *conf_file;
 	GFileMonitor *conf_file_monitor;
 	guint conf_file_monitor_id;
 
@@ -297,7 +299,7 @@ setup_monitoring (NMSystemConfigInterface *config)
 		priv->monitor = monitor;
 	}
 
-	file = g_file_new_for_path (CONF_FILE);
+	file = g_file_new_for_path (priv->conf_file);
 	monitor = g_file_monitor_file (file, G_FILE_MONITOR_NONE, NULL, NULL);
 	g_object_unref (file);
 
@@ -344,12 +346,13 @@ add_connection (NMSystemConfigInterface *config,
 static GSList *
 get_unmanaged_specs (NMSystemConfigInterface *config)
 {
+	SCPluginKeyfilePrivate *priv = SC_PLUGIN_KEYFILE_GET_PRIVATE (config);
 	GKeyFile *key_file;
 	GSList *specs = NULL;
 	GError *error = NULL;
 
 	key_file = g_key_file_new ();
-	if (g_key_file_load_from_file (key_file, CONF_FILE, G_KEY_FILE_NONE, &error)) {
+	if (g_key_file_load_from_file (key_file, priv->conf_file, G_KEY_FILE_NONE, &error)) {
 		char *str;
 
 		str = g_key_file_get_value (key_file, "keyfile", "unmanaged-devices", NULL);
@@ -366,7 +369,7 @@ get_unmanaged_specs (NMSystemConfigInterface *config)
 			g_free (udis); /* Yes, g_free, not g_strfreev because we need the strings in the list */
 		}
 	} else {
-		g_warning ("Error parsing file '%s': %s", CONF_FILE, error->message);
+		g_warning ("Error parsing file '%s': %s", priv->conf_file, error->message);
 		g_error_free (error);
 	}
 
@@ -378,15 +381,16 @@ get_unmanaged_specs (NMSystemConfigInterface *config)
 static char *
 plugin_get_hostname (SCPluginKeyfile *plugin)
 {
+	SCPluginKeyfilePrivate *priv = SC_PLUGIN_KEYFILE_GET_PRIVATE (plugin);
 	GKeyFile *key_file;
 	char *hostname = NULL;
 	GError *error = NULL;
 
 	key_file = g_key_file_new ();
-	if (g_key_file_load_from_file (key_file, CONF_FILE, G_KEY_FILE_NONE, &error))
+	if (g_key_file_load_from_file (key_file, priv->conf_file, G_KEY_FILE_NONE, &error))
 		hostname = g_key_file_get_value (key_file, "keyfile", "hostname", NULL);
 	else {
-		g_warning ("Error parsing file '%s': %s", CONF_FILE, error->message);
+		g_warning ("Error parsing file '%s': %s", priv->conf_file, error->message);
 		g_error_free (error);
 	}
 
@@ -404,7 +408,7 @@ plugin_set_hostname (SCPluginKeyfile *plugin, const char *hostname)
 	gboolean result = FALSE;
 
 	key_file = g_key_file_new ();
-	if (g_key_file_load_from_file (key_file, CONF_FILE, G_KEY_FILE_NONE, &error)) {
+	if (g_key_file_load_from_file (key_file, priv->conf_file, G_KEY_FILE_NONE, &error)) {
 		char *data;
 		gsize len;
 
@@ -412,7 +416,7 @@ plugin_set_hostname (SCPluginKeyfile *plugin, const char *hostname)
 
 		data = g_key_file_to_data (key_file, &len, &error);
 		if (data) {
-			g_file_set_contents (CONF_FILE, data, len, &error);
+			g_file_set_contents (priv->conf_file, data, len, &error);
 			g_free (data);
 
 			g_free (priv->hostname);
@@ -425,7 +429,7 @@ plugin_set_hostname (SCPluginKeyfile *plugin, const char *hostname)
 			g_error_free (error);
 		}
 	} else {
-		g_warning ("Error parsing file '%s': %s", CONF_FILE, error->message);
+		g_warning ("Error parsing file '%s': %s", priv->conf_file, error->message);
 		g_error_free (error);
 	}
 
@@ -441,6 +445,11 @@ sc_plugin_keyfile_init (SCPluginKeyfile *plugin)
 {
 	SCPluginKeyfilePrivate *priv = SC_PLUGIN_KEYFILE_GET_PRIVATE (plugin);
 
+	if (g_file_test (CONF_FILE, G_FILE_TEST_EXISTS))
+		priv->conf_file = CONF_FILE;
+	else
+		priv->conf_file = OLD_CONF_FILE;
+
 	priv->hostname = plugin_get_hostname (plugin);
 }
 
diff --git a/test/Makefile.am b/test/Makefile.am
index 9a07f91..8e235e4 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -28,6 +28,9 @@ nm_online_LDADD = \
 	$(GLIB_LIBS)
 
 libnm_glib_test_SOURCES = libnm-glib-test.c
+libnm_glib_test_CFLAGS = \
+	-Wno-deprecated-declarations \
+	-Wno-deprecated
 libnm_glib_test_LDADD = \
 	$(top_builddir)/libnm-glib/libnm-glib.la \
 	$(top_builddir)/libnm-util/libnm-util.la \
