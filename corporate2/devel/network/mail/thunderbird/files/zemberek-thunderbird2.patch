diff -Naur mozilla-orig/extensions/spellcheck/Makefile.in mozilla/extensions/spellcheck/Makefile.in
--- mozilla-orig/extensions/spellcheck/Makefile.in	2008-06-12 23:17:58.000000000 +0300
+++ mozilla/extensions/spellcheck/Makefile.in	2008-06-12 23:18:50.000000000 +0300
@@ -47,7 +47,7 @@
 ifneq (,$(filter cocoa,$(MOZ_WIDGET_TOOLKIT)))
 DIRS		+= osxspell
 else
-DIRS		+= myspell
+DIRS		+= myspell zemberek
 endif
 
 include $(topsrcdir)/config/rules.mk
diff -Naur mozilla-orig/extensions/spellcheck/src/mozSpellChecker.cpp mozilla/extensions/spellcheck/src/mozSpellChecker.cpp
--- mozilla-orig/extensions/spellcheck/src/mozSpellChecker.cpp	2008-06-12 23:17:58.000000000 +0300
+++ mozilla/extensions/spellcheck/src/mozSpellChecker.cpp	2008-06-12 23:18:50.000000000 +0300
@@ -40,6 +40,7 @@
 #include "nsIServiceManager.h"
 #include "mozISpellI18NManager.h"
 #include "nsIStringEnumerator.h"
+#include "nsStringAPI.h"
 
 #define UNREASONABLE_WORD_LENGTH 64
 
@@ -65,7 +66,7 @@
   mPersonalDictionary = do_GetService("@mozilla.org/spellchecker/personaldictionary;1");
 
   nsresult rv;
-  mSpellCheckingEngine = do_GetService("@mozilla.org/spellchecker/myspell;1",&rv);
+  mSpellCheckingEngine = do_GetService("@mozilla.org/spellchecker/zemberek;1",&rv);
   if (NS_FAILED(rv)) {
     return rv;
   }
@@ -334,6 +335,18 @@
 {
   if(!mSpellCheckingEngine)
     return NS_ERROR_NULL_POINTER;
+
+  nsresult  rv;
+
+  if (aDictionary.Equals(NS_LITERAL_STRING("tr-TR").get()))
+  {
+    mSpellCheckingEngine = do_GetService("@mozilla.org/spellchecker/zemberek;1",&rv);
+  }
+  else
+  {
+    mSpellCheckingEngine = do_GetService("@mozilla.org/spellchecker/myspell;1",&rv);
+  }
+  mSpellCheckingEngine->SetPersonalDictionary(mPersonalDictionary);
  
   nsresult res;
   res = mSpellCheckingEngine->SetDictionary(PromiseFlatString(aDictionary).get());
diff -Naur mozilla-orig/extensions/spellcheck/src/mozSpellChecker.cpp.orig mozilla/extensions/spellcheck/src/mozSpellChecker.cpp.orig
--- mozilla-orig/extensions/spellcheck/src/mozSpellChecker.cpp.orig	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/src/mozSpellChecker.cpp.orig	2007-09-06 09:01:36.000000000 +0300
@@ -0,0 +1,431 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Spellchecker Component.
+ *
+ * The Initial Developer of the Original Code is
+ * David Einstein.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): David Einstein Deinst@world.std.com
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "mozSpellChecker.h"
+#include "nsIServiceManager.h"
+#include "mozISpellI18NManager.h"
+#include "nsIStringEnumerator.h"
+
+#define UNREASONABLE_WORD_LENGTH 64
+
+NS_IMPL_ISUPPORTS1(mozSpellChecker, nsISpellChecker)
+
+mozSpellChecker::mozSpellChecker()
+{
+}
+
+mozSpellChecker::~mozSpellChecker()
+{
+  if(mPersonalDictionary){
+    //    mPersonalDictionary->Save();
+    mPersonalDictionary->EndSession();
+  }
+  mSpellCheckingEngine = nsnull;
+  mPersonalDictionary = nsnull;
+}
+
+nsresult 
+mozSpellChecker::Init()
+{
+  mPersonalDictionary = do_GetService("@mozilla.org/spellchecker/personaldictionary;1");
+
+  nsresult rv;
+  mSpellCheckingEngine = do_GetService("@mozilla.org/spellchecker/myspell;1",&rv);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  mSpellCheckingEngine->SetPersonalDictionary(mPersonalDictionary);
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::SetDocument(nsITextServicesDocument *aDoc, PRBool aFromStartofDoc)
+{
+  mTsDoc = aDoc;
+  mFromStart = aFromStartofDoc;
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP 
+mozSpellChecker::NextMisspelledWord(nsAString &aWord, nsStringArray *aSuggestions)
+{
+  if(!aSuggestions||!mConverter)
+    return NS_ERROR_NULL_POINTER;
+
+  PRUint32 selOffset;
+  PRInt32 begin,end;
+  nsresult result;
+  result = SetupDoc(&selOffset);
+  PRBool isMisspelled,done;
+  if (NS_FAILED(result))
+    return result;
+
+  while( NS_SUCCEEDED(mTsDoc->IsDone(&done)) && !done )
+    {
+      nsString str;
+      result = mTsDoc->GetCurrentTextBlock(&str);
+  
+      if (NS_FAILED(result))
+        return result;
+      do{
+        result = mConverter->FindNextWord(str.get(),str.Length(),selOffset,&begin,&end);
+        if(NS_SUCCEEDED(result)&&(begin != -1)){
+          const nsAString &currWord = Substring(str, begin, end - begin);
+          result = CheckWord(currWord, &isMisspelled, aSuggestions);
+          if(isMisspelled){
+            aWord = currWord;
+            mTsDoc->SetSelection(begin, end-begin);
+            mTsDoc->ScrollSelectionIntoView();
+            return NS_OK;
+          }
+        }
+        selOffset = end;
+      }while(end != -1);
+      mTsDoc->NextBlock();
+      selOffset=0;
+    }
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::CheckWord(const nsAString &aWord, PRBool *aIsMisspelled, nsStringArray *aSuggestions)
+{
+  nsresult result;
+  PRBool correct;
+  if(!mSpellCheckingEngine)
+    return NS_ERROR_NULL_POINTER;
+
+  // don't bother to check crazy words, also, myspell gets unhappy if you
+  // give it too much data and crashes sometimes
+  if (aWord.Length() > UNREASONABLE_WORD_LENGTH) {
+    *aIsMisspelled = PR_TRUE;
+    return NS_OK;
+  }
+
+  *aIsMisspelled = PR_FALSE;
+  result = mSpellCheckingEngine->Check(PromiseFlatString(aWord).get(), &correct);
+  NS_ENSURE_SUCCESS(result, result);
+  if(!correct){
+    if(aSuggestions){
+      PRUint32 count,i;
+      PRUnichar **words;
+      
+      result = mSpellCheckingEngine->Suggest(PromiseFlatString(aWord).get(), &words, &count);
+      NS_ENSURE_SUCCESS(result, result); 
+      for(i=0;i<count;i++){
+        aSuggestions->AppendString(nsDependentString(words[i]));
+      }
+      
+      if (count)
+        NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(count, words);
+    }
+    if(aIsMisspelled){
+      *aIsMisspelled = PR_TRUE;
+    }
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::Replace(const nsAString &aOldWord, const nsAString &aNewWord, PRBool aAllOccurrences)
+{
+  if(!mConverter)
+    return NS_ERROR_NULL_POINTER;
+
+  nsAutoString newWord(aNewWord); // sigh
+
+  if(aAllOccurrences){
+    PRUint32 selOffset;
+    PRInt32 startBlock,currentBlock,currOffset;
+    PRInt32 begin,end;
+    PRBool done;
+    nsresult result;
+    nsAutoString str;
+
+    // find out where we are
+    result = SetupDoc(&selOffset);
+    if(NS_FAILED(result))
+      return result;
+    result = GetCurrentBlockIndex(mTsDoc,&startBlock);
+    if(NS_FAILED(result))
+      return result;
+
+    //start at the beginning
+    result = mTsDoc->FirstBlock();
+    currOffset=0;
+    currentBlock = 0;
+    while( NS_SUCCEEDED(mTsDoc->IsDone(&done)) && !done )
+      {
+        result = mTsDoc->GetCurrentTextBlock(&str);
+        do{
+          result = mConverter->FindNextWord(str.get(),str.Length(),currOffset,&begin,&end);
+          if(NS_SUCCEEDED(result)&&(begin != -1)){
+            if (aOldWord.Equals(Substring(str, begin, end-begin))) {
+              // if we are before the current selection point but in the same block
+              // move the selection point forwards
+              if((currentBlock == startBlock)&&(begin < (PRInt32) selOffset)){
+                selOffset += (aNewWord.Length() - aOldWord.Length());
+                if(selOffset < 0) selOffset=0;
+              }
+              mTsDoc->SetSelection(begin, end-begin);
+              mTsDoc->InsertText(&newWord);
+              mTsDoc->GetCurrentTextBlock(&str);
+              end += (aNewWord.Length() - aOldWord.Length());  // recursion was cute in GEB, not here.
+            }
+          }
+          currOffset = end;
+        }while(currOffset != -1);
+        mTsDoc->NextBlock();
+        currentBlock++;
+        currOffset=0;          
+      }
+
+    // We are done replacing.  Put the selection point back where we found  it (or equivalent);
+    result = mTsDoc->FirstBlock();
+    currentBlock = 0;
+    while(( NS_SUCCEEDED(mTsDoc->IsDone(&done)) && !done ) &&(currentBlock < startBlock)){
+      mTsDoc->NextBlock();
+    }
+
+//After we have moved to the block where the first occurance of replace was done, put the 
+//selection to the next word following it. In case there is no word following it i.e if it happens
+//to be the last word in that block, then move to the next block and put the selection to the 
+//first word in that block, otherwise when the Setupdoc() is called, it queries the LastSelectedBlock()
+//and the selection offset of the last occurance of the replaced word is taken instead of the first 
+//occurance and things get messed up as reported in the bug 244969
+
+    if( NS_SUCCEEDED(mTsDoc->IsDone(&done)) && !done ){
+      nsString str;                                
+      result = mTsDoc->GetCurrentTextBlock(&str);  
+      result = mConverter->FindNextWord(str.get(),str.Length(),selOffset,&begin,&end);
+            if(end == -1)
+             {
+                mTsDoc->NextBlock();
+                selOffset=0;
+                result = mTsDoc->GetCurrentTextBlock(&str); 
+                result = mConverter->FindNextWord(str.get(),str.Length(),selOffset,&begin,&end);
+                mTsDoc->SetSelection(begin, 0);
+             }
+         else
+                mTsDoc->SetSelection(begin, 0);
+    }
+ }
+  else{
+    mTsDoc->InsertText(&newWord);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::IgnoreAll(const nsAString &aWord)
+{
+  if(mPersonalDictionary){
+    mPersonalDictionary->IgnoreWord(PromiseFlatString(aWord).get());
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::AddWordToPersonalDictionary(const nsAString &aWord)
+{
+  nsresult res;
+  PRUnichar empty=0;
+  if (!mPersonalDictionary)
+    return NS_ERROR_NULL_POINTER;
+  res = mPersonalDictionary->AddWord(PromiseFlatString(aWord).get(),&empty);
+  return res;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::RemoveWordFromPersonalDictionary(const nsAString &aWord)
+{
+  nsresult res;
+  PRUnichar empty=0;
+  if (!mPersonalDictionary)
+    return NS_ERROR_NULL_POINTER;
+  res = mPersonalDictionary->RemoveWord(PromiseFlatString(aWord).get(),&empty);
+  return res;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::GetPersonalDictionary(nsStringArray *aWordList)
+{
+  if(!aWordList || !mPersonalDictionary)
+    return NS_ERROR_NULL_POINTER;
+
+  nsCOMPtr<nsIStringEnumerator> words;
+  mPersonalDictionary->GetWordList(getter_AddRefs(words));
+  
+  PRBool hasMore;
+  nsAutoString word;
+  while (NS_SUCCEEDED(words->HasMore(&hasMore)) && hasMore) {
+    words->GetNext(word);
+    aWordList->AppendString(word);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::GetDictionaryList(nsStringArray *aDictionaryList)
+{
+  nsAutoString temp;
+  PRUint32 count,i;
+  PRUnichar **words;
+  
+  if(!aDictionaryList || !mSpellCheckingEngine)
+    return NS_ERROR_NULL_POINTER;
+  mSpellCheckingEngine->GetDictionaryList(&words,&count);
+  for(i=0;i<count;i++){
+    temp.Assign(words[i]);
+    aDictionaryList->AppendString(temp);
+  }
+  NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(count, words);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::GetCurrentDictionary(nsAString &aDictionary)
+{
+  nsXPIDLString dictname;
+  mSpellCheckingEngine->GetDictionary(getter_Copies(dictname));
+  aDictionary = dictname;
+  return NS_OK;
+}
+
+NS_IMETHODIMP 
+mozSpellChecker::SetCurrentDictionary(const nsAString &aDictionary)
+{
+  if(!mSpellCheckingEngine)
+    return NS_ERROR_NULL_POINTER;
+ 
+  nsresult res;
+  res = mSpellCheckingEngine->SetDictionary(PromiseFlatString(aDictionary).get());
+  if(NS_FAILED(res)){
+    NS_WARNING("Dictionary load failed");
+    return res;
+  }
+  nsXPIDLString language;
+  
+  nsCOMPtr<mozISpellI18NManager> serv(do_GetService("@mozilla.org/spellchecker/i18nmanager;1", &res));
+  if(serv && NS_SUCCEEDED(res)){
+    res = serv->GetUtil(language.get(),getter_AddRefs(mConverter));
+  }
+  return res;
+}
+
+nsresult
+mozSpellChecker::SetupDoc(PRUint32 *outBlockOffset)
+{
+  nsresult  rv;
+
+  nsITextServicesDocument::TSDBlockSelectionStatus blockStatus;
+  PRInt32 selOffset;
+  PRInt32 selLength;
+  *outBlockOffset = 0;
+
+  if (!mFromStart) 
+  {
+    rv = mTsDoc->LastSelectedBlock(&blockStatus, &selOffset, &selLength);
+    if (NS_SUCCEEDED(rv) && (blockStatus != nsITextServicesDocument::eBlockNotFound))
+    {
+      switch (blockStatus)
+      {
+        case nsITextServicesDocument::eBlockOutside:  // No TB in S, but found one before/after S.
+        case nsITextServicesDocument::eBlockPartial:  // S begins or ends in TB but extends outside of TB.
+          // the TS doc points to the block we want.
+          *outBlockOffset = selOffset + selLength;
+          break;
+                    
+        case nsITextServicesDocument::eBlockInside:  // S extends beyond the start and end of TB.
+          // we want the block after this one.
+          rv = mTsDoc->NextBlock();
+          *outBlockOffset = 0;
+          break;
+                
+        case nsITextServicesDocument::eBlockContains: // TB contains entire S.
+          *outBlockOffset = selOffset + selLength;
+          break;
+        
+        case nsITextServicesDocument::eBlockNotFound: // There is no text block (TB) in or before the selection (S).
+        default:
+          NS_NOTREACHED("Shouldn't ever get this status");
+      }
+    }
+    else  //failed to get last sel block. Just start at beginning
+    {
+      rv = mTsDoc->FirstBlock();
+      *outBlockOffset = 0;
+    }
+  
+  }
+  else // we want the first block
+  {
+    rv = mTsDoc->FirstBlock();
+    mFromStart = PR_FALSE;
+  }
+  return rv;
+}
+
+
+// utility method to discover which block we're in. The TSDoc interface doesn't give
+// us this, because it can't assume a read-only document.
+// shamelessly stolen from nsTextServicesDocument
+nsresult
+mozSpellChecker::GetCurrentBlockIndex(nsITextServicesDocument *aDoc, PRInt32 *outBlockIndex)
+{
+  PRInt32  blockIndex = 0;
+  PRBool   isDone = PR_FALSE;
+  nsresult result = NS_OK;
+
+  do
+  {
+    aDoc->PrevBlock();
+
+    result = aDoc->IsDone(&isDone);
+
+    if (!isDone)
+      blockIndex ++;
+
+  } while (NS_SUCCEEDED(result) && !isDone);
+  
+  *outBlockIndex = blockIndex;
+
+  return result;
+}
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/Makefile mozilla/extensions/spellcheck/zemberek/Makefile
--- mozilla-orig/extensions/spellcheck/zemberek/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/Makefile	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,50 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= ../../..
+srcdir		= .
+VPATH		= .
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= zemberek 
+DIRS		= src
+
+include $(topsrcdir)/config/rules.mk
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/Makefile.in mozilla/extensions/spellcheck/zemberek/Makefile.in
--- mozilla-orig/extensions/spellcheck/zemberek/Makefile.in	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/Makefile.in	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,50 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= zemberek 
+DIRS		= src
+
+include $(topsrcdir)/config/rules.mk
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/Makefile mozilla/extensions/spellcheck/zemberek/src/Makefile
--- mozilla-orig/extensions/spellcheck/zemberek/src/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/Makefile	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,84 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= ../../../..
+srcdir		= .
+VPATH		= .
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= zemberek
+LIBRARY_NAME	= zemberek
+# Do not set EXPORT_LIBRARY as we do not want zemberek in the static libs list
+#EXPORT_LIBRARY  = 1
+FORCE_SHARED_LIB = 1
+IS_COMPONENT	= 1
+# Do not set MODULE_NAME as we do not want the entry points
+# for this module translated in static builds
+#MODULE_NAME	= mozMyZemberekModule
+MOZILLA_INTERNAL_API = 1
+
+REQUIRES	= xpcom \
+		  string \
+		  uconv \
+		  unicharutil \
+		  spellchecker \
+		  xulapp \
+		  $(NULL)
+
+CPPSRCS = zsconn.cpp \
+	  zstring.cpp \
+	  zemberek.cpp \
+	  mozZemberek.cpp \
+	  mozZemberekFactory.cpp \
+          $(NULL)
+
+ifdef MOZ_XUL_APP
+CPPSRCS += mozZemberekDirProvider.cpp
+endif
+
+EXTRA_DSO_LDOPTS = \
+		$(LIBS_DIR) \
+		$(XPCOM_LIBS) \
+		$(NSPR_LIBS) \
+		$(MOZ_UNICHARUTIL_LIBS) \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/Makefile.in mozilla/extensions/spellcheck/zemberek/src/Makefile.in
--- mozilla-orig/extensions/spellcheck/zemberek/src/Makefile.in	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/Makefile.in	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,84 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= zemberek
+LIBRARY_NAME	= zemberek
+# Do not set EXPORT_LIBRARY as we do not want zemberek in the static libs list
+#EXPORT_LIBRARY  = 1
+FORCE_SHARED_LIB = 1
+IS_COMPONENT	= 1
+# Do not set MODULE_NAME as we do not want the entry points
+# for this module translated in static builds
+#MODULE_NAME	= mozMyZemberekModule
+MOZILLA_INTERNAL_API = 1
+
+REQUIRES	= xpcom \
+		  string \
+		  uconv \
+		  unicharutil \
+		  spellchecker \
+		  xulapp \
+		  $(NULL)
+
+CPPSRCS = zsconn.cpp \
+	  zstring.cpp \
+	  zemberek.cpp \
+	  mozZemberek.cpp \
+	  mozZemberekFactory.cpp \
+          $(NULL)
+
+ifdef MOZ_XUL_APP
+CPPSRCS += mozZemberekDirProvider.cpp
+endif
+
+EXTRA_DSO_LDOPTS = \
+		$(LIBS_DIR) \
+		$(XPCOM_LIBS) \
+		$(NSPR_LIBS) \
+		$(MOZ_UNICHARUTIL_LIBS) \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberek.cpp mozilla/extensions/spellcheck/zemberek/src/mozZemberek.cpp
--- mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberek.cpp	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/mozZemberek.cpp	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,471 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/*# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+#include "mozZemberek.h"
+#include "nsReadableUtils.h"
+#include "nsXPIDLString.h"
+#include "nsIObserverService.h"
+#include "nsISimpleEnumerator.h"
+#include "nsIDirectoryEnumerator.h"
+#include "nsIFile.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsDirectoryServiceDefs.h"
+#include "mozISpellI18NManager.h"
+#include "nsICharsetConverterManager.h"
+#include "nsUnicharUtilCIID.h"
+#include "nsUnicharUtils.h"
+#include "nsCRT.h"
+#include <stdlib.h>
+
+static NS_DEFINE_CID(kCharsetConverterManagerCID, NS_ICHARSETCONVERTERMANAGER_CID);
+static NS_DEFINE_CID(kUnicharUtilCID, NS_UNICHARUTIL_CID);
+
+NS_IMPL_ISUPPORTS3(mozZemberek,
+                   mozISpellCheckingEngine,
+                   nsIObserver,
+                   nsISupportsWeakReference)
+
+nsresult
+mozZemberek::Init()
+{
+  if (!mDictionaries.Init())
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  LoadDictionaryList();
+
+  nsCOMPtr<nsIObserverService> obs =
+    do_GetService("@mozilla.org/observer-service;1");
+  if (obs) {
+    obs->AddObserver(this, "profile-do-change", PR_TRUE);
+  }
+
+  return NS_OK;
+}
+
+mozZemberek::~mozZemberek()
+{
+  mPersonalDictionary = nsnull;
+  delete mZemberek;
+}
+
+/* attribute wstring dictionary; */
+NS_IMETHODIMP mozZemberek::GetDictionary(PRUnichar **aDictionary)
+{
+  NS_ENSURE_ARG_POINTER(aDictionary);
+
+  if (mDictionary.IsEmpty())
+    return NS_ERROR_NOT_INITIALIZED;
+
+  *aDictionary = ToNewUnicode(mDictionary);
+  return *aDictionary ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* set the Dictionary.
+ * This also Loads the dictionary and initializes the converter using the dictionaries converter
+ */
+NS_IMETHODIMP mozZemberek::SetDictionary(const PRUnichar *aDictionary)
+{
+  NS_ENSURE_ARG_POINTER(aDictionary);
+
+  if (mDictionary.Equals(aDictionary))
+    return NS_OK;
+
+  nsIFile* affFile = mDictionaries.GetWeak(nsDependentString(aDictionary));
+  if (!affFile)
+    return NS_ERROR_FILE_NOT_FOUND;
+
+  nsCAutoString dictFileName, affFileName;
+
+  // XXX This isn't really good. nsIFile->NativePath isn't safe for all
+  // character sets on Windows.
+  // A better way would be to QI to nsILocalFile, and get a filehandle
+  // from there. Only problem is that myspell wants a path
+
+  nsresult rv = affFile->GetNativePath(affFileName);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  dictFileName = affFileName;
+  PRInt32 dotPos = dictFileName.RFindChar('.');
+  if (dotPos == -1)
+    return NS_ERROR_FAILURE;
+
+  dictFileName.SetLength(dotPos);
+  dictFileName.AppendLiteral(".dic");
+
+  // SetDictionary can be called multiple times, so we might have a
+  // valid mZemberek instance which needs cleaned up.
+  delete mZemberek;
+
+  mDictionary = aDictionary;
+
+  mZemberek = new Zemberek();
+  if (!mZemberek)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsCOMPtr<nsICharsetConverterManager> ccm =
+    do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = ccm->GetUnicodeDecoder(mZemberek->get_dic_encoding(),
+                              getter_AddRefs(mDecoder));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = ccm->GetUnicodeEncoder(mZemberek->get_dic_encoding(),
+                              getter_AddRefs(mEncoder));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+
+  if (mEncoder)
+    mEncoder->SetOutputErrorBehavior(mEncoder->kOnError_Signal, nsnull, '?');
+
+  PRInt32 pos = mDictionary.FindChar('-');
+  if (pos == -1)
+    pos = mDictionary.FindChar('_');
+
+  if (pos == -1)
+    mLanguage.Assign(mDictionary);
+  else
+    mLanguage = Substring(mDictionary, 0, pos);
+
+  return NS_OK;
+}
+
+/* readonly attribute wstring language; */
+NS_IMETHODIMP mozZemberek::GetLanguage(PRUnichar **aLanguage)
+{
+  NS_ENSURE_ARG_POINTER(aLanguage);
+
+  if (mDictionary.IsEmpty())
+    return NS_ERROR_NOT_INITIALIZED;
+
+  *aLanguage = ToNewUnicode(mLanguage);
+  return *aLanguage ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+/* readonly attribute boolean providesPersonalDictionary; */
+NS_IMETHODIMP mozZemberek::GetProvidesPersonalDictionary(PRBool *aProvidesPersonalDictionary)
+{
+  NS_ENSURE_ARG_POINTER(aProvidesPersonalDictionary);
+
+  *aProvidesPersonalDictionary = PR_FALSE;
+  return NS_OK;
+}
+
+/* readonly attribute boolean providesWordUtils; */
+NS_IMETHODIMP mozZemberek::GetProvidesWordUtils(PRBool *aProvidesWordUtils)
+{
+  NS_ENSURE_ARG_POINTER(aProvidesWordUtils);
+
+  *aProvidesWordUtils = PR_FALSE;
+  return NS_OK;
+}
+
+/* readonly attribute wstring name; */
+NS_IMETHODIMP mozZemberek::GetName(PRUnichar * *aName)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* readonly attribute wstring copyright; */
+NS_IMETHODIMP mozZemberek::GetCopyright(PRUnichar * *aCopyright)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute mozIPersonalDictionary personalDictionary; */
+NS_IMETHODIMP mozZemberek::GetPersonalDictionary(mozIPersonalDictionary * *aPersonalDictionary)
+{
+  *aPersonalDictionary = mPersonalDictionary;
+  NS_IF_ADDREF(*aPersonalDictionary);
+  return NS_OK;
+}
+
+NS_IMETHODIMP mozZemberek::SetPersonalDictionary(mozIPersonalDictionary * aPersonalDictionary)
+{
+  mPersonalDictionary = aPersonalDictionary;
+  return NS_OK;
+}
+
+struct AppendNewStruct
+{
+  PRUnichar **dics;
+  PRUint32 count;
+  PRBool failed;
+};
+
+static PLDHashOperator
+AppendNewString(const nsAString& aString, nsIFile* aFile, void* aClosure)
+{
+  AppendNewStruct *ans = (AppendNewStruct*) aClosure;
+  ans->dics[ans->count] = ToNewUnicode(aString);
+  if (!ans->dics[ans->count]) {
+    ans->failed = PR_TRUE;
+    return PL_DHASH_STOP;
+  }
+
+  ++ans->count;
+  return PL_DHASH_NEXT;
+}
+
+/* void GetDictionaryList ([array, size_is (count)] out wstring dictionaries, out PRUint32 count); */
+NS_IMETHODIMP mozZemberek::GetDictionaryList(PRUnichar ***aDictionaries,
+                                            PRUint32 *aCount)
+{
+  if (!aDictionaries || !aCount)
+    return NS_ERROR_NULL_POINTER;
+
+  AppendNewStruct ans = {
+    (PRUnichar**) NS_Alloc(sizeof(PRUnichar*) * mDictionaries.Count()),
+    0,
+    PR_FALSE
+  };
+
+  // This pointer is used during enumeration
+  mDictionaries.EnumerateRead(AppendNewString, &ans);
+
+  if (ans.failed) {
+    while (ans.count) {
+      --ans.count;
+      NS_Free(ans.dics[ans.count]);
+    }
+    NS_Free(ans.dics);
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  *aDictionaries = ans.dics;
+  *aCount = ans.count;
+
+  return NS_OK;
+}
+
+void
+mozZemberek::LoadDictionaryList()
+{
+  mDictionaries.Clear();
+
+  nsresult rv;
+
+  nsCOMPtr<nsIProperties> dirSvc =
+    do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
+  if (!dirSvc)
+    return;
+
+  nsCOMPtr<nsIFile> dictDir;
+  rv = dirSvc->Get(DICTIONARY_SEARCH_DIRECTORY,
+                   NS_GET_IID(nsIFile), getter_AddRefs(dictDir));
+  if (NS_FAILED(rv)) {
+    // default to appdir/dictionaries
+    rv = dirSvc->Get(NS_XPCOM_CURRENT_PROCESS_DIR,
+                     NS_GET_IID(nsIFile), getter_AddRefs(dictDir));
+    if (NS_FAILED(rv))
+      return;
+
+    dictDir->AppendNative(NS_LITERAL_CSTRING("dictionaries"));
+  }
+
+  LoadDictionariesFromDir(dictDir);
+
+  nsCOMPtr<nsISimpleEnumerator> dictDirs;
+  rv = dirSvc->Get(DICTIONARY_SEARCH_DIRECTORY_LIST,
+                   NS_GET_IID(nsISimpleEnumerator), getter_AddRefs(dictDirs));
+  if (NS_FAILED(rv))
+    return;
+
+  PRBool hasMore;
+  while (NS_SUCCEEDED(dictDirs->HasMoreElements(&hasMore)) && hasMore) {
+    nsCOMPtr<nsISupports> elem;
+    dictDirs->GetNext(getter_AddRefs(elem));
+
+    dictDir = do_QueryInterface(elem);
+    if (dictDir)
+      LoadDictionariesFromDir(dictDir);
+  }
+}
+
+void
+mozZemberek::LoadDictionariesFromDir(nsIFile* aDir)
+{
+  nsresult rv;
+
+  PRBool check = PR_FALSE;
+  rv = aDir->Exists(&check);
+  if (NS_FAILED(rv) || !check)
+    return;
+
+  rv = aDir->IsDirectory(&check);
+  if (NS_FAILED(rv) || !check)
+    return;
+
+  nsCOMPtr<nsISimpleEnumerator> e;
+  rv = aDir->GetDirectoryEntries(getter_AddRefs(e));
+  if (NS_FAILED(rv))
+    return;
+
+  nsCOMPtr<nsIDirectoryEnumerator> files(do_QueryInterface(e));
+  if (!files)
+    return;
+
+  nsCOMPtr<nsIFile> file;
+  while (NS_SUCCEEDED(files->GetNextFile(getter_AddRefs(file))) && file) {
+    nsAutoString leafName;
+    file->GetLeafName(leafName);
+    if (!StringEndsWith(leafName, NS_LITERAL_STRING(".dic")))
+      continue;
+
+    nsAutoString dict(leafName);
+    dict.SetLength(dict.Length() - 4); // magic length of ".dic"
+
+    // check for the presence of the .aff file
+    leafName = dict;
+    leafName.AppendLiteral(".aff");
+    file->SetLeafName(leafName);
+    rv = file->Exists(&check);
+    if (NS_FAILED(rv) || !check)
+      continue;
+
+#ifdef DEBUG_bsmedberg
+    printf("Adding dictionary: %s\n", NS_ConvertUTF16toUTF8(dict).get());
+#endif
+
+    mDictionaries.Put(dict, file);
+  }
+}
+
+nsresult mozZemberek::ConvertCharset(const PRUnichar* aStr, char ** aDst)
+{
+  NS_ENSURE_ARG_POINTER(aDst);
+  NS_ENSURE_TRUE(mEncoder, NS_ERROR_NULL_POINTER);
+
+  PRInt32 outLength;
+  PRInt32 inLength = nsCRT::strlen(aStr);
+  nsresult rv = mEncoder->GetMaxLength(aStr, inLength, &outLength);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  *aDst = (char *) nsMemory::Alloc(sizeof(char) * (outLength+1));
+  NS_ENSURE_TRUE(*aDst, NS_ERROR_OUT_OF_MEMORY);
+
+  rv = mEncoder->Convert(aStr, &inLength, *aDst, &outLength);
+  if (NS_SUCCEEDED(rv))
+    (*aDst)[outLength] = '\0'; 
+
+  return rv;
+}
+
+/* boolean Check (in wstring word); */
+NS_IMETHODIMP mozZemberek::Check(const PRUnichar *aWord, PRBool *aResult)
+{
+  NS_ENSURE_ARG_POINTER(aWord);
+  NS_ENSURE_ARG_POINTER(aResult);
+  NS_ENSURE_TRUE(mZemberek, NS_ERROR_FAILURE);
+
+  nsXPIDLCString charsetWord;
+  nsresult rv = ConvertCharset(aWord, getter_Copies(charsetWord));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  *aResult = mZemberek->spellCheck(charsetWord);
+
+  if (!*aResult && mPersonalDictionary) 
+    rv = mPersonalDictionary->Check(aWord, mLanguage.get(), aResult);
+  
+  return rv;
+}
+
+/* void Suggest (in wstring word, [array, size_is (count)] out wstring suggestions, out PRUint32 count); */
+NS_IMETHODIMP mozZemberek::Suggest(const PRUnichar *aWord, PRUnichar ***aSuggestions, PRUint32 *aSuggestionCount)
+{
+  NS_ENSURE_ARG_POINTER(aSuggestions);
+  NS_ENSURE_ARG_POINTER(aSuggestionCount);
+  NS_ENSURE_TRUE(mZemberek, NS_ERROR_FAILURE);
+
+  nsresult rv;
+  *aSuggestionCount = 0;
+  
+  nsXPIDLCString charsetWord;
+  rv = ConvertCharset(aWord, getter_Copies(charsetWord));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  char ** wlst;
+  *aSuggestionCount = mZemberek->getSuggestions(&wlst, charsetWord);
+
+  if (*aSuggestionCount) {    
+    *aSuggestions  = (PRUnichar **)nsMemory::Alloc(*aSuggestionCount * sizeof(PRUnichar *));    
+    if (*aSuggestions) {
+      PRUint32 index = 0;
+      for (index = 0; index < *aSuggestionCount && NS_SUCCEEDED(rv); ++index) {
+        // Convert the suggestion to utf16     
+        PRInt32 inLength = nsCRT::strlen(wlst[index]);
+        PRInt32 outLength;
+        rv = mDecoder->GetMaxLength(wlst[index], inLength, &outLength);
+        if (NS_SUCCEEDED(rv))
+        {
+          (*aSuggestions)[index] = (PRUnichar *) nsMemory::Alloc(sizeof(PRUnichar) * (outLength+1));
+          if ((*aSuggestions)[index])
+          {
+            rv = mDecoder->Convert(wlst[index], &inLength, (*aSuggestions)[index], &outLength);
+            if (NS_SUCCEEDED(rv))
+              (*aSuggestions)[index][outLength] = 0;
+          } 
+          else
+            rv = NS_ERROR_OUT_OF_MEMORY;
+        }
+      }
+
+      if (NS_FAILED(rv))
+        NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(index, *aSuggestions); // free the PRUnichar strings up to the point at which the error occurred
+    }
+    else // if (*aSuggestions)
+      rv = NS_ERROR_OUT_OF_MEMORY;
+  }
+  
+  NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(*aSuggestionCount, wlst);
+  return rv;
+}
+
+NS_IMETHODIMP
+mozZemberek::Observe(nsISupports* aSubj, const char *aTopic,
+                    const PRUnichar *aData)
+{
+  NS_ASSERTION(!strcmp(aTopic, "profile-do-change"),
+               "Unexpected observer topic");
+
+  LoadDictionaryList();
+
+  return NS_OK;
+}
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.cpp mozilla/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.cpp
--- mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.cpp	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.cpp	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,182 @@
+/*# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+#include "mozZemberekDirProvider.h"
+#include "nsXULAppAPI.h"
+#include "nsString.h"
+
+#include "mozISpellCheckingEngine.h"
+#include "nsICategoryManager.h"
+
+NS_IMPL_ISUPPORTS2(mozZemberekDirProvider,
+		   nsIDirectoryServiceProvider,
+		   nsIDirectoryServiceProvider2)
+
+NS_IMETHODIMP
+mozZemberekDirProvider::GetFile(const char *aKey, PRBool *aPersist,
+			       nsIFile* *aResult)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+mozZemberekDirProvider::GetFiles(const char *aKey,
+				nsISimpleEnumerator* *aResult)
+{
+  if (strcmp(aKey, DICTIONARY_SEARCH_DIRECTORY_LIST) != 0) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIProperties> dirSvc =
+    do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
+  if (!dirSvc)
+    return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsISimpleEnumerator> list;
+  nsresult rv = dirSvc->Get(XRE_EXTENSIONS_DIR_LIST,
+			    NS_GET_IID(nsISimpleEnumerator),
+			    getter_AddRefs(list));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsISimpleEnumerator> e = new AppendingEnumerator(list);
+  if (!e)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  *aResult = nsnull;
+  e.swap(*aResult);
+  return NS_SUCCESS_AGGREGATE_RESULT;
+}
+
+NS_IMPL_ISUPPORTS1(mozZemberekDirProvider::AppendingEnumerator,
+		   nsISimpleEnumerator)
+
+NS_IMETHODIMP
+mozZemberekDirProvider::AppendingEnumerator::HasMoreElements(PRBool *aResult)
+{
+  *aResult = mNext ? PR_TRUE : PR_FALSE;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+mozZemberekDirProvider::AppendingEnumerator::GetNext(nsISupports* *aResult)
+{
+  if (aResult)
+    NS_ADDREF(*aResult = mNext);
+
+  mNext = nsnull;
+
+  nsresult rv;
+
+  // Ignore all errors
+
+  PRBool more;
+  while (NS_SUCCEEDED(mBase->HasMoreElements(&more)) && more) {
+    nsCOMPtr<nsISupports> nextbasesupp;
+    mBase->GetNext(getter_AddRefs(nextbasesupp));
+
+    nsCOMPtr<nsIFile> nextbase(do_QueryInterface(nextbasesupp));
+    if (!nextbase)
+      continue;
+
+    nextbase->Clone(getter_AddRefs(mNext));
+    if (!mNext)
+      continue;
+
+    mNext->AppendNative(NS_LITERAL_CSTRING("dictionaries"));
+
+    PRBool exists;
+    rv = mNext->Exists(&exists);
+    if (NS_SUCCEEDED(rv) && exists)
+      break;
+
+    mNext = nsnull;
+  }
+
+  return NS_OK;
+}
+
+mozZemberekDirProvider::AppendingEnumerator::AppendingEnumerator
+    (nsISimpleEnumerator* aBase) :
+  mBase(aBase)
+{
+  // Initialize mNext to begin
+  GetNext(nsnull);
+}
+
+NS_METHOD
+mozZemberekDirProvider::Register(nsIComponentManager* aCompMgr,
+				nsIFile* aPath, const char *aLoaderStr,
+				const char *aType,
+				const nsModuleComponentInfo *aInfo)
+{
+  nsresult rv;
+
+  nsCOMPtr<nsICategoryManager> catMan =
+    do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
+  if (!catMan)
+    return NS_ERROR_FAILURE;
+
+  rv = catMan->AddCategoryEntry(XPCOM_DIRECTORY_PROVIDER_CATEGORY,
+				"spellcheck-directory-provider",
+				kContractID, PR_TRUE, PR_TRUE, nsnull);
+  return rv;
+}
+
+NS_METHOD
+mozZemberekDirProvider::Unregister(nsIComponentManager* aCompMgr,
+				  nsIFile* aPath,
+				  const char *aLoaderStr,
+				  const nsModuleComponentInfo *aInfo)
+{
+  nsresult rv;
+
+  nsCOMPtr<nsICategoryManager> catMan =
+    do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
+  if (!catMan)
+    return NS_ERROR_FAILURE;
+
+  rv = catMan->DeleteCategoryEntry(XPCOM_DIRECTORY_PROVIDER_CATEGORY,
+				   "spellcheck-directory-provider",
+				   PR_TRUE);
+  return rv;
+}
+
+char const *const
+mozZemberekDirProvider::kContractID = "@mozilla.org/spellcheck/dir-provider;1";
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.h mozilla/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.h
--- mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.h	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/mozZemberekDirProvider.h	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,85 @@
+/*# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+#ifndef mozZemberekDirProvider_h__
+#define mozZemberekDirProvider_h__
+
+#include "nsIDirectoryService.h"
+#include "nsIGenericFactory.h"
+#include "nsISimpleEnumerator.h"
+
+class mozZemberekDirProvider :
+  public nsIDirectoryServiceProvider2
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDIRECTORYSERVICEPROVIDER
+  NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
+
+  static NS_METHOD Register(nsIComponentManager* aCompMgr,
+			    nsIFile* aPath, const char *aLoaderStr,
+			    const char *aType,
+			    const nsModuleComponentInfo *aInfo);
+
+  static NS_METHOD Unregister(nsIComponentManager* aCompMgr,
+			      nsIFile* aPath, const char *aLoaderStr,
+			      const nsModuleComponentInfo *aInfo);
+
+  static char const *const kContractID;
+
+private:
+  class AppendingEnumerator : public nsISimpleEnumerator
+  {
+  public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSISIMPLEENUMERATOR
+
+    AppendingEnumerator(nsISimpleEnumerator* aBase);
+
+  private:
+    nsCOMPtr<nsISimpleEnumerator> mBase;
+    nsCOMPtr<nsIFile>             mNext;
+  };
+};
+
+#define ZEMBEREKDIRPROVIDER_CID \
+{ 0x2aa60653, 0x653c, 0x45ca, \
+  { 0xb7, 0x64, 0xaa, 0x3d, 0xcf, 0x27, 0xe4, 0x7d } }
+
+#endif // mozZemberekDirProvider
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberekFactory.cpp mozilla/extensions/spellcheck/zemberek/src/mozZemberekFactory.cpp
--- mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberekFactory.cpp	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/mozZemberekFactory.cpp	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+#include "nsIGenericFactory.h"
+
+#include "mozZemberek.h"
+
+#ifdef MOZ_XUL_APP
+#include "mozZemberekDirProvider.h"
+#endif
+
+////////////////////////////////////////////////////////////////////////
+// Define the contructor function for the objects
+//
+// NOTE: This creates an instance of objects by using the default constructor
+//
+
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(mozZemberek, Init)
+
+#ifdef MOZ_XUL_APP
+NS_GENERIC_FACTORY_CONSTRUCTOR(mozZemberekDirProvider)
+#endif
+
+////////////////////////////////////////////////////////////////////////
+// Define a table of CIDs implemented by this module along with other
+// information like the function to create an instance, contractid, and
+// class name.
+//
+static nsModuleComponentInfo components[] = {
+    {
+        "mozZemberek",
+        MOZ_ZEMBEREK_CID,
+        MOZ_ZEMBEREK_CONTRACTID,
+        mozZemberekConstructor
+    }
+#ifdef MOZ_XUL_APP
+    , {
+        "mozZemberekDirProvider",
+        ZEMBEREKDIRPROVIDER_CID,
+        mozZemberekDirProvider::kContractID,
+        mozZemberekDirProviderConstructor,
+        mozZemberekDirProvider::Register,
+        mozZemberekDirProvider::Unregister
+    }
+#endif
+};
+
+////////////////////////////////////////////////////////////////////////
+// Implement the NSGetModule() exported function for your module
+// and the entire implementation of the module object.
+//
+NS_IMPL_NSGETMODULE(mozZemberekModule, components)
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberek.h mozilla/extensions/spellcheck/zemberek/src/mozZemberek.h
--- mozilla-orig/extensions/spellcheck/zemberek/src/mozZemberek.h	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/mozZemberek.h	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/*# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Spellchecker Component.
+#
+# The Initial Developer of the Original Code is Faik Uygur.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# TUBITAK/UEKAE. All Rights Reserved.
+#
+# Contributor(s): Faik Uygur <faik@pardus.org.tr>
+#
+# Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+# of the zpspell code is Baris Metin. Portions created by the Initial Developer
+# Copyright (c) 2004, TUBITAK/UEKAE. All Rights Reserved.
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+#ifndef mozZemberek_h__
+#define mozZemberek_h__
+
+#include "zemberek.h"
+#include "mozISpellCheckingEngine.h"
+#include "mozIPersonalDictionary.h"
+#include "nsString.h"
+#include "nsCOMPtr.h"
+#include "nsIObserver.h"
+#include "nsIUnicodeEncoder.h"
+#include "nsIUnicodeDecoder.h"
+#include "nsInterfaceHashtable.h"
+#include "nsWeakReference.h"
+
+#define MOZ_ZEMBEREK_CONTRACTID "@mozilla.org/spellchecker/zemberek;1"
+#define MOZ_ZEMBEREK_CID         \
+{ /* 15DDAC0D-D94C-4fc1-8F48-E1BB04A6F380} */  \
+0x15DDAC0D, 0xD94C, 0x4fc1,                    \
+{ 0x8F, 0x48, 0xE1, 0xBB, 0x04, 0xA6, 0xF3, 0x80} }
+
+class mozZemberek : public mozISpellCheckingEngine,
+                   public nsIObserver,
+                   public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_MOZISPELLCHECKINGENGINE
+  NS_DECL_NSIOBSERVER
+
+  mozZemberek() : mZemberek(nsnull) { }
+  virtual ~mozZemberek();
+
+  nsresult Init();
+
+  void LoadDictionaryList();
+  void LoadDictionariesFromDir(nsIFile* aDir);
+
+  // helper method for converting a word to the charset of the dictionary
+  nsresult ConvertCharset(const PRUnichar* aStr, char ** aDst);
+
+protected:
+ 
+  nsCOMPtr<mozIPersonalDictionary> mPersonalDictionary;
+  nsCOMPtr<nsIUnicodeEncoder>      mEncoder; 
+  nsCOMPtr<nsIUnicodeDecoder>      mDecoder; 
+
+  // Hashtable matches dictionary name to .aff file
+  nsInterfaceHashtable<nsStringHashKey, nsIFile> mDictionaries;
+  nsString  mDictionary;
+  nsString  mLanguage;
+
+  Zemberek  *mZemberek;
+};
+
+#endif
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/zemberek.cpp mozilla/extensions/spellcheck/zemberek/src/zemberek.cpp
--- mozilla-orig/extensions/spellcheck/zemberek/src/zemberek.cpp	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/zemberek.cpp	2008-06-12 23:19:43.000000000 +0300
@@ -0,0 +1,77 @@
+/*
+  Copyright (c) 2004, TUBITAK/UEKAE
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  Mozilla Zemberek Client library is based on zpspell. The Initial Developer
+  of the zpspell code is Baris Metin.
+*/
+
+#include <iostream>
+#include <vector>
+#include <cstring>
+#include <cstdlib>
+
+#include "zsconn.h"
+#include "zstring.h"
+#include "zemberek.h"
+
+/* use myspell's limit for maxSug */
+Zemberek::Zemberek() : maxSug(25)
+{
+    zsconn = new ZSConn();
+}
+
+Zemberek::~Zemberek()
+{
+    delete zsconn;
+}
+
+int Zemberek::spellCheck(const char *word) const
+{
+    ZString zstr = zsconn->checkString(word, 0);
+    return (zstr.status() == Z_TRUE);
+}
+
+int Zemberek::getSuggestions(char ***suggestions, const char *word) const
+{
+    int ns = 0;
+    //XXX: This check is unnecessary. we call this method only for misspelled words.
+    ZString zstr = zsconn->checkString(word, 0);
+
+    if ( zstr.status() == Z_FALSE ) {
+        zstr.setSuggestions( zsconn->getSuggestions( zstr.str() ) );
+        if ( zstr.suggestionCount() != 0 ) {
+            zstr.setStatus( Z_SUGGESTION );
+        }
+    }
+
+    *suggestions = NULL;
+
+    if (zstr.status() != Z_SUGGESTION)
+	return 0;
+
+    char **wlst = (char **)calloc(maxSug, sizeof(char *));
+    if (wlst == NULL) 
+      return 0;
+    
+    vector<string>::const_iterator words_iter;
+    const vector<string> &words = zstr.suggestions();
+
+    for (words_iter = words.begin(); words_iter != words.end() && ns < maxSug; words_iter++, ns++) {
+	wlst[ns] = strdup((*words_iter).c_str());
+    }
+
+    if (ns > 0)
+	*suggestions = wlst;
+
+    return ns;
+}
+
+char *Zemberek::get_dic_encoding()
+{
+    return strdup("UTF-8");
+}
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/zemberek.h mozilla/extensions/spellcheck/zemberek/src/zemberek.h
--- mozilla-orig/extensions/spellcheck/zemberek/src/zemberek.h	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/zemberek.h	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,34 @@
+/*
+  Copyright (c) 2004, TUBITAK/UEKAE
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  Please read the COPYING file.
+*/
+
+#ifndef ZEMBEREK_H
+#define ZEMBEREK_H
+
+#include "zsconn.h"
+
+using namespace std;
+
+class Zemberek
+{
+public:
+    Zemberek();
+    ~Zemberek();
+
+    int getSuggestions(char ***suggestions, const char *word) const;
+    int spellCheck(const char *word) const;
+    char *get_dic_encoding();
+
+private:
+    const short maxSug;
+    ZSConn *zsconn;
+};
+
+#endif
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/zsconn.cpp mozilla/extensions/spellcheck/zemberek/src/zsconn.cpp
--- mozilla-orig/extensions/spellcheck/zemberek/src/zsconn.cpp	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/zsconn.cpp	2008-06-12 23:19:57.000000000 +0300
@@ -0,0 +1,177 @@
+/*
+  Copyright (c) 2004, TUBITAK/UEKAE
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  Please read the COPYING file.
+*/
+
+#include <iostream>
+#include <sstream>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <cstring>
+#include <cstdlib>
+
+#include "zsconn.h"
+
+#define HOST "localhost"
+#define ZPORT 10444
+
+
+ZSConn::ZSConn()
+{
+    struct hostent *he;
+    struct sockaddr_in saddr;
+
+    if ( ( he = (struct hostent *)gethostbyname(HOST) ) == NULL ) {
+	perror( "gethostbyname()" );
+    }
+
+    if ( ( _conn = socket(AF_INET, SOCK_STREAM, 0) ) == -1 ) {
+	perror( "socket()" );
+    }
+
+    saddr.sin_family = AF_INET;
+    saddr.sin_port = htons( (uint16_t)ZPORT );
+    saddr.sin_addr = *( (struct in_addr *)he->h_addr );
+    memset( &(saddr.sin_zero), '\0', 8 );
+
+    if ( connect(_conn, (struct sockaddr *)&saddr, sizeof(struct sockaddr)) == -1) {
+        perror("zemberek-server hatas");
+    }
+}
+
+ZSConn::~ZSConn()
+{
+    if ( _conn ) {
+        shutdown( _conn, SHUT_RDWR );
+        close( _conn );
+    }
+}
+
+
+ZString ZSConn::checkString( const string& str, int offset ) const
+{
+    ZString zstr( str, offset );
+
+    // pislikleri temizle, bunlar ispell'e gnderilen komutlar.
+    // imdilik iimiz yok bunlarla
+    // bir de ^ var ama o kullanlyor bizim iin...
+    string flags( "*&@+-~#!%`" );
+    string::iterator it = flags.begin();
+    string::iterator end = flags.end();
+    for ( ; it != end; ++it ) {
+        if ( str[0] == *it ) {
+            zstr.setStatus( Z_UNKNOWN );
+            return zstr;
+        }
+    }
+    zstr.setStatus( spellCheck( zstr.str() ) );
+    return zstr;
+}
+
+enum Z_CHECK_RESULT ZSConn::spellCheck( const string& str ) const
+{
+    stringstream strstream;
+    strstream << str.length()+2 << " * " << str;
+    string checkStr = strstream.str();
+    if ( send(_conn, checkStr.c_str(), checkStr.length(), 0) == -1) {
+	perror("zemberek-server hatas");
+	return Z_TRUE;
+    }
+
+    switch ( recvResult()[0] ) {
+    case '*':
+        return Z_TRUE;
+        break;
+    case '#':
+        return Z_FALSE;
+        break;
+    default:
+        return Z_UNKNOWN;
+        break;
+    }
+}
+
+vector<string> ZSConn::getSuggestions(const string& str ) const
+{
+    stringstream strstream;
+    vector<string> suggestions;
+
+    strstream << str.length()+2 << " & " << str;
+    string checkStr = strstream.str();
+    if ( send( _conn, checkStr.c_str(), checkStr.length(), 0 ) == -1 ) {
+	perror("zemberek-server hatas");
+	return suggestions;
+    }
+
+    string result = recvResult();
+
+    if ( result[0] != '&' ) {
+        return suggestions;
+    }
+
+    string::iterator it = result.begin();
+    string::iterator end = result.end();
+    bool start = false;
+    string tmp;
+    for ( ; it != end; ++it ) {
+        if ( *it == '(' ) {
+            start = true;
+            continue;
+        }
+
+        if ( !start ) continue;
+
+
+        if ( *it == ',' ) {
+            suggestions.push_back( tmp );
+            tmp.erase();
+            continue;
+        } else if ( *it == ')' ) {
+            suggestions.push_back( tmp );
+            break;
+        }
+
+        tmp += *it;
+    }
+
+    return suggestions;
+}
+
+
+string ZSConn::recvResult() const
+{
+    int numbytes = 0;
+    string buf("");
+
+    int size = 0;
+    while (true) {
+        char s;
+        numbytes = recv (_conn, &s, 1, 0);
+
+        // ' ' boluk karakteri hi gelmezse???
+        if (s == ' ') {
+            char *endptr;
+            size = strtol (buf.c_str() , &endptr, 0);
+            buf.erase();
+            break;
+        }
+
+        buf += s;
+    }
+    char *ret = new char[size+1];
+    numbytes = recv (_conn, ret, size, 0);
+    ret[numbytes]='\0';
+
+    string result = ret;
+    delete ret;
+
+    return result;
+}
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/zsconn.h mozilla/extensions/spellcheck/zemberek/src/zsconn.h
--- mozilla-orig/extensions/spellcheck/zemberek/src/zsconn.h	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/zsconn.h	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,39 @@
+/*
+  Copyright (c) 2004, TUBITAK/UEKAE
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  Please read the COPYING file.
+*/
+
+/*
+  ZemberekServer Connection.
+*/
+
+#ifndef ZSCONN_H
+#define ZSCONN_H
+
+#include "zstring.h"
+
+using namespace std;
+
+class ZSConn
+{
+public:
+    ZSConn();
+    ~ZSConn();
+
+    ZString checkString( const string& str, int offset ) const;
+    vector<string> getSuggestions (const string& str ) const;
+
+private:
+    int _conn;
+
+    enum Z_CHECK_RESULT spellCheck( const string& str ) const;
+    string recvResult() const;
+};
+
+#endif
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/zstring.cpp mozilla/extensions/spellcheck/zemberek/src/zstring.cpp
--- mozilla-orig/extensions/spellcheck/zemberek/src/zstring.cpp	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/zstring.cpp	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,80 @@
+/*
+  Copyright (c) 2004, TUBITAK/UEKAE
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  Please read the COPYING file.
+*/
+
+#include <iostream>
+#include <sstream>
+
+#include "zstring.h"
+
+ZString::ZString(const string& str, int offset )
+    : _str(str), _offset(offset),
+      _status(Z_UNKNOWN)
+{}
+
+
+/* set */
+void ZString::setStatus( enum Z_CHECK_RESULT status )
+{
+    _status = status;
+}
+
+void ZString::setSuggestions( const vector<string>& suggestions)
+{
+    _suggestions = suggestions;
+}
+
+void ZString::addSuggestion( const string& suggestion )
+{
+    _suggestions.push_back( suggestion );
+}
+
+/* get */
+int ZString::offset() const
+{
+    return _offset;
+}
+
+const string& ZString::str() const
+{
+    return _str;
+}
+
+enum Z_CHECK_RESULT ZString::status() const
+{
+    return _status;
+}
+
+int ZString::suggestionCount() const
+{
+    return _suggestions.size();
+}
+
+const string ZString::suggestionString() const
+{
+    stringstream sstr;
+
+    vector<string>::const_iterator it = _suggestions.begin();
+    int len = _suggestions.size();
+    for (int i=0 ; i < len ; ++i, ++it ) {
+        sstr << *it;
+        if ( i < len-1 ) {
+            sstr << ", ";
+        }
+    }
+
+    return sstr.str();
+}
+
+const vector<string>& ZString::suggestions() const
+{
+    return _suggestions;
+}
+
diff -Naur mozilla-orig/extensions/spellcheck/zemberek/src/zstring.h mozilla/extensions/spellcheck/zemberek/src/zstring.h
--- mozilla-orig/extensions/spellcheck/zemberek/src/zstring.h	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/extensions/spellcheck/zemberek/src/zstring.h	2008-06-12 23:18:50.000000000 +0300
@@ -0,0 +1,50 @@
+/*
+  Copyright (c) 2004, TUBITAK/UEKAE
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  Please read the COPYING file.
+*/
+
+#ifndef ZSTRING_H
+#define ZSTRING_H
+
+#include <string>
+#include <vector>
+
+using namespace std;
+
+enum Z_CHECK_RESULT {
+    Z_TRUE = 0,
+    Z_FALSE,
+    Z_SUGGESTION,
+    Z_UNKNOWN
+};
+
+class ZString
+{
+public:
+    ZString(const string& str, int offset );
+
+    void setStatus( enum Z_CHECK_RESULT status );
+    void setSuggestions( const vector<string>& suggestions);
+    void addSuggestion( const string& suggestion );
+
+    int offset() const;
+    const string& str() const;
+    enum Z_CHECK_RESULT status() const;
+    const vector<string>& suggestions() const;
+    int suggestionCount() const;
+    const string suggestionString() const;
+
+private:
+    int _offset;
+    enum Z_CHECK_RESULT _status;
+    const string _str;
+    vector<string> _suggestions;
+};
+
+#endif // ZSTRING_H
