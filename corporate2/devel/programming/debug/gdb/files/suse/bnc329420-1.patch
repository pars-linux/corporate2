On Wed, 13 May 2009, Sami Wagiaalla wrote:

> This problem is due to the fact that in Archer we are using 
> dwarf2_full_name instead of dwarf2_linkage_name.
> 
> I am trying your patch but it does not seem to have solved the problem 
> for me. Are you testing against the Archer fedora branch ( 
> archer-jankratochvil-fedora-merge ) ?

Meh, wrong patch, sorry.  I must have had traces of my other approach 
still in dwarf2read.c that this worked when I checked before sending.  It 
actually fixes only the partial DIEs and I'm not even sure if that's 
necessary.  It certainly does not fix the problem for reading full DIEs.  
As it's a rather generic tree reader (read_die_and_children_1 and friends) 
it seems a bit clumsy to special case bogus namespace dies there, which 
brings me back to my other option (that's the one I started and tested 
with), hacking determine_prefix, like below.  That fixes the problem.  
Really :-)


Ciao,
Michael.
Index: gdb-6.8.50.20090302/gdb/dwarf2read.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/dwarf2read.c	2009-05-13 15:53:22.000000000 +0200
+++ gdb-6.8.50.20090302/gdb/dwarf2read.c	2009-05-13 23:48:52.000000000 +0200
@@ -8885,9 +8894,18 @@ determine_prefix (struct die_info *die,
     switch (parent->tag)
       {
       case DW_TAG_namespace:
-	parent_type = read_type_die (parent, cu);
-	/* We give a name to even anonymous namespaces.  */
-	return TYPE_TAG_NAME (parent_type);
+	{
+	  char *prefix;
+	  parent_type = read_type_die (parent, cu);
+	  /* We give a name to even anonymous namespaces.  */
+	  prefix = TYPE_TAG_NAME (parent_type);
+	  /* Special hack for bogus global namespace that is emitted as an
+	     explicit namespace with the name '::' in g++ 4.1, for
+	     some decls.  */
+	  if (prefix[0] == ':' && prefix[1] == ':' && prefix[2] == 0)
+	    return "";
+	  return prefix;
+	}
       case DW_TAG_class_type:
       case DW_TAG_interface_type:
       case DW_TAG_structure_type:

