diff -Nur rpm2targz-9.0.0.4g-old/rpmoffset.c rpm2targz-9.0.0.4g/rpmoffset.c
--- rpm2targz-9.0.0.4g-old/rpmoffset.c	2010-08-05 16:01:16.379359842 +0300
+++ rpm2targz-9.0.0.4g/rpmoffset.c	2010-08-05 22:19:04.539928089 +0300
@@ -25,6 +25,14 @@
 	const size_t len;
 } magic_t;
 
+int is_lzma_header(char *buf) {
+	return (buf[0] < 0xE1
+		&& buf[0] == 0x5d
+		&& buf[4] < 0x20
+		&& (memcmp (buf + 10 , "\x00\x00\x00", 3) == 0
+			|| (memcmp (buf + 5, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8) == 0)));
+}
+
 static const unsigned char magic_gzip[]  = { '\037', '\213', '\010' };
 static const unsigned char magic_bzip2[] = { 'B', 'Z', 'h' };
 static const unsigned char magic_xz[]    = { 0xFD, '7', 'z', 'X', 'Z', 0x00 };
@@ -41,6 +49,7 @@
 int main(int argc, char *argv[])
 {
 	int show_magic = 0;
+	size_t lzma_offset = 0;
 	size_t i, read_cnt, offset, left;
 	FILE *fp = stdin;
 	char p[BUFSIZ];
@@ -77,6 +86,19 @@
 			}
 		}
 
+		/* Do not stop when we find lzma, to prefer xz over lzma, since xz has lzma header at the beginning */
+		for (i = 0; i < read_cnt; i++) {
+			if (read_cnt + left > 10 && is_lzma_header(p+i)) {
+				/*
+				if (show_magic)
+					printf("lzma ");
+				printf("%zu\n", offset+i);
+				return 0;
+				*/
+				lzma_offset = offset + i;
+			}
+		}
+
 		memmove(p, p + left + read_cnt - MAGIC_SIZE_MIN + 1, MAGIC_SIZE_MIN - 1);
 
 		offset += read_cnt;
@@ -86,6 +108,12 @@
 		}
 	}
 
+	if (lzma_offset) {
+		if (show_magic)
+			printf("lzma ");
+		printf("%zu\n", lzma_offset);
+	}
+
 	if (ferror(stdin))
 		perror(argv[0]);
 
