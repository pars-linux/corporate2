diff -Nur ooo-build-3.1.1.4/ChangeLog ooo-build-3.1.1.5/ChangeLog
--- ooo-build-3.1.1.4/ChangeLog	2009-10-20 17:32:46.000000000 +0300
+++ ooo-build-3.1.1.5/ChangeLog	2009-11-26 18:06:33.000000000 +0200
@@ -1,10 +1,283 @@
-2009-10-20  Petr Mladek  <pmladek@suse.cz>  [8b39736eb9e28247773e385b0962f309b0e76c7c]
+2009-11-26  Petr Mladek  <pmladek@suse.cz>  [b68630c172563cb685232c525d17c441931de749]
+
+	Release ooo-build-3.1.1.5 (maintenance update)
+
+	* version 3.1.1.5  (maintenance update)
+	* tag OOO_BUILD_3_1_1_5
+
+2009-11-26  Petr Mladek  <pmladek@suse.cz>  [fdda0f1eba4ee46b80db14e548159ccaa163e678]
+
+	Fix check for old GNU patch tool (i#107027)
+
+	* patches/apply.pl.in: do not break with GNU patch-2.6
+
+2009-11-25  Kohei Yoshida  <kyoshida@novell.com>  [cdcdc572866fa23fd854f07cc5be6fcf18f5b4d1]
+
+	Speed up filtering performance in presence of cell notes.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-perf-filtering-with-notes.diff: set draw
+	  page size *only once* after the entire filtering operation is
+	  complete, instead of each time a single row is filtered.  This
+	  speeds up filtering speed considerably depending on how many rows
+	  get filtered and how many cell notes the sheet has.  With the
+	  test document I had the filtering time was reduced from 45 seconds
+	  to 0.66 seconds. (n#556927)
+
+2009-11-24  Kohei Yoshida  <kyoshida@novell.com>  [80ce47b0a454f3a1bb93c191f26c93056821375f]
+
+	Fixed incorrect import of sheet protection options.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-xls-import-sheet-protection-fix.diff:
+	  some xls documents have extra "feature header" records (where sheet
+	  protection options are stored) that stores no data at all, but
+	  we weren't checking the validity of each feature header record and
+	  importing everything.  That caused the sheet protection options
+	  to be imported incorrectly. (n#542024)
+
+2009-11-23  Kohei Yoshida  <kyoshida@novell.com>  [5309e978fc12de1f81f5c5991b96dcfe146fd0bb]
+
+	Removed unnecessary debug code that I forgot to remove.
+
+	* patches/dev300/calc-perf-speedup-pagebreak-update.diff:
+
+2009-11-23  Kohei Yoshida  <kyoshida@novell.com>  [ccca40848b685e1fbef2f33d8b16ebeb02d4618a]
+
+	Oops.   I applied the patch in the wrong section.
+
+	* patches/dev300/apply: moved the previous patch from
+	  CalcRowLimit to CalcExperimental.
+
+2009-11-23  Kohei Yoshida  <kyoshida@novell.com>  [085e933003c9f9f77336c46c214ba62d5adf5da4]
+
+	Speed up page break update to improve printing performance.
+
+	This patch is not enabled in the default build.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-perf-speedup-pagebreak-update.diff: refactored
+	  row height storage to use flat_segment_tree, and make use of it
+	  during page break update.  A document that used to take 7 minutes to
+	  print (99 page document) now only takes ~30 seconds. (n#554955)
+
+2009-11-23  Rene Engelhard  <rene@debian.org>  [c17fa6c8c90e76a6c3fff6744256ee5375039c7a]
+
+	ooo32gsl05 is nominated and contains the icc fix -> < ooo320-m6
+
+
+2009-11-23  Rene Engelhard  <rene@debian.org>  [7fb23b391ff7e2b70dbd84d9624a87142d8d5523]
+
+	add HPPA support from cws linuxhppa1
+
+
+2009-11-20  Kohei Yoshida  <kyoshida@novell.com>  [c89ee90243a7fc3c797073e0094f32b970db389c]
+
+	Fixed compiler errors and warnings with gcc 4.3.2.
+
+	* patches/dev300/calc-perf-flat-segment-tree.diff:
+
+2009-11-20  Kohei Yoshida  <kyoshida@novell.com>  [3d0f355b949bf881c7b69d98c73bd0b47e520684]
+
+	Updated flat_segment_tree implementation.
+
+	* patches/dev300/calc-perf-flat-segment-tree.diff: this update
+	  provides const iterators (forward and reverse) to iterate
+	  through the leaf nodes.  I need this bits for my experimental
+	  code in CalcExperimental section.  This should not affect the
+	  stable code since the stable code does not use the new
+	  iterators.
+
+2009-11-18  Noel Power  <noel.power@novell.com>  [6d98caa89f7be6aa42a7503f8d297f1ee792c8b4]
+
+	fix n#554261 ( find fails to wrap search when it fails )
+
+	* patches/dev300/apply:
+	* patches/vba/vba-fix-find-wraparound-onfail.diff: fix for n#554261, the Range.Find api can be specified with a cell ( in the range to search ) to start from, if the search fails then the search should be restarted from the begining of the range
+
+2009-11-13  Kohei Yoshida  <kyoshida@novell.com>  [c644d4aea9f87bf48bbb43a22ad41e4c4f6e6cfc]
+
+	Speed up row's hidden state lookup during pagenation.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-perf-page-and-manual-breaks-fwd-iterator.diff:
+	  speed up row's hidden state lookup when updating page breaks, which
+	  results in 40% performance improvement during printing. (n#554955)
+
+2009-11-12  Kohei Yoshida  <kyoshida@novell.com>  [0f971603409080e5136207f56f83db681b2ee70a]
+
+	Set rotate reference to bottom in presence of rotated text and border.
+
+	This fixes i#38709 and n#549728.  dr already fixed this for 3.3 in the
+	upstream build.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-xls-import-slanted-border-oox.diff: for xlsx
+	  import.
+
+	* patches/dev300/calc-xls-import-slanted-border.diff:
+	* patches/dev300/calc-xls-import-slanted-border-sc.diff: renamed.
+
+2009-11-12  Kohei Yoshida  <kyoshida@novell.com>  [06bcdf6420e39ef6aff6f313bc9626b9fdac6b06]
+
+	Fixed build breakage in sc (xlsx related).
+
+	* patches/dev300/apply:
+	* patches/dev300/xlsx-build-fix-m18.diff: renamed to the patch below.
+	* patches/dev300/xlsx-build-fix.diff: added new hunk to add new
+	  function definition added by the recent vba patch.
+
+2009-11-12  Rene Engelhard  <rene@debian.org>  [3733a84c4ee430bed9ef33379b61231e9b796846]
+
+	adapt icc-use-sal-endianness-and-types.diffs makefile.mk for 3.1.1
+
+	* patches/dev300/icc-use-sal-endianness-and-types.diff:
+
+2009-11-12  Rene Engelhard  <rene@debian.org>  [d3710ff30e264935d076a73a6f7dc69267f840a6]
+
+	apply xulrunner-1.9.1.diff for DebianOnly, too
+
+
+2009-11-12  Noel Power  <noel.power@novell.com>  [ff7c0716ba648499c2c06ac2fc85c73dcf71dac0]
+
+	add some fixes
+
+	* patches/dev300/apply:
+	* patches/vba/vba-fix-override-exportproblem.diff: fixes odd problem re-importing a roundtripped document that uses the rare hack of overriding the control name with that supplied in a funny attribute in the associated document module stream ( very rare problem )
+	* patches/vba/vba-fix-selection-dot-inproject.diff: fixes a couple of problems, a) some issues with resolving macros which use a project name ( that contains a '.' ) b) fixes selection of pasted range
+
+2009-11-10  Rene Engelhard  <rene@debian.org>  [15358d0ee4b92789d2ec9c58251eb16d3e8b23bd]
+
+	add icc fix from i#106523
+
+
+2009-11-04  Fong Lin  <pflin@novell.com>  [d3073b852e168f51e4368a8448ef7b758989000f]
+
+	Fix the background color of text frame and bullet indent issue. n#547308
+
+	* patches/dev300/apply:
+	* patches/dev300/sw-ww8-import-list-fix.diff:
+	* patches/dev300/sw-ww8-textframe-background-fix.diff:
+
+2009-11-03  Jan Nieuwenhuizen  <janneke@gnu.org>  [44fbd3921eb21d6526eb153046f0ad0a6811afa6]
+
+	Actually apply layout-listbox-line-count-move-copy-sheet.diff.  Fixes n#548091.
+
+	   * Modified     patches/dev300/apply
+
+2009-10-31  Kohei Yoshida  <kyoshida@novell.com>  [8a4d08ec440c3c5eaf664b5732eb79d2c6ed9896]
+
+	This is the correct fix for the previous paste-on-enter bug.
+
+	* patches/dev300/calc-paste-on-enter-crash-fix.diff: we should
+	  disable paste mode when the input mode is activated.
+	  (i#102456)
+
+2009-10-30  Kohei Yoshida  <kyoshida@novell.com>  [390b0ce544dfca09e36d6cf4f03f7d12b988af87]
+
+	Don't paste on enter while in edit mode.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-paste-on-enter-crash-fix.diff: fixes
+	  i#102456.
+
+2009-10-29  Radek Doulik  <rodo@novell.com>  [8c34432a931671efb7e2271205c3dafade1c5682]
+
+	backported change from dev320, fixes header/footer problem from n#549246
+
+	* patches/dev300/apply:
+	* patches/dev300/oox-pptx-import-fix-header-footer-backport.diff:
+
+2009-10-28  Noel Power  <npower@linux-h0uc.site>  [b27d86baee90a7ea690a7fa5aed9820ad0a9dbe0]
+
+	fix bnc bug number in comment
+
+	* patches/dev300/apply:
+
+2009-10-28  Noel Power  <npower@linux-h0uc.site>  [9aa5f574ed3bb8a2bef16dbd1256ee5503b43fc8]
+
+	add missing fixes for  bnc#542132, bnc#541749, bnc#541735
+
+	* patches/dev300/apply:
+	* patches/vba/vba-control-api-vis-fix.diff: fix for bnc#542132
+	* patches/vba/vba-fix-isempty.diff: bnc#541749
+	* patches/vba/vba-fix-wsfunction-booleanparam.diff: bnc#541735
+
+2009-10-27  Noel Power  <npower@linux-h0uc.site>  [3420f97f6708365828b5a5065db23c8718819c46]
+
+	I think it is safe to commit this, enable fix for n#549383
+
+	* patches/dev300/apply:
+
+2009-10-27  Noel Power  <npower@linux-h0uc.site>  [4569c0d0d7cc757d84c7b13b7e4c414be44ffa55]
+
+	add fix for  n#548383 ( commented out for now )
+
+	* patches/dev300/apply:
+	* patches/vba/vba-autofiltermode.diff:  add autofiltermode api
+
+2009-10-27  Kohei Yoshida  <kyoshida@novell.com>  [11abb457f18ebc3a3c0177b923cd1c8ba53903a4]
+
+	Set the reference edge of a cell to bottom when importing angled text.
+
+	* patches/dev300/apply:
+	* patches/dev300/calc-xls-import-slanted-border.diff: When importing
+	  cells with angled text from xls document, set the reference edge
+	  to 'bottom' so that the borders get slanted as well.
+	  (n#549728, i#38709)
+
+2009-10-23  Kohei Yoshida  <kyoshida@novell.com>  [7011943819078d380d4a92b64a967c2e645587f8]
+
+	Fixed incorrect pre-decimal digit calculation for values < 1.
+
+	* patches/dev300/calc-general-type-auto-decimal-svtools.diff:
+	  values less than 1.0 were incorrectly displayed in scientific
+	  notation where they should have been displayed in decimal
+	  notation.
+
+2009-10-22  Kohei Yoshida  <kyoshida@novell.com>  [a26eafc29fa094e14110661bbb63fd7b6d3a88e5]
+
+	Correct fix for the mirrored range selection bug in RTL mode.
+
+	* patches/dev300/calc-selection-fixed-cursor.diff: my previous fix
+	  only worked part of the time.  This is hopefully the correct fix.
+	  (n#542684)
+
+2009-10-22  Jan Nieuwenhuizen  <janneke@gnu.org>  [0c096ed1df62a99eb81bc618d042303017e49eee]
+
+	ListBox: fix line-count.  move-copy-sheet.xml: line-count="7".  Fixes n#548091.
+
+	   * Modified     patches/dev300/apply
+	   * Added        patches/dev300/layout-listbox-line-count-move-copy-sheet.diff
+
+2009-10-21  Cédric Bosdonnat  <cedricbosdo@openoffice.org>  [df43127e853b920b288a6156111e4a2150bbae42]
+
+	Fixed n#546416
+
+	The field end position wasn't written when two text fields were
+	consecutive.
+
+	* patches/dev300/field-patch.diff: fixed the field-patch.
+
+2009-10-21  Radek Doulik  <rodo@novell.com>  [9d4c66ae31d3ed224083dcc17ba07a9aee748c20]
+
+	fix crasher in xml parser
+
+	* patches/dev300/apply:
+	* patches/dev300/unoxml-fix-empty-xmlns.diff:
+
+2009-10-21  Petr Mladek  <pmladek@suse.cz>  [0faa11ae305ff3da585f73c692dbce0bad9b9beb]
 
 	Release ooo-build-3.1.1.4 (maintenance update; openSUSE-11.2-rc2)
 
 	* version 3.1.1.4  (maintenance update)
 	* tag OOO_BUILD_3_1_1_4
 
+2009-10-20  Rene Engelhard  <rene@debian.org>  [ae4d8d886a8a43fb69f501a42cb11b6df4a2d553]
+
+	add fpicker filter fix from launchpad.net/bugs/452518
+
+
 2009-10-20  Jan Nieuwenhuizen  <janneke@gnu.org>  [9c6f5fadc204bdc49ce058427af95de732e256e6]
 
 	Populate "Search in" with Formulas:Values:Notes.  Fixes n#548249.
diff -Nur ooo-build-3.1.1.4/configure ooo-build-3.1.1.5/configure
--- ooo-build-3.1.1.4/configure	2009-10-20 17:32:34.000000000 +0300
+++ ooo-build-3.1.1.5/configure	2009-11-26 18:06:20.000000000 +0200
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.63 for ooo-build 3.1.1.4.
+# Generated by GNU Autoconf 2.63 for ooo-build 3.1.1.5.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -594,8 +594,8 @@
 # Identity of this package.
 PACKAGE_NAME='ooo-build'
 PACKAGE_TARNAME='ooo-build'
-PACKAGE_VERSION='3.1.1.4'
-PACKAGE_STRING='ooo-build 3.1.1.4'
+PACKAGE_VERSION='3.1.1.5'
+PACKAGE_STRING='ooo-build 3.1.1.5'
 PACKAGE_BUGREPORT=''
 
 ac_unique_file="bin/build-ooo"
@@ -1455,7 +1455,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures ooo-build 3.1.1.4 to adapt to many kinds of systems.
+\`configure' configures ooo-build 3.1.1.5 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1521,7 +1521,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of ooo-build 3.1.1.4:";;
+     short | recursive ) echo "Configuration of ooo-build 3.1.1.5:";;
    esac
   cat <<\_ACEOF
 
@@ -1876,7 +1876,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-ooo-build configure 3.1.1.4
+ooo-build configure 3.1.1.5
 generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1890,7 +1890,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by ooo-build $as_me 3.1.1.4, which was
+It was created by ooo-build $as_me 3.1.1.5, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
@@ -2617,7 +2617,7 @@
 
 # Define the identity of the package.
  PACKAGE='ooo-build'
- VERSION='3.1.1.4'
+ VERSION='3.1.1.5'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2841,7 +2841,7 @@
 
 
 
-OOO_BUILDVERSION=3.1.1.4
+OOO_BUILDVERSION=3.1.1.5
 
 
 PROPAGATED_ARGS=$ac_configure_args
@@ -7571,7 +7571,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by ooo-build $as_me 3.1.1.4, which was
+This file was extended by ooo-build $as_me 3.1.1.5, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -7625,7 +7625,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-ooo-build config.status 3.1.1.4
+ooo-build config.status 3.1.1.5
 configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff -Nur ooo-build-3.1.1.4/configure.in ooo-build-3.1.1.5/configure.in
--- ooo-build-3.1.1.4/configure.in	2009-10-20 17:32:30.000000000 +0300
+++ ooo-build-3.1.1.5/configure.in	2009-11-26 18:06:14.000000000 +0200
@@ -1,4 +1,4 @@
-AC_INIT(ooo-build, 3.1.1.4)
+AC_INIT(ooo-build, 3.1.1.5)
 AC_PREREQ(2.51)
 AC_CONFIG_SRCDIR(bin/build-ooo)
 AC_PREFIX_DEFAULT(/usr)
diff -Nur ooo-build-3.1.1.4/NEWS ooo-build-3.1.1.5/NEWS
--- ooo-build-3.1.1.4/NEWS	2009-10-20 17:28:26.000000000 +0300
+++ ooo-build-3.1.1.5/NEWS	2009-11-26 17:36:25.000000000 +0200
@@ -1,3 +1,43 @@
+ooo-build-3.1.1.5 (maintenance update)
+
+    + features:
+	+ build on Linux hppa [Caolan, Rene]
+    + Common bits:
+	+ XML parser crasher [Radek]
+	+ broken colors in PDF export (i#106523) [Caolan, Rene]
+	+ “Move/Copy Sheet” dialogs scrolling (bnc#548091) [Jan]
+	+ select right export filters in KDE4 file picker (lp#452518,
+	  bnc#557585) [Matevž, Rene]
+    + Calc bits:
+	+ more on flat_segment_tree implementation [Kohei]
+	+ don't paste on enter while in edit mode (i#102456) [Kohei]
+	+ mirrored range selection bug in RTL mode (bnc#542684) [Kohei]
+    + Writer bits:
+	+ two consecutive fields DOC export (bnc#546416) [Cédric]
+	+ background color and bullet indentation DOC import (bnc#547308) [Fong]
+    + OOXML bits:
+	+ header/footer PPTX import (bnc#549246) [Radek]
+    + VBA bits:
+	+ override export problem [Noel]
+	+ selection of pasted range [Noel]
+	+ autofiltermode API (bnc#548383) [Noel]
+	+ resolving macros which use a project name [Noel]
+	+ non-working visibility for controls (bnc#542132) [Noel]
+	+ find fails to wrap search when it fails (bnc#554261) [Noel]
+	+ boolean arguments to worksheet functions fail (bnc#541735) [Noel]
+	+ IsEmpty RTL function fails with non-object params (bnc#541749) [Noel]
+    + build bits:
+	+ allow build with patch-2.6 (i#107027)
+    + Debian bits:
+	+ use xulrunner-1.9.1.diff [Rene]
+    + Experimental stuff:
+	+ cells with slanted text import (bnc#549728, i#38709) [Kohei]
+	+ page break update and printing performance (bnc#554955) [Kohei]
+	+ incorrect import of sheet protection options (bnc#542024) [Kohei]
+	+ more on automatic adjusting number of decimals (bnc#541973) [Kohei]
+	+ filtering performance in presence of cell notes (bnc#556927) [Kohei]
+	+ rot. text + border in XLS import (i#38709, bnc#549728) [Daniel,Kohei]
+
 ooo-build-3.1.1.4 (maintenance update)
 
     + Common bits:
diff -Nur ooo-build-3.1.1.4/patches/apply.pl.in ooo-build-3.1.1.5/patches/apply.pl.in
--- ooo-build-3.1.1.4/patches/apply.pl.in	2009-08-05 15:20:53.000000000 +0300
+++ ooo-build-3.1.1.5/patches/apply.pl.in	2009-11-26 15:41:26.000000000 +0200
@@ -920,11 +920,13 @@
 
     open ($Patch, "@GNUPATCH@ --version|") || die "Can't run patch: $!";
     $ver_line = <$Patch>;
-    $ver_line =~ m/\s+(\d+)\.(\d+)\.(\d+)/ || die "Can't get patch version\n";
-    if ($1 >= 2 && $2 >= 5 && $3 >= 9) {
+    $ver_line =~ m/\s+(\d+)\.(\d+)\.?(\d+)?/ || die "Can't get patch version\n";
+    if ( ( $1 > 2 ) ||
+         ( $1 == 2 && $2 > 5 ) ||
+         ( $1 == 2 && $2 == 5 && $3 >= 9 ) ) {
 	$is_old = 0;
     }
-    
+
     if ($is_old) {
 	print "Old patch version - pruning LFs\n";
     }
diff -Nur ooo-build-3.1.1.4/patches/dev300/apply ooo-build-3.1.1.5/patches/dev300/apply
--- ooo-build-3.1.1.4/patches/dev300/apply	2009-10-20 17:28:57.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/apply	2009-11-26 15:41:26.000000000 +0200
@@ -35,7 +35,7 @@
 	      UnitBootstrap, RadioButtons, UnstableLibwpd, WWInProgress, \
 	      KDE4Experimental, MinGW, CalcExperimental, Mono24, \
 	      OOXMLExportExperimental, CrossWin32Patches, AutoLayout, \
-	      OptionalIconThemes
+	      OptionalIconThemes, HPPA
 DebianLooseSections: DebianBaseNoHelpContent
 # Optional sections
 Optional : DejaVuFonts, NovellOnlyExtensionFixes, Win32OnlyExtensionFixes, Linux32OnlyExtensionFixes
@@ -74,7 +74,7 @@
 Slackware : LinuxCommon, SlackwareOnly, NotDebian, Mono, msaccess, CairoFonts
 # Debian
 DebianBase : LinuxCommon, DebianBaseOnly, Lockdown, GCCSTL, BerkeleyDB43, Split, PostgreSQL, MySQL, OptionalIconThemes
-Debian : DebianBase, DebianOnly, DebianSidOnly, Debian32Only, CairoFonts
+Debian : DebianBase, DebianOnly, DebianSidOnly, Debian32Only, CairoFonts, HPPA
 DebianEtch : DebianBase, DebianOnly, DebianEtchOnly, Debian32Only
 # Ubuntu
 UbuntuBased : DebianBase, UbuntuOnly
@@ -532,6 +532,10 @@
 # Password dialog - default is OK
 uui-passworddlg-ok-default.diff, i#102230, atimar
 
+[ Fixes < ooo320-m6 ]
+# fix icc
+icc-use-sal-endianness-and-types.diff, i#106523, n#467181
+
 [ RadioButtons ]
 forms-radio-button-group-names.diff, n#310052, i#30823, jonp
 # depends on forms-radio-button-group-names.diff,
@@ -760,6 +764,7 @@
 
 # Paste clipboard when ENTER is pressed, then clear clipboard.
 sc-paste-on-enter.diff, n#358545, i#28535, jonp
+calc-paste-on-enter-crash-fix.diff, i#102456, kohei
 
 # Support copy & pasting of non-contiguous region.
 calc-multi-range-copy-paste.diff, n#447003, i#25855, kohei
@@ -1523,8 +1528,6 @@
 gentoo-sandbox.diff
 # specific JVM search path
 jvm-search-path.diff
-# build against xulrunner 1.9.1+
-xulrunner-1.9.1.diff, ccheney
 
 [ DebianBaseOnly ]
 SectionOwner => rengelha
@@ -1537,6 +1540,9 @@
 disable-helpcontent2.diff
 disable-xmlsearch-and-xmlhelp-jar.diff
 
+[ DebianOnly ]
+# build against xulrunner 1.9.1+
+xulrunner-1.9.1.diff, ccheney
 
 [ Mono ]
 SectionOwner => rodo
@@ -1884,7 +1890,13 @@
 vba-financial-functions.diff, n#525633, n#525635, n#525642, n#525647, 
 vba-typename-fix.diff, n#525649
 vba-reenable-rowsourcefixes.diff, n#540960
-
+vba-autofiltermode.diff, n#549383
+vba-control-api-vis-fix.diff, bnc#542132
+vba-fix-isempty.diff, bnc#541749 
+vba-fix-wsfunction-booleanparam.diff, bnc#541735
+vba-fix-selection-dot-inproject.diff
+vba-fix-override-exportproblem.diff
+vba-fix-find-wraparound-onfail.diff. n#554261
 [VBAUntested]
 SectionOwner => noelpwer
 # doesn't work
@@ -2469,6 +2481,7 @@
 layout-parallel-build.diff
 
 layout-calc-advanced-search-in.diff, n#548249, janneke
+layout-listbox-line-count-move-copy-sheet.diff, n#548091, janneke
 
 [ FrameworkFeature ]
 SectionOwner => kohei
@@ -2834,6 +2847,11 @@
 # TODO file up-stream
 lockfile-less-symbols.diff, jholesov
 
+# fix incorrect background color of text frame
+sw-ww8-textframe-background-fix.diff, Fong, n#547308
+# fix the bullet indent issue
+sw-ww8-import-list-fix.diff, Fong, n#547308
+
 [ InternalMesaHeaders ]
 internal-mesa-headers-config_office.diff, fridrich
 internal-mesa-headers-slideshow.diff, fridrich
@@ -3160,8 +3178,8 @@
 # update with the changes introduced up to m17
 xlsx-filter-as-a-separate-lib-m17-update.diff
 
-# build fix for m18 and up
-xlsx-build-fix-m18.diff, kohei
+# build fix
+xlsx-build-fix.diff, kohei
 
 # tweak to above ( associated with vba-fallback-to-calling-doc-context.diff )
 xlsx-separate-lib-vba-fallback-tweak.diff
@@ -3275,6 +3293,7 @@
 # less than 1000.
 calc-perf-rowheight-no-progress-bar.diff, n#514156, kohei
 
+
 [ OOXMLExport ]
 oox-calc-export-row-limit.diff, n#504623, janneke.
 
@@ -3448,6 +3467,23 @@
 # Correctly encrypt zero bytes in the conditional formatting records.
 calc-xls-export-encryption-condfmt-fix.diff, n#541058, kohei
 
+# Set reference edge to bottom when importing cells with slanted text.
+calc-xls-import-slanted-border-sc.diff,  n#549728, i#38709, kohei
+calc-xls-import-slanted-border-oox.diff, n#549728, i#38709, kohei
+
+# Fix incorrect import of sheet protection options.
+calc-xls-import-sheet-protection-fix.diff, n#542024, kohei
+
+# Speed up filtering performance with notes.
+calc-perf-filtering-with-notes.diff, n#556927, kohei
+
+[ CalcExperimental and CalcRowLimit ]
+# speed up row's hidden state query during pagenation.
+calc-perf-page-and-manual-breaks-fwd-iterator.diff, n#503482, kohei
+
+# Refactor row height storage to speed up page break updates.
+calc-perf-speedup-pagebreak-update.diff, n#554955, kohei
+
 [ AutoLayout ]
 sd-layoutcode.diff, cocofan
 offapi-layoutcode.diff, cocofan
@@ -3474,3 +3510,9 @@
 sd-print-fix-pageoffset.diff, n#537931, rodo
 svx-ppt-import-fix-bullet-size.diff, n#515972, rodo
 sd-ppt-fix-document-summary-reading.diff, n#546758, rodo
+# fixes crasher in xml parser
+unoxml-fix-empty-xmlns.diff, rodo
+oox-pptx-import-fix-header-footer-backport.diff, n#549246, rodo
+
+[ HPPA ]
+cws-linuxhppa1.diff, i#107051
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-general-type-auto-decimal-svtools.diff ooo-build-3.1.1.5/patches/dev300/calc-general-type-auto-decimal-svtools.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-general-type-auto-decimal-svtools.diff	2009-10-19 22:18:28.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/calc-general-type-auto-decimal-svtools.diff	2009-11-23 16:47:56.000000000 +0200
@@ -214,7 +214,7 @@
  }
  
  void SvNumberformat::ImpGetOutputInputLine(double fNumber, String& OutString)
-@@ -1958,6 +1979,62 @@ ULONG SvNumberformat::ImpGGTRound(ULONG x, ULONG y)
+@@ -1958,6 +1979,65 @@ ULONG SvNumberformat::ImpGGTRound(ULONG x, ULONG y)
      }
  }
  
@@ -251,7 +251,10 @@
 +    if (bSign)
 +        fTestNum = -fTestNum;
 +
-+    sal_uInt16 nDigitPre = static_cast<sal_uInt16>(ceil(log10(fTestNum)));
++    double fExp = log10(fTestNum);
++    // Values < 1.0 always have one digit before the decimal point.
++    sal_uInt16 nDigitPre = fExp >= 0.0 ? static_cast<sal_uInt16>(ceil(fExp)) : 1;
++
 +    if (nDigitPre > 15)
 +    {
 +        lcl_GetOutputStringScientific(fNumber, nCharCount, GetFormatter(), rOutString);
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-paste-on-enter-crash-fix.diff ooo-build-3.1.1.5/patches/dev300/calc-paste-on-enter-crash-fix.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-paste-on-enter-crash-fix.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-paste-on-enter-crash-fix.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,15 @@
+diff --git sc/source/ui/app/inputhdl.cxx sc/source/ui/app/inputhdl.cxx
+index e5d46e5..2e450dd 100644
+--- sc/source/ui/app/inputhdl.cxx
++++ sc/source/ui/app/inputhdl.cxx
+@@ -2275,6 +2275,10 @@ void ScInputHandler::SetMode( ScInputMode eNewMode )
+         return;
+     }
+ 
++    if (eNewMode != SC_INPUT_NONE)
++        // Disable paste mode when edit mode starts.
++        pActiveViewSh->GetViewData()->SetPasteMode( SC_PASTE_NONE );
++
+     bInOwnChange = TRUE;				// disable ModifyHdl (reset below)
+ 
+     ScInputMode eOldMode = eMode;
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-perf-filtering-with-notes.diff ooo-build-3.1.1.5/patches/dev300/calc-perf-filtering-with-notes.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-perf-filtering-with-notes.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-perf-filtering-with-notes.diff	2009-11-26 15:41:26.000000000 +0200
@@ -0,0 +1,35 @@
+diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
+index c3ee408..86e9e1d 100644
+--- sc/source/core/data/table2.cxx
++++ sc/source/core/data/table2.cxx
+@@ -2500,7 +2500,6 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
+ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
+ {
+     SCROW nStartRow = nRow1;
+-    nRecalcLvl++;
+     while (nStartRow <= nRow2)
+     {
+         SCROW nEndRow = -1;
+@@ -2540,9 +2539,6 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
+     //	to be done here.
+     if (pOutlineTable)
+         UpdateOutlineRow( nRow1, nRow2, bShow );
+-
+-    if( !--nRecalcLvl )
+-        SetDrawPageSize();
+ }
+ 
+ 
+diff --git sc/source/core/data/table3.cxx sc/source/core/data/table3.cxx
+index 6da3d50..20b4f49 100644
+--- sc/source/core/data/table3.cxx
++++ sc/source/core/data/table3.cxx
+@@ -1648,6 +1648,8 @@ SCSIZE ScTable::Query(ScQueryParam& rParamOrg, BOOL bKeepSub)
+ 
+     delete[] pSpecial;
+ 
++    SetDrawPageSize();
++
+     return nCount;
+ }
+ 
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-perf-flat-segment-tree.diff ooo-build-3.1.1.5/patches/dev300/calc-perf-flat-segment-tree.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-perf-flat-segment-tree.diff	2009-09-30 14:37:42.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/calc-perf-flat-segment-tree.diff	2009-11-23 16:47:56.000000000 +0200
@@ -1,9 +1,9 @@
 diff --git sc/inc/mdds/flatsegmenttree.hxx sc/inc/mdds/flatsegmenttree.hxx
 new file mode 100644
-index 0000000..96a6256
+index 0000000..40a912a
 --- /dev/null
 +++ sc/inc/mdds/flatsegmenttree.hxx
-@@ -0,0 +1,815 @@
+@@ -0,0 +1,956 @@
 +/*************************************************************************
 + *
 + * Copyright (c) 2008-2009 Kohei Yoshida
@@ -35,6 +35,7 @@
 +#define __MDDS_FLATSEGMENTTREE_HXX__
 +
 +#include <iostream>
++#include <utility>
 +#include <cassert>
 +
 +#include "node.hxx"
@@ -131,6 +132,146 @@
 +        }
 +    };
 +
++private:
++    class const_iterator_base
++    {
++    public:
++        typedef flat_segment_tree<key_type, value_type> fst_type;
++
++        explicit const_iterator_base(const fst_type* _db, bool _end, bool _forward) : 
++            m_db(_db), m_pos(NULL), m_end_pos(_end), m_forward(_forward)
++        {
++            if (!_db)
++                return;
++
++            if (m_forward)
++            {
++                // forward direction
++                m_pos = _end ? get_node(_db->m_right_leaf) : get_node(_db->m_left_leaf);
++            }
++            else
++            {
++                // reverse direction
++                m_pos = _end ? get_node(_db->m_left_leaf) : get_node(_db->m_right_leaf);
++            }
++        }
++
++        const_iterator_base(const const_iterator_base& r) :
++            m_db(r.m_db), m_pos(r.m_pos), m_end_pos(r.m_end_pos), m_forward(r.m_forward) {}
++
++        const_iterator_base& operator=(const const_iterator_base& r)
++        {
++            m_db = r.m_db;
++            m_pos = r.m_pos;
++            return *this;
++        }
++
++        void operator++()
++        {
++            assert(m_pos);
++            if (m_forward)
++            {
++                if (m_pos == get_node(m_db->m_right_leaf))
++                    m_end_pos = true;
++                else
++                    m_pos = get_node(m_pos->right);
++            }
++            else
++            {
++                if (m_pos == get_node(m_db->m_left_leaf))
++                    m_end_pos = true;
++                else
++                    m_pos = get_node(m_pos->left);
++            }
++        }
++
++        void operator--()
++        {
++            assert(m_pos);
++            if (m_end_pos)
++                m_end_pos = false;
++            else
++                m_pos = m_forward ? get_node(m_pos->left) : get_node(m_pos->right);
++        }
++
++        bool operator==(const const_iterator_base& r) const
++        {
++            return (m_end_pos == r.m_end_pos) && (m_pos == r.m_pos);
++        }
++
++        bool operator!=(const const_iterator_base& r) const
++        {
++            return !operator==(r);
++        }
++
++        const ::std::pair<key_type, value_type>& operator*()
++        {
++            return get_current_node_pair();
++        }
++
++        const ::std::pair<key_type, value_type>* operator->()
++        {
++            return &get_current_node_pair();
++        }
++
++    private:
++        const ::std::pair<key_type, value_type>& get_current_node_pair()
++        {
++            m_current_pair = ::std::pair<key_type, value_type>(m_pos->value_leaf.key, m_pos->value_leaf.value);
++            return m_current_pair;
++        }
++
++        const fst_type* m_db;
++        const typename fst_type::node* m_pos;
++        ::std::pair<key_type, value_type> m_current_pair;
++        bool            m_end_pos:1;
++        bool            m_forward:1;
++    };
++
++public:
++    class const_iterator : public const_iterator_base
++    {
++        friend class flat_segment_tree;
++    public:
++        const_iterator() :
++            const_iterator_base(NULL, false, true) {}
++
++    private:
++        explicit const_iterator(typename const_iterator_base::fst_type* _db, bool _end) : 
++            const_iterator_base(_db, _end, true) {}
++    };
++
++    class const_reverse_iterator : public const_iterator_base
++    {
++        friend class flat_segment_tree;
++    public:
++        const_reverse_iterator() :
++            const_iterator_base(NULL, false, false) {}
++    private:
++        explicit const_reverse_iterator(typename const_iterator_base::fst_type* _db, bool _end) : 
++            const_iterator_base(_db, _end, false) {}
++    };
++
++    const_iterator begin()
++    {
++        return const_iterator(this, false);
++    }
++
++    const_iterator end()
++    {
++        return const_iterator(this, true);
++    }
++
++    const_reverse_iterator rbegin()
++    {
++        return const_reverse_iterator(this, false);
++    }
++
++    const_reverse_iterator rend()
++    {
++        return const_reverse_iterator(this, true);
++    }
++
 +    /** 
 +     * Get a pointer of concrete node type from the base pointer.
 +     *
@@ -179,38 +320,38 @@
 +    /** 
 +     * Insert a new segment into the tree.
 +     *
-+     * @param start start value of the segment being inserted.  The value is 
-+     *              inclusive.
-+     * @param end end value of the segment being inserted.  The value is not 
-+     *            inclusive.
++     * @param start_key start value of the segment being inserted.  The value 
++     *              is inclusive.
++     * @param end_key end value of the segment being inserted.  The value is 
++     *            not inclusive.
 +     * @param val value associated with this segment.
 +     */
-+    void insert_segment(key_type start, key_type end, value_type val)
++    void insert_segment(key_type start_key, key_type end_key, value_type val)
 +    {
-+        if (end < get_node(m_left_leaf)->value_leaf.key || start > get_node(m_right_leaf)->value_leaf.key)
++        if (end_key < get_node(m_left_leaf)->value_leaf.key || start_key > get_node(m_right_leaf)->value_leaf.key)
 +            // The new segment does not overlap the current interval.
 +            return;
 +
-+        if (start < get_node(m_left_leaf)->value_leaf.key)
++        if (start_key < get_node(m_left_leaf)->value_leaf.key)
 +            // The start value should not be smaller than the current minimum.
-+            start = get_node(m_left_leaf)->value_leaf.key;
++            start_key = get_node(m_left_leaf)->value_leaf.key;
 +
-+        if (end > get_node(m_right_leaf)->value_leaf.key)
++        if (end_key > get_node(m_right_leaf)->value_leaf.key)
 +            // The end value should not be larger than the current maximum.
-+            end = get_node(m_right_leaf)->value_leaf.key;
++            end_key = get_node(m_right_leaf)->value_leaf.key;
 +
-+        if (start >= end)
++        if (start_key >= end_key)
 +            return;
 +
 +        // Find the node with value that either equals or is greater than the
 +        // start value.
 +
-+        node_base_ptr start_pos = get_insertion_pos_leaf(start, m_left_leaf);
++        node_base_ptr start_pos = get_insertion_pos_leaf(start_key, m_left_leaf);
 +        if (!start_pos)
 +            // Insertion position not found.  Bail out.
 +            return;
 +
-+        node_base_ptr end_pos = get_insertion_pos_leaf(end, start_pos);
++        node_base_ptr end_pos = get_insertion_pos_leaf(end_key, start_pos);
 +        if (!end_pos)
 +            end_pos = m_right_leaf;
 +
@@ -219,7 +360,7 @@
 +
 +        // Set the start node.
 +
-+        if (get_node(start_pos)->value_leaf.key == start)
++        if (get_node(start_pos)->value_leaf.key == start_key)
 +        {
 +            // Re-use the existing node, but save the old value for later.
 +
@@ -247,7 +388,7 @@
 +        {
 +            // Insert a new node before the insertion position node.
 +            node_base_ptr new_node(new node(true));
-+            get_node(new_node)->value_leaf.key = start;
++            get_node(new_node)->value_leaf.key = start_key;
 +            get_node(new_node)->value_leaf.value = val;
 +            new_start_node = new_node;
 +
@@ -274,7 +415,7 @@
 +
 +        // Set the end node.
 +
-+        if (get_node(end_pos)->value_leaf.key == end)
++        if (get_node(end_pos)->value_leaf.key == end_key)
 +        {
 +            // The new segment ends exactly at the end node position.
 +
@@ -302,7 +443,7 @@
 +        {
 +            // Insert a new node before the insertion position node.
 +            node_base_ptr new_node(new node(true));
-+            get_node(new_node)->value_leaf.key = end;
++            get_node(new_node)->value_leaf.key = end_key;
 +            get_node(new_node)->value_leaf.value = old_value;
 +
 +            // Link to the left node.
@@ -324,43 +465,43 @@
 +     * @param start start position of the segment being removed.
 +     * @param end end position of the segment being removed. 
 +     */
-+    void shift_segment_left(key_type start, key_type end)
++    void shift_segment_left(key_type start_key, key_type end_key)
 +    {
-+        if (start >= end)
++        if (start_key >= end_key)
 +            return;
 +
 +        key_type left_leaf_key = get_node(m_left_leaf)->value_leaf.key;
 +        key_type right_leaf_key = get_node(m_right_leaf)->value_leaf.key;
-+        if (start < left_leaf_key || end < left_leaf_key)
++        if (start_key < left_leaf_key || end_key < left_leaf_key)
 +            // invalid key value
 +            return;
 +
-+        if (start > right_leaf_key || end > right_leaf_key)
++        if (start_key > right_leaf_key || end_key > right_leaf_key)
 +            // invalid key value.
 +            return;
 +
 +        node_base_ptr node_pos;
-+        if (left_leaf_key == start)
++        if (left_leaf_key == start_key)
 +            node_pos = m_left_leaf;
 +        else
 +            // Get the first node with a key value equal to or greater than the 
 +            // start key value.  But we want to skip the leftmost node.
-+            node_pos = get_insertion_pos_leaf(start, m_left_leaf->right);
++            node_pos = get_insertion_pos_leaf(start_key, m_left_leaf->right);
 +
 +        if (!node_pos)
 +            return;
 +
-+        key_type segment_size = end - start;
++        key_type segment_size = end_key - start_key;
 +
 +        if (node_pos == m_right_leaf)
 +        {
 +            // The segment being removed begins after the last node before the 
 +            // right-most node.
 +
-+            if (right_leaf_key <= end)
++            if (right_leaf_key <= end_key)
 +            {
 +                // The end position equals or is past the right-most node.
-+                append_new_segment(start);
++                append_new_segment(start_key);
 +            }
 +            else
 +            {
@@ -371,7 +512,7 @@
 +            return;
 +        }
 +
-+        if (end < get_node(node_pos)->value_leaf.key)
++        if (end_key < get_node(node_pos)->value_leaf.key)
 +        {
 +            // The removed segment does not overlap with any nodes.  Simply 
 +            // shift the key values of those nodes that come after the removed
@@ -384,11 +525,11 @@
 +
 +        // Move the first node to the starting position, and from there search
 +        // for the first node whose key value is greater than the end value.
-+        get_node(node_pos)->value_leaf.key = start;
++        get_node(node_pos)->value_leaf.key = start_key;
 +        node_base_ptr start_pos = node_pos;
 +        node_pos = node_pos->right;
 +        value_type last_seg_value = get_node(start_pos)->value_leaf.value;
-+        while (get_node(node_pos) != get_node(m_right_leaf) && get_node(node_pos)->value_leaf.key <= end)
++        while (get_node(node_pos) != get_node(m_right_leaf) && get_node(node_pos)->value_leaf.key <= end_key)
 +        {
 +            last_seg_value = get_node(node_pos)->value_leaf.value;
 +            node_base_ptr next = node_pos->right;
@@ -474,7 +615,7 @@
 +        m_valid_tree = false;
 +    }
 +
-+    bool search(key_type key, value_type& value, key_type* start = NULL, key_type* end = NULL) const
++    bool search(key_type key, value_type& value, key_type* start_key = NULL, key_type* end_key = NULL) const
 +    {
 +        if (key < get_node(m_left_leaf)->value_leaf.key || get_node(m_right_leaf)->value_leaf.key <= key)
 +            // key value is out-of-bound.
@@ -484,26 +625,26 @@
 +        if (pos->value_leaf.key == key)
 +        {
 +            value = pos->value_leaf.value;
-+            if (start)
-+                *start = pos->value_leaf.key;
-+            if (end && pos->right)
-+                *end = get_node(pos->right)->value_leaf.key;
++            if (start_key)
++                *start_key = pos->value_leaf.key;
++            if (end_key && pos->right)
++                *end_key = get_node(pos->right)->value_leaf.key;
 +            return true;
 +        }
 +        else if (pos->left && get_node(pos->left)->value_leaf.key < key)
 +        {
 +            value = get_node(pos->left)->value_leaf.value;
-+            if (start)
-+                *start = get_node(pos->left)->value_leaf.key;
-+            if (end)
-+                *end = pos->value_leaf.key;
++            if (start_key)
++                *start_key = get_node(pos->left)->value_leaf.key;
++            if (end_key)
++                *end_key = pos->value_leaf.key;
 +            return true;
 +        }
 +
 +        return false;
 +    }
 +
-+    bool search_tree(key_type key, value_type& value, key_type* start = NULL, key_type* end = NULL) const
++    bool search_tree(key_type key, value_type& value, key_type* start_key = NULL, key_type* end_key = NULL) const
 +    {
 +        if (!m_root_node || !m_valid_tree)
 +        {    
@@ -574,17 +715,17 @@
 +        }
 +
 +        value = cur_node->value_leaf.value;
-+        if (start)
-+            *start = cur_node->value_leaf.key;
++        if (start_key)
++            *start_key = cur_node->value_leaf.key;
 +
-+        if (end)
++        if (end_key)
 +        {
 +            assert(cur_node->right);
 +            if (cur_node->right)
-+                *end = get_node(cur_node->right)->value_leaf.key;
++                *end_key = get_node(cur_node->right)->value_leaf.key;
 +            else
 +                // This should never happen, but just in case....
-+                *end = get_node(m_right_leaf)->value_leaf.key;
++                *end_key = get_node(m_right_leaf)->value_leaf.key;
 +        }
 +
 +        return true;
@@ -708,9 +849,9 @@
 +private:
 +    flat_segment_tree();
 +
-+    void append_new_segment(key_type start)
++    void append_new_segment(key_type start_key)
 +    {
-+        if (get_node(m_right_leaf->left)->value_leaf.key == start)
++        if (get_node(m_right_leaf->left)->value_leaf.key == start_key)
 +        {
 +            get_node(m_right_leaf->left)->value_leaf.value = m_init_val;
 +            return;
@@ -719,7 +860,7 @@
 +#ifdef UNIT_TEST
 +        // The start position must come after the position of the last node 
 +        // before the right-most node.
-+        assert(get_node(m_right_leaf->left)->value_leaf.key < start);        
++        assert(get_node(m_right_leaf->left)->value_leaf.key < start_key);        
 +#endif
 +
 +        if (get_node(m_right_leaf->left)->value_leaf.value == m_init_val)
@@ -728,7 +869,7 @@
 +            return;
 +
 +        node_base_ptr new_node(new node(true));
-+        get_node(new_node)->value_leaf.key   = start;
++        get_node(new_node)->value_leaf.key   = start_key;
 +        get_node(new_node)->value_leaf.value = m_init_val;
 +        new_node->left = m_right_leaf->left;
 +        new_node->right = m_right_leaf;
@@ -1228,22 +1369,22 @@
 +
 +#endif
 diff --git sc/source/core/data/makefile.mk sc/source/core/data/makefile.mk
-index c631bb4..5fbec41 100644
+index b177f20..4ac58a9 100644
 --- sc/source/core/data/makefile.mk
 +++ sc/source/core/data/makefile.mk
 @@ -102,6 +102,7 @@ SLOFILES =  \
  	$(SLO)$/phonetic.obj \
- 	$(SLO)$/poolhelp.obj \
- 	$(SLO)$/scimpexpmsg.obj \
+     $(SLO)$/poolhelp.obj \
+     $(SLO)$/scimpexpmsg.obj \
 +	$(SLO)$/segmenttree.obj \
- 	$(SLO)$/sortparam.obj \
- 	$(SLO)$/stlpool.obj \
- 	$(SLO)$/stlsheet.obj \
+     $(SLO)$/sortparam.obj \
+     $(SLO)$/stlpool.obj \
+     $(SLO)$/stlsheet.obj \
 @@ -147,7 +148,8 @@ EXCEPTIONSFILES= \
- 	$(SLO)$/dbdocutl.obj \
- 	$(SLO)$/dptabsrc.obj \
- 	$(SLO)$/drwlayer.obj \
--	$(SLO)$/globalx.obj
+     $(SLO)$/dbdocutl.obj \
+     $(SLO)$/dptabsrc.obj \
+     $(SLO)$/drwlayer.obj \
+-    $(SLO)$/globalx.obj
 +	$(SLO)$/globalx.obj \
 +	$(SLO)$/segmenttree.obj
  
@@ -1480,4 +1621,3 @@
 +{
 +    mpImpl->insertSegment(static_cast<SCCOLROW>(nCol), static_cast<SCCOLROW>(nSize), bSkipStartBoundary);
 +}
-
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-perf-page-and-manual-breaks-fwd-iterator.diff ooo-build-3.1.1.5/patches/dev300/calc-perf-page-and-manual-breaks-fwd-iterator.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-perf-page-and-manual-breaks-fwd-iterator.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-perf-page-and-manual-breaks-fwd-iterator.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,86 @@
+diff --git sc/inc/segmenttree.hxx sc/inc/segmenttree.hxx
+index 466f9ed..64ba898 100644
+--- sc/inc/segmenttree.hxx
++++ sc/inc/segmenttree.hxx
+@@ -46,6 +46,22 @@ public:
+         SCROW   mnRow2;
+         bool    mbValue;
+     };
++
++    class ForwardIterator
++    {
++    public:
++        explicit ForwardIterator(ScFlatBoolRowSegments& rSegs);
++
++        bool getValue(SCROW nPos, bool& rVal);
++
++    private:
++        ScFlatBoolRowSegments&  mrSegs;
++
++        SCROW   mnCurPos;
++        SCROW   mnLastPos;
++        bool    mbCurValue;
++    };
++
+     ScFlatBoolRowSegments();
+     ~ScFlatBoolRowSegments();
+ 
+diff --git sc/source/core/data/segmenttree.cxx sc/source/core/data/segmenttree.cxx
+index be8e408..0ee889b 100644
+--- sc/source/core/data/segmenttree.cxx
++++ sc/source/core/data/segmenttree.cxx
+@@ -130,6 +130,34 @@ void ScFlatBoolSegmentsImpl::insertSegment(SCCOLROW nPos, SCCOLROW nSize, bool b
+ 
+ // ============================================================================
+ 
++ScFlatBoolRowSegments::ForwardIterator::ForwardIterator(ScFlatBoolRowSegments& rSegs) :
++    mrSegs(rSegs), mnCurPos(0), mnLastPos(-1), mbCurValue(false)
++{
++}
++
++bool ScFlatBoolRowSegments::ForwardIterator::getValue(SCROW nPos, bool& rVal)
++{
++    if (nPos >= mnCurPos)
++        // It can only go in a forward direction.
++        mnCurPos = nPos;
++
++    if (mnCurPos > mnLastPos)
++    {
++        // position not in the current segment.  Update the current value.
++        ScFlatBoolRowSegments::RangeData aData;
++        if (!mrSegs.getRangeData(mnCurPos, aData))
++            return false;
++    
++        mbCurValue = aData.mbValue;
++        mnLastPos = aData.mnRow2;
++    }
++
++    rVal = mbCurValue;
++    return true;
++}
++
++// ----------------------------------------------------------------------------
++
+ ScFlatBoolRowSegments::ScFlatBoolRowSegments() :
+     mpImpl(new ScFlatBoolSegmentsImpl(static_cast<SCCOLROW>(MAXROW)))
+ {
+diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
+index 7e7cab9..4d28ff2 100644
+--- sc/source/core/data/table5.cxx
++++ sc/source/core/data/table5.cxx
+@@ -203,10 +203,14 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
+     BOOL bRepeatRow = ( nRepeatStartY != SCROW_REPEAT_NONE );
+     BOOL bRowFound = FALSE;
+     long nSizeY = 0;
++    ScFlatBoolRowSegments::ForwardIterator aIter(*mpHiddenRows);
+     for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
+     {
+         BOOL bStartOfPage = FALSE;
+-        long nThisY = RowHidden(nY) ? 0 : pRowHeight->GetValue(nY);
++        bool bThisRowHidden = false;
++        aIter.getValue(nY, bThisRowHidden);
++        long nThisY = bThisRowHidden ? 0 : pRowHeight->GetValue(nY);
++
+         bool bManualBreak = HasRowManualBreak(nY);
+ 		if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
+         {
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-perf-speedup-pagebreak-update.diff ooo-build-3.1.1.5/patches/dev300/calc-perf-speedup-pagebreak-update.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-perf-speedup-pagebreak-update.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-perf-speedup-pagebreak-update.diff	2009-11-26 15:41:26.000000000 +0200
@@ -0,0 +1,1272 @@
+diff --git sc/inc/document.hxx sc/inc/document.hxx
+index 8d28d82..26d19a9 100644
+--- sc/inc/document.hxx
++++ sc/inc/document.hxx
+@@ -1237,7 +1237,6 @@ public:
+     SC_DLLPUBLIC USHORT			GetRowHeight( SCROW nRow, SCTAB nTab ) const;
+     SC_DLLPUBLIC ULONG			GetRowHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab ) const;
+     ULONG			GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, SCTAB nTab, double fScale ) const;
+-    SC_DLLPUBLIC const ScSummableCompressedArray< SCROW, USHORT> & GetRowHeightArray( SCTAB nTab ) const;
+     SC_DLLPUBLIC ULONG			GetColOffset( SCCOL nCol, SCTAB nTab ) const;
+     SC_DLLPUBLIC ULONG			GetRowOffset( SCROW nRow, SCTAB nTab ) const;
+ 
+@@ -1257,9 +1256,6 @@ public:
+                         SCTAB nTab, double fScale ) const;
+     SC_DLLPUBLIC inline USHORT	FastGetRowHeight( SCROW nRow, SCTAB nTab ) const;
+     inline SCROW	FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const;
+-                    /** No check for flags whether row is hidden, height value
+-                        is returned unconditionally. */
+-    inline USHORT   FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const;
+ 
+     SCROW			GetHiddenRowCount( SCROW nRow, SCTAB nTab ) const;
+ 
+@@ -1848,11 +1844,6 @@ inline SCROW ScDocument::FastGetRowForHeight( SCTAB nTab, ULONG nHeight ) const
+ {
+     return pTab[nTab]->GetRowForHeight(nHeight);
+ }
+-
+-inline USHORT ScDocument::FastGetOriginalRowHeight( SCROW nRow, SCTAB nTab ) const
+-{
+-    return pTab[nTab]->pRowHeight->GetValue(nRow);
+-}
+  
+ #endif
+ 
+diff --git sc/inc/mdds/flatsegmenttree.hxx sc/inc/mdds/flatsegmenttree.hxx
+index 40a912a..23dfc04 100644
+--- sc/inc/mdds/flatsegmenttree.hxx
++++ sc/inc/mdds/flatsegmenttree.hxx
+@@ -160,7 +160,7 @@ private:
+             return *this;
+         }
+ 
+-        void operator++()
++        const ::std::pair<key_type, value_type>* operator++()
+         {
+             assert(m_pos);
+             if (m_forward)
+@@ -177,15 +177,19 @@ private:
+                 else
+                     m_pos = get_node(m_pos->left);
+             }
++
++            return operator->();
+         }
+ 
+-        void operator--()
++        const ::std::pair<key_type, value_type>* operator--()
+         {
+             assert(m_pos);
+             if (m_end_pos)
+                 m_end_pos = false;
+             else
+                 m_pos = m_forward ? get_node(m_pos->left) : get_node(m_pos->right);
++
++            return operator->();
+         }
+ 
+         bool operator==(const const_iterator_base& r) const
+@@ -231,7 +235,7 @@ public:
+             const_iterator_base(NULL, false, true) {}
+ 
+     private:
+-        explicit const_iterator(typename const_iterator_base::fst_type* _db, bool _end) : 
++        explicit const_iterator(const typename const_iterator_base::fst_type* _db, bool _end) : 
+             const_iterator_base(_db, _end, true) {}
+     };
+ 
+@@ -242,26 +246,26 @@ public:
+         const_reverse_iterator() :
+             const_iterator_base(NULL, false, false) {}
+     private:
+-        explicit const_reverse_iterator(typename const_iterator_base::fst_type* _db, bool _end) : 
++        explicit const_reverse_iterator(const typename const_iterator_base::fst_type* _db, bool _end) : 
+             const_iterator_base(_db, _end, false) {}
+     };
+ 
+-    const_iterator begin()
++    const_iterator begin() const
+     {
+         return const_iterator(this, false);
+     }
+ 
+-    const_iterator end()
++    const_iterator end() const
+     {
+         return const_iterator(this, true);
+     }
+ 
+-    const_reverse_iterator rbegin()
++    const_reverse_iterator rbegin() const
+     {
+         return const_reverse_iterator(this, false);
+     }
+ 
+-    const_reverse_iterator rend()
++    const_reverse_iterator rend() const
+     {
+         return const_reverse_iterator(this, true);
+     }
+diff --git sc/inc/segmenttree.hxx sc/inc/segmenttree.hxx
+index 64ba898..9b9d753 100644
+--- sc/inc/segmenttree.hxx
++++ sc/inc/segmenttree.hxx
+@@ -53,6 +53,7 @@ public:
+         explicit ForwardIterator(ScFlatBoolRowSegments& rSegs);
+ 
+         bool getValue(SCROW nPos, bool& rVal);
++        SCROW getLastPos() const;
+ 
+     private:
+         ScFlatBoolRowSegments&  mrSegs;
+@@ -101,5 +102,50 @@ private:
+     ::std::auto_ptr<ScFlatBoolSegmentsImpl> mpImpl;
+ };
+ 
++// ============================================================================
++
++class ScFlatUInt16SegmentsImpl;
++
++class ScFlatUInt16RowSegments
++{
++public:
++    struct RangeData
++    {
++        SCROW       mnRow1;
++        SCROW       mnRow2;
++        sal_uInt16  mnValue;
++    };
++
++    class ForwardIterator
++    {
++    public:
++        explicit ForwardIterator(ScFlatUInt16RowSegments& rSegs);
++
++        bool getValue(SCROW nPos, sal_uInt16& rVal);
++        SCROW getLastPos() const;
++
++    private:
++        ScFlatUInt16RowSegments&  mrSegs;
++
++        SCROW       mnCurPos;
++        SCROW       mnLastPos;
++        sal_uInt16  mnCurValue;
++    };
++
++    ScFlatUInt16RowSegments(sal_uInt16 nDefault);
++    ~ScFlatUInt16RowSegments();
++
++    void setValue(SCROW nRow1, SCROW nRow2, sal_uInt16 nValue);
++    sal_uInt16 getValue(SCROW nRow);
++    sal_uInt32 getSumValue(SCROW nRow1, SCROW nRow2);
++    bool getRangeData(SCROW nRow, RangeData& rData);
++    void removeSegment(SCROW nRow1, SCROW nRow2);
++    void insertSegment(SCROW nRow, SCROW nSize, bool bSkipStartBoundary);
++
++    SCROW findLastNotOf(sal_uInt16 nValue) const;
++
++private:
++    ::std::auto_ptr<ScFlatUInt16SegmentsImpl> mpImpl;
++};
+ 
+ #endif
+diff --git sc/inc/table.hxx sc/inc/table.hxx
+index 192ca18..db301be 100644
+--- sc/inc/table.hxx
++++ sc/inc/table.hxx
+@@ -83,6 +83,7 @@ struct RowInfo;
+ struct ScFunctionData;
+ struct ScLineFlags;
+ class CollatorWrapper;
++class ScFlatUInt16RowSegments;
+ class ScFlatBoolRowSegments;
+ class ScFlatBoolColSegments;
+ struct ScSetStringParam;
+@@ -120,7 +121,7 @@ private:
+     ::std::auto_ptr<ScTableProtection> pTabProtection;
+ 
+     USHORT*			pColWidth;
+-    ScSummableCompressedArray< SCROW, USHORT>*  pRowHeight;
++    ::boost::shared_ptr<ScFlatUInt16RowSegments> mpRowHeights;
+ 
+     BYTE*			pColFlags;
+     ScBitMaskCompressedArray< SCROW, BYTE>*     pRowFlags;
+@@ -592,7 +593,7 @@ public:
+     void		SetManualHeight( SCROW nStartRow, SCROW nEndRow, BOOL bManual );
+ 
+ 	USHORT		GetColWidth( SCCOL nCol );
+-    SC_DLLPUBLIC USHORT GetRowHeight( SCROW nRow );
++    SC_DLLPUBLIC USHORT GetRowHeight( SCROW nRow, SCROW* pStartRow = NULL, SCROW* pEndRow = NULL );
+ 	ULONG		GetRowHeight( SCROW nStartRow, SCROW nEndRow );
+ 	ULONG		GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale );
+ 	ULONG		GetColOffset( SCCOL nCol );
+@@ -639,8 +640,6 @@ public:
+ 
+     const ScBitMaskCompressedArray< SCROW, BYTE> * GetRowFlagsArray() const
+                     { return pRowFlags; }
+-    const ScSummableCompressedArray< SCROW, USHORT> * GetRowHeightArray() const
+-                    { return pRowHeight; }
+ 
+     BOOL		UpdateOutlineCol( SCCOL nStartCol, SCCOL nEndCol, BOOL bShow );
+     BOOL		UpdateOutlineRow( SCROW nStartRow, SCROW nEndRow, BOOL bShow );
+@@ -655,6 +654,19 @@ public:
+     bool        HasColPageBreak(SCCOL nCol) const;
+     bool        HasRowManualBreak(SCROW nRow) const;
+     bool        HasColManualBreak(SCCOL nCol) const;
++
++    /** 
++     * Get the row position of the next manual break that occurs at or below 
++     * specified row.  When no more manual breaks are present at or below 
++     * the specified row, -1 is returned. 
++     *  
++     * @param nRow row at which the search begins. 
++     *  
++     * @return SCROW next row position with manual page break, or -1 if no 
++     *         more manual breaks are present.
++     */
++    SCROW       GetNextManualBreak(SCROW nRow) const;
++
+     void        RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow);
+     void        RemoveRowBreak(SCROW nRow, bool bPage, bool bManual);
+     void        RemoveColBreak(SCCOL nCol, bool bPage, bool bManual);
+@@ -672,6 +684,7 @@ public:
+     void        SetColHidden(SCCOL nStartCol, SCCOL nEndCol, bool bHidden);
+     void        CopyColHidden(ScTable& rTable, SCCOL nStartCol, SCCOL nEndCol);
+     void        CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow);
++    void        CopyRowHeight(ScTable& rSrcTable, SCROW nStartRow, SCROW nEndRow, SCROW nSrcOffset);
+     SCROW       FirstVisibleRow(SCROW nStartRow, SCROW nEndRow);
+     SCROW       LastVisibleRow(SCROW nStartRow, SCROW nEndRow);
+     SCROW       CountVisibleRows(SCROW nStartRow, SCROW nEndRow);
+diff --git sc/source/core/data/document.cxx sc/source/core/data/document.cxx
+index 43da81b..579c99a 100644
+--- sc/source/core/data/document.cxx
++++ sc/source/core/data/document.cxx
+@@ -3050,28 +3050,6 @@ ULONG ScDocument::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow,
+ }
+ 
+ 
+-const ScSummableCompressedArray< SCROW, USHORT> & ScDocument::GetRowHeightArray(
+-        SCTAB nTab ) const
+-{
+-    const ScSummableCompressedArray< SCROW, USHORT> * pHeight;
+-    if ( ValidTab(nTab) && pTab[nTab] )
+-        pHeight = pTab[nTab]->GetRowHeightArray();
+-    else
+-    {
+-        DBG_ERROR("wrong sheet number");
+-        pHeight = 0;
+-    }
+-    if (!pHeight)
+-    {
+-        DBG_ERROR("no row heights at sheet");
+-        static ScSummableCompressedArray< SCROW, USHORT> aDummy( MAXROW,
+-                ScGlobal::nStdRowHeight);
+-        pHeight = &aDummy;
+-    }
+-    return *pHeight;
+-}
+-
+-
+ SCROW ScDocument::GetHiddenRowCount( SCROW nRow, SCTAB nTab ) const
+ {
+     if ( ValidTab(nTab) && pTab[nTab] )
+@@ -3545,7 +3523,7 @@ SCCOL ScDocument::GetNextDifferentChangedCol( SCTAB nTab, SCCOL nStart) const
+ 
+ SCROW ScDocument::GetNextDifferentChangedRow( SCTAB nTab, SCROW nStart, bool bCareManualSize) const
+ {
+-    if ( ValidTab(nTab) && pTab[nTab] && pTab[nTab]->GetRowFlagsArray() && pTab[nTab]->GetRowHeightArray() )
++    if ( ValidTab(nTab) && pTab[nTab] && pTab[nTab]->GetRowFlagsArray() && pTab[nTab]->mpRowHeights )
+     {
+         BYTE nStartFlags = pTab[nTab]->GetRowFlags(nStart);
+         USHORT nStartHeight = pTab[nTab]->GetOriginalHeight(nStart);
+@@ -3555,7 +3533,7 @@ SCROW ScDocument::GetNextDifferentChangedRow( SCTAB nTab, SCROW nStart, bool bCa
+             SCROW nFlagsEndRow;
+             SCROW nHeightEndRow;
+             BYTE nFlags = pTab[nTab]->GetRowFlagsArray()->GetValue( nRow, nIndex, nFlagsEndRow );
+-            USHORT nHeight = pTab[nTab]->GetRowHeightArray()->GetValue( nRow, nIndex, nHeightEndRow );
++            USHORT nHeight = pTab[nTab]->GetRowHeight(nRow, NULL, &nHeightEndRow);
+             if (((nStartFlags & CR_MANUALBREAK) != (nFlags & CR_MANUALBREAK)) ||
+                 ((nStartFlags & CR_MANUALSIZE) != (nFlags & CR_MANUALSIZE)) ||
+                 (bCareManualSize && (nStartFlags & CR_MANUALSIZE) && (nStartHeight != nHeight)) ||
+diff --git sc/source/core/data/drwlayer.cxx sc/source/core/data/drwlayer.cxx
+index b83c94b..ea8373e 100644
+--- sc/source/core/data/drwlayer.cxx
++++ sc/source/core/data/drwlayer.cxx
+@@ -549,13 +549,11 @@ void ScDrawLayer::RecalcPos( SdrObject* pObj, const ScDrawObjData& rData,
+ 
+     if( rData.mbNote )
+     {
+-        /*  #i63671# while inserting/deleting cells/rows/columns: note has
+-            not been moved yet in document, get it from old position. */
+         DBG_ASSERT( rOldStart.IsValid(), "ScDrawLayer::RecalcPos - invalid position for cell note" );
+         /*  When inside an undo action, there may be pending note captions
+             where cell note is already deleted. The caption will be deleted
+             later with drawing undo. */
+-        if( ScPostIt* pNote = pDoc->GetNote( rOldStart ) )
++        if( ScPostIt* pNote = pDoc->GetNote( rData.maStart ) )
+             pNote->UpdateCaptionPos( rData.maStart );
+         return;
+     }
+diff --git sc/source/core/data/segmenttree.cxx sc/source/core/data/segmenttree.cxx
+index 0ee889b..98c5032 100644
+--- sc/source/core/data/segmenttree.cxx
++++ sc/source/core/data/segmenttree.cxx
+@@ -34,100 +34,182 @@
+ #include "segmenttree.hxx"
+ #include "mdds/flatsegmenttree.hxx"
+ 
+-#define USE_TREE_SEARCH 1
++#include <limits>
+ 
+-class ScFlatBoolSegmentsImpl
++using ::std::numeric_limits;
++
++// ============================================================================
++
++template<typename _ValueType, typename _ExtValueType = _ValueType>
++class ScFlatSegmentsImpl
+ {
+ public:
++    typedef _ValueType ValueType;
++    typedef _ExtValueType ExtValueType;
++
+     struct RangeData
+     {
+         SCCOLROW    mnPos1;
+         SCCOLROW    mnPos2;
+-        bool        mbValue;
++        ValueType   mnValue;
+     };
+-    ScFlatBoolSegmentsImpl(SCCOLROW nMax);
+-    ~ScFlatBoolSegmentsImpl();
+ 
+-    void setTrue(SCCOLROW nPos1, SCCOLROW nPos2);
+-    void setFalse(SCCOLROW nPos1, SCCOLROW nPos2);
+-    bool getValue(SCCOLROW nPos);
++    inline ScFlatSegmentsImpl(SCCOLROW nMax, ValueType nDefault);
++    ~ScFlatSegmentsImpl();
++
++    void setValue(SCCOLROW nPos1, SCCOLROW nPos2, ValueType nValue);
++    ValueType getValue(SCCOLROW nPos);
++    ExtValueType getSumValue(SCCOLROW nPos1, SCCOLROW nPos2);
+     bool getRangeData(SCCOLROW nPos, RangeData& rData);
+     void removeSegment(SCCOLROW nPos1, SCCOLROW nPos2);
+     void insertSegment(SCCOLROW nPos, SCCOLROW nSize, bool bSkipStartBoundary);
+ 
+-private:
+-    ScFlatBoolSegmentsImpl();
+-    ScFlatBoolSegmentsImpl(const ScFlatBoolSegmentsImpl&);
++    SCROW findLastNotOf(ValueType nValue) const;
+ 
+-    ::mdds::flat_segment_tree<SCCOLROW, bool> maSegments;
++private:
++    typedef ::mdds::flat_segment_tree<SCCOLROW, ValueType> fst_type;
++    fst_type maSegments;
+ };
+ 
+-ScFlatBoolSegmentsImpl::ScFlatBoolSegmentsImpl(SCCOLROW nMax) :
+-    maSegments(0, nMax+1, false)
++template<typename _ValueType, typename _ExtValueType>
++ScFlatSegmentsImpl<_ValueType, _ExtValueType>::ScFlatSegmentsImpl(SCCOLROW nMax, ValueType nDefault) :
++    maSegments(0, nMax+1, nDefault)
+ {
+ }
+ 
+-ScFlatBoolSegmentsImpl::~ScFlatBoolSegmentsImpl()
++template<typename _ValueType, typename _ExtValueType>
++ScFlatSegmentsImpl<_ValueType, _ExtValueType>::~ScFlatSegmentsImpl()
+ {
+ }
+ 
+-void ScFlatBoolSegmentsImpl::setTrue(SCCOLROW nPos1, SCCOLROW nPos2)
++template<typename _ValueType, typename _ExtValueType>
++void ScFlatSegmentsImpl<_ValueType, _ExtValueType>::setValue(SCCOLROW nPos1, SCCOLROW nPos2, ValueType nValue)
+ {
+-    maSegments.insert_segment(nPos1, nPos2+1, true);
++    maSegments.insert_segment(nPos1, nPos2+1, nValue);
+ }
+ 
+-void ScFlatBoolSegmentsImpl::setFalse(SCCOLROW nPos1, SCCOLROW nPos2)
++template<typename _ValueType, typename _ExtValueType>
++typename ScFlatSegmentsImpl<_ValueType, _ExtValueType>::ValueType ScFlatSegmentsImpl<_ValueType, _ExtValueType>::getValue(SCCOLROW nPos)
+ {
+-    maSegments.insert_segment(nPos1, nPos2+1, false);
++    ValueType nValue = 0;
++    if (!maSegments.is_tree_valid())
++        maSegments.build_tree();
++
++    maSegments.search_tree(nPos, nValue);
++    return nValue;
+ }
+ 
+-bool ScFlatBoolSegmentsImpl::getValue(SCCOLROW nPos)
++template<typename _ValueType, typename _ExtValueType>
++typename ScFlatSegmentsImpl<_ValueType, _ExtValueType>::ExtValueType 
++ScFlatSegmentsImpl<_ValueType, _ExtValueType>::getSumValue(SCCOLROW nPos1, SCCOLROW nPos2)
+ {
+-    bool bValue = false;
+-#if USE_TREE_SEARCH
+-    if (!maSegments.is_tree_valid())
+-        maSegments.build_tree();
++    RangeData aData;
++    if (!getRangeData(nPos1, aData))
++        return 0;
+ 
+-    maSegments.search_tree(nPos, bValue);
+-#else
+-    maSegments.search(nPos, bValue);
+-#endif
+-    return bValue;
++    sal_uInt32 nValue = 0;
++
++    SCROW nCurPos = nPos1;
++    SCROW nEndPos = aData.mnPos2;
++    while (nEndPos <= nPos2)
++    {
++        nValue += aData.mnValue * (nEndPos - nCurPos + 1);
++        nCurPos = nEndPos + 1;
++        if (!getRangeData(nCurPos, aData))
++            break;
++
++        nEndPos = aData.mnPos2;
++    }
++    if (nCurPos <= nPos2)
++    {
++        nEndPos = ::std::min(nEndPos, nPos2);
++        nValue += aData.mnValue * (nEndPos - nCurPos + 1);
++    }
++    return nValue;
+ }
+ 
+-bool ScFlatBoolSegmentsImpl::getRangeData(SCCOLROW nPos, RangeData& rData)
++template<typename _ValueType, typename _ExtValueType>
++bool ScFlatSegmentsImpl<_ValueType, _ExtValueType>::getRangeData(SCCOLROW nPos, RangeData& rData)
+ {
+-#if USE_TREE_SEARCH
+     if (!maSegments.is_tree_valid())
+         maSegments.build_tree();
+-#endif
+ 
+-    bool bValue;
++    ValueType nValue;
+     SCCOLROW nPos1, nPos2;
+-#if USE_TREE_SEARCH
+-    if (!maSegments.search_tree(nPos, bValue, &nPos1, &nPos2))
++    if (!maSegments.search_tree(nPos, nValue, &nPos1, &nPos2))
+         return false;
+-#else
+-    if (!maSegments.search(nPos, bValue, &nPos1, &nPos2))
+-        return false;
+-#endif
+ 
+     rData.mnPos1 = nPos1;
+     rData.mnPos2 = nPos2-1; // end point is not inclusive.
+-    rData.mbValue = bValue;
++    rData.mnValue = nValue;
+     return true;
+ }
+ 
+-void ScFlatBoolSegmentsImpl::removeSegment(SCCOLROW nPos1, SCCOLROW nPos2)
++template<typename _ValueType, typename _ExtValueType>
++void ScFlatSegmentsImpl<_ValueType, _ExtValueType>::removeSegment(SCCOLROW nPos1, SCCOLROW nPos2)
+ {
+     maSegments.shift_segment_left(nPos1, nPos2);
+ }
+ 
+-void ScFlatBoolSegmentsImpl::insertSegment(SCCOLROW nPos, SCCOLROW nSize, bool bSkipStartBoundary)
++template<typename _ValueType, typename _ExtValueType>
++void ScFlatSegmentsImpl<_ValueType, _ExtValueType>::insertSegment(SCCOLROW nPos, SCCOLROW nSize, bool bSkipStartBoundary)
+ {
+     maSegments.shift_segment_right(nPos, nSize, bSkipStartBoundary);
+ }
+ 
++template<typename _ValueType, typename _ExtValueType>
++SCCOLROW ScFlatSegmentsImpl<_ValueType, _ExtValueType>::findLastNotOf(ValueType nValue) const
++{
++    SCCOLROW nPos = numeric_limits<SCCOLROW>::max(); // position not found.
++    typename fst_type::const_reverse_iterator itr = maSegments.rbegin(), itrEnd = maSegments.rend();
++    // Note that when searching in reverse direction, we need to skip the first 
++    // node, since the right-most leaf node does not store a valid value.
++    for (++itr; itr != itrEnd; ++itr)
++    {
++        if (itr->second != nValue)
++        {
++            nPos = (--itr)->second - 1;
++            break;
++        }
++    }
++    return nPos;
++}
++
++// ============================================================================
++
++class ScFlatUInt16SegmentsImpl : public ScFlatSegmentsImpl<sal_uInt16, sal_uInt32>
++{
++public:
++    explicit ScFlatUInt16SegmentsImpl(SCCOLROW nMax, sal_uInt16 nDefault) :
++        ScFlatSegmentsImpl<sal_uInt16, sal_uInt32>(nMax, nDefault)
++    {
++    }
++};
++
++// ----------------------------------------------------------------------------
++
++class ScFlatBoolSegmentsImpl : public ScFlatSegmentsImpl<bool>
++{
++public:
++    explicit ScFlatBoolSegmentsImpl(SCCOLROW nMax) :
++        ScFlatSegmentsImpl<bool>(nMax, false)
++    {
++    }
++
++    void setTrue(SCCOLROW nPos1, SCCOLROW nPos2);
++    void setFalse(SCCOLROW nPos1, SCCOLROW nPos2);
++};
++
++void ScFlatBoolSegmentsImpl::setTrue(SCCOLROW nPos1, SCCOLROW nPos2)
++{
++    setValue(nPos1, nPos2, true);
++}
++
++void ScFlatBoolSegmentsImpl::setFalse(SCCOLROW nPos1, SCCOLROW nPos2)
++{
++    setValue(nPos1, nPos2, false);
++}
++
+ // ============================================================================
+ 
+ ScFlatBoolRowSegments::ForwardIterator::ForwardIterator(ScFlatBoolRowSegments& rSegs) :
+@@ -156,6 +238,11 @@ bool ScFlatBoolRowSegments::ForwardIterator::getValue(SCROW nPos, bool& rVal)
+     return true;
+ }
+ 
++SCROW ScFlatBoolRowSegments::ForwardIterator::getLastPos() const
++{
++    return mnLastPos;
++}
++
+ // ----------------------------------------------------------------------------
+ 
+ ScFlatBoolRowSegments::ScFlatBoolRowSegments() :
+@@ -188,7 +275,7 @@ bool ScFlatBoolRowSegments::getRangeData(SCROW nRow, RangeData& rData)
+     if (!mpImpl->getRangeData(static_cast<SCCOLROW>(nRow), aData))
+         return false;
+ 
+-    rData.mbValue = aData.mbValue;
++    rData.mbValue = aData.mnValue;
+     rData.mnRow1  = static_cast<SCROW>(aData.mnPos1);
+     rData.mnRow2  = static_cast<SCROW>(aData.mnPos2);
+     return true;
+@@ -236,7 +323,7 @@ bool ScFlatBoolColSegments::getRangeData(SCCOL nCol, RangeData& rData)
+     if (!mpImpl->getRangeData(static_cast<SCCOLROW>(nCol), aData))
+         return false;
+ 
+-    rData.mbValue = aData.mbValue;
++    rData.mbValue = aData.mnValue;
+     rData.mnCol1  = static_cast<SCCOL>(aData.mnPos1);
+     rData.mnCol2  = static_cast<SCCOL>(aData.mnPos2);
+     return true;
+@@ -251,3 +338,92 @@ void ScFlatBoolColSegments::insertSegment(SCCOL nCol, SCCOL nSize, bool bSkipSta
+ {
+     mpImpl->insertSegment(static_cast<SCCOLROW>(nCol), static_cast<SCCOLROW>(nSize), bSkipStartBoundary);
+ }
++
++// ============================================================================
++
++
++// ============================================================================
++
++ScFlatUInt16RowSegments::ForwardIterator::ForwardIterator(ScFlatUInt16RowSegments& rSegs) :
++    mrSegs(rSegs), mnCurPos(0), mnLastPos(-1), mnCurValue(0)
++{
++}
++
++bool ScFlatUInt16RowSegments::ForwardIterator::getValue(SCROW nPos, sal_uInt16& rVal)
++{
++    if (nPos >= mnCurPos)
++        // It can only go in a forward direction.
++        mnCurPos = nPos;
++
++    if (mnCurPos > mnLastPos)
++    {
++        // position not in the current segment.  Update the current value.
++        ScFlatUInt16RowSegments::RangeData aData;
++        if (!mrSegs.getRangeData(mnCurPos, aData))
++            return false;
++    
++        mnCurValue = aData.mnValue;
++        mnLastPos = aData.mnRow2;
++    }
++
++    rVal = mnCurValue;
++    return true;
++}
++
++SCROW ScFlatUInt16RowSegments::ForwardIterator::getLastPos() const
++{
++    return mnLastPos;
++}
++
++// ----------------------------------------------------------------------------
++
++ScFlatUInt16RowSegments::ScFlatUInt16RowSegments(sal_uInt16 nDefault) :
++    mpImpl(new ScFlatUInt16SegmentsImpl(static_cast<SCCOLROW>(MAXROW), nDefault))
++{
++}
++
++ScFlatUInt16RowSegments::~ScFlatUInt16RowSegments()
++{
++}
++
++void ScFlatUInt16RowSegments::setValue(SCROW nRow1, SCROW nRow2, sal_uInt16 nValue)
++{
++    mpImpl->setValue(static_cast<SCCOLROW>(nRow1), static_cast<SCCOLROW>(nRow2), nValue);
++}
++
++sal_uInt16 ScFlatUInt16RowSegments::getValue(SCROW nRow)
++{
++    return mpImpl->getValue(static_cast<SCCOLROW>(nRow));
++}
++
++sal_uInt32 ScFlatUInt16RowSegments::getSumValue(SCROW nRow1, SCROW nRow2)
++{
++    return mpImpl->getSumValue(static_cast<SCCOLROW>(nRow1), static_cast<SCCOLROW>(nRow2));
++}
++
++bool ScFlatUInt16RowSegments::getRangeData(SCROW nRow, RangeData& rData)
++{
++    ScFlatUInt16SegmentsImpl::RangeData aData;
++    if (!mpImpl->getRangeData(static_cast<SCCOLROW>(nRow), aData))
++        return false;
++
++    rData.mnRow1  = aData.mnPos1;
++    rData.mnRow2  = aData.mnPos2;
++    rData.mnValue = aData.mnValue;
++    return true;
++}
++
++void ScFlatUInt16RowSegments::removeSegment(SCROW nRow1, SCROW nRow2)
++{
++    mpImpl->removeSegment(static_cast<SCCOLROW>(nRow1), static_cast<SCCOLROW>(nRow2));
++}
++
++void ScFlatUInt16RowSegments::insertSegment(SCROW nRow, SCROW nSize, bool bSkipStartBoundary)
++{
++    mpImpl->insertSegment(static_cast<SCCOLROW>(nRow), static_cast<SCCOLROW>(nSize), bSkipStartBoundary);
++}
++
++SCROW ScFlatUInt16RowSegments::findLastNotOf(sal_uInt16 nValue) const
++{
++    return static_cast<SCROW>(mpImpl->findLastNotOf(nValue));
++}
+diff --git sc/source/core/data/table1.cxx sc/source/core/data/table1.cxx
+index d46dba2..5319b1a 100644
+--- sc/source/core/data/table1.cxx
++++ sc/source/core/data/table1.cxx
+@@ -137,7 +137,7 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
+     nRepeatStartY( SCROW_REPEAT_NONE ),
+     pTabProtection( NULL ),
+     pColWidth( NULL ),
+-    pRowHeight( NULL ),
++    mpRowHeights( static_cast<ScFlatUInt16RowSegments*>(NULL) ),
+     pColFlags( NULL ),
+     pRowFlags( NULL ),
+     mpHiddenCols(new ScFlatBoolColSegments),
+@@ -178,7 +178,7 @@ ScTable::ScTable( ScDocument* pDoc, SCTAB nNewTab, const String& rNewName,
+ 
+     if (bRowInfo)
+     {
+-        pRowHeight = new ScSummableCompressedArray< SCROW, USHORT>( MAXROW, ScGlobal::nStdRowHeight);
++        mpRowHeights.reset(new ScFlatUInt16RowSegments(ScGlobal::nStdRowHeight));
+         pRowFlags  = new ScBitMaskCompressedArray< SCROW, BYTE>( MAXROW, 0);
+     }
+ 
+@@ -220,7 +220,6 @@ ScTable::~ScTable()
+ 
+     delete[] pColWidth;
+     delete[] pColFlags;
+-    delete pRowHeight;
+     delete pRowFlags;
+     delete pOutlineTable;
+     delete pSearchParam;
+diff --git sc/source/core/data/table2.cxx sc/source/core/data/table2.cxx
+index ce2705d..01b268e 100644
+--- sc/source/core/data/table2.cxx
++++ sc/source/core/data/table2.cxx
+@@ -120,15 +163,16 @@ void ScTable::InsertRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
+     nRecalcLvl++;
+     if (nStartCol==0 && nEndCol==MAXCOL)
+     {
+-        if (pRowHeight && pRowFlags)
++        if (mpRowHeights && pRowFlags)
+         {
+-            pRowHeight->Insert( nStartRow, nSize);
++            mpRowHeights->insertSegment(nStartRow, nSize, false);
+             BYTE nNewFlags = pRowFlags->Insert( nStartRow, nSize);
+             // only copy manual size flag, clear all others
+             if (nNewFlags && (nNewFlags != CR_MANUALSIZE))
+                 pRowFlags->SetValue( nStartRow, nStartRow + nSize - 1,
+                         nNewFlags & CR_MANUALSIZE);
+         }
++
+         if (pOutlineTable)
+             pOutlineTable->InsertRow( nStartRow, nSize );
+ 
+@@ -151,11 +195,12 @@ void ScTable::DeleteRow( SCCOL nStartCol, SCCOL nEndCol, SCROW nStartRow, SCSIZE
+     nRecalcLvl++;
+     if (nStartCol==0 && nEndCol==MAXCOL)
+     {
+-        if (pRowHeight && pRowFlags)
+-        {
+-            pRowHeight->Remove( nStartRow, nSize);
++        if (pRowFlags)
+             pRowFlags->Remove( nStartRow, nSize);
+-        }
++
++        if (mpRowHeights)
++            mpRowHeights->removeSegment(nStartRow, nStartRow+nSize);
++
+         if (pOutlineTable)
+             if (pOutlineTable->DeleteRow( nStartRow, nSize ))
+                 if (pUndoOutline)
+@@ -372,10 +417,10 @@ void ScTable::CopyToClip(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
+         pTable->CopyColHidden(*this, 0, nCol2);
+         pTable->CopyColFiltered(*this, 0, nCol2);
+ 
+-        if (pRowFlags && pTable->pRowFlags && pRowHeight && pTable->pRowHeight)
++        if (pRowFlags && pTable->pRowFlags && mpRowHeights && pTable->mpRowHeights)
+         {
+             pTable->pRowFlags->CopyFromAnded( *pRowFlags, 0, nRow2, CR_MANUALSIZE);
+-            pTable->pRowHeight->CopyFrom( *pRowHeight, 0, nRow2);
++            pTable->CopyRowHeight(*this, 0, nRow2, 0);
+         }
+ 
+         pTable->CopyRowHidden(*this, 0, nRow2);
+@@ -420,10 +465,10 @@ void ScTable::CopyFromClip(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
+                 for (i=nCol1; i<=nCol2; i++)
+                     pColWidth[i] = pTable->pColWidth[i-nDx];
+ 
+-            if (nCol1==0 && nCol2==MAXCOL && pRowHeight && pTable->pRowHeight &&
++            if (nCol1==0 && nCol2==MAXCOL && mpRowHeights && pTable->mpRowHeights &&
+                                              pRowFlags && pTable->pRowFlags)
+             {
+-                pRowHeight->CopyFrom( *pTable->pRowHeight, nRow1, nRow2, -nDy);
++                CopyRowHeight(*pTable, nRow1, nRow2, -nDy);
+                 // Must copy CR_MANUALSIZE bit too, otherwise pRowHeight doesn't make sense
+                 for (SCROW j=nRow1; j<=nRow2; j++)
+                 {
+@@ -674,13 +719,13 @@ void ScTable::CopyToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
+                         bFlagChange = true;
+                 }
+ 
+-            if (nCol1==0 && nCol2==MAXCOL && pRowHeight && pDestTab->pRowHeight)
++            if (nCol1==0 && nCol2==MAXCOL && mpRowHeights && pDestTab->mpRowHeights)
+             {
+-                bool bChange = pDestTab->pRowHeight->SumValues(nRow1, nRow2) != pRowHeight->SumValues(nRow1, nRow2);
++                bool bChange = pDestTab->GetRowHeight(nRow1, nRow2) != GetRowHeight(nRow1, nRow2);
+                 if (bChange)
+                     bFlagChange = true;
+ 
+-                pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
++                pDestTab->CopyRowHeight(*this, nRow1, nRow2, 0);
+                 pDestTab->pRowFlags->CopyFrom(*pRowFlags, nRow1, nRow2);
+ 
+                 // Hidden flags.
+@@ -741,7 +786,7 @@ void ScTable::UndoToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
+     if (ValidColRow(nCol1, nRow1) && ValidColRow(nCol2, nRow2))
+     {
+         BOOL bWidth  = (nRow1==0 && nRow2==MAXROW && pColWidth && pDestTab->pColWidth);
+-        BOOL bHeight = (nCol1==0 && nCol2==MAXCOL && pRowHeight && pDestTab->pRowHeight);
++        BOOL bHeight = (nCol1==0 && nCol2==MAXCOL && mpRowHeights && pDestTab->mpRowHeights);
+ 
+         if (bWidth||bHeight)
+             nRecalcLvl++;
+@@ -761,7 +806,8 @@ void ScTable::UndoToTable(SCCOL nCol1, SCROW nRow1, SCCOL nCol2, SCROW nRow2,
+                 for (SCCOL i=nCol1; i<=nCol2; i++)
+                     pDestTab->pColWidth[i] = pColWidth[i];
+             if (bHeight)
+-                pDestTab->pRowHeight->CopyFrom( *pRowHeight, nRow1, nRow2);
++                pDestTab->CopyRowHeight(*this, nRow1, nRow2, 0);
++
+             if( !--nRecalcLvl )
+                 SetDrawPageSize();
+         }
+@@ -1352,7 +1398,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
+                         // reicht die gedrehte Zelle bis in den sichtbaren Bereich?
+ 
+                         SCCOL nTouchedCol = nCol;
+-                        long nWidth = (long) ( pRowHeight->GetValue(nRow) * nFactor );
++                        long nWidth = static_cast<long>(mpRowHeights->getValue(nRow) * nFactor);
+                         DBG_ASSERT(nWidth <= 0, "Richtung falsch");
+                         while ( nWidth < 0 && nTouchedCol > 0 )
+                         {
+@@ -1380,7 +1426,7 @@ SCSIZE ScTable::FillMaxRot( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCO
+ 
+ void ScTable::FindMaxRotCol( RowInfo* pRowInfo, SCSIZE nArrCount, SCCOL nX1, SCCOL nX2 )
+ {
+-    if ( !pColWidth || !pRowHeight || !pColFlags || !pRowFlags )
++    if ( !pColWidth || !mpRowHeights || !pColFlags || !pRowFlags )
+     {
+         DBG_ERROR( "Spalten-/Zeileninfo fehlt" );
+         return;
+@@ -2021,7 +2067,7 @@ void ScTable::SetColWidth( SCCOL nCol, USHORT nNewWidth )
+ 
+ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
+ {
+-    if (VALIDROW(nRow) && pRowHeight)
++    if (VALIDROW(nRow) && mpRowHeights)
+     {
+         if (!nNewHeight)
+         {
+@@ -2029,14 +2075,14 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
+             nNewHeight = ScGlobal::nStdRowHeight;
+         }
+ 
+-        USHORT nOldHeight = pRowHeight->GetValue(nRow);
++        sal_uInt16 nOldHeight = mpRowHeights->getValue(nRow);
+         if ( nNewHeight != nOldHeight )
+         {
+             nRecalcLvl++;
+             ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
+             if (pDrawLayer)
+                 pDrawLayer->HeightChanged( nTab, nRow, ((long) nNewHeight) - (long) nOldHeight );
+-            pRowHeight->SetValue( nRow, nNewHeight);
++            mpRowHeights->setValue(nRow, nRow, nNewHeight);
+             if( !--nRecalcLvl )
+                 SetDrawPageSize();
+ 
+@@ -2049,12 +2095,45 @@ void ScTable::SetRowHeight( SCROW nRow, USHORT nNewHeight )
+     }
+ }
+ 
++namespace {
++
++/** 
++ * Check if the new pixel size is different from the old size between 
++ * specified ranges. 
++ */
++bool lcl_pixelSizeChanged(
++    ScFlatUInt16RowSegments& rRowHeights, SCROW nStartRow, SCROW nEndRow, 
++    sal_uInt16 nNewHeight, double nPPTY)
++{
++    long nNewPix = static_cast<long>(nNewHeight * nPPTY);
++
++    ScFlatUInt16RowSegments::ForwardIterator aFwdIter(rRowHeights);
++    for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
++    {
++        sal_uInt16 nHeight;
++        if (!aFwdIter.getValue(nRow, nHeight))
++            break;
++
++        if (nHeight != nNewHeight)
++        {    
++            bool bChanged = (nNewPix != static_cast<long>(nHeight * nPPTY));
++            if (bChanged)
++                return true;
++        }
++
++        // Skip ahead to the last position of the current range.
++        nRow = aFwdIter.getLastPos();
++    }
++    return false;
++}
++
++}
+ 
+ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeight,
+                                     double /* nPPTX */, double nPPTY )
+ {
+     BOOL bChanged = FALSE;
+-    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
++    if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && mpRowHeights)
+     {
+         nRecalcLvl++;
+         if (!nNewHeight)
+@@ -2063,8 +2142,6 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
+             nNewHeight = ScGlobal::nStdRowHeight;
+         }
+ 
+-        long nNewPix = (long) ( nNewHeight * nPPTY );
+-
+         BOOL bSingle = FALSE;
+         ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
+         if (pDrawLayer)
+@@ -2073,23 +2150,34 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
+ 
+         if (bSingle)
+         {
+-            size_t nIndex;
+-            SCROW nRegionEndRow;
+-            USHORT nOldHeight = pRowHeight->GetValue( nStartRow, nIndex, nRegionEndRow);
+-            if (nNewHeight == nOldHeight && nEndRow <= nRegionEndRow)
++            ScFlatUInt16RowSegments::RangeData aData;
++            mpRowHeights->getRangeData(nStartRow, aData);
++            if (nNewHeight == aData.mnValue && nEndRow <= aData.mnRow2)
+                 bSingle = FALSE;    // no difference in this range
+         }
+         if (bSingle)
+         {
+             if (nEndRow-nStartRow < 20)
+             {
+-                for (SCROW nRow = nStartRow; nRow <= nEndRow; ++nRow)
++                if (!bChanged)
++                    bChanged = lcl_pixelSizeChanged(*mpRowHeights, nStartRow, nEndRow, nNewHeight, nPPTY);
++
++                /*  #i94028# #i94991# If drawing objects are involved, each row
++                    has to be changed for its own, because each call to
++                    ScDrawLayer::HeightChanged expects correct row heights
++                    above passed row in the document. Cannot use array iterator
++                    because array changes in every cycle. */
++                if( pDrawLayer )
+                 {
+-                    if (!bChanged)
+-                        if (pRowHeight->GetValue( nRow ))
+-                            bChanged = (nNewPix != (long) (pRowHeight->GetValue( nRow ) * nPPTY));
+-                    SetRowHeight( nRow, nNewHeight );
++                    for( SCROW nRow = nStartRow; nRow <= nEndRow ; ++nRow )
++                    {
++                        pDrawLayer->HeightChanged( nTab, nRow,
++                            ((long) nNewHeight) - ((long) mpRowHeights->getValue(nRow)));
++                        mpRowHeights->setValue(nRow, nRow, nNewHeight);
++                    }
+                 }
++                else
++                    mpRowHeights->setValue(nStartRow, nEndRow, nNewHeight);
+             }
+             else
+             {
+@@ -2104,22 +2192,19 @@ BOOL ScTable::SetRowHeightRange( SCROW nStartRow, SCROW nEndRow, USHORT nNewHeig
+         {
+             if (pDrawLayer)
+             {
+-                unsigned long nOldHeights = pRowHeight->SumValues( nStartRow, nEndRow);
++                unsigned long nOldHeights = GetRowHeight(nStartRow, nEndRow);
+                 // FIXME: should we test for overflows?
+                 long nHeightDif = (long) (unsigned long) nNewHeight *
+                     (nEndRow - nStartRow + 1) - nOldHeights;
+                 pDrawLayer->HeightChanged( nTab, nEndRow, nHeightDif );
+             }
+-            // Whether new pixel size will differ from old pixel size in any row.
+-            ScCompressedArrayIterator< SCROW, USHORT> aIter( *pRowHeight,
+-                    nStartRow, nEndRow);
+-            do
+-            {
+-                if (*aIter != nNewHeight)
+-                    bChanged = (nNewPix != (long) (*aIter * nPPTY));
+-            } while (!bChanged && aIter.NextRange());
+-            pRowHeight->SetValue( nStartRow, nEndRow, nNewHeight);
++
++            if (!bChanged)
++                bChanged = lcl_pixelSizeChanged(*mpRowHeights, nStartRow, nEndRow, nNewHeight, nPPTY);
++
++            mpRowHeights->setValue(nStartRow, nEndRow, nNewHeight);
+         }
++
+         if( !--nRecalcLvl )
+             SetDrawPageSize();
+ 
+@@ -2225,16 +2310,27 @@ USHORT ScTable::GetCommonWidth( SCCOL nEndCol )
+ }
+ 
+ 
+-USHORT ScTable::GetRowHeight( SCROW nRow )
++USHORT ScTable::GetRowHeight( SCROW nRow, SCROW* pStartRow, SCROW* pEndRow )
+ {
+     DBG_ASSERT(VALIDROW(nRow),"Falsche Zeilennummer");
+ 
+-	if (VALIDROW(nRow) && pRowHeight)
++	if (VALIDROW(nRow) && mpRowHeights)
+     {
+         if (RowHidden(nRow))
+             return 0;
+         else
+-            return pRowHeight->GetValue(nRow);
++        {
++            ScFlatUInt16RowSegments::RangeData aData;
++            if (!mpRowHeights->getRangeData(nRow, aData))
++                // TODO: What should we return in case the search fails?
++                return 0;
++
++            if (pStartRow)
++                *pStartRow = aData.mnRow1;
++            if (pEndRow)
++                *pEndRow = aData.mnRow2;
++            return aData.mnValue;
++        }
+     }
+     else
+         return (USHORT) ScGlobal::nStdRowHeight;
+@@ -2245,7 +2341,7 @@ ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow )
+ {
+     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
+ 
+-	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
++	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && mpRowHeights)
+     {
+         ULONG nHeight = 0;
+         SCROW nRow = nStartRow;
+@@ -2256,7 +2352,7 @@ ULONG ScTable::GetRowHeight( SCROW nStartRow, SCROW nEndRow )
+             {
+                 if (nLastRow > nEndRow)
+                     nLastRow = nEndRow;
+-                nHeight += pRowFlags->SumCoupledArrayForCondition(nRow, nLastRow, 0, 0, *pRowHeight);
++                nHeight += mpRowHeights->getSumValue(nRow, nLastRow);
+             }
+             nRow = nLastRow + 1;
+         }
+@@ -2271,7 +2367,7 @@ ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale
+ {
+     DBG_ASSERT(VALIDROW(nStartRow) && VALIDROW(nEndRow),"Falsche Zeilennummer");
+ 
+-	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && pRowHeight)
++	if (VALIDROW(nStartRow) && VALIDROW(nEndRow) && mpRowHeights)
+     {
+         ULONG nHeight = 0;
+         SCROW nRow = nStartRow;
+@@ -2282,8 +2378,8 @@ ULONG ScTable::GetScaledRowHeight( SCROW nStartRow, SCROW nEndRow, double fScale
+             {
+                 if (nLastRow > nEndRow)
+                     nLastRow = nEndRow;
+-                nHeight += pRowFlags->SumScaledCoupledArrayForCondition(
+-                    nRow, nLastRow, 0, 0, *pRowHeight, fScale);
++                sal_uInt32 nThisHeight = mpRowHeights->getSumValue(nRow, nLastRow);
++                nHeight += nThisHeight * fScale;
+             }
+             nRow = nLastRow + 1;
+         }
+@@ -2298,8 +2394,8 @@ USHORT ScTable::GetOriginalHeight( SCROW nRow ) const		// non-0 even if hidden
+ {
+     DBG_ASSERT(VALIDROW(nRow),"wrong row number");
+ 
+-    if (VALIDROW(nRow) && pRowHeight)
+-        return pRowHeight->GetValue(nRow);
++    if (VALIDROW(nRow) && mpRowHeights)
++        return mpRowHeights->getValue(nRow);
+     else
+         return (USHORT) ScGlobal::nStdRowHeight;
+ }
+@@ -2369,9 +2465,11 @@ void ScTable::ShowRow(SCROW nRow, BOOL bShow)
+             if (pDrawLayer)
+             {
+                 if (bShow)
+-                    pDrawLayer->HeightChanged( nTab, nRow, (long) pRowHeight->GetValue(nRow) );
++                    pDrawLayer->HeightChanged(
++                        nTab, nRow, static_cast<long>(mpRowHeights->getValue(nRow)));
+                 else
+-                    pDrawLayer->HeightChanged( nTab, nRow, -(long) pRowHeight->GetValue(nRow) );
++                    pDrawLayer->HeightChanged(
++                        nTab, nRow, -static_cast<long>(mpRowHeights->getValue(nRow)));
+             }
+ 
+             SetRowHidden(nRow, nRow, !bShow);
+@@ -2407,9 +2505,11 @@ void ScTable::DBShowRow(SCROW nRow, BOOL bShow)
+             if (pDrawLayer)
+             {
+                 if (bShow)
+-                    pDrawLayer->HeightChanged( nTab, nRow, (long) pRowHeight->GetValue(nRow) );
++                    pDrawLayer->HeightChanged(
++                        nTab, nRow, static_cast<long>(mpRowHeights->getValue(nRow)));
+                 else
+-                    pDrawLayer->HeightChanged( nTab, nRow, -(long) pRowHeight->GetValue(nRow) );
++                    pDrawLayer->HeightChanged(
++                        nTab, nRow, -static_cast<long>(mpRowHeights->getValue(nRow)));
+             }
+         }
+ 
+@@ -2457,7 +2557,7 @@ void ScTable::DBShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
+             ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
+             if (pDrawLayer)
+             {
+-                long nHeight = (long) pRowHeight->SumValues( nStartRow, nEndRow);
++                long nHeight = static_cast<long>(mpRowHeights->getSumValue(nStartRow, nEndRow));
+                 if (bShow)
+                     pDrawLayer->HeightChanged( nTab, nStartRow, nHeight );
+                 else
+@@ -2506,7 +2606,7 @@ void ScTable::ShowRows(SCROW nRow1, SCROW nRow2, BOOL bShow)
+             ScDrawLayer* pDrawLayer = pDocument->GetDrawLayer();
+             if (pDrawLayer)
+             {
+-                long nHeight = (long) pRowHeight->SumValues( nStartRow, nEndRow);
++                long nHeight = static_cast<long>(mpRowHeights->getSumValue(nStartRow, nEndRow));
+                 if (bShow)
+                     pDrawLayer->HeightChanged( nTab, nStartRow, nHeight );
+                 else
+@@ -2618,7 +2718,10 @@ SCROW ScTable::GetLastChangedRow() const
+     if (!ValidRow(nLastFlags))
+         nLastFlags = 0;
+ 
+-    SCROW nLastHeight = pRowHeight->GetLastUnequalAccess( 0, ScGlobal::nStdRowHeight);
++    // Find the last row position where the height is NOT the standard row
++    // height.
++    // KOHEI: Test this to make sure it does what it's supposed to.
++    SCROW nLastHeight = mpRowHeights->findLastNotOf(ScGlobal::nStdRowHeight);
+     if (!ValidRow(nLastHeight))
+         nLastHeight = 0;
+ 
+@@ -2911,7 +3014,7 @@ void ScTable::SetDrawPageSize()
+ ULONG ScTable::GetRowOffset( SCROW nRow )
+ {
+     ULONG n = 0;
+-    if ( pRowFlags && pRowHeight )
++    if ( mpHiddenRows && mpRowHeights )
+     {
+         if (nRow == 0)
+             return 0;
+@@ -2947,7 +3050,7 @@ SCROW ScTable::GetRowForHeight(ULONG nHeight)
+             continue;
+         }
+ 
+-        sal_uInt32 nNew = pRowHeight->GetValue(nRow);
++        sal_uInt32 nNew = mpRowHeights->getValue(nRow);
+         nSum += nNew;
+         if (nSum > nHeight)
+         {
+diff --git sc/source/core/data/table5.cxx sc/source/core/data/table5.cxx
+index 4d28ff2..1892a39 100644
+--- sc/source/core/data/table5.cxx
++++ sc/source/core/data/table5.cxx
+@@ -203,15 +203,31 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
+     BOOL bRepeatRow = ( nRepeatStartY != SCROW_REPEAT_NONE );
+     BOOL bRowFound = FALSE;
+     long nSizeY = 0;
+-    ScFlatBoolRowSegments::ForwardIterator aIter(*mpHiddenRows);
++    ScFlatBoolRowSegments::ForwardIterator aIterHidden(*mpHiddenRows);
++    ScFlatUInt16RowSegments::ForwardIterator aIterHeights(*mpRowHeights);
++    SCROW nNextManualBreak = GetNextManualBreak(nStartRow); // -1 => no more manual breaks
+     for (SCROW nY = nStartRow; nY <= nEndRow; ++nY)
+     {
+         BOOL bStartOfPage = FALSE;
+         bool bThisRowHidden = false;
+-        aIter.getValue(nY, bThisRowHidden);
+-        long nThisY = bThisRowHidden ? 0 : pRowHeight->GetValue(nY);
++        aIterHidden.getValue(nY, bThisRowHidden);
++        long nThisY = 0;
++        if (!bThisRowHidden)
++        {
++            sal_uInt16 nTmp;    
++            aIterHeights.getValue(nY, nTmp);
++            nThisY = static_cast<long>(nTmp);
++        }
++
++        bool bManualBreak = false;
++        if (nNextManualBreak >= 0)
++        {
++            bManualBreak = (nY == nNextManualBreak);
++            if (nY >= nNextManualBreak)
++                // Query the next menual break position.
++                nNextManualBreak = GetNextManualBreak(nY+1);
++        }
+ 
+-        bool bManualBreak = HasRowManualBreak(nY);
+ 		if ( (nSizeY+nThisY > nPageSizeY) || (bManualBreak && !bSkipBreaks) )
+         {
+             SetRowBreak(nY, true, false);
+@@ -237,6 +253,38 @@ void ScTable::UpdatePageBreaks( const ScRange* pUserArea )
+             bRowFound = TRUE;
+         }
+ 
++        if (bThisRowHidden)
++        {
++            // Hidden row range.  Skip them unless there is a manual break.
++            SCROW nLastCommon = aIterHidden.getLastPos();
++            if (nNextManualBreak >= 0)
++                nLastCommon = ::std::min(nLastCommon, nNextManualBreak-1);
++            nY = nLastCommon;
++        }
++        else
++        {
++            // Visible row range.
++
++            SCROW nLastHidden = aIterHidden.getLastPos();
++            SCROW nLastHeight = aIterHeights.getLastPos();
++            SCROW nLastCommon = ::std::min(nLastHidden, nLastHeight);
++            if (nNextManualBreak >= 0)
++                nLastCommon = ::std::min(nLastCommon, nNextManualBreak-1);
++    
++            if (nLastCommon > nY)
++            {
++                long nMaxMultiple = static_cast<long>(nLastCommon - nY);
++                long nMultiple = (nPageSizeY - nSizeY) / nThisY;
++                if (nMultiple > nMaxMultiple)
++                    nMultiple = nMaxMultiple;
++                if (nMultiple > 1)
++                {
++                    nSizeY += nThisY * (nMultiple - 1);
++                    nY += nMultiple - 1;
++                }
++            }
++        }
++
+         nSizeY += nThisY;
+     }
+ 
+@@ -325,6 +373,12 @@ bool ScTable::HasColManualBreak(SCCOL nCol) const
+     return (maColManualBreaks.count(nCol) > 0);
+ }
+ 
++SCROW ScTable::GetNextManualBreak(SCROW nRow) const
++{
++    set<SCROW>::const_iterator itr = maRowManualBreaks.lower_bound(nRow);
++    return itr == maRowManualBreaks.end() ? -1 : *itr;
++}
++
+ void ScTable::RemoveRowPageBreaks(SCROW nStartRow, SCROW nEndRow)
+ {
+     using namespace std;
+@@ -562,6 +616,25 @@ void ScTable::CopyRowHidden(ScTable& rTable, SCROW nStartRow, SCROW nEndRow)
+     }
+ }
+ 
++void ScTable::CopyRowHeight(ScTable& rSrcTable, SCROW nStartRow, SCROW nEndRow, SCROW nSrcOffset)
++{
++    SCROW nRow = nStartRow;
++    ScFlatUInt16RowSegments::RangeData aSrcData;
++    while (nRow <= nEndRow)
++    {
++        if (!rSrcTable.mpRowHeights->getRangeData(nRow + nSrcOffset, aSrcData))
++            // Something is wrong !
++            return;
++
++        SCROW nLastRow = aSrcData.mnRow2 - nSrcOffset;
++        if (nLastRow > nEndRow)
++            nLastRow = nEndRow;
++
++        mpRowHeights->setValue(nRow, nLastRow, aSrcData.mnValue);
++        nRow = nLastRow + 1;
++    }
++}
++
+ SCROW ScTable::FirstVisibleRow(SCROW nStartRow, SCROW nEndRow)
+ {
+     SCROW nRow = nStartRow;
+@@ -644,7 +717,7 @@ sal_uInt32 ScTable::GetTotalRowHeight(SCROW nStartRow, SCROW nEndRow)
+ 
+         if (!aData.mbValue)
+             // visible row range.
+-            nHeight += pRowHeight->SumValues(nRow, aData.mnRow2);
++            nHeight += mpRowHeights->getSumValue(nRow, aData.mnRow2);
+ 
+         nRow = aData.mnRow2 + 1;
+     }
+diff --git sc/source/ui/view/prevloc.cxx sc/source/ui/view/prevloc.cxx
+index fb65955..65c7f73 100644
+--- sc/source/ui/view/prevloc.cxx
++++ sc/source/ui/view/prevloc.cxx
+@@ -692,7 +692,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
+                 if (pDoc->RowHidden(nRow, nTab))
+                     continue;
+ 
+-                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
++                USHORT nDocH = pDoc->GetOriginalHeight( nRow, nTab );
+                 long nNextY = nPosY + (long) (nDocH * nScaleY);
+ 
+                 long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
+@@ -713,7 +713,7 @@ void ScPreviewLocationData::GetTableInfo( const Rectangle& rVisiblePixel, ScPrev
+                 if (pDoc->RowHidden(nRow, nTab))
+                     continue;
+ 
+-                USHORT nDocH = pDoc->FastGetOriginalRowHeight( nRow, nTab );
++                USHORT nDocH = pDoc->GetOriginalHeight( nRow, nTab );
+                 long nNextY = nPosY + (long) (nDocH * nScaleY);
+ 
+                 long nPixelStart = pWindow->LogicToPixel( Size( 0, nPosY ), aCellMapMode ).Height();
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-selection-fixed-cursor.diff ooo-build-3.1.1.5/patches/dev300/calc-selection-fixed-cursor.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-selection-fixed-cursor.diff	2009-10-19 21:39:14.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/calc-selection-fixed-cursor.diff	2009-10-23 15:16:33.000000000 +0300
@@ -153,7 +153,7 @@
      SCsCOLROW nRTLSign = 1;
      if ( pData->GetDocument()->IsLayoutRTL( pData->GetTabNo() ) )
      {
-@@ -172,38 +218,61 @@ void ScCellShell::GetStateCursor( SfxItemSet& /* rSet */ )
+@@ -172,38 +218,64 @@ void ScCellShell::GetStateCursor( SfxItemSet& /* rSet */ )
  
  void ScCellShell::ExecuteCursorSel( SfxRequest& rReq )
  {
@@ -179,7 +179,10 @@
  
 -    switch ( nSlotId )
 +    // Horizontal direction depends on whether or not the UI language is RTL.
-+    SCsCOL nMovX = Application::GetSettings().GetLayoutRTL() ? -1 : 1;
++    SCsCOL nMovX = 1;
++    if (GetViewData()->GetDocument()->IsLayoutRTL(GetViewData()->GetTabNo()))
++        // mirror horizontal movement for right-to-left mode.
++        nMovX = -1;
 +
 +    switch (nSlotId)
      {
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-xls-import-sheet-protection-fix.diff ooo-build-3.1.1.5/patches/dev300/calc-xls-import-sheet-protection-fix.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-xls-import-sheet-protection-fix.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-xls-import-sheet-protection-fix.diff	2009-11-26 15:41:26.000000000 +0200
@@ -0,0 +1,35 @@
+diff --git sc/source/filter/excel/xicontent.cxx sc/source/filter/excel/xicontent.cxx
+index cfe65b4..666083d 100644
+--- sc/source/filter/excel/xicontent.cxx
++++ sc/source/filter/excel/xicontent.cxx
+@@ -1228,7 +1228,29 @@ void XclImpSheetProtectBuffer::ReadProtect( XclImpStream& rStrm, SCTAB nTab )
+ 
+ void XclImpSheetProtectBuffer::ReadOptions( XclImpStream& rStrm, SCTAB nTab )
+ {
+-    rStrm.Ignore(19);
++    rStrm.Ignore(12);
++
++    // feature type can be either 2 or 4.  If 2, this record stores flag for 
++    // enhanced protection, whereas if 4 it stores flag for smart tag.
++    sal_uInt16 nFeatureType;
++    rStrm >> nFeatureType;
++    if (nFeatureType != 2)
++        // We currently only support import of enhanced protection data.
++        return;
++
++    rStrm.Ignore(1); // always 1
++
++    // The flag size specifies the size of bytes that follows that stores 
++    // feature data.  If -1 it depends on the feature type imported earlier.
++    // For enhanced protection data, the size is always 4.  For the most xls
++    // documents out there this value is almost always -1.
++    sal_Int32 nFlagSize;
++    rStrm >> nFlagSize;
++    if (nFlagSize != -1)
++        return;
++
++    // There are actually 4 bytes to read, but the upper 2 bytes currently 
++    // don't store any bits.
+     sal_uInt16 nOptions;
+     rStrm >> nOptions;
+ 
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-xls-import-slanted-border-oox.diff ooo-build-3.1.1.5/patches/dev300/calc-xls-import-slanted-border-oox.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-xls-import-slanted-border-oox.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-xls-import-slanted-border-oox.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,93 @@
+diff --git oox/inc/oox/xls/stylesbuffer.hxx oox/inc/oox/xls/stylesbuffer.hxx
+index e9d17db..4f288f5 100644
+--- oox/inc/oox/xls/stylesbuffer.hxx
++++ oox/inc/oox/xls/stylesbuffer.hxx
+@@ -434,6 +434,8 @@ public:
+     /** Writes all border attributes to the passed property set. */
+     void                writeToPropertySet( PropertySet& rPropSet ) const;
+ 
++    bool                hasBorder() const;
++
+ private:
+     /** Returns the border line struct specified by the passed XML token identifier. */
+     OoxBorderLineData*  getBorderLine( sal_Int32 nElement );
+@@ -857,6 +859,7 @@ public:
+     /** Writes the cell formatting attributes of the specified style XF to the passed property set. */
+     void                writeStyleXfToPropertySet( PropertySet& rPropSet, sal_Int32 nXfId ) const;
+ 
++    bool                hasBorder( sal_Int32 nBorderId ) const;
+ private:
+     void                insertCellStyle( CellStyleRef xCellStyle );
+ 
+diff --git oox/source/xls/stylesbuffer.cxx oox/source/xls/stylesbuffer.cxx
+index 5627c78..00411bb 100644
+--- oox/source/xls/stylesbuffer.cxx
++++ oox/source/xls/stylesbuffer.cxx
+@@ -40,6 +40,7 @@
+ #include <com/sun/star/style/XStyle.hpp>
+ #include <com/sun/star/text/WritingMode2.hpp>
+ #include <com/sun/star/text/XText.hpp>
++#include <com/sun/star/table/CellVertJustify.hpp>
+ #include <rtl/tencinfo.h>
+ #include <rtl/ustrbuf.hxx>
+ #include "oox/helper/attributelist.hxx"
+@@ -1599,6 +1600,34 @@ void Border::writeToPropertySet( PropertySet& rPropSet ) const
+     getStylesPropertyHelper().writeBorderProperties( rPropSet, maApiData );
+ }
+ 
++namespace {
++
++bool lcl_isBorder(const ::com::sun::star::table::BorderLine& rBorder)
++{
++    return (rBorder.InnerLineWidth > 0) || (rBorder.OuterLineWidth > 0);
++}
++
++}
++
++bool Border::hasBorder() const
++{
++    const ApiBorderData::ApiTableBorder& rTabBorder = maApiData.maBorder;
++
++    if (rTabBorder.IsBottomLineValid && lcl_isBorder(rTabBorder.BottomLine))
++        return true;
++
++    if (rTabBorder.IsTopLineValid && lcl_isBorder(rTabBorder.TopLine))
++        return true;
++
++    if (rTabBorder.IsLeftLineValid && lcl_isBorder(rTabBorder.LeftLine))
++        return true;
++
++    if (rTabBorder.IsRightLineValid && lcl_isBorder(rTabBorder.RightLine))
++        return true;
++
++    return false;
++}
++
+ OoxBorderLineData* Border::getBorderLine( sal_Int32 nElement )
+ {
+     switch( nElement )
+@@ -2255,6 +2284,11 @@ void Xf::writeToPropertySet( PropertySet& rPropSet ) const
+         rStyles.writeBorderToPropertySet( rPropSet, maOoxData.mnBorderId );
+     if( maOoxData.mbAreaUsed )
+         rStyles.writeFillToPropertySet( rPropSet, maOoxData.mnFillId );
++
++    ::com::sun::star::table::CellVertJustify eRotRef = ::com::sun::star::table::CellVertJustify_STANDARD;
++    if (maOoxData.mbBorderUsed && rStyles.hasBorder(maOoxData.mnBorderId) && maAlignment.getApiData().mnRotation)
++        eRotRef = ::com::sun::star::table::CellVertJustify_BOTTOM;
++    rPropSet.setProperty( CREATE_OUSTRING("RotateReference"), eRotRef );
+ }
+ 
+ void Xf::setBiffUsedFlags( sal_uInt8 nUsedFlags )
+@@ -3150,6 +3184,12 @@ void StylesBuffer::writeCellXfToPropertySet( PropertySet& rPropSet, sal_Int32 nX
+         pXf->writeToPropertySet( rPropSet );
+ }
+ 
++bool StylesBuffer::hasBorder( sal_Int32 nBorderId ) const
++{
++    Border* pBorder = maBorders.get( nBorderId ).get();
++    return pBorder && pBorder->hasBorder();
++}
++
+ void StylesBuffer::writeStyleXfToPropertySet( PropertySet& rPropSet, sal_Int32 nXfId ) const
+ {
+     if( Xf* pXf = maStyleXfs.get( nXfId ).get() )
diff -Nur ooo-build-3.1.1.4/patches/dev300/calc-xls-import-slanted-border-sc.diff ooo-build-3.1.1.5/patches/dev300/calc-xls-import-slanted-border-sc.diff
--- ooo-build-3.1.1.4/patches/dev300/calc-xls-import-slanted-border-sc.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/calc-xls-import-slanted-border-sc.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,77 @@
+diff --git sc/source/filter/excel/xistyle.cxx sc/source/filter/excel/xistyle.cxx
+index 9f38dda..ac5e956 100644
+--- sc/source/filter/excel/xistyle.cxx
++++ sc/source/filter/excel/xistyle.cxx
+@@ -765,7 +765,6 @@ void XclImpCellAlign::FillToItemSet( SfxItemSet& rItemSet, const XclImpFont* pFo
+     sal_uInt8 nXclRot = (mnOrient == EXC_ORIENT_NONE) ? mnRotation : XclTools::GetXclRotFromOrient( mnOrient );
+     bool bStacked = (nXclRot == EXC_ROT_STACKED);
+     ScfTools::PutItem( rItemSet, SfxBoolItem( ATTR_STACKED, bStacked ), bSkipPoolDefs );
+-    ScfTools::PutItem( rItemSet, SvxRotateModeItem( SVX_ROTATE_MODE_STANDARD, ATTR_ROTATE_MODE ), bSkipPoolDefs );
+     // set an angle in the range from -90 to 90 degrees
+     sal_Int32 nAngle = XclTools::GetScRotation( nXclRot, 0 );
+     ScfTools::PutItem( rItemSet, SfxInt32Item( ATTR_ROTATE_VALUE, nAngle ), bSkipPoolDefs );
+@@ -863,6 +862,15 @@ void XclImpCellBorder::FillFromCF8( sal_uInt16 nLineStyle, sal_uInt32 nLineColor
+     mbDiagUsed    = false;
+ }
+ 
++bool XclImpCellBorder::HasAnyOuterBorder() const
++{
++    return
++        (mbLeftUsed   && (mnLeftLine != EXC_LINE_NONE)) ||
++        (mbRightUsed  && (mnRightLine != EXC_LINE_NONE)) ||
++        (mbTopUsed    && (mnTopLine != EXC_LINE_NONE)) ||
++        (mbBottomUsed && (mnBottomLine != EXC_LINE_NONE));
++}
++
+ namespace {
+ 
+ /** Converts the passed line style to a SvxBorderLine, or returns false, if style is "no line". */
+@@ -1244,11 +1252,12 @@ const ScPatternAttr& XclImpXF::CreatePattern( bool bSkipPoolDefs )
+     // create new pattern attribute set
+     mpPattern.reset( new ScPatternAttr( GetDoc().GetPool() ) );
+     SfxItemSet& rItemSet = mpPattern->GetItemSet();
++    XclImpXF* pParentXF = IsCellXF() ? GetXFBuffer().GetXF( mnParent ) : 0;
+ 
+     // parent cell style
+     if( IsCellXF() )
+     {
+-        if( XclImpXF* pParentXF = GetXFBuffer().GetXF( mnParent ) )
++        if( pParentXF )
+         {
+             mpStyleSheet = pParentXF->CreateStyleSheet();
+             UpdateUsedFlags( *pParentXF );
+@@ -1292,6 +1301,20 @@ const ScPatternAttr& XclImpXF::CreatePattern( bool bSkipPoolDefs )
+             maArea.mnPattern != EXC_PATT_SOLID);
+     }
+ 
++    /*  #i38709# Decide which rotation reference mode to use. If any outer
++        border line of the cell is set (either explicitly or via cell style),
++        and the cell contents are rotated, set rotation reference to bottom of
++        cell. This causes the borders to be painted rotated with the text. */
++    if( mbAlignUsed || mbBorderUsed )
++    {
++        SvxRotateMode eRotateMode = SVX_ROTATE_MODE_STANDARD;
++        const XclImpCellAlign* pAlign = mbAlignUsed ? &maAlignment : (pParentXF ? &pParentXF->maAlignment : 0);
++        const XclImpCellBorder* pBorder = mbBorderUsed ? &maBorder : (pParentXF ? &pParentXF->maBorder : 0);
++        if( pAlign && pBorder && (0 < pAlign->mnRotation) && (pAlign->mnRotation <= 180) && pBorder->HasAnyOuterBorder() )
++            eRotateMode = SVX_ROTATE_MODE_BOTTOM;
++        ScfTools::PutItem( rItemSet, SvxRotateModeItem( eRotateMode, ATTR_ROTATE_MODE ), bSkipPoolDefs );
++    }
++
+     return *mpPattern;
+ }
+ 
+diff --git sc/source/filter/inc/xistyle.hxx sc/source/filter/inc/xistyle.hxx
+index 91d9265..92ceca6 100644
+--- sc/source/filter/inc/xistyle.hxx
++++ sc/source/filter/inc/xistyle.hxx
+@@ -321,6 +321,9 @@ struct XclImpCellBorder : public XclCellBorder
+     /** Fills this struct with BIFF8 CF (conditional format) record data. */
+     void                FillFromCF8( sal_uInt16 nLineStyle, sal_uInt32 nLineColor, sal_uInt32 nFlags );
+ 
++    /** Returns true, if any of the outer border lines is visible. */
++    bool                HasAnyOuterBorder() const;
++
+     /** Inserts a box item representing this border style into the item set.
+         @param bSkipPoolDefs  true = Do not put items equal to pool default; false = Put all items. */
+     void                FillToItemSet(
diff -Nur ooo-build-3.1.1.4/patches/dev300/cws-linuxhppa1.diff ooo-build-3.1.1.5/patches/dev300/cws-linuxhppa1.diff
--- ooo-build-3.1.1.4/patches/dev300/cws-linuxhppa1.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/cws-linuxhppa1.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,2172 @@
+# HG changeset patch
+# User Caolán McNamara <cmc@openoffice.org>
+# Date 1258645276 0
+# Node ID 9e94a83ee85cd717604b6c7ace0ac38bd8a1b4f2
+# Parent  0d8650731e2fe04a3b67ec4e9728924544664187
+linuxhppa1: #i107051#: port to linux hppa (parisc)
+
+diff -r 0d8650731e2f -r 9e94a83ee85c automation/source/testtool/objtest.cxx
+--- automation/source/testtool/objtest.cxx	Mon Nov 16 21:50:44 2009 +0100
++++ automation/source/testtool/objtest.cxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -521,6 +521,8 @@
+     abGP.Append( "20" );  // Linux ia64
+ #elif defined LINUX && defined S390
+     abGP.Append( "21" );  // Linux S390
++#elif defined LINUX && defined HPPA
++    abGP.Append( "22" );  // Linux PA-RISC
+ #else
+ #error ("unknown platform. please request an ID for your platform on qa/dev")
+ #endif
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/prj/build.lst
+--- bridges/prj/build.lst	Mon Nov 16 21:50:44 2009 +0100
++++ bridges/prj/build.lst	Thu Nov 19 15:41:16 2009 +0000
+@@ -21,6 +21,7 @@
+ br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes br_cppuno_shared br_inc NULL
+ br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gccl3r br_unotypes NULL
+ br	bridges\source\cpp_uno\gcc3_linux_ia64		nmake	-	u	br_gccl3a br_unotypes NULL
++br	bridges\source\cpp_uno\gcc3_linux_hppa		nmake	-	u	br_gccl3h br_unotypes NULL
+ br	bridges\source\cpp_uno\gcc3_macosx_intel			nmake	-	u	br_gcc3macoxi br_cppuno_shared br_unotypes br_inc NULL
+ br	bridges\source\cpp_uno\gcc3_macosx_powerpc			nmake	-	u	br_gcc3macoxp br_cppuno_shared br_unotypes br_inc NULL
+ br	bridges\source\cpp_uno\cc50_solaris_sparc			nmake	-	u	br_cc50sols br_unotypes br_cppuno_shared br_inc NULL
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_hppa/call.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_hppa/call.cxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,145 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2008 by Sun Microsystems, Inc.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * $RCSfile: uno2cpp.cxx,v $
++ * $Revision: 1.2 $
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++#include <malloc.h>
++#include <rtl/alloc.h>
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include "com/sun/star/uno/RuntimeException.hpp"
++#include <uno/data.h>
++
++#include <bridges/cpp_uno/shared/bridge.hxx>
++#include <bridges/cpp_uno/shared/types.hxx>
++#include <bridges/cpp_uno/shared/unointerfaceproxy.hxx>
++#include <bridges/cpp_uno/shared/vtables.hxx>
++
++#include "share.hxx"
++
++#include <stdio.h>
++#include <string.h>
++
++using namespace ::rtl;
++using namespace ::com::sun::star::uno;
++
++void MapReturn(sal_uInt32 ret0, sal_uInt32 ret1, typelib_TypeDescription *pReturnTypeDescr, bool bRegisterReturn, sal_uInt32 *pRegisterReturn)
++{
++    register float fret asm("fr4");
++    register double dret asm("fr4");
++
++    switch (pReturnTypeDescr->eTypeClass)
++    {
++        case typelib_TypeClass_HYPER:
++        case typelib_TypeClass_UNSIGNED_HYPER:
++            pRegisterReturn[1] = ret1;
++        case typelib_TypeClass_LONG:
++        case typelib_TypeClass_UNSIGNED_LONG:
++        case typelib_TypeClass_ENUM:
++        case typelib_TypeClass_CHAR:
++        case typelib_TypeClass_SHORT:
++        case typelib_TypeClass_UNSIGNED_SHORT:
++        case typelib_TypeClass_BOOLEAN:
++        case typelib_TypeClass_BYTE:
++            pRegisterReturn[0] = ret0;
++            break;
++        case typelib_TypeClass_FLOAT:
++            *(float*)pRegisterReturn = fret;
++	    break;
++        case typelib_TypeClass_DOUBLE:
++            *(double*)pRegisterReturn = dret;
++            break;
++        case typelib_TypeClass_STRUCT:
++        case typelib_TypeClass_EXCEPTION:
++        {
++            if (bRegisterReturn)
++            {
++                pRegisterReturn[0] = ret0;
++                pRegisterReturn[1] = ret1;
++            }
++            break;
++        }
++        default:
++            break;
++    }
++}
++
++//Moved callVirtual into this .cxx so that I can do this and get gcc to not
++//touch r28 without having to learn any more pa-risc assembly than is
++//strictly necessary
++register sal_uInt32 r28 __asm__("%r28");
++
++void callVirtualMethod(void * pThis, sal_uInt32 nVtableIndex, 
++    void * pRegisterReturn, typelib_TypeDescription *pReturnTypeDescr, bool bRegisterReturn,
++    sal_uInt32 *pStack, sal_uInt32 nStack, sal_uInt32 *pGPR, double *pFPR) __attribute__((noinline));
++
++void callVirtualMethod(void * pThis, sal_uInt32 nVtableIndex, 
++    void * pRegisterReturn, typelib_TypeDescription *pReturnTypeDescr, bool bRegisterReturn,
++    sal_uInt32 *pStack, sal_uInt32 nStack, sal_uInt32 *pGPR, double *pFPR)
++{
++    register sal_uInt32* sp __asm__("%r30");
++
++    sal_uInt32 pMethod = *((sal_uInt32*)pThis);
++    pMethod += 4 * nVtableIndex;
++    pMethod = *((sal_uInt32 *)pMethod);
++
++#ifdef CMC_DEBUG
++    fprintf(stderr, "this is %p\n", pGPR[0]);
++    for (int i = 0; i < hppa::MAX_GPR_REGS ; ++i)
++        fprintf(stderr, "normal reg %d is %d %x\n", i, pGPR[i], pGPR[i]);
++
++    for (int i = 0; i < hppa::MAX_SSE_REGS ; ++i)
++        fprintf(stderr, "float reg %d is %x\n", i, pFPR[i]);
++
++    for (int i = 0; i < nStack; ++i)
++        fprintf(stderr, "stack bytes are %x\n", pStack[i]);
++#endif
++
++    //Always reserve 4 slots, and align to 8 bytes
++    sal_uInt32 nStackBytes = ( ( nStack + 4 + 1 ) >> 1 ) * 8;
++    __builtin_alloca(nStackBytes);
++    sal_uInt32 *stack = sp-8;
++    int o = -5;
++    for (sal_uInt32 i = 0; i < nStack; ++i, --o)
++        stack[o] = pStack[i];
++
++    typedef int (* FunctionCall )( sal_uInt32, sal_uInt32, sal_uInt32, sal_uInt32 );
++    FunctionCall pFunc = (FunctionCall)pMethod;
++
++    asm volatile("fldd %0, %%fr4" : : "m"(pFPR[0]) : "fr4");
++    asm volatile("fldd %0, %%fr5" : : "m"(pFPR[1]) : "fr5");
++    asm volatile("fldd %0, %%fr6" : : "m"(pFPR[2]) : "fr6");
++    asm volatile("fldd %0, %%fr7" : : "m"(pFPR[3]) : "fr7");
++    asm volatile("ldw %0, %%r28" : : "m"(pRegisterReturn) : "r28");
++    (*pFunc)(pGPR[0], pGPR[1], pGPR[2], pGPR[3]);
++
++    register sal_uInt32 r29 __asm__("%r29");
++    MapReturn(r28, r29, pReturnTypeDescr, bRegisterReturn, (sal_uInt32*)pRegisterReturn);
++}
++
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_hppa/cpp2uno.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_hppa/cpp2uno.cxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,728 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2008 by Sun Microsystems, Inc.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * $RCSfile: cpp2uno.cxx,v $
++ * $Revision: 1.2 $
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++#include <malloc.h>
++#include <hash_map>
++
++#include <rtl/alloc.h>
++#include <osl/mutex.hxx>
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include "com/sun/star/uno/RuntimeException.hpp"
++#include <uno/data.h>
++#include <typelib/typedescription.hxx>
++
++#include "bridges/cpp_uno/shared/bridge.hxx"
++#include "bridges/cpp_uno/shared/cppinterfaceproxy.hxx"
++#include "bridges/cpp_uno/shared/types.hxx"
++#include "bridges/cpp_uno/shared/vtablefactory.hxx"
++
++#include "share.hxx"
++
++#include <dlfcn.h>
++
++
++using namespace ::osl;
++using namespace ::rtl;
++using namespace ::com::sun::star::uno;
++
++namespace
++{
++
++    static typelib_TypeClass cpp2uno_call(
++        bridges::cpp_uno::shared::CppInterfaceProxy* pThis,
++        const typelib_TypeDescription * pMemberTypeDescr,
++        typelib_TypeDescriptionReference * pReturnTypeRef, 
++        sal_Int32 nParams, typelib_MethodParameter * pParams,
++        long r8, void ** gpreg, double *fpreg, void ** ovrflw,
++        sal_Int64 * pRegisterReturn /* space for register return */ )
++    {
++        void ** startovrflw;
++        int nregs = 0; //number of words passed in registers
++
++#ifdef CMC_DEBUG
++	fprintf(stderr, "cpp2uno_call\n");
++#endif
++        // return
++        typelib_TypeDescription * pReturnTypeDescr = 0;
++        if (pReturnTypeRef)
++            TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
++        
++        void * pUnoReturn = 0;
++        // complex return ptr: if != 0 && != pUnoReturn, reconversion need
++        void * pCppReturn = 0;
++
++        if (pReturnTypeDescr)
++        {
++            if (hppa::isRegisterReturn(pReturnTypeRef))
++            {
++#ifdef CMC_DEBUG
++		fprintf(stderr, "simple return\n");
++#endif
++                pUnoReturn = pRegisterReturn; // direct way for simple types
++            }
++            else
++            {
++#ifdef CMC_DEBUG
++		fprintf(stderr, "complex return via r8\n");
++#endif
++                pCppReturn = (void *)r8;
++
++                pUnoReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
++                    ? alloca( pReturnTypeDescr->nSize )
++                    : pCppReturn); // direct way
++            }
++        }
++        // pop this
++        gpreg++;
++        fpreg++;
++        nregs++;
++
++        // stack space
++        OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
++        // parameters
++        void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
++        void ** pCppArgs = pUnoArgs + nParams;
++        // indizes of values this have to be converted (interface conversion
++        // cpp<=>uno)
++        sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
++        // type descriptions for reconversions
++        typelib_TypeDescription ** ppTempParamTypeDescr = 
++            (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
++        
++        sal_Int32 nTempIndizes   = 0;
++        bool bOverFlowUsed = false;
++        for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
++        {
++            const typelib_MethodParameter & rParam = pParams[nPos];
++            typelib_TypeDescription * pParamTypeDescr = 0;
++            TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
++
++            if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
++            {
++                switch (pParamTypeDescr->eTypeClass)
++                {
++                    case typelib_TypeClass_DOUBLE:
++                        if (nregs < hppa::MAX_WORDS_IN_REGS && (nregs & 1))
++                        {
++                            gpreg++;
++                            fpreg++;
++                            nregs++;
++                        }
++                        if (nregs < hppa::MAX_WORDS_IN_REGS-1)
++                        {
++                            fpreg++;
++                            pCppArgs[nPos] = pUnoArgs[nPos] = fpreg;
++                            gpreg+=2;
++                            fpreg+=2;
++                            nregs+=2;
++                        }
++                        else
++                        {
++                            if ((startovrflw-ovrflw) & 4)
++                                ovrflw--;
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)ovrflw - 4);
++                            bOverFlowUsed = true;
++                        }
++                        if (bOverFlowUsed) ovrflw-=2;
++                        break;
++                    case typelib_TypeClass_FLOAT:
++                        if (nregs < hppa::MAX_WORDS_IN_REGS)
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = fpreg;
++                            gpreg++;
++                            fpreg++;
++                            nregs++;
++                        }
++                        else
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                            bOverFlowUsed = true;
++                        }
++                        if (bOverFlowUsed) ovrflw--;
++                        break;
++                    case typelib_TypeClass_HYPER:
++                    case typelib_TypeClass_UNSIGNED_HYPER:
++                        if (nregs < hppa::MAX_WORDS_IN_REGS && (nregs & 1))
++                        {
++                            gpreg++;
++                            fpreg++;
++                            nregs++;
++                        }
++                        if (nregs < hppa::MAX_WORDS_IN_REGS-1)
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
++                            gpreg+=2;
++                            fpreg+=2;
++                            nregs+=2;
++                        }
++                        else
++                        {
++                            if ((startovrflw-ovrflw) & 4)
++                                ovrflw--;
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)ovrflw - 4);
++                            bOverFlowUsed = true;
++                        }
++                        if (bOverFlowUsed) ovrflw-=2;
++                        break;
++                    case typelib_TypeClass_BYTE:
++                    case typelib_TypeClass_BOOLEAN:
++                        if (nregs < hppa::MAX_WORDS_IN_REGS)
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)gpreg + 3);
++                            gpreg++;
++                            fpreg++;
++                            nregs++;
++                        }
++                        else
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)ovrflw+3);
++                            bOverFlowUsed = true;
++                        }
++                        if (bOverFlowUsed) ovrflw--;
++                        break;
++                    case typelib_TypeClass_CHAR:
++                    case typelib_TypeClass_SHORT:
++                    case typelib_TypeClass_UNSIGNED_SHORT:
++                        if (nregs < hppa::MAX_WORDS_IN_REGS)
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)gpreg+2);
++                            gpreg++;
++                            fpreg++;
++                            nregs++;
++                        }
++                        else
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ((char*)ovrflw+2);
++                            bOverFlowUsed = true;
++                        }
++                        if (bOverFlowUsed) ovrflw--;
++                        break;
++                    case typelib_TypeClass_ENUM:
++                    case typelib_TypeClass_LONG:
++                    case typelib_TypeClass_UNSIGNED_LONG:
++                    default:
++                        if (nregs < hppa::MAX_WORDS_IN_REGS)
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = gpreg;
++                            gpreg++;
++                            fpreg++;
++                            nregs++;
++                        }
++                        else
++                        {
++                            pCppArgs[nPos] = pUnoArgs[nPos] = ovrflw;
++                            bOverFlowUsed = true;
++                        }
++                        if (bOverFlowUsed) ovrflw--;
++                        break;
++                }
++                // no longer needed
++                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++            }
++            else // ptr to complex value | ref
++            {
++                void *pCppStack;
++
++                if (nregs < hppa::MAX_WORDS_IN_REGS)
++                {
++                    pCppArgs[nPos] = pCppStack = *gpreg;
++                    gpreg++;
++                    fpreg++;
++                    nregs++;
++                }
++                else
++                {
++                    pCppArgs[nPos] = pCppStack = *ovrflw;
++                    bOverFlowUsed = true;
++                }
++                if (bOverFlowUsed) ovrflw--;
++
++                if (! rParam.bIn) // is pure out
++                {
++                    // uno out is unconstructed mem!
++                    pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
++                    pTempIndizes[nTempIndizes] = nPos;
++                    // will be released at reconversion
++                    ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++                }
++                // is in/inout
++                else if (bridges::cpp_uno::shared::relatesToInterfaceType(
++                    pParamTypeDescr ))
++                {
++                   uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ), 
++                        pCppStack, pParamTypeDescr,
++                        pThis->getBridge()->getCpp2Uno() );
++                    pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
++                    // will be released at reconversion
++                    ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++                }
++                else // direct way
++                {
++                    pUnoArgs[nPos] = pCppStack;
++                    // no longer needed
++                    TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++                }
++            }
++        }
++
++        // ExceptionHolder
++        uno_Any aUnoExc; // Any will be constructed by callee
++        uno_Any * pUnoExc = &aUnoExc;
++
++#ifdef CMC_DEBUG
++	fprintf(stderr, "before dispatch\n");
++#endif
++        // invoke uno dispatch call
++        (*pThis->getUnoI()->pDispatcher)(
++          pThis->getUnoI(), pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
++
++#ifdef CMC_DEBUG
++	fprintf(stderr, "after dispatch\n");
++#endif
++
++        // in case an exception occured...
++        if (pUnoExc)
++        {
++            // destruct temporary in/inout params
++            for ( ; nTempIndizes--; )
++            {
++                sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++                
++                if (pParams[nIndex].bIn) // is in/inout => was constructed
++                    uno_destructData( pUnoArgs[nIndex], 
++                        ppTempParamTypeDescr[nTempIndizes], 0 );
++                TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
++            }
++            if (pReturnTypeDescr)
++                TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
++            
++            CPPU_CURRENT_NAMESPACE::raiseException( &aUnoExc, 
++                pThis->getBridge()->getUno2Cpp() ); // has to destruct the any
++            // is here for dummy
++            return typelib_TypeClass_VOID;
++        }
++        else // else no exception occured...
++        {
++            // temporary params
++            for ( ; nTempIndizes--; )
++            {
++                sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++                typelib_TypeDescription * pParamTypeDescr =
++                    ppTempParamTypeDescr[nTempIndizes];
++                
++                if (pParams[nIndex].bOut) // inout/out
++                {
++                    // convert and assign
++                    uno_destructData( pCppArgs[nIndex], pParamTypeDescr,
++                        cpp_release );
++                    uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], 
++                        pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
++                }
++                // destroy temp uno param
++                uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
++                
++                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++            }
++            // return
++            if (pCppReturn) // has complex return
++            {
++                if (pUnoReturn != pCppReturn) // needs reconversion
++                {
++                    uno_copyAndConvertData( pCppReturn, pUnoReturn,
++                        pReturnTypeDescr, pThis->getBridge()->getUno2Cpp() );
++                    // destroy temp uno return
++                    uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
++                }
++                // complex return ptr is set to eax
++                *(void **)pRegisterReturn = pCppReturn;
++            }
++            if (pReturnTypeDescr)
++            {
++                typelib_TypeClass eRet =
++                    (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
++                TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
++                return eRet;
++            }
++            else
++                return typelib_TypeClass_VOID;
++        }
++    }
++
++
++    //=====================================================================
++    static typelib_TypeClass cpp_mediate(
++        sal_Int32 nFunctionIndex, sal_Int32 nVtableOffset,
++        void ** gpreg, double* fpreg,
++        long sp, long r8,
++        sal_Int64 * pRegisterReturn /* space for register return */ )
++
++    {
++	void ** ovrflw = (void**)(sp);
++#ifdef CMC_DEBUG
++	fprintf(stderr, "cpp_mediate with\n");
++	fprintf(stderr, "%x %x\n", nFunctionIndex, nVtableOffset);
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[0]), (long)(ovrflw[-1]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-2]), (long)(ovrflw[-3]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-4]), (long)(ovrflw[-5]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-6]), (long)(ovrflw[-7]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-8]), (long)(ovrflw[-9]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-10]), (long)(ovrflw[-11]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-12]), (long)(ovrflw[-13]));
++	fprintf(stderr, "and %x %x\n", (long)(ovrflw[-14]), (long)(ovrflw[-15]));
++#endif
++        OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
++
++        // gpreg:  [ret *], this, [other gpr params]
++        // fpreg:  [fpr params]
++        // ovrflw: [gpr or fpr params (properly aligned)]
++
++        void * pThis;
++        if (nFunctionIndex & 0x80000000 )
++        {
++	    nFunctionIndex &= 0x7fffffff;
++	    pThis = gpreg[1];
++#ifdef CMC_DEBUG
++	    fprintf(stderr, "pThis is gpreg[1]\n");
++#endif
++        }
++        else
++        {
++	    pThis = gpreg[0];
++#ifdef CMC_DEBUG
++            fprintf(stderr, "pThis is gpreg[0]\n");
++#endif
++        }
++
++        pThis = static_cast< char * >(pThis) - nVtableOffset;
++
++        bridges::cpp_uno::shared::CppInterfaceProxy * pCppI = 
++            bridges::cpp_uno::shared::CppInterfaceProxy::castInterfaceToProxy(
++                pThis);
++            
++        typelib_InterfaceTypeDescription * pTypeDescr = pCppI->getTypeDescr();
++
++        OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex,
++            "### illegal vtable index!" );
++        if (nFunctionIndex >= pTypeDescr->nMapFunctionIndexToMemberIndex)
++        {
++            throw RuntimeException(
++                OUString::createFromAscii("illegal vtable index!"),
++                (XInterface *)pCppI );
++        }
++
++        // determine called method
++        OSL_ENSURE( nFunctionIndex < pTypeDescr->nMapFunctionIndexToMemberIndex,
++            "### illegal vtable index!" );
++        sal_Int32 nMemberPos =
++            pTypeDescr->pMapFunctionIndexToMemberIndex[nFunctionIndex];
++        OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers,
++            "### illegal member index!" );
++
++        TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
++
++        typelib_TypeClass eRet;
++        switch (aMemberDescr.get()->eTypeClass)
++        {
++        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
++        {
++            if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] ==
++                nFunctionIndex)
++            {
++                // is GET method
++                eRet = cpp2uno_call(
++                    pCppI, aMemberDescr.get(),
++                    ((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
++                    0, 0, // no params
++                    r8, gpreg, fpreg, ovrflw, pRegisterReturn );
++            }
++            else
++            {
++                // is SET method
++                typelib_MethodParameter aParam;
++                aParam.pTypeRef =
++                    ((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
++                aParam.bIn      = sal_True;
++                aParam.bOut     = sal_False;
++                
++                eRet = cpp2uno_call(
++                    pCppI, aMemberDescr.get(),
++                    0, // indicates void return
++                    1, &aParam,
++                    r8, gpreg, fpreg, ovrflw, pRegisterReturn );
++            }
++            break;
++        }
++        case typelib_TypeClass_INTERFACE_METHOD:
++        {
++            // is METHOD
++            switch (nFunctionIndex)
++            {
++            case 1: // acquire()
++                pCppI->acquireProxy(); // non virtual call!
++                eRet = typelib_TypeClass_VOID;
++                break;
++            case 2: // release()
++                pCppI->releaseProxy(); // non virtual call!
++                eRet = typelib_TypeClass_VOID;
++                break;
++            case 0: // queryInterface() opt
++            {
++                typelib_TypeDescription * pTD = 0;
++                TYPELIB_DANGER_GET(&pTD,
++                    reinterpret_cast<Type *>(gpreg[1])->getTypeLibType());
++                if (pTD)
++                {
++                    XInterface * pInterface = 0;
++                    (*pCppI->getBridge()->getCppEnv()->getRegisteredInterface)(
++                        pCppI->getBridge()->getCppEnv(),
++                        (void **)&pInterface, pCppI->getOid().pData,
++                        (typelib_InterfaceTypeDescription *)pTD );
++                
++                    if (pInterface)
++                    {
++                        ::uno_any_construct(
++                            reinterpret_cast< uno_Any * >( r8 ),
++                            &pInterface, pTD, cpp_acquire );
++                        pInterface->release();
++                        TYPELIB_DANGER_RELEASE( pTD );
++                        *(void **)pRegisterReturn = (void*)r8;
++                        eRet = typelib_TypeClass_ANY;
++                        break;
++                    }
++                    TYPELIB_DANGER_RELEASE( pTD );
++                }
++            } // else perform queryInterface()
++            default:
++                eRet = cpp2uno_call(
++                    pCppI, aMemberDescr.get(),
++                    ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
++                    ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
++                    ((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
++                    r8, gpreg, fpreg, ovrflw, pRegisterReturn );
++            }
++            break;
++        }
++        default:
++        {
++            throw RuntimeException(
++                OUString::createFromAscii("no member description found!"),
++                (XInterface *)pCppI );
++            // is here for dummy
++            eRet = typelib_TypeClass_VOID;
++        }
++        }
++
++        return eRet;
++    }
++}
++
++//=======================================================================
++/**
++ * is called on incoming vtable calls
++ * (called by asm snippets)
++ */
++
++sal_Int64 cpp_vtable_call( sal_uInt32 in0, sal_uInt32 in1, sal_uInt32 in2, sal_uInt32 in3, sal_uInt32 firstonstack )
++{
++    register sal_Int32 r21 asm("r21");
++    register sal_Int32 r22 asm("r22");
++    register sal_Int32 r28 asm("r28");
++    sal_Int32 functionIndex = r21;
++    sal_Int32 vtableOffset = r22;
++    sal_Int32 r8 = r28;
++
++    long sp = (long)&firstonstack;
++
++    sal_uInt32 gpreg[hppa::MAX_GPR_REGS];
++    gpreg[0] = in0;
++    gpreg[1] = in1;
++    gpreg[2] = in2;
++    gpreg[3] = in3;
++
++    float fpreg[hppa::MAX_SSE_REGS]; //todo
++    register float f0 asm("fr4"); fpreg[0] = f0;
++    register float f1 asm("fr5"); fpreg[1] = f1;
++    register float f2 asm("fr6"); fpreg[2] = f2;
++    register float f3 asm("fr7"); fpreg[3] = f3;
++
++    double dpreg[hppa::MAX_SSE_REGS]; //todo
++    register double d0 asm("fr4"); dpreg[0] = d0;
++    register double d1 asm("fr5"); dpreg[1] = d1;
++    register double d2 asm("fr6"); dpreg[2] = d2;
++    register double d3 asm("fr7"); dpreg[3] = d3;
++
++
++#ifdef CMC_DEBUG
++    fprintf(stderr, "got to cpp_vtable_call with %x %x\n", functionIndex, vtableOffset);
++    for (int i = 0; i < hppa::MAX_GPR_REGS; ++i)
++	fprintf(stderr, "reg %d is %d %x\n", i, gpreg[i], gpreg[i]);
++    for (int i = 0; i < hppa::MAX_SSE_REGS; ++i)
++	fprintf(stderr, "float reg %d is %f %x\n", i, fpreg[i], ((long*)fpreg)[i]);
++    for (int i = 0; i < 4; ++i)
++	fprintf(stderr, "double reg %d is %f %llx\n", i, dpreg[i], ((long long*)dpreg)[i]);
++#endif
++
++    sal_Int64 nRegReturn;
++
++    typelib_TypeClass aType =
++        cpp_mediate( functionIndex, vtableOffset, (void**)gpreg, dpreg, sp, r8, &nRegReturn);
++
++    switch( aType )
++    {
++        case typelib_TypeClass_FLOAT:
++            f0 = (*((float*)&nRegReturn));
++            break;
++        case typelib_TypeClass_DOUBLE:
++            d0 = (*((double*)&nRegReturn));
++            break;
++        default:
++            break;
++    }
++
++    return nRegReturn;
++}
++
++
++namespace
++{
++    const int codeSnippetSize = 44;
++
++#   define unldil(v) (((v & 0x7c) << 14) | ((v & 0x180) << 7) | ((v & 0x3) << 12) | ((v & 0xffe00) >> 8) | ((v & 0x100000) >> 20))
++#   define L21(v)  unldil(((unsigned long)(v) >> 11) & 0x1fffff) //Left 21 bits
++#   define R11(v)  (((unsigned long)(v) & 0x7FF) << 1) //Right 11 bits
++
++    unsigned char *codeSnippet(unsigned char* code, sal_Int32 functionIndex, 
++        sal_Int32 vtableOffset, bool bHasHiddenParam)
++    {
++        if (bHasHiddenParam)
++            functionIndex |= 0x80000000;
++
++        unsigned char * p = code;
++        *(unsigned long*)&p[0]  = 0xeaa00000; // b,l 0x8,r21
++        *(unsigned long*)&p[4]  = 0xd6a01c1e; // depwi 0,31,2,r21
++        *(unsigned long*)&p[8]  = 0x4aa10040; // ldw 32(r21),r1
++
++        *(unsigned long*)&p[12] = 0x22A00000 | L21(functionIndex); // ldil L<functionIndex>,r21
++        *(unsigned long*)&p[16] = 0x36B50000 | R11(functionIndex); // ldo R<functionIndex>,r21
++
++        *(unsigned long*)&p[20] = 0x22C00000 | L21(vtableOffset); // ldil L<vtableOffset>,r22
++        *(unsigned long*)&p[24] = 0x36D60000 | R11(vtableOffset); // ldo R<vtableOffset>,r22
++
++        *(unsigned long*)&p[28] = 0x0c201094; // ldw 0(r1),r20
++        *(unsigned long*)&p[32] = 0xea80c000; // bv r0(r20)
++        *(unsigned long*)&p[36] = 0x0c281093; // ldw 4(r1),r19
++        *(unsigned long*)&p[40] = ((unsigned long)(cpp_vtable_call) & ~2);
++
++        return code + codeSnippetSize;
++    }
++}
++
++struct bridges::cpp_uno::shared::VtableFactory::Slot { void * fn; };
++
++bridges::cpp_uno::shared::VtableFactory::Slot *
++bridges::cpp_uno::shared::VtableFactory::mapBlockToVtable(void * block)
++{
++    return static_cast< Slot * >(block) + 2;
++}
++
++sal_Size bridges::cpp_uno::shared::VtableFactory::getBlockSize(
++    sal_Int32 slotCount)
++{
++    return (slotCount + 2) * sizeof (Slot) + slotCount * codeSnippetSize;
++}
++
++bridges::cpp_uno::shared::VtableFactory::Slot *
++bridges::cpp_uno::shared::VtableFactory::initializeBlock(
++    void * block, sal_Int32 slotCount)
++{
++    Slot * slots = mapBlockToVtable(block);
++    slots[-2].fn = 0;
++    slots[-1].fn = 0;
++    return slots + slotCount;
++}
++
++unsigned char * bridges::cpp_uno::shared::VtableFactory::addLocalFunctions(
++    Slot ** slots, unsigned char * code, sal_PtrDiff writetoexecdiff,
++    typelib_InterfaceTypeDescription const * type, sal_Int32 functionOffset,
++    sal_Int32 functionCount, sal_Int32 vtableOffset)
++{
++    (*slots) -= functionCount;
++    Slot * s = *slots;
++    for (sal_Int32 i = 0; i < type->nMembers; ++i)
++    {
++        typelib_TypeDescription * member = 0;
++        TYPELIB_DANGER_GET(&member, type->ppMembers[i]);
++        OSL_ASSERT(member != 0);
++        switch (member->eTypeClass)
++        {
++            case typelib_TypeClass_INTERFACE_ATTRIBUTE:
++                // Getter:
++                (s++)->fn = code + writetoexecdiff;
++                code = codeSnippet(code, functionOffset++, vtableOffset, false);
++                // Setter:
++                if (!reinterpret_cast<
++                    typelib_InterfaceAttributeTypeDescription * >(
++                        member)->bReadOnly)
++                {
++                    (s++)->fn = code + writetoexecdiff;
++                    code = codeSnippet(code, functionOffset++, vtableOffset, false);
++                }
++                break;
++            case typelib_TypeClass_INTERFACE_METHOD:
++            {
++                (s++)->fn = code + writetoexecdiff;
++                code = codeSnippet(code, functionOffset++, vtableOffset, false);
++                break;
++            }
++        default:
++            OSL_ASSERT(false);
++            break;
++        }
++        TYPELIB_DANGER_RELEASE(member);
++    }
++    return code;
++}
++
++void bridges::cpp_uno::shared::VtableFactory::flushCode(
++    unsigned char const *beg, unsigned char const *end)
++{
++    void *p = (void*)((size_t)beg & ~31);
++    size_t stride = 32;
++    while (p < end)
++    {
++        asm volatile("fdc (%0)\n\t"
++                     "sync\n\t"
++                     "fic,m %1(%%sr4, %0)\n\t"
++                     "sync" : "+r"(p) : "r"(stride) : "memory");
++    }
++}
++
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_hppa/except.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_hppa/except.cxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,337 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2008 by Sun Microsystems, Inc.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * $RCSfile: except.cxx,v $
++ * $Revision: 1.2 $
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++#include <stdio.h>
++#include <string.h>
++#include <dlfcn.h>
++#include <cxxabi.h>
++#include <hash_map>
++
++#include <rtl/strbuf.hxx>
++#include <rtl/ustrbuf.hxx>
++#include <osl/diagnose.h>
++#include <osl/mutex.hxx>
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include "com/sun/star/uno/RuntimeException.hpp"
++#include <typelib/typedescription.hxx>
++#include <uno/any2.h>
++
++#include "share.hxx"
++
++
++using namespace ::std;
++using namespace ::osl;
++using namespace ::rtl;
++using namespace ::com::sun::star::uno;
++using namespace ::__cxxabiv1;
++
++extern sal_Int32 * pHack;
++extern sal_Int32 nHack;
++
++namespace CPPU_CURRENT_NAMESPACE
++{
++    void dummy_can_throw_anything( char const * )
++    {
++    }
++
++    //===================================================================
++    static OUString toUNOname( char const * p ) SAL_THROW( () )
++    {
++#if OSL_DEBUG_LEVEL > 1
++        char const * start = p;
++#endif
++
++        // example: N3com3sun4star4lang24IllegalArgumentExceptionE
++
++        OUStringBuffer buf( 64 );
++        OSL_ASSERT( 'N' == *p );
++        ++p; // skip N
++
++        while ('E' != *p)
++        {
++            // read chars count
++            long n = (*p++ - '0');
++            while ('0' <= *p && '9' >= *p)
++            {
++                n *= 10;
++                n += (*p++ - '0');
++            }
++            buf.appendAscii( p, n );
++            p += n;
++            if ('E' != *p)
++                buf.append( (sal_Unicode)'.' );
++        }
++
++#if OSL_DEBUG_LEVEL > 1
++        OUString ret( buf.makeStringAndClear() );
++        OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
++        fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
++        return ret;
++#else
++        return buf.makeStringAndClear();
++#endif
++    }
++
++    //=====================================================================
++    class RTTI
++    {
++        typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
++
++        Mutex m_mutex;
++        t_rtti_map m_rttis;
++        t_rtti_map m_generatedRttis;
++
++        void * m_hApp;
++
++    public:
++        RTTI() SAL_THROW( () );
++        ~RTTI() SAL_THROW( () );
++
++        type_info * getRTTI(typelib_CompoundTypeDescription *) SAL_THROW( () );
++    };
++    //____________________________________________________________________
++    RTTI::RTTI() SAL_THROW( () )
++        : m_hApp( dlopen( 0, RTLD_LAZY ) )
++    {
++    }
++    //____________________________________________________________________
++    RTTI::~RTTI() SAL_THROW( () )
++    {
++        dlclose( m_hApp );
++    }
++
++    //____________________________________________________________________
++    type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
++    {
++        type_info * rtti;
++
++        OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
++
++        MutexGuard guard( m_mutex );
++        t_rtti_map::const_iterator iRttiFind( m_rttis.find( unoName ) );
++        if (iRttiFind == m_rttis.end())
++        {
++            // RTTI symbol
++            OStringBuffer buf( 64 );
++            buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
++            sal_Int32 index = 0;
++            do
++            {
++                OUString token( unoName.getToken( 0, '.', index ) );
++                buf.append( token.getLength() );
++                OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
++                buf.append( c_token );
++            }
++            while (index >= 0);
++            buf.append( 'E' );
++
++            OString symName( buf.makeStringAndClear() );
++            rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
++
++            if (rtti)
++            {
++                pair< t_rtti_map::iterator, bool > insertion(
++                    m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
++                OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
++            }
++            else
++            {
++                // try to lookup the symbol in the generated rtti map
++                t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
++                if (iFind == m_generatedRttis.end())
++                {
++                    // we must generate it !
++                    // symbol and rtti-name is nearly identical,
++                    // the symbol is prefixed with _ZTI
++                    char const * rttiName = symName.getStr() +4;
++#if OSL_DEBUG_LEVEL > 1
++                    fprintf( stderr,"generated rtti for %s\n", rttiName );
++#endif
++                    if (pTypeDescr->pBaseTypeDescription)
++                    {
++                        // ensure availability of base
++                        type_info * base_rtti = getRTTI(
++                            (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
++                        rtti = new __si_class_type_info(
++                            strdup( rttiName ), (__class_type_info *)base_rtti );
++                    }
++                    else
++                    {
++                        // this class has no base class
++                        rtti = new __class_type_info( strdup( rttiName ) );
++                    }
++
++                    pair< t_rtti_map::iterator, bool > insertion(
++                        m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
++                    OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
++                }
++                else // taking already generated rtti
++                {
++                    rtti = iFind->second;
++                }
++            }
++        }
++        else
++        {
++            rtti = iRttiFind->second;
++        }
++
++        return rtti;
++    }
++
++    //------------------------------------------------------------------
++    static void deleteException( void * pExc )
++    {
++        __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
++        typelib_TypeDescription * pTD = 0;
++        OUString unoName( toUNOname( header->exceptionType->name() ) );
++        ::typelib_typedescription_getByName( &pTD, unoName.pData );
++        OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
++        if (pTD)
++        {
++            ::uno_destructData( pExc, pTD, cpp_release );
++            ::typelib_typedescription_release( pTD );
++        }
++    }
++
++    //==================================================================
++    void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
++    {
++#if OSL_DEBUG_LEVEL > 1
++        OString cstr(
++            OUStringToOString(
++                *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
++                RTL_TEXTENCODING_ASCII_US ) );
++        fprintf( stderr, "> uno exception occured: %s\n", cstr.getStr() );
++#endif
++        void * pCppExc;
++        type_info * rtti;
++
++        {
++        // construct cpp exception object
++        typelib_TypeDescription * pTypeDescr = 0;
++        TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
++        OSL_ASSERT( pTypeDescr );
++        if (! pTypeDescr)
++        {
++            throw RuntimeException(
++                OUString( RTL_CONSTASCII_USTRINGPARAM("cannot get typedescription for type ") ) +
++                *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
++                Reference< XInterface >() );
++        }
++
++        pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
++        ::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
++
++        // destruct uno exception
++        ::uno_any_destruct( pUnoExc, 0 );
++        // avoiding locked counts
++        static RTTI * s_rtti = 0;
++        if (! s_rtti)
++        {
++            MutexGuard guard( Mutex::getGlobalMutex() );
++            if (! s_rtti)
++            {
++#ifdef LEAK_STATIC_DATA
++                s_rtti = new RTTI();
++#else
++                static RTTI rtti_data;
++                s_rtti = &rtti_data;
++#endif
++            }
++        }
++        rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
++        TYPELIB_DANGER_RELEASE( pTypeDescr );
++        OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
++        if (! rtti)
++        {
++            throw RuntimeException(
++                OUString( RTL_CONSTASCII_USTRINGPARAM("no rtti for type ") ) +
++                *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
++                Reference< XInterface >() );
++        }
++        }
++
++
++	__cxa_throw( pCppExc, rtti, deleteException );
++    }
++
++    static void* getAdjustedPtr(__cxa_exception* header)
++    {
++        return header->adjustedPtr;
++    }
++
++    //===================================================================
++    void fillUnoException( __cxa_exception * header, uno_Any * pUnoExc, uno_Mapping * pCpp2Uno )
++    {
++        if (! header)
++        {
++            RuntimeException aRE(
++                OUString( RTL_CONSTASCII_USTRINGPARAM("no exception header!") ),
++                Reference< XInterface >() );
++            Type const & rType = ::getCppuType( &aRE );
++            uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
++#if OSL_DEBUG_LEVEL > 0
++            OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
++            OSL_ENSURE( 0, cstr.getStr() );
++#endif
++            return;
++        }
++
++        typelib_TypeDescription * pExcTypeDescr = 0;
++        OUString unoName( toUNOname( header->exceptionType->name() ) );
++#if OSL_DEBUG_LEVEL > 1
++        OString cstr_unoName( OUStringToOString( unoName, RTL_TEXTENCODING_ASCII_US ) );
++        fprintf( stderr, "> c++ exception occured: %s\n", cstr_unoName.getStr() );
++#endif
++        typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
++        if (0 == pExcTypeDescr)
++        {
++            RuntimeException aRE(
++                OUString( RTL_CONSTASCII_USTRINGPARAM("exception type not found: ") ) + unoName,
++                Reference< XInterface >() );
++            Type const & rType = ::getCppuType( &aRE );
++            uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
++#if OSL_DEBUG_LEVEL > 0
++            OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
++            OSL_ENSURE( 0, cstr.getStr() );
++#endif
++        }
++        else
++        {
++            // construct uno exception any
++            uno_any_constructAndConvert( pUnoExc, getAdjustedPtr(header), pExcTypeDescr, pCpp2Uno );
++            typelib_typedescription_release( pExcTypeDescr );
++        }
++    }
++}
++
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_hppa/makefile.mk
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_hppa/makefile.mk	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,86 @@
++#*************************************************************************
++#
++# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++# 
++# Copyright 2008 by Sun Microsystems, Inc.
++#
++# OpenOffice.org - a multi-platform office productivity suite
++#
++# $RCSfile: makefile.mk,v $
++#
++# $Revision: 1.2 $
++#
++# This file is part of OpenOffice.org.
++#
++# OpenOffice.org is free software: you can redistribute it and/or modify
++# it under the terms of the GNU Lesser General Public License version 3
++# only, as published by the Free Software Foundation.
++#
++# OpenOffice.org is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU Lesser General Public License version 3 for more details
++# (a copy is included in the LICENSE file that accompanied this code).
++#
++# You should have received a copy of the GNU Lesser General Public License
++# version 3 along with OpenOffice.org.  If not, see
++# <http://www.openoffice.org/license.html>
++# for a copy of the LGPLv3 License.
++#
++#*************************************************************************
++
++PRJ=..$/..$/..
++
++PRJNAME=bridges
++TARGET=gcc3_uno
++LIBTARGET=no
++ENABLE_EXCEPTIONS=TRUE
++NO_BSYMBOLIC=TRUE
++
++# --- Settings -----------------------------------------------------
++
++.INCLUDE :  settings.mk
++
++# --- Files --------------------------------------------------------
++
++.IF "$(COM)$(OS)$(CPU)" == "GCCLINUXH"
++
++.IF "$(cppu_no_leak)" == ""
++CFLAGS += -DLEAK_STATIC_DATA
++.ENDIF
++
++CFLAGSCXX += -fno-omit-frame-pointer 
++
++NOOPTFILES= \
++	$(SLO)$/cpp2uno.obj \
++	$(SLO)$/except.obj \
++	$(SLO)$/uno2cpp.obj \
++	$(SLO)$/call.obj
++
++CFLAGSNOOPT=-O0
++
++SLOFILES= \
++	$(SLO)$/cpp2uno.obj \
++	$(SLO)$/except.obj \
++	$(SLO)$/uno2cpp.obj \
++	$(SLO)$/call.obj
++
++SHL1TARGET= $(TARGET)
++
++SHL1DEF=$(MISC)$/$(SHL1TARGET).def
++SHL1IMPLIB=i$(TARGET)
++SHL1VERSIONMAP=..$/..$/bridge_exports.map
++SHL1RPATH=URELIB
++
++SHL1OBJS = $(SLOFILES)
++SHL1LIBS = $(SLB)$/cpp_uno_shared.lib
++
++SHL1STDLIBS= \
++	$(CPPULIB)			\
++	$(SALLIB)
++
++.ENDIF
++
++# --- Targets ------------------------------------------------------
++
++.INCLUDE :  target.mk
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_hppa/share.hxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_hppa/share.hxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,102 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2008 by Sun Microsystems, Inc.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * $RCSfile: share.hxx,v $
++ * $Revision: 1.2 $
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++#include "uno/mapping.h"
++
++#include <typeinfo>
++#include <exception>
++#include <cstddef>
++
++namespace CPPU_CURRENT_NAMESPACE
++{
++
++  void dummy_can_throw_anything( char const * );
++
++
++// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
++
++struct _Unwind_Exception
++{
++    unsigned exception_class __attribute__((__mode__(__DI__)));
++    void * exception_cleanup;
++    unsigned private_1 __attribute__((__mode__(__word__)));
++    unsigned private_2 __attribute__((__mode__(__word__)));
++} __attribute__((__aligned__));
++
++struct __cxa_exception
++{ 
++    ::std::type_info *exceptionType;
++    void (*exceptionDestructor)(void *); 
++    
++    ::std::unexpected_handler unexpectedHandler;
++    ::std::terminate_handler terminateHandler;
++    
++    __cxa_exception *nextException;
++    
++    int handlerCount;
++    
++    int handlerSwitchValue;
++    const unsigned char *actionRecord;
++    const unsigned char *languageSpecificData;
++    void *catchTemp;
++    void *adjustedPtr;
++    
++    _Unwind_Exception unwindHeader;
++};    
++
++extern "C" void *__cxa_allocate_exception(
++    std::size_t thrown_size ) throw();
++extern "C" void __cxa_throw (
++    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
++
++struct __cxa_eh_globals
++{
++    __cxa_exception *caughtExceptions;
++    unsigned int uncaughtExceptions;
++};
++extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
++
++// -----
++
++//==================================================================================================
++void raiseException(
++    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
++//==================================================================================================
++void fillUnoException(
++    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
++}
++
++
++namespace hppa 
++{
++    enum hppalimits { MAX_WORDS_IN_REGS = 4, MAX_GPR_REGS = 4, MAX_SSE_REGS = 4 };
++
++    bool isRegisterReturn( typelib_TypeDescriptionReference *pTypeRef );
++}
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_hppa/uno2cpp.cxx
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ bridges/source/cpp_uno/gcc3_linux_hppa/uno2cpp.cxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,524 @@
++/*************************************************************************
++ *
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ * 
++ * Copyright 2008 by Sun Microsystems, Inc.
++ *
++ * OpenOffice.org - a multi-platform office productivity suite
++ *
++ * $RCSfile: uno2cpp.cxx,v $
++ * $Revision: 1.2 $
++ *
++ * This file is part of OpenOffice.org.
++ *
++ * OpenOffice.org is free software: you can redistribute it and/or modify
++ * it under the terms of the GNU Lesser General Public License version 3
++ * only, as published by the Free Software Foundation.
++ *
++ * OpenOffice.org is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU Lesser General Public License version 3 for more details
++ * (a copy is included in the LICENSE file that accompanied this code).
++ *
++ * You should have received a copy of the GNU Lesser General Public License
++ * version 3 along with OpenOffice.org.  If not, see
++ * <http://www.openoffice.org/license.html>
++ * for a copy of the LGPLv3 License.
++ *
++ ************************************************************************/
++
++#include <malloc.h>
++#include <rtl/alloc.h>
++
++#include <com/sun/star/uno/genfunc.hxx>
++#include "com/sun/star/uno/RuntimeException.hpp"
++#include <uno/data.h>
++
++#include <bridges/cpp_uno/shared/bridge.hxx>
++#include <bridges/cpp_uno/shared/types.hxx>
++#include <bridges/cpp_uno/shared/unointerfaceproxy.hxx>
++#include <bridges/cpp_uno/shared/vtables.hxx>
++
++#include "share.hxx"
++
++#include <stdio.h>
++#include <string.h>
++
++using namespace ::rtl;
++using namespace ::com::sun::star::uno;
++
++void callVirtualMethod(void * pThis, sal_uInt32 nVtableIndex, 
++    void * pRegisterReturn, typelib_TypeDescription *pReturnTypeDescr, bool bRegisterReturn,
++    sal_uInt32 *pStack, sal_uInt32 nStack, sal_uInt32 *pGPR, double *pFPR);
++
++#define INSERT_INT32( pSV, nr, pGPR, pDS, bOverFlow )\
++        if (nr < hppa::MAX_WORDS_IN_REGS) \
++        { \
++            pGPR[nr++] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
++        } \
++        else \
++            bOverFlow = true; \
++        if (bOverFlow) \
++            *pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV );
++
++#define INSERT_INT64( pSV, nr, pGPR, pDS, pStart, bOverFlow )\
++    if ( (nr < hppa::MAX_WORDS_IN_REGS) && (nr % 2) ) \
++    { \
++        ++nr; \
++    } \
++    if ( nr < hppa::MAX_WORDS_IN_REGS ) \
++    { \
++        pGPR[nr++] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
++        pGPR[nr++] = *(reinterpret_cast<sal_uInt32 *>( pSV ) + 1); \
++    } \
++    else \
++        bOverFlow = true; \
++    if ( bOverFlow ) \
++    { \
++        if ( (pDS - pStart) % 2) \
++            ++pDS; \
++        *pDS++ = reinterpret_cast<sal_uInt32 *>( pSV )[1]; \
++        *pDS++ = reinterpret_cast<sal_uInt32 *>( pSV )[0]; \
++    }
++
++#define INSERT_FLOAT( pSV, nr, pFPR, pDS, bOverFlow ) \
++    if (nr < hppa::MAX_WORDS_IN_REGS) \
++    { \
++        sal_uInt32 *pDouble = (sal_uInt32 *)&(pFPR[nr++]); \
++        pDouble[0] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
++    } \
++    else \
++        bOverFlow = true; \
++    if (bOverFlow) \
++        *pDS++ = *reinterpret_cast<sal_uInt32 *>( pSV );
++
++#define INSERT_DOUBLE( pSV, nr, pFPR, pDS, pStart, bOverFlow ) \
++    if ( (nr < hppa::MAX_WORDS_IN_REGS) && (nr % 2) ) \
++    { \
++        ++nr; \
++    } \
++    if ( nr < hppa::MAX_WORDS_IN_REGS ) \
++    { \
++        sal_uInt32 *pDouble = (sal_uInt32 *)&(pFPR[nr+1]); \
++        pDouble[0] = *reinterpret_cast<sal_uInt32 *>( pSV ); \
++        pDouble[1] = *(reinterpret_cast<sal_uInt32 *>( pSV ) + 1); \
++        nr+=2; \
++    } \
++    else \
++        bOverFlow = true; \
++    if ( bOverFlow ) \
++    { \
++        if ( (pDS - pStart) % 2) \
++            ++pDS; \
++        *pDS++ = reinterpret_cast<sal_uInt32 *>( pSV )[1]; \
++        *pDS++ = reinterpret_cast<sal_uInt32 *>( pSV )[0]; \
++    }
++
++#define INSERT_INT16( pSV, nr, pGPR, pDS, bOverFlow ) \
++    if ( nr < hppa::MAX_WORDS_IN_REGS ) \
++        pGPR[nr++] = *reinterpret_cast<sal_uInt16 *>( pSV ); \
++    else \
++        bOverFlow = true; \
++    if (bOverFlow) \
++        *pDS++ = *reinterpret_cast<sal_uInt16 *>( pSV );
++
++#define INSERT_INT8(  pSV, nr, pGPR, pDS, bOverFlow ) \
++    if ( nr < hppa::MAX_WORDS_IN_REGS ) \
++        pGPR[nr++] = *reinterpret_cast<sal_uInt8 *>( pSV ); \
++    else \
++        bOverFlow = true; \
++    if (bOverFlow) \
++        *pDS++ = *reinterpret_cast<sal_uInt8 *>( pSV );
++
++namespace hppa
++{
++    bool is_complex_struct(const typelib_TypeDescription * type)
++    {
++        const typelib_CompoundTypeDescription * p
++            = reinterpret_cast< const typelib_CompoundTypeDescription * >(type);
++        for (sal_Int32 i = 0; i < p->nMembers; ++i)
++        {
++            if (p->ppTypeRefs[i]->eTypeClass == typelib_TypeClass_STRUCT ||
++                p->ppTypeRefs[i]->eTypeClass == typelib_TypeClass_EXCEPTION)
++            { 
++                typelib_TypeDescription * t = 0;
++                TYPELIB_DANGER_GET(&t, p->ppTypeRefs[i]);
++                bool b = is_complex_struct(t);
++                TYPELIB_DANGER_RELEASE(t);
++                if (b) {
++                    return true;
++                }
++            }
++            else if (!bridges::cpp_uno::shared::isSimpleType(p->ppTypeRefs[i]->eTypeClass))
++                return true;
++        }
++        if (p->pBaseTypeDescription != 0)
++            return is_complex_struct(&p->pBaseTypeDescription->aBase);
++        return false;
++    }
++
++    bool isRegisterReturn( typelib_TypeDescriptionReference *pTypeRef )
++    {
++        if (bridges::cpp_uno::shared::isSimpleType(pTypeRef))
++            return true;
++        else if (pTypeRef->eTypeClass == typelib_TypeClass_STRUCT || pTypeRef->eTypeClass == typelib_TypeClass_EXCEPTION)
++        {
++            typelib_TypeDescription * pTypeDescr = 0;
++            TYPELIB_DANGER_GET( &pTypeDescr, pTypeRef );
++
++            /* If the struct is larger than 8 bytes, then there is a buffer at r8 to stick the return value into  */
++            bool bRet = pTypeDescr->nSize <= 8 && !is_complex_struct(pTypeDescr);
++
++            TYPELIB_DANGER_RELEASE( pTypeDescr );
++            return bRet;
++        }
++        return false;
++    }
++}
++
++
++namespace {
++//======================================================================= 
++static void cpp_call(
++    bridges::cpp_uno::shared::UnoInterfaceProxy * pThis,
++    bridges::cpp_uno::shared::VtableSlot aVtableSlot,
++    typelib_TypeDescriptionReference * pReturnTypeRef,
++    sal_Int32 nParams, typelib_MethodParameter * pParams,
++    void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
++{
++    // max space for: [complex ret ptr], values|ptr ...
++    sal_uInt32 * pStack = (sal_uInt32 *)__builtin_alloca(
++        sizeof(sal_Int32) + ((nParams+2) * sizeof(sal_Int64)) );
++    sal_uInt32 * pStackStart = pStack;
++
++    sal_uInt32 pGPR[hppa::MAX_GPR_REGS];
++    double pFPR[hppa::MAX_SSE_REGS];
++    sal_uInt32 nRegs=0;
++
++    // return
++    typelib_TypeDescription * pReturnTypeDescr = 0;
++    TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
++    OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
++    
++    void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
++    bool bOverFlow = false;
++    bool bRegisterReturn = true;
++
++    if (pReturnTypeDescr)
++    {
++
++        bRegisterReturn = hppa::isRegisterReturn(pReturnTypeRef);
++        if (bRegisterReturn)
++            pCppReturn = pUnoReturn; // direct way for simple types
++        else
++        {
++            // complex return via ptr
++            pCppReturn = (bridges::cpp_uno::shared::relatesToInterfaceType( pReturnTypeDescr )
++                    ? __builtin_alloca( pReturnTypeDescr->nSize )
++                    : pUnoReturn); // direct way
++        }
++    }
++    // push this
++    void * pAdjustedThisPtr = reinterpret_cast< void ** >(pThis->getCppI())
++        + aVtableSlot.offset;
++    INSERT_INT32( &pAdjustedThisPtr, nRegs, pGPR, pStack, bOverFlow );
++
++    // stack space
++    OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
++    // args
++    void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
++    // indizes of values this have to be converted (interface conversion cpp<=>uno)
++    sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
++    // type descriptions for reconversions
++    typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
++
++    sal_Int32 nTempIndizes   = 0;
++
++    for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
++    {
++        const typelib_MethodParameter & rParam = pParams[nPos];
++        typelib_TypeDescription * pParamTypeDescr = 0;
++        TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
++
++        if (!rParam.bOut && bridges::cpp_uno::shared::isSimpleType( pParamTypeDescr ))
++        {
++            uno_copyAndConvertData( pCppArgs[nPos] = alloca(8), pUnoArgs[nPos],
++                pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
++            
++            switch (pParamTypeDescr->eTypeClass)
++            {
++                case typelib_TypeClass_HYPER:
++                case typelib_TypeClass_UNSIGNED_HYPER:
++#ifdef CMC_DEBUG
++                    fprintf(stderr, "hyper is %llx\n", *((long long*)pCppArgs[nPos]));
++#endif
++                    INSERT_INT64( pCppArgs[nPos], nRegs, pGPR, pStack, pStackStart, bOverFlow );
++                break;
++                case typelib_TypeClass_LONG:
++                case typelib_TypeClass_UNSIGNED_LONG:
++                case typelib_TypeClass_ENUM:
++#ifdef CMC_DEBUG
++                    fprintf(stderr, "long is %x\n", pCppArgs[nPos]);
++#endif
++                    INSERT_INT32( pCppArgs[nPos], nRegs, pGPR, pStack, bOverFlow );
++                break;
++                case typelib_TypeClass_SHORT:
++                case typelib_TypeClass_CHAR:
++                case typelib_TypeClass_UNSIGNED_SHORT:
++                    INSERT_INT16( pCppArgs[nPos], nRegs, pGPR, pStack, bOverFlow );
++                break;
++                case typelib_TypeClass_BOOLEAN:
++                case typelib_TypeClass_BYTE:
++                    INSERT_INT8( pCppArgs[nPos], nRegs, pGPR, pStack, bOverFlow );
++                break;
++                case typelib_TypeClass_FLOAT:
++                    INSERT_FLOAT( pCppArgs[nPos], nRegs, pFPR, pStack, bOverFlow );
++                break;
++                case typelib_TypeClass_DOUBLE:
++                    INSERT_DOUBLE( pCppArgs[nPos], nRegs, pFPR, pStack, pStackStart, bOverFlow );
++                break;
++                default:
++                break;
++            }
++            // no longer needed
++            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++        }
++        else // ptr to complex value | ref
++        {
++            if (! rParam.bIn) // is pure out
++            {
++                // cpp out is constructed mem, uno out is not!
++                uno_constructData(
++                    pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
++                    pParamTypeDescr );
++                pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
++                // will be released at reconversion
++                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++            }
++            // is in/inout
++            else if (bridges::cpp_uno::shared::relatesToInterfaceType( pParamTypeDescr ))
++            {
++                uno_copyAndConvertData(
++                    pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
++                    pUnoArgs[nPos], pParamTypeDescr, pThis->getBridge()->getUno2Cpp() );
++                
++                pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
++                // will be released at reconversion
++                ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
++            }
++            else // direct way
++            {
++                pCppArgs[nPos] = pUnoArgs[nPos];
++                // no longer needed
++                TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++            }
++            INSERT_INT32( &(pCppArgs[nPos]), nRegs, pGPR, pStack, bOverFlow );
++        }
++    }
++
++    try
++    {
++        callVirtualMethod(
++            pAdjustedThisPtr, aVtableSlot.index,
++            pCppReturn, pReturnTypeDescr, bRegisterReturn,
++            pStackStart, 
++            (pStack - pStackStart), pGPR, pFPR);
++
++        // NO exception occured...
++        *ppUnoExc = 0;
++
++        // reconvert temporary params
++        for ( ; nTempIndizes--; )
++        {
++            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++            typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
++            
++            if (pParams[nIndex].bIn)
++            {
++                if (pParams[nIndex].bOut) // inout
++                {
++                    uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
++                    uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
++                                            pThis->getBridge()->getCpp2Uno() );
++                }
++            }
++            else // pure out
++            {
++                uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
++                                        pThis->getBridge()->getCpp2Uno() );
++            }
++            // destroy temp cpp param => cpp: every param was constructed
++            uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
++            
++            TYPELIB_DANGER_RELEASE( pParamTypeDescr );
++        }
++        // return value
++        if (pCppReturn && pUnoReturn != pCppReturn)
++        {
++            uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
++                                    pThis->getBridge()->getCpp2Uno() );
++            uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
++        }
++    }
++    catch (...)
++    {
++        // fill uno exception
++        fillUnoException( CPPU_CURRENT_NAMESPACE::__cxa_get_globals()->caughtExceptions, *ppUnoExc, pThis->getBridge()->getCpp2Uno() );
++
++        // temporary params
++        for ( ; nTempIndizes--; )
++        {
++            sal_Int32 nIndex = pTempIndizes[nTempIndizes];
++            // destroy temp cpp param => cpp: every param was constructed
++            uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
++            TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
++        }
++        
++        // return type
++        if (pReturnTypeDescr)
++            TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
++    }
++}
++}
++
++namespace bridges { namespace cpp_uno { namespace shared {
++
++void unoInterfaceProxyDispatch(
++    uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
++    void * pReturn, void * pArgs[], uno_Any ** ppException )
++{
++    // is my surrogate
++    bridges::cpp_uno::shared::UnoInterfaceProxy * pThis
++          = static_cast< bridges::cpp_uno::shared::UnoInterfaceProxy * >(pUnoI);
++#if OSL_DEBUG_LEVEL > 0
++    typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
++#endif
++
++    switch (pMemberDescr->eTypeClass)
++    {
++        case typelib_TypeClass_INTERFACE_ATTRIBUTE:
++        {
++#if OSL_DEBUG_LEVEL > 0
++            // determine vtable call index
++            sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
++            OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
++#endif
++        
++            VtableSlot aVtableSlot(
++                getVtableSlot(
++                reinterpret_cast<typelib_InterfaceAttributeTypeDescription const *>
++                   (pMemberDescr)));
++        
++            if (pReturn)
++            {
++                // dependent dispatch
++                cpp_call(
++                    pThis, aVtableSlot,
++                    ((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
++                    0, 0, // no params
++                    pReturn, pArgs, ppException );
++            }
++            else
++            {
++                // is SET
++                typelib_MethodParameter aParam;
++                aParam.pTypeRef =
++                    ((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
++                aParam.bIn      = sal_True;
++                aParam.bOut     = sal_False;
++
++                typelib_TypeDescriptionReference * pReturnTypeRef = 0;
++                OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
++                typelib_typedescriptionreference_new(
++                    &pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
++            
++                // dependent dispatch
++                aVtableSlot.index += 1;
++                cpp_call(
++                    pThis, aVtableSlot, // get, then set method
++                    pReturnTypeRef,
++                    1, &aParam,
++                    pReturn, pArgs, ppException );
++            
++                typelib_typedescriptionreference_release( pReturnTypeRef );
++            }
++        
++            break;
++        }
++        case typelib_TypeClass_INTERFACE_METHOD:
++        {
++#if OSL_DEBUG_LEVEL > 0
++            // determine vtable call index
++            sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
++            OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
++#endif
++
++            VtableSlot aVtableSlot(
++                getVtableSlot(
++                reinterpret_cast<typelib_InterfaceMethodTypeDescription const *>
++                  (pMemberDescr)));
++
++            switch (aVtableSlot.index)
++            {
++                // standard calls
++                case 1: // acquire uno interface
++                    (*pUnoI->acquire)( pUnoI );
++                    *ppException = 0;
++                break;
++                case 2: // release uno interface
++                    (*pUnoI->release)( pUnoI );
++                    *ppException = 0;
++                    break;
++                case 0: // queryInterface() opt
++                {
++                    typelib_TypeDescription * pTD = 0;
++                    TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
++                    if (pTD)
++                    {
++                        uno_Interface * pInterface = 0;
++                        (*pThis->getBridge()->getUnoEnv()->getRegisteredInterface)(
++                            pThis->getBridge()->getUnoEnv(),
++                            (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
++            
++                        if (pInterface)
++                        {
++                            ::uno_any_construct(
++                                reinterpret_cast< uno_Any * >( pReturn ),
++                                &pInterface, pTD, 0 );
++                                (*pInterface->release)( pInterface );
++                                TYPELIB_DANGER_RELEASE( pTD );
++                                *ppException = 0;
++                           break;
++                        }
++
++                        TYPELIB_DANGER_RELEASE( pTD );
++                    }
++                } // else perform queryInterface()
++                default:
++                    // dependent dispatch
++                    cpp_call(
++                        pThis, aVtableSlot,
++                        ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
++                        ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
++                        ((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
++                        pReturn, pArgs, ppException );
++            }
++            break;
++        }
++        default:
++        {
++            ::com::sun::star::uno::RuntimeException aExc(
++                OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
++                ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
++        
++            Type const & rExcType = ::getCppuType( &aExc );
++            // binary identical null reference
++            ::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
++        }
++    }
++}
++
++} } }
++
++/* vi:set tabstop=4 shiftwidth=4 expandtab: */
+diff -r 0d8650731e2f -r 9e94a83ee85c bridges/source/cpp_uno/gcc3_linux_m68k/cpp2uno.cxx
+--- bridges/source/cpp_uno/gcc3_linux_m68k/cpp2uno.cxx	Mon Nov 16 21:50:44 2009 +0100
++++ bridges/source/cpp_uno/gcc3_linux_m68k/cpp2uno.cxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -256,7 +256,7 @@
+                     // destroy temp uno return
+                     uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+                 }
+-                // complex return ptr is set to eax
++                // complex return ptr is set to return reg 
+                 *(void **)pRegisterReturn = pCppReturn;
+             }
+             if (pReturnTypeDescr)
+diff -r 0d8650731e2f -r 9e94a83ee85c configure.in
+--- configure.in	Mon Nov 16 21:50:44 2009 +0100
++++ configure.in	Thu Nov 19 15:41:16 2009 +0000
+@@ -130,7 +130,7 @@
+ ],,)
+ AC_ARG_WITH(system-stdlibs,
+ [  --with-system-stdlibs   use libstdc++/libgcc_s already on system
+-],,checkforprelink=yes)
++],,checkforstdlibproblems=yes)
+ AC_ARG_WITH(system-mspack,
+ [  --with-system-mspack    use libmspack already installed on system
+ ],,)
+@@ -2709,7 +2709,7 @@
+       if ! $CXX $CXXFLAGS $CPPFLAGS -fpic -S visibility.cxx 2>/dev/null > /dev/null; then
+          gccvisbroken=yes
+       else
+-         if $EGREP -q '@PLT|\$stub' visibility.s; then
++         if $EGREP -q '@PLT|\$stub|\(PLT\)' visibility.s; then
+              gccvisbroken=no;
+          else 
+              gccvisbroken=yes; 
+@@ -2889,8 +2889,8 @@
+         _jdk=`$JAVAINTERPRETER -version 2>&1 | $AWK -F'"' '{ print \$2 }' | $SED s/[[-A-Za-z]]*//`
+         _jdk_ver=`echo "$_jdk" | $AWK -F. '{ print (($1 * 100) + $2) * 100 + $3;}'`
+    
+-        if test "$_jdk_ver" -lt 10600; then
+-             AC_MSG_ERROR([IBM JDK is too old, you need at least 1.6])
++        if test "$_jdk_ver" -lt 10500; then
++             AC_MSG_ERROR([IBM JDK is too old, you need at least 1.5])
+         fi
+ 
+         AC_MSG_RESULT([checked (IBM JDK $_jdk)])
+@@ -3581,10 +3581,16 @@
+ dnl Check for prelinked libgcc_s.so.1
+ dnl ===================================================================
+ if test -z "$with_system_stdlibs" -a -z "$with_system_libs"; then
+-  if test -n "$checkforprelink" -a -f /etc/rpm/macros.prelink; then
+-    with_system_stdlibs=yes
+-    AC_MSG_WARN([prelinked libgcc_s.so.1, enabling --with-system-stdlibs, use --without-system-stdlibs to override])
+-    echo "prelinked libgcc_s.so.1, enabling --with-system-stdlibs, use --without-system-stdlibs to override" >> warn
++  if test -n "$checkforstdlibproblems"; then
++    if test -f /etc/rpm/macros.prelink; then
++      with_system_stdlibs=yes
++      AC_MSG_WARN([prelinked libgcc_s.so.1, enabling --with-system-stdlibs, use --without-system-stdlibs to override])
++      echo "prelinked libgcc_s.so.1, enabling --with-system-stdlibs, use --without-system-stdlibs to override" >> warn
++    elif test "$GCC" = "yes" -a ! -e `$CC -print-file-name=libgcc_s.so.1`; then
++      with_system_stdlibs=yes
++      AC_MSG_WARN([platform doesn't have a libgcc_s.so.1, enabling --with-system-stdlibs, use --without-system-stdlibs to override])
++      echo "platform doesn't have a libgcc_s.so.1, enabling --with-system-stdlibs, use --without-system-stdlibs to override" >> warn
++    fi
+   fi
+ fi
+ 
+diff -r 0d8650731e2f -r 9e94a83ee85c jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx
+--- jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	Mon Nov 16 21:50:44 2009 +0100
++++ jvmfwk/plugins/sunmajor/pluginlib/vendorbase.hxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -70,9 +70,11 @@
+ #define JFW_PLUGIN_ARCH "ia64"
+ #elif defined M68K
+ #define JFW_PLUGIN_ARCH "m68k"
+-#else // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K
++#elif defined HPPA
++#define JFW_PLUGIN_ARCH "parisc"
++#else // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA
+ #error unknown plattform
+-#endif // SPARC, INTEL, POWERPC, MIPS, ARM
++#endif // SPARC, INTEL, POWERPC, MIPS, ARM, IA64, M68K, HPPA
+ 
+ 
+ class MalformedVersionException
+diff -r 0d8650731e2f -r 9e94a83ee85c sal/rtl/source/macro.hxx
+--- sal/rtl/source/macro.hxx	Mon Nov 16 21:50:44 2009 +0100
++++ sal/rtl/source/macro.hxx	Thu Nov 19 15:41:16 2009 +0000
+@@ -94,6 +94,8 @@
+ #    define THIS_ARCH "IA64"
+ #elif defined M68K
+ #    define THIS_ARCH "M68K"
++#elif defined HPPA
++#    define THIS_ARCH "HPPA"
+ #endif
+ 
+ #if ! defined THIS_ARCH
+diff -r 0d8650731e2f -r 9e94a83ee85c sal/typesconfig/typesconfig.c
+--- sal/typesconfig/typesconfig.c	Mon Nov 16 21:50:44 2009 +0100
++++ sal/typesconfig/typesconfig.c	Thu Nov 19 15:41:16 2009 +0000
+@@ -163,7 +163,7 @@
+ |*	Letzte Aenderung
+ |*
+ *************************************************************************/
+-#if defined(IA64) || defined(ARM32)
++#if defined(IA64) || defined(ARM32) || defined(HPPA)
+ 
+ int forceerror()
+ {
+diff -r 0d8650731e2f -r 9e94a83ee85c set_soenv.in
+--- set_soenv.in	Mon Nov 16 21:50:44 2009 +0100
++++ set_soenv.in	Thu Nov 19 15:41:16 2009 +0000
+@@ -495,6 +495,17 @@
+       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."m68k".$ds."server";
+       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."m68k".$ds."native_threads";
+    }
++   elsif ($platform =~ m/^hppa/)
++   {  print "Setting Linux hppa specific values... ";
++      $outfile        = "LinuxHPPAEnv.Set";
++      $CPU            = "H";
++      $CPUNAME        = "HPPA";
++      $OUTPATH        = "unxlnghppa";
++      $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."hppa";
++      $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."hppa".$ds."server";
++      $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."hppa".$ds."native_threads";
++      $EPM_FLAGS      = "-a hppa";
++   }
+    elsif ($platform =~ m/^alpha/) 
+    {  print "Setting Linux Alpha specific values... ";
+       $outfile        = "LinuxAlphaEnv.Set"; 
+diff -r 0d8650731e2f -r 9e94a83ee85c solenv/inc/unx.mk
+--- solenv/inc/unx.mk	Mon Nov 16 21:50:44 2009 +0100
++++ solenv/inc/unx.mk	Thu Nov 19 15:41:16 2009 +0000
+@@ -179,6 +179,10 @@
+ .INCLUDE : unxlngm68k.mk
+ .ENDIF
+ 
++.IF "$(COM)$(OS)$(CPU)" == "GCCLINUXH"
++.INCLUDE : unxlnghppa.mk
++.ENDIF
++
+ # --- general *ix settings ---
+ HC=hc
+ HCFLAGS=
+diff -r 0d8650731e2f -r 9e94a83ee85c solenv/inc/unxlnghppa.mk
+--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
++++ solenv/inc/unxlnghppa.mk	Thu Nov 19 15:41:16 2009 +0000
+@@ -0,0 +1,39 @@
++#*************************************************************************
++#
++# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++# 
++# Copyright 2008 by Sun Microsystems, Inc.
++#
++# OpenOffice.org - a multi-platform office productivity suite
++#
++# $RCSfile: unxlnghppa.mk,v $
++#
++# $Revision: 1.2 $
++#
++# This file is part of OpenOffice.org.
++#
++# OpenOffice.org is free software: you can redistribute it and/or modify
++# it under the terms of the GNU Lesser General Public License version 3
++# only, as published by the Free Software Foundation.
++#
++# OpenOffice.org is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU Lesser General Public License version 3 for more details
++# (a copy is included in the LICENSE file that accompanied this code).
++#
++# You should have received a copy of the GNU Lesser General Public License
++# version 3 along with OpenOffice.org.  If not, see
++# <http://www.openoffice.org/license.html>
++# for a copy of the LGPLv3 License.
++#
++#*************************************************************************
++
++# mk file for Unix Linux HPPA using GCC, please make generic modifications to unxlng.mk
++PICSWITCH:=-fPIC
++.INCLUDE : unxlng.mk
++CDEFS+=-DHPPA
++CFLAGS+=
++CFLAGSCC+=
++CFLAGSCXX+=
++DLLPOSTFIX=lh
+diff -r 0d8650731e2f -r 9e94a83ee85c tools/inc/tools/solar.h
+--- tools/inc/tools/solar.h	Mon Nov 16 21:50:44 2009 +0100
++++ tools/inc/tools/solar.h	Thu Nov 19 15:41:16 2009 +0000
+@@ -385,6 +385,8 @@
+   #define __DLLEXTENSION "la.so"
+ #elif defined LINUX && defined M68K
+   #define __DLLEXTENSION "lm.so"
++#elif defined LINUX && defined HPPA
++  #define __DLLEXTENSION "lh.so"
+ #elif defined LINUX
+   #error unknown plattform
+ #elif defined FREEBSD && defined X86
diff -Nur ooo-build-3.1.1.4/patches/dev300/field-patch.diff ooo-build-3.1.1.5/patches/dev300/field-patch.diff
--- ooo-build-3.1.1.4/patches/dev300/field-patch.diff	2009-08-05 15:20:53.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/field-patch.diff	2009-10-23 15:16:33.000000000 +0300
@@ -1290,7 +1290,7 @@
              {
                  continue;
 diff --git sw/source/filter/ww8/wrtw8nds.cxx sw/source/filter/ww8/wrtw8nds.cxx
-index ab8ff01..a8f5157 100644
+index 611f913..7726efb 100644
 --- sw/source/filter/ww8/wrtw8nds.cxx
 +++ sw/source/filter/ww8/wrtw8nds.cxx
 @@ -112,6 +112,45 @@ using namespace sw::util;
@@ -1339,14 +1339,36 @@
  /*  */
  
  WW8_AttrIter::WW8_AttrIter(SwWW8Writer& rWr)
-@@ -288,19 +327,17 @@ xub_StrLen WW8_SwAttrIter::SearchNext( xub_StrLen nStartPos )
+@@ -284,22 +323,40 @@ WW8_SwAttrIter::WW8_SwAttrIter(SwWW8Writer& rWr, const SwTxtNode& rTxtNd) :
+     nAktSwPos = SearchNext(1);
+ }
+ 
++xub_StrLen lcl_getMinPos( xub_StrLen pos1, xub_StrLen pos2 )
++{
++    xub_StrLen min = STRING_NOTFOUND;
++    if ( pos1 == STRING_NOTFOUND && pos2 != STRING_NOTFOUND )
++        min = pos2;
++    else if ( pos2 == STRING_NOTFOUND && pos1 != STRING_NOTFOUND )
++        min = pos1;
++    else if ( pos2 != STRING_NOTFOUND && pos2 != STRING_NOTFOUND )
++    {
++        if ( pos1 < pos2 )
++            min = pos1;
++        else
++            min = pos2;
++    }
++
++    return min;
++}
++
+ xub_StrLen WW8_SwAttrIter::SearchNext( xub_StrLen nStartPos )
  {
      xub_StrLen nPos;
      xub_StrLen nMinPos = STRING_MAXLEN;
 +    xub_StrLen i=0;
 +
- 	const String aTxt = rNd.GetTxt();
- 	xub_StrLen pos = aTxt.Search(CH_TXT_ATR_FIELDSTART, nStartPos);
+     const String aTxt = rNd.GetTxt();
+-    xub_StrLen pos = aTxt.Search(CH_TXT_ATR_FIELDSTART, nStartPos);
 -	if( pos==STRING_NOTFOUND )
 -    {
 -		pos = aTxt.Search(CH_TXT_ATR_FIELDEND, nStartPos);
@@ -1354,22 +1376,24 @@
 -            pos = aTxt.Search(CH_TXT_ATR_FORMELEMENT, nStartPos);
 -    }
 -	if( pos!=STRING_NOTFOUND )
-+	if (pos==STRING_NOTFOUND) 
-+		pos=aTxt.Search(CH_TXT_ATR_FIELDEND, nStartPos);
-+	if (pos==STRING_NOTFOUND) 
-+		pos=aTxt.Search(CH_TXT_ATR_FORMELEMENT, nStartPos);
-+	if (pos!=STRING_NOTFOUND)  
- 		nMinPos=pos;
+-        nMinPos=pos;
++    xub_StrLen fieldEndPos = aTxt.Search(CH_TXT_ATR_FIELDEND, nStartPos);
++    xub_StrLen fieldStartPos = aTxt.Search(CH_TXT_ATR_FIELDSTART, nStartPos);
++    xub_StrLen formElementPos = aTxt.Search(CH_TXT_ATR_FORMELEMENT, nStartPos);
  
 -    xub_StrLen i=0;
--
++    xub_StrLen pos = lcl_getMinPos( fieldEndPos, fieldStartPos );
++    pos = lcl_getMinPos( pos, formElementPos );
++
++	if (pos!=STRING_NOTFOUND)  
++        nMinPos=pos;
+ 
      // first the redline, then the attributes
      if( pCurRedline )
-     {
-@@ -1558,36 +1595,49 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, SwCntntNode& rNode )
- 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
+@@ -1558,36 +1615,49 @@ Writer& OutWW8_SwTxtNode( Writer& rWrt, SwCntntNode& rNode )
+                 ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
  
- 				if (pFieldmark!=NULL) {
+                 if (pFieldmark!=NULL) {
 -					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 1);
 +				  if (pFieldmark->isType(ECMA_FORMTEXT)) {
 +				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
@@ -1381,31 +1405,31 @@
 +				  if (pFieldmark->isType(ECMA_HYPERLINK)) {
 +					rWW8Wrt.WriteHyperlinkData( *pFieldmark );
 +				  }
-+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CMD_END);
- 				}
++    			  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CMD_END);
+                 }
 -				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String::CreateFromAscii(" FORMTEXT "), WRITEFIELD_START | WRITEFIELD_CMD_START);
 -				if (pFieldmark!=NULL) {
 -					rWW8Wrt.WriteFormData( *pFieldmark );
 -				}
 -				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String(), WRITEFIELD_CMD_END);
- 			} else if (ch==CH_TXT_ATR_FIELDEND) {
- 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
- 				SwFieldBookmark* pFieldmark=(SwFieldBookmark*)rWW8Wrt.pDoc->getFieldBookmarkFor( aPosition );
- 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
+             } else if (ch==CH_TXT_ATR_FIELDEND) {
+                 SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
+                 SwFieldBookmark* pFieldmark=(SwFieldBookmark*)rWW8Wrt.pDoc->getFieldBookmarkFor( aPosition );
+                 ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
 -				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String(), WRITEFIELD_CLOSE);
- 				if (pFieldmark!=NULL) {
+                 if (pFieldmark!=NULL) {
 -					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
 +				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CLOSE);
 +				  if (pFieldmark->isType(ECMA_FORMTEXT)) {
 +				    
 +				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
 +				  }
- 				}
- 			} else if (ch==CH_TXT_ATR_FORMELEMENT) {
- 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
- 				SwFieldBookmark* pFieldmark=rWW8Wrt.pDoc->getFormFieldBookmarkFor( aPosition );
- 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
- 				if (pFieldmark!=NULL) {
+                 }
+             } else if (ch==CH_TXT_ATR_FORMELEMENT) {
+                 SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
+                 SwFieldBookmark* pFieldmark=rWW8Wrt.pDoc->getFormFieldBookmarkFor( aPosition );
+                 ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
+                 if (pFieldmark!=NULL) {
 -					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 1);
 -				}
 -				rWW8Wrt.OutField(NULL, ww::eFORMCHECKBOX, String::CreateFromAscii(" FORMCHECKBOX "), WRITEFIELD_START | WRITEFIELD_CMD_START);
@@ -1427,13 +1451,13 @@
 +				    rWW8Wrt.WriteFormData( *pFieldmark );
 +
 +				  }
-+				  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CMD_END | WRITEFIELD_CLOSE);
++    			  rWW8Wrt.OutField(NULL, lcl_getFieldId(pFieldmark), String(), WRITEFIELD_CLOSE );
 +				  if (pFieldmark->isType(ECMA_FORMDROPDOWN) || pFieldmark->isType(ECMA_FORMCHECKBOX)) {				    
 +				    rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
 +				  }
- 				}
- 			}
- 			nLen-=static_cast<USHORT>(ofs);
+                 }
+             }
+             nLen-=static_cast<USHORT>(ofs);
 diff --git sw/source/filter/ww8/wrtww8.cxx sw/source/filter/ww8/wrtww8.cxx
 index ca1d344..0d99564 100644
 --- sw/source/filter/ww8/wrtww8.cxx
diff -Nur ooo-build-3.1.1.4/patches/dev300/icc-use-sal-endianness-and-types.diff ooo-build-3.1.1.5/patches/dev300/icc-use-sal-endianness-and-types.diff
--- ooo-build-3.1.1.4/patches/dev300/icc-use-sal-endianness-and-types.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/icc-use-sal-endianness-and-types.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,267 @@
+diff -r 2691de086167 icc/README
+--- icc/README	Thu Nov 05 15:23:36 2009 +0000
++++ icc/README	Thu Nov 05 18:03:59 2009 +0000
+@@ -31,11 +31,9 @@
+ 
+ <build>/misc/build/SampleICC-1.3.2/IccProfLib/IccProfLibConf.h
+ 
+-The patches:
+-SampleICC-1.3.2.patch is the file to be used for Linux and Windows
+-SampleICC-1.3.2-bendian.patch is the file to be used for
+-big endian platform, formed from the above patch plus the big endian
+-forcing.
++The patchs:
++SampleICC-1.3.2.patch tweaks the build to use the endianness
++detected in sal.
+ 
+ beppec56@openoffice.org
+ 
+diff -r 2691de086167 icc/SampleICC-1.3.2.patch
+--- icc/SampleICC-1.3.2.patch	Thu Nov 05 15:23:36 2009 +0000
++++ icc/SampleICC-1.3.2.patch	Thu Nov 05 18:03:59 2009 +0000
+@@ -1,5 +1,5 @@
+ *** misc/SampleICC-1.3.2/configure	Mon Aug 20 22:10:59 2007
+---- misc/build/SampleICC-1.3.2/configure	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/configure	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 19991,19997 ****
+   
+@@ -60,7 +60,7 @@
+     *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+   echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+ *** misc/SampleICC-1.3.2/Contrib/Makefile.in	Mon Aug 20 22:10:37 2007
+---- misc/build/SampleICC-1.3.2/Contrib/Makefile.in	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/Contrib/Makefile.in	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 103,120 ****
+   
+@@ -95,7 +95,7 @@
+   subdir = Contrib
+   mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+ *** misc/SampleICC-1.3.2/Contrib/CmdLine/Makefile.in	Mon Aug 20 22:10:34 2007
+---- misc/build/SampleICC-1.3.2/Contrib/CmdLine/Makefile.in	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/Contrib/CmdLine/Makefile.in	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 102,116 ****
+   install_sh = @install_sh@
+@@ -126,7 +126,7 @@
+   subdir = Contrib/CmdLine
+   mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+ *** misc/SampleICC-1.3.2/Contrib/ICC_utils/Makefile.in	Mon Aug 20 22:10:35 2007
+---- misc/build/SampleICC-1.3.2/Contrib/ICC_utils/Makefile.in	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/Contrib/ICC_utils/Makefile.in	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 133,139 ****
+   CONFIG_CLEAN_FILES =
+@@ -145,7 +145,7 @@
+   	ICC_tool_exception.lo Vetters.lo
+   libICC_utils_la_OBJECTS = $(am_libICC_utils_la_OBJECTS)
+ *** misc/SampleICC-1.3.2/Contrib/ICC_utils/Stubs.h	Mon Aug 20 22:04:53 2007
+---- misc/build/SampleICC-1.3.2/Contrib/ICC_utils/Stubs.h	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/Contrib/ICC_utils/Stubs.h	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 130,136 ****
+   
+@@ -164,7 +164,7 @@
+       return (r_ != p.r_) ? (r_ < p.r_) : ((g_ != p.g_) ? (g_ < p.g_) : (b_ < p.b_));
+     }
+ *** misc/SampleICC-1.3.2/Contrib/ICC_utils/Vetters.cpp	Mon Aug 20 22:04:54 2007
+---- misc/build/SampleICC-1.3.2/Contrib/ICC_utils/Vetters.cpp	Fri Jan 25 14:49:56 2008
++--- misc/build/SampleICC-1.3.2/Contrib/ICC_utils/Vetters.cpp	Fri Jan 25 14:57:06 2008
+ ***************
+ *** 1,322 ****
+ ! /*
+@@ -820,7 +820,7 @@
+ !   }
+ ! }
+ *** misc/SampleICC-1.3.2/IccProfLib/IccIO.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccIO.cpp	Fri Jan 25 14:25:33 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccIO.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 78,84 ****
+   #include "IccIO.h"
+@@ -838,8 +838,20 @@
+   #include <string.h>
+   
+   #ifndef __max
++*** misc/SampleICC-1.3.2/IccProfLib/IccIO.h	Mon Aug 20 22:05:00 2007
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccIO.h	Fri Jan 25 14:23:09 2008
++***************
++*** 79,84 ****
++--- 79,85 ----
++  #define _ICCIO_H
++  
++  #include "IccDefs.h"
+++ #include "memory"
++  #include "stdio.h"
++  
++  #ifdef USESAMPLEICCNAMESPACE
+ *** misc/SampleICC-1.3.2/IccProfLib/IccMpeACS.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccMpeACS.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccMpeACS.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 136,152 ****
+     icChar sigBuf[30];
+@@ -878,7 +890,7 @@
+       icMemDump(sDescription, m_pData, m_nDataSize);
+     }
+ *** misc/SampleICC-1.3.2/IccProfLib/IccMpeBasic.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccMpeBasic.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccMpeBasic.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 218,249 ****
+     sprintf(buf, "%.8f", m_endPoint);
+@@ -1362,8 +1374,56 @@
+       return icValidateCriticalError;
+     }
+   
++*** misc/SampleICC-1.3.2/IccProfLib/IccProfLibConf.h	Mon Aug 20 22:05:00 2007
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccProfLibConf.h	Fri Jan 25 14:23:09 2008
++***************
++*** 107,126 ****
++  
++  #else // non-PC, perhaps Mac or Linux
++  
++!   #define ICCUINT64 unsigned long long
++!   #define ICCINT64  long long
++!   #define ICUINT64TYPE unsigned long long
++!   #define ICINT64TYPE long long
++! 
++!   #if defined(__APPLE__)
++!     #if  defined(__LITTLE_ENDIAN__)
++!       #define ICC_BYTE_ORDER_LITTLE_ENDIAN
++!     #else
++!       #define ICC_BYTE_ORDER_BIG_ENDIAN
++!     #endif
++!   #else
++!     #define ICC_BYTE_ORDER_LITTLE_ENDIAN
++!   #endif
++  
++    #define ICCPROFLIB_API
++    #define ICCPROFLIB_EXTERN
++--- 107,129 ----
++  
++  #else // non-PC, perhaps Mac or Linux
++  
++! #include <sal/types.h>
++! #include <osl/endian.h>
++! 
++!   #define ICCUINT64 sal_uInt64
++!   #define ICCINT64 sal_Int64
++!   #define ICUINT64TYPE sal_uInt64
++!   #define ICINT64TYPE sal_Int64
++!   #define ICINT32TYPE sal_Int32
++!   #define ICUINT32TYPE sal_uInt32
++! 
++! #if defined(_LITTLE_ENDIAN)
++! #    define ICC_BYTE_ORDER_LITTLE_ENDIAN
++! #elif defined(_BIG_ENDIAN)
++! #    define ICC_BYTE_ORDER_BIG_ENDIAN
++! #else
++! #    error "ENDIAN unknown"
++! #endif
++  
++    #define ICCPROFLIB_API
++    #define ICCPROFLIB_EXTERN
+ *** misc/SampleICC-1.3.2/IccProfLib/IccProfile.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccProfile.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccProfile.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 567,573 ****
+   
+@@ -1989,7 +2049,7 @@
+       return NULL;
+     }
+ *** misc/SampleICC-1.3.2/IccProfLib/IccTagBasic.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccTagBasic.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccTagBasic.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 166,172 ****
+       CIccInfo Info;
+@@ -3311,7 +3371,7 @@
+     }
+     else {
+ *** misc/SampleICC-1.3.2/IccProfLib/IccTagLut.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccTagLut.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccTagLut.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 323,345 ****
+     icChar buf[128], *ptr;
+@@ -4443,7 +4503,7 @@
+             }
+           }
+ *** misc/SampleICC-1.3.2/IccProfLib/IccTagMPE.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccTagMPE.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccTagMPE.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 218,224 ****
+             icGetSig(sigbuf, m_sig), m_nSize);
+@@ -4615,7 +4675,7 @@
+     }
+   
+ *** misc/SampleICC-1.3.2/IccProfLib/IccTagProfSeqId.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccTagProfSeqId.cpp	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccTagProfSeqId.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 234,240 ****
+   {
+@@ -4706,7 +4766,7 @@
+   
+   
+ *** misc/SampleICC-1.3.2/IccProfLib/IccTagProfSeqId.h	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccTagProfSeqId.h	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccTagProfSeqId.h	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 161,164 ****
+   }
+@@ -4719,7 +4779,7 @@
+   
+ ! #endif //_ICCTAGPROFSEQID_H
+ *** misc/SampleICC-1.3.2/IccProfLib/IccUtil.cpp	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/IccUtil.cpp	Fri Jan 25 14:27:16 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/IccUtil.cpp	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 79,85 ****
+   #include "IccUtil.h"
+@@ -4974,7 +5034,7 @@
+       rv = icMaxStatus(rv, icValidateWarning);
+     }
+ *** misc/SampleICC-1.3.2/IccProfLib/icProfileHeader.h	Mon Aug 20 22:05:00 2007
+---- misc/build/SampleICC-1.3.2/IccProfLib/icProfileHeader.h	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/IccProfLib/icProfileHeader.h	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 659,668 ****
+   typedef enum {
+@@ -5000,7 +5060,7 @@
+   
+   
+ *** misc/SampleICC-1.3.2/Tools/CmdLine/Makefile.in	Mon Aug 20 22:10:42 2007
+---- misc/build/SampleICC-1.3.2/Tools/CmdLine/Makefile.in	Fri Jan 25 14:24:00 2008
++--- misc/build/SampleICC-1.3.2/Tools/CmdLine/Makefile.in	Fri Jan 25 14:23:09 2008
+ ***************
+ *** 101,117 ****
+   am__quote = @am__quote@
+diff -r 2691de086167 icc/makefile.mk
+--- icc/makefile.mk	Thu Nov 05 15:23:36 2009 +0000
++++ icc/makefile.mk	Thu Nov 05 18:03:59 2009 +0000
+@@ -41,12 +41,7 @@
+ # --- Files --------------------------------------------------------
+ 
+ TARFILE_NAME=SampleICC-1.3.2
+-#checking for endianess
+-.IF "$(CPU)"=="I"
+ PATCH_FILE_NAME=$(TARFILE_NAME).patch
+-.ELSE
+-PATCH_FILE_NAME=$(TARFILE_NAME)-bendian.patch
+-.ENDIF
+ 
+ CONVERTFILES= \
+ 	IccProfLib$/IccTagProfSeqId.h \
+diff -r 2691de086167 icc/prj/build.lst
+--- icc/prj/build.lst	Thu Nov 05 15:23:36 2009 +0000
++++ icc/prj/build.lst	Thu Nov 05 18:03:59 2009 +0000
+@@ -1,3 +1,3 @@
+-ip     icc :	solenv external NULL
++ip     icc :	solenv external sal NULL
+ ip	icc		usr1	-	all	ip_mkout NULL
+ ip	icc		nmake	-	all	ip_icc	NULL
diff -Nur ooo-build-3.1.1.4/patches/dev300/kde4_fpicker_fixes2.diff ooo-build-3.1.1.5/patches/dev300/kde4_fpicker_fixes2.diff
--- ooo-build-3.1.1.4/patches/dev300/kde4_fpicker_fixes2.diff	2009-10-14 12:52:43.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/kde4_fpicker_fixes2.diff	2009-10-21 16:16:06.000000000 +0300
@@ -236,3 +236,14 @@
  	
  	Display* pDisp = QX11Info::display();
  	SalKDEDisplay *pSalDisplay = new SalKDEDisplay(pDisp);
+--- fpicker/source/unx/kde4/KDE4FilePicker.cxx	2009-10-19 22:40:31.000000000 +0200
++++ fpicker/source/unx/kde4/KDE4FilePicker_new.cxx	2009-10-19 22:38:57.000000000 +0200
+@@ -349,7 +349,7 @@
+ rtl::OUString SAL_CALL KDE4FilePicker::getCurrentFilter()
+     throw( uno::RuntimeException )
+ {
+-	QString filter = _filters[_dialog->currentFilter()];
++	QString filter = _dialog->filterWidget()->currentText();
+ 	
+ 	//default if not found
+ 	if (filter.isNull())
diff -Nur ooo-build-3.1.1.4/patches/dev300/layout-listbox-line-count-move-copy-sheet.diff ooo-build-3.1.1.5/patches/dev300/layout-listbox-line-count-move-copy-sheet.diff
--- ooo-build-3.1.1.4/patches/dev300/layout-listbox-line-count-move-copy-sheet.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/layout-listbox-line-count-move-copy-sheet.diff	2009-10-23 15:16:33.000000000 +0300
@@ -0,0 +1,108 @@
+From 7dd49a45955f78580e9cff600e5882cb28a6940a Mon Sep 17 00:00:00 2001
+From: jcn <jcn@8da58560-a4e7-4996-a0c2-a735b94b261c>
+Date: Mon, 20 Oct 2008 17:29:04 +0000
+Subject: [PATCH] move-copy-sheet.xml: use line-count="7".  Fixes n#548091.
+
+   * Modified     toolkit/workben/layout/move-copy-sheet.xml
+   * Modified     sc/uiconfig/layout/move-copy-sheet.xml
+
+fixed compiler warnings
+
+   * Modified     vcl/source/control/lstbox.cxx    
+
+git-svn-id: svn+ssh://svn.services.openoffice.org/ooo/cws/layoutdialogs2@264352 8da58560-a4e7-4996-a0c2-a735b94b261c
+
+layoutdialogs2: vcl: respect line-count also for non-dropdown listbox.
+
+   * Modified     vcl/inc/vcl/lstbox.hxx
+   * Modified     vcl/source/control/lstbox.cxx    
+
+git-svn-id: svn+ssh://svn.services.openoffice.org/ooo/cws/layoutdialogs2@262552 8da58560-a4e7-4996-a0c2-a735b94b261c
+---
+ sc/uiconfig/layout/move-copy-sheet.xml     |    2 +-
+ toolkit/workben/layout/move-copy-sheet.xml |    2 +-
+ vcl/inc/vcl/lstbox.hxx                     |    1 +
+ vcl/source/control/lstbox.cxx              |   14 ++++++--------
+ 4 files changed, 9 insertions(+), 10 deletions(-)
+
+diff --git sc/uiconfig/layout/move-copy-sheet.xml sc/uiconfig/layout/move-copy-sheet.xml
+index 6e68b5a..7c4af29 100644
+--- sc/uiconfig/layout/move-copy-sheet.xml
++++ sc/uiconfig/layout/move-copy-sheet.xml
+@@ -9,7 +9,7 @@
+         <fixedtext id="FT_DEST" _label="To ~document"/>
+         <listbox has_border="true" dropdown="true" id="LB_DEST" tabstop="true"/>
+         <fixedtext id="FT_INSERT" _label="~Insert before"/>
+-        <listbox has_border="true" id="LB_INSERT" tabstop="true" string-item-list=" : : : : " />
++        <listbox has_border="true" id="LB_INSERT" tabstop="true" line-count="7" string-item-list=" : : : : " />
+         <checkbox id="BTN_COPY" tabstop="true" _label="~Copy"/>
+ 	<dialogbuttonhbox border="5" spacing="5">
+ 	    <flow/>
+diff --git toolkit/workben/layout/move-copy-sheet.xml toolkit/workben/layout/move-copy-sheet.xml
+index 6e68b5a..7c4af29 100644
+--- toolkit/workben/layout/move-copy-sheet.xml
++++ toolkit/workben/layout/move-copy-sheet.xml
+@@ -9,7 +9,7 @@
+         <fixedtext id="FT_DEST" _label="To ~document"/>
+         <listbox has_border="true" dropdown="true" id="LB_DEST" tabstop="true"/>
+         <fixedtext id="FT_INSERT" _label="~Insert before"/>
+-        <listbox has_border="true" id="LB_INSERT" tabstop="true" string-item-list=" : : : : " />
++        <listbox has_border="true" id="LB_INSERT" tabstop="true" line-count="7" string-item-list=" : : : : " />
+         <checkbox id="BTN_COPY" tabstop="true" _label="~Copy"/>
+ 	<dialogbuttonhbox border="5" spacing="5">
+ 	    <flow/>
+diff --git vcl/inc/vcl/lstbox.hxx vcl/inc/vcl/lstbox.hxx
+index 2390ab9..bfcac48 100644
+--- vcl/inc/vcl/lstbox.hxx
++++ vcl/inc/vcl/lstbox.hxx
+
+@@ -57,6 +57,7 @@ private:
+ 	BOOL						mbDDAutoSize;
+ 	Link						maSelectHdl;
+ 	Link						maDoubleClickHdl;
++    USHORT mnLineCount;
+ 
+ //#if 0 // _SOLAR__PRIVATE
+ private:
+diff --git vcl/source/control/lstbox.cxx vcl/source/control/lstbox.cxx
+index b22abb5..8a510d4 100644
+--- vcl/source/control/lstbox.cxx
++++ vcl/source/control/lstbox.cxx
+@@ -604,18 +604,18 @@ BOOL ListBox::IsDDAutoWidthEnabled() const
+ 
+ void ListBox::SetDropDownLineCount( USHORT nLines )
+ {
++    mnLineCount = nLines;
+ 	if ( mpFloatWin )
+-		mpFloatWin->SetDropDownLineCount( nLines );
++		mpFloatWin->SetDropDownLineCount( mnLineCount );
+ }
+ 
+ // -----------------------------------------------------------------------
+ 
+ USHORT ListBox::GetDropDownLineCount() const
+ {
+-	USHORT nLines = 0;
+-	if ( mpFloatWin )
+-		nLines = mpFloatWin->GetDropDownLineCount();
+-	return nLines;
++    if ( mpFloatWin )
++        return mpFloatWin->GetDropDownLineCount();
++	return mnLineCount;
+ }
+ 
+ // -----------------------------------------------------------------------
+@@ -1260,9 +1260,7 @@ Size ListBox::CalcMinimumSize() const
+ {
+ 	Size aSz;
+ 	if ( !IsDropDownBox() )
+-	{
+-		aSz = mpImplLB->CalcSize( mpImplLB->GetEntryList()->GetEntryCount() );
+-	}
++        aSz = mpImplLB->CalcSize (mnLineCount ? mnLineCount : mpImplLB->GetEntryList()->GetEntryCount());
+ 	else
+ 	{
+ 		aSz.Height() = mpImplLB->CalcSize( 1 ).Height();
+-- 
+1.6.3.3
+
diff -Nur ooo-build-3.1.1.4/patches/dev300/oox-pptx-import-fix-header-footer-backport.diff ooo-build-3.1.1.5/patches/dev300/oox-pptx-import-fix-header-footer-backport.diff
--- ooo-build-3.1.1.4/patches/dev300/oox-pptx-import-fix-header-footer-backport.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/oox-pptx-import-fix-header-footer-backport.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,102 @@
+diff -rup oox-orig/inc/oox/drawingml/shape.hxx oox/inc/oox/drawingml/shape.hxx
+--- oox-orig/inc/oox/drawingml/shape.hxx	2009-10-29 15:55:23.000000000 +0100
++++ oox/inc/oox/drawingml/shape.hxx	2009-10-29 17:27:19.000000000 +0100
+@@ -170,7 +170,8 @@ protected:
+                             const ::rtl::OUString& rServiceName,
+                             const ThemePtr& rxTheme,
+                             const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
+-                            const ::com::sun::star::awt::Rectangle* pShapeRect );
++                            const ::com::sun::star::awt::Rectangle* pShapeRect,
++			    sal_Bool bClearText );
+ 
+     void                addChildren(
+                             const ::oox::core::XmlFilterBase& rFilterBase,
+diff -rup oox-orig/source/drawingml/shape.cxx oox/source/drawingml/shape.cxx
+--- oox-orig/source/drawingml/shape.cxx	2009-10-29 15:55:25.000000000 +0100
++++ oox/source/drawingml/shape.cxx	2009-10-29 17:30:43.000000000 +0100
+@@ -167,7 +167,7 @@ void Shape::addShape(
+         rtl::OUString sServiceName( msServiceName );
+         if( sServiceName.getLength() )
+         {
+-            Reference< XShape > xShape( createAndInsert( rFilterBase, sServiceName, rxTheme, rxShapes, pShapeRect ) );
++            Reference< XShape > xShape( createAndInsert( rFilterBase, sServiceName, rxTheme, rxShapes, pShapeRect, sal_False ) );
+ 
+             if( pShapeMap && msId.getLength() )
+             {
+@@ -279,7 +279,8 @@ Reference< XShape > Shape::createAndInse
+         const rtl::OUString& rServiceName,
+         const ThemePtr& rxTheme,
+         const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >& rxShapes,
+-        const awt::Rectangle* pShapeRect )
++        const awt::Rectangle* pShapeRect,
++        sal_Bool bClearText )
+ {
+     basegfx::B2DHomMatrix aTransformation;
+ 
+@@ -429,6 +430,17 @@ Reference< XShape > Shape::createAndInse
+         }
+         rxShapes->add( mxShape );
+ 
++        // sj: removing default text of placeholder objects such as SlideNumberShape or HeaderShape
++        if ( bClearText )
++        {
++            uno::Reference< text::XText > xText( mxShape, uno::UNO_QUERY );
++            if ( xText.is() )
++            {
++                OUString aEmpty;
++                xText->setString( aEmpty );
++            }
++        }
++
+         LineProperties aLineProperties;
+         aLineProperties.maLineFill.moFillType = XML_noFill;
+         sal_Int32 nLinePhClr = -1;
+diff -rup oox-orig/source/ppt/pptshape.cxx oox/source/ppt/pptshape.cxx
+--- oox-orig/source/ppt/pptshape.cxx	2009-10-29 15:55:25.000000000 +0100
++++ oox/source/ppt/pptshape.cxx	2009-10-29 17:29:38.000000000 +0100
+@@ -84,6 +84,7 @@ void PPTShape::addShape(
+         {
+             oox::drawingml::TextListStylePtr aMasterTextListStyle;
+             Reference< lang::XMultiServiceFactory > xServiceFact( rFilterBase.getModel(), UNO_QUERY_THROW );
++	    sal_Bool bClearText = sal_False;
+ 
+ 			if ( sServiceName != OUString::createFromAscii( "com.sun.star.drawing.GraphicObjectShape" ) &&
+ 			     sServiceName != OUString::createFromAscii( "com.sun.star.drawing.OLE2Shape" ) )
+@@ -131,24 +132,28 @@ void PPTShape::addShape(
+                     {
+                         const rtl::OUString sDateTimeShapeService( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.presentation.DateTimeShape" ) );
+                         sServiceName = sDateTimeShapeService;
++			bClearText = sal_True;
+                     }
+                     break;
+                     case XML_hdr :
+                     {
+                         const rtl::OUString sHeaderShapeService( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.presentation.HeaderShape" ) );
+                         sServiceName = sHeaderShapeService;
++			bClearText = sal_True;
+                     }
+                     break;
+                     case XML_ftr :
+                     {
+                         const rtl::OUString sFooterShapeService( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.presentation.FooterShape" ) );
+                         sServiceName = sFooterShapeService;
++			bClearText = sal_True;
+                     }
+                     break;
+                     case XML_sldNum :
+                     {
+                         const rtl::OUString sSlideNumberShapeService( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.presentation.SlideNumberShape" ) );
+                         sServiceName = sSlideNumberShapeService;
++			bClearText = sal_True;
+                     }
+                     break;
+                     case XML_sldImg :
+@@ -191,7 +196,7 @@ void PPTShape::addShape(
+ 			} else
+ 			    setMasterTextListStyle( aMasterTextListStyle );
+ 
+-            Reference< XShape > xShape( createAndInsert( rFilterBase, sServiceName, rxTheme, rxShapes, pShapeRect ) );
++			Reference< XShape > xShape( createAndInsert( rFilterBase, sServiceName, rxTheme, rxShapes, pShapeRect, bClearText ) );
+ 
+             if( pShapeMap && msId.getLength() )
+             {
diff -Nur ooo-build-3.1.1.4/patches/dev300/sw-ww8-import-list-fix.diff ooo-build-3.1.1.5/patches/dev300/sw-ww8-import-list-fix.diff
--- ooo-build-3.1.1.4/patches/dev300/sw-ww8-import-list-fix.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/sw-ww8-import-list-fix.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,34 @@
+diff --git sw/source/filter/ww8/ww8par6.cxx sw/source/filter/ww8/ww8par6.cxx
+index c15042a..c75935f 100644
+--- sw/source/filter/ww8/ww8par6.cxx
++++ sw/source/filter/ww8/ww8par6.cxx
+@@ -3898,6 +3898,29 @@ void SwWW8ImplReader::Read_LR( USHORT nId, const BYTE* pData, short nLen )
+     if( pLR )
+         aLR = *(const SvxLRSpaceItem*)pLR;
+ 
++    // Fix the regression issue: #i99822#: Discussion?   
++    // Since the list lever formatting doesn't apply into paragraph style 
++    // for list levels of mode LABEL_ALIGNMENT.(see ww8par3.cxx 
++    // W8ImplReader::RegisterNumFmtOnTxtNode).
++    // Need to apply the list format to the paragraph here.
++    SwTxtNode* pTxtNode = pPaM->GetNode()->GetTxtNode();
++    if( pTxtNode && pTxtNode->AreListLevelIndentsApplicable() )
++    {
++        SwNumRule * pNumRule = pTxtNode->GetNumRule();
++        if( pNumRule )
++        {
++            BYTE nLvl = static_cast< BYTE >(pTxtNode->GetActualListLevel());
++            const SwNumFmt* pFmt = pNumRule->GetNumFmt( nLvl );
++            if ( pFmt && pFmt->GetPositionAndSpaceMode() == SvxNumberFormat::LABEL_ALIGNMENT )
++            {
++                aLR.SetTxtLeft( pFmt->GetIndentAt() );
++                aLR.SetTxtFirstLineOfst( static_cast<short>(pFmt->GetFirstLineIndent()) );
++                // make paragraph have hard-set indent attributes
++                pTxtNode->SetAttr( aLR );
++            }
++        }
++    }
++
+     /*
+     The older word sprms mean left/right, while the new ones mean before/after.
+     Writer now also works with before after, so when we see old left/right and
diff -Nur ooo-build-3.1.1.4/patches/dev300/sw-ww8-textframe-background-fix.diff ooo-build-3.1.1.5/patches/dev300/sw-ww8-textframe-background-fix.diff
--- ooo-build-3.1.1.4/patches/dev300/sw-ww8-textframe-background-fix.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/sw-ww8-textframe-background-fix.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,23 @@
+diff --git sw/source/filter/ww8/ww8graf.cxx sw/source/filter/ww8/ww8graf.cxx
+index 2853bcc..add9cd2 100644
+--- sw/source/filter/ww8/ww8graf.cxx
++++ sw/source/filter/ww8/ww8graf.cxx
+@@ -1906,6 +1906,7 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
+                 }
+             break;
+             case XFILL_SOLID:
++            case XFILL_GRADIENT:
+                 {
+                     const Color aColor = static_cast< XFillColorItem const & >(
+                         rOldSet.Get(XATTR_FILLCOLOR)).GetColorValue();
+@@ -1917,8 +1918,8 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
+                     bBrushItemOk = true;
+                 }
+             break;
+-            case XFILL_GRADIENT:
+-            break;
++            //case XFILL_GRADIENT:
++            //break;
+             case XFILL_HATCH:
+             break;
+             case XFILL_BITMAP:
diff -Nur ooo-build-3.1.1.4/patches/dev300/unoxml-fix-empty-xmlns.diff ooo-build-3.1.1.5/patches/dev300/unoxml-fix-empty-xmlns.diff
--- ooo-build-3.1.1.4/patches/dev300/unoxml-fix-empty-xmlns.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/unoxml-fix-empty-xmlns.diff	2009-10-23 15:16:33.000000000 +0300
@@ -0,0 +1,13 @@
+--- unoxml/source/dom/node.cxx.orig	2009-10-21 15:48:14.000000000 +0200
++++ unoxml/source/dom/node.cxx	2009-10-21 15:49:05.000000000 +0200
+@@ -71,8 +71,9 @@ namespace DOM
+         // add node's namespaces to current context
+         for (xmlNsPtr pNs = pNode->nsDef; pNs != 0; pNs = pNs->next) {
+             const xmlChar *pPrefix = pNs->prefix;
++	    // prefix can be NULL when xmlns attribute is empty (xmlns="")
+             OString prefix(reinterpret_cast<const sal_Char*>(pPrefix),
+-                           strlen(reinterpret_cast<const char*>(pPrefix)));
++                           pPrefix ? strlen(reinterpret_cast<const char*>(pPrefix)) : 0);
+             const xmlChar *pHref = pNs->href;
+             OUString val(reinterpret_cast<const sal_Char*>(pHref),
+                 strlen(reinterpret_cast<const char*>(pHref)),
diff -Nur ooo-build-3.1.1.4/patches/dev300/xlsx-build-fix.diff ooo-build-3.1.1.5/patches/dev300/xlsx-build-fix.diff
--- ooo-build-3.1.1.4/patches/dev300/xlsx-build-fix.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/dev300/xlsx-build-fix.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,30 @@
+diff --git sc/source/filter/xlsx/xlsx-xeformula.cxx sc/source/filter/xlsx/xlsx-xeformula.cxx
+index 31af0f9..c1989b8 100644
+--- sc/source/filter/xlsx/xlsx-xeformula.cxx
++++ sc/source/filter/xlsx/xlsx-xeformula.cxx
+@@ -619,7 +619,7 @@ void XclExpFmlaCompImpl::Init( XclFormulaType eType, const ScTokenArray& rScTokA
+             DBG_ASSERT( mbOk, "XclExpFmlaCompImpl::Init - missing cell address" );
+             // clone the passed token array, convert references relative to current cell position
+             mxOwnScTokArr.reset( rScTokArr.Clone() );
+-            ScCompiler::MoveRelWrap( *mxOwnScTokArr, GetDocPtr(), *pScBasePos );
++            ScCompiler::MoveRelWrap( *mxOwnScTokArr, GetDocPtr(), *pScBasePos, MAXCOL, MAXROW );
+             // don't remember pScBasePos in mpScBasePos, shared formulas use real relative refs
+         break;
+         default:;
+diff --git sc/source/filter/xlsx/xlsx-xiescher.cxx sc/source/filter/xlsx/xlsx-xiescher.cxx
+index 1637ab1..48ebcb6 100644
+--- sc/source/filter/xlsx/xlsx-xiescher.cxx
++++ sc/source/filter/xlsx/xlsx-xiescher.cxx
+@@ -2791,6 +2791,12 @@ SdrObject* XclImpPictureObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfPr
+     return xSdrObj.release();
+ }
+ 
++String XclImpPictureObj::GetObjName() const
++{
++    // dummy function definition.  This is never called.
++    return String();
++}
++
+ void XclImpPictureObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
+ {
+     if( IsOcxControl() )
diff -Nur ooo-build-3.1.1.4/patches/dev300/xlsx-build-fix-m18.diff ooo-build-3.1.1.5/patches/dev300/xlsx-build-fix-m18.diff
--- ooo-build-3.1.1.4/patches/dev300/xlsx-build-fix-m18.diff	2009-08-17 14:30:19.000000000 +0300
+++ ooo-build-3.1.1.5/patches/dev300/xlsx-build-fix-m18.diff	1970-01-01 02:00:00.000000000 +0200
@@ -1,13 +0,0 @@
-diff --git sc/source/filter/xlsx/xlsx-xeformula.cxx sc/source/filter/xlsx/xlsx-xeformula.cxx
-index 31af0f9..c1989b8 100644
---- sc/source/filter/xlsx/xlsx-xeformula.cxx
-+++ sc/source/filter/xlsx/xlsx-xeformula.cxx
-@@ -619,7 +619,7 @@ void XclExpFmlaCompImpl::Init( XclFormulaType eType, const ScTokenArray& rScTokA
-             DBG_ASSERT( mbOk, "XclExpFmlaCompImpl::Init - missing cell address" );
-             // clone the passed token array, convert references relative to current cell position
-             mxOwnScTokArr.reset( rScTokArr.Clone() );
--            ScCompiler::MoveRelWrap( *mxOwnScTokArr, GetDocPtr(), *pScBasePos );
-+            ScCompiler::MoveRelWrap( *mxOwnScTokArr, GetDocPtr(), *pScBasePos, MAXCOL, MAXROW );
-             // don't remember pScBasePos in mpScBasePos, shared formulas use real relative refs
-         break;
-         default:;
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-autofiltermode.diff ooo-build-3.1.1.5/patches/vba/vba-autofiltermode.diff
--- ooo-build-3.1.1.4/patches/vba/vba-autofiltermode.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-autofiltermode.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,275 @@
+diff --git oovbaapi/ooo/vba/excel/XWorksheet.idl oovbaapi/ooo/vba/excel/XWorksheet.idl
+index 1f07f9f..4e037a5 100644
+--- oovbaapi/ooo/vba/excel/XWorksheet.idl
++++ oovbaapi/ooo/vba/excel/XWorksheet.idl
+@@ -64,6 +64,7 @@ interface XWorksheet
+ 	interface ::com::sun::star::container::XNamed;
+ 
+     [attribute] boolean Visible; 
++    [attribute] boolean AutoFilterMode; 
+     [attribute, readonly] long StandardHeight;
+     [attribute, readonly] long StandardWidth;
+     [attribute, readonly] boolean ProtectionMode;
+diff --git sc/source/ui/vba/excelvbahelper.cxx sc/source/ui/vba/excelvbahelper.cxx
+index 49d1e34..9cb844a 100644
+--- sc/source/ui/vba/excelvbahelper.cxx
++++ sc/source/ui/vba/excelvbahelper.cxx
+@@ -44,6 +44,55 @@ namespace vba
+ {
+ namespace excel
+ {
++
++
++uno::Reference< sheet::XDatabaseRanges > 
++GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
++{
++    uno::Reference< frame::XModel > xModel;
++    if ( pShell )
++        xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
++    uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
++    uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
++    return xDBRanges;
++}
++
++// returns the XDatabaseRange for the autofilter on sheet (nSheet)
++// also populates sName with the name of range
++uno::Reference< sheet::XDatabaseRange > 
++GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName ) throw ( uno::RuntimeException )
++{
++    uno::Reference< container::XIndexAccess > xIndexAccess( GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
++    uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
++    table::CellRangeAddress dbAddress;
++    for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
++    {
++        uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
++        uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
++        // autofilters work weirdly with openoffice, unnamed is the default 
++        // named range which is used to create an autofilter, but
++        // its also possible that another name could be used
++        //     this also causes problems when an autofilter is created on
++        //     another sheet
++        // ( but.. you can use any named range )
++        dbAddress = xDBRange->getDataArea();
++        if ( dbAddress.Sheet == nSheet )
++        {
++            sal_Bool bHasAuto = sal_False;
++            uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
++            xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
++            if ( bHasAuto )
++            {
++                sName = xNamed->getName();	
++                xDataBaseRange=xDBRange;
++                break;
++            }
++        }
++    }
++    return xDataBaseRange;
++} 
++
++
+ void implSetZoom( const uno::Reference< frame::XModel >& xModel, sal_Int16 nZoom, std::vector< SCTAB >& nTabs )
+ {
+     ScTabViewShell* pViewSh = excel::getBestViewShell( xModel );
+@@ -217,6 +266,7 @@ ScVbaCellRangeAccess::GetDataSet( ScCellRangeObj* pRangeObj )
+ 	return pDataSet;
+ 	
+ }
++
+ } //excel
+ } //vba 
+ } //ooo 
+diff --git sc/source/ui/vba/excelvbahelper.hxx sc/source/ui/vba/excelvbahelper.hxx
+index 9c95501..d97721e 100644
+--- sc/source/ui/vba/excelvbahelper.hxx
++++ sc/source/ui/vba/excelvbahelper.hxx
+@@ -32,6 +32,8 @@
+ 
+ #include<vbahelper/vbahelper.hxx>
+ #include <docsh.hxx>
++#include <com/sun/star/sheet/XDatabaseRanges.hpp>
++#include <com/sun/star/sheet/XDatabaseRange.hpp>
+ 
+ class ScCellRangeObj;
+ 
+@@ -51,6 +53,10 @@ namespace ooo
+ 		ScDocShell* getDocShell( const css::uno::Reference< css::frame::XModel>& xModel ) ;
+ 		ScTabViewShell* getCurrentBestViewShell( const css::uno::Reference< css::uno::XComponentContext >& xContext );
+ 		SfxViewFrame* getViewFrame( const css::uno::Reference< css::frame::XModel >& xModel );
++
++                css::uno::Reference< css::sheet::XDatabaseRanges > GetDataBaseRanges( ScDocShell* pShell ) throw ( css::uno::RuntimeException );
++
++                css::uno::Reference< css::sheet::XDatabaseRange > GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName ) throw ( css::uno::RuntimeException );
+             class ScVbaCellRangeAccess
+             {
+             public:
+diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
+index 23c9598..4f68d10 100644
+--- sc/source/ui/vba/vbarange.cxx
++++ sc/source/ui/vba/vbarange.cxx
+@@ -3943,56 +3943,12 @@ ScVbaRange::ApplicationRange( const uno::Reference< uno::XComponentContext >& xC
+     return pRange->Range( Cell1, Cell2, true ); 
+ }
+ 
+-uno::Reference< sheet::XDatabaseRanges > 
+-lcl_GetDataBaseRanges( ScDocShell* pShell ) throw ( uno::RuntimeException )
+-{
+-    uno::Reference< frame::XModel > xModel;
+-    if ( pShell )
+-        xModel.set( pShell->GetModel(), uno::UNO_QUERY_THROW );
+-    uno::Reference< beans::XPropertySet > xModelProps( xModel, uno::UNO_QUERY_THROW );
+-    uno::Reference< sheet::XDatabaseRanges > xDBRanges( xModelProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("DatabaseRanges") ) ), uno::UNO_QUERY_THROW );
+-    return xDBRanges;	
+-}
+-// returns the XDatabaseRange for the autofilter on sheet (nSheet)
+-// also populates sName with the name of range
+-uno::Reference< sheet::XDatabaseRange > 
+-lcl_GetAutoFiltRange( ScDocShell* pShell, sal_Int16 nSheet, rtl::OUString& sName )
+-{
+-    uno::Reference< container::XIndexAccess > xIndexAccess( lcl_GetDataBaseRanges( pShell ), uno::UNO_QUERY_THROW );
+-    uno::Reference< sheet::XDatabaseRange > xDataBaseRange;
+-    table::CellRangeAddress dbAddress;
+-    for ( sal_Int32 index=0; index < xIndexAccess->getCount(); ++index )
+-    {
+-        uno::Reference< sheet::XDatabaseRange > xDBRange( xIndexAccess->getByIndex( index ), uno::UNO_QUERY_THROW );
+-        uno::Reference< container::XNamed > xNamed( xDBRange, uno::UNO_QUERY_THROW ); 
+-        // autofilters work weirdly with openoffice, unnamed is the default 
+-        // named range which is used to create an autofilter, but
+-        // its also possible that another name could be used
+-        //     this also causes problems when an autofilter is created on
+-        //     another sheet
+-        // ( but.. you can use any named range )
+-        dbAddress = xDBRange->getDataArea();
+-        if ( dbAddress.Sheet == nSheet )
+-        {
+-            sal_Bool bHasAuto = sal_False;
+-            uno::Reference< beans::XPropertySet > xProps( xDBRange, uno::UNO_QUERY_THROW );
+-            xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ) ) >>= bHasAuto;
+-            if ( bHasAuto )
+-            {
+-                sName = xNamed->getName();	
+-                xDataBaseRange=xDBRange;
+-                break;
+-            }
+-        }
+-    }
+-    return xDataBaseRange;
+-} 
+ 
+ // Helper functions for AutoFilter
+ ScDBData* lcl_GetDBData_Impl( ScDocShell* pDocShell, sal_Int16 nSheet )
+ {
+     rtl::OUString sName;
+-    lcl_GetAutoFiltRange( pDocShell, nSheet, sName );
++    excel::GetAutoFiltRange( pDocShell, nSheet, sName );
+     OSL_TRACE("lcl_GetDBData_Impl got autofilter range %s for sheet %d",
+         rtl::OUStringToOString( sName, RTL_TEXTENCODING_UTF8 ).getStr() , nSheet );
+     ScDBData* pRet = NULL;
+@@ -4159,7 +4115,7 @@ ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const
+     ScDocShell* pShell = getScDocShell();
+     sal_Bool bHasAuto = sal_False;	
+     rtl::OUString sAutofiltRangeName;
+-    uno::Reference< sheet::XDatabaseRange > xDataBaseRange = lcl_GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
++    uno::Reference< sheet::XDatabaseRange > xDataBaseRange = excel::GetAutoFiltRange( pShell, nSheet, sAutofiltRangeName );
+     if ( xDataBaseRange.is() )
+         bHasAuto = true;	
+ 
+@@ -4192,7 +4148,7 @@ ScVbaRange::AutoFilter( const uno::Any& Field, const uno::Any& Criteria1, const
+             autoFiltAddress = multiCellRange.getCellRangeAddressable()->getRangeAddress();
+         }
+ 
+-        uno::Reference< sheet::XDatabaseRanges > xDBRanges = lcl_GetDataBaseRanges( pShell );
++        uno::Reference< sheet::XDatabaseRanges > xDBRanges = excel::GetDataBaseRanges( pShell );
+         if ( xDBRanges.is() )
+         {
+             rtl::OUString sGenName( RTL_CONSTASCII_USTRINGPARAM("VBA_Autofilter_") );
+diff --git sc/source/ui/vba/vbawindow.cxx sc/source/ui/vba/vbawindow.cxx
+index c05b314..a612f59 100644
+--- sc/source/ui/vba/vbawindow.cxx
++++ sc/source/ui/vba/vbawindow.cxx
+@@ -59,7 +59,7 @@ using namespace ::ooo::vba;
+ using namespace ::ooo::vba::excel::XlWindowState;
+ 
+ // nameExists defined in vbaworksheet.cxx
+-bool nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException );
++bool nameExists( const uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, const ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException );
+ 
+ typedef  std::hash_map< rtl::OUString,
+ SCTAB, ::rtl::OUStringHash,
+diff --git sc/source/ui/vba/vbaworksheet.cxx sc/source/ui/vba/vbaworksheet.cxx
+index 015e68f..3a38bd3 100644
+--- sc/source/ui/vba/vbaworksheet.cxx
++++ sc/source/ui/vba/vbaworksheet.cxx
+@@ -99,7 +99,7 @@
+ using namespace com::sun::star;
+ using namespace ooo::vba;
+ bool
+-nameExists( uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException )
++nameExists( const uno::Reference <sheet::XSpreadsheetDocument>& xSpreadDoc, const ::rtl::OUString & name, SCTAB& nTab ) throw ( lang::IllegalArgumentException )
+ {
+     if (!xSpreadDoc.is())
+         throw lang::IllegalArgumentException( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "nameExists() xSpreadDoc is null" ) ), uno::Reference< uno::XInterface  >(), 1 );
+@@ -993,6 +993,50 @@ ScVbaWorksheet::PrintOut( const uno::Any& From, const uno::Any& To, const uno::A
+ 	PrintOutHelper( excel::getBestViewShell( xModel ), From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, PrToFileName, bSelection );
+ }
+ 
++uno::Reference< sheet::XDatabaseRange > lcl_getXDatabase( const uno::Reference< frame::XModel >& xModel, const rtl::OUString& aSheetName ) throw ( uno::RuntimeException)
++
++{
++    uno::Reference< sheet::XDatabaseRange > xDBRange;
++    uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
++    SCTAB nTab(0);
++    bool bSheetExists = nameExists (xSpreadDoc, aSheetName, nTab);
++    if ( bSheetExists )    
++    {
++        rtl::OUString sAutofilterRngName;
++	ScDocShell* pShell = excel::getDocShell( xModel );
++
++        xDBRange = excel::GetAutoFiltRange( pShell, static_cast<  sal_Int16 >( nTab ), sAutofilterRngName );
++            
++    }
++    return xDBRange;
++}
++
++::sal_Bool SAL_CALL 
++ScVbaWorksheet::getAutoFilterMode() throw (uno::RuntimeException)
++{
++    if ( lcl_getXDatabase( getModel(), getName() ).is() )
++        return sal_True; 
++    return sal_False;
++}
++
++void SAL_CALL 
++ScVbaWorksheet::setAutoFilterMode( ::sal_Bool _autofiltermode ) throw (uno::RuntimeException)
++{
++    if ( !_autofiltermode )
++    {
++        uno::Reference< sheet::XDatabaseRange >xAutoFilt = lcl_getXDatabase( getModel(), getName() );
++        
++       if ( xAutoFilt.is() )
++       {
++           uno::Reference< beans::XPropertySet > xProps( xAutoFilt, uno::UNO_QUERY_THROW );
++           xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("AutoFilter") ), uno::makeAny( sal_False ) );
++       }
++    }
++    // Not possible to set to true
++    else
++        throw uno::RuntimeException();
++}
++
+ namespace worksheet
+ {
+ namespace sdecl = comphelper::service_decl;
+diff --git sc/source/ui/vba/vbaworksheet.hxx sc/source/ui/vba/vbaworksheet.hxx
+index cf696a3..3324753 100644
+--- sc/source/ui/vba/vbaworksheet.hxx
++++ sc/source/ui/vba/vbaworksheet.hxx
+@@ -82,6 +82,9 @@ public:
+     { return mxSheet; }
+ 
+     // Attributes
++    virtual ::sal_Bool SAL_CALL getAutoFilterMode() throw (::com::sun::star::uno::RuntimeException);
++    virtual void SAL_CALL setAutoFilterMode( ::sal_Bool _autofiltermode ) throw (::com::sun::star::uno::RuntimeException);
++
+     virtual ::rtl::OUString SAL_CALL getName() throw (css::uno::RuntimeException);
+     virtual void SAL_CALL setName( const ::rtl::OUString &rName ) throw (css::uno::RuntimeException);
+     virtual sal_Bool SAL_CALL getVisible() throw (css::uno::RuntimeException);
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-control-api-vis-fix.diff ooo-build-3.1.1.5/patches/vba/vba-control-api-vis-fix.diff
--- ooo-build-3.1.1.4/patches/vba/vba-control-api-vis-fix.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-control-api-vis-fix.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,26 @@
+diff --git vbahelper/source/msforms/vbacontrol.cxx vbahelper/source/msforms/vbacontrol.cxx
+index 0989548..f51cf56 100644
+--- vbahelper/source/msforms/vbacontrol.cxx
++++ vbahelper/source/msforms/vbacontrol.cxx
+@@ -189,14 +189,17 @@ void SAL_CALL ScVbaControl::setEnabled( sal_Bool bVisible ) throw (uno::RuntimeE
+ 
+ sal_Bool SAL_CALL ScVbaControl::getVisible() throw (uno::RuntimeException)
+ {
+-    uno::Reference< awt::XWindow2 > xWindow2( getWindowPeer(), uno::UNO_QUERY_THROW );
+-    return xWindow2->isVisible();
++    sal_Bool bVisible( sal_True );
++    m_xProps->getPropertyValue
++            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EnableVisible" ) )) >>= bVisible;
++    return bVisible;
+ }
+ 
+ void SAL_CALL ScVbaControl::setVisible( sal_Bool bVisible ) throw (uno::RuntimeException)
+ {
+-    uno::Reference< awt::XWindow2 > xWindow2( getWindowPeer(), uno::UNO_QUERY_THROW );
+-    xWindow2->setVisible( bVisible );
++    uno::Any aValue( bVisible );
++    m_xProps->setPropertyValue
++            (rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "EnableVisible" ) ), aValue);
+ }
+ double SAL_CALL ScVbaControl::getHeight() throw (uno::RuntimeException)
+ {
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-fix-find-wraparound-onfail.diff ooo-build-3.1.1.5/patches/vba/vba-fix-find-wraparound-onfail.diff
--- ooo-build-3.1.1.4/patches/vba/vba-fix-find-wraparound-onfail.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-fix-find-wraparound-onfail.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,18 @@
+diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
+index f327fed..735f913 100644
+--- sc/source/ui/vba/vbarange.cxx
++++ sc/source/ui/vba/vbarange.cxx
+@@ -2953,6 +2953,13 @@ ScVbaRange::Find( const uno::Any& What, const uno::Any& After, const uno::Any& L
+         uno::Reference< util::XSearchDescriptor > xSearchDescriptor( xDescriptor, uno::UNO_QUERY );
+         uno::Reference< uno::XInterface > xInterface = xStartCell.is() ? xSearch->findNext( xStartCell, xSearchDescriptor) : xSearch->findFirst( xSearchDescriptor );
+         uno::Reference< table::XCellRange > xCellRange( xInterface, uno::UNO_QUERY );
++        // if we are searching from a starting cell and failed to find a match 
++        // then try from the begining
++        if ( !xCellRange.is() && xStartCell.is() )
++        { 
++            xInterface = xSearch->findFirst( xSearchDescriptor );
++            xCellRange.set( xInterface, uno::UNO_QUERY ); 
++        }
+         if ( xCellRange.is() )
+         {
+             uno::Reference< excel::XRange > xResultRange = new ScVbaRange( this, mxContext, xCellRange );
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-fix-isempty.diff ooo-build-3.1.1.5/patches/vba/vba-fix-isempty.diff
--- ooo-build-3.1.1.4/patches/vba/vba-fix-isempty.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-fix-isempty.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,34 @@
+diff --git basic/source/classes/sbunoobj.cxx basic/source/classes/sbunoobj.cxx
+index b02dca2..6abb00c 100644
+--- basic/source/classes/sbunoobj.cxx
++++ basic/source/classes/sbunoobj.cxx
+@@ -139,16 +139,19 @@ bool SbUnoObject::getDefaultPropName( SbUnoObject* pUnoObj, String& sDfltProp )
+ SbxVariable* getDefaultProp( SbxVariable* pRef )
+ {
+ 	SbxVariable* pDefaultProp = NULL;
+-	SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
+-	if ( !pObj )
++	if ( pRef->GetType() == SbxOBJECT )
+ 	{
+-		SbxBase* pObjVarObj = pRef->GetObject();
+-		pObj = PTR_CAST(SbxObject,pObjVarObj);
+-	}
+-	if ( pObj && pObj->ISA(SbUnoObject) )
+-	{
+-		SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);
+-		pDefaultProp = pUnoObj->GetDfltProperty();
++  		SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
++		if ( !pObj )
++		{
++			SbxBase* pObjVarObj = pRef->GetObject();
++			pObj = PTR_CAST(SbxObject,pObjVarObj);
++		}
++		if ( pObj && pObj->ISA(SbUnoObject) )
++		{
++			SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);
++			pDefaultProp = pUnoObj->GetDfltProperty();
++		}
+ 	}
+ 	return pDefaultProp;
+ }
+
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-fix-override-exportproblem.diff ooo-build-3.1.1.5/patches/vba/vba-fix-override-exportproblem.diff
--- ooo-build-3.1.1.4/patches/vba/vba-fix-override-exportproblem.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-fix-override-exportproblem.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,71 @@
+diff --git sc/source/filter/excel/xiescher.cxx sc/source/filter/excel/xiescher.cxx
+index 5eb246e..7a36a07 100644
+--- sc/source/filter/excel/xiescher.cxx
++++ sc/source/filter/excel/xiescher.cxx
+@@ -401,16 +401,11 @@ void XclImpDrawObjBase::SetAnchor( const XclObjAnchor& rAnchor )
+ 
+ String XclImpDrawObjBase::GetObjName() const
+ {
+-    String sName( GetObjectManager().GetOleNameOverride( GetObjId() ) );
+-  
+-    
+     /*  #118053# #i51348# Always return a non-empty name. Create English
+         default names depending on the object type. This is not implemented as
+         virtual functions in derived classes, as class type and object type may
+         not match. */
+-    if ( sName.Len() == 0 )
+-        sName = ( (maObjName.Len() > 0) ? maObjName : GetObjectManager().GetDefaultObjName( *this ) );
+-    return sName;
++    return (maObjName.Len() > 0) ? maObjName : GetObjectManager().GetDefaultObjName( *this );
+ }
+ 
+ bool XclImpDrawObjBase::IsValidSize( const Rectangle& rAnchorRect ) const
+@@ -2788,6 +2783,17 @@ SdrObject* XclImpPictureObj::DoCreateSdrObj( const Rectangle& rAnchorRect, ScfPr
+     return xSdrObj.release();
+ }
+ 
++String XclImpPictureObj::GetObjName() const
++{
++    if( IsOcxControl() )
++    {
++        String sName( GetObjectManager().GetOleNameOverride( GetObjId() ) );
++        if ( sName.Len() > 0 )
++            return sName;
++    }
++    return XclImpDrawObjBase::GetObjName();
++}
++
+ void XclImpPictureObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
+ {
+     if( IsOcxControl() )
+diff --git sc/source/filter/inc/xiescher.hxx sc/source/filter/inc/xiescher.hxx
+index a673a5e..a9eca6e 100644
+--- sc/source/filter/inc/xiescher.hxx
++++ sc/source/filter/inc/xiescher.hxx
+@@ -95,7 +95,7 @@ public:
+     /** Returns the Excel object type from OBJ record. */
+     inline sal_uInt16   GetObjType() const { return mnObjType; }
+     /** Returns the name of this object, may generate a default name. */
+-    String              GetObjName() const;
++    virtual String              GetObjName() const;
+     /** Returns associated macro name, if set, otherwise zero length string. */
+     inline const String& GetMacroName() const { return maMacroName; }
+ 
+@@ -860,7 +860,8 @@ class XclImpPictureObj : public XclImpRectObj, public XclImpControlHelper
+ {
+ public:
+     explicit            XclImpPictureObj( const XclImpRoot& rRoot );
+-
++    /** Returns the ObjectName - can use non-obvious lookup for override in the associated vba document module stream**/
++    virtual String              GetObjName() const;
+     /** Returns the graphic imported from the IMGDATA record. */
+     inline const Graphic& GetGraphic() const { return maGraphic; }
+     /** Returns the visible area of the imported graphic. */
+@@ -891,7 +892,6 @@ protected:
+     virtual SdrObject*  DoCreateSdrObj( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const;
+     /** Overloaded to do additional processing on the SdrObject. */
+     virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+-
+ private:
+     /** Reads and sets the picture flags from a BIFF3-BIFF5 OBJ picture record. */
+     void                ReadFlags3( XclImpStream& rStrm );
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-fix-selection-dot-inproject.diff ooo-build-3.1.1.5/patches/vba/vba-fix-selection-dot-inproject.diff
--- ooo-build-3.1.1.4/patches/vba/vba-fix-selection-dot-inproject.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-fix-selection-dot-inproject.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,176 @@
+diff --git basic/source/runtime/stdobj.cxx basic/source/runtime/stdobj.cxx
+index 38ba7cd..4c8c807 100644
+--- basic/source/runtime/stdobj.cxx
++++ basic/source/runtime/stdobj.cxx
+@@ -73,6 +73,45 @@ struct Methods {
+     USHORT		nHash;		// Hashcode
+ };
+ 
++struct StringHashCode
++{
++    size_t operator()( const String& rStr ) const
++    {
++        return rtl_ustr_hashCode_WithLength( rStr.GetBuffer(), rStr.Len() );
++    }
++};
++
++class VBABlacklist
++{
++friend class VBABlackListQuery;
++    std::hash_map< String, bool, StringHashCode > mBlackList;
++    VBABlacklist()
++    {
++        const char* list[] = { "Red" };
++        sal_Int32 nSize = sizeof( list ) / sizeof( list[ 0 ] );
++        for ( sal_Int32 index = 0; index < nSize; ++index )
++        {
++            mBlackList[ String::CreateFromAscii( list[ index ] ).ToLowerAscii() ] = true;
++        }
++    } 
++public:
++    bool isBlackListed( const String& sName )
++    {
++        String sNameLower( sName );
++        sNameLower.ToLowerAscii();
++        return ( mBlackList.find( sNameLower ) != mBlackList.end() );
++    }
++};
++
++class VBABlackListQuery
++{
++public:
++    static bool isBlackListed( const String& sName )
++    {
++        static VBABlacklist blackList;
++        return blackList.isBlackListed( sName );
++    }
++};
+ static Methods aMethods[] = {
+ 
+ { "AboutStarBasic", SbxNULL,      1 | _FUNCTION, RTLNAME(AboutStarBasic),0  },
+@@ -759,13 +798,15 @@ SbxVariable* SbiStdObject::Find( const String& rName, SbxClassType t )
+              && ( p->nHash == nHash_ )
+              && ( rName.EqualsIgnoreCaseAscii( p->pName ) ) )
+             {
++                SbiInstance* pInst = pINST;
+                 bFound = TRUE;
+                 if( p->nArgs & _COMPTMASK )
+                 {
+-                    SbiInstance* pInst = pINST;
+                     if( !pInst || !pInst->IsCompatibility() )
+                         bFound = FALSE;
+                 }
++                if ( pInst && pInst->IsCompatibility() && VBABlackListQuery::isBlackListed( rName ) )
++                            bFound = FALSE;
+                 break;
+             }
+             nIndex += ( p->nArgs & _ARGSMASK ) + 1;
+diff --git sc/source/ui/vba/vbarange.cxx sc/source/ui/vba/vbarange.cxx
+index d09c699..7ba906e 100644
+--- sc/source/ui/vba/vbarange.cxx
++++ sc/source/ui/vba/vbarange.cxx
+@@ -2555,8 +2555,6 @@ ScVbaRange::PasteSpecial( const uno::Any& Paste, const uno::Any& Operation, cons
+   
+         uno::Reference< frame::XModel > xModel( ( pShell ? pShell->GetModel() : NULL ), uno::UNO_QUERY_THROW );
+ 	uno::Reference< view::XSelectionSupplier > xSelection( xModel->getCurrentController(), uno::UNO_QUERY_THROW );
+-    // save old selection
+-	uno::Reference< uno::XInterface > xSel( xModel->getCurrentSelection() );
+     // select this range
+     xSelection->select( uno::makeAny( mxRange ) );
+     // set up defaults	
+@@ -2577,8 +2575,6 @@ ScVbaRange::PasteSpecial( const uno::Any& Paste, const uno::Any& Operation, cons
+     USHORT nFlags = getPasteFlags(nPaste);
+     USHORT nFormulaBits = getPasteFormulaBits(nOperation);
+ 	excel::implnPasteSpecial(pShell->GetModel(), nFlags,nFormulaBits,bSkipBlanks,bTranspose);
+-    // restore selection
+-    xSelection->select( uno::makeAny( xSel ) );
+ }
+ 
+ uno::Reference< excel::XRange > 
+diff --git scripting/source/basprov/basprov.cxx scripting/source/basprov/basprov.cxx
+index 562e605..562a8e5 100644
+--- scripting/source/basprov/basprov.cxx
++++ scripting/source/basprov/basprov.cxx
+@@ -374,7 +374,33 @@ namespace basprov
+             ::rtl::OUString::createFromAscii( "location" ) );
+ 
+         sal_Int32 nIndex = 0;
+-        ::rtl::OUString aLibrary = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
++        // In some strange circumstances the Library name can have an 
++        // apparantly illegal '.' in it ( in imported VBA )
++     
++        BasicManager* pBasicMgr =  NULL;
++        if ( aLocation.equals( ::rtl::OUString::createFromAscii("document") ) )
++        {
++            pBasicMgr = m_pDocBasicManager;
++        }
++        else if ( aLocation.equals( ::rtl::OUString::createFromAscii("application") ) )
++        {
++            pBasicMgr = m_pAppBasicManager;
++        }
++        rtl::OUString sProjectName;
++        if (  pBasicMgr )
++            sProjectName = pBasicMgr->GetName();
++
++        ::rtl::OUString aLibrary;
++        if ( sProjectName.getLength() && aDescription.match( sProjectName ) )
++        {
++            OSL_TRACE("LibraryName %s is part of the url %s",
++                rtl::OUStringToOString( sProjectName, RTL_TEXTENCODING_UTF8 ).getStr(),
++                rtl::OUStringToOString( aDescription, RTL_TEXTENCODING_UTF8 ).getStr() );
++            aLibrary = sProjectName;            
++            nIndex = sProjectName.getLength() + 1;
++        }
++        else
++            aLibrary = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
+         ::rtl::OUString aModule;
+         if ( nIndex != -1 )
+             aModule = aDescription.getToken( 0, (sal_Unicode)'.', nIndex );
+@@ -384,15 +410,6 @@ namespace basprov
+ 
+         if ( aLibrary.getLength() != 0 && aModule.getLength() != 0 && aMethod.getLength() != 0 && aLocation.getLength() != 0 )
+         {
+-            BasicManager* pBasicMgr =  NULL;
+-            if ( aLocation.equals( ::rtl::OUString::createFromAscii("document") ) )
+-            {
+-                pBasicMgr = m_pDocBasicManager;
+-            }
+-            else if ( aLocation.equals( ::rtl::OUString::createFromAscii("application") ) )
+-            {
+-                pBasicMgr = m_pAppBasicManager;
+-            }
+ 
+             if ( pBasicMgr )
+             {
+diff --git svx/source/msfilter/msvbahelper.cxx svx/source/msfilter/msvbahelper.cxx
+index d02746f..cf66309 100644
+--- svx/source/msfilter/msvbahelper.cxx
++++ svx/source/msfilter/msvbahelper.cxx
+@@ -98,7 +98,17 @@ SfxObjectShell* findShellForUrl( const rtl::OUString& sMacroURLOrPath )
+             }
+             else
+             {
+-                if ( aURL.equals( xModel->getURL() ) )
++                // sometimes just the name of the document ( without the path
++                // is used
++                bool bDocNameNoPathMatch = false;
++                if ( aURL.getLength() && aURL.indexOf( '/' ) == -1 )
++                {
++                    sal_Int32 lastSlashIndex = xModel->getURL().lastIndexOf( '/' );
++                    if ( lastSlashIndex > -1 )
++                        bDocNameNoPathMatch = xModel->getURL().copy( lastSlashIndex + 1 ).equals( aURL );
++                } 
++                             
++                if ( aURL.equals( xModel->getURL() ) || bDocNameNoPathMatch )
+                 {
+                     pFoundShell = pShell; 
+                     break;
+@@ -207,7 +217,7 @@ VBAMacroResolvedInfo resolveVBAMacro( SfxObjectShell* pShell, const rtl::OUStrin
+         OSL_TRACE("doc search, current shell is 0x%x", pShell );
+         SfxObjectShell* pFoundShell = findShellForUrl( sDocUrlOrPath );
+         OSL_TRACE("doc search, after find, found shell is 0x%x", pFoundShell );
+-        aRes = resolveVBAMacro( pFoundShell, sMacroUrl ); 
++        return resolveVBAMacro( pFoundShell, sMacroUrl ); 
+     }    
+     else
+     {
diff -Nur ooo-build-3.1.1.4/patches/vba/vba-fix-wsfunction-booleanparam.diff ooo-build-3.1.1.5/patches/vba/vba-fix-wsfunction-booleanparam.diff
--- ooo-build-3.1.1.4/patches/vba/vba-fix-wsfunction-booleanparam.diff	1970-01-01 02:00:00.000000000 +0200
+++ ooo-build-3.1.1.5/patches/vba/vba-fix-wsfunction-booleanparam.diff	2009-11-23 16:47:56.000000000 +0200
@@ -0,0 +1,22 @@
+diff --git sc/source/ui/vba/vbawsfunction.cxx sc/source/ui/vba/vbawsfunction.cxx
+index d0e7ee3..ed3a749 100644
+--- sc/source/ui/vba/vbawsfunction.cxx
++++ sc/source/ui/vba/vbawsfunction.cxx
+@@ -81,6 +81,16 @@ ScVbaWSFunction::invoke(const rtl::OUString& FunctionName, const uno::Sequence<
+ 			aArrayTemp[i] = myRange->getCellRange();
+ 			continue;
+ 		}
++                else if (  aArray[ i ].getValueType().getTypeClass() == uno::TypeClass_BOOLEAN )
++		{
++			sal_Bool bValue( sal_False );
++			aArray[ i ] >>= bValue;
++			if ( bValue )
++				aArrayTemp[ i ] <<= double( 1.0 ); 
++			else
++				aArrayTemp[ i ] <<= double( 0.0 ); 
++                        
++		}
+         else if ( aArray[ i ].getValueType().getTypeClass() == uno::TypeClass_SEQUENCE )
+         {
+             // the sheet.FunctionAccess service doesn't deal with Sequences, only Sequences of Sequence
+
