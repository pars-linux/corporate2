diff -uNr hdparm-9.27-with-wiper_2.3/Changelog hdparm-9.27-with-wiper_2.5/Changelog
--- hdparm-9.27-with-wiper_2.3/Changelog	2009-09-01 17:19:27.000000000 +0300
+++ hdparm-9.27-with-wiper_2.5/Changelog	2009-10-02 16:16:59.000000000 +0300
@@ -1,4 +1,5 @@
 hdparm-9.27
+	- repackaged again with wiper-2.5
 	- wiper.sh updated to wiper-2.3
 	- fix definition of reg_flags in sgio.h to work with old IDE drivers again
 hdparm-9.26
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.3/fiemap_compat_ioctl.patch hdparm-9.27-with-wiper_2.5/wiper-2.3/fiemap_compat_ioctl.patch
--- hdparm-9.27-with-wiper_2.3/wiper-2.3/fiemap_compat_ioctl.patch	2009-08-01 18:19:56.000000000 +0300
+++ hdparm-9.27-with-wiper_2.5/wiper-2.3/fiemap_compat_ioctl.patch	1970-01-01 02:00:00.000000000 +0200
@@ -1,42 +0,0 @@
-Add support for the FIEMAP ioctl for 32-bit user on 64-bit kernel.
-
-When using a 32-bit runtime on top of a 64-bit kernel,
-programs like "filefrag" and "hdparm --fibmap" do not work correctly.
-
-This is because there's no compat ioctl entry for the FIEMAP call.
-FIEMAP returns file extent info, similar to FIBMAP (but better).
-
-Since FIBMAP itself is b0rked on ext4, this leaves no way for a 32-bit
-program to reliably get detailed block information for a file
-when run on top of a 64-bit kernel.  This patch addresses the issue.
-
-Once upstream, this patch could also be a candidate for -stable.
-
-Signed-off-by: Mark Lord <mlord@pobox.com> 
-
---- old/fs/compat_ioctl.c	2009-08-01 10:47:16.601066905 -0400
-+++ linux/fs/compat_ioctl.c	2009-08-01 10:49:23.054387926 -0400
-@@ -35,6 +35,7 @@
- #include <linux/falloc.h>
- #include <linux/fs.h>
- #include <linux/file.h>
-+#include <linux/fiemap.h>
- #include <linux/ppp_defs.h>
- #include <linux/if_ppp.h>
- #include <linux/if_pppox.h>
-@@ -1907,6 +1908,7 @@
- COMPATIBLE_IOCTL(FIONREAD)  /* This is also TIOCINQ */
- /* 0x00 */
- COMPATIBLE_IOCTL(FIBMAP)
-+COMPATIBLE_IOCTL(FS_IOC_FIEMAP)
- COMPATIBLE_IOCTL(FIGETBSZ)
- /* 'X' - originally XFS but some now in the VFS */
- COMPATIBLE_IOCTL(FIFREEZE)
-@@ -2805,6 +2807,7 @@
- 		goto out_fput;
- #endif
- 
-+	case FS_IOC_FIEMAP:
- 	case FIBMAP:
- 	case FIGETBSZ:
- 	case FIONREAD:
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.3/GPLv2.txt hdparm-9.27-with-wiper_2.5/wiper-2.3/GPLv2.txt
--- hdparm-9.27-with-wiper_2.3/wiper-2.3/GPLv2.txt	2009-07-30 00:58:31.000000000 +0300
+++ hdparm-9.27-with-wiper_2.5/wiper-2.3/GPLv2.txt	1970-01-01 02:00:00.000000000 +0200
@@ -1,341 +0,0 @@
-
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.3/README.txt hdparm-9.27-with-wiper_2.5/wiper-2.3/README.txt
--- hdparm-9.27-with-wiper_2.3/wiper-2.3/README.txt	2009-08-18 16:50:08.000000000 +0300
+++ hdparm-9.27-with-wiper_2.5/wiper-2.3/README.txt	1970-01-01 02:00:00.000000000 +0200
@@ -1,89 +0,0 @@
-TRIM / wiper script for SATA SSDs   (August 2009)
-=================================================
-
-The wiper.sh script is for tuning up SATA SSDs (Solid-State-Drives).
-
-It calculates a list of free (unallocated) blocks within a filesystem,
-and informs the SSD firmware of those blocks, so that it can better manage
-the underlying media for wear-leveling and garbage-collection purposes.
-
-In some cases, this can restore a sluggish SSD to nearly-new speeds again.
-
-This script may be EXTREMELY HAZARDOUS TO YOUR DATA.
-
-It does work for me here, but it has not yet been exhaustively tested by others.
-
-Please back-up your data to a *different* physical drive before trying it.
-And if you are at all worried, then DO NOT USE THIS SCRIPT!!
-
-Once there are drives in the marketplace with production firmware that supports
-the SATA DSM TRIM command, then this will get tested a bit more over time.
-As that happens, it will be moved out of this directory and installed alongside
-the hdparm executable, probably under /sbin or /usr/sbin.
-
-Until then, DO NOT USE THIS SCRIPT if you cannot afford losing your data!!
-
-
-This script works for read-write mounted ext4 and xfs filesystems,
-and for read-only mounted/unmounted ext2, ext3, ext4 and xfs filesystems.
-
-Invoke the script with the pathname to the mounted filesystem
-or the block device path for the filesystem.
-
-	Eg.	./wiper.sh /boot
-		./wiper.sh /
-		./wiper.sh /dev/sda1
-
-Note that the most comprehensive results are achieved when
-wiping a filesystem that is not currently mounted read-write,
-though the difference is small.
-
-==================================================
-
-btrfs -- DO NOT USE !!!
-
-Due to end-user demand, this script can also now TRIM some mounted btrfs filesystems.
-
-But btrfs breaks the Linux filesystem model in many ways, making it rather dangerous
-to your data to try and TRIM it.  It implements it's own internal multiple-device
-layer, similar to DM/MD/VFS, but without any indication to external utilities like wiper.sh.
-As a result, detection of the underlying device for the filesystem is haphazard at best,
-and this could cause wiper.sh to destroy data on whatever device it thinks is the correct one.
-
-Also, because of the built-in duplication of multiple-device support, the FIBMAP and FIEMAP
-ioctl()s will work incorrectly on btrfs when more than a single device is involved.
-This means that btrfs will mislead the wiper.sh script, causing it to TRIM the WRONG sectors,
-destroying valuable data, programs, and filesystem metadata.  You will lose everything.
-
-Currently, it is mostly (but not completely) safe to run wiper.sh on a mounted btrfs
-filesystem which is comprised of a single underlying device partition.  This usually works
-without trouble.  But btrfs provides no means to detect this case, so wiper.sh is unable
-to safeguard against corruption in the cases where more than one device partition is used.
-
-btrfs is an experimental beta with serious issues; use ext4 or xfs instead.
-
-==================================================
-
-The sil24_trim_protocol_fix.patch file in this directory is a kernel
-patch for all recent Linux kernel versions up to and including 2.6.31.
-
-This fixes the kernel device driver for the Silicon Image SiI-3132
-SATA controller to correctly pass DSM/TRIM commands to the drives.
-
-If you use this hardware in your system, then you will need to apply
-the patch to your kernel before using the wiper scripts.
-
-==================================================
-
-The fiemap_compat_ioctl.patch file in this directory is a kernel patch
-to speed up "hdparm --fibmap" when run as a 32-bit program on top of
-a 64-bit Linux kernel.  Kernels versions up to and including 2.6.31
-are missing support for this, so hdparm will fall back to the older
-and slower FIBMAP call, causing wiper.sh to take much longer to run.
-The older call has other limitations, such as failing on really large
-files or huge disks, so use of FIEMAP really is preferred.
-
-As of August 16, a similar patch has now been backported to the -stable
-streams of most recent Linux kernel versions.  So update your kernel
-and this functionality will already be included.
-
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.3/sil24_trim_protocol_fix.patch hdparm-9.27-with-wiper_2.5/wiper-2.3/sil24_trim_protocol_fix.patch
--- hdparm-9.27-with-wiper_2.3/wiper-2.3/sil24_trim_protocol_fix.patch	2009-07-30 23:19:41.000000000 +0300
+++ hdparm-9.27-with-wiper_2.5/wiper-2.3/sil24_trim_protocol_fix.patch	1970-01-01 02:00:00.000000000 +0200
@@ -1,36 +0,0 @@
-The sil24 hardware has a built-in list of commands and associated protocols
-that gets used by default to decide how to handle a given command. However,
-if the command is not known to the controller then it presumably assumes it to
-be a non-data command which then causes protocol mismatch errors if the device
-ends up requesting data transfer. The new DATA SET MANAGEMENT - Trim command
-causes this issue since it's a DMA data-out command.
-
-Since we should always know best what protocol the command should be using,
-let's just set the override flag to inform the controller what protocol to use
-for all non-ATAPI commands with data transfer.
-
-Signed-off-by: Robert Hancock <hancockrwd@gmail.com>
-Tested-by: Mark Lord <liml@rtr.ca>
-
-diff --git a/drivers/ata/sata_sil24.c b/drivers/ata/sata_sil24.c
-index 77aa8d7..e6946fc 100644
---- a/drivers/ata/sata_sil24.c
-+++ b/drivers/ata/sata_sil24.c
-@@ -846,6 +846,17 @@ static void sil24_qc_prep(struct ata_queued_cmd *qc)
- 	if (!ata_is_atapi(qc->tf.protocol)) {
- 		prb = &cb->ata.prb;
- 		sge = cb->ata.sge;
-+		if (ata_is_data(qc->tf.protocol)) {
-+			u16 prot = 0;
-+			ctrl = PRB_CTRL_PROTOCOL;
-+			if (ata_is_ncq(qc->tf.protocol))
-+				prot |= PRB_PROT_NCQ;
-+			if (qc->tf.flags & ATA_TFLAG_WRITE)
-+				prot |= PRB_PROT_WRITE;
-+			else
-+				prot |= PRB_PROT_READ;
-+			prb->prot = cpu_to_le16(prot);
-+		}
- 	} else {
- 		prb = &cb->atapi.prb;
- 		sge = cb->atapi.sge;
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.3/wiper.sh hdparm-9.27-with-wiper_2.5/wiper-2.3/wiper.sh
--- hdparm-9.27-with-wiper_2.3/wiper-2.3/wiper.sh	2009-09-01 16:56:47.000000000 +0300
+++ hdparm-9.27-with-wiper_2.5/wiper-2.3/wiper.sh	1970-01-01 02:00:00.000000000 +0200
@@ -1,663 +0,0 @@
-#!/bin/bash
-#
-# SATA SSD free-space TRIM utility, by Mark Lord
-
-VERSION=2.3
- 
-# Copyright (C) 2009 Mark Lord.  All rights reserved.
-#
-# Requires gawk, a really-recent hdparm, and various other programs.
-# This needs to be redone entirely in C, for 64-bit math, someday.
-# 
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License Version 2,
-# as published by the Free Software Foundation.
-# 
-# This program is distributed in the hope that it would be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software Foundation,
-# Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-export LANG=C
-
-## Find a required program, and give a nicer error message than we'd otherwise see:
-##
-function find_prog(){
-	prog="$1"
-	if [ ! -x "$prog" ]; then
-		prog="${prog##*/}"
-		p=`type -f -P "$prog" 2>/dev/null`
-		if [ "$p" = "" ]; then
-			echo "$1: needed but not found, aborting." >&2
-			exit 1
-		fi
-		prog="$p"
-		echo "  --> using $prog instead of $1" >&2
-	fi
-	echo "$prog"
-}
-
-echo
-echo "${0##*/}: Linux SATA SSD TRIM utility, version $VERSION, by Mark Lord."
-
-## Ensure we have most of the necessary utilities available before trying to proceed:
-##
-hash -r  ## Refresh bash's cached PATH entries
-HDPARM=`find_prog /sbin/hdparm`	|| exit 1
-FIND=`find_prog /usr/bin/find`	|| exit 1
-STAT=`find_prog /usr/bin/stat`	|| exit 1
-GAWK=`find_prog /usr/bin/gawk`	|| exit 1
-BLKID=`find_prog /sbin/blkid`	|| exit 1
-GREP=`find_prog /bin/grep`	|| exit 1
-ID=`find_prog /usr/bin/id`	|| exit 1
-LS=`find_prog /bin/ls`		|| exit 1
-DF=`find_prog /bin/df`		|| exit 1
-RM=`find_prog /bin/rm`		|| exit 1
-
-## I suppose this will confuse the three SELinux users out there:
-##
-if [ `$ID -u` -ne 0 ]; then
-	echo "Only the super-user can use this (try \"sudo $0\" instead), aborting." >&2
-	exit 1
-fi
-
-## We need a very modern hdparm, for its --fallocate and --trim-sector-ranges-stdin flags:
-## Version 9.25 added automatic determination of safe max-size of TRIM commands.
-##
-HDPVER=`$HDPARM -V | $GAWK '{gsub("[^0-9.]","",$2); if ($2 > 0) print ($2 * 100); else print 0; exit(0)}'`
-if [ $HDPVER -lt 925 ]; then
-	echo "$HDPARM: version >= 9.25 is required, aborting." >&2
-	exit 1
-fi
-
-## Convert relative path "$1" into an absolute pathname, resolving all symlinks:
-##
-function get_realpath(){
-	iter=0
-	p="$1"
-	while [ -e "$p" -a $iter -lt 100 ]; do
-		## Strip trailing slashes:
-		while [ "$p" != "/" -a "$p" != "${p%%/}" ]; do
-			p="${p%%/}"
-		done
-		## Split into directory:leaf portions:
-		d="${p%/*}"
-		t="${p##*/}"
-		## If the split worked, then cd into the directory portion:
-		if [ "$d" != "" -a "$d" != "$p" ]; then
-			cd -P "$d" || exit
-			p="$t"
-		fi
-		## If what we have left is a directory, then cd to it and print realpath:
-		if [ -d "$p" ]; then
-			cd -P "$p" || exit
-			pwd -P
-			exit
-		## Otherwise if it is a symlink, read the link and loop again:
-		elif [ -h "$p" ]; then
-			p="`$LS -ld "$p" | awk '{sub("^[^>]*-[>] *",""); print}'`"
-		## Otherwise, prefix $p with the cwd path and print it:
-		elif [ -e "$p" ]; then
-			[ "${p:0:1}" = "/" ] || p="`pwd -P`/$p"
-			echo "$p"
-			exit
-		fi
-		iter=$((iter + 1))
-	done
-}
-
-## The usual terse usage information:
-##
-function usage_error(){
-	echo >&2
-	echo "Linux tune-up (TRIM) utility for SATA SSDs"
-	echo "Usage:  $0 [--verbose] [--commit] <mount_point|block_device>" >&2
-	echo "   Eg:  $0 /dev/sda1" >&2
-	echo >&2
-	exit 1
-}
-
-## Parameter parsing for the main script.
-## Yeah, we could use getopt here instead, but what fun would that be?
-##
-verbose=0
-commit=""
-argc=$#
-arg=""
-while [ $argc -gt 0 ]; do
-	if [ "$1" = "--commit" ]; then
-		commit=yes
-	elif [ "$1" = "--verbose" ]; then
-		verbose=1
-	elif [ "$1" = "" ]; then
-		usage_error
-	else
-		if [ "$arg" != "" ]; then
-			echo "$1: too many arguments, aborting." >&2
-			exit 1
-		fi
-		arg="$1"
-	fi
-	argc=$((argc - 1))
-	shift
-done
-[ "$arg" = "" ] && usage_error
-
-function get_devpath(){
-	dir="$1"
-	kdev=`$STAT --format="%04D" "$dir" 2>/dev/null`
-	[ "$kdev" = "" ] && exit 1
-	major=$((0x${kdev:0:2}))
-	minor=$((0x${kdev:2:2}))
-	$FIND /dev -xdev -type b -exec $LS -ln {} \; | $GAWK -v major="$major," -v minor="$minor" \
-		'($5 == major && $6 == minor){r=$NF}END{print r}'
-}
-
-## Convert "$arg" into an absolute pathname target, with no symlinks or embedded blanks:
-target="`get_realpath "$arg"`"
-if [ "$target" = "" ]; then
-	[ "$arg" = "/dev/root" ] && target="`get_devpath /`"
-	if [ "$target" = "" ]; then
-		echo "$arg: unable to determine full pathname, aborting." >&2
-		exit 1
-	fi
-fi
-if [ "$target" != "${target##* }" ]; then
-	echo "\"$target\": pathname has embedded blanks, aborting." >&2
-	exit 1
-fi
-
-## Take a first cut at online/offline determination, based on the target:
-##
-if [ -d "$target" ]; then
-	method=online
-elif [ -b "$target" ]; then
-	method=offline
-else
-	echo "$target: not a block device or mount point, aborting." >&2
-	exit 1
-fi
-
-## Find the active mount-point (fsdir) associated with a device ($1: fsdev).
-## This is complicated, and probably still buggy, because a single
-## device can show up under *multiple* mount points in /proc/mounts.
-##
-function get_fsdir(){
-	rw=""
-	r=""
-	while read -a m ; do
-		pdev="${m[0]}"
-		[ "$pdev" = "$1" ] || pdev="`get_realpath "$pdev"`"
-		if [ "$pdev" = "$1" ]; then
-			if [ "$rw" != "rw" ]; then
-				rw="${m[3]:0:2}"
-				r="${m[1]}"
-			fi
-		fi
-		#echo "$pdev ${m[1]} ${m[2]} ${m[3]}"
-	done
-	echo -n "$r"
-}
-
-## Find the device (fsdev) associated with a mount point ($1: fsdir).
-## Since mounts can be stacked on top of each other, we return the
-## one from the last occurance in the list from /proc/mounts.
-##
-function get_fsdev(){   ## from fsdir
-	get_realpath "`$GAWK -v p="$1" '{if ($2 == p) r=$1} END{print r}' < /proc/mounts`"
-}
-
-## Find the r/w or r/o status (fsmode) of a filesystem mount point  ($1: fsdir)
-## We get it from the last occurance of the mount point in the list from /proc/mounts,
-## and convert it to a longer human-readable string.
-##
-function get_fsmode(){  ## from fsdir
-	mode="`$GAWK -v p="$1" '{if ($2 == p) r=substr($4,1,2)} END{print r}' < /proc/mounts`"
-	if [ "$mode" = "ro" ]; then
-		echo "read-only"
-	elif [ "$mode" = "rw" ]; then
-		echo "read-write"
-	else
-		echo "$fsdir: unable to determine mount status, aborting." >&2
-		exit 1
-	fi
-}
-
-## Use $DF to determine the device name associated with the root filesystem.
-##
-## This *usually* works, but on some distros it just returns "/dev/root",
-## and "/dev/root" does not actually exist.  We leave it like that for now,
-## because that's the pattern such systems also use in /proc/mounts.
-## Later, at time of use, we'll try harder to find the real rootdev.
-##
-rdev="`($DF -P / | $GAWK '/^[/]/{print $1;exit}') 2>/dev/null`"
-rootdev="`get_realpath "$rootdev"`"
-[ "$rootdev" = "" ] && rootdev=$rdev
-[ $verbose -gt 0 ] && echo "rootdev=$rootdev rdev=$rdev"
-
-## The user gave us a directory (mount point) to TRIM,
-## which implies that we will be doing an online TRIM
-## using --fallocate and --fibmap to find the free extents.
-## Do some preliminary correctness/feasibility checks on fsdir:
-##
-if [ "$method" = "online" ]; then
-	## Ensure fsdir exists and is accessible to us:
-	fsdir="$target"
-	cd "$fsdir" || exit 1
-
-	if [ "$fsdir" = "/" ]; then
-		fsdev="$rootdev"
-	else
-		## Figure out what device holds the filesystem.
-		fsdev="`get_fsdev $fsdir`"
-		if [ "$fsdev" = "" ]; then
-			echo "$fsdir: not found in /proc/mounts, aborting." >&2
-			exit 1
-		fi
-	fi
-
-	## The root filesystem may show up as the phoney "/dev/root" device
-	## in /proc/mounts (ugh).  So if we see that, then substitute the rootdev
-	## that $DF gave us earlier.  But $DF may have the same problem (double ugh).
-	##
-	[ ! -e "$fsdev" -a "$fsdev" = "/dev/root" ] && fsdev="$rootdev"
-
-	## Ensure that fsdev exists and is a block device:
-	if [ ! -e "$fsdev" ]; then
-		if [ "$fsdev" != "/dev/root" ]; then
-			echo "$fsdev: not found" >&2
-			exit 1
-		fi
-		rdev="`get_devpath /`"
-		if [ "$rdev" = "" ]; then
-			echo "$fsdev: not found" >&2
-			exit 1
-		fi
-		fsdev="$rdev"
-	fi
-	if [ ! -b "$fsdev" ]; then
-		echo "$fsdev: not a block device" >&2
-		exit 1
-	fi
-
-	## If it is mounted read-only, we must switch to doing an "offline" trim of fsdev:
-	fsmode="`get_fsmode $fsdir`" || exit 1
-	[ $verbose -gt 0 ] && echo "fsmode1: fsmode=$fsmode"
-	[ "$fsmode" = "read-only" ] && method=offline
-fi
-
-## This is not an "else" clause from the above, because "method" may have changed.
-## For offline TRIM, we need the block device, and it cannot be mounted read-write:
-##
-if [ "$method" = "offline" ]; then
-	## We might already have fsdev/fsdir from above; if not, we need to find them.
-	if [ "$fsdev" = "" -o "$fsdir" = "" ]; then
-		fsdev="$target"
-		fsdir="`get_fsdir "$fsdev" < /proc/mounts`"
-		## More weirdness for /dev/root in /proc/mounts:
-		if [ "$fsdir" = "" -a "$fsdev" = "$rootdev" ]; then
-			fsdir="`get_fsdir /dev/root < /proc/mounts`"
-			if [ "$fsdir" = "" ]; then
-				rdev="`get_devpath /`"
-				[ "$rdev" != "" ] && fsdir="`get_fsdir "$rdev" < /proc/mounts`"
-			fi
-		fi
-	fi
-
-	## If the filesystem is truly not-mounted, then fsdir will still be empty here.
-	## It could be mounted, though.  Read-only is fine, but read-write means we need
-	## to switch gears and do an "online" TRIM instead of an "offline" TRIM.
-	##
-	if [ "$fsdir" != "" ]; then
-		fsmode="`get_fsmode $fsdir`" || exit 1
-		[ $verbose -gt 0 ] && echo "fsmode2: fsmode=$fsmode"
-		if [ "$fsmode" = "read-write" ]; then
-			method=online
-			cd "$fsdir" || exit 1
-		fi
-	fi
-fi
-
-## Use $LS to find the major number of a block device:
-##
-function get_major(){
-	$LS -ln "$1" | $GAWK '{print gensub(",","",1,$5)}'
-}
-
-## At this point, we have finalized our selection of online vs. offline,
-## and we definitely know the fsdev, as well as the fsdir (fsdir="" if not-mounted).
-##
-## Now guess at the underlying rawdev name, which could be exactly the same as fsdev.
-## Then determine whether or not rawdev claims support for TRIM commands.
-## Note that some devices lie about support, and later reject the TRIM commands.
-##
-rawdev=`echo $fsdev | $GAWK '{print gensub("[0-9]*$","","g")}'`
-rawdev="`get_realpath "$rawdev"`"
-if [ ! -e "$rawdev" ]; then
-	rawdev=""
-elif [ ! -b "$rawdev" ]; then
-	rawdev=""
-elif [ "`get_major $fsdev`" -ne "`get_major $rawdev`" ]; then  ## sanity check
-	rawdev=""
-elif [ "`get_major $fsdev`" -ne "8" ]; then ## "SCSI" drives only; no LVM confusion for now
-	echo "$rawdev: does not appear to be a SCSI/SATA SSD, aborting." >&2
-	exit 1
-elif ! $HDPARM -I $rawdev | $GREP -i '[ 	][*][ 	]*Data Set Management TRIM supported' &>/dev/null ; then
-	if [ "$commit" = "yes" ]; then
-		echo "$rawdev: DSM/TRIM command not supported, aborting." >&2
-		exit 1
-	fi
-	echo "$rawdev: DSM/TRIM command not supported (continuing with dry-run)." >&2
-fi
-if [ "$rawdev" = "" ]; then
-	echo "$fsdev: unable to reliably determine the underlying physical device name, aborting" >&2
-	exit 1
-fi
-
-## We also need to know the offset of fsdev from the beginning of rawdev,
-## because TRIM requires absolute sector numbers within rawdev:
-##
-fsoffset=`$HDPARM -g "$fsdev" | $GAWK 'END {print $NF}'`
-
-## Next step is to determine what type of filesystem we are dealing with (fstype):
-##
-if [ "$fsdir" = "" ]; then
-	## Not mounted: use $BLKID to determine the fstype of fsdev:
-	fstype=`$BLKID -w /dev/null -c /dev/null $fsdev 2>/dev/null | \
-		 $GAWK '/ TYPE=".*"/{sub("^.* TYPE=\"",""); sub("[\" ][\" ]*.*$",""); print}'`
-	[ $verbose -gt 0 ] && echo "$fsdev: fstype=$fstype"
-else
-	## Mounted: we could just use $BLKID here, too, but it's safer to use /proc/mounts directly:
-	fstype="`$GAWK -v p="$fsdir" '{if ($2 == p) r=$3} END{print r}' < /proc/mounts`"
-	[ $verbose -gt 0 ] && echo "$fsdir: fstype=$fstype"
-fi
-if [ "$fstype" = "" ]; then
-	echo "$fsdev: unable to determine filesystem type, aborting." >&2
-	exit 1
-fi
-
-## Some helper funcs and vars for use with the xfs filesystem tools:
-##
-function xfs_abort(){
-	echo "$fsdev: unable to determine xfs filesystem ${1-parameters}, aborting." >&2
-	exit 1
-}
-function xfs_trimlist(){
-	$XFS_DB -r -c "freesp -d" "$fsdev"  ## couldn't get this to work inline
-}
-xfs_agoffsets=""
-xfs_blksects=0
-
-## Now figure out whether we can actually do TRIM on this type of filesystem:
-##
-if [ "$method" = "online" ]; then
-
-	if [ "$fstype" = "ext2" -o "$fstype" = "ext3" ]; then  ## No --fallocate support
-		echo "$target: cannot TRIM $fstype filesystem when mounted read-write, aborting." >&2
-		exit 1
-	fi
-
-	## Figure out if we have enough free space to even attempt TRIM:
-	##
-	freesize=`$DF -P -B 1024 . | $GAWK '{r=$4}END{print r}'`
-	if [ "$freesize" = "" ]; then
-		echo "$fsdev: unknown to '$DF'"
-		exit 1
-	fi
-	if [ $freesize -lt 15000 ]; then
-		echo "$target: filesystem too full for TRIM, aborting." >&2
-		exit 1
-	fi
-
-	## Figure out how much space to --fallocate (later), keeping in mind
-	## that this is a live filesystem, and we need to leave some space for
-	## other concurrent activities, as well as for filesystem overhead (metadata).
-	## So, reserve at least 1% (35% on btrfs) or 7500 KB, whichever is larger:
-	##
-	reserved=$((freesize / 100))
-	[ "$fstype" = "btrfs" ] && reserved=$((reserved * 35))
-	[ $reserved -lt 7500 ] && reserved=7500
-	[ $verbose -gt 0 ] && echo "freesize = ${freesize} KB, reserved = ${reserved} KB"
-	tmpsize=$((freesize - reserved))
-	tmpfile="WIPER_TMPFILE.$$"
-	get_trimlist="$HDPARM --fibmap $tmpfile"
-else
-	## We can only do offline TRIM on filesystems that we "know" about here.
-	## Currently, this includes the ext2/3/4 family, and xfs.
-	## The first step for any of these is to ensure that the filesystem is "clean",
-	## and immediately abort if it is not.
-	##
-	get_trimlist=""
-	if [ "$fstype" = "ext2" -o "$fstype" = "ext3" -o "$fstype" = "ext4" ]; then
-		DUMPE2FS=`find_prog /sbin/dumpe2fs` || exit 1
-		fstate="`$DUMPE2FS $fsdev 2>/dev/null | $GAWK '/^[Ff]ilesystem state:/{print $NF}' 2>/dev/null`"
-		if [ "$fstate" != "clean" ]; then
-			echo "$target: filesystem not clean, please run \"e2fsck $fsdev\" first, aborting." >&2
-			exit 1
-		fi
-		get_trimlist="$DUMPE2FS $fsdev"
-	elif [ "$fstype" = "xfs" ]; then
-		XFS_DB=`find_prog /sbin/xfs_db` || exit 1
-		XFS_REPAIR=`find_prog /sbin/xfs_repair` || exit 1
-		if ! $XFS_REPAIR -n "$fsdev" &>/dev/null ; then
-			echo "$fsdev: filesystem not clean, please run \"xfs_repair $fsdev\" first, aborting." >&2
-			exit 1
-		fi
-
-		## For xfs, life is more complex than with ext2/3/4 above.
-		## The $XFS_DB tool does not return absolute block numbers for freespace,
-		## but rather gives them as relative to it's allocation groups (ag's).
-		## So, we'll need to interogate it for the offset of each ag within the filesystem.
-		## The agoffsets are extracted from $XFS_DB as sector offsets within the fsdev.
-		##
-		agcount=`$XFS_DB -r -c "sb" -c "print agcount" "$fsdev" | $GAWK '{print 0 + $NF}'`
-		[ "$agcount" = "" -o "$agcount" = "0" ] && xfs_abort "agcount"
-		xfs_agoffsets=
-		i=0
-		while [ $i -lt $agcount ]; do
-			agoffset=`$XFS_DB -r -c "sb" -c "convert agno $i daddr" "$fsdev" \
-				| $GAWK '{print 0 + gensub("[( )]","","g",$2)}'`
-			[ "$agoffset" = "" ] && xfs_abort "agoffset-$i"
-			[ $i -gt 0 ] && [ $agoffset -le ${xfs_agoffsets##* } ] && xfs_abort "agoffset[$i]"
-			xfs_agoffsets="$xfs_agoffsets $agoffset"
-			i=$((i + 1))
-		done
-		xfs_agoffsets="${xfs_agoffsets:1}"	## strip leading space
-
-		## We also need xfs_blksects for later, because freespace gets listed as block numbers.
-		##
-		blksize=`$XFS_DB -r -c "sb" -c "print blocksize" "$fsdev" | $GAWK '{print 0 + $NF}'`
-		[ "$blksize" = "" -o "$blksize" = "0" ] && xfs_abort "block size"
-		xfs_blksects=$((blksize/512))
-		get_trimlist="xfs_trimlist"
-	fi
-	if [ "$get_trimlist" = "" ]; then
-		echo "$target: offline TRIM not supported for $fstype filesystems, aborting." >&2
-		exit 1
-	fi
-fi
-
-## All ready.  Now let the user know exactly what we intend to do:
-##
-mountstatus="$fstype non-mounted"
-[ "$fsdir" = "" ] || mountstatus="$fstype mounted $fsmode at $fsdir"
-echo "Preparing for $method TRIM of free space on $fsdev ($mountstatus)."
-
-## If they specified "--commit" on the command line, then prompt for confirmation first:
-##
-if [ "$commit" = "yes" ]; then
-	echo >/dev/tty
-	## Neither FIEMAP nor FIBMAP are safe on btrfs with mulitiple devices; non-detectable here.. ugh.
-	if [ "$fstype" = "btrfs" ]; then
-		echo "btrfs is experimental, will silently corrupt data when than one device is involved," >/dev/tty
-		echo "and provides no means for this script to determine which devices are in use." >/dev/tty
-		echo -n "Do you want to risk destroying all of your data (y/N)? " >/dev/tty
-		read yn < /dev/tty
-		if [ "$yn" != "y" -a "$yn" != "Y" ]; then
-			echo "Aborting." >&2
-			exit 1
-		fi
-		echo >/dev/tty
-	fi
-	echo -n "This operation could silently destroy your data.  Are you sure (y/N)? " >/dev/tty
-	read yn < /dev/tty
-	if [ "$yn" != "y" -a "$yn" != "Y" ]; then
-		echo "Aborting." >&2
-		exit 1
-	fi
-	TRIM="$HDPARM --please-destroy-my-drive --trim-sector-ranges-stdin $rawdev"
-else
-	echo "This will be a DRY-RUN only.  Use --commit to do it for real."
-	TRIM="$GAWK {}"
-fi
-
-## Useful in a few places later on:
-##
-function sync_disks(){
-	echo -n "Syncing disks.. "
-	sync
-	echo
-}
-
-## Clean up tmpfile (if any) and exit:
-##
-function do_cleanup(){
-	if [ "$method" = "online" ]; then
-		if [ -e $tmpfile ]; then
-			echo "Removing temporary file.."
-			$RM -f $tmpfile
-		fi
-		sync_disks
-	fi
-	[ $1 -eq 0 ] && echo "Done."
-	[ $1 -eq 0 ] || echo "Aborted." >&2
-	exit $1
-}
-
-## Prepare signal handling, in case we get interrupted while $tmpfile exists:
-##
-function do_abort(){
-	echo
-	do_cleanup 1
-}
-trap do_abort SIGTERM
-trap do_abort SIGQUIT
-trap do_abort SIGINT
-trap do_abort SIGHUP
-
-## For online TRIM, go ahead and create the huge temporary file.
-## This is where we finally discover whether the filesystem actually
-## supports --fallocate or not.  Some folks will be disappointed here.
-##
-## Note that --fallocate does not actually write any file data to fsdev,
-## but rather simply allocates formerly-free space to the tmpfile.
-##
-if [ "$method" = "online" ]; then
-	if [ -e "$tmpfile" ]; then
-		if ! $RM -f "$tmpfile" ; then
-			echo "$tmpfile: already exists and could not be removed, aborting." >&2
-			exit 1
-		fi
-	fi
-	echo -n "Creating temporary file (${tmpsize} KB).. "
-	if ! $HDPARM --fallocate "${tmpsize}" $tmpfile ; then
-		echo "$target: this kernel may not support 'fallocate' on a $fstype filesystem, aborting." >&2
-		exit 1
-	fi
-	echo
-fi
-
-## Finally, we are now ready to TRIM something!
-##
-## Feed the "get_trimlist" output into a gawk program which will
-## extract the trimable lba-ranges (extents) and batch them together
-## into huge --trim-sector-ranges calls.
-##
-## We are limited by two things when doing this:
-##   1. Some device drivers may not support more than 255 sectors
-##      full of lba:count range data, and
-##   2. The hdparm command lines are limited to under 64KB on many systems.
-##
-sync_disks
-if [ "$commit" = "yes" ]; then
-	echo "Beginning TRIM operations.."
-else
-	echo "Simulating TRIM operations.."
-fi
-[ $verbose -gt 0 ] && echo "get_trimlist=$get_trimlist"
-
-## Begin gawk program
-GAWKPROG='
-	BEGIN {
-		if (xfs_agoffsets != "") {
-			method = "xfs_offline"
-			agcount = split(xfs_agoffsets,agoffset," ");
-		}
-	}
-	function append_range (lba,count  ,this_count){
-		while (count > 0) {
-			this_count  = (count > 65535) ? 65535 : count
-			printf "%u:%u ", lba, this_count
-			lba        += this_count
-			count      -= this_count
-		}
-	}
-	(method == "online") {	## Output from "hdparm --fibmap", in absolute sectors:
-		if (NF == 4 && $2 ~ "^[1-9][0-9]*$")
-			append_range($2,$4)
-		next
-	}
-	(method == "xfs_offline") { ## Output from xfs_db:
-		if (NF == 3 && gensub("[0-9 ]","","g",$0) == "" && $1 < agcount) {
-			lba   = agoffset[1 + $1] + ($2 * xfs_blksects) + fsoffset
-			count = $3 * xfs_blksects
-			append_range(lba,count)
-		}
-		next
-	}
-	/^Block size: *[1-9]/ {	## First stage output from dumpe2fs:
-		blksects = $NF / 512
-		next
-	}
-	/^Group [1-9][0-9]*:/ {	## Second stage output from dumpe2fs:
-		in_groups = 1
-		next
-	}
-	/^ *Free blocks: [0-9]/	{ ## Bulk of output from dumpe2fs:
-		if (blksects && in_groups) {
-			n = split(substr($0,16),f,",*  *")
-			for (i = 1; i <= n; ++i) {
-				if (f[i] ~ "^[1-9][0-9]*-[1-9][0-9]*$") {
-					split(f[i],b,"-")
-					lba   = (b[1] * blksects) + fsoffset
-					count = (b[2] - b[1] + 1) * blksects
-					append_range(lba,count)
-				} else if (f[i] ~ "^[1-9][0-9]*$") {
-					lba   = (f[i] * blksects) + fsoffset
-					count = blksects;
-					append_range(lba,count)
-				}
-			}
-		}
-	}
-	END {
-		if (err == 0 && nranges > 0)
-			do_trim()
-		exit err
-	}'
-## End gawk program
-
-$get_trimlist 2>/dev/null | $GAWK		\
-	-v method="$method"			\
-	-v rawdev="$rawdev"			\
-	-v fsoffset="$fsoffset"			\
-	-v verbose="$verbose"			\
-	-v xfs_blksects="$xfs_blksects"		\
-	-v xfs_agoffsets="$xfs_agoffsets"	\
-	"$GAWKPROG" | $TRIM
-
-do_cleanup $?
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.5/fiemap_compat_ioctl.patch hdparm-9.27-with-wiper_2.5/wiper-2.5/fiemap_compat_ioctl.patch
--- hdparm-9.27-with-wiper_2.3/wiper-2.5/fiemap_compat_ioctl.patch	1970-01-01 02:00:00.000000000 +0200
+++ hdparm-9.27-with-wiper_2.5/wiper-2.5/fiemap_compat_ioctl.patch	2009-08-01 18:19:56.000000000 +0300
@@ -0,0 +1,42 @@
+Add support for the FIEMAP ioctl for 32-bit user on 64-bit kernel.
+
+When using a 32-bit runtime on top of a 64-bit kernel,
+programs like "filefrag" and "hdparm --fibmap" do not work correctly.
+
+This is because there's no compat ioctl entry for the FIEMAP call.
+FIEMAP returns file extent info, similar to FIBMAP (but better).
+
+Since FIBMAP itself is b0rked on ext4, this leaves no way for a 32-bit
+program to reliably get detailed block information for a file
+when run on top of a 64-bit kernel.  This patch addresses the issue.
+
+Once upstream, this patch could also be a candidate for -stable.
+
+Signed-off-by: Mark Lord <mlord@pobox.com> 
+
+--- old/fs/compat_ioctl.c	2009-08-01 10:47:16.601066905 -0400
++++ linux/fs/compat_ioctl.c	2009-08-01 10:49:23.054387926 -0400
+@@ -35,6 +35,7 @@
+ #include <linux/falloc.h>
+ #include <linux/fs.h>
+ #include <linux/file.h>
++#include <linux/fiemap.h>
+ #include <linux/ppp_defs.h>
+ #include <linux/if_ppp.h>
+ #include <linux/if_pppox.h>
+@@ -1907,6 +1908,7 @@
+ COMPATIBLE_IOCTL(FIONREAD)  /* This is also TIOCINQ */
+ /* 0x00 */
+ COMPATIBLE_IOCTL(FIBMAP)
++COMPATIBLE_IOCTL(FS_IOC_FIEMAP)
+ COMPATIBLE_IOCTL(FIGETBSZ)
+ /* 'X' - originally XFS but some now in the VFS */
+ COMPATIBLE_IOCTL(FIFREEZE)
+@@ -2805,6 +2807,7 @@
+ 		goto out_fput;
+ #endif
+ 
++	case FS_IOC_FIEMAP:
+ 	case FIBMAP:
+ 	case FIGETBSZ:
+ 	case FIONREAD:
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.5/GPLv2.txt hdparm-9.27-with-wiper_2.5/wiper-2.5/GPLv2.txt
--- hdparm-9.27-with-wiper_2.3/wiper-2.5/GPLv2.txt	1970-01-01 02:00:00.000000000 +0200
+++ hdparm-9.27-with-wiper_2.5/wiper-2.5/GPLv2.txt	2009-07-30 00:58:31.000000000 +0300
@@ -0,0 +1,341 @@
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.5/README.txt hdparm-9.27-with-wiper_2.5/wiper-2.5/README.txt
--- hdparm-9.27-with-wiper_2.3/wiper-2.5/README.txt	1970-01-01 02:00:00.000000000 +0200
+++ hdparm-9.27-with-wiper_2.5/wiper-2.5/README.txt	2009-10-02 16:14:32.000000000 +0300
@@ -0,0 +1,97 @@
+TRIM / wiper script for SATA SSDs   (October 2009)
+=================================================
+
+The wiper.sh script is for tuning up SATA SSDs (Solid-State-Drives).
+
+It calculates a list of free (unallocated) blocks within a filesystem,
+and informs the SSD firmware of those blocks, so that it can better manage
+the underlying media for wear-leveling and garbage-collection purposes.
+
+In some cases, this can restore a sluggish SSD to nearly-new speeds again.
+
+This script may be EXTREMELY HAZARDOUS TO YOUR DATA.
+
+It does work for me here, but it has not yet been exhaustively tested by others.
+
+Please back-up your data to a *different* physical drive before trying it.
+And if you are at all worried, then DO NOT USE THIS SCRIPT!!
+
+Once there are drives in the marketplace with production firmware that supports
+the SATA DSM TRIM command, then this will get tested a bit more over time.
+As that happens, it will be moved out of this directory and installed alongside
+the hdparm executable, probably under /sbin or /usr/sbin.
+
+Until then, DO NOT USE THIS SCRIPT if you cannot afford losing your data!!
+
+
+This script works for read-write mounted ext4 and xfs filesystems,
+and for read-only mounted/unmounted ext2, ext3, ext4, reiser3 and xfs filesystems.
+
+Invoke the script with the pathname to the mounted filesystem
+or the block device path for the filesystem.
+
+	Eg.	./wiper.sh /boot
+		./wiper.sh /
+		./wiper.sh /dev/sda1
+
+Note that the most comprehensive results are achieved when
+wiping a filesystem that is not currently mounted read-write,
+though the difference is small.
+
+==================================================
+
+btrfs -- DO NOT USE !!!
+
+Chris Mason, the primary author/maintainer of btrfs, believes that
+the FIEMAP/FIBMAP ioctl() calls are completely unsafe when used on
+a btrfs filesystem.  Even when only a single device is involved.
+This seems rather strange. If true, those ioctls() should be removed from btrfs.
+
+But there are other issues, as well.
+
+btrfs breaks the Linux filesystem model in many ways, making it rather dangerous
+to your data to try and TRIM it.  It implements it's own internal multiple-device
+layer, similar to DM/MD/VFS, but without any indication to external utilities like wiper.sh.
+As a result, detection of the underlying device for the filesystem is haphazard at best,
+and this could cause wiper.sh to destroy data on whatever device it thinks is the correct one.
+
+Also, because of the built-in duplication of multiple-device support, the FIBMAP and FIEMAP
+ioctl()s will work incorrectly on btrfs when more than a single device is involved.
+This means that btrfs will mislead the wiper.sh script, causing it to TRIM the WRONG sectors,
+destroying valuable data, programs, and filesystem metadata.  You will lose everything.
+
+Finally, due to the non-standard internal volume/device remapping done by btrfs,
+it is very difficult for standard Linux tools like hdparm and wiper.sh to actually
+determine the device that lies underneath a given file.  Odd, but true.
+
+So support for btrfs has been dropped as of wiper-2.5.
+It used to work for single drives, but as of the Linux-2.6.31 kernel even hdparm
+is now failing for simple operations like obtaining drive geometries from /sys on btrfs.
+
+btrfs is an experimental beta with serious issues; use ext4 or xfs instead.
+
+==================================================
+
+The sil24_trim_protocol_fix.patch file in this directory is a kernel
+patch for all recent Linux kernel versions up to and including 2.6.31.
+
+This fixes the kernel device driver for the Silicon Image SiI-3132
+SATA controller to correctly pass DSM/TRIM commands to the drives.
+
+If you use this hardware in your system, then you will need to apply
+the patch to your kernel before using the wiper scripts.
+
+==================================================
+
+The fiemap_compat_ioctl.patch file in this directory is a kernel patch
+to speed up "hdparm --fibmap" when run as a 32-bit program on top of
+a 64-bit Linux kernel.  Kernels versions up to and including 2.6.31
+are missing support for this, so hdparm will fall back to the older
+and slower FIBMAP call, causing wiper.sh to take much longer to run.
+The older call has other limitations, such as failing on really large
+files or huge disks, so use of FIEMAP really is preferred.
+
+As of August 16, a similar patch has now been backported to the -stable
+streams of most recent Linux kernel versions.  So update your kernel
+and this functionality will already be included.
+
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.5/sil24_trim_protocol_fix.patch hdparm-9.27-with-wiper_2.5/wiper-2.5/sil24_trim_protocol_fix.patch
--- hdparm-9.27-with-wiper_2.3/wiper-2.5/sil24_trim_protocol_fix.patch	1970-01-01 02:00:00.000000000 +0200
+++ hdparm-9.27-with-wiper_2.5/wiper-2.5/sil24_trim_protocol_fix.patch	2009-07-30 23:19:41.000000000 +0300
@@ -0,0 +1,36 @@
+The sil24 hardware has a built-in list of commands and associated protocols
+that gets used by default to decide how to handle a given command. However,
+if the command is not known to the controller then it presumably assumes it to
+be a non-data command which then causes protocol mismatch errors if the device
+ends up requesting data transfer. The new DATA SET MANAGEMENT - Trim command
+causes this issue since it's a DMA data-out command.
+
+Since we should always know best what protocol the command should be using,
+let's just set the override flag to inform the controller what protocol to use
+for all non-ATAPI commands with data transfer.
+
+Signed-off-by: Robert Hancock <hancockrwd@gmail.com>
+Tested-by: Mark Lord <liml@rtr.ca>
+
+diff --git a/drivers/ata/sata_sil24.c b/drivers/ata/sata_sil24.c
+index 77aa8d7..e6946fc 100644
+--- a/drivers/ata/sata_sil24.c
++++ b/drivers/ata/sata_sil24.c
+@@ -846,6 +846,17 @@ static void sil24_qc_prep(struct ata_queued_cmd *qc)
+ 	if (!ata_is_atapi(qc->tf.protocol)) {
+ 		prb = &cb->ata.prb;
+ 		sge = cb->ata.sge;
++		if (ata_is_data(qc->tf.protocol)) {
++			u16 prot = 0;
++			ctrl = PRB_CTRL_PROTOCOL;
++			if (ata_is_ncq(qc->tf.protocol))
++				prot |= PRB_PROT_NCQ;
++			if (qc->tf.flags & ATA_TFLAG_WRITE)
++				prot |= PRB_PROT_WRITE;
++			else
++				prot |= PRB_PROT_READ;
++			prb->prot = cpu_to_le16(prot);
++		}
+ 	} else {
+ 		prb = &cb->atapi.prb;
+ 		sge = cb->atapi.sge;
diff -uNr hdparm-9.27-with-wiper_2.3/wiper-2.5/wiper.sh hdparm-9.27-with-wiper_2.5/wiper-2.5/wiper.sh
--- hdparm-9.27-with-wiper_2.3/wiper-2.5/wiper.sh	1970-01-01 02:00:00.000000000 +0200
+++ hdparm-9.27-with-wiper_2.5/wiper-2.5/wiper.sh	2009-10-02 16:11:27.000000000 +0300
@@ -0,0 +1,699 @@
+#!/bin/bash
+#
+# SATA SSD free-space TRIM utility, by Mark Lord
+
+VERSION=2.5
+ 
+# Copyright (C) 2009 Mark Lord.  All rights reserved.
+#
+# Requires gawk, a really-recent hdparm, and various other programs.
+# This needs to be redone entirely in C, for 64-bit math, someday.
+# 
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License Version 2,
+# as published by the Free Software Foundation.
+# 
+# This program is distributed in the hope that it would be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+export LANG=C
+
+## The usual terse usage information:
+##
+function usage_error(){
+	echo >&2
+	echo "Linux tune-up (TRIM) utility for SATA SSDs"
+	echo "Usage:  $0 [--verbose] [--commit] <mount_point|block_device>" >&2
+	echo "   Eg:  $0 /dev/sda1" >&2
+	echo >&2
+	exit 1
+}
+
+## Parameter parsing for the main script.
+## Yeah, we could use getopt here instead, but what fun would that be?
+##
+
+echo
+echo "${0##*/}: Linux SATA SSD TRIM utility, version $VERSION, by Mark Lord."
+
+verbose=0
+commit=""
+argc=$#
+arg=""
+while [ $argc -gt 0 ]; do
+	if [ "$1" = "--commit" ]; then
+		commit=yes
+	elif [ "$1" = "--verbose" ]; then
+		verbose=1
+	elif [ "$1" = "" ]; then
+		usage_error
+	else
+		if [ "$arg" != "" ]; then
+			echo "$1: too many arguments, aborting." >&2
+			exit 1
+		fi
+		arg="$1"
+	fi
+	argc=$((argc - 1))
+	shift
+done
+[ "$arg" = "" ] && usage_error
+
+## Find a required program, or else give a nicer error message than we'd otherwise see:
+##
+function find_prog(){
+	prog="$1"
+	if [ ! -x "$prog" ]; then
+		prog="${prog##*/}"
+		p=`type -f -P "$prog" 2>/dev/null`
+		if [ "$p" = "" ]; then
+			echo "$1: needed but not found, aborting." >&2
+			exit 1
+		fi
+		prog="$p"
+		[ $verbose -gt 0 ] && echo "  --> using $prog instead of $1" >&2
+	fi
+	echo "$prog"
+}
+
+## Ensure we have most of the necessary utilities available before trying to proceed:
+##
+hash -r  ## Refresh bash's cached PATH entries
+HDPARM=`find_prog /sbin/hdparm`	|| exit 1
+FIND=`find_prog /usr/bin/find`	|| exit 1
+STAT=`find_prog /usr/bin/stat`	|| exit 1
+GAWK=`find_prog /usr/bin/gawk`	|| exit 1
+BLKID=`find_prog /sbin/blkid`	|| exit 1
+GREP=`find_prog /bin/grep`	|| exit 1
+ID=`find_prog /usr/bin/id`	|| exit 1
+LS=`find_prog /bin/ls`		|| exit 1
+DF=`find_prog /bin/df`		|| exit 1
+RM=`find_prog /bin/rm`		|| exit 1
+
+## I suppose this will confuse the three SELinux users out there:
+##
+if [ `$ID -u` -ne 0 ]; then
+	echo "Only the super-user can use this (try \"sudo $0\" instead), aborting." >&2
+	exit 1
+fi
+
+## We need a very modern hdparm, for its --fallocate and --trim-sector-ranges-stdin flags:
+## Version 9.25 added automatic determination of safe max-size of TRIM commands.
+##
+HDPVER=`$HDPARM -V | $GAWK '{gsub("[^0-9.]","",$2); if ($2 > 0) print ($2 * 100); else print 0; exit(0)}'`
+if [ $HDPVER -lt 925 ]; then
+	echo "$HDPARM: version >= 9.25 is required, aborting." >&2
+	exit 1
+fi
+
+## Convert relative path "$1" into an absolute pathname, resolving all symlinks:
+##
+function get_realpath(){
+	iter=0
+	p="$1"
+	while [ -e "$p" -a $iter -lt 100 ]; do
+		## Strip trailing slashes:
+		while [ "$p" != "/" -a "$p" != "${p%%/}" ]; do
+			p="${p%%/}"
+		done
+		## Split into directory:leaf portions:
+		d="${p%/*}"
+		t="${p##*/}"
+		## If the split worked, then cd into the directory portion:
+		if [ "$d" != "" -a "$d" != "$p" ]; then
+			cd -P "$d" || exit
+			p="$t"
+		fi
+		## If what we have left is a directory, then cd to it and print realpath:
+		if [ -d "$p" ]; then
+			cd -P "$p" || exit
+			pwd -P
+			exit
+		## Otherwise if it is a symlink, read the link and loop again:
+		elif [ -h "$p" ]; then
+			p="`$LS -ld "$p" | awk '{sub("^[^>]*-[>] *",""); print}'`"
+		## Otherwise, prefix $p with the cwd path and print it:
+		elif [ -e "$p" ]; then
+			[ "${p:0:1}" = "/" ] || p="`pwd -P`/$p"
+			echo "$p"
+			exit
+		fi
+		iter=$((iter + 1))
+	done
+}
+
+function get_devpath(){
+	dir="$1"
+	kdev=`$STAT --format="%04D" "$dir" 2>/dev/null`
+	[ "$kdev" = "" ] && exit 1
+	major=$((0x${kdev:0:2}))
+	minor=$((0x${kdev:2:2}))
+	$FIND /dev -xdev -type b -exec $LS -ln {} \; | $GAWK -v major="$major," -v minor="$minor" \
+		'($5 == major && $6 == minor){r=$NF}END{print r}'
+}
+
+## Convert "$arg" into an absolute pathname target, with no symlinks or embedded blanks:
+target="`get_realpath "$arg"`"
+if [ "$target" = "" ]; then
+	[ "$arg" = "/dev/root" ] && target="`get_devpath /`"
+	if [ "$target" = "" ]; then
+		echo "$arg: unable to determine full pathname, aborting." >&2
+		exit 1
+	fi
+fi
+if [ "$target" != "${target##* }" ]; then
+	echo "\"$target\": pathname has embedded blanks, aborting." >&2
+	exit 1
+fi
+
+## Take a first cut at online/offline determination, based on the target:
+##
+if [ -d "$target" ]; then
+	method=online
+elif [ -b "$target" ]; then
+	method=offline
+else
+	echo "$target: not a block device or mount point, aborting." >&2
+	exit 1
+fi
+
+## Find the active mount-point (fsdir) associated with a device ($1: fsdev).
+## This is complicated, and probably still buggy, because a single
+## device can show up under *multiple* mount points in /proc/mounts.
+##
+function get_fsdir(){
+	rw=""
+	r=""
+	while read -a m ; do
+		pdev="${m[0]}"
+		[ "$pdev" = "$1" ] || pdev="`get_realpath "$pdev"`"
+		if [ "$pdev" = "$1" ]; then
+			if [ "$rw" != "rw" ]; then
+				rw="${m[3]:0:2}"
+				r="${m[1]}"
+			fi
+		fi
+		#echo "$pdev ${m[1]} ${m[2]} ${m[3]}"
+	done
+	echo -n "$r"
+}
+
+## Find the device (fsdev) associated with a mount point ($1: fsdir).
+## Since mounts can be stacked on top of each other, we return the
+## one from the last occurance in the list from /proc/mounts.
+##
+function get_fsdev(){   ## from fsdir
+	get_realpath "`$GAWK -v p="$1" '{if ($2 == p) r=$1} END{print r}' < /proc/mounts`"
+}
+
+## Find the r/w or r/o status (fsmode) of a filesystem mount point  ($1: fsdir)
+## We get it from the last occurance of the mount point in the list from /proc/mounts,
+## and convert it to a longer human-readable string.
+##
+function get_fsmode(){  ## from fsdir
+	mode="`$GAWK -v p="$1" '{if ($2 == p) r=substr($4,1,2)} END{print r}' < /proc/mounts`"
+	if [ "$mode" = "ro" ]; then
+		echo "read-only"
+	elif [ "$mode" = "rw" ]; then
+		echo "read-write"
+	else
+		echo "$fsdir: unable to determine mount status, aborting." >&2
+		exit 1
+	fi
+}
+
+## Use $DF to determine the device name associated with the root filesystem.
+##
+## This *usually* works, but on some distros it just returns "/dev/root",
+## and "/dev/root" does not actually exist.  We leave it like that for now,
+## because that's the pattern such systems also use in /proc/mounts.
+## Later, at time of use, we'll try harder to find the real rootdev.
+##
+rdev="`($DF -P / | $GAWK '/^[/]/{print $1;exit}') 2>/dev/null`"
+rootdev="`get_realpath "$rootdev"`"
+[ "$rootdev" = "" ] && rootdev=$rdev
+[ $verbose -gt 0 ] && echo "rootdev=$rootdev rdev=$rdev"
+
+## The user gave us a directory (mount point) to TRIM,
+## which implies that we will be doing an online TRIM
+## using --fallocate and --fibmap to find the free extents.
+## Do some preliminary correctness/feasibility checks on fsdir:
+##
+if [ "$method" = "online" ]; then
+	## Ensure fsdir exists and is accessible to us:
+	fsdir="$target"
+	cd "$fsdir" || exit 1
+
+	if [ "$fsdir" = "/" ]; then
+		fsdev="$rootdev"
+	else
+		## Figure out what device holds the filesystem.
+		fsdev="`get_fsdev $fsdir`"
+		if [ "$fsdev" = "" ]; then
+			echo "$fsdir: not found in /proc/mounts, aborting." >&2
+			exit 1
+		fi
+	fi
+
+	## The root filesystem may show up as the phoney "/dev/root" device
+	## in /proc/mounts (ugh).  So if we see that, then substitute the rootdev
+	## that $DF gave us earlier.  But $DF may have the same problem (double ugh).
+	##
+	[ ! -e "$fsdev" -a "$fsdev" = "/dev/root" ] && fsdev="$rootdev"
+
+	## Ensure that fsdev exists and is a block device:
+	if [ ! -e "$fsdev" ]; then
+		if [ "$fsdev" != "/dev/root" ]; then
+			echo "$fsdev: not found" >&2
+			exit 1
+		fi
+		rdev="`get_devpath /`"
+		if [ "$rdev" = "" ]; then
+			echo "$fsdev: not found" >&2
+			exit 1
+		fi
+		fsdev="$rdev"
+	fi
+	if [ ! -b "$fsdev" ]; then
+		echo "$fsdev: not a block device" >&2
+		exit 1
+	fi
+
+	## If it is mounted read-only, we must switch to doing an "offline" trim of fsdev:
+	fsmode="`get_fsmode $fsdir`" || exit 1
+	[ $verbose -gt 0 ] && echo "fsmode1: fsmode=$fsmode"
+	[ "$fsmode" = "read-only" ] && method=offline
+fi
+
+## This is not an "else" clause from the above, because "method" may have changed.
+## For offline TRIM, we need the block device, and it cannot be mounted read-write:
+##
+if [ "$method" = "offline" ]; then
+	## We might already have fsdev/fsdir from above; if not, we need to find them.
+	if [ "$fsdev" = "" -o "$fsdir" = "" ]; then
+		fsdev="$target"
+		fsdir="`get_fsdir "$fsdev" < /proc/mounts`"
+		## More weirdness for /dev/root in /proc/mounts:
+		if [ "$fsdir" = "" -a "$fsdev" = "$rootdev" ]; then
+			fsdir="`get_fsdir /dev/root < /proc/mounts`"
+			if [ "$fsdir" = "" ]; then
+				rdev="`get_devpath /`"
+				[ "$rdev" != "" ] && fsdir="`get_fsdir "$rdev" < /proc/mounts`"
+			fi
+		fi
+	fi
+
+	## If the filesystem is truly not-mounted, then fsdir will still be empty here.
+	## It could be mounted, though.  Read-only is fine, but read-write means we need
+	## to switch gears and do an "online" TRIM instead of an "offline" TRIM.
+	##
+	if [ "$fsdir" != "" ]; then
+		fsmode="`get_fsmode $fsdir`" || exit 1
+		[ $verbose -gt 0 ] && echo "fsmode2: fsmode=$fsmode"
+		if [ "$fsmode" = "read-write" ]; then
+			method=online
+			cd "$fsdir" || exit 1
+		fi
+	fi
+fi
+
+## Use $LS to find the major number of a block device:
+##
+function get_major(){
+	$LS -ln "$1" | $GAWK '{print gensub(",","",1,$5)}'
+}
+
+## At this point, we have finalized our selection of online vs. offline,
+## and we definitely know the fsdev, as well as the fsdir (fsdir="" if not-mounted).
+##
+## Now guess at the underlying rawdev name, which could be exactly the same as fsdev.
+## Then determine whether or not rawdev claims support for TRIM commands.
+## Note that some devices lie about support, and later reject the TRIM commands.
+##
+rawdev=`echo $fsdev | $GAWK '{print gensub("[0-9]*$","","g")}'`
+rawdev="`get_realpath "$rawdev"`"
+if [ ! -e "$rawdev" ]; then
+	rawdev=""
+elif [ ! -b "$rawdev" ]; then
+	rawdev=""
+elif [ "`get_major $fsdev`" -ne "`get_major $rawdev`" ]; then  ## sanity check
+	rawdev=""
+elif [ "`get_major $fsdev`" -ne "8" ]; then ## "SCSI" drives only; no LVM confusion for now
+	echo "$rawdev: does not appear to be a SCSI/SATA SSD, aborting." >&2
+	exit 1
+elif ! $HDPARM -I $rawdev | $GREP -i '[ 	][*][ 	]*Data Set Management TRIM supported' &>/dev/null ; then
+	if [ "$commit" = "yes" ]; then
+		echo "$rawdev: DSM/TRIM command not supported, aborting." >&2
+		exit 1
+	fi
+	echo "$rawdev: DSM/TRIM command not supported (continuing with dry-run)." >&2
+fi
+if [ "$rawdev" = "" ]; then
+	echo "$fsdev: unable to reliably determine the underlying physical device name, aborting" >&2
+	exit 1
+fi
+
+## We also need to know the offset of fsdev from the beginning of rawdev,
+## because TRIM requires absolute sector numbers within rawdev:
+##
+fsoffset=`$HDPARM -g "$fsdev" | $GAWK 'END {print $NF}'`
+
+## Next step is to determine what type of filesystem we are dealing with (fstype):
+##
+if [ "$fsdir" = "" ]; then
+	## Not mounted: use $BLKID to determine the fstype of fsdev:
+	fstype=`$BLKID -w /dev/null -c /dev/null $fsdev 2>/dev/null | \
+		 $GAWK '/ TYPE=".*"/{sub("^.* TYPE=\"",""); sub("[\" ][\" ]*.*$",""); print}'`
+	[ $verbose -gt 0 ] && echo "$fsdev: fstype=$fstype"
+else
+	## Mounted: we could just use $BLKID here, too, but it's safer to use /proc/mounts directly:
+	fstype="`$GAWK -v p="$fsdir" '{if ($2 == p) r=$3} END{print r}' < /proc/mounts`"
+	[ $verbose -gt 0 ] && echo "$fsdir: fstype=$fstype"
+fi
+if [ "$fstype" = "" ]; then
+	echo "$fsdev: unable to determine filesystem type, aborting." >&2
+	exit 1
+fi
+
+## Some helper funcs and vars for use with the xfs filesystem tools:
+##
+function xfs_abort(){
+	echo "$fsdev: unable to determine xfs filesystem ${1-parameters}, aborting." >&2
+	exit 1
+}
+function xfs_trimlist(){
+	$XFS_DB -r -c "freesp -d" "$fsdev"  ## couldn't get this to work inline
+}
+xfs_agoffsets=""
+xfs_blksects=0
+
+## We used to allow single-drive btrfs here, but it stopped working in linux-2.6.31,
+## and Chris Mason says "unsafe at any speed" really.  So it's been dropped now.
+##
+if [ "$fstype" = "btrfs" ]; then  ## hdparm --fibmap fails, due to fake 0:xx device nodes
+	echo "$target: btrfs filesystem type not supported (cannot determine physical devices), aborting." >&2
+	exit 1
+fi
+
+## Now figure out whether we can actually do TRIM on this type of filesystem:
+##
+if [ "$method" = "online" ]; then
+	## Print sensible error messages for some common situations,
+	## rather than failing with more confusing messages later on..
+	##
+	if [ "$fstype" = "ext2" -o "$fstype" = "ext3" ]; then  ## No --fallocate support
+		echo "$target: cannot TRIM $fstype filesystem when mounted read-write, aborting." >&2
+		exit 1
+	fi
+
+	## Figure out if we have enough free space to even attempt TRIM:
+	##
+	freesize=`$DF -P -B 1024 . | $GAWK '{r=$4}END{print r}'`
+	if [ "$freesize" = "" ]; then
+		echo "$fsdev: unknown to '$DF'"
+		exit 1
+	fi
+	if [ $freesize -lt 15000 ]; then
+		echo "$target: filesystem too full for TRIM, aborting." >&2
+		exit 1
+	fi
+
+	## Figure out how much space to --fallocate (later), keeping in mind
+	## that this is a live filesystem, and we need to leave some space for
+	## other concurrent activities, as well as for filesystem overhead (metadata).
+	## So, reserve at least 1% or 7500 KB, whichever is larger:
+	##
+	reserved=$((freesize / 100))
+	[ $reserved -lt 7500 ] && reserved=7500
+	[ $verbose -gt 0 ] && echo "freesize = ${freesize} KB, reserved = ${reserved} KB"
+	tmpsize=$((freesize - reserved))
+	tmpfile="WIPER_TMPFILE.$$"
+	get_trimlist="$HDPARM --fibmap $tmpfile"
+else
+	## We can only do offline TRIM on filesystems that we "know" about here.
+	## Currently, this includes the ext2/3/4 family, xfs, and reiserfs.
+	## The first step for any of these is to ensure that the filesystem is "clean",
+	## and immediately abort if it is not.
+	##
+	get_trimlist=""
+	if [ "$fstype" = "ext2" -o "$fstype" = "ext3" -o "$fstype" = "ext4" ]; then
+		DUMPE2FS=`find_prog /sbin/dumpe2fs` || exit 1
+		fstate="`$DUMPE2FS $fsdev 2>/dev/null | $GAWK '/^[Ff]ilesystem state:/{print $NF}' 2>/dev/null`"
+		if [ "$fstate" != "clean" ]; then
+			echo "$target: filesystem not clean, please run \"e2fsck $fsdev\" first, aborting." >&2
+			exit 1
+		fi
+		get_trimlist="$DUMPE2FS $fsdev"
+	elif [ "$fstype" = "xfs" ]; then
+		XFS_DB=`find_prog /sbin/xfs_db` || exit 1
+		XFS_REPAIR=`find_prog /sbin/xfs_repair` || exit 1
+		if ! $XFS_REPAIR -n "$fsdev" &>/dev/null ; then
+			echo "$fsdev: filesystem not clean, please run \"xfs_repair $fsdev\" first, aborting." >&2
+			exit 1
+		fi
+
+		## For xfs, life is more complex than with ext2/3/4 above.
+		## The $XFS_DB tool does not return absolute block numbers for freespace,
+		## but rather gives them as relative to it's allocation groups (ag's).
+		## So, we'll need to interogate it for the offset of each ag within the filesystem.
+		## The agoffsets are extracted from $XFS_DB as sector offsets within the fsdev.
+		##
+		agcount=`$XFS_DB -r -c "sb" -c "print agcount" "$fsdev" | $GAWK '{print 0 + $NF}'`
+		[ "$agcount" = "" -o "$agcount" = "0" ] && xfs_abort "agcount"
+		xfs_agoffsets=
+		i=0
+		while [ $i -lt $agcount ]; do
+			agoffset=`$XFS_DB -r -c "sb" -c "convert agno $i daddr" "$fsdev" \
+				| $GAWK '{print 0 + gensub("[( )]","","g",$2)}'`
+			[ "$agoffset" = "" ] && xfs_abort "agoffset-$i"
+			[ $i -gt 0 ] && [ $agoffset -le ${xfs_agoffsets##* } ] && xfs_abort "agoffset[$i]"
+			xfs_agoffsets="$xfs_agoffsets $agoffset"
+			i=$((i + 1))
+		done
+		xfs_agoffsets="${xfs_agoffsets:1}"	## strip leading space
+
+		## We also need xfs_blksects for later, because freespace gets listed as block numbers.
+		##
+		blksize=`$XFS_DB -r -c "sb" -c "print blocksize" "$fsdev" | $GAWK '{print 0 + $NF}'`
+		[ "$blksize" = "" -o "$blksize" = "0" ] && xfs_abort "block size"
+		xfs_blksects=$((blksize/512))
+		get_trimlist="xfs_trimlist"
+	elif [ "$fstype" = "reiserfs" ]; then
+		DEBUGREISERFS=`find_prog /sbin/debugreiserfs` || exit 1
+		( $DEBUGREISERFS $fsdev | grep '^Filesystem state:.consistent' ) &> /dev/null
+		if [ $? -ne 0 ]; then
+			echo "Please run fsck.reiserfs first, aborting." >&2
+			exit 1
+		fi
+		get_trimlist="$DEBUGREISERFS -m $fsdev"
+	fi
+	if [ "$get_trimlist" = "" ]; then
+		echo "$target: offline TRIM not supported for $fstype filesystems, aborting." >&2
+		exit 1
+	fi
+fi
+
+## All ready.  Now let the user know exactly what we intend to do:
+##
+mountstatus="$fstype non-mounted"
+[ "$fsdir" = "" ] || mountstatus="$fstype mounted $fsmode at $fsdir"
+echo "Preparing for $method TRIM of free space on $fsdev ($mountstatus)."
+
+## If they specified "--commit" on the command line, then prompt for confirmation first:
+##
+if [ "$commit" = "yes" ]; then
+	echo >/dev/tty
+	echo -n "This operation could silently destroy your data.  Are you sure (y/N)? " >/dev/tty
+	read yn < /dev/tty
+	if [ "$yn" != "y" -a "$yn" != "Y" ]; then
+		echo "Aborting." >&2
+		exit 1
+	fi
+	TRIM="$HDPARM --please-destroy-my-drive --trim-sector-ranges-stdin $rawdev"
+else
+	echo "This will be a DRY-RUN only.  Use --commit to do it for real."
+	TRIM="$GAWK {}"
+fi
+
+## Useful in a few places later on:
+##
+function sync_disks(){
+	echo -n "Syncing disks.. "
+	sync
+	echo
+}
+
+## Clean up tmpfile (if any) and exit:
+##
+function do_cleanup(){
+	if [ "$method" = "online" ]; then
+		if [ -e $tmpfile ]; then
+			echo "Removing temporary file.."
+			$RM -f $tmpfile
+		fi
+		sync_disks
+	fi
+	[ $1 -eq 0 ] && echo "Done."
+	[ $1 -eq 0 ] || echo "Aborted." >&2
+	exit $1
+}
+
+## Prepare signal handling, in case we get interrupted while $tmpfile exists:
+##
+function do_abort(){
+	echo
+	do_cleanup 1
+}
+trap do_abort SIGTERM
+trap do_abort SIGQUIT
+trap do_abort SIGINT
+trap do_abort SIGHUP
+
+## For online TRIM, go ahead and create the huge temporary file.
+## This is where we finally discover whether the filesystem actually
+## supports --fallocate or not.  Some folks will be disappointed here.
+##
+## Note that --fallocate does not actually write any file data to fsdev,
+## but rather simply allocates formerly-free space to the tmpfile.
+##
+if [ "$method" = "online" ]; then
+	if [ -e "$tmpfile" ]; then
+		if ! $RM -f "$tmpfile" ; then
+			echo "$tmpfile: already exists and could not be removed, aborting." >&2
+			exit 1
+		fi
+	fi
+	echo -n "Creating temporary file (${tmpsize} KB).. "
+	if ! $HDPARM --fallocate "${tmpsize}" $tmpfile ; then
+		echo "$target: this kernel may not support 'fallocate' on a $fstype filesystem, aborting." >&2
+		exit 1
+	fi
+	echo
+fi
+
+## Finally, we are now ready to TRIM something!
+##
+## Feed the "get_trimlist" output into a gawk program which will
+## extract the trimable lba-ranges (extents) and batch them together
+## into huge --trim-sector-ranges calls.
+##
+## We are limited by at least one thing when doing this:
+##   1. Some device drivers may not support more than 255 sectors
+##      full of lba:count range data per TRIM command.
+## The latest hdparm versions now take care of that automatically.
+##
+sync_disks
+if [ "$commit" = "yes" ]; then
+	echo "Beginning TRIM operations.."
+else
+	echo "Simulating TRIM operations.."
+fi
+[ $verbose -gt 0 ] && echo "get_trimlist=$get_trimlist"
+
+## Begin gawk program
+GAWKPROG='
+	BEGIN {
+		if (xfs_agoffsets != "") {
+			method = "xfs_offline"
+			agcount = split(xfs_agoffsets,agoffset," ");
+		}
+	}
+	function append_range (lba,count  ,this_count){
+		nsectors += count;
+		while (count > 0) {
+			this_count  = (count > 65535) ? 65535 : count
+			printf "%u:%u ", lba, this_count
+			#if (verbose) printf "%u:%u ", lba, this_count > "/dev/stderr"
+			lba        += this_count
+			count      -= this_count
+			nranges++;
+		}
+	}
+	(method == "online") {	## Output from "hdparm --fibmap", in absolute sectors:
+		if (NF == 4 && $2 ~ "^[1-9][0-9]*$")
+			append_range($2,$4)
+		next
+	}
+	(method == "xfs_offline") { ## Output from xfs_db:
+		if (NF == 3 && gensub("[0-9 ]","","g",$0) == "" && $1 < agcount) {
+			lba   = agoffset[1 + $1] + ($2 * xfs_blksects) + fsoffset
+			count = $3 * xfs_blksects
+			append_range(lba,count)
+		}
+		next
+	}
+	/^Block size: *[1-9]/ {	## First stage output from dumpe2fs:
+		blksects = $NF / 512
+		next
+	}
+	/^Group [1-9][0-9]*:/ {	## Second stage output from dumpe2fs:
+		in_groups = 1
+		next
+	}
+	/^ *Free blocks: [0-9]/	{ ## Bulk of output from dumpe2fs:
+		if (blksects && in_groups) {
+			n = split(substr($0,16),f,",*  *")
+			for (i = 1; i <= n; ++i) {
+				if (f[i] ~ "^[1-9][0-9]*-[1-9][0-9]*$") {
+					split(f[i],b,"-")
+					lba   = (b[1] * blksects) + fsoffset
+					count = (b[2] - b[1] + 1) * blksects
+					append_range(lba,count)
+				} else if (f[i] ~ "^[1-9][0-9]*$") {
+					lba   = (f[i] * blksects) + fsoffset
+					count = blksects
+					append_range(lba,count)
+				}
+			}
+			next
+		}
+	}
+	/^Reiserfs super block/ {
+		method = "reiserfs"
+		next
+	}
+	/^Blocksize: / {
+		if (method == "reiserfs") {
+			blksects = $2 / 512
+			next
+		}
+	}
+	/^#[0-9][0-9]*:.*Free[(]/ { ## debugreiserfs
+		if (method == "reiserfs" && blksects > 0) {
+			n = split($0,f)
+			for (i = 4; i <= n; ++i) {
+				if (f[i] ~ "^ *Free[(]") {
+					if (2 == split(gensub("[^-0-9]","","g",f[i]),b,"-")) {
+						lba = (b[1] * blksects) + fsoffset
+						count = (b[2] - b[1] + 1) * blksects
+						append_range(lba, count)
+					}
+				}
+			}
+			next
+		}
+	}
+	END {
+		if (err == 0 && commit != "yes")
+			printf "(dry-run) trimming %u sectors from %u ranges\n", nsectors, nranges > "/dev/stderr"
+		exit err
+	}'
+## End gawk program
+
+$get_trimlist 2>/dev/null | $GAWK		\
+	-v commit="$commit"			\
+	-v method="$method"			\
+	-v rawdev="$rawdev"			\
+	-v fsoffset="$fsoffset"			\
+	-v verbose="$verbose"			\
+	-v xfs_blksects="$xfs_blksects"		\
+	-v xfs_agoffsets="$xfs_agoffsets"	\
+	"$GAWKPROG" | $TRIM
+
+do_cleanup $?
