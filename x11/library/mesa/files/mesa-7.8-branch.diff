diff --git a/Makefile b/Makefile
index 84d0038..e95f941 100644
--- a/Makefile
+++ b/Makefile
@@ -180,7 +180,7 @@ ultrix-gcc:
 
 # Rules for making release tarballs
 
-VERSION=7.8.2
+VERSION=7.8.3-rc1
 DIRECTORY = Mesa-$(VERSION)
 LIB_NAME = MesaLib-$(VERSION)
 DEMO_NAME = MesaDemos-$(VERSION)
@@ -285,9 +285,6 @@ MAIN_FILES = \
 	$(DIRECTORY)/src/mesa/x86-64/*.[chS]				\
 	$(DIRECTORY)/src/mesa/x86-64/Makefile				\
 	$(DIRECTORY)/progs/Makefile					\
-	$(DIRECTORY)/progs/util/README					\
-	$(DIRECTORY)/progs/util/*.[ch]					\
-	$(DIRECTORY)/progs/util/sampleMakefile				\
 	$(DIRECTORY)/windows/VC8/
 
 ES_FILES = \
@@ -438,7 +435,10 @@ DEMO_FILES = \
 	$(DIRECTORY)/progs/glsl/*.c			\
 	$(DIRECTORY)/progs/glsl/*.frag			\
 	$(DIRECTORY)/progs/glsl/*.vert			\
-	$(DIRECTORY)/progs/glsl/*.shtest
+	$(DIRECTORY)/progs/glsl/*.shtest		\
+	$(DIRECTORY)/progs/util/README			\
+	$(DIRECTORY)/progs/util/*.[ch]			\
+	$(DIRECTORY)/progs/util/sampleMakefile
 
 GLUT_FILES = \
 	$(DIRECTORY)/include/GL/glut.h			\
diff --git a/configs/autoconf.in b/configs/autoconf.in
index fbd5faa..6218be9 100644
--- a/configs/autoconf.in
+++ b/configs/autoconf.in
@@ -26,6 +26,11 @@ INTEL_LIBS = @INTEL_LIBS@
 INTEL_CFLAGS = @INTEL_CFLAGS@
 X11_LIBS = @X11_LIBS@
 X11_CFLAGS = @X11_CFLAGS@
+GLW_CFLAGS = @GLW_CFLAGS@
+GLUT_CFLAGS = @GLUT_CFLAGS@
+
+# dlopen
+DLOPEN_LIBS = @DLOPEN_LIBS@
 
 # Assembler
 MESA_ASM_SOURCES = @MESA_ASM_SOURCES@
diff --git a/configs/default b/configs/default
index f12bec8..d4b45a3 100644
--- a/configs/default
+++ b/configs/default
@@ -121,6 +121,8 @@ APP_LIB_DEPS    = $(EXTRA_LIB_PATH) -L$(TOP)/$(LIB_DIR) -l$(GLUT_LIB) -l$(GLU_LI
 APP_LIB_DEPS = -lm
 X11_LIBS = -lX11
 
+DLOPEN_LIBS = -ldl
+
 # Installation directories (for make install)
 INSTALL_DIR = /usr/local
 INSTALL_LIB_DIR = $(INSTALL_DIR)/$(LIB_DIR)
diff --git a/configure.ac b/configure.ac
index e711634..e15371f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -398,6 +398,7 @@ dnl Check to see if dlopen is in default libraries (like Solaris, which
 dnl has it in libc), or if libdl is needed to get it.
 AC_CHECK_FUNC([dlopen], [],
     [AC_CHECK_LIB([dl], [dlopen], [DLOPEN_LIBS="-ldl"])])
+AC_SUBST([DLOPEN_LIBS])
 
 dnl See if posix_memalign is available
 AC_CHECK_FUNC([posix_memalign], [DEFINES="$DEFINES -DHAVE_POSIX_MEMALIGN"])
@@ -699,7 +700,7 @@ AC_SUBST([DRI_DRIVER_SEARCH_DIR])
 dnl Direct rendering or just indirect rendering
 AC_ARG_ENABLE([driglx-direct],
     [AS_HELP_STRING([--disable-driglx-direct],
-        [enable direct rendering in GLX for DRI @<:@default=enabled@:>@])],
+        [enable direct rendering in GLX and EGL for DRI @<:@default=enabled@:>@])],
     [driglx_direct="$enableval"],
     [driglx_direct="yes"])
 dnl Which drivers to build - default is chosen by platform
@@ -1102,10 +1103,6 @@ fi
 
 if test "x$enable_glut" = xyes; then
     SRC_DIRS="$SRC_DIRS glut/glx"
-    GLUT_CFLAGS=""
-    if test "x$GCC" = xyes; then
-        GLUT_CFLAGS="-fexceptions"
-    fi
     if test "$x11_pkgconfig" = yes; then
         PKG_CHECK_MODULES([GLUT],[x11 xmu xi])
         GLUT_PC_REQ_PRIV="x11 xmu xi"
@@ -1116,6 +1113,9 @@ if test "x$enable_glut" = xyes; then
         GLUT_PC_LIB_PRIV="$GLUT_LIB_DEPS"
         GLUT_PC_CFLAGS="$X11_INCLUDES"
     fi
+    if test "x$GCC" = xyes; then
+        GLUT_CFLAGS="$GLUT_CFLAGS -fexceptions"
+    fi
     GLUT_LIB_DEPS="$GLUT_LIB_DEPS -lm"
     GLUT_PC_LIB_PRIV="$GLUT_PC_LIB_PRIV -lm"
 
@@ -1217,6 +1217,10 @@ yes)
             if test "x$enable_egl" != xyes; then
                 AC_MSG_ERROR([cannot build egl state tracker without EGL library])
             fi
+            # define GLX_DIRECT_RENDERING even when the driver is not dri
+            if test "x$mesa_driver" != xdri -a "x$driglx_direct" = xyes; then
+                DEFINES="$DEFINES -DGLX_DIRECT_RENDERING"
+            fi
             ;;
         xorg)
             PKG_CHECK_MODULES([LIBDRM_XORG], [libdrm >= $LIBDRM_XORG_REQUIRED])
diff --git a/docs/news.html b/docs/news.html
index 92e2a18..01e2834 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -11,6 +11,14 @@
 <H1>News</H1>
 
 
+<h2>TBD, 2010</h2>
+
+<p>
+<a href="relnotes-7.8.3.html">Mesa 7.8.3</a> is released.  This is a bug-fix
+release collecting fixes since the 7.8.2 release.
+</p>
+
+
 <h2>June 16, 2010</h2>
 
 <p>
diff --git a/docs/relnotes-7.8.2.html b/docs/relnotes-7.8.2.html
index 4d7758d..1393b2e 100644
--- a/docs/relnotes-7.8.2.html
+++ b/docs/relnotes-7.8.2.html
@@ -142,7 +142,5 @@ a471807b65e49c325808ba4551be93ed  MesaGLUT-7.8.2.tar.bz2
 </ul>
 
 
-<h2>Changes</h2>
-<p>None.</p>
 </body>
 </html>
diff --git a/docs/relnotes-7.8.3.html b/docs/relnotes-7.8.3.html
new file mode 100644
index 0000000..1e9f433
--- /dev/null
+++ b/docs/relnotes-7.8.3.html
@@ -0,0 +1,89 @@
+<HTML>
+
+<TITLE>Mesa Release Notes</TITLE>
+
+<head><link rel="stylesheet" type="text/css" href="mesa.css"></head>
+
+<BODY>
+
+<body bgcolor="#eeeeee">
+
+<H1>Mesa 7.8.3 Release Notes / (date tbd)</H1>
+
+<p>
+Mesa 7.8.3 is a bug fix release which fixes bugs found since the 7.8.2 release.
+</p>
+<p>
+Mesa 7.8.3 implements the OpenGL 2.1 API, but the version reported by
+glGetString(GL_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 2.1.
+</p>
+<p>
+See the <a href="install.html">Compiling/Installing page</a> for prerequisites
+for DRI hardware acceleration.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+x  MesaLib-7.8.3.tar.gz
+x  MesaLib-7.8.3.tar.bz2
+x  MesaLib-7.8.3.zip
+x  MesaDemos-7.8.3.tar.gz
+x  MesaDemos-7.8.3.tar.bz2
+x  MesaDemos-7.8.3.zip
+x  MesaGLUT-7.8.3.tar.gz
+x  MesaGLUT-7.8.3.tar.bz2
+x  MesaGLUT-7.8.3.zip
+</pre>
+
+
+<h2>New features</h2>
+<p>None.</p>
+
+
+<h2>Changes</h2>
+<ul>
+<li>The radeon driver should use less memory when searching for a valid mip
+image.</li>
+</ul>
+
+
+<h2>Bug fixes</h2>
+<ul>
+<li>Fix unsupported FB with D24S8 (bug 
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=23670">29116</a>)</li>
+<li>Fix ReadPixels crash when reading depth/stencil from an FBO</li>
+<li>Fixed a bug rendering to 16-bit buffers using swrast.</li>
+<li>Fixed a state tracker/TGSI bug that caused crashes when using Windows'
+    memory debugging features.</li>
+<li>Fixed an issue rendering to 32-bit channels with swrast (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=29487">29487</a>)</li>
+<li>GLSL: fix indirect <TT>gl_TextureMatrix</TT> addressing (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=28967">28967</a>)</li>
+<li>GLSL: fix for bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27216">27216</a></li>
+<li>GLSL: fix zw fragcoord entries in some cases (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=29183">29183</a>)</li>
+<li>Fix texture env generation in some cases (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=28169">28169</a>)</li>
+<li>osmesa: a fix for calling <TT>OSMesaMakeCurrent</TT> twice was applied (bug 
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=10966">10966</a></li>
+<li>A bug was fixed which could cause Mesa to ignore the
+    <TT>MESA_EXTENSION_OVERRIDE</TT> environment variable.</li>
+<li>A bug related to specular highlights on backfaces was fixed.</li>
+<li>A radeon-specific issue with <TT>glCopyTex(Sub)Image</TT> was
+    corrected.</li>
+<li>radeon/wine: flush command stream in more cases, fixing wine d3d9
+    tests.</li>
+<li>r600: fix sin+cos normalization.</li>
+<li>r600: (properly) ignore <TT>GL_COORD_REPLACE</TT> when point sprites are
+    disabled.</li>
+<li>radeon: avoid flushing when the context is not current.</li>
+<li>r300c: a bug affecting unaligned BOs was fixed.</li>
+<li>r300c: a hardlock caused by ARB_half_float_vertex incorrectly advertised on some chipsets.</li>
+</ul>
+
+
+</body>
+</html>
diff --git a/docs/relnotes.html b/docs/relnotes.html
index 39b02b8..46f6469 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -13,6 +13,7 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <UL>
+<LI><A HREF="relnotes-7.8.3.html">7.8.3 release notes</A>
 <LI><A HREF="relnotes-7.8.2.html">7.8.2 release notes</A>
 <LI><A HREF="relnotes-7.8.1.html">7.8.1 release notes</A>
 <LI><A HREF="relnotes-7.8.html">7.8 release notes</A>
diff --git a/include/GL/gl_mangle.h b/include/GL/gl_mangle.h
index 43d2e89..15589d8 100644
--- a/include/GL/gl_mangle.h
+++ b/include/GL/gl_mangle.h
@@ -56,6 +56,7 @@
 #define glBeginOcclusionQueryNV		MANGLE(BeginOcclusionQueryNV)
 #define glBeginPerfMonitorAMD		MANGLE(BeginPerfMonitorAMD)
 #define glBeginQueryARB		MANGLE(BeginQueryARB)
+#define glBeginQueryIndexed		MANGLE(BeginQueryIndexed)
 #define glBeginQuery		MANGLE(BeginQuery)
 #define glBeginTransformFeedbackEXT		MANGLE(BeginTransformFeedbackEXT)
 #define glBeginTransformFeedback		MANGLE(BeginTransformFeedback)
@@ -75,6 +76,7 @@
 #define glBindBufferRange		MANGLE(BindBufferRange)
 #define glBindBufferRangeNV		MANGLE(BindBufferRangeNV)
 #define glBindFragDataLocationEXT		MANGLE(BindFragDataLocationEXT)
+#define glBindFragDataLocationIndexed		MANGLE(BindFragDataLocationIndexed)
 #define glBindFragDataLocation		MANGLE(BindFragDataLocation)
 #define glBindFragmentShaderATI		MANGLE(BindFragmentShaderATI)
 #define glBindFramebufferEXT		MANGLE(BindFramebufferEXT)
@@ -87,10 +89,12 @@
 #define glBindProgramNV		MANGLE(BindProgramNV)
 #define glBindRenderbufferEXT		MANGLE(BindRenderbufferEXT)
 #define glBindRenderbuffer		MANGLE(BindRenderbuffer)
+#define glBindSampler		MANGLE(BindSampler)
 #define glBindTexGenParameterEXT		MANGLE(BindTexGenParameterEXT)
 #define glBindTextureEXT		MANGLE(BindTextureEXT)
 #define glBindTexture		MANGLE(BindTexture)
 #define glBindTextureUnitParameterEXT		MANGLE(BindTextureUnitParameterEXT)
+#define glBindTransformFeedback		MANGLE(BindTransformFeedback)
 #define glBindTransformFeedbackNV		MANGLE(BindTransformFeedbackNV)
 #define glBindVertexArrayAPPLE		MANGLE(BindVertexArrayAPPLE)
 #define glBindVertexArray		MANGLE(BindVertexArray)
@@ -215,6 +219,10 @@
 #define glColorMaskIndexedEXT		MANGLE(ColorMaskIndexedEXT)
 #define glColorMask		MANGLE(ColorMask)
 #define glColorMaterial		MANGLE(ColorMaterial)
+#define glColorP3ui		MANGLE(ColorP3ui)
+#define glColorP3uiv		MANGLE(ColorP3uiv)
+#define glColorP4ui		MANGLE(ColorP4ui)
+#define glColorP4uiv		MANGLE(ColorP4uiv)
 #define glColorPointerEXT		MANGLE(ColorPointerEXT)
 #define glColorPointerListIBM		MANGLE(ColorPointerListIBM)
 #define glColorPointer		MANGLE(ColorPointer)
@@ -236,6 +244,7 @@
 #define glCombinerParameterivNV		MANGLE(CombinerParameterivNV)
 #define glCombinerStageParameterfvNV		MANGLE(CombinerStageParameterfvNV)
 #define glCompileShaderARB		MANGLE(CompileShaderARB)
+#define glCompileShaderIncludeARB		MANGLE(CompileShaderIncludeARB)
 #define glCompileShader		MANGLE(CompileShader)
 #define glCompressedMultiTexImage1DEXT		MANGLE(CompressedMultiTexImage1DEXT)
 #define glCompressedMultiTexImage2DEXT		MANGLE(CompressedMultiTexImage2DEXT)
@@ -326,6 +335,7 @@
 #define glDeleteFramebuffersEXT		MANGLE(DeleteFramebuffersEXT)
 #define glDeleteFramebuffers		MANGLE(DeleteFramebuffers)
 #define glDeleteLists		MANGLE(DeleteLists)
+#define glDeleteNamedStringARB		MANGLE(DeleteNamedStringARB)
 #define glDeleteObjectARB		MANGLE(DeleteObjectARB)
 #define glDeleteOcclusionQueriesNV		MANGLE(DeleteOcclusionQueriesNV)
 #define glDeletePerfMonitorsAMD		MANGLE(DeletePerfMonitorsAMD)
@@ -336,10 +346,12 @@
 #define glDeleteQueries		MANGLE(DeleteQueries)
 #define glDeleteRenderbuffersEXT		MANGLE(DeleteRenderbuffersEXT)
 #define glDeleteRenderbuffers		MANGLE(DeleteRenderbuffers)
+#define glDeleteSamplers		MANGLE(DeleteSamplers)
 #define glDeleteShader		MANGLE(DeleteShader)
 #define glDeleteSync		MANGLE(DeleteSync)
 #define glDeleteTexturesEXT		MANGLE(DeleteTexturesEXT)
 #define glDeleteTextures		MANGLE(DeleteTextures)
+#define glDeleteTransformFeedbacks		MANGLE(DeleteTransformFeedbacks)
 #define glDeleteTransformFeedbacksNV		MANGLE(DeleteTransformFeedbacksNV)
 #define glDeleteVertexArraysAPPLE		MANGLE(DeleteVertexArraysAPPLE)
 #define glDeleteVertexArrays		MANGLE(DeleteVertexArrays)
@@ -363,6 +375,7 @@
 #define glDisableVertexAttribArrayARB		MANGLE(DisableVertexAttribArrayARB)
 #define glDisableVertexAttribArray		MANGLE(DisableVertexAttribArray)
 #define glDrawArraysEXT		MANGLE(DrawArraysEXT)
+#define glDrawArraysIndirect		MANGLE(DrawArraysIndirect)
 #define glDrawArraysInstancedARB		MANGLE(DrawArraysInstancedARB)
 #define glDrawArraysInstancedEXT		MANGLE(DrawArraysInstancedEXT)
 #define glDrawArraysInstanced		MANGLE(DrawArraysInstanced)
@@ -374,6 +387,7 @@
 #define glDrawElementArrayAPPLE		MANGLE(DrawElementArrayAPPLE)
 #define glDrawElementArrayATI		MANGLE(DrawElementArrayATI)
 #define glDrawElementsBaseVertex		MANGLE(DrawElementsBaseVertex)
+#define glDrawElementsIndirect		MANGLE(DrawElementsIndirect)
 #define glDrawElementsInstancedARB		MANGLE(DrawElementsInstancedARB)
 #define glDrawElementsInstancedBaseVertex		MANGLE(DrawElementsInstancedBaseVertex)
 #define glDrawElementsInstancedEXT		MANGLE(DrawElementsInstancedEXT)
@@ -386,7 +400,9 @@
 #define glDrawRangeElementsBaseVertex		MANGLE(DrawRangeElementsBaseVertex)
 #define glDrawRangeElementsEXT		MANGLE(DrawRangeElementsEXT)
 #define glDrawRangeElements		MANGLE(DrawRangeElements)
+#define glDrawTransformFeedback		MANGLE(DrawTransformFeedback)
 #define glDrawTransformFeedbackNV		MANGLE(DrawTransformFeedbackNV)
+#define glDrawTransformFeedbackStream		MANGLE(DrawTransformFeedbackStream)
 #define glEdgeFlagFormatNV		MANGLE(EdgeFlagFormatNV)
 #define glEdgeFlag		MANGLE(EdgeFlag)
 #define glEdgeFlagPointerEXT		MANGLE(EdgeFlagPointerEXT)
@@ -414,6 +430,7 @@
 #define glEndOcclusionQueryNV		MANGLE(EndOcclusionQueryNV)
 #define glEndPerfMonitorAMD		MANGLE(EndPerfMonitorAMD)
 #define glEndQueryARB		MANGLE(EndQueryARB)
+#define glEndQueryIndexed		MANGLE(EndQueryIndexed)
 #define glEndQuery		MANGLE(EndQuery)
 #define glEndTransformFeedbackEXT		MANGLE(EndTransformFeedbackEXT)
 #define glEndTransformFeedback		MANGLE(EndTransformFeedback)
@@ -498,7 +515,6 @@
 #define glFramebufferTextureEXT		MANGLE(FramebufferTextureEXT)
 #define glFramebufferTextureFaceARB		MANGLE(FramebufferTextureFaceARB)
 #define glFramebufferTextureFaceEXT		MANGLE(FramebufferTextureFaceEXT)
-#define glFramebufferTextureFace		MANGLE(FramebufferTextureFace)
 #define glFramebufferTextureLayerARB		MANGLE(FramebufferTextureLayerARB)
 #define glFramebufferTextureLayerEXT		MANGLE(FramebufferTextureLayerEXT)
 #define glFramebufferTextureLayer		MANGLE(FramebufferTextureLayer)
@@ -529,15 +545,20 @@
 #define glGenQueries		MANGLE(GenQueries)
 #define glGenRenderbuffersEXT		MANGLE(GenRenderbuffersEXT)
 #define glGenRenderbuffers		MANGLE(GenRenderbuffers)
+#define glGenSamplers		MANGLE(GenSamplers)
 #define glGenSymbolsEXT		MANGLE(GenSymbolsEXT)
 #define glGenTexturesEXT		MANGLE(GenTexturesEXT)
 #define glGenTextures		MANGLE(GenTextures)
+#define glGenTransformFeedbacks		MANGLE(GenTransformFeedbacks)
 #define glGenTransformFeedbacksNV		MANGLE(GenTransformFeedbacksNV)
 #define glGenVertexArraysAPPLE		MANGLE(GenVertexArraysAPPLE)
 #define glGenVertexArrays		MANGLE(GenVertexArrays)
 #define glGenVertexShadersEXT		MANGLE(GenVertexShadersEXT)
 #define glGetActiveAttribARB		MANGLE(GetActiveAttribARB)
 #define glGetActiveAttrib		MANGLE(GetActiveAttrib)
+#define glGetActiveSubroutineName		MANGLE(GetActiveSubroutineName)
+#define glGetActiveSubroutineUniformiv		MANGLE(GetActiveSubroutineUniformiv)
+#define glGetActiveSubroutineUniformName		MANGLE(GetActiveSubroutineUniformName)
 #define glGetActiveUniformARB		MANGLE(GetActiveUniformARB)
 #define glGetActiveUniformBlockiv		MANGLE(GetActiveUniformBlockiv)
 #define glGetActiveUniformBlockName		MANGLE(GetActiveUniformBlockName)
@@ -599,6 +620,7 @@
 #define glGetFloatIndexedvEXT		MANGLE(GetFloatIndexedvEXT)
 #define glGetFloatv		MANGLE(GetFloatv)
 #define glGetFogFuncSGIS		MANGLE(GetFogFuncSGIS)
+#define glGetFragDataIndex		MANGLE(GetFragDataIndex)
 #define glGetFragDataLocationEXT		MANGLE(GetFragDataLocationEXT)
 #define glGetFragDataLocation		MANGLE(GetFragDataLocation)
 #define glGetFragmentLightfvSGIX		MANGLE(GetFragmentLightfvSGIX)
@@ -678,6 +700,8 @@
 #define glGetNamedProgramLocalParameterIuivEXT		MANGLE(GetNamedProgramLocalParameterIuivEXT)
 #define glGetNamedProgramStringEXT		MANGLE(GetNamedProgramStringEXT)
 #define glGetNamedRenderbufferParameterivEXT		MANGLE(GetNamedRenderbufferParameterivEXT)
+#define glGetNamedStringARB		MANGLE(GetNamedStringARB)
+#define glGetNamedStringivARB		MANGLE(GetNamedStringivARB)
 #define glGetObjectBufferfvATI		MANGLE(GetObjectBufferfvATI)
 #define glGetObjectBufferivATI		MANGLE(GetObjectBufferivATI)
 #define glGetObjectParameterfvARB		MANGLE(GetObjectParameterfvARB)
@@ -717,18 +741,26 @@
 #define glGetProgramParameterdvNV		MANGLE(GetProgramParameterdvNV)
 #define glGetProgramParameterfvNV		MANGLE(GetProgramParameterfvNV)
 #define glGetProgramRegisterfvMESA		MANGLE(GetProgramRegisterfvMESA)
+#define glGetProgramStageiv		MANGLE(GetProgramStageiv)
 #define glGetProgramStringARB		MANGLE(GetProgramStringARB)
 #define glGetProgramStringNV		MANGLE(GetProgramStringNV)
+#define glGetQueryIndexediv		MANGLE(GetQueryIndexediv)
 #define glGetQueryivARB		MANGLE(GetQueryivARB)
 #define glGetQueryiv		MANGLE(GetQueryiv)
 #define glGetQueryObjecti64vEXT		MANGLE(GetQueryObjecti64vEXT)
+#define glGetQueryObjecti64v		MANGLE(GetQueryObjecti64v)
 #define glGetQueryObjectivARB		MANGLE(GetQueryObjectivARB)
 #define glGetQueryObjectiv		MANGLE(GetQueryObjectiv)
 #define glGetQueryObjectui64vEXT		MANGLE(GetQueryObjectui64vEXT)
+#define glGetQueryObjectui64v		MANGLE(GetQueryObjectui64v)
 #define glGetQueryObjectuivARB		MANGLE(GetQueryObjectuivARB)
 #define glGetQueryObjectuiv		MANGLE(GetQueryObjectuiv)
 #define glGetRenderbufferParameterivEXT		MANGLE(GetRenderbufferParameterivEXT)
 #define glGetRenderbufferParameteriv		MANGLE(GetRenderbufferParameteriv)
+#define glGetSamplerParameterfv		MANGLE(GetSamplerParameterfv)
+#define glGetSamplerParameterIfv		MANGLE(GetSamplerParameterIfv)
+#define glGetSamplerParameterIiv		MANGLE(GetSamplerParameterIiv)
+#define glGetSamplerParameteriv		MANGLE(GetSamplerParameteriv)
 #define glGetSeparableFilterEXT		MANGLE(GetSeparableFilterEXT)
 #define glGetSeparableFilter		MANGLE(GetSeparableFilter)
 #define glGetShaderInfoLog		MANGLE(GetShaderInfoLog)
@@ -738,6 +770,8 @@
 #define glGetSharpenTexFuncSGIS		MANGLE(GetSharpenTexFuncSGIS)
 #define glGetStringi		MANGLE(GetStringi)
 #define glGetString		MANGLE(GetString)
+#define glGetSubroutineIndex		MANGLE(GetSubroutineIndex)
+#define glGetSubroutineUniformLocation		MANGLE(GetSubroutineUniformLocation)
 #define glGetSynciv		MANGLE(GetSynciv)
 #define glGetTexBumpParameterfvATI		MANGLE(GetTexBumpParameterfvATI)
 #define glGetTexBumpParameterivATI		MANGLE(GetTexBumpParameterivATI)
@@ -770,6 +804,7 @@
 #define glGetTransformFeedbackVaryingNV		MANGLE(GetTransformFeedbackVaryingNV)
 #define glGetUniformBlockIndex		MANGLE(GetUniformBlockIndex)
 #define glGetUniformBufferSizeEXT		MANGLE(GetUniformBufferSizeEXT)
+#define glGetUniformdv		MANGLE(GetUniformdv)
 #define glGetUniformfvARB		MANGLE(GetUniformfvARB)
 #define glGetUniformfv		MANGLE(GetUniformfv)
 #define glGetUniformIndices		MANGLE(GetUniformIndices)
@@ -778,6 +813,7 @@
 #define glGetUniformLocationARB		MANGLE(GetUniformLocationARB)
 #define glGetUniformLocation		MANGLE(GetUniformLocation)
 #define glGetUniformOffsetEXT		MANGLE(GetUniformOffsetEXT)
+#define glGetUniformSubroutineuiv		MANGLE(GetUniformSubroutineuiv)
 #define glGetUniformui64vNV		MANGLE(GetUniformui64vNV)
 #define glGetUniformuivEXT		MANGLE(GetUniformuivEXT)
 #define glGetUniformuiv		MANGLE(GetUniformuiv)
@@ -865,6 +901,7 @@
 #define glIsFramebuffer		MANGLE(IsFramebuffer)
 #define glIsList		MANGLE(IsList)
 #define glIsNamedBufferResidentNV		MANGLE(IsNamedBufferResidentNV)
+#define glIsNamedStringARB		MANGLE(IsNamedStringARB)
 #define glIsObjectBufferATI		MANGLE(IsObjectBufferATI)
 #define glIsOcclusionQueryNV		MANGLE(IsOcclusionQueryNV)
 #define glIsProgramARB		MANGLE(IsProgramARB)
@@ -874,10 +911,12 @@
 #define glIsQuery		MANGLE(IsQuery)
 #define glIsRenderbufferEXT		MANGLE(IsRenderbufferEXT)
 #define glIsRenderbuffer		MANGLE(IsRenderbuffer)
+#define glIsSampler		MANGLE(IsSampler)
 #define glIsShader		MANGLE(IsShader)
 #define glIsSync		MANGLE(IsSync)
 #define glIsTextureEXT		MANGLE(IsTextureEXT)
 #define glIsTexture		MANGLE(IsTexture)
+#define glIsTransformFeedback		MANGLE(IsTransformFeedback)
 #define glIsTransformFeedbackNV		MANGLE(IsTransformFeedbackNV)
 #define glIsVariantEnabledEXT		MANGLE(IsVariantEnabledEXT)
 #define glIsVertexArrayAPPLE		MANGLE(IsVertexArrayAPPLE)
@@ -915,6 +954,8 @@
 #define glLogicOp		MANGLE(LogicOp)
 #define glMakeBufferNonResidentNV		MANGLE(MakeBufferNonResidentNV)
 #define glMakeBufferResidentNV		MANGLE(MakeBufferResidentNV)
+#define glMakeNamedBufferNonResidentNV		MANGLE(MakeNamedBufferNonResidentNV)
+#define glMakeNamedBufferResidentNV		MANGLE(MakeNamedBufferResidentNV)
 #define glMap1d		MANGLE(Map1d)
 #define glMap1f		MANGLE(Map1f)
 #define glMap2d		MANGLE(Map2d)
@@ -1048,6 +1089,14 @@
 #define glMultiTexCoord4s		MANGLE(MultiTexCoord4s)
 #define glMultiTexCoord4svARB		MANGLE(MultiTexCoord4svARB)
 #define glMultiTexCoord4sv		MANGLE(MultiTexCoord4sv)
+#define glMultiTexCoordP1ui		MANGLE(MultiTexCoordP1ui)
+#define glMultiTexCoordP1uiv		MANGLE(MultiTexCoordP1uiv)
+#define glMultiTexCoordP2ui		MANGLE(MultiTexCoordP2ui)
+#define glMultiTexCoordP2uiv		MANGLE(MultiTexCoordP2uiv)
+#define glMultiTexCoordP3ui		MANGLE(MultiTexCoordP3ui)
+#define glMultiTexCoordP3uiv		MANGLE(MultiTexCoordP3uiv)
+#define glMultiTexCoordP4ui		MANGLE(MultiTexCoordP4ui)
+#define glMultiTexCoordP4uiv		MANGLE(MultiTexCoordP4uiv)
 #define glMultiTexCoordPointerEXT		MANGLE(MultiTexCoordPointerEXT)
 #define glMultiTexEnvfEXT		MANGLE(MultiTexEnvfEXT)
 #define glMultiTexEnvfvEXT		MANGLE(MultiTexEnvfvEXT)
@@ -1087,8 +1136,6 @@
 #define glNamedFramebufferTextureEXT		MANGLE(NamedFramebufferTextureEXT)
 #define glNamedFramebufferTextureFaceEXT		MANGLE(NamedFramebufferTextureFaceEXT)
 #define glNamedFramebufferTextureLayerEXT		MANGLE(NamedFramebufferTextureLayerEXT)
-#define glNamedMakeBufferNonResidentNV		MANGLE(NamedMakeBufferNonResidentNV)
-#define glNamedMakeBufferResidentNV		MANGLE(NamedMakeBufferResidentNV)
 #define glNamedProgramLocalParameter4dEXT		MANGLE(NamedProgramLocalParameter4dEXT)
 #define glNamedProgramLocalParameter4dvEXT		MANGLE(NamedProgramLocalParameter4dvEXT)
 #define glNamedProgramLocalParameter4fEXT		MANGLE(NamedProgramLocalParameter4fEXT)
@@ -1104,6 +1151,7 @@
 #define glNamedRenderbufferStorageEXT		MANGLE(NamedRenderbufferStorageEXT)
 #define glNamedRenderbufferStorageMultisampleCoverageEXT		MANGLE(NamedRenderbufferStorageMultisampleCoverageEXT)
 #define glNamedRenderbufferStorageMultisampleEXT		MANGLE(NamedRenderbufferStorageMultisampleEXT)
+#define glNamedStringARB		MANGLE(NamedStringARB)
 #define glNewList		MANGLE(NewList)
 #define glNewObjectBufferATI		MANGLE(NewObjectBufferATI)
 #define glNormal3b		MANGLE(Normal3b)
@@ -1121,6 +1169,8 @@
 #define glNormal3s		MANGLE(Normal3s)
 #define glNormal3sv		MANGLE(Normal3sv)
 #define glNormalFormatNV		MANGLE(NormalFormatNV)
+#define glNormalP3ui		MANGLE(NormalP3ui)
+#define glNormalP3uiv		MANGLE(NormalP3uiv)
 #define glNormalPointerEXT		MANGLE(NormalPointerEXT)
 #define glNormalPointerListIBM		MANGLE(NormalPointerListIBM)
 #define glNormalPointer		MANGLE(NormalPointer)
@@ -1140,6 +1190,9 @@
 #define glOrtho		MANGLE(Ortho)
 #define glPassTexCoordATI		MANGLE(PassTexCoordATI)
 #define glPassThrough		MANGLE(PassThrough)
+#define glPatchParameterfv		MANGLE(PatchParameterfv)
+#define glPatchParameteri		MANGLE(PatchParameteri)
+#define glPauseTransformFeedback		MANGLE(PauseTransformFeedback)
 #define glPauseTransformFeedbackNV		MANGLE(PauseTransformFeedbackNV)
 #define glPixelDataRangeNV		MANGLE(PixelDataRangeNV)
 #define glPixelMapfv		MANGLE(PixelMapfv)
@@ -1231,38 +1284,55 @@
 #define glProgramParameters4dvNV		MANGLE(ProgramParameters4dvNV)
 #define glProgramParameters4fvNV		MANGLE(ProgramParameters4fvNV)
 #define glProgramStringARB		MANGLE(ProgramStringARB)
+#define glProgramUniform1dEXT		MANGLE(ProgramUniform1dEXT)
+#define glProgramUniform1dvEXT		MANGLE(ProgramUniform1dvEXT)
 #define glProgramUniform1fEXT		MANGLE(ProgramUniform1fEXT)
 #define glProgramUniform1fvEXT		MANGLE(ProgramUniform1fvEXT)
 #define glProgramUniform1iEXT		MANGLE(ProgramUniform1iEXT)
 #define glProgramUniform1ivEXT		MANGLE(ProgramUniform1ivEXT)
 #define glProgramUniform1uiEXT		MANGLE(ProgramUniform1uiEXT)
 #define glProgramUniform1uivEXT		MANGLE(ProgramUniform1uivEXT)
+#define glProgramUniform2dEXT		MANGLE(ProgramUniform2dEXT)
+#define glProgramUniform2dvEXT		MANGLE(ProgramUniform2dvEXT)
 #define glProgramUniform2fEXT		MANGLE(ProgramUniform2fEXT)
 #define glProgramUniform2fvEXT		MANGLE(ProgramUniform2fvEXT)
 #define glProgramUniform2iEXT		MANGLE(ProgramUniform2iEXT)
 #define glProgramUniform2ivEXT		MANGLE(ProgramUniform2ivEXT)
 #define glProgramUniform2uiEXT		MANGLE(ProgramUniform2uiEXT)
 #define glProgramUniform2uivEXT		MANGLE(ProgramUniform2uivEXT)
+#define glProgramUniform3dEXT		MANGLE(ProgramUniform3dEXT)
+#define glProgramUniform3dvEXT		MANGLE(ProgramUniform3dvEXT)
 #define glProgramUniform3fEXT		MANGLE(ProgramUniform3fEXT)
 #define glProgramUniform3fvEXT		MANGLE(ProgramUniform3fvEXT)
 #define glProgramUniform3iEXT		MANGLE(ProgramUniform3iEXT)
 #define glProgramUniform3ivEXT		MANGLE(ProgramUniform3ivEXT)
 #define glProgramUniform3uiEXT		MANGLE(ProgramUniform3uiEXT)
 #define glProgramUniform3uivEXT		MANGLE(ProgramUniform3uivEXT)
+#define glProgramUniform4dEXT		MANGLE(ProgramUniform4dEXT)
+#define glProgramUniform4dvEXT		MANGLE(ProgramUniform4dvEXT)
 #define glProgramUniform4fEXT		MANGLE(ProgramUniform4fEXT)
 #define glProgramUniform4fvEXT		MANGLE(ProgramUniform4fvEXT)
 #define glProgramUniform4iEXT		MANGLE(ProgramUniform4iEXT)
 #define glProgramUniform4ivEXT		MANGLE(ProgramUniform4ivEXT)
 #define glProgramUniform4uiEXT		MANGLE(ProgramUniform4uiEXT)
 #define glProgramUniform4uivEXT		MANGLE(ProgramUniform4uivEXT)
+#define glProgramUniformMatrix2dvEXT		MANGLE(ProgramUniformMatrix2dvEXT)
 #define glProgramUniformMatrix2fvEXT		MANGLE(ProgramUniformMatrix2fvEXT)
+#define glProgramUniformMatrix2x3dvEXT		MANGLE(ProgramUniformMatrix2x3dvEXT)
 #define glProgramUniformMatrix2x3fvEXT		MANGLE(ProgramUniformMatrix2x3fvEXT)
+#define glProgramUniformMatrix2x4dvEXT		MANGLE(ProgramUniformMatrix2x4dvEXT)
 #define glProgramUniformMatrix2x4fvEXT		MANGLE(ProgramUniformMatrix2x4fvEXT)
+#define glProgramUniformMatrix3dvEXT		MANGLE(ProgramUniformMatrix3dvEXT)
 #define glProgramUniformMatrix3fvEXT		MANGLE(ProgramUniformMatrix3fvEXT)
+#define glProgramUniformMatrix3x2dvEXT		MANGLE(ProgramUniformMatrix3x2dvEXT)
 #define glProgramUniformMatrix3x2fvEXT		MANGLE(ProgramUniformMatrix3x2fvEXT)
+#define glProgramUniformMatrix3x4dvEXT		MANGLE(ProgramUniformMatrix3x4dvEXT)
 #define glProgramUniformMatrix3x4fvEXT		MANGLE(ProgramUniformMatrix3x4fvEXT)
+#define glProgramUniformMatrix4dvEXT		MANGLE(ProgramUniformMatrix4dvEXT)
 #define glProgramUniformMatrix4fvEXT		MANGLE(ProgramUniformMatrix4fvEXT)
+#define glProgramUniformMatrix4x2dvEXT		MANGLE(ProgramUniformMatrix4x2dvEXT)
 #define glProgramUniformMatrix4x2fvEXT		MANGLE(ProgramUniformMatrix4x2fvEXT)
+#define glProgramUniformMatrix4x3dvEXT		MANGLE(ProgramUniformMatrix4x3dvEXT)
 #define glProgramUniformMatrix4x3fvEXT		MANGLE(ProgramUniformMatrix4x3fvEXT)
 #define glProgramUniformui64NV		MANGLE(ProgramUniformui64NV)
 #define glProgramUniformui64vNV		MANGLE(ProgramUniformui64vNV)
@@ -1274,6 +1344,7 @@
 #define glPushClientAttrib		MANGLE(PushClientAttrib)
 #define glPushMatrix		MANGLE(PushMatrix)
 #define glPushName		MANGLE(PushName)
+#define glQueryCounter		MANGLE(QueryCounter)
 #define glRasterPos2d		MANGLE(RasterPos2d)
 #define glRasterPos2dv		MANGLE(RasterPos2dv)
 #define glRasterPos2f		MANGLE(RasterPos2f)
@@ -1345,6 +1416,7 @@
 #define glResetMinmaxEXT		MANGLE(ResetMinmaxEXT)
 #define glResetMinmax		MANGLE(ResetMinmax)
 #define glResizeBuffersMESA		MANGLE(ResizeBuffersMESA)
+#define glResumeTransformFeedback		MANGLE(ResumeTransformFeedback)
 #define glResumeTransformFeedbackNV		MANGLE(ResumeTransformFeedbackNV)
 #define glRotated		MANGLE(Rotated)
 #define glRotatef		MANGLE(Rotatef)
@@ -1357,6 +1429,12 @@
 #define glSampleMaskSGIS		MANGLE(SampleMaskSGIS)
 #define glSamplePatternEXT		MANGLE(SamplePatternEXT)
 #define glSamplePatternSGIS		MANGLE(SamplePatternSGIS)
+#define glSamplerParameterf		MANGLE(SamplerParameterf)
+#define glSamplerParameterfv		MANGLE(SamplerParameterfv)
+#define glSamplerParameterIiv		MANGLE(SamplerParameterIiv)
+#define glSamplerParameteri		MANGLE(SamplerParameteri)
+#define glSamplerParameterIuiv		MANGLE(SamplerParameterIuiv)
+#define glSamplerParameteriv		MANGLE(SamplerParameteriv)
 #define glScaled		MANGLE(Scaled)
 #define glScalef		MANGLE(Scalef)
 #define glScissor		MANGLE(Scissor)
@@ -1395,6 +1473,8 @@
 #define glSecondaryColor3usvEXT		MANGLE(SecondaryColor3usvEXT)
 #define glSecondaryColor3usv		MANGLE(SecondaryColor3usv)
 #define glSecondaryColorFormatNV		MANGLE(SecondaryColorFormatNV)
+#define glSecondaryColorP3ui		MANGLE(SecondaryColorP3ui)
+#define glSecondaryColorP3uiv		MANGLE(SecondaryColorP3uiv)
 #define glSecondaryColorPointerEXT		MANGLE(SecondaryColorPointerEXT)
 #define glSecondaryColorPointerListIBM		MANGLE(SecondaryColorPointerListIBM)
 #define glSecondaryColorPointer		MANGLE(SecondaryColorPointer)
@@ -1509,6 +1589,14 @@
 #define glTexCoord4s		MANGLE(TexCoord4s)
 #define glTexCoord4sv		MANGLE(TexCoord4sv)
 #define glTexCoordFormatNV		MANGLE(TexCoordFormatNV)
+#define glTexCoordP1ui		MANGLE(TexCoordP1ui)
+#define glTexCoordP1uiv		MANGLE(TexCoordP1uiv)
+#define glTexCoordP2ui		MANGLE(TexCoordP2ui)
+#define glTexCoordP2uiv		MANGLE(TexCoordP2uiv)
+#define glTexCoordP3ui		MANGLE(TexCoordP3ui)
+#define glTexCoordP3uiv		MANGLE(TexCoordP3uiv)
+#define glTexCoordP4ui		MANGLE(TexCoordP4ui)
+#define glTexCoordP4uiv		MANGLE(TexCoordP4uiv)
 #define glTexCoordPointerEXT		MANGLE(TexCoordPointerEXT)
 #define glTexCoordPointerListIBM		MANGLE(TexCoordPointerListIBM)
 #define glTexCoordPointer		MANGLE(TexCoordPointer)
@@ -1574,6 +1662,8 @@
 #define glTransformFeedbackVaryingsNV		MANGLE(TransformFeedbackVaryingsNV)
 #define glTranslated		MANGLE(Translated)
 #define glTranslatef		MANGLE(Translatef)
+#define glUniform1d		MANGLE(Uniform1d)
+#define glUniform1dv		MANGLE(Uniform1dv)
 #define glUniform1fARB		MANGLE(Uniform1fARB)
 #define glUniform1f		MANGLE(Uniform1f)
 #define glUniform1fvARB		MANGLE(Uniform1fvARB)
@@ -1586,6 +1676,8 @@
 #define glUniform1ui		MANGLE(Uniform1ui)
 #define glUniform1uivEXT		MANGLE(Uniform1uivEXT)
 #define glUniform1uiv		MANGLE(Uniform1uiv)
+#define glUniform2d		MANGLE(Uniform2d)
+#define glUniform2dv		MANGLE(Uniform2dv)
 #define glUniform2fARB		MANGLE(Uniform2fARB)
 #define glUniform2f		MANGLE(Uniform2f)
 #define glUniform2fvARB		MANGLE(Uniform2fvARB)
@@ -1598,6 +1690,8 @@
 #define glUniform2ui		MANGLE(Uniform2ui)
 #define glUniform2uivEXT		MANGLE(Uniform2uivEXT)
 #define glUniform2uiv		MANGLE(Uniform2uiv)
+#define glUniform3d		MANGLE(Uniform3d)
+#define glUniform3dv		MANGLE(Uniform3dv)
 #define glUniform3fARB		MANGLE(Uniform3fARB)
 #define glUniform3f		MANGLE(Uniform3f)
 #define glUniform3fvARB		MANGLE(Uniform3fvARB)
@@ -1610,6 +1704,8 @@
 #define glUniform3ui		MANGLE(Uniform3ui)
 #define glUniform3uivEXT		MANGLE(Uniform3uivEXT)
 #define glUniform3uiv		MANGLE(Uniform3uiv)
+#define glUniform4d		MANGLE(Uniform4d)
+#define glUniform4dv		MANGLE(Uniform4dv)
 #define glUniform4fARB		MANGLE(Uniform4fARB)
 #define glUniform4f		MANGLE(Uniform4f)
 #define glUniform4fvARB		MANGLE(Uniform4fvARB)
@@ -1624,18 +1720,28 @@
 #define glUniform4uiv		MANGLE(Uniform4uiv)
 #define glUniformBlockBinding		MANGLE(UniformBlockBinding)
 #define glUniformBufferEXT		MANGLE(UniformBufferEXT)
+#define glUniformMatrix2dv		MANGLE(UniformMatrix2dv)
 #define glUniformMatrix2fvARB		MANGLE(UniformMatrix2fvARB)
 #define glUniformMatrix2fv		MANGLE(UniformMatrix2fv)
+#define glUniformMatrix2x3dv		MANGLE(UniformMatrix2x3dv)
 #define glUniformMatrix2x3fv		MANGLE(UniformMatrix2x3fv)
+#define glUniformMatrix2x4dv		MANGLE(UniformMatrix2x4dv)
 #define glUniformMatrix2x4fv		MANGLE(UniformMatrix2x4fv)
+#define glUniformMatrix3dv		MANGLE(UniformMatrix3dv)
 #define glUniformMatrix3fvARB		MANGLE(UniformMatrix3fvARB)
 #define glUniformMatrix3fv		MANGLE(UniformMatrix3fv)
+#define glUniformMatrix3x2dv		MANGLE(UniformMatrix3x2dv)
 #define glUniformMatrix3x2fv		MANGLE(UniformMatrix3x2fv)
+#define glUniformMatrix3x4dv		MANGLE(UniformMatrix3x4dv)
 #define glUniformMatrix3x4fv		MANGLE(UniformMatrix3x4fv)
+#define glUniformMatrix4dv		MANGLE(UniformMatrix4dv)
 #define glUniformMatrix4fvARB		MANGLE(UniformMatrix4fvARB)
 #define glUniformMatrix4fv		MANGLE(UniformMatrix4fv)
+#define glUniformMatrix4x2dv		MANGLE(UniformMatrix4x2dv)
 #define glUniformMatrix4x2fv		MANGLE(UniformMatrix4x2fv)
+#define glUniformMatrix4x3dv		MANGLE(UniformMatrix4x3dv)
 #define glUniformMatrix4x3fv		MANGLE(UniformMatrix4x3fv)
+#define glUniformSubroutinesuiv		MANGLE(UniformSubroutinesuiv)
 #define glUniformui64NV		MANGLE(Uniformui64NV)
 #define glUniformui64vNV		MANGLE(Uniformui64vNV)
 #define glUnlockArraysEXT		MANGLE(UnlockArraysEXT)
@@ -1844,6 +1950,14 @@
 #define glVertexAttribIFormatNV		MANGLE(VertexAttribIFormatNV)
 #define glVertexAttribIPointerEXT		MANGLE(VertexAttribIPointerEXT)
 #define glVertexAttribIPointer		MANGLE(VertexAttribIPointer)
+#define glVertexAttribP1ui		MANGLE(VertexAttribP1ui)
+#define glVertexAttribP1uiv		MANGLE(VertexAttribP1uiv)
+#define glVertexAttribP2ui		MANGLE(VertexAttribP2ui)
+#define glVertexAttribP2uiv		MANGLE(VertexAttribP2uiv)
+#define glVertexAttribP3ui		MANGLE(VertexAttribP3ui)
+#define glVertexAttribP3uiv		MANGLE(VertexAttribP3uiv)
+#define glVertexAttribP4ui		MANGLE(VertexAttribP4ui)
+#define glVertexAttribP4uiv		MANGLE(VertexAttribP4uiv)
 #define glVertexAttribPointerARB		MANGLE(VertexAttribPointerARB)
 #define glVertexAttribPointer		MANGLE(VertexAttribPointer)
 #define glVertexAttribPointerNV		MANGLE(VertexAttribPointerNV)
@@ -1868,6 +1982,12 @@
 #define glVertexBlendEnvfATI		MANGLE(VertexBlendEnvfATI)
 #define glVertexBlendEnviATI		MANGLE(VertexBlendEnviATI)
 #define glVertexFormatNV		MANGLE(VertexFormatNV)
+#define glVertexP2ui		MANGLE(VertexP2ui)
+#define glVertexP2uiv		MANGLE(VertexP2uiv)
+#define glVertexP3ui		MANGLE(VertexP3ui)
+#define glVertexP3uiv		MANGLE(VertexP3uiv)
+#define glVertexP4ui		MANGLE(VertexP4ui)
+#define glVertexP4uiv		MANGLE(VertexP4uiv)
 #define glVertexPointerEXT		MANGLE(VertexPointerEXT)
 #define glVertexPointerListIBM		MANGLE(VertexPointerListIBM)
 #define glVertexPointer		MANGLE(VertexPointer)
diff --git a/progs/egl/Makefile b/progs/egl/Makefile
index fe490c2..c74f474 100644
--- a/progs/egl/Makefile
+++ b/progs/egl/Makefile
@@ -60,7 +60,7 @@ xeglgears: xeglgears.o $(HEADERS) $(LIB_DEP)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LIBS) -lm $(X11_LIBS)
 
 xeglthreads: xeglthreads.o $(HEADERS) $(LIB_DEP)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LIBS) -lm $(X11_LIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LIBS) -lm -lpthread $(X11_LIBS)
 
 xegl_tri: xegl_tri.o $(HEADERS) $(LIB_DEP)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LIBS) -lm $(X11_LIBS)
diff --git a/src/gallium/auxiliary/tgsi/tgsi_ureg.c b/src/gallium/auxiliary/tgsi/tgsi_ureg.c
index 3d0455d..db7bf17 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_ureg.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_ureg.c
@@ -1489,6 +1489,12 @@ const struct tgsi_token *ureg_get_tokens( struct ureg_program *ureg,
 }
 
 
+void ureg_free_tokens( const struct tgsi_token *tokens )
+{
+   FREE((struct tgsi_token *)tokens);
+}
+
+
 struct ureg_program *ureg_create( unsigned processor )
 {
    struct ureg_program *ureg = CALLOC_STRUCT( ureg_program );
diff --git a/src/gallium/auxiliary/tgsi/tgsi_ureg.h b/src/gallium/auxiliary/tgsi/tgsi_ureg.h
index 0130a77..8302d1b 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_ureg.h
+++ b/src/gallium/auxiliary/tgsi/tgsi_ureg.h
@@ -104,6 +104,10 @@ ureg_get_tokens( struct ureg_program *ureg,
                  unsigned *nr_tokens );
 
 
+/* Free the tokens created by ureg_get_tokens() */
+void ureg_free_tokens( const struct tgsi_token *tokens );
+
+
 void 
 ureg_destroy( struct ureg_program * );
 
diff --git a/src/gallium/auxiliary/util/u_atomic.h b/src/gallium/auxiliary/util/u_atomic.h
index a156823..8434491 100644
--- a/src/gallium/auxiliary/util/u_atomic.h
+++ b/src/gallium/auxiliary/util/u_atomic.h
@@ -29,6 +29,8 @@
 #define PIPE_ATOMIC_ASM_MSVC_X86                
 #elif (defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86))
 #define PIPE_ATOMIC_ASM_GCC_X86
+#elif (defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86_64))
+#define PIPE_ATOMIC_ASM_GCC_X86_64
 #elif defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 401)
 #define PIPE_ATOMIC_GCC_INTRINSIC
 #else
@@ -36,6 +38,51 @@
 #endif
 
 
+#if defined(PIPE_ATOMIC_ASM_GCC_X86_64)
+#define PIPE_ATOMIC "GCC x86_64 assembly"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define p_atomic_set(_v, _i) (*(_v) = (_i))
+#define p_atomic_read(_v) (*(_v))
+
+static INLINE boolean
+p_atomic_dec_zero(int32_t *v)
+{
+   unsigned char c;
+
+   __asm__ __volatile__("lock; decl %0; sete %1":"+m"(*v), "=qm"(c)
+			::"memory");
+
+   return c != 0;
+}
+
+static INLINE void
+p_atomic_inc(int32_t *v)
+{
+   __asm__ __volatile__("lock; incl %0":"+m"(*v));
+}
+
+static INLINE void
+p_atomic_dec(int32_t *v)
+{
+   __asm__ __volatile__("lock; decl %0":"+m"(*v));
+}
+
+static INLINE int32_t
+p_atomic_cmpxchg(int32_t *v, int32_t old, int32_t _new)
+{
+   return __sync_val_compare_and_swap(v, old, _new);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PIPE_ATOMIC_ASM_GCC_X86_64 */
+
 
 #if defined(PIPE_ATOMIC_ASM_GCC_X86)
 
diff --git a/src/gallium/state_trackers/egl/x11/glxinit.c b/src/gallium/state_trackers/egl/x11/glxinit.c
index 1ed2afd..dd35189 100644
--- a/src/gallium/state_trackers/egl/x11/glxinit.c
+++ b/src/gallium/state_trackers/egl/x11/glxinit.c
@@ -16,6 +16,8 @@
 
 #include "glxinit.h"
 
+#ifdef GLX_DIRECT_RENDERING
+
 typedef struct GLXGenericGetString
 {
    CARD8 reqType;
@@ -680,3 +682,5 @@ __glXInitialize(Display * dpy)
 
    return dpyPriv;
 }
+
+#endif /* GLX_DIRECT_RENDERING */
diff --git a/src/gallium/state_trackers/egl/x11/native_dri2.c b/src/gallium/state_trackers/egl/x11/native_dri2.c
index 8d2a8b1..a8bdd34 100644
--- a/src/gallium/state_trackers/egl/x11/native_dri2.c
+++ b/src/gallium/state_trackers/egl/x11/native_dri2.c
@@ -37,6 +37,8 @@
 #include "native_x11.h"
 #include "x11_screen.h"
 
+#ifdef GLX_DIRECT_RENDERING
+
 enum dri2_surface_type {
    DRI2_SURFACE_TYPE_WINDOW,
    DRI2_SURFACE_TYPE_PIXMAP,
@@ -878,3 +880,15 @@ x11_create_dri2_display(EGLNativeDisplayType dpy,
 
    return &dri2dpy->base;
 }
+
+#else /* GLX_DIRECT_RENDERING */
+
+struct native_display *
+x11_create_dri2_display(EGLNativeDisplayType dpy,
+                        struct native_event_handler *event_handler,
+                        struct drm_api *api)
+{
+   return NULL;
+}
+
+#endif /* GLX_DIRECT_RENDERING */
diff --git a/src/gallium/state_trackers/egl/x11/native_x11.c b/src/gallium/state_trackers/egl/x11/native_x11.c
index 7b4fe63..0c25e4d 100644
--- a/src/gallium/state_trackers/egl/x11/native_x11.c
+++ b/src/gallium/state_trackers/egl/x11/native_x11.c
@@ -70,7 +70,9 @@ native_create_probe(EGLNativeDisplayType dpy)
    xscr = x11_screen_create(xdpy, scr);
    if (xscr) {
       if (x11_screen_support(xscr, X11_SCREEN_EXTENSION_DRI2)) {
+#ifdef GLX_DIRECT_RENDERING
          driver_name = x11_screen_probe_dri2(xscr, NULL, NULL);
+#endif
          if (driver_name)
             nprobe->data = strdup(driver_name);
       }
diff --git a/src/gallium/state_trackers/egl/x11/x11_screen.c b/src/gallium/state_trackers/egl/x11/x11_screen.c
index f409611..1706120 100644
--- a/src/gallium/state_trackers/egl/x11/x11_screen.c
+++ b/src/gallium/state_trackers/egl/x11/x11_screen.c
@@ -39,8 +39,10 @@
 #include "glxinit.h"
 
 struct x11_screen {
+#ifdef GLX_DIRECT_RENDERING
    /* dummy base class */
    struct __GLXDRIdisplayRec base;
+#endif
 
    Display *dpy;
    int number;
@@ -103,15 +105,19 @@ x11_screen_destroy(struct x11_screen *xscr)
    if (xscr->dri_device)
       Xfree(xscr->dri_device);
 
+#ifdef GLX_DIRECT_RENDERING
    /* xscr->glx_dpy will be destroyed with the X display */
    if (xscr->glx_dpy)
       xscr->glx_dpy->dri2Display = NULL;
+#endif
 
    if (xscr->visuals)
       XFree(xscr->visuals);
    free(xscr);
 }
 
+#ifdef GLX_DIRECT_RENDERING
+
 static boolean
 x11_screen_init_dri2(struct x11_screen *xscr)
 {
@@ -133,6 +139,8 @@ x11_screen_init_glx(struct x11_screen *xscr)
    return (xscr->glx_dpy != NULL);
 }
 
+#endif /* GLX_DIRECT_RENDERING */
+
 /**
  * Return true if the screen supports the extension.
  */
@@ -145,12 +153,14 @@ x11_screen_support(struct x11_screen *xscr, enum x11_screen_extension ext)
    case X11_SCREEN_EXTENSION_XSHM:
       supported = XShmQueryExtension(xscr->dpy);
       break;
+#ifdef GLX_DIRECT_RENDERING
    case X11_SCREEN_EXTENSION_GLX:
       supported = x11_screen_init_glx(xscr);
       break;
    case X11_SCREEN_EXTENSION_DRI2:
       supported = x11_screen_init_dri2(xscr);
       break;
+#endif
    default:
       break;
    }
@@ -234,6 +244,39 @@ x11_screen_convert_visual(struct x11_screen *xscr, const XVisualInfo *visual,
 }
 
 /**
+ * Return the depth of a drawable.
+ *
+ * Unlike other drawable functions, the drawable needs not be a DRI2 drawable.
+ */
+uint
+x11_drawable_get_depth(struct x11_screen *xscr, Drawable drawable)
+{
+   unsigned int depth;
+
+   if (drawable != xscr->last_drawable) {
+      Window root;
+      int x, y;
+      unsigned int w, h, border;
+      Status ok;
+
+      ok = XGetGeometry(xscr->dpy, drawable, &root,
+            &x, &y, &w, &h, &border, &depth);
+      if (!ok)
+         depth = 0;
+
+      xscr->last_drawable = drawable;
+      xscr->last_depth = depth;
+   }
+   else {
+      depth = xscr->last_depth;
+   }
+
+   return depth;
+}
+
+#ifdef GLX_DIRECT_RENDERING
+
+/**
  * Return the GLX fbconfigs.
  */
 const __GLcontextModes *
@@ -392,37 +435,6 @@ x11_drawable_get_buffers(struct x11_screen *xscr, Drawable drawable,
 }
 
 /**
- * Return the depth of a drawable.
- *
- * Unlike other drawable functions, the drawable needs not be a DRI2 drawable.
- */
-uint
-x11_drawable_get_depth(struct x11_screen *xscr, Drawable drawable)
-{
-   unsigned int depth;
-
-   if (drawable != xscr->last_drawable) {
-      Window root;
-      int x, y;
-      unsigned int w, h, border;
-      Status ok;
-
-      ok = XGetGeometry(xscr->dpy, drawable, &root,
-            &x, &y, &w, &h, &border, &depth);
-      if (!ok)
-         depth = 0;
-
-      xscr->last_drawable = drawable;
-      xscr->last_depth = depth;
-   }
-   else {
-      depth = xscr->last_depth;
-   }
-
-   return depth;
-}
-
-/**
  * Create a mode list of the given size.
  */
 __GLcontextModes *
@@ -489,3 +501,5 @@ dri2InvalidateBuffers(Display *dpy, XID drawable)
 
    xscr->dri_invalidate_buffers(xscr, drawable, xscr->dri_user_data);
 }
+
+#endif /* GLX_DIRECT_RENDERING */
diff --git a/src/gallium/state_trackers/egl/x11/x11_screen.h b/src/gallium/state_trackers/egl/x11/x11_screen.h
index 37e8d5a..55e1201 100644
--- a/src/gallium/state_trackers/egl/x11/x11_screen.h
+++ b/src/gallium/state_trackers/egl/x11/x11_screen.h
@@ -68,20 +68,18 @@ void
 x11_screen_convert_visual(struct x11_screen *xscr, const XVisualInfo *visual,
                           __GLcontextModes *mode);
 
+uint
+x11_drawable_get_depth(struct x11_screen *xscr, Drawable drawable);
+
+#ifdef GLX_DIRECT_RENDERING
+
+/* GLX */
 const __GLcontextModes *
 x11_screen_get_glx_configs(struct x11_screen *xscr);
 
 const __GLcontextModes *
 x11_screen_get_glx_visuals(struct x11_screen *xscr);
 
-const char *
-x11_screen_probe_dri2(struct x11_screen *xscr, int *major, int *minor);
-
-int
-x11_screen_enable_dri2(struct x11_screen *xscr,
-                       x11_drawable_invalidate_buffers invalidate_buffers,
-                       void *user_data);
-
 __GLcontextModes *
 x11_context_modes_create(unsigned count);
 
@@ -91,6 +89,15 @@ x11_context_modes_destroy(__GLcontextModes *modes);
 unsigned
 x11_context_modes_count(const __GLcontextModes *modes);
 
+/* DRI2 */
+const char *
+x11_screen_probe_dri2(struct x11_screen *xscr, int *major, int *minor);
+
+int
+x11_screen_enable_dri2(struct x11_screen *xscr,
+                       x11_drawable_invalidate_buffers invalidate_buffers,
+                       void *user_data);
+
 void
 x11_drawable_enable_dri2(struct x11_screen *xscr,
                          Drawable drawable, boolean on);
@@ -105,7 +112,6 @@ x11_drawable_get_buffers(struct x11_screen *xscr, Drawable drawable,
                          int *width, int *height, unsigned int *attachments,
                          boolean with_format, int num_ins, int *num_outs);
 
-uint
-x11_drawable_get_depth(struct x11_screen *xscr, Drawable drawable);
+#endif /* GLX_DIRECT_RENDERING */
 
 #endif /* _X11_SCREEN_H_ */
diff --git a/src/gallium/winsys/drm/Makefile.egl b/src/gallium/winsys/drm/Makefile.egl
index 8363de6..c48967f 100644
--- a/src/gallium/winsys/drm/Makefile.egl
+++ b/src/gallium/winsys/drm/Makefile.egl
@@ -11,7 +11,7 @@
 
 EGL_DRIVER_OBJECTS = $(EGL_DRIVER_SOURCES:.c=.o)
 
-common_LIBS = -ldrm -lm -ldl
+common_LIBS = -ldrm -lm $(DLOPEN_LIBS)
 
 x11_ST = $(TOP)/src/gallium/state_trackers/egl/libeglx11.a
 x11_LIBS = $(common_LIBS) -lX11 -lXext -lXfixes
diff --git a/src/glw/Makefile b/src/glw/Makefile
index 1fb3d3c..39352f0 100644
--- a/src/glw/Makefile
+++ b/src/glw/Makefile
@@ -17,7 +17,7 @@ OBJECTS = $(GLW_SOURCES:.c=.o)
 ##### RULES #####
 
 .c.o:
-	$(CC) -c $(INCDIRS) $(CFLAGS) $<
+	$(CC) -c $(INCDIRS) $(CFLAGS) $(GLW_CFLAGS) $<
 
 
 
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c b/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c
index df67aaf..b8ee288 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c
@@ -141,12 +141,28 @@ static void add_inst_to_list(struct schedule_instruction ** list, struct schedul
 	*list = inst;
 }
 
+static void add_inst_to_list_end(struct schedule_instruction ** list,
+					struct schedule_instruction * inst)
+{
+	if(!*list){
+		*list = inst;
+	}else{
+		struct schedule_instruction * temp = *list;
+		while(temp->NextReady){
+			temp = temp->NextReady;
+		}
+		temp->NextReady = inst;
+	}
+}
+
 static void instruction_ready(struct schedule_state * s, struct schedule_instruction * sinst)
 {
 	DBG("%i is now ready\n", sinst->Instruction->IP);
 
+	/* Adding Ready TEX instructions to the end of the "Ready List" helps
+	 * us emit TEX instructions in blocks without losing our place. */
 	if (sinst->Instruction->Type == RC_INSTRUCTION_NORMAL)
-		add_inst_to_list(&s->ReadyTEX, sinst);
+		add_inst_to_list_end(&s->ReadyTEX, sinst);
 	else if (sinst->Instruction->U.P.Alpha.Opcode == RC_OPCODE_NOP)
 		add_inst_to_list(&s->ReadyRGB, sinst);
 	else if (sinst->Instruction->U.P.RGB.Opcode == RC_OPCODE_NOP)
@@ -163,11 +179,14 @@ static void decrease_dependencies(struct schedule_state * s, struct schedule_ins
 		instruction_ready(s, sinst);
 }
 
-static void commit_instruction(struct schedule_state * s, struct schedule_instruction * sinst)
-{
-	DBG("%i: commit\n", sinst->Instruction->IP);
-
-	for(unsigned int i = 0; i < sinst->NumReadValues; ++i) {
+/**
+ * This function decreases the dependencies of the next instruction that
+ * wants to write to each of sinst's read values.
+ */
+static void commit_update_reads(struct schedule_state * s,
+					struct schedule_instruction * sinst){
+	unsigned int i;
+	for(i = 0; i < sinst->NumReadValues; ++i) {
 		struct reg_value * v = sinst->ReadValues[i];
 		assert(v->NumReaders > 0);
 		v->NumReaders--;
@@ -176,8 +195,12 @@ static void commit_instruction(struct schedule_state * s, struct schedule_instru
 				decrease_dependencies(s, v->Next->Writer);
 		}
 	}
+}
 
-	for(unsigned int i = 0; i < sinst->NumWriteValues; ++i) {
+static void commit_update_writes(struct schedule_state * s,
+					struct schedule_instruction * sinst){
+	unsigned int i;
+	for(i = 0; i < sinst->NumWriteValues; ++i) {
 		struct reg_value * v = sinst->WriteValues[i];
 		if (v->NumReaders) {
 			for(struct reg_value_reader * r = v->Readers; r; r = r->Next) {
@@ -196,6 +219,15 @@ static void commit_instruction(struct schedule_state * s, struct schedule_instru
 	}
 }
 
+static void commit_alu_instruction(struct schedule_state * s, struct schedule_instruction * sinst)
+{
+	DBG("%i: commit\n", sinst->Instruction->IP);
+
+	commit_update_reads(s, sinst);
+
+	commit_update_writes(s, sinst);
+}
+
 /**
  * Emit all ready texture instructions in a single block.
  *
@@ -208,21 +240,37 @@ static void emit_all_tex(struct schedule_state * s, struct rc_instruction * befo
 
 	assert(s->ReadyTEX);
 
-	/* Don't let the ready list change under us! */
-	readytex = s->ReadyTEX;
-	s->ReadyTEX = 0;
-
 	/* Node marker for R300 */
 	struct rc_instruction * inst_begin = rc_insert_new_instruction(s->C, before->Prev);
 	inst_begin->U.I.Opcode = RC_OPCODE_BEGIN_TEX;
 
 	/* Link texture instructions back in */
+	readytex = s->ReadyTEX;
 	while(readytex) {
-		struct schedule_instruction * tex = readytex;
+		rc_insert_instruction(before->Prev, readytex->Instruction);
+		DBG("%i: commit TEX reads\n", readytex->Instruction->IP);
+
+		/* All of the TEX instructions in the same TEX block have
+		 * their source registers read from before any of the
+		 * instructions in that block write to their destination
+		 * registers.  This means that when we commit a TEX
+		 * instruction, any other TEX instruction that wants to write
+		 * to one of the committed instruction's source register can be
+		 * marked as ready and should be emitted in the same TEX
+		 * block. This prevents the following sequence from being
+		 * emitted in two different TEX blocks:
+		 * 0: TEX temp[0].xyz, temp[1].xy__, 2D[0];
+		 * 1: TEX temp[1].xyz, temp[2].xy__, 2D[0];
+		 */
+		commit_update_reads(s, readytex);
+		readytex = readytex->NextReady;
+	}
+	readytex = s->ReadyTEX;
+	s->ReadyTEX = 0;
+	while(readytex){
+		DBG("%i: commit TEX writes\n", readytex->Instruction->IP);
+		commit_update_writes(s, readytex);
 		readytex = readytex->NextReady;
-
-		rc_insert_instruction(before->Prev, tex->Instruction);
-		commit_instruction(s, tex);
 	}
 }
 
@@ -328,7 +376,7 @@ static void emit_one_alu(struct schedule_state *s, struct rc_instruction * befor
 		}
 
 		rc_insert_instruction(before->Prev, sinst->Instruction);
-		commit_instruction(s, sinst);
+		commit_alu_instruction(s, sinst);
 	} else {
 		struct schedule_instruction **prgb;
 		struct schedule_instruction **palpha;
@@ -346,8 +394,8 @@ static void emit_one_alu(struct schedule_state *s, struct rc_instruction * befor
 				*prgb = (*prgb)->NextReady;
 				*palpha = (*palpha)->NextReady;
 				rc_insert_instruction(before->Prev, psirgb->Instruction);
-				commit_instruction(s, psirgb);
-				commit_instruction(s, psialpha);
+				commit_alu_instruction(s, psirgb);
+				commit_alu_instruction(s, psialpha);
 				goto success;
 			}
 		}
@@ -357,7 +405,7 @@ static void emit_one_alu(struct schedule_state *s, struct rc_instruction * befor
 		s->ReadyRGB = s->ReadyRGB->NextReady;
 
 		rc_insert_instruction(before->Prev, sinst->Instruction);
-		commit_instruction(s, sinst);
+		commit_alu_instruction(s, sinst);
 	success: ;
 	}
 }
diff --git a/src/mesa/drivers/dri/r300/r300_context.c b/src/mesa/drivers/dri/r300/r300_context.c
index 689bb13..4cbd4f2 100644
--- a/src/mesa/drivers/dri/r300/r300_context.c
+++ b/src/mesa/drivers/dri/r300/r300_context.c
@@ -456,7 +456,7 @@ static void r300InitGLExtensions(GLcontext *ctx)
 	if (!r300->radeon.radeonScreen->drmSupportsOcclusionQueries) {
 		_mesa_disable_extension(ctx, "GL_ARB_occlusion_query");
 	}
-	if (r300->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV350)
+        if (r300->radeon.radeonScreen->chip_family >= CHIP_FAMILY_R420)
   		_mesa_enable_extension(ctx, "GL_ARB_half_float_vertex");
 
 	if (r300->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
diff --git a/src/mesa/drivers/dri/r300/r300_draw.c b/src/mesa/drivers/dri/r300/r300_draw.c
index 282c0e1..5ae9f49 100644
--- a/src/mesa/drivers/dri/r300/r300_draw.c
+++ b/src/mesa/drivers/dri/r300/r300_draw.c
@@ -523,8 +523,7 @@ static void r300AllocDmaRegions(GLcontext *ctx, const struct gl_client_array *in
 			r300ConvertAttrib(ctx, count, input[i], &vbuf->attribs[index]);
 		} else {
 			if (input[i]->BufferObj->Name) {
-				if (stride % 4 != 0) {
-					assert(((intptr_t) input[i]->Ptr) % input[i]->StrideB == 0);
+				if (stride % 4 != 0 || (intptr_t)input[i]->Ptr % 4 != 0) {
 					r300AlignDataToDword(ctx, input[i], count, &vbuf->attribs[index]);
 					vbuf->attribs[index].is_named_bo = GL_FALSE;
 				} else {
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.c b/src/mesa/drivers/dri/r600/r700_assembler.c
index 834bcc6..7b957fb 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.c
+++ b/src/mesa/drivers/dri/r600/r700_assembler.c
@@ -293,7 +293,9 @@ GLuint GetSurfaceFormat(GLenum eType, GLuint nChannels, GLuint * pClient_size)
                 case 2:
                     format = FMT_16_16; break;
                 case 3:
-                    format = FMT_16_16_16; break;
+                    /* 3 comp GL_SHORT vertex format doesnt work on r700
+                       4 somehow works, test - sauerbraten  */
+                    format = FMT_16_16_16_16; break;
                 case 4:
                     format = FMT_16_16_16_16; break;
                 default:
@@ -1051,6 +1053,67 @@ void checkop_init(r700_AssemblerBase* pAsm)
     pAsm->aArgSubst[3] = -1;
 }
 
+static GLboolean next_ins(r700_AssemblerBase *pAsm)
+{
+    struct prog_instruction *pILInst = &(pAsm->pILInst[pAsm->uiCurInst]);
+
+    if (GL_TRUE == pAsm->is_tex)
+    {
+        if (pILInst->TexSrcTarget == TEXTURE_RECT_INDEX)
+        {
+            if (GL_FALSE == assemble_tex_instruction(pAsm, GL_FALSE))
+            {
+                radeon_error("Error assembling TEX instruction\n");
+                return GL_FALSE;
+            }
+        }
+        else
+        {
+            if (GL_FALSE == assemble_tex_instruction(pAsm, GL_TRUE))
+            {
+                radeon_error("Error assembling TEX instruction\n");
+                return GL_FALSE;
+            }
+        }
+    }
+    else
+    {   //ALU
+        if (GL_FALSE == assemble_alu_instruction(pAsm))
+        {
+            radeon_error("Error assembling ALU instruction\n");
+            return GL_FALSE;
+        }
+    }
+
+    if (pAsm->D.dst.rtype == DST_REG_OUT)
+    {
+        assert(pAsm->D.dst.reg >= pAsm->starting_export_register_number);
+
+        if (pAsm->D.dst.op3)
+        {
+            // There is no mask for OP3 instructions, so all channels are written
+            pAsm->pucOutMask[pAsm->D.dst.reg - pAsm->starting_export_register_number] = 0xF;
+        }
+        else
+        {
+            pAsm->pucOutMask[pAsm->D.dst.reg - pAsm->starting_export_register_number]
+               |= (unsigned char)pAsm->pILInst[pAsm->uiCurInst].DstReg.WriteMask;
+        }
+    }
+
+    //reset for next inst.
+    pAsm->D.bits    = 0;
+    pAsm->D2.bits   = 0;
+    pAsm->S[0].bits = 0;
+    pAsm->S[1].bits = 0;
+    pAsm->S[2].bits = 0;
+    pAsm->is_tex = GL_FALSE;
+    pAsm->need_tex_barrier = GL_FALSE;
+    pAsm->D2.bits = 0;
+    pAsm->C[0].bits = pAsm->C[1].bits = pAsm->C[2].bits = pAsm->C[3].bits = 0;
+    return GL_TRUE;
+}
+
 GLboolean mov_temp(r700_AssemblerBase* pAsm, int src)
 {
     GLuint tmp = gethelpr(pAsm);
@@ -1201,7 +1264,7 @@ GLboolean checkop3(r700_AssemblerBase* pAsm)
 	    {
             if( GL_FALSE == mov_temp(pAsm, 1) )
             {
-                return 1;
+                return GL_FALSE;
             }
         }
 
@@ -2578,62 +2641,6 @@ GLboolean assemble_alu_instruction(r700_AssemblerBase *pAsm)
     return GL_TRUE;
 }
 
-GLboolean next_ins(r700_AssemblerBase *pAsm)
-{
-    struct prog_instruction *pILInst = &(pAsm->pILInst[pAsm->uiCurInst]);
-
-    if( GL_TRUE == pAsm->is_tex )
-    {
-	    if (pILInst->TexSrcTarget == TEXTURE_RECT_INDEX) {
-		    if( GL_FALSE == assemble_tex_instruction(pAsm, GL_FALSE) ) 
-		    {
-			    radeon_error("Error assembling TEX instruction\n");
-			    return GL_FALSE;
-		    }
-	    } else {
-		    if( GL_FALSE == assemble_tex_instruction(pAsm, GL_TRUE) ) 
-		    {
-			    radeon_error("Error assembling TEX instruction\n");
-			    return GL_FALSE;
-		    }
-	    }
-    }
-    else 
-    {   //ALU      
-        if( GL_FALSE == assemble_alu_instruction(pAsm) ) 
-        {
-            radeon_error("Error assembling ALU instruction\n");
-            return GL_FALSE;
-        }
-    } 
-      
-    if(pAsm->D.dst.rtype == DST_REG_OUT) 
-    {
-        if(pAsm->D.dst.op3) 
-        {        
-            // There is no mask for OP3 instructions, so all channels are written        
-            pAsm->pucOutMask[pAsm->D.dst.reg - pAsm->starting_export_register_number] = 0xF;
-        }
-        else 
-        {
-            pAsm->pucOutMask[pAsm->D.dst.reg - pAsm->starting_export_register_number] 
-               |= (unsigned char)pAsm->pILInst[pAsm->uiCurInst].DstReg.WriteMask;
-        }
-    }
-    
-    //reset for next inst.
-    pAsm->D.bits    = 0;
-    pAsm->D2.bits   = 0;
-    pAsm->S[0].bits = 0;
-    pAsm->S[1].bits = 0;
-    pAsm->S[2].bits = 0;
-    pAsm->is_tex = GL_FALSE;
-    pAsm->need_tex_barrier = GL_FALSE;
-    pAsm->D2.bits = 0;
-    pAsm->C[0].bits = pAsm->C[1].bits = pAsm->C[2].bits = pAsm->C[3].bits = 0;
-    return GL_TRUE;
-}
-
 GLboolean assemble_math_function(r700_AssemblerBase* pAsm, BITS opcode)
 {
     BITS tmp;
@@ -2865,25 +2872,92 @@ GLboolean assemble_CMP(r700_AssemblerBase *pAsm)
 
 GLboolean assemble_TRIG(r700_AssemblerBase *pAsm, BITS opcode)
 {
+    /* 
+     * r600 - trunc to -PI..PI range
+     * r700 - normalize by dividing by 2PI
+     * see fdo bug 27901
+     */
+  
     int tmp;
     checkop1(pAsm);
 
     tmp = gethelpr(pAsm);
 
-    pAsm->D.dst.opcode = SQ_OP2_INST_MUL;
+    pAsm->D.dst.opcode = SQ_OP3_INST_MULADD;
+    pAsm->D.dst.op3    = 1;
+
     setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
     pAsm->D.dst.rtype  = DST_REG_TEMPORARY;
     pAsm->D.dst.reg    = tmp;
-    pAsm->D.dst.writex = 1;
 
     assemble_src(pAsm, 0, -1);
 
     pAsm->S[1].src.rtype = SRC_REC_LITERAL;
     setswizzle_PVSSRC(&(pAsm->S[1].src), SQ_SEL_X);
+    
+    pAsm->S[2].src.rtype = SRC_REC_LITERAL;
+    setswizzle_PVSSRC(&(pAsm->S[2].src), SQ_SEL_Y);
+
     pAsm->D2.dst2.literal_slots = 1;
     pAsm->C[0].f = 1/(3.1415926535 * 2);
-    pAsm->C[1].f = 0.0F;
-    next_ins(pAsm);
+    pAsm->C[1].f = 0.5f;
+    
+    if ( GL_FALSE == next_ins(pAsm) )
+    {
+        return GL_FALSE;
+    }
+
+    pAsm->D.dst.opcode = SQ_OP2_INST_FRACT;
+
+    setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
+    pAsm->D.dst.rtype  = DST_REG_TEMPORARY;
+    pAsm->D.dst.reg    = tmp;
+    pAsm->D.dst.writex = 1;
+
+    setaddrmode_PVSSRC(&(pAsm->S[0].src), ADDR_ABSOLUTE);
+    pAsm->S[0].src.rtype = SRC_REG_TEMPORARY;
+    pAsm->S[0].src.reg   = tmp;
+    setswizzle_PVSSRC(&(pAsm->S[0].src), SQ_SEL_X);
+
+    if(( GL_FALSE == next_ins(pAsm) ))
+    {
+        return GL_FALSE;
+    }
+    pAsm->D.dst.opcode = SQ_OP3_INST_MULADD;
+    pAsm->D.dst.op3    = 1;
+
+    setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
+    pAsm->D.dst.rtype  = DST_REG_TEMPORARY;
+    pAsm->D.dst.reg    = tmp;
+
+    setaddrmode_PVSSRC(&(pAsm->S[0].src), ADDR_ABSOLUTE);
+    pAsm->S[0].src.rtype = SRC_REG_TEMPORARY;
+    pAsm->S[0].src.reg   = tmp;
+    setswizzle_PVSSRC(&(pAsm->S[0].src), SQ_SEL_X);
+
+    pAsm->S[1].src.rtype = SRC_REC_LITERAL;
+    setswizzle_PVSSRC(&(pAsm->S[1].src), SQ_SEL_X);
+
+    pAsm->S[2].src.rtype = SRC_REC_LITERAL;
+    setswizzle_PVSSRC(&(pAsm->S[2].src), SQ_SEL_Y);
+
+    pAsm->D2.dst2.literal_slots = 1;
+
+    if (pAsm->bR6xx)
+    {
+       pAsm->C[0].f = 3.1415926535897f * 2.0f;
+       pAsm->C[1].f = -3.1415926535897f;
+    }
+    else 
+    {
+       pAsm->C[0].f = 1.0f;
+       pAsm->C[1].f = -0.5f;
+    }
+
+    if(( GL_FALSE == next_ins(pAsm) ))
+    {
+        return GL_FALSE;
+    }
 
     pAsm->D.dst.opcode = opcode;
     pAsm->D.dst.math = 1;
@@ -4023,22 +4097,79 @@ GLboolean assemble_SCS(r700_AssemblerBase *pAsm)
     checkop1(pAsm);
 
     tmp = gethelpr(pAsm);
-    /* tmp.x = src /2*PI */
-    pAsm->D.dst.opcode = SQ_OP2_INST_MUL;
+
+    pAsm->D.dst.opcode = SQ_OP3_INST_MULADD;
+    pAsm->D.dst.op3    = 1;
+
     setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
     pAsm->D.dst.rtype  = DST_REG_TEMPORARY;
     pAsm->D.dst.reg    = tmp;
-    pAsm->D.dst.writex = 1;
 
     assemble_src(pAsm, 0, -1);
 
     pAsm->S[1].src.rtype = SRC_REC_LITERAL;
     setswizzle_PVSSRC(&(pAsm->S[1].src), SQ_SEL_X);
+
+    pAsm->S[2].src.rtype = SRC_REC_LITERAL;
+    setswizzle_PVSSRC(&(pAsm->S[2].src), SQ_SEL_Y);
+
     pAsm->D2.dst2.literal_slots = 1;
     pAsm->C[0].f = 1/(3.1415926535 * 2);
-    pAsm->C[1].f = 0.0F;
+    pAsm->C[1].f = 0.5F;
 
-    next_ins(pAsm);
+    if ( GL_FALSE == next_ins(pAsm) )
+    {
+        return GL_FALSE;
+    }
+
+    pAsm->D.dst.opcode = SQ_OP2_INST_FRACT;
+
+    setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
+    pAsm->D.dst.rtype  = DST_REG_TEMPORARY;
+    pAsm->D.dst.reg    = tmp;
+    pAsm->D.dst.writex = 1;
+
+    setaddrmode_PVSSRC(&(pAsm->S[0].src), ADDR_ABSOLUTE);
+    pAsm->S[0].src.rtype = SRC_REG_TEMPORARY;
+    pAsm->S[0].src.reg   = tmp;
+    setswizzle_PVSSRC(&(pAsm->S[0].src), SQ_SEL_X);
+
+    if(( GL_FALSE == next_ins(pAsm) ))
+    {
+        return GL_FALSE;
+    }
+    pAsm->D.dst.opcode = SQ_OP3_INST_MULADD;
+    pAsm->D.dst.op3    = 1;
+
+    setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
+    pAsm->D.dst.rtype  = DST_REG_TEMPORARY;
+    pAsm->D.dst.reg    = tmp;
+
+    setaddrmode_PVSSRC(&(pAsm->S[0].src), ADDR_ABSOLUTE);
+    pAsm->S[0].src.rtype = SRC_REG_TEMPORARY;
+    pAsm->S[0].src.reg   = tmp;
+    setswizzle_PVSSRC(&(pAsm->S[0].src), SQ_SEL_X);
+
+    pAsm->S[1].src.rtype = SRC_REC_LITERAL;
+    setswizzle_PVSSRC(&(pAsm->S[1].src), SQ_SEL_X);
+
+    pAsm->S[2].src.rtype = SRC_REC_LITERAL;
+    setswizzle_PVSSRC(&(pAsm->S[2].src), SQ_SEL_Y);
+
+    pAsm->D2.dst2.literal_slots = 1;
+
+    if(pAsm->bR6xx) {
+       pAsm->C[0].f = 3.1415926535897f * 2.0f;
+       pAsm->C[1].f = -3.1415926535897f;
+    } else {
+       pAsm->C[0].f = 1.0f;
+       pAsm->C[1].f = -0.5f;
+    }
+
+    if(( GL_FALSE == next_ins(pAsm) ))
+    {
+        return GL_FALSE;
+    }
 
     // COS dst.x,    a.x
     pAsm->D.dst.opcode = SQ_OP2_INST_COS;
@@ -6154,7 +6285,7 @@ GLboolean callPreSub(r700_AssemblerBase* pAsm,
     }
     if(uNumValidSrc > 0)
     {
-        prelude_cf_ptr     = pAsm->cf_current_alu_clause_ptr;
+        prelude_cf_ptr     = (R700ControlFlowGenericClause*) pAsm->cf_current_alu_clause_ptr;
         pAsm->alu_x_opcode = SQ_CF_INST_ALU;
     }
 
@@ -6274,7 +6405,7 @@ GLboolean callPreSub(r700_AssemblerBase* pAsm,
 
         next_ins(pAsm);        
 
-        pAsm->callers[pAsm->unCallerArrayPointer - 1].finale_cf_ptr  = pAsm->cf_current_alu_clause_ptr;
+        pAsm->callers[pAsm->unCallerArrayPointer - 1].finale_cf_ptr  = (R700ControlFlowGenericClause*) pAsm->cf_current_alu_clause_ptr;
         pAsm->callers[pAsm->unCallerArrayPointer - 1].prelude_cf_ptr = prelude_cf_ptr;
         pAsm->alu_x_opcode = SQ_CF_INST_ALU;
     }
@@ -6347,6 +6478,8 @@ GLboolean Process_Export(r700_AssemblerBase* pAsm,
 
     if (export_count == 1) 
     {
+        assert(starting_register_number >= pAsm->starting_export_register_number);
+
         ucWriteMask = pAsm->pucOutMask[starting_register_number - pAsm->starting_export_register_number];
 	/* exports Z as a float into Red channel */
 	if (GL_TRUE == is_depth_export)
@@ -6437,6 +6570,7 @@ GLboolean Process_Fragment_Exports(r700_AssemblerBase *pR700AsmCode,
 { 
     unsigned int unBit;
     GLuint export_count = 0;
+    unsigned int i;
 
     if(pR700AsmCode->depth_export_register_number >= 0) 
     {
@@ -6446,39 +6580,24 @@ GLboolean Process_Fragment_Exports(r700_AssemblerBase *pR700AsmCode,
 		}
     }
 
-    unBit = 1 << FRAG_RESULT_COLOR;
-	if(OutputsWritten & unBit)
-	{
-		if( GL_FALSE == Process_Export(pR700AsmCode,
-                                       SQ_EXPORT_PIXEL, 
-                                       0, 
-                                       1, 
-                                       pR700AsmCode->uiFP_OutputMap[FRAG_RESULT_COLOR], 
-                                       GL_FALSE) ) 
-        {
-            return GL_FALSE;
-        }
-        export_count++;
-	}
-	unBit = 1 << FRAG_RESULT_DEPTH;
-	if(OutputsWritten & unBit)
-	{
-        if( GL_FALSE == Process_Export(pR700AsmCode,
-                                       SQ_EXPORT_PIXEL, 
-                                       0, 
-                                       1, 
-                                       pR700AsmCode->uiFP_OutputMap[FRAG_RESULT_DEPTH], 
-                                       GL_TRUE)) 
+    for (i = 0; i < FRAG_RESULT_MAX; ++i)
+    {
+        unBit = 1 << i;
+
+        if (OutputsWritten & unBit)
         {
-            return GL_FALSE;
+            GLboolean is_depth = i == FRAG_RESULT_DEPTH ? GL_TRUE : GL_FALSE;
+            if (!Process_Export(pR700AsmCode, SQ_EXPORT_PIXEL, 0, 1, pR700AsmCode->uiFP_OutputMap[i], is_depth))
+                return GL_FALSE;
+            ++export_count;
         }
-        export_count++;
-	}
+    }
+
     /* Need to export something, otherwise we'll hang
      * results are undefined anyway */
     if(export_count == 0)
     {
-        Process_Export(pR700AsmCode, SQ_EXPORT_PIXEL, 0, 1, 0, GL_FALSE);
+        Process_Export(pR700AsmCode, SQ_EXPORT_PIXEL, 0, 1, pR700AsmCode->starting_export_register_number, GL_FALSE);
     }
     
     if(pR700AsmCode->cf_last_export_ptr != NULL) 
@@ -6511,13 +6630,30 @@ GLboolean Process_Vertex_Exports(r700_AssemblerBase *pR700AsmCode,
         {
             return GL_FALSE;
         }
+        export_starting_index++;
+        export_count--;
+        }
 
+    unBit = 1 << VERT_RESULT_PSIZ;
+    if(OutputsWritten & unBit)
+    {
+        if( GL_FALSE == Process_Export(pR700AsmCode,
+                                       SQ_EXPORT_POS,
+                                       export_starting_index,
+                                       1,
+                                       pR700AsmCode->ucVP_OutputMap[VERT_RESULT_PSIZ],
+                                       GL_FALSE) )
+        {
+            return GL_FALSE;
+        }
         export_count--;
+    }
+
+    pR700AsmCode->cf_last_export_ptr->m_Word1.f.cf_inst = SQ_CF_INST_EXPORT_DONE;
 
-        pR700AsmCode->cf_last_export_ptr->m_Word1.f.cf_inst = SQ_CF_INST_EXPORT_DONE;
-	}
 
     pR700AsmCode->number_of_exports = export_count;
+    export_starting_index = 0;
 
 	unBit = 1 << VERT_RESULT_COL0;
 	if(OutputsWritten & unBit)
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.h b/src/mesa/drivers/dri/r600/r700_assembler.h
index 0064d08..2d3c324 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.h
+++ b/src/mesa/drivers/dri/r600/r700_assembler.h
@@ -582,7 +582,6 @@ GLboolean check_scalar(r700_AssemblerBase* pAsm,
 GLboolean check_vector(r700_AssemblerBase* pAsm,
                        R700ALUInstruction* alu_instruction_ptr);
 GLboolean assemble_alu_instruction(r700_AssemblerBase *pAsm);
-GLboolean next_ins(r700_AssemblerBase *pAsm);
 
 GLboolean pops(r700_AssemblerBase *pAsm, GLuint pops);
 GLboolean jumpToOffest(r700_AssemblerBase *pAsm, GLuint pops, GLint offset);
diff --git a/src/mesa/drivers/dri/r600/r700_fragprog.c b/src/mesa/drivers/dri/r600/r700_fragprog.c
index 84d51e6..39234af 100644
--- a/src/mesa/drivers/dri/r600/r700_fragprog.c
+++ b/src/mesa/drivers/dri/r600/r700_fragprog.c
@@ -226,22 +226,23 @@ void Map_Fragment_Program(r700_AssemblerBase         *pAsm,
 	pAsm->number_of_exports = 0;
 	pAsm->number_of_colorandz_exports = 0; /* don't include stencil and mask out. */
 	pAsm->starting_export_register_number = pAsm->number_used_registers;
-	unBit = 1 << FRAG_RESULT_COLOR;
-	if(mesa_fp->Base.OutputsWritten & unBit)
-	{
-		pAsm->uiFP_OutputMap[FRAG_RESULT_COLOR] = pAsm->number_used_registers++;
-		pAsm->number_of_exports++;
-		pAsm->number_of_colorandz_exports++;
-	}
-	unBit = 1 << FRAG_RESULT_DEPTH;
-	if(mesa_fp->Base.OutputsWritten & unBit)
-	{
-        pAsm->depth_export_register_number = pAsm->number_used_registers;
-		pAsm->uiFP_OutputMap[FRAG_RESULT_DEPTH] = pAsm->number_used_registers++;
-		pAsm->number_of_exports++;
-		pAsm->number_of_colorandz_exports++;
-		pAsm->pR700Shader->depthIsExported = 1;
-	}
+
+    for (i = 0; i < FRAG_RESULT_MAX; ++i)
+    {
+        unBit = 1 << i;
+        if (mesa_fp->Base.OutputsWritten & unBit)
+        {
+            if (i == FRAG_RESULT_DEPTH)
+            {
+                pAsm->depth_export_register_number = pAsm->number_used_registers;
+                pAsm->pR700Shader->depthIsExported = 1;
+            }
+
+            pAsm->uiFP_OutputMap[i] = pAsm->number_used_registers++;
+            ++pAsm->number_of_exports;
+            ++pAsm->number_of_colorandz_exports;
+        }
+    }
 
     pAsm->pucOutMask = (unsigned char*) MALLOC(pAsm->number_of_exports);
     for(ui=0; ui<pAsm->number_of_exports; ui++)
@@ -560,27 +561,34 @@ GLboolean r700SetupFragmentProgram(GLcontext * ctx)
         CLEARbit(r700->SPI_PS_IN_CONTROL_1.u32All, FRONT_FACE_ENA_bit);
     }
 
-    /* see if we need any point_sprite replacements */
-    for (i = VERT_RESULT_TEX0; i<= VERT_RESULT_TEX7; i++)
+    /* see if we need any point_sprite replacements, also increase num_interp
+     * as there's no vp output for them */
+    if (ctx->Point.PointSprite)
     {
-        if(ctx->Point.CoordReplace[i - VERT_RESULT_TEX0] == GL_TRUE)
-            point_sprite = GL_TRUE;
+        for (i = FRAG_ATTRIB_TEX0; i<= FRAG_ATTRIB_TEX7; i++)
+        {
+            if (ctx->Point.CoordReplace[i - FRAG_ATTRIB_TEX0] == GL_TRUE)
+            {
+                ui++;
+                point_sprite = GL_TRUE;
+            }
+        }
     }
 
+    if( mesa_fp->Base.InputsRead & (1 << FRAG_ATTRIB_PNTC))
+        ui++;
+
     if ((mesa_fp->Base.InputsRead & (1 << FRAG_ATTRIB_PNTC)) || point_sprite)
     {
-        /* for FRAG_ATTRIB_PNTC we need to increase num_interp */
-        if(mesa_fp->Base.InputsRead & (1 << FRAG_ATTRIB_PNTC))
-        {
-            ui++;
-            SETfield(r700->SPI_PS_IN_CONTROL_0.u32All, ui, NUM_INTERP_shift, NUM_INTERP_mask);
-        }
+        SETfield(r700->SPI_PS_IN_CONTROL_0.u32All, ui, NUM_INTERP_shift, NUM_INTERP_mask);
         SETbit(r700->SPI_INTERP_CONTROL_0.u32All, PNT_SPRITE_ENA_bit);
         SETfield(r700->SPI_INTERP_CONTROL_0.u32All, SPI_PNT_SPRITE_SEL_S, PNT_SPRITE_OVRD_X_shift, PNT_SPRITE_OVRD_X_mask);
         SETfield(r700->SPI_INTERP_CONTROL_0.u32All, SPI_PNT_SPRITE_SEL_T, PNT_SPRITE_OVRD_Y_shift, PNT_SPRITE_OVRD_Y_mask);
         SETfield(r700->SPI_INTERP_CONTROL_0.u32All, SPI_PNT_SPRITE_SEL_0, PNT_SPRITE_OVRD_Z_shift, PNT_SPRITE_OVRD_Z_mask);
         SETfield(r700->SPI_INTERP_CONTROL_0.u32All, SPI_PNT_SPRITE_SEL_1, PNT_SPRITE_OVRD_W_shift, PNT_SPRITE_OVRD_W_mask);
-        if(ctx->Point.SpriteOrigin == GL_LOWER_LEFT)
+        /* Like e.g. viewport and winding, point sprite coordinates are
+         * inverted when rendering to FBO. */
+        if ((ctx->Point.SpriteOrigin == GL_LOWER_LEFT) == !ctx->DrawBuffer->Name)
             SETbit(r700->SPI_INTERP_CONTROL_0.u32All, PNT_SPRITE_TOP_1_bit);
         else
             CLEARbit(r700->SPI_INTERP_CONTROL_0.u32All, PNT_SPRITE_TOP_1_bit);
@@ -668,8 +676,9 @@ GLboolean r700SetupFragmentProgram(GLcontext * ctx)
 
     for(i=0; i<8; i++)
     {
+	    GLboolean coord_replace = ctx->Point.PointSprite && ctx->Point.CoordReplace[i];
 	    unBit = 1 << (VERT_RESULT_TEX0 + i);
-	    if(OutputsWritten & unBit)
+	    if ((OutputsWritten & unBit) || coord_replace)
 	    {
 		    ui = pAsm->uiFP_AttributeMap[FRAG_ATTRIB_TEX0 + i];
 		    SETbit(r700->SPI_PS_INPUT_CNTL[ui].u32All, SEL_CENTROID_bit);
@@ -677,7 +686,7 @@ GLboolean r700SetupFragmentProgram(GLcontext * ctx)
 			     SEMANTIC_shift, SEMANTIC_mask);
 		    CLEARbit(r700->SPI_PS_INPUT_CNTL[ui].u32All, FLAT_SHADE_bit);
 		    /* ARB_point_sprite */
-		    if(ctx->Point.CoordReplace[i] == GL_TRUE)
+		    if (coord_replace)
 		    {
 			     SETbit(r700->SPI_PS_INPUT_CNTL[ui].u32All, PT_SPRITE_TEX_bit);
 		    }
diff --git a/src/mesa/drivers/dri/r600/r700_vertprog.c b/src/mesa/drivers/dri/r600/r700_vertprog.c
index 05c6516..14dd2a5 100644
--- a/src/mesa/drivers/dri/r600/r700_vertprog.c
+++ b/src/mesa/drivers/dri/r600/r700_vertprog.c
@@ -628,6 +628,16 @@ GLboolean r700SetupVertexProgram(GLcontext * ctx)
 
     R600_STATECHANGE(context, spi);
 
+    if(vp->mesa_program->Base.OutputsWritten & (1 << VERT_RESULT_PSIZ)) {
+        R600_STATECHANGE(context, cl);
+        SETbit(r700->PA_CL_VS_OUT_CNTL.u32All, USE_VTX_POINT_SIZE_bit);
+        SETbit(r700->PA_CL_VS_OUT_CNTL.u32All, VS_OUT_MISC_VEC_ENA_bit);
+    } else if (r700->PA_CL_VS_OUT_CNTL.u32All != 0) {
+        R600_STATECHANGE(context, cl);
+        CLEARbit(r700->PA_CL_VS_OUT_CNTL.u32All, USE_VTX_POINT_SIZE_bit);
+        CLEARbit(r700->PA_CL_VS_OUT_CNTL.u32All, VS_OUT_MISC_VEC_ENA_bit);
+    }
+
     SETfield(r700->SPI_VS_OUT_CONFIG.u32All,
 	     vp->r700Shader.nParamExports ? (vp->r700Shader.nParamExports - 1) : 0,
              VS_EXPORT_COUNT_shift, VS_EXPORT_COUNT_mask);
diff --git a/src/mesa/drivers/dri/radeon/radeon_chipset.h b/src/mesa/drivers/dri/radeon/radeon_chipset.h
index 98732c8..6dbfdc9 100644
--- a/src/mesa/drivers/dri/radeon/radeon_chipset.h
+++ b/src/mesa/drivers/dri/radeon/radeon_chipset.h
@@ -413,9 +413,9 @@ enum {
    CHIP_FAMILY_R350,
    CHIP_FAMILY_RV350,
    CHIP_FAMILY_RV380,
+   CHIP_FAMILY_RS400,
    CHIP_FAMILY_R420,
    CHIP_FAMILY_RV410,
-   CHIP_FAMILY_RS400,
    CHIP_FAMILY_RS600,
    CHIP_FAMILY_RS690,
    CHIP_FAMILY_RS740,
diff --git a/src/mesa/drivers/dri/radeon/radeon_common_context.c b/src/mesa/drivers/dri/radeon/radeon_common_context.c
index 94f4766..5a7d52c 100644
--- a/src/mesa/drivers/dri/radeon/radeon_common_context.c
+++ b/src/mesa/drivers/dri/radeon/radeon_common_context.c
@@ -300,10 +300,10 @@ void radeonDestroyContext(__DRIcontext *driContextPriv )
 	_mesa_meta_free(radeon->glCtx);
 
 	if (radeon == current) {
-		radeon_firevertices(radeon);
 		_mesa_make_current(NULL, NULL, NULL);
 	}
 
+	radeon_firevertices(radeon);
 	if (!is_empty_list(&radeon->dma.reserved)) {
 		rcommonFlushCmdBuf( radeon, __FUNCTION__ );
 	}
diff --git a/src/mesa/drivers/dri/radeon/radeon_mipmap_tree.c b/src/mesa/drivers/dri/radeon/radeon_mipmap_tree.c
index 6c570a5..f3ce852 100644
--- a/src/mesa/drivers/dri/radeon/radeon_mipmap_tree.c
+++ b/src/mesa/drivers/dri/radeon/radeon_mipmap_tree.c
@@ -588,17 +588,17 @@ int radeon_validate_texture_miptree(GLcontext * ctx, struct gl_texture_object *t
 			__FUNCTION__, texObj ,t->minLod, t->maxLod);
 
 	radeon_mipmap_tree *dst_miptree;
-	dst_miptree = get_biggest_matching_miptree(t, t->minLod, t->maxLod);
+	dst_miptree = get_biggest_matching_miptree(t, t->base.BaseLevel, t->base.MaxLevel);
 
+	radeon_miptree_unreference(&t->mt);
 	if (!dst_miptree) {
-		radeon_miptree_unreference(&t->mt);
 		radeon_try_alloc_miptree(rmesa, t);
-		dst_miptree = t->mt;
 		radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
 			"%s: No matching miptree found, allocated new one %p\n",
 			__FUNCTION__, t->mt);
 
 	} else {
+		radeon_miptree_reference(dst_miptree, &t->mt);
 		radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
 			"%s: Using miptree %p\n", __FUNCTION__, t->mt);
 	}
@@ -615,7 +615,7 @@ int radeon_validate_texture_miptree(GLcontext * ctx, struct gl_texture_object *t
 				"Checking image level %d, face %d, mt %p ... ",
 				level, face, img->mt);
 			
-			if (img->mt != dst_miptree) {
+			if (img->mt != t->mt) {
 				radeon_print(RADEON_TEXTURE, RADEON_TRACE,
 					"MIGRATING\n");
 
@@ -623,7 +623,7 @@ int radeon_validate_texture_miptree(GLcontext * ctx, struct gl_texture_object *t
 				if (src_bo && radeon_bo_is_referenced_by_cs(src_bo, rmesa->cmdbuf.cs)) {
 					radeon_firevertices(rmesa);
 				}
-				migrate_image_to_miptree(dst_miptree, img, face, level);
+				migrate_image_to_miptree(t->mt, img, face, level);
 			} else
 				radeon_print(RADEON_TEXTURE, RADEON_TRACE, "OK\n");
 		}
diff --git a/src/mesa/drivers/dri/radeon/radeon_tex_copy.c b/src/mesa/drivers/dri/radeon/radeon_tex_copy.c
index 5cfad6f..fb6f2e5 100644
--- a/src/mesa/drivers/dri/radeon/radeon_tex_copy.c
+++ b/src/mesa/drivers/dri/radeon/radeon_tex_copy.c
@@ -52,22 +52,34 @@ do_copy_texsubimage(GLcontext *ctx,
     gl_format dst_mesaformat;
     unsigned src_width;
     unsigned dst_width;
+    unsigned flip_y;
 
     if (!radeon->vtbl.blit) {
         return GL_FALSE;
     }
 
     if (_mesa_get_format_bits(timg->base.TexFormat, GL_DEPTH_BITS) > 0) {
-        rrb = radeon_get_depthbuffer(radeon);
+        if (ctx->ReadBuffer->_DepthBuffer && ctx->ReadBuffer->_DepthBuffer->Wrapped) {
+            rrb = radeon_renderbuffer(ctx->ReadBuffer->_DepthBuffer->Wrapped);
+        } else {
+            rrb = radeon_renderbuffer(ctx->ReadBuffer->_DepthBuffer);
+        }
+        flip_y = ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Type == GL_NONE;
     } else {
-        rrb = radeon_get_colorbuffer(radeon);
+        rrb = radeon_renderbuffer(ctx->ReadBuffer->_ColorReadBuffer);
+        flip_y = ctx->ReadBuffer->Attachment[BUFFER_COLOR0].Type == GL_NONE;
+    }
+
+    // This is software renderbuffer, fallback to swrast
+    if (!rrb) {
+        return GL_FALSE;
     }
 
     if (!timg->mt) {
         radeon_validate_texture_miptree(ctx, &tobj->base);
     }
 
-    assert(rrb && rrb->bo);
+    assert(rrb->bo);
     assert(timg->mt);
     assert(timg->mt->bo);
     assert(timg->base.Width >= dstx + width);
@@ -124,7 +136,7 @@ do_copy_texsubimage(GLcontext *ctx,
                              timg->mt->bo, dst_offset, dst_mesaformat,
                              timg->mt->levels[level].rowstride / dst_bpp,
                              dst_width, timg->base.Height,
-                             dstx, dsty, width, height, 1);
+                             dstx, dsty, width, height, flip_y);
 }
 
 void
diff --git a/src/mesa/drivers/dri/radeon/radeon_texture.c b/src/mesa/drivers/dri/radeon/radeon_texture.c
index ff37fd3..caa55d2 100644
--- a/src/mesa/drivers/dri/radeon/radeon_texture.c
+++ b/src/mesa/drivers/dri/radeon/radeon_texture.c
@@ -1016,7 +1016,15 @@ radeon_get_tex_image(GLcontext * ctx, GLenum target, GLint level,
 			__func__, ctx, texObj, image, compressed);
 
 	if (image->mt) {
+		radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
 		/* Map the texture image read-only */
+		if (radeon_bo_is_referenced_by_cs(image->mt->bo, rmesa->cmdbuf.cs)) {
+				radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
+				    "%s: called for texture that is queued for GPU processing\n",
+				    __func__);
+				radeon_firevertices(rmesa);
+		}
+
 		radeon_teximage_map(image, GL_FALSE);
 	} else {
 		/* Image hasn't been uploaded to a miptree yet */
diff --git a/src/mesa/drivers/osmesa/osmesa.c b/src/mesa/drivers/osmesa/osmesa.c
index e376f12..c5e874b 100644
--- a/src/mesa/drivers/osmesa/osmesa.c
+++ b/src/mesa/drivers/osmesa/osmesa.c
@@ -1061,7 +1061,6 @@ OSMesaCreateContextExt( GLenum format, GLint depthBits, GLint stencilBits,
    struct dd_function_table functions;
    GLint rind, gind, bind, aind;
    GLint redBits = 0, greenBits = 0, blueBits = 0, alphaBits =0;
-   GLenum type = CHAN_TYPE;
 
    rind = gind = bind = aind = 0;
    if (format==OSMESA_RGBA) {
@@ -1329,6 +1328,7 @@ OSMesaMakeCurrent( OSMesaContext osmesa, void *buffer, GLenum type,
     * size.
     */
    osmesa->rb = new_osmesa_renderbuffer(&osmesa->mesa, osmesa->format, type);
+   _mesa_remove_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT);
    _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT, osmesa->rb);
    assert(osmesa->rb->RefCount == 2);
 
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 71d1514..98bb7fa 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -1880,7 +1880,7 @@ _mesa_BufferObjectUnpurgeable(GLcontext *ctx, GLuint name, GLenum option)
 
    bufObj->Purgeable = GL_FALSE;
 
-   retval = GL_RETAINED_APPLE;
+   retval = option;
    if (ctx->Driver.BufferObjectUnpurgeable)
       retval = ctx->Driver.BufferObjectUnpurgeable(ctx, bufObj, option);
 
@@ -1910,11 +1910,11 @@ _mesa_RenderObjectUnpurgeable(GLcontext *ctx, GLuint name, GLenum option)
 
    bufObj->Purgeable = GL_FALSE;
 
-   retval = GL_RETAINED_APPLE;
+   retval = option;
    if (ctx->Driver.RenderObjectUnpurgeable)
       retval = ctx->Driver.RenderObjectUnpurgeable(ctx, bufObj, option);
 
-   return option;
+   return retval;
 }
 
 
@@ -1940,7 +1940,7 @@ _mesa_TextureObjectUnpurgeable(GLcontext *ctx, GLuint name, GLenum option)
 
    bufObj->Purgeable = GL_FALSE;
 
-   retval = GL_RETAINED_APPLE;
+   retval = option;
    if (ctx->Driver.TextureObjectUnpurgeable)
       retval = ctx->Driver.TextureObjectUnpurgeable(ctx, bufObj, option);
 
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 73126b9..1dc0c9c 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1358,6 +1358,8 @@ _mesa_make_current( GLcontext *newCtx, GLframebuffer *drawBuffer,
       if (newCtx->FirstTimeCurrent) {
          _mesa_compute_version(newCtx);
 
+         newCtx->Extensions.String = _mesa_make_extension_string(newCtx);
+
          check_context_limits(newCtx);
 
          /* We can use this to help debug user's problems.  Tell them to set
diff --git a/src/mesa/main/getstring.c b/src/mesa/main/getstring.c
index 51dd5f7..b9daaba 100644
--- a/src/mesa/main/getstring.c
+++ b/src/mesa/main/getstring.c
@@ -71,8 +71,6 @@ _mesa_GetString( GLenum name )
       case GL_VERSION:
          return (const GLubyte *) ctx->VersionString;
       case GL_EXTENSIONS:
-         if (!ctx->Extensions.String)
-            ctx->Extensions.String = _mesa_make_extension_string(ctx);
          return (const GLubyte *) ctx->Extensions.String;
 #if FEATURE_ARB_shading_language_100
       case GL_SHADING_LANGUAGE_VERSION_ARB:
diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index b971cc9..db84de2 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -537,7 +537,7 @@ _mesa_update_state_locked( GLcontext *ctx )
 
    /* Determine which state flags effect vertex/fragment program state */
    if (ctx->FragmentProgram._MaintainTexEnvProgram) {
-      prog_flags |= (_NEW_TEXTURE | _NEW_FOG |
+      prog_flags |= (_NEW_BUFFERS | _NEW_TEXTURE | _NEW_FOG |
 		     _NEW_ARRAY | _NEW_LIGHT | _NEW_POINT | _NEW_RENDERMODE |
 		     _NEW_PROGRAM);
    }
diff --git a/src/mesa/main/texenvprogram.c b/src/mesa/main/texenvprogram.c
index 964ba13..df09c12 100644
--- a/src/mesa/main/texenvprogram.c
+++ b/src/mesa/main/texenvprogram.c
@@ -98,6 +98,7 @@ struct state_key {
    GLuint fog_enabled:1;
    GLuint fog_mode:2;          /**< FOG_x */
    GLuint inputs_available:12;
+   GLuint num_draw_buffers:4;
 
    /* NOTE: This array of structs must be last! (see "keySize" below) */
    struct {
@@ -485,6 +486,9 @@ static GLuint make_state_key( GLcontext *ctx,  struct state_key *key )
       inputs_referenced |= FRAG_BIT_FOGC; /* maybe */
    }
 
+   /* _NEW_BUFFERS */
+   key->num_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;
+
    key->inputs_available = (inputs_available & inputs_referenced);
 
    /* compute size of state key, ignoring unused texture units */
@@ -1199,11 +1203,14 @@ emit_texenv(struct texenv_fragment_program *p, GLuint unit)
    else
       alpha_saturate = GL_FALSE;
 
-   /* If this is the very last calculation, emit direct to output reg:
+   /* If this is the very last calculation (and various other conditions
+    * are met), emit directly to the color output register.  Otherwise,
+    * emit to a temporary register.
     */
    if (key->separate_specular ||
        unit != p->last_tex_stage ||
        alpha_shift ||
+       key->num_draw_buffers != 1 ||
        rgb_shift)
       dest = get_temp( p );
    else
@@ -1438,10 +1445,10 @@ create_new_program(GLcontext *ctx, struct state_key *key,
    p.program->Base.Parameters = _mesa_new_parameter_list();
    p.program->Base.InputsRead = 0x0;
 
-   if (ctx->DrawBuffer->_NumColorDrawBuffers == 1)
+   if (key->num_draw_buffers == 1)
       p.program->Base.OutputsWritten = 1 << FRAG_RESULT_COLOR;
    else {
-      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++)
+      for (i = 0; i < key->num_draw_buffers; i++)
 	 p.program->Base.OutputsWritten |= (1 << (FRAG_RESULT_DATA0 + i));
    }
 
@@ -1493,8 +1500,8 @@ create_new_program(GLcontext *ctx, struct state_key *key,
 
    cf = get_source( &p, SRC_PREVIOUS, 0 );
 
-   for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
-      if (ctx->DrawBuffer->_NumColorDrawBuffers == 1)
+   for (i = 0; i < key->num_draw_buffers; i++) {
+      if (key->num_draw_buffers == 1)
 	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_COLOR );
       else {
 	 out = make_ureg( PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i );
diff --git a/src/mesa/main/version.h b/src/mesa/main/version.h
index 9955be2..af4e69f 100644
--- a/src/mesa/main/version.h
+++ b/src/mesa/main/version.h
@@ -34,8 +34,8 @@
 /* Mesa version */
 #define MESA_MAJOR 7
 #define MESA_MINOR 8
-#define MESA_PATCH 2
-#define MESA_VERSION_STRING "7.8.2"
+#define MESA_PATCH 3
+#define MESA_VERSION_STRING "7.8.3"
 
 /* To make version comparison easy */
 #define MESA_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff --git a/src/mesa/shader/slang/slang_builtin.c b/src/mesa/shader/slang/slang_builtin.c
index 791e751..f265285 100644
--- a/src/mesa/shader/slang/slang_builtin.c
+++ b/src/mesa/shader/slang/slang_builtin.c
@@ -399,7 +399,7 @@ lookup_statevar(const char *var, GLint index1, GLint index2, const char *field,
    }
 
    if (isMatrix) {
-      /* load all four columns of matrix */
+      /* load all four rows (or columns) of matrix */
       GLint pos[4];
       GLuint j;
       for (j = 0; j < 4; j++) {
@@ -489,9 +489,26 @@ emit_statevars(const char *name, int array_len,
          tokens[0] = STATE_TEXGEN;
          tokens[2] = STATE_TEXGEN_OBJECT_Q;
       }
+      else if (strcmp(name, "gl_TextureMatrix") == 0) {
+         tokens[0] = STATE_TEXTURE_MATRIX;
+         tokens[4] = STATE_MATRIX_TRANSPOSE;
+      }
+      else if (strcmp(name, "gl_TextureMatrixInverse") == 0) {
+         tokens[0] = STATE_TEXTURE_MATRIX;
+         tokens[4] = STATE_MATRIX_INVTRANS;
+      }
+      else if (strcmp(name, "gl_TextureMatrixTranspose") == 0) {
+         tokens[0] = STATE_TEXTURE_MATRIX;
+         tokens[4] = 0;
+      }
+      else if (strcmp(name, "gl_TextureMatrixInverseTranspose") == 0) {
+         tokens[0] = STATE_TEXTURE_MATRIX;
+         tokens[4] = STATE_MATRIX_INVERSE;
+      }
       else {
          return -1; /* invalid array name */
       }
+      /* emit state vars for each array element */
       for (i = 0; i < array_len; i++) {
          GLint p;
          tokens[1] = i;
@@ -513,6 +530,19 @@ emit_statevars(const char *name, int array_len,
       }
       return pos;
    }
+   else if (type->type == SLANG_SPEC_MAT4) {
+      /* unroll/emit 4 array rows (or columns) */
+      slang_type_specifier vec4;
+      GLint i, p, pos = -1;
+      vec4.type = SLANG_SPEC_VEC4;
+      for (i = 0; i < 4; i++) {
+         tokens[2] = tokens[3] = i; /* row[i] (or column[i]) of matrix */
+         p = emit_statevars(NULL, 0, &vec4, tokens, paramList);
+         if (pos == -1)
+            pos = p;
+      }
+      return pos;
+   }
    else {
       GLint pos;
       assert(type->type == SLANG_SPEC_VEC4 ||
diff --git a/src/mesa/shader/slang/slang_emit.c b/src/mesa/shader/slang/slang_emit.c
index 7c0ea0c..4155052 100644
--- a/src/mesa/shader/slang/slang_emit.c
+++ b/src/mesa/shader/slang/slang_emit.c
@@ -2362,7 +2362,10 @@ emit(slang_emit_info *emitInfo, slang_ir_node *n)
 #if 0
       assert(!n->Store);
 #endif
-      n->Store = n->Children[1]->Store;
+      if (n->Children[1]->Store)
+         n->Store = n->Children[1]->Store;
+      else
+         n->Store = n->Children[0]->Store;
       return inst;
 
    case IR_SCOPE:
@@ -2370,6 +2373,7 @@ emit(slang_emit_info *emitInfo, slang_ir_node *n)
       _slang_push_var_table(emitInfo->vt);
       inst = emit(emitInfo, n->Children[0]);
       _slang_pop_var_table(emitInfo->vt);
+      n->Store = n->Children[0]->Store;
       return inst;
 
    case IR_VAR_DECL:
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 5fcfa86..a64c561 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -1135,7 +1135,7 @@ st_destroy_drawpix(struct st_context *st)
    st_reference_fragprog(st, &st->drawpix.z_shader, NULL);
    st_reference_fragprog(st, &st->pixel_xfer.combined_prog, NULL);
    if (st->drawpix.vert_shaders[0])
-      free(st->drawpix.vert_shaders[0]);
+      ureg_free_tokens(st->drawpix.vert_shaders[0]);
    if (st->drawpix.vert_shaders[1])
-      free(st->drawpix.vert_shaders[1]);
+      ureg_free_tokens(st->drawpix.vert_shaders[1]);
 }
diff --git a/src/mesa/state_tracker/st_cb_fbo.c b/src/mesa/state_tracker/st_cb_fbo.c
index 00e9d1d..df5674d 100644
--- a/src/mesa/state_tracker/st_cb_fbo.c
+++ b/src/mesa/state_tracker/st_cb_fbo.c
@@ -460,26 +460,38 @@ static void
 st_validate_framebuffer(GLcontext *ctx, struct gl_framebuffer *fb)
 {
    struct pipe_screen *screen = ctx->st->pipe->screen;
-   const struct gl_renderbuffer *depthRb =
-      fb->Attachment[BUFFER_DEPTH].Renderbuffer;
-   const struct gl_renderbuffer *stencilRb =
-      fb->Attachment[BUFFER_STENCIL].Renderbuffer;
+   const struct gl_renderbuffer_attachment *depth =
+         &fb->Attachment[BUFFER_DEPTH];
+   const struct gl_renderbuffer_attachment *stencil =
+         &fb->Attachment[BUFFER_STENCIL];
    GLuint i;
 
-   if (stencilRb && depthRb && stencilRb != depthRb) {
+   if (depth->Type && stencil->Type && depth->Type != stencil->Type) {
+      fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
+      return;
+   }
+   if (depth->Type == GL_RENDERBUFFER_EXT &&
+       stencil->Type == GL_RENDERBUFFER_EXT &&
+       depth->Renderbuffer != stencil->Renderbuffer) {
+      fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
+      return;
+   }
+   if (depth->Type == GL_TEXTURE &&
+       stencil->Type == GL_TEXTURE &&
+       depth->Texture != stencil->Texture) {
       fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
       return;
    }
 
    if (!st_validate_attachment(screen,
-			       &fb->Attachment[BUFFER_DEPTH],
-			       PIPE_TEXTURE_USAGE_DEPTH_STENCIL)) {
+                               depth,
+                               PIPE_TEXTURE_USAGE_DEPTH_STENCIL)) {
       fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
       return;
    }
    if (!st_validate_attachment(screen,
-			       &fb->Attachment[BUFFER_STENCIL],
-			       PIPE_TEXTURE_USAGE_DEPTH_STENCIL)) {
+                               stencil,
+                               PIPE_TEXTURE_USAGE_DEPTH_STENCIL)) {
       fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
       return;
    }
diff --git a/src/mesa/state_tracker/st_cb_readpixels.c b/src/mesa/state_tracker/st_cb_readpixels.c
index 952d9ce..7ff10d4 100644
--- a/src/mesa/state_tracker/st_cb_readpixels.c
+++ b/src/mesa/state_tracker/st_cb_readpixels.c
@@ -69,6 +69,10 @@ st_read_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
    ubyte *stmap;
    GLint j;
 
+   if (strb->Base.Wrapped) {
+      strb = st_renderbuffer(strb->Base.Wrapped);
+   }
+
    if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
       y = ctx->DrawBuffer->Height - y - height;
    }
@@ -366,6 +370,9 @@ st_readpixels(GLcontext *ctx, GLint x, GLint y, GLsizei width, GLsizei height,
    }
    else if (format == GL_DEPTH_COMPONENT) {
       strb = st_renderbuffer(ctx->ReadBuffer->_DepthBuffer);
+      if (strb->Base.Wrapped) {
+         strb = st_renderbuffer(strb->Base.Wrapped);
+      }
    }
    else {
       /* Read color buffer */
diff --git a/src/mesa/state_tracker/st_mesa_to_tgsi.c b/src/mesa/state_tracker/st_mesa_to_tgsi.c
index d7ef57e..d08af62 100644
--- a/src/mesa/state_tracker/st_mesa_to_tgsi.c
+++ b/src/mesa/state_tracker/st_mesa_to_tgsi.c
@@ -683,8 +683,12 @@ emit_adjusted_wpos( struct st_translate *t,
    struct ureg_dst wpos_temp = ureg_DECL_temporary(ureg);
    struct ureg_src wpos_input = t->inputs[t->inputMapping[FRAG_ATTRIB_WPOS]];
 
-   ureg_ADD(ureg, ureg_writemask(wpos_temp, TGSI_WRITEMASK_X | TGSI_WRITEMASK_Y),
-		   wpos_input, ureg_imm1f(ureg, value));
+   /* Note that we bias X and Y and pass Z and W through unchanged.
+    * The shader might also use gl_FragCoord.w and .z.
+    */
+   ureg_ADD(ureg,
+            ureg_writemask(wpos_temp, TGSI_WRITEMASK_XYZW),
+            wpos_input, ureg_imm4f(ureg, value, value, 0.0f, 0.0f));
 
    t->inputs[t->inputMapping[FRAG_ATTRIB_WPOS]] = ureg_src(wpos_temp);
 }
diff --git a/src/mesa/swrast/s_span.c b/src/mesa/swrast/s_span.c
index 687c8eb..32d4f52 100644
--- a/src/mesa/swrast/s_span.c
+++ b/src/mesa/swrast/s_span.c
@@ -971,6 +971,10 @@ shade_texture_span(GLcontext *ctx, SWspan *span)
       if (span->primitive == GL_BITMAP && span->array->ChanType != GL_FLOAT) {
          convert_color_type(span, GL_FLOAT, 0);
       }
+      else {
+         span->array->rgba = (void *) span->array->attribs[FRAG_ATTRIB_COL0];
+      }
+
       if (span->primitive != GL_POINT ||
 	  (span->interpMask & SPAN_RGBA) ||
 	  ctx->Point.PointSprite) {
@@ -1222,9 +1226,22 @@ _swrast_write_rgba_span( GLcontext *ctx, SWspan *span)
             GLchan rgbaSave[MAX_WIDTH][4];
             const GLuint fragOutput = multiFragOutputs ? buf : 0;
 
+            /* set span->array->rgba to colors for render buffer's datatype */
             if (rb->DataType != span->array->ChanType || fragOutput > 0) {
                convert_color_type(span, rb->DataType, fragOutput);
             }
+            else {
+               if (rb->DataType == GL_UNSIGNED_BYTE) {
+                  span->array->rgba = span->array->rgba8;
+               }
+               else if (rb->DataType == GL_UNSIGNED_SHORT) {
+                  span->array->rgba = (void *) span->array->rgba16;
+               }
+               else {
+                  span->array->rgba = (void *)
+                     span->array->attribs[FRAG_ATTRIB_COL0];
+               }
+            }
 
             if (!multiFragOutputs && numBuffers > 1) {
                /* save colors for second, third renderbuffer writes */
diff --git a/src/mesa/swrast_setup/ss_context.c b/src/mesa/swrast_setup/ss_context.c
index ebd1574..0fcb7c7 100644
--- a/src/mesa/swrast_setup/ss_context.c
+++ b/src/mesa/swrast_setup/ss_context.c
@@ -115,7 +115,7 @@ setup_vertex_format(GLcontext *ctx)
    GLboolean intColors = !ctx->FragmentProgram._Current
                       && !ctx->ATIFragmentShader._Enabled
                       && ctx->RenderMode == GL_RENDER
-                      && CHAN_TYPE == GL_UNSIGNED_BYTE;
+                      && CHAN_TYPE != GL_FLOAT;
 
    if (intColors != swsetup->intColors ||
        !RENDERINPUTS_EQUAL(tnl->render_inputs_bitset,
diff --git a/src/mesa/swrast_setup/ss_triangle.c b/src/mesa/swrast_setup/ss_triangle.c
index bad0d81..f22bc52 100644
--- a/src/mesa/swrast_setup/ss_triangle.c
+++ b/src/mesa/swrast_setup/ss_triangle.c
@@ -159,7 +159,7 @@ static void _swsetup_render_tri(GLcontext *ctx,
 }
 
 #define SS_COLOR(a,b) UNCLAMPED_FLOAT_TO_RGBA_CHAN(a,b)
-#define SS_SPEC(a,b) UNCLAMPED_FLOAT_TO_RGB_CHAN(a,b)
+#define SS_SPEC(a,b) COPY_4V(a,b)
 #define SS_IND(a,b) (a = b)
 
 #define IND (0)
