diff --git a/COPYING b/COPYING
index 7f33cbf..529cbf2 100644
--- a/COPYING
+++ b/COPYING
@@ -1,12 +1,129 @@
-This is a stub file.  This package has not yet had its complete licensing
-information compiled.  Please see the individual source files for details on
-your rights to use and modify this software.
+Copyright 1997 through 2004 by Marc Aurele La France (TSI @ UQV), tsi@xfree86.org
 
-Please submit updated COPYING files to the Xorg bugzilla:
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting documentation, and
+that the name of Marc Aurele La France not be used in advertising or
+publicity pertaining to distribution of the software without specific,
+written prior permission.  Marc Aurele La France makes no representations
+about the suitability of this software for any purpose.  It is provided
+"as-is" without express or implied warranty.
 
-https://bugs.freedesktop.org/enter_bug.cgi?product=xorg
+MARC AURELE LA FRANCE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO
+EVENT SHALL MARC AURELE LA FRANCE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
 
-All licensing questions regarding this software should be directed at the
-Xorg mailing list:
+Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
+Copyright (c) 1995-2003 by The XFree86 Project, Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of the copyright holder(s)
+and author(s) shall not be used in advertising or otherwise to promote
+the sale, use or other dealings in this Software without prior written
+authorization from the copyright holder(s) and author(s).
+
+Copyright 2006-2007 Advanced Micro Devices, Inc.
+Copyright 2007  Egbert Eich   <eich@novell.com>
+Copyright 2007  Matthias Hopf <mhopf@novell.com>
+Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
+Copyright 2007  Luc Verhaegen <lverhaegen@novell.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Copyright 2007  Advanced Micro Devices, Inc.
+Copyright (C) 2008-2009  Advanced Micro Devices, Inc.
+Copyright 2004 Eric Anholt
+Copyright 2005 Eric Anholt
+Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
+Copyright 2004 ATI Technologies Inc., Markham, Ontario
+Copyright (C) 2008-2009  Alexander Deucher
+Copyright 2008 Jérôme Glisse
+Copyright 2005 Benjamin Herrenschmidt
+Copyright 2008 Kristian Høgsberg
+Copyright (C) 2008-2009  Matthias Hopf
+Copyright (c) 2006 Itronix Inc.
+Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+Copyright © 2007 Red Hat, Inc.
+Copyright © 2009 Red Hat, Inc.
+Copyright 2007 George Sapountzis
+Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
+Copyright 2006 Tungsten Graphics, Inc.
+Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice (including the next
+paragraph) shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
+Copyright © 2006 Keith Packard
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting documentation, and
+that the name of the copyright holders not be used in advertising or
+publicity pertaining to distribution of the software without specific,
+written prior permission.  The copyright holders make no representations
+about the suitability of this software for any purpose.  It is provided "as
+is" without express or implied warranty.
+
+THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+OF THIS SOFTWARE.
 
-http://lists.freedesktop.org/mailman/listinfo/xorg
diff --git a/configure.ac b/configure.ac
index c50528d..cf0a855 100644
--- a/configure.ac
+++ b/configure.ac
@@ -22,7 +22,7 @@
 
 AC_PREREQ(2.57)
 AC_INIT([xf86-video-ati],
-        6.13.0,
+        6.13.99,
         [https://bugs.freedesktop.org/enter_bug.cgi?product=xorg],
         xf86-video-ati)
 
@@ -152,6 +152,10 @@ if test "$DRI" = yes; then
                         else
                                 DRM_MODE=no
 			fi
+			PKG_CHECK_MODULES(LIBUDEV, [libudev], [LIBUDEV=yes], [LIBUDEV=no])
+			if test "x$LIBUDEV" = xyes; then
+			       AC_DEFINE(HAVE_LIBUDEV, 1,[libudev support])
+			fi
         	fi
 	fi
 	CFLAGS="$save_CFLAGS"
@@ -159,6 +163,7 @@ else
 	DRM_MODE=no
 fi
 AM_CONDITIONAL(DRM_MODE, test x$DRM_MODE = xyes)
+AM_CONDITIONAL(LIBUDEV, test x$LIBUDEV = xyes)
 
 save_CFLAGS="$CFLAGS"
 CFLAGS="$XORG_CFLAGS"
@@ -358,6 +363,8 @@ AC_SUBST([XORG_CFLAGS])
 AC_SUBST([DRI_CFLAGS])
 AC_SUBST([LIBDRM_RADEON_CFLAGS])
 AC_SUBST([LIBDRM_RADEON_LIBS])
+AC_SUBST([LIBUDEV_CFLAGS])
+AC_SUBST([LIBUDEV_LIBS])
 AC_SUBST([moduledir])
 
 DRIVER_NAME=ati
diff --git a/man/radeon.man b/man/radeon.man
index 05b7d16..673ab03 100644
--- a/man/radeon.man
+++ b/man/radeon.man
@@ -656,7 +656,7 @@ sizes are scaled to more than double to avoid blurred output.  Bicubic
 filtering is not currently compatible with other Xv attributes like hue,
 contrast, and brightness, and must be disabled to use those attributes.
 The default is
-.B 'auto'(2).
+.B 'off'(0).
 
 .SH SEE ALSO
 __xservername__(__appmansuffix__), __xconfigfile__(__filemansuffix__), Xserver(__appmansuffix__), X(__miscmansuffix__)
diff --git a/src/Makefile.am b/src/Makefile.am
index 0f89480..0ce46b0 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -78,6 +78,7 @@ AM_CFLAGS = \
             @XORG_CFLAGS@ \
             @DRI_CFLAGS@ \
             @XMODES_CFLAGS@ \
+            @LIBUDEV_CFLAGS@ \
             -DDISABLE_EASF \
             -DENABLE_ALL_SERVICE_FUNCTIONS \
             -DATOM_BIOS \
@@ -91,6 +92,10 @@ ati_drv_la_LIBADD = $(PCIACCESS_LIBS)
 radeon_drv_la_LIBADD += $(PCIACCESS_LIBS)
 endif
 
+if LIBUDEV
+radeon_drv_la_LIBADD += $(LIBUDEV_LIBS)
+endif
+
 ati_drv_la_LTLIBRARIES = ati_drv.la
 ati_drv_la_LDFLAGS = -module -avoid-version
 ati_drv_ladir = @moduledir@/drivers
diff --git a/src/ati_pciids_gen.h b/src/ati_pciids_gen.h
index f88b069..b4479ac 100644
--- a/src/ati_pciids_gen.h
+++ b/src/ati_pciids_gen.h
@@ -2,6 +2,7 @@
 #define PCI_CHIP_RV380_3151 0x3151
 #define PCI_CHIP_RV380_3152 0x3152
 #define PCI_CHIP_RV380_3154 0x3154
+#define PCI_CHIP_RV380_3155 0x3155
 #define PCI_CHIP_RV380_3E50 0x3E50
 #define PCI_CHIP_RV380_3E54 0x3E54
 #define PCI_CHIP_RS100_4136 0x4136
@@ -348,6 +349,7 @@
 #define PCI_CHIP_RV770_9456 0x9456
 #define PCI_CHIP_RV770_945A 0x945A
 #define PCI_CHIP_RV770_945B 0x945B
+#define PCI_CHIP_RV770_945E 0x945E
 #define PCI_CHIP_RV790_9460 0x9460
 #define PCI_CHIP_RV790_9462 0x9462
 #define PCI_CHIP_RV770_946A 0x946A
@@ -358,6 +360,7 @@
 #define PCI_CHIP_RV730_9487 0x9487
 #define PCI_CHIP_RV730_9488 0x9488
 #define PCI_CHIP_RV730_9489 0x9489
+#define PCI_CHIP_RV730_948A 0x948A
 #define PCI_CHIP_RV730_948F 0x948F
 #define PCI_CHIP_RV730_9490 0x9490
 #define PCI_CHIP_RV730_9491 0x9491
@@ -401,12 +404,14 @@
 #define PCI_CHIP_RV670_9519 0x9519
 #define PCI_CHIP_RV710_9540 0x9540
 #define PCI_CHIP_RV710_9541 0x9541
+#define PCI_CHIP_RV710_9542 0x9542
 #define PCI_CHIP_RV710_954E 0x954E
 #define PCI_CHIP_RV710_954F 0x954F
 #define PCI_CHIP_RV710_9552 0x9552
 #define PCI_CHIP_RV710_9553 0x9553
 #define PCI_CHIP_RV710_9555 0x9555
 #define PCI_CHIP_RV710_9557 0x9557
+#define PCI_CHIP_RV710_955F 0x955F
 #define PCI_CHIP_RV630_9580 0x9580
 #define PCI_CHIP_RV630_9581 0x9581
 #define PCI_CHIP_RV630_9583 0x9583
@@ -420,7 +425,6 @@
 #define PCI_CHIP_RV630_958D 0x958D
 #define PCI_CHIP_RV630_958E 0x958E
 #define PCI_CHIP_RV630_958F 0x958F
-#define PCI_CHIP_RV710_9542 0x9542
 #define PCI_CHIP_RV620_95C0 0x95C0
 #define PCI_CHIP_RV620_95C2 0x95C2
 #define PCI_CHIP_RV620_95C4 0x95C4
@@ -473,6 +477,7 @@
 #define PCI_CHIP_JUNIPER_68BE 0x68BE
 #define PCI_CHIP_REDWOOD_68C0 0x68C0
 #define PCI_CHIP_REDWOOD_68C1 0x68C1
+#define PCI_CHIP_REDWOOD_68C7 0x68C7
 #define PCI_CHIP_REDWOOD_68C8 0x68C8
 #define PCI_CHIP_REDWOOD_68C9 0x68C9
 #define PCI_CHIP_REDWOOD_68D8 0x68D8
diff --git a/src/atombios_crtc.c b/src/atombios_crtc.c
index 1d86643..6f083b4 100644
--- a/src/atombios_crtc.c
+++ b/src/atombios_crtc.c
@@ -458,6 +458,19 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
     unsigned char *space;
 
     memset(&spc_param, 0, sizeof(spc_param));
+
+    if (IS_AVIVO_VARIANT) {
+	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, TRUE))
+	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
+	else
+	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
+    } else {
+	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
+	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
+	else
+	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
+    }
+
     if (IS_AVIVO_VARIANT) {
 	if ((info->ChipFamily == CHIP_FAMILY_RS600) ||
 	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
@@ -471,6 +484,7 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
 	for (i = 0; i < xf86_config->num_output; i++) {
 	    xf86OutputPtr output = xf86_config->output[i];
 	    if (output->crtc == crtc) {
+		radeon_output = output->driver_private;
 		radeon_encoder = radeon_get_encoder(output);
 		/* DVO wants 2x pixel clock if the DVO chip is in 12 bit mode */
 		/* AdjustDisplayPll handles this on DCE3.x */
@@ -478,6 +492,11 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
 		    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1) &&
 		    !IS_DCE3_VARIANT)
 		    sclock *= 2;
+		if (radeon_output->active_device &
+		    (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT)) {
+		    pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;
+		    radeon_crtc->pll_algo = RADEON_PLL_OLD;
+		}
 	    }
 	}
 
@@ -614,7 +633,8 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
 	}
     }
 
-    RADEONComputePLL(pScrn, &info->pll, sclock, &temp, &fb_div, &frac_fb_div, &ref_div, &post_div, pll_flags);
+    RADEONComputePLL(crtc, &info->pll, sclock, &temp,
+		     &fb_div, &frac_fb_div, &ref_div, &post_div, pll_flags);
     sclock = temp; /* 10 khz */
 
     xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
diff --git a/src/atombios_output.c b/src/atombios_output.c
index 0a54657..3e2d301 100644
--- a/src/atombios_output.c
+++ b/src/atombios_output.c
@@ -1801,8 +1801,12 @@ atombios_output_mode_set(xf86OutputPtr output,
     case ENCODER_OBJECT_ID_INTERNAL_DAC2:
     case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
 	atombios_output_dac_setup(output, ATOM_ENABLE);
-	if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))
-	    atombios_output_tv_setup(output, ATOM_ENABLE);
+	if (radeon_output->devices & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) {
+		if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))
+			atombios_output_tv_setup(output, ATOM_ENABLE);
+		else
+			atombios_output_tv_setup(output, ATOM_DISABLE);
+	}
 	break;
     }
     atombios_apply_output_quirks(output, adjusted_mode);
diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index 399a6a7..1366b36 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -292,7 +292,7 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
 #endif
 	}
 
-	output_ids = xcalloc(sizeof(uint32_t), xf86_config->num_output);
+	output_ids = calloc(sizeof(uint32_t), xf86_config->num_output);
 	if (!output_ids) {
 		ret = FALSE;
 		goto done;
@@ -522,6 +522,32 @@ static const xf86CrtcFuncsRec drmmode_crtc_funcs = {
     .destroy = NULL, /* XXX */
 };
 
+int drmmode_get_crtc_id(xf86CrtcPtr crtc)
+{
+	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+	return drmmode_crtc->hw_id;
+}
+
+void drmmode_crtc_hw_id(xf86CrtcPtr crtc)
+{
+	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+	ScrnInfoPtr pScrn = crtc->scrn;
+	RADEONInfoPtr info = RADEONPTR(pScrn);
+	struct drm_radeon_info ginfo;
+	int r;
+	uint32_t tmp;
+
+	memset(&ginfo, 0, sizeof(ginfo));
+	ginfo.request = 0x4;
+	tmp = drmmode_crtc->mode_crtc->crtc_id;
+	ginfo.value = (uintptr_t)&tmp;
+	r = drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INFO, &ginfo, sizeof(ginfo));
+	if (r) {
+		drmmode_crtc->hw_id = -1;
+		return;
+	}
+	drmmode_crtc->hw_id = tmp;
+}
 
 static void
 drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
@@ -537,6 +563,7 @@ drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
 	drmmode_crtc->mode_crtc = drmModeGetCrtc(drmmode->fd, drmmode->mode_res->crtcs[num]);
 	drmmode_crtc->drmmode = drmmode;
 	crtc->driver_private = drmmode_crtc;
+	drmmode_crtc_hw_id(crtc);
 
 	return;
 }
@@ -622,15 +649,15 @@ drmmode_output_destroy(xf86OutputPtr output)
 		drmModeFreePropertyBlob(drmmode_output->edid_blob);
 	for (i = 0; i < drmmode_output->num_props; i++) {
 		drmModeFreeProperty(drmmode_output->props[i].mode_prop);
-		xfree(drmmode_output->props[i].atoms);
+		free(drmmode_output->props[i].atoms);
 	}
 	for (i = 0; i < drmmode_output->mode_output->count_encoders; i++) {
 		drmModeFreeEncoder(drmmode_output->mode_encoders[i]);
-		xfree(drmmode_output->mode_encoders);
+		free(drmmode_output->mode_encoders);
 	}
-	xfree(drmmode_output->props);
+	free(drmmode_output->props);
 	drmModeFreeConnector(drmmode_output->mode_output);
-	xfree(drmmode_output);
+	free(drmmode_output);
 	output->driver_private = NULL;
 }
 
@@ -672,7 +699,7 @@ drmmode_output_create_resources(xf86OutputPtr output)
     drmModePropertyPtr drmmode_prop;
     int i, j, err;
 
-    drmmode_output->props = xcalloc(mode_output->count_props, sizeof(drmmode_prop_rec));
+    drmmode_output->props = calloc(mode_output->count_props, sizeof(drmmode_prop_rec));
     if (!drmmode_output->props)
 	return;
     
@@ -695,9 +722,10 @@ drmmode_output_create_resources(xf86OutputPtr output)
 
 	if (drmmode_prop->flags & DRM_MODE_PROP_RANGE) {
 	    INT32 range[2];
+	    INT32 value = p->value;
 
 	    p->num_atoms = 1;
-	    p->atoms = xcalloc(p->num_atoms, sizeof(Atom));
+	    p->atoms = calloc(p->num_atoms, sizeof(Atom));
 	    if (!p->atoms)
 		continue;
 	    p->atoms[0] = MakeAtom(drmmode_prop->name, strlen(drmmode_prop->name), TRUE);
@@ -712,14 +740,14 @@ drmmode_output_create_resources(xf86OutputPtr output)
 			"RRConfigureOutputProperty error, %d\n", err);
 	    }
 	    err = RRChangeOutputProperty(output->randr_output, p->atoms[0],
-		    XA_INTEGER, 32, PropModeReplace, 1, &p->value, FALSE, TRUE);
+		    XA_INTEGER, 32, PropModeReplace, 1, &value, FALSE, TRUE);
 	    if (err != 0) {
 		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
 			"RRChangeOutputProperty error, %d\n", err);
 	    }
 	} else if (drmmode_prop->flags & DRM_MODE_PROP_ENUM) {
 	    p->num_atoms = drmmode_prop->count_enums + 1;
-	    p->atoms = xcalloc(p->num_atoms, sizeof(Atom));
+	    p->atoms = calloc(p->num_atoms, sizeof(Atom));
 	    if (!p->atoms)
 		continue;
 	    p->atoms[0] = MakeAtom(drmmode_prop->name, strlen(drmmode_prop->name), TRUE);
@@ -868,7 +896,7 @@ drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
 	if (!koutput)
 		return;
 
-	kencoders = xcalloc(sizeof(drmModeEncoderPtr), koutput->count_encoders);
+	kencoders = calloc(sizeof(drmModeEncoderPtr), koutput->count_encoders);
 	if (!kencoders) {
 		goto out_free_encoders;
 	}
@@ -917,7 +945,7 @@ drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
 		goto out_free_encoders;
 	}
 
-	drmmode_output = xcalloc(sizeof(drmmode_output_private_rec), 1);
+	drmmode_output = calloc(sizeof(drmmode_output_private_rec), 1);
 	if (!drmmode_output) {
 		xf86OutputDestroy(output);
 		goto out_free_encoders;
@@ -933,7 +961,7 @@ drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
 	output->subpixel_order = subpixel_conv_table[koutput->subpixel];
 	output->driver_private = drmmode_output;
 	
-	output->possible_crtcs = 0xf;
+	output->possible_crtcs = 0x7f;
 	for (i = 0; i < koutput->count_encoders; i++) {
 		output->possible_crtcs &= kencoders[i]->possible_crtcs;
 	}
@@ -957,7 +985,7 @@ out_free_encoders:
 	if (kencoders){
 		for (i = 0; i < koutput->count_encoders; i++)
 			drmModeFreeEncoder(kencoders[i]);
-		xfree(kencoders);
+		free(kencoders);
 	}
 	drmModeFreeConnector(koutput);
 	
@@ -1102,10 +1130,10 @@ drmmode_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
 	} else {
 		if (radeon_bo_map(info->front_bo, 1))
 			goto fail;
-		fb_shadow = xcalloc(1, screen_size);
+		fb_shadow = calloc(1, screen_size);
 		if (fb_shadow == NULL)
 			goto fail;
-		xfree(info->fb_shadow);
+		free(info->fb_shadow);
 		info->fb_shadow = fb_shadow;
 		screen->ModifyPixmapHeader(screen->GetScreenPixmap(screen),
 					   width, height, -1, -1, pitch * cpp,
@@ -1150,15 +1178,34 @@ static const xf86CrtcConfigFuncsRec drmmode_xf86crtc_config_funcs = {
 	drmmode_xf86crtc_resize
 };
 
+static void
+drmmode_vblank_handler(int fd, unsigned int frame, unsigned int tv_sec,
+			unsigned int tv_usec, void *event_data)
+{
+	radeon_dri2_frame_event_handler(frame, tv_sec, tv_usec, event_data);
+}
+
+static void
+drm_wakeup_handler(pointer data, int err, pointer p)
+{
+	drmmode_ptr drmmode = data;
+	fd_set *read_mask = p;
+
+	if (err >= 0 && FD_ISSET(drmmode->fd, read_mask)) {
+		drmHandleEvent(drmmode->fd, &drmmode->event_context);
+	}
+}
 
 Bool drmmode_pre_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int cpp)
 {
-	xf86CrtcConfigPtr   xf86_config;
+	xf86CrtcConfigPtr xf86_config;
+	RADEONInfoPtr info = RADEONPTR(pScrn);
 	int i;
 
 	xf86CrtcConfigInit(pScrn, &drmmode_xf86crtc_config_funcs);
 	xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
 
+	drmmode->scrn = pScrn;
 	drmmode->cpp = cpp;
 	drmmode->mode_res = drmModeGetResources(drmmode->fd);
 	if (!drmmode->mode_res)
@@ -1177,6 +1224,16 @@ Bool drmmode_pre_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int cpp)
 
 	xf86InitialConfiguration(pScrn, TRUE);
 
+	drmmode->flip_count = 0;
+	drmmode->event_context.version = DRM_EVENT_CONTEXT_VERSION;
+	drmmode->event_context.vblank_handler = drmmode_vblank_handler;
+	drmmode->event_context.page_flip_handler = NULL;
+	if (info->dri->pKernelDRMVersion->version_minor >= 4) {
+		AddGeneralSocket(drmmode->fd);
+		RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
+				drm_wakeup_handler, drmmode);
+	}
+
 	return TRUE;
 }
 
@@ -1347,4 +1404,67 @@ Bool drmmode_setup_colormap(ScreenPtr pScreen, ScrnInfoPtr pScrn)
          return FALSE;
     return TRUE;
 }
+
+#ifdef HAVE_LIBUDEV
+static void
+drmmode_handle_uevents(int fd, void *closure)
+{
+	drmmode_ptr drmmode = closure;
+	ScrnInfoPtr scrn = drmmode->scrn;
+	struct udev_device *dev;
+	dev = udev_monitor_receive_device(drmmode->uevent_monitor);
+	if (!dev)
+		return;
+
+	RRGetInfo(screenInfo.screens[scrn->scrnIndex], TRUE);
+	udev_device_unref(dev);
+}
+#endif
+
+void drmmode_uevent_init(ScrnInfoPtr scrn, drmmode_ptr drmmode)
+{
+#ifdef HAVE_LIBUDEV
+	struct udev *u;
+	struct udev_monitor *mon;
+
+	u = udev_new();
+	if (!u)
+		return;
+	mon = udev_monitor_new_from_netlink(u, "udev");
+	if (!mon) {
+		udev_unref(u);
+		return;
+	}
+
+	if (udev_monitor_filter_add_match_subsystem_devtype(mon,
+							    "drm",
+							    "drm_minor") < 0 ||
+	    udev_monitor_enable_receiving(mon) < 0) {
+		udev_monitor_unref(mon);
+		udev_unref(u);
+		return;
+	}
+
+	drmmode->uevent_handler =
+		xf86AddGeneralHandler(udev_monitor_get_fd(mon),
+				      drmmode_handle_uevents,
+				      drmmode);
+
+	drmmode->uevent_monitor = mon;
+#endif
+}
+
+void drmmode_uevent_fini(ScrnInfoPtr scrn, drmmode_ptr drmmode)
+{
+#ifdef HAVE_LIBUDEV
+	if (drmmode->uevent_handler) {
+		struct udev *u = udev_monitor_get_udev(drmmode->uevent_monitor);
+		xf86RemoveGeneralHandler(drmmode->uevent_handler);
+
+		udev_monitor_unref(drmmode->uevent_monitor);
+		udev_unref(u);
+	}
+#endif
+}
+
 #endif
diff --git a/src/drmmode_display.h b/src/drmmode_display.h
index 2e76259..a9891b2 100644
--- a/src/drmmode_display.h
+++ b/src/drmmode_display.h
@@ -30,6 +30,9 @@
 #ifdef XF86DRM_MODE
 
 #include "xf86drmMode.h"
+#ifdef HAVE_LIBUDEV
+#include "libudev.h"
+#endif
 
 #include "radeon_probe.h"
 
@@ -40,12 +43,19 @@ typedef struct {
   drmModeFBPtr mode_fb;
   int cpp;
   struct radeon_bo_manager *bufmgr;
+  ScrnInfoPtr scrn;
+#ifdef HAVE_LIBUDEV
+  struct udev_monitor *uevent_monitor;
+  InputHandlerProc uevent_handler;
+#endif
+  drmEventContext event_context;
+  int flip_count;
 } drmmode_rec, *drmmode_ptr;
 
 typedef struct {
-
     drmmode_ptr drmmode;
     drmModeCrtcPtr mode_crtc;
+    int hw_id;
     struct radeon_bo *cursor_bo;
     struct radeon_bo *rotate_bo;
     unsigned rotate_fb_id;
@@ -81,6 +91,10 @@ void drmmode_adjust_frame(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int x, int y,
 extern Bool drmmode_set_desired_modes(ScrnInfoPtr pScrn, drmmode_ptr drmmode);
 extern void drmmode_copy_fb(ScrnInfoPtr pScrn, drmmode_ptr drmmode);
 extern Bool drmmode_setup_colormap(ScreenPtr pScreen, ScrnInfoPtr pScrn);
+
+extern void drmmode_uevent_init(ScrnInfoPtr scrn, drmmode_ptr drmmode);
+extern void drmmode_uevent_fini(ScrnInfoPtr scrn, drmmode_ptr drmmode);
+
 #endif
 
 #endif
diff --git a/src/legacy_crtc.c b/src/legacy_crtc.c
index e4c1f04..0beb54d 100644
--- a/src/legacy_crtc.c
+++ b/src/legacy_crtc.c
@@ -1184,10 +1184,12 @@ RADEONInitCrtc2Registers(xf86CrtcPtr crtc, RADEONSavePtr save,
 
 /* Define PLL registers for requested video mode */
 static void
-RADEONInitPLLRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
+RADEONInitPLLRegisters(xf86CrtcPtr crtc, RADEONSavePtr save,
 		       RADEONPLLPtr pll, DisplayModePtr mode,
 		       int flags)
 {
+    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
+    ScrnInfoPtr pScrn = crtc->scrn;
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     uint32_t feedback_div = 0;
     uint32_t frac_fb_div = 0;
@@ -1223,7 +1225,13 @@ RADEONInitPLLRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
        return;
     }
 
-    RADEONComputePLL(pScrn, pll, mode->Clock, &freq, &feedback_div, &frac_fb_div, &reference_div, &post_divider, flags);
+    if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
+	radeon_crtc->pll_algo = RADEON_PLL_NEW;
+    else
+	radeon_crtc->pll_algo = RADEON_PLL_OLD;
+
+    RADEONComputePLL(crtc, pll, mode->Clock, &freq,
+		     &feedback_div, &frac_fb_div, &reference_div, &post_divider, flags);
 
     for (post_div = &post_divs[0]; post_div->divider; ++post_div) {
 	if (post_div->divider == post_divider)
@@ -1266,10 +1274,12 @@ RADEONInitPLLRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
 
 /* Define PLL2 registers for requested video mode */
 static void
-RADEONInitPLL2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save,
+RADEONInitPLL2Registers(xf86CrtcPtr crtc, RADEONSavePtr save,
 			RADEONPLLPtr pll, DisplayModePtr mode,
 			int flags)
 {
+    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
+    ScrnInfoPtr pScrn = crtc->scrn;
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     uint32_t feedback_div = 0;
     uint32_t frac_fb_div = 0;
@@ -1303,7 +1313,13 @@ RADEONInitPLL2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save,
        return;
     }
 
-    RADEONComputePLL(pScrn, pll, mode->Clock, &freq, &feedback_div, &frac_fb_div, &reference_div, &post_divider, flags);
+    if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
+	radeon_crtc->pll_algo = RADEON_PLL_NEW;
+    else
+	radeon_crtc->pll_algo = RADEON_PLL_OLD;
+
+    RADEONComputePLL(crtc, pll, mode->Clock, &freq,
+		     &feedback_div, &frac_fb_div, &reference_div, &post_divider, flags);
 
     for (post_div = &post_divs[0]; post_div->divider; ++post_div) {
 	if (post_div->divider == post_divider)
@@ -1795,7 +1811,7 @@ legacy_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
 	dot_clock = adjusted_mode->Clock / 1000.0;
 	if (dot_clock) {
 	    ErrorF("init pll1\n");
-	    RADEONInitPLLRegisters(pScrn, info->ModeReg, &info->pll, adjusted_mode, pll_flags);
+	    RADEONInitPLLRegisters(crtc, info->ModeReg, &info->pll, adjusted_mode, pll_flags);
 	} else {
 	    info->ModeReg->ppll_ref_div = info->SavedReg->ppll_ref_div;
 	    info->ModeReg->ppll_div_3   = info->SavedReg->ppll_div_3;
@@ -1809,7 +1825,7 @@ legacy_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
 	dot_clock = adjusted_mode->Clock / 1000.0;
 	if (dot_clock) {
 	    ErrorF("init pll2\n");
-	    RADEONInitPLL2Registers(pScrn, info->ModeReg, &info->pll, adjusted_mode, pll_flags);
+	    RADEONInitPLL2Registers(crtc, info->ModeReg, &info->pll, adjusted_mode, pll_flags);
 	}
 	break;
     }
diff --git a/src/legacy_output.c b/src/legacy_output.c
index fe0fbe3..670f1ba 100644
--- a/src/legacy_output.c
+++ b/src/legacy_output.c
@@ -165,7 +165,7 @@ RADEONGetExtTMDSInfo(ScrnInfoPtr pScrn, radeon_dvo_ptr dvo)
 	    dvo->DVOChip =
 		RADEONDVODeviceInit(dvo->pI2CBus, dvo->dvo_i2c_slave_addr);
 	    if (!dvo->DVOChip)
-		xfree(dvo->pI2CBus);
+		free(dvo->pI2CBus);
 	}
     }
 }
@@ -442,7 +442,7 @@ RADEONDVODeviceInit(I2CBusPtr b, I2CSlaveAddr addr)
 {
     I2CDevPtr dvo;
 
-    dvo = xcalloc(1, sizeof(I2CDevRec));
+    dvo = calloc(1, sizeof(I2CDevRec));
     if (dvo == NULL)
 	return NULL;
 
@@ -458,7 +458,7 @@ RADEONDVODeviceInit(I2CBusPtr b, I2CSlaveAddr addr)
 	return dvo;
     }
 
-    xfree(dvo);
+    free(dvo);
     return NULL;
 }
 
diff --git a/src/pcidb/ati_pciids.csv b/src/pcidb/ati_pciids.csv
index b26cf25..6f101b2 100644
--- a/src/pcidb/ati_pciids.csv
+++ b/src/pcidb/ati_pciids.csv
@@ -3,6 +3,7 @@
 "0x3151","RV380_3151","RV380",,,,,,"ATI FireMV 2400 (PCI)"
 "0x3152","RV380_3152","RV380",1,,,,,"ATI Radeon Mobility X300 (M24) 3152 (PCIE)"
 "0x3154","RV380_3154","RV380",1,,,,,"ATI FireGL M24 GL 3154 (PCIE)"
+"0x3155","RV380_3155","RV380",1,,,,,"ATI FireMV 2400 3155 (PCI)"
 "0x3E50","RV380_3E50","RV380",,,,,,"ATI Radeon X600 (RV380) 3E50 (PCIE)"
 "0x3E54","RV380_3E54","RV380",,,,,,"ATI FireGL V3200 (RV380) 3E54 (PCIE)"
 "0x4136","RS100_4136","RS100",,1,,,1,"ATI Radeon IGP320 (A3) 4136"
@@ -349,6 +350,7 @@
 "0x9456","RV770_9456","RV770",,,,,,"ATI FirePro V8700 (FireGL)"
 "0x945A","RV770_945A","RV770",1,,,,,"ATI Mobility RADEON HD 4870"
 "0x945B","RV770_945B","RV770",1,,,,,"ATI Mobility RADEON M98"
+"0x945E","RV770_945E","RV770",1,,,,,"ATI Mobility RADEON HD 4870"
 "0x9460","RV790_9460","RV770",,,,,,"ATI Radeon 4800 Series"
 "0x9462","RV790_9462","RV770",,,,,,"ATI Radeon 4800 Series"
 "0x946A","RV770_946A","RV770",1,,,,,"ATI FirePro M7750"
@@ -359,6 +361,7 @@
 "0x9487","RV730_9487","RV730",,,,,,"ATI Radeon RV730 (AGP)"
 "0x9488","RV730_9488","RV730",1,,,,,"ATI Mobility Radeon HD 4670"
 "0x9489","RV730_9489","RV730",1,,,,,"ATI FirePro M5750"
+"0x948A","RV730_948A","RV730",1,,,,,"ATI Mobility Radeon HD 4670"
 "0x948F","RV730_948F","RV730",,,,,,"ATI Radeon RV730 (AGP)"
 "0x9490","RV730_9490","RV730",,,,,,"ATI RV730XT [Radeon HD 4670]"
 "0x9491","RV730_9491","RV730",,,,,,"ATI RADEON E4600"
@@ -402,12 +405,14 @@
 "0x9519","RV670_9519","RV670",,,,,,"AMD Firestream 9170"
 "0x9540","RV710_9540","RV710",,,,,,"ATI Radeon HD 4550"
 "0x9541","RV710_9541","RV710",,,,,,"ATI Radeon RV710"
+"0x9542","RV710_9542","RV710",,,,,,"ATI Radeon RV710"
 "0x954E","RV710_954E","RV710",,,,,,"ATI Radeon RV710"
 "0x954F","RV710_954F","RV710",,,,,,"ATI Radeon HD 4350"
 "0x9552","RV710_9552","RV710",1,,,,,"ATI Mobility Radeon 4300 Series"
 "0x9553","RV710_9553","RV710",1,,,,,"ATI Mobility Radeon 4500 Series"
 "0x9555","RV710_9555","RV710",1,,,,,"ATI Mobility Radeon 4500 Series"
 "0x9557","RV710_9557","RV710",1,,,,,"ATI FirePro RG220"
+"0x955F","RV710_955F","RV710",1,,,,,"ATI Mobility Radeon 4330"
 "0x9580","RV630_9580","RV630",,,,,,"ATI RV630"
 "0x9581","RV630_9581","RV630",1,,,,,"ATI Mobility Radeon HD 2600"
 "0x9583","RV630_9583","RV630",1,,,,,"ATI Mobility Radeon HD 2600 XT"
@@ -421,7 +426,6 @@
 "0x958D","RV630_958D","RV630",,,,,,"ATI FireGL V3600"
 "0x958E","RV630_958E","RV630",,,,,,"ATI Radeon HD 2600 LE"
 "0x958F","RV630_958F","RV630",1,,,,,"ATI Mobility FireGL Graphics Processor"
-"0x9542","RV710_9542","RV710",,,,,,"ATI Radeon RV710"
 "0x95C0","RV620_95C0","RV620",,,,,,"ATI Radeon HD 3470"
 "0x95C2","RV620_95C2","RV620",1,,,,,"ATI Mobility Radeon HD 3430"
 "0x95C4","RV620_95C4","RV620",1,,,,,"ATI Mobility Radeon HD 3400 Series"
@@ -474,6 +478,7 @@
 "0x68BE","JUNIPER_68BE","JUNIPER",,,,,,"ATI Radeon HD 5700 Series"
 "0x68C0","REDWOOD_68C0","REDWOOD",1,,,,,"ATI Mobility Radeon HD 5000 Series"
 "0x68C1","REDWOOD_68C1","REDWOOD",1,,,,,"ATI Mobility Radeon HD 5000 Series"
+"0x68C7","REDWOOD_68C7","REDWOOD",1,,,,,"ATI Mobility Radeon HD 5570"
 "0x68C8","REDWOOD_68C8","REDWOOD",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
 "0x68C9","REDWOOD_68C9","REDWOOD",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
 "0x68D8","REDWOOD_68D8","REDWOOD",,,,,,"ATI Radeon HD 5670"
diff --git a/src/r600_exa.c b/src/r600_exa.c
index 26b59d8..b1c024a 100644
--- a/src/r600_exa.c
+++ b/src/r600_exa.c
@@ -2360,7 +2360,7 @@ R600DrawInit(ScreenPtr pScreen)
 	info->accel_state->vsync = FALSE;
 
     if (!exaDriverInit(pScreen, info->accel_state->exa)) {
-	xfree(info->accel_state->exa);
+	free(info->accel_state->exa);
 	return FALSE;
     }
 
diff --git a/src/r600_shader.c b/src/r600_shader.c
index e78aa32..7e25f6d 100644
--- a/src/r600_shader.c
+++ b/src/r600_shader.c
@@ -1403,7 +1403,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                             WHOLE_QUAD_MODE(0),
                             BARRIER(0));
     /* 2 */
-    shader[i++] = CF_DWORD0(0);
+    shader[i++] = CF_DWORD0(ADDR(0));
     shader[i++] = CF_DWORD1(POP_COUNT(0),
                             CF_CONST(0),
                             COND(SQ_CF_COND_ACTIVE),
diff --git a/src/r600_state.h b/src/r600_state.h
index e9bfa10..43dc929 100644
--- a/src/r600_state.h
+++ b/src/r600_state.h
@@ -235,13 +235,13 @@ do {                                                                    \
 do {                                                                    \
     if ((reg) >= SET_CONFIG_REG_offset && (reg) < SET_CONFIG_REG_end) {	\
 	PACK3((ib), IT_SET_CONFIG_REG, (num) + 1);			\
-	E32(ib, ((reg) - SET_CONFIG_REG_offset) >> 2);                  \
+	E32((ib), ((reg) - SET_CONFIG_REG_offset) >> 2);		\
     } else if ((reg) >= SET_CONTEXT_REG_offset && (reg) < SET_CONTEXT_REG_end) { \
 	PACK3((ib), IT_SET_CONTEXT_REG, (num) + 1);			\
-	E32(ib, ((reg) - SET_CONTEXT_REG_offset) >> 2);			\
+	E32((ib), ((reg) - SET_CONTEXT_REG_offset) >> 2);		\
     } else if ((reg) >= SET_ALU_CONST_offset && (reg) < SET_ALU_CONST_end) { \
 	PACK3((ib), IT_SET_ALU_CONST, (num) + 1);			\
-	E32(ib, ((reg) - SET_ALU_CONST_offset) >> 2);			\
+	E32((ib), ((reg) - SET_ALU_CONST_offset) >> 2);			\
     } else if ((reg) >= SET_RESOURCE_offset && (reg) < SET_RESOURCE_end) { \
 	PACK3((ib), IT_SET_RESOURCE, num + 1);				\
 	E32((ib), ((reg) - SET_RESOURCE_offset) >> 2);			\
diff --git a/src/r6xx_accel.c b/src/r6xx_accel.c
index a835d71..0edfe8b 100644
--- a/src/r6xx_accel.c
+++ b/src/r6xx_accel.c
@@ -661,11 +661,12 @@ set_screen_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
 
-    BEGIN_BATCH(6);
-    EREG(ib, PA_SC_SCREEN_SCISSOR_TL,              ((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
-						    (y1 << PA_SC_SCREEN_SCISSOR_TL__TL_Y_shift)));
-    EREG(ib, PA_SC_SCREEN_SCISSOR_BR,              ((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
-						    (y2 << PA_SC_SCREEN_SCISSOR_BR__BR_Y_shift)));
+    BEGIN_BATCH(4);
+    PACK0(ib, PA_SC_SCREEN_SCISSOR_TL, 2);
+    E32(ib, ((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
+	     (y1 << PA_SC_SCREEN_SCISSOR_TL__TL_Y_shift)));
+    E32(ib, ((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
+	     (y2 << PA_SC_SCREEN_SCISSOR_BR__BR_Y_shift)));
     END_BATCH();
 }
 
@@ -674,14 +675,13 @@ set_vport_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
 
-    BEGIN_BATCH(6);
-    EREG(ib, PA_SC_VPORT_SCISSOR_0_TL +
-	 id * PA_SC_VPORT_SCISSOR_0_TL_offset, ((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
-						(y1 << PA_SC_VPORT_SCISSOR_0_TL__TL_Y_shift) |
-						WINDOW_OFFSET_DISABLE_bit));
-    EREG(ib, PA_SC_VPORT_SCISSOR_0_BR +
-	 id * PA_SC_VPORT_SCISSOR_0_BR_offset, ((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
-						(y2 << PA_SC_VPORT_SCISSOR_0_BR__BR_Y_shift)));
+    BEGIN_BATCH(4);
+    PACK0(ib, PA_SC_VPORT_SCISSOR_0_TL + id * PA_SC_VPORT_SCISSOR_0_TL_offset, 2);
+    E32(ib, ((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
+	     (y1 << PA_SC_VPORT_SCISSOR_0_TL__TL_Y_shift) |
+	     WINDOW_OFFSET_DISABLE_bit));
+    E32(ib, ((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
+	     (y2 << PA_SC_VPORT_SCISSOR_0_BR__BR_Y_shift)));
     END_BATCH();
 }
 
@@ -690,12 +690,13 @@ set_generic_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
 
-    BEGIN_BATCH(6);
-    EREG(ib, PA_SC_GENERIC_SCISSOR_TL,            ((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
-						   (y1 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift) |
-						   WINDOW_OFFSET_DISABLE_bit));
-    EREG(ib, PA_SC_GENERIC_SCISSOR_BR,            ((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
-						   (y2 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift)));
+    BEGIN_BATCH(4);
+    PACK0(ib, PA_SC_GENERIC_SCISSOR_TL, 2);
+    E32(ib, ((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
+	     (y1 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift) |
+	     WINDOW_OFFSET_DISABLE_bit));
+    E32(ib, ((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
+	     (y2 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift)));
     END_BATCH();
 }
 
@@ -704,12 +705,13 @@ set_window_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
 
-    BEGIN_BATCH(6);
-    EREG(ib, PA_SC_WINDOW_SCISSOR_TL,             ((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
-						   (y1 << PA_SC_WINDOW_SCISSOR_TL__TL_Y_shift) |
-						   WINDOW_OFFSET_DISABLE_bit));
-    EREG(ib, PA_SC_WINDOW_SCISSOR_BR,             ((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
-						   (y2 << PA_SC_WINDOW_SCISSOR_BR__BR_Y_shift)));
+    BEGIN_BATCH(4);
+    PACK0(ib, PA_SC_WINDOW_SCISSOR_TL, 2);
+    E32(ib, ((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
+	     (y1 << PA_SC_WINDOW_SCISSOR_TL__TL_Y_shift) |
+	     WINDOW_OFFSET_DISABLE_bit));
+    E32(ib, ((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
+	      (y2 << PA_SC_WINDOW_SCISSOR_BR__BR_Y_shift)));
     END_BATCH();
 }
 
@@ -718,13 +720,12 @@ set_clip_rect(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, i
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
 
-    BEGIN_BATCH(6);
-    EREG(ib, PA_SC_CLIPRECT_0_TL +
-	 id * PA_SC_CLIPRECT_0_TL_offset,     ((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
-					       (y1 << PA_SC_CLIPRECT_0_TL__TL_Y_shift)));
-    EREG(ib, PA_SC_CLIPRECT_0_BR +
-	 id * PA_SC_CLIPRECT_0_BR_offset,     ((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
-					       (y2 << PA_SC_CLIPRECT_0_BR__BR_Y_shift)));
+    BEGIN_BATCH(4);
+    PACK0(ib, PA_SC_CLIPRECT_0_TL + id * PA_SC_CLIPRECT_0_TL_offset, 2);
+    E32(ib, ((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
+	     (y1 << PA_SC_CLIPRECT_0_TL__TL_Y_shift)));
+    E32(ib, ((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
+	     (y2 << PA_SC_CLIPRECT_0_BR__BR_Y_shift)));
     END_BATCH();
 }
 
@@ -752,35 +753,6 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
 
     start_3d(pScrn, accel_state->ib);
 
-    // ASIC specific setup, see drm
-    BEGIN_BATCH(15);
-    if (info->ChipFamily < CHIP_FAMILY_RV770) {
-	EREG(ib, TA_CNTL_AUX,                     (( 3 << GRADIENT_CREDIT_shift)		|
-						   (28 << TD_FIFO_CREDIT_shift)));
-	EREG(ib, VC_ENHANCE,                      0);
-	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
-	EREG(ib, DB_DEBUG,                        0x82000000); /* ? */
-	EREG(ib, DB_WATERMARKS,		        ((4  << DEPTH_FREE_shift)		|
-						 (16 << DEPTH_FLUSH_shift)		|
-						 (0  << FORCE_SUMMARIZE_shift)		|
-						 (4  << DEPTH_PENDING_FREE_shift)	|
-						 (16 << DEPTH_CACHELINE_FREE_shift)	|
-						 0));
-    } else {
-	EREG(ib, TA_CNTL_AUX,                      (( 2 << GRADIENT_CREDIT_shift)		|
-						    (28 << TD_FIFO_CREDIT_shift)));
-	EREG(ib, VC_ENHANCE,                       0);
-	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
-	EREG(ib, DB_DEBUG,                         0);
-	EREG(ib, DB_WATERMARKS,                    ((4  << DEPTH_FREE_shift)		|
-						    (16 << DEPTH_FLUSH_shift)		|
-						    (0  << FORCE_SUMMARIZE_shift)		|
-						    (4  << DEPTH_PENDING_FREE_shift)	|
-						    (4  << DEPTH_CACHELINE_FREE_shift)	|
-						    0));
-    }
-    END_BATCH();
-
     // SQ
     sq_conf.ps_prio = 0;
     sq_conf.vs_prio = 1;
@@ -905,171 +877,145 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
 
     sq_setup(pScrn, ib, &sq_conf);
 
-    BEGIN_BATCH(59);
-    EREG(ib, SQ_VTX_BASE_VTX_LOC,                 0);
-    EREG(ib, SQ_VTX_START_INST_LOC,               0);
+    BEGIN_BATCH(83);
+    if (info->ChipFamily < CHIP_FAMILY_RV770) {
+	EREG(ib, TA_CNTL_AUX, (( 3 << GRADIENT_CREDIT_shift) |
+				 - (28 << TD_FIFO_CREDIT_shift)));
+	EREG(ib, VC_ENHANCE, 0);
+	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
+	EREG(ib, DB_DEBUG, 0x82000000); /* ? */
+	EREG(ib, DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
+				 (16 << DEPTH_FLUSH_shift) |
+				 (0 << FORCE_SUMMARIZE_shift) |
+				 (4 << DEPTH_PENDING_FREE_shift) |
+				 (16 << DEPTH_CACHELINE_FREE_shift) |
+				 0));
+    } else {
+	EREG(ib, TA_CNTL_AUX, (( 2 << GRADIENT_CREDIT_shift) |
+			       - (28 << TD_FIFO_CREDIT_shift)));
+	EREG(ib, VC_ENHANCE, 0);
+	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
+	EREG(ib, DB_DEBUG, 0);
+	EREG(ib, DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
+				 (16 << DEPTH_FLUSH_shift) |
+				 (0 << FORCE_SUMMARIZE_shift) |
+				 (4 << DEPTH_PENDING_FREE_shift) |
+				 (4 << DEPTH_CACHELINE_FREE_shift) |
+				 0));
+    }
+
+    PACK0(ib, SQ_VTX_BASE_VTX_LOC, 2);
+    E32(ib, 0);
+    E32(ib, 0);
 
     PACK0(ib, SQ_ESGS_RING_ITEMSIZE, 9);
-    E32(ib, 0);							// SQ_ESGS_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_GSVS_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_ESTMP_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_GSTMP_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_VSTMP_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_PSTMP_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_FBUF_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_REDUC_RING_ITEMSIZE
-    E32(ib, 0);							// SQ_GS_VERT_ITEMSIZE
+    E32(ib, 0); // SQ_ESGS_RING_ITEMSIZE
+    E32(ib, 0); // SQ_GSVS_RING_ITEMSIZE
+    E32(ib, 0); // SQ_ESTMP_RING_ITEMSIZE
+    E32(ib, 0); // SQ_GSTMP_RING_ITEMSIZE
+    E32(ib, 0); // SQ_VSTMP_RING_ITEMSIZE
+    E32(ib, 0); // SQ_PSTMP_RING_ITEMSIZE
+    E32(ib, 0); // SQ_FBUF_RING_ITEMSIZE
+    E32(ib, 0); // SQ_REDUC_RING_ITEMSIZE
+    E32(ib, 0); // SQ_GS_VERT_ITEMSIZE
 
     // DB
     EREG(ib, DB_DEPTH_INFO,                       0);
-    EREG(ib, DB_STENCIL_CLEAR,                    0);
-    EREG(ib, DB_DEPTH_CLEAR,                      0);
-    EREG(ib, DB_STENCILREFMASK,                   0);
-    EREG(ib, DB_STENCILREFMASK_BF,                0);
     EREG(ib, DB_DEPTH_CONTROL,                    0);
-    EREG(ib, DB_RENDER_CONTROL,                   STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
+    PACK0(ib, DB_RENDER_CONTROL, 2);
+    E32(ib, STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
     if (info->ChipFamily < CHIP_FAMILY_RV770)
-	EREG(ib, DB_RENDER_OVERRIDE,              FORCE_SHADER_Z_ORDER_bit);
+	E32(ib, FORCE_SHADER_Z_ORDER_bit);
     else
-	EREG(ib, DB_RENDER_OVERRIDE,              0);
+	E32(ib, 0);
     EREG(ib, DB_ALPHA_TO_MASK,                    ((2 << ALPHA_TO_MASK_OFFSET0_shift)	|
 						   (2 << ALPHA_TO_MASK_OFFSET1_shift)	|
 						   (2 << ALPHA_TO_MASK_OFFSET2_shift)	|
 						   (2 << ALPHA_TO_MASK_OFFSET3_shift)));
-
-
     EREG(ib, DB_SHADER_CONTROL, ((1 << Z_ORDER_shift) | /* EARLY_Z_THEN_LATE_Z */
 				 DUAL_EXPORT_ENABLE_bit)); /* Only useful if no depth export */
 
+    PACK0(ib, DB_STENCIL_CLEAR, 2);
+    E32(ib, 0); // DB_STENCIL_CLEAR
+    E32(ib, 0); // DB_DEPTH_CLEAR
 
-    // SX
-    EREG(ib, SX_ALPHA_TEST_CONTROL,               0);
-    EREG(ib, SX_ALPHA_REF,                        0);
-
-    // CB
-    PACK0(ib, CB_BLEND_RED, 4);
-    E32(ib, 0x00000000);
-    E32(ib, 0x00000000);
-    E32(ib, 0x00000000);
-    E32(ib, 0x00000000);
-    END_BATCH();
+    PACK0(ib, DB_STENCILREFMASK, 3);
+    E32(ib, 0); // DB_STENCILREFMASK
+    E32(ib, 0); // DB_STENCILREFMASK_BF
+    E32(ib, 0); // SX_ALPHA_REF
 
-    if (info->ChipFamily < CHIP_FAMILY_RV770) {
-	BEGIN_BATCH(11);
-	PACK0(ib, CB_FOG_RED, 3);
-	E32(ib, 0x00000000);
-	E32(ib, 0x00000000);
-	E32(ib, 0x00000000);
-	PACK0(ib, CB_CLEAR_RED, 4);
-	EFLOAT(ib, 1.0);						/* WTF? */
-	EFLOAT(ib, 0.0);
-	EFLOAT(ib, 1.0);
-	EFLOAT(ib, 1.0);
-	END_BATCH();
-    }
-
-    BEGIN_BATCH(18);
     PACK0(ib, CB_CLRCMP_CONTROL, 4);
     E32(ib, 1 << CLRCMP_FCN_SEL_shift);				// CB_CLRCMP_CONTROL: use CLRCMP_FCN_SRC
     E32(ib, 0);							// CB_CLRCMP_SRC
     E32(ib, 0);							// CB_CLRCMP_DST
     E32(ib, 0);							// CB_CLRCMP_MSK
 
-    EREG(ib, CB_SHADER_MASK,                      (0xf << OUTPUT0_ENABLE_shift));
+    EREG(ib, CB_SHADER_MASK,                      OUTPUT0_ENABLE_mask);
     EREG(ib, R7xx_CB_SHADER_CONTROL,              (RT0_ENABLE_bit));
 
+    PACK0(ib, SX_ALPHA_TEST_CONTROL, 5);
+    E32(ib, 0); // SX_ALPHA_TEST_CONTROL
+    E32(ib, 0x00000000); // CB_BLEND_RED
+    E32(ib, 0x00000000); // CB_BLEND_GREEN
+    E32(ib, 0x00000000); // CB_BLEND_BLUE
+    E32(ib, 0x00000000); // CB_BLEND_ALPHA
 
-    // SC
     EREG(ib, PA_SC_WINDOW_OFFSET,                 ((0 << WINDOW_X_OFFSET_shift) |
 						   (0 << WINDOW_Y_OFFSET_shift)));
 
+    if (info->ChipFamily < CHIP_FAMILY_RV770)
+	EREG(ib, R7xx_PA_SC_EDGERULE,             0x00000000);
+    else
+	EREG(ib, R7xx_PA_SC_EDGERULE,             0xAAAAAAAA);
+
     EREG(ib, PA_SC_CLIPRECT_RULE,                 CLIP_RULE_mask);
+
     END_BATCH();
 
     /* clip boolean is set to always visible -> doesn't matter */
     for (i = 0; i < PA_SC_CLIPRECT_0_TL_num; i++)
 	set_clip_rect (pScrn, ib, i, 0, 0, 8192, 8192);
 
-    BEGIN_BATCH(3);
-    if (info->ChipFamily < CHIP_FAMILY_RV770)
-	EREG(ib, R7xx_PA_SC_EDGERULE,             0x00000000);
-    else
-	EREG(ib, R7xx_PA_SC_EDGERULE,             0xAAAAAAAA);
-    END_BATCH();
-
-    for (i = 0; i < PA_SC_VPORT_SCISSOR_0_TL_num; i++) {
+    for (i = 0; i < PA_SC_VPORT_SCISSOR_0_TL_num; i++)
 	set_vport_scissor (pScrn, ib, i, 0, 0, 8192, 8192);
-	BEGIN_BATCH(4);
-	PACK0(ib, PA_SC_VPORT_ZMIN_0 + i * PA_SC_VPORT_ZMIN_0_offset, 2);
-	EFLOAT(ib, 0.0);
-	EFLOAT(ib, 1.0);
-	END_BATCH();
-    }
 
-    BEGIN_BATCH(15);
+    BEGIN_BATCH(42);
+    PACK0(ib, PA_SC_MPASS_PS_CNTL, 2);
+    E32(ib, 0);
     if (info->ChipFamily < CHIP_FAMILY_RV770)
-	EREG(ib, PA_SC_MODE_CNTL,                 (WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
+	E32(ib, (WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
     else
-	EREG(ib, PA_SC_MODE_CNTL,                 (FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
-						   0x00500000)); /* ? */
-
-    EREG(ib, PA_SU_SC_MODE_CNTL, (FACE_bit |
-				  (POLYMODE_PTYPE__TRIANGLES << POLYMODE_FRONT_PTYPE_shift) |
-				  (POLYMODE_PTYPE__TRIANGLES << POLYMODE_BACK_PTYPE_shift)));
-
-
-    EREG(ib, PA_SC_LINE_CNTL,                     0);
-    EREG(ib, PA_SC_AA_CONFIG,                     0);
-    EREG(ib, PA_SC_AA_MASK,                       0xFFFFFFFF);
-    END_BATCH();
-
-    //XXX: double check this
-    if (info->ChipFamily > CHIP_FAMILY_R600) {
-	BEGIN_BATCH(6);
-	EREG(ib, PA_SC_AA_SAMPLE_LOCS_MCTX,       0);
-	EREG(ib, PA_SC_AA_SAMPLE_LOCS_8S_WD1_M,   0);
-	END_BATCH();
-    }
-
-    BEGIN_BATCH(83);
-    EREG(ib, PA_SC_LINE_STIPPLE,                  0);
-    EREG(ib, PA_SC_MPASS_PS_CNTL,                 0);
-
-    // CL
-    PACK0(ib, PA_CL_VPORT_XSCALE_0, 6);
-    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_XSCALE
-    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_XOFFSET
-    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_YSCALE
-    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_YOFFSET
-    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_ZSCALE
-    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_ZOFFSET
-    EREG(ib, PA_CL_VTE_CNTL,                      0);
-    EREG(ib, PA_CL_VS_OUT_CNTL,                   0);
-    EREG(ib, PA_CL_NANINF_CNTL,                   0);
-    PACK0(ib, PA_CL_GB_VERT_CLIP_ADJ, 4);
+	E32(ib, (FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
+		 0x00500000)); /* ? */
+
+    PACK0(ib, PA_SC_LINE_CNTL, 9);
+    E32(ib, 0); // PA_SC_LINE_CNTL
+    E32(ib, 0); // PA_SC_AA_CONFIG
+    E32(ib, ((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) | PIX_CENTER_bit | // PA_SU_VTX_CNTL
+	     (5 << QUANT_MODE_shift))); /* Round to Even, fixed point 1/256 */
     EFLOAT(ib, 1.0);						// PA_CL_GB_VERT_CLIP_ADJ
     EFLOAT(ib, 1.0);						// PA_CL_GB_VERT_DISC_ADJ
     EFLOAT(ib, 1.0);						// PA_CL_GB_HORZ_CLIP_ADJ
     EFLOAT(ib, 1.0);						// PA_CL_GB_HORZ_DISC_ADJ
+    E32(ib, 0);                                                 // PA_SC_AA_SAMPLE_LOCS_MCTX
+    E32(ib, 0);                                                 // PA_SC_AA_SAMPLE_LOCS_8S_WD1_M
 
-    /* Scissor / viewport */
-    EREG(ib, PA_CL_VTE_CNTL,                      VTX_XY_FMT_bit);
-    EREG(ib, PA_CL_CLIP_CNTL,                     CLIP_DISABLE_bit);
-
-    // SU
-    EREG(ib, PA_SU_SC_MODE_CNTL,                  FACE_bit);
-    EREG(ib, PA_SU_POINT_SIZE,                    0);
-    EREG(ib, PA_SU_POINT_MINMAX,                  0);
-    EREG(ib, PA_SU_POLY_OFFSET_DB_FMT_CNTL,       0);
-    EREG(ib, PA_SU_POLY_OFFSET_BACK_SCALE,        0);
-    EREG(ib, PA_SU_POLY_OFFSET_FRONT_SCALE,       0);
-    EREG(ib, PA_SU_POLY_OFFSET_BACK_OFFSET,       0);
-    EREG(ib, PA_SU_POLY_OFFSET_FRONT_OFFSET,      0);
-
-    EREG(ib, PA_SU_LINE_CNTL,                     (8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */
-    EREG(ib, PA_SU_VTX_CNTL,                      ((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) | PIX_CENTER_bit |
-						   (5 << QUANT_MODE_shift))); /* Round to Even, fixed point 1/256 */
-    EREG(ib, PA_SU_POLY_OFFSET_CLAMP,             0);
+    EREG(ib, PA_SC_AA_MASK,                       0xFFFFFFFF);
+
+    PACK0(ib, PA_CL_CLIP_CNTL, 5);
+    E32(ib, CLIP_DISABLE_bit); // PA_CL_CLIP_CNTL
+    E32(ib, FACE_bit);         // PA_SU_SC_MODE_CNTL
+    E32(ib, VTX_XY_FMT_bit);   // PA_CL_VTE_CNTL
+    E32(ib, 0);                // PA_CL_VS_OUT_CNTL
+    E32(ib, 0);                // PA_CL_NANINF_CNTL
+
+    PACK0(ib, PA_SU_POLY_OFFSET_DB_FMT_CNTL, 6);
+    E32(ib, 0); // PA_SU_POLY_OFFSET_DB_FMT_CNTL
+    E32(ib, 0); // PA_SU_POLY_OFFSET_CLAMP
+    E32(ib, 0); // PA_SU_POLY_OFFSET_FRONT_SCALE
+    E32(ib, 0); // PA_SU_POLY_OFFSET_FRONT_OFFSET
+    E32(ib, 0); // PA_SU_POLY_OFFSET_BACK_SCALE
+    E32(ib, 0); // PA_SU_POLY_OFFSET_BACK_OFFSET
 
     // SPI
     if (info->ChipFamily < CHIP_FAMILY_RV770)
@@ -1077,10 +1023,12 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
     else
 	EREG(ib, R7xx_SPI_THREAD_GROUPING,        (1 << PS_GROUPING_shift));
 
-    EREG(ib, SPI_INPUT_Z,                         0);
-    EREG(ib, SPI_FOG_CNTL,                        0);
-    EREG(ib, SPI_FOG_FUNC_SCALE,                  0);
-    EREG(ib, SPI_FOG_FUNC_BIAS,                   0);
+    PACK0(ib, SPI_INPUT_Z, 4);
+    E32(ib, 0); // SPI_INPUT_Z
+    E32(ib, 0); // SPI_FOG_CNTL
+    E32(ib, 0); // SPI_FOG_FUNC_SCALE
+    E32(ib, 0); // SPI_FOG_FUNC_BIAS
+
     END_BATCH();
 
     // clear FS
@@ -1088,31 +1036,44 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
     fs_setup(pScrn, ib, &fs_conf, RADEON_GEM_DOMAIN_VRAM);
 
     // VGT
-    BEGIN_BATCH(75);
-    EREG(ib, VGT_MAX_VTX_INDX,                    2048); /* XXX set to a reasonably large number of indices */
-    EREG(ib, VGT_MIN_VTX_INDX,                    0);
-    EREG(ib, VGT_INDX_OFFSET,                     0);
-    EREG(ib, VGT_INSTANCE_STEP_RATE_0,            0);
-    EREG(ib, VGT_INSTANCE_STEP_RATE_1,            0);
-    EREG(ib, VGT_MULTI_PRIM_IB_RESET_INDX,        0);
-    EREG(ib, VGT_OUTPUT_PATH_CNTL,                0);
-    EREG(ib, VGT_GS_MODE,                         0);
-    EREG(ib, VGT_HOS_CNTL,                        0);
-    EREG(ib, VGT_HOS_MAX_TESS_LEVEL,              0);
-    EREG(ib, VGT_HOS_MIN_TESS_LEVEL,              0);
-    EREG(ib, VGT_HOS_REUSE_DEPTH,                 0);
-    EREG(ib, VGT_GROUP_PRIM_TYPE,                 0);
-    EREG(ib, VGT_GROUP_FIRST_DECR,                0);
-    EREG(ib, VGT_GROUP_DECR,                      0);
-    EREG(ib, VGT_GROUP_VECT_0_CNTL,               0);
-    EREG(ib, VGT_GROUP_VECT_1_CNTL,               0);
-    EREG(ib, VGT_GROUP_VECT_0_FMT_CNTL,           0);
-    EREG(ib, VGT_GROUP_VECT_1_FMT_CNTL,           0);
+    BEGIN_BATCH(43);
+    PACK0(ib, VGT_MAX_VTX_INDX, 4);
+    E32(ib, 2048); /* XXX set to a reasonably large number of indices */ // VGT_MAX_VTX_INDX
+    E32(ib, 0); // VGT_MIN_VTX_INDX
+    E32(ib, 0); // VGT_INDX_OFFSET
+    E32(ib, 0); // VGT_MULTI_PRIM_IB_RESET_INDX
+
     EREG(ib, VGT_PRIMITIVEID_EN,                  0);
     EREG(ib, VGT_MULTI_PRIM_IB_RESET_EN,          0);
-    EREG(ib, VGT_STRMOUT_EN,                      0);
-    EREG(ib, VGT_REUSE_OFF,                       0);
-    EREG(ib, VGT_VTX_CNT_EN,                      0);
+
+    PACK0(ib, VGT_INSTANCE_STEP_RATE_0, 2);
+    E32(ib, 0); // VGT_INSTANCE_STEP_RATE_0
+    E32(ib, 0); // VGT_INSTANCE_STEP_RATE_1
+
+    PACK0(ib, PA_SU_POINT_SIZE, 17);
+    E32(ib, 0); // PA_SU_POINT_SIZE
+    E32(ib, 0); // PA_SU_POINT_MINMAX
+    E32(ib, (8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */ // PA_SU_LINE_CNTL
+    E32(ib, 0); // PA_SC_LINE_STIPPLE
+    E32(ib, 0); // VGT_OUTPUT_PATH_CNTL
+    E32(ib, 0); // VGT_HOS_CNTL
+    E32(ib, 0); // VGT_HOS_MAX_TESS_LEVEL
+    E32(ib, 0); // VGT_HOS_MIN_TESS_LEVEL
+    E32(ib, 0); // VGT_HOS_REUSE_DEPTH
+    E32(ib, 0); // VGT_GROUP_PRIM_TYPE
+    E32(ib, 0); // VGT_GROUP_FIRST_DECR
+    E32(ib, 0); // VGT_GROUP_DECR
+    E32(ib, 0); // VGT_GROUP_VECT_0_CNTL
+    E32(ib, 0); // VGT_GROUP_VECT_1_CNTL
+    E32(ib, 0); // VGT_GROUP_VECT_0_FMT_CNTL
+    E32(ib, 0); // VGT_GROUP_VECT_1_FMT_CNTL
+    E32(ib, 0); // VGT_GS_MODE
+
+    PACK0(ib, VGT_STRMOUT_EN, 3);
+    E32(ib, 0); // VGT_STRMOUT_EN
+    E32(ib, 0); // VGT_REUSE_OFF
+    E32(ib, 0); // VGT_VTX_CNT_EN
+
     EREG(ib, VGT_STRMOUT_BUFFER_EN,               0);
     END_BATCH();
 }
@@ -1322,6 +1283,8 @@ void r600_vb_no_space(ScrnInfoPtr pScrn, int vert_size)
     }
 #endif 
 
-    r600_finish_op(pScrn, vert_size);
-    r600_cp_start(pScrn);
+    if (accel_state->vb_start_op != -1) {
+	r600_finish_op(pScrn, vert_size);
+	r600_cp_start(pScrn);
+    }
 }
diff --git a/src/radeon.h b/src/radeon.h
index 88f1516..56bc076 100644
--- a/src/radeon.h
+++ b/src/radeon.h
@@ -543,13 +543,8 @@ typedef struct {
 } RADEONConfigPrivRec, *RADEONConfigPrivPtr;
 
 typedef struct {
-#ifdef PER_CONTEXT_SAREA
-    drm_context_t ctx_id;
-    drm_handle_t sarea_handle;
-#else
     /* Nothing here yet */
     int dummy;
-#endif
 } RADEONDRIContextRec, *RADEONDRIContextPtr;
 
 struct radeon_dri {
@@ -646,10 +641,6 @@ struct radeon_dri {
 
     int               irq;
 
-#ifdef PER_CONTEXT_SAREA
-    int               perctx_sarea_size;
-#endif
-
 #ifdef USE_XAA
     uint32_t          frontPitchOffset;
     uint32_t          backPitchOffset;
@@ -971,7 +962,6 @@ typedef struct {
     unsigned int xv_max_height;
 
     /* general */
-    Bool              showCache;
     OptionInfoPtr     Options;
 
     DisplayModePtr currentMode, savedCurrentMode;
@@ -1042,7 +1032,7 @@ typedef struct {
     struct radeon_cs_manager *csm;
     struct radeon_cs *cs;
 
-    struct radeon_bo *cursor_bo[2];
+    struct radeon_bo *cursor_bo[6];
     uint64_t vram_size;
     uint64_t gart_size;
     drmmode_rec drmmode;
@@ -1138,6 +1128,7 @@ extern Bool RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen);
 #  endif
 uint32_t radeonGetPixmapOffset(PixmapPtr pPix);
 #endif
+extern int radeon_cs_space_remaining(ScrnInfoPtr pScrn);
 
 #ifdef USE_XAA
 /* radeon_accelfuncs.c */
@@ -1176,7 +1167,7 @@ extern void radeon_crtc_load_lut(xf86CrtcPtr crtc);
 extern void radeon_crtc_modeset_ioctl(xf86CrtcPtr crtc, Bool post);
 extern Bool RADEONAllocateControllers(ScrnInfoPtr pScrn, int mask);
 extern void RADEONBlank(ScrnInfoPtr pScrn);
-extern void RADEONComputePLL(ScrnInfoPtr pScrn,
+extern void RADEONComputePLL(xf86CrtcPtr crtc,
 			     RADEONPLLPtr pll, unsigned long freq,
 			     uint32_t *chosen_dot_clock_freq,
 			     uint32_t *chosen_feedback_div,
diff --git a/src/radeon_accel.c b/src/radeon_accel.c
index 0250d91..281bc6d 100644
--- a/src/radeon_accel.c
+++ b/src/radeon_accel.c
@@ -328,10 +328,6 @@ void RADEONEngineReset(ScrnInfoPtr pScrn)
 	INREG(RADEON_RBBM_SOFT_RESET);
     }
 
-    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl | RADEON_HDP_SOFT_RESET);
-    INREG(RADEON_HOST_PATH_CNTL);
-    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl);
-
     if (!IS_R300_VARIANT && !IS_AVIVO_VARIANT)
 	OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
 
@@ -499,9 +495,11 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 	    }
 	}
 
-	/* RV410 SE cards only have 1 quadpipe */
+	/* SE cards only have 1 quadpipe */
 	if ((info->Chipset == PCI_CHIP_RV410_5E4C) ||
-	    (info->Chipset == PCI_CHIP_RV410_5E4F))
+	    (info->Chipset == PCI_CHIP_RV410_5E4F) ||
+	    (info->Chipset == PCI_CHIP_R300_AD) ||
+	    (info->Chipset == PCI_CHIP_R350_AH))
 	    info->accel_state->num_gb_pipes = 1;
 
 	if (IS_R300_3D || IS_R500_3D)
@@ -573,6 +571,18 @@ uint32_t radeonGetPixmapOffset(PixmapPtr pPix)
     return offset;
 }
 
+int radeon_cs_space_remaining(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+
+#ifdef XF86DRM_MODE
+    if (info->cs)
+	return (info->cs->ndw - info->cs->cdw);
+    else
+#endif
+        return (info->cp->indirectBuffer->total - info->cp->indirectBuffer->used) / (int)sizeof(uint32_t);
+}
+
 #define ACCEL_MMIO
 #define ACCEL_PREAMBLE()        unsigned char *RADEONMMIO = info->MMIO
 #define BEGIN_ACCEL(n)          RADEONWaitForFifo(pScrn, (n))
diff --git a/src/radeon_accelfuncs.c b/src/radeon_accelfuncs.c
index 36f25e7..d0bead3 100644
--- a/src/radeon_accelfuncs.c
+++ b/src/radeon_accelfuncs.c
@@ -1206,7 +1206,7 @@ FUNC_NAME(RADEONAccelInit)(ScreenPtr pScreen, XAAInfoRecPtr a)
     a->ScanlineColorExpandBuffers       = info->accel_state->scratch_buffer;
     if (!info->accel_state->scratch_save)
 	info->accel_state->scratch_save
-	    = xalloc(((pScrn->virtualX+31)/32*4)
+	    = malloc(((pScrn->virtualX+31)/32*4)
 		     + (pScrn->virtualX * info->CurrentLayout.pixel_bytes));
     info->accel_state->scratch_buffer[0]             = info->accel_state->scratch_save;
     a->SetupForScanlineCPUToScreenColorExpandFill
diff --git a/src/radeon_atombios.c b/src/radeon_atombios.c
index 42b35d0..996e6ee 100644
--- a/src/radeon_atombios.c
+++ b/src/radeon_atombios.c
@@ -490,7 +490,7 @@ rhdAtomAllocateFbScratch(atomBiosHandlePtr handle,
 	xf86DrvMsg(handle->scrnIndex, X_INFO,
 		   "Cannot get VRAM scratch space. "
 		   "Allocating in main memory instead\n");
-	handle->scratchBase = xcalloc(fb_size,1);
+	handle->scratchBase = calloc(fb_size,1);
 	return ATOM_SUCCESS;
     }
     return ATOM_FAILED;
@@ -651,14 +651,14 @@ rhdAtomInit(atomBiosHandlePtr unused1, AtomBiosRequestID unused2,
     BIOSImageSize = RADEON_VBIOS_SIZE;
 #endif
 
-    if (!(atomDataPtr = xcalloc(1, sizeof(atomDataTables)))) {
+    if (!(atomDataPtr = calloc(1, sizeof(atomDataTables)))) {
 	xf86DrvMsg(scrnIndex,X_ERROR,"Cannot allocate memory for "
 		   "ATOM BIOS data tabes\n");
 	goto error;
     }
     if (!rhdAtomGetDataTable(scrnIndex, info->VBIOS, atomDataPtr, &cmd_offset, BIOSImageSize))
 	goto error1;
-    if (!(handle = xcalloc(1, sizeof(atomBiosHandleRec)))) {
+    if (!(handle = calloc(1, sizeof(atomBiosHandleRec)))) {
 	xf86DrvMsg(scrnIndex,X_ERROR,"Cannot allocate memory\n");
 	goto error1;
     }
@@ -677,7 +677,7 @@ rhdAtomInit(atomBiosHandlePtr unused1, AtomBiosRequestID unused2,
     return ATOM_SUCCESS;
 
  error1:
-    xfree(atomDataPtr);
+    free(atomDataPtr);
  error:
     return ATOM_FAILED;
 }
@@ -688,10 +688,10 @@ rhdAtomTearDown(atomBiosHandlePtr handle,
 {
     //RHDFUNC(handle);
 
-    xfree(handle->BIOSBase);
-    xfree(handle->atomDataPtr);
-    if (handle->scratchBase) xfree(handle->scratchBase);
-    xfree(handle);
+    free(handle->BIOSBase);
+    free(handle->atomDataPtr);
+    if (handle->scratchBase) free(handle->scratchBase);
+    free(handle);
     return ATOM_SUCCESS;
 }
 
@@ -777,7 +777,7 @@ rhdAtomDTDTimings(atomBiosHandlePtr handle, ATOM_DTD_FORMAT *dtd)
     if (!dtd->usHActive || !dtd->usVActive)
 	return NULL;
 
-    if (!(mode = (DisplayModePtr)xcalloc(1,sizeof(DisplayModeRec))))
+    if (!(mode = (DisplayModePtr)calloc(1,sizeof(DisplayModeRec))))
 	return NULL;
 
     mode->CrtcHDisplay = mode->HDisplay = le16_to_cpu(dtd->usHActive);
@@ -861,7 +861,7 @@ rhdAtomLvdsDDC(atomBiosHandlePtr handle, uint32_t offset, unsigned char *record)
 		    - sizeof(UCHAR);
 		if (offset > handle->BIOSImageSize) break;
 		/* dup string as we free it later */
-		if (!(EDIDBlock = (unsigned char *)xalloc(
+		if (!(EDIDBlock = (unsigned char *)malloc(
 			  ((ATOM_FAKE_EDID_PATCH_RECORD*)record)->ucFakeEDIDLength)))
 		    return NULL;
 		memcpy(EDIDBlock,&((ATOM_FAKE_EDID_PATCH_RECORD*)record)->ucFakeEDIDString,
@@ -871,7 +871,7 @@ rhdAtomLvdsDDC(atomBiosHandlePtr handle, uint32_t offset, unsigned char *record)
 		{
 		    xf86MonPtr mon = xf86InterpretEDID(handle->scrnIndex,EDIDBlock);
 		    xf86PrintEDID(mon);
-		    xfree(mon);
+		    free(mon);
 		}
 		return EDIDBlock;
 
@@ -1802,9 +1802,9 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 		    if (device_support & ATOM_DEVICE_LCD1_SUPPORT) {
 			if (info->encoders[device_index]->dev_priv == NULL) {
 			    info->encoders[device_index]->dev_priv =
-				(radeon_lvds_ptr)xcalloc(1,sizeof(radeon_lvds_rec));
+				(radeon_lvds_ptr)calloc(1,sizeof(radeon_lvds_rec));
 			    if (info->encoders[device_index]->dev_priv == NULL) {
-				ErrorF("xalloc failed\n");
+				ErrorF("calloc failed\n");
 				return FALSE;
 			    } else
 				RADEONGetATOMLVDSInfo(pScrn, (radeon_lvds_ptr)info->encoders[device_index]->dev_priv);
@@ -1816,7 +1816,7 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 	    }
 	}
 
-	info->encoders[device_index] = (radeon_encoder_ptr)xcalloc(1,sizeof(radeon_encoder_rec));
+	info->encoders[device_index] = (radeon_encoder_ptr)calloc(1,sizeof(radeon_encoder_rec));
 	if (info->encoders[device_index] != NULL) {
 	    info->encoders[device_index]->encoder_id = encoder_id;
 	    info->encoders[device_index]->devices = 0;
@@ -1824,9 +1824,9 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 	    // add dev_priv stuff
 	    switch (encoder_id) {
 	    case ENCODER_OBJECT_ID_INTERNAL_LVDS:
-		    info->encoders[device_index]->dev_priv = (radeon_lvds_ptr)xcalloc(1,sizeof(radeon_lvds_rec));
+		    info->encoders[device_index]->dev_priv = (radeon_lvds_ptr)calloc(1,sizeof(radeon_lvds_rec));
 		    if (info->encoders[device_index]->dev_priv == NULL) {
-			ErrorF("xalloc failed\n");
+			ErrorF("calloc failed\n");
 			return FALSE;
 		    } else {
 			if (info->IsAtomBios)
@@ -1837,9 +1837,9 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_DAC2:
 		if (!IS_AVIVO_VARIANT) {
-		    info->encoders[device_index]->dev_priv = (radeon_tvdac_ptr)xcalloc(1,sizeof(radeon_tvdac_rec));
+		    info->encoders[device_index]->dev_priv = (radeon_tvdac_ptr)calloc(1,sizeof(radeon_tvdac_rec));
 		    if (info->encoders[device_index]->dev_priv == NULL) {
-			ErrorF("xalloc failed\n");
+			ErrorF("calloc failed\n");
 			return FALSE;
 		    } else
 			RADEONGetTVDacAdjInfo(pScrn, (radeon_tvdac_ptr)info->encoders[device_index]->dev_priv);
@@ -1847,9 +1847,9 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
 		if (!IS_AVIVO_VARIANT) {
-		    info->encoders[device_index]->dev_priv = (radeon_tmds_ptr)xcalloc(1,sizeof(radeon_tmds_rec));
+		    info->encoders[device_index]->dev_priv = (radeon_tmds_ptr)calloc(1,sizeof(radeon_tmds_rec));
 		    if (info->encoders[device_index]->dev_priv == NULL) {
-			ErrorF("xalloc failed\n");
+			ErrorF("calloc failed\n");
 			return FALSE;
 		    } else
 			RADEONGetTMDSInfo(pScrn, (radeon_tmds_ptr)info->encoders[device_index]->dev_priv);
@@ -1857,9 +1857,9 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_DVO1:
 		if (!IS_AVIVO_VARIANT) {
-		    info->encoders[device_index]->dev_priv = (radeon_dvo_ptr)xcalloc(1,sizeof(radeon_dvo_rec));
+		    info->encoders[device_index]->dev_priv = (radeon_dvo_ptr)calloc(1,sizeof(radeon_dvo_rec));
 		    if (info->encoders[device_index]->dev_priv == NULL) {
-			ErrorF("xalloc failed\n");
+			ErrorF("calloc failed\n");
 			return FALSE;
 		    } else
 			RADEONGetExtTMDSInfo(pScrn, (radeon_dvo_ptr)info->encoders[device_index]->dev_priv);
@@ -1871,9 +1871,9 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 	    case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
 	    case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
 		if (device_support & ATOM_DEVICE_LCD1_SUPPORT) {
-		    info->encoders[device_index]->dev_priv = (radeon_lvds_ptr)xcalloc(1,sizeof(radeon_lvds_rec));
+		    info->encoders[device_index]->dev_priv = (radeon_lvds_ptr)calloc(1,sizeof(radeon_lvds_rec));
 		    if (info->encoders[device_index]->dev_priv == NULL) {
-			ErrorF("xalloc failed\n");
+			ErrorF("calloc failed\n");
 			return FALSE;
 		    } else
 			RADEONGetATOMLVDSInfo(pScrn, (radeon_lvds_ptr)info->encoders[device_index]->dev_priv);
@@ -1882,7 +1882,7 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 	    }
 	    return TRUE;
 	} else {
-	    ErrorF("xalloc failed\n");
+	    ErrorF("calloc failed\n");
 	    return FALSE;
 	}
     }
@@ -2289,9 +2289,12 @@ RADEONGetATOMClockInfo(ScrnInfoPtr pScrn)
 	break;
     }
     pll->reference_div = 0;
-    if (pll->pll_out_min == 0)
-	pll->pll_out_min = 64800;
-
+    if (pll->pll_out_min == 0) {
+	if (IS_AVIVO_VARIANT)
+	    pll->pll_out_min = 64800;
+	else
+	    pll->pll_out_min = 20000;
+    }
 
     /* limiting the range is a good thing in most cases
      * as it limits the number of matching pll combinations,
diff --git a/src/radeon_bios.c b/src/radeon_bios.c
index d066edc..5810bdb 100644
--- a/src/radeon_bios.c
+++ b/src/radeon_bios.c
@@ -361,9 +361,9 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
 
 #ifdef XSERVER_LIBPCIACCESS
     int size = info->PciInfo->rom_size > RADEON_VBIOS_SIZE ? info->PciInfo->rom_size : RADEON_VBIOS_SIZE;
-    info->VBIOS = xalloc(size);
+    info->VBIOS = malloc(size);
 #else
-    info->VBIOS = xalloc(RADEON_VBIOS_SIZE);
+    info->VBIOS = malloc(RADEON_VBIOS_SIZE);
 #endif
     if (!info->VBIOS) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
@@ -381,7 +381,7 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
     if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		   "Unrecognized BIOS signature, BIOS data will not be used\n");
-	xfree (info->VBIOS);
+	free (info->VBIOS);
 	info->VBIOS = NULL;
 	return FALSE;
     }
@@ -396,7 +396,7 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
     else if (info->VBIOS[dptr + 0x14] != 0x0) {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		   "Not an x86 BIOS ROM image, BIOS data will not be used\n");
-	xfree (info->VBIOS);
+	free (info->VBIOS);
 	info->VBIOS = NULL;
 	return FALSE;
     }
@@ -406,7 +406,7 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
     if(!info->ROMHeaderStart) {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		   "Invalid ROM pointer, BIOS data will not be used\n");
-	xfree (info->VBIOS);
+	free (info->VBIOS);
 	info->VBIOS = NULL;
 	return FALSE;
     }
@@ -548,15 +548,6 @@ static void RADEONApplyLegacyQuirks(ScrnInfoPtr pScrn, int index)
 	}
     }
 
-    /* Some RV100 cards with 2 VGA ports show up with DVI+VGA */
-    if (info->Chipset == PCI_CHIP_RV100_QY &&
-	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1002 &&
-	PCI_SUB_DEVICE_ID(info->PciInfo) == 0x013a) {
-	if (info->BiosConnector[index].ConnectorType == CONNECTOR_DVI_I) {
-	    info->BiosConnector[index].ConnectorType = CONNECTOR_VGA;
-	}
-    }
-
     /* X300 card with extra non-existent DVI port */
     if (info->Chipset == PCI_CHIP_RV370_5B60 &&
 	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x17af &&
diff --git a/src/radeon_chipinfo_gen.h b/src/radeon_chipinfo_gen.h
index 0f53790..3fc2a53 100644
--- a/src/radeon_chipinfo_gen.h
+++ b/src/radeon_chipinfo_gen.h
@@ -4,6 +4,7 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x3151, CHIP_FAMILY_RV380, 0, 0, 0, 0, 0 },
  { 0x3152, CHIP_FAMILY_RV380, 1, 0, 0, 0, 0 },
  { 0x3154, CHIP_FAMILY_RV380, 1, 0, 0, 0, 0 },
+ { 0x3155, CHIP_FAMILY_RV380, 1, 0, 0, 0, 0 },
  { 0x3E50, CHIP_FAMILY_RV380, 0, 0, 0, 0, 0 },
  { 0x3E54, CHIP_FAMILY_RV380, 0, 0, 0, 0, 0 },
  { 0x4136, CHIP_FAMILY_RS100, 0, 1, 0, 0, 1 },
@@ -268,6 +269,7 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x9456, CHIP_FAMILY_RV770, 0, 0, 0, 0, 0 },
  { 0x945A, CHIP_FAMILY_RV770, 1, 0, 0, 0, 0 },
  { 0x945B, CHIP_FAMILY_RV770, 1, 0, 0, 0, 0 },
+ { 0x945E, CHIP_FAMILY_RV770, 1, 0, 0, 0, 0 },
  { 0x9460, CHIP_FAMILY_RV770, 0, 0, 0, 0, 0 },
  { 0x9462, CHIP_FAMILY_RV770, 0, 0, 0, 0, 0 },
  { 0x946A, CHIP_FAMILY_RV770, 1, 0, 0, 0, 0 },
@@ -278,6 +280,7 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x9487, CHIP_FAMILY_RV730, 0, 0, 0, 0, 0 },
  { 0x9488, CHIP_FAMILY_RV730, 1, 0, 0, 0, 0 },
  { 0x9489, CHIP_FAMILY_RV730, 1, 0, 0, 0, 0 },
+ { 0x948A, CHIP_FAMILY_RV730, 1, 0, 0, 0, 0 },
  { 0x948F, CHIP_FAMILY_RV730, 0, 0, 0, 0, 0 },
  { 0x9490, CHIP_FAMILY_RV730, 0, 0, 0, 0, 0 },
  { 0x9491, CHIP_FAMILY_RV730, 0, 0, 0, 0, 0 },
@@ -321,12 +324,14 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x9519, CHIP_FAMILY_RV670, 0, 0, 0, 0, 0 },
  { 0x9540, CHIP_FAMILY_RV710, 0, 0, 0, 0, 0 },
  { 0x9541, CHIP_FAMILY_RV710, 0, 0, 0, 0, 0 },
+ { 0x9542, CHIP_FAMILY_RV710, 0, 0, 0, 0, 0 },
  { 0x954E, CHIP_FAMILY_RV710, 0, 0, 0, 0, 0 },
  { 0x954F, CHIP_FAMILY_RV710, 0, 0, 0, 0, 0 },
  { 0x9552, CHIP_FAMILY_RV710, 1, 0, 0, 0, 0 },
  { 0x9553, CHIP_FAMILY_RV710, 1, 0, 0, 0, 0 },
  { 0x9555, CHIP_FAMILY_RV710, 1, 0, 0, 0, 0 },
  { 0x9557, CHIP_FAMILY_RV710, 1, 0, 0, 0, 0 },
+ { 0x955F, CHIP_FAMILY_RV710, 1, 0, 0, 0, 0 },
  { 0x9580, CHIP_FAMILY_RV630, 0, 0, 0, 0, 0 },
  { 0x9581, CHIP_FAMILY_RV630, 1, 0, 0, 0, 0 },
  { 0x9583, CHIP_FAMILY_RV630, 1, 0, 0, 0, 0 },
@@ -340,7 +345,6 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x958D, CHIP_FAMILY_RV630, 0, 0, 0, 0, 0 },
  { 0x958E, CHIP_FAMILY_RV630, 0, 0, 0, 0, 0 },
  { 0x958F, CHIP_FAMILY_RV630, 1, 0, 0, 0, 0 },
- { 0x9542, CHIP_FAMILY_RV710, 0, 0, 0, 0, 0 },
  { 0x95C0, CHIP_FAMILY_RV620, 0, 0, 0, 0, 0 },
  { 0x95C2, CHIP_FAMILY_RV620, 1, 0, 0, 0, 0 },
  { 0x95C4, CHIP_FAMILY_RV620, 1, 0, 0, 0, 0 },
@@ -393,6 +397,7 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x68BE, CHIP_FAMILY_JUNIPER, 0, 0, 0, 0, 0 },
  { 0x68C0, CHIP_FAMILY_REDWOOD, 1, 0, 0, 0, 0 },
  { 0x68C1, CHIP_FAMILY_REDWOOD, 1, 0, 0, 0, 0 },
+ { 0x68C7, CHIP_FAMILY_REDWOOD, 1, 0, 0, 0, 0 },
  { 0x68C8, CHIP_FAMILY_REDWOOD, 0, 0, 0, 0, 0 },
  { 0x68C9, CHIP_FAMILY_REDWOOD, 0, 0, 0, 0, 0 },
  { 0x68D8, CHIP_FAMILY_REDWOOD, 0, 0, 0, 0, 0 },
diff --git a/src/radeon_chipset_gen.h b/src/radeon_chipset_gen.h
index 7b74d7e..e38579b 100644
--- a/src/radeon_chipset_gen.h
+++ b/src/radeon_chipset_gen.h
@@ -4,6 +4,7 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV380_3151, "ATI FireMV 2400 (PCI)" },
   { PCI_CHIP_RV380_3152, "ATI Radeon Mobility X300 (M24) 3152 (PCIE)" },
   { PCI_CHIP_RV380_3154, "ATI FireGL M24 GL 3154 (PCIE)" },
+  { PCI_CHIP_RV380_3155, "ATI FireMV 2400 3155 (PCI)" },
   { PCI_CHIP_RV380_3E50, "ATI Radeon X600 (RV380) 3E50 (PCIE)" },
   { PCI_CHIP_RV380_3E54, "ATI FireGL V3200 (RV380) 3E54 (PCIE)" },
   { PCI_CHIP_RS100_4136, "ATI Radeon IGP320 (A3) 4136" },
@@ -268,6 +269,7 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV770_9456, "ATI FirePro V8700 (FireGL)" },
   { PCI_CHIP_RV770_945A, "ATI Mobility RADEON HD 4870" },
   { PCI_CHIP_RV770_945B, "ATI Mobility RADEON M98" },
+  { PCI_CHIP_RV770_945E, "ATI Mobility RADEON HD 4870" },
   { PCI_CHIP_RV790_9460, "ATI Radeon 4800 Series" },
   { PCI_CHIP_RV790_9462, "ATI Radeon 4800 Series" },
   { PCI_CHIP_RV770_946A, "ATI FirePro M7750" },
@@ -278,6 +280,7 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV730_9487, "ATI Radeon RV730 (AGP)" },
   { PCI_CHIP_RV730_9488, "ATI Mobility Radeon HD 4670" },
   { PCI_CHIP_RV730_9489, "ATI FirePro M5750" },
+  { PCI_CHIP_RV730_948A, "ATI Mobility Radeon HD 4670" },
   { PCI_CHIP_RV730_948F, "ATI Radeon RV730 (AGP)" },
   { PCI_CHIP_RV730_9490, "ATI RV730XT [Radeon HD 4670]" },
   { PCI_CHIP_RV730_9491, "ATI RADEON E4600" },
@@ -321,12 +324,14 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV670_9519, "AMD Firestream 9170" },
   { PCI_CHIP_RV710_9540, "ATI Radeon HD 4550" },
   { PCI_CHIP_RV710_9541, "ATI Radeon RV710" },
+  { PCI_CHIP_RV710_9542, "ATI Radeon RV710" },
   { PCI_CHIP_RV710_954E, "ATI Radeon RV710" },
   { PCI_CHIP_RV710_954F, "ATI Radeon HD 4350" },
   { PCI_CHIP_RV710_9552, "ATI Mobility Radeon 4300 Series" },
   { PCI_CHIP_RV710_9553, "ATI Mobility Radeon 4500 Series" },
   { PCI_CHIP_RV710_9555, "ATI Mobility Radeon 4500 Series" },
   { PCI_CHIP_RV710_9557, "ATI FirePro RG220" },
+  { PCI_CHIP_RV710_955F, "ATI Mobility Radeon 4330" },
   { PCI_CHIP_RV630_9580, "ATI RV630" },
   { PCI_CHIP_RV630_9581, "ATI Mobility Radeon HD 2600" },
   { PCI_CHIP_RV630_9583, "ATI Mobility Radeon HD 2600 XT" },
@@ -340,7 +345,6 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV630_958D, "ATI FireGL V3600" },
   { PCI_CHIP_RV630_958E, "ATI Radeon HD 2600 LE" },
   { PCI_CHIP_RV630_958F, "ATI Mobility FireGL Graphics Processor" },
-  { PCI_CHIP_RV710_9542, "ATI Radeon RV710" },
   { PCI_CHIP_RV620_95C0, "ATI Radeon HD 3470" },
   { PCI_CHIP_RV620_95C2, "ATI Mobility Radeon HD 3430" },
   { PCI_CHIP_RV620_95C4, "ATI Mobility Radeon HD 3400 Series" },
@@ -393,6 +397,7 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_JUNIPER_68BE, "ATI Radeon HD 5700 Series" },
   { PCI_CHIP_REDWOOD_68C0, "ATI Mobility Radeon HD 5000 Series" },
   { PCI_CHIP_REDWOOD_68C1, "ATI Mobility Radeon HD 5000 Series" },
+  { PCI_CHIP_REDWOOD_68C7, "ATI Mobility Radeon HD 5570" },
   { PCI_CHIP_REDWOOD_68C8, "ATI FirePro (FireGL) Graphics Adapter" },
   { PCI_CHIP_REDWOOD_68C9, "ATI FirePro (FireGL) Graphics Adapter" },
   { PCI_CHIP_REDWOOD_68D8, "ATI Radeon HD 5670" },
diff --git a/src/radeon_commonfuncs.c b/src/radeon_commonfuncs.c
index 8c46235..95193f6 100644
--- a/src/radeon_commonfuncs.c
+++ b/src/radeon_commonfuncs.c
@@ -170,20 +170,21 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 			(5 << R300_PVS_NUM_CNTLRS_SHIFT) |
 			(5 << R300_VF_MAX_VTX_NUM_SHIFT));
 
-	if (info->ChipFamily == CHIP_FAMILY_RV515)
-	    vap_cntl |= (2 << R300_PVS_NUM_FPUS_SHIFT);
-	else if ((info->ChipFamily == CHIP_FAMILY_RV530) ||
-		 (info->ChipFamily == CHIP_FAMILY_RV560) ||
-		 (info->ChipFamily == CHIP_FAMILY_RV570))
+	if ((info->ChipFamily == CHIP_FAMILY_R300) ||
+	    (info->ChipFamily == CHIP_FAMILY_R350))
+	    vap_cntl |= (4 << R300_PVS_NUM_FPUS_SHIFT);
+	else if (info->ChipFamily == CHIP_FAMILY_RV530)
 	    vap_cntl |= (5 << R300_PVS_NUM_FPUS_SHIFT);
 	else if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
 		 (info->ChipFamily == CHIP_FAMILY_R420))
 	    vap_cntl |= (6 << R300_PVS_NUM_FPUS_SHIFT);
 	else if ((info->ChipFamily == CHIP_FAMILY_R520) ||
-		 (info->ChipFamily == CHIP_FAMILY_R580))
+		 (info->ChipFamily == CHIP_FAMILY_R580) ||
+		 (info->ChipFamily == CHIP_FAMILY_RV560) ||
+		 (info->ChipFamily == CHIP_FAMILY_RV570))
 	    vap_cntl |= (8 << R300_PVS_NUM_FPUS_SHIFT);
 	else
-	    vap_cntl |= (4 << R300_PVS_NUM_FPUS_SHIFT);
+	    vap_cntl |= (2 << R300_PVS_NUM_FPUS_SHIFT);
 
 	if (info->accel_state->has_tcl)
 	    BEGIN_ACCEL(15);
diff --git a/src/radeon_crtc.c b/src/radeon_crtc.c
index 0b071b8..5f4a0a7 100644
--- a/src/radeon_crtc.c
+++ b/src/radeon_crtc.c
@@ -447,7 +447,7 @@ done:
 }
 
 void
-RADEONComputePLL(ScrnInfoPtr pScrn,
+RADEONComputePLL(xf86CrtcPtr crtc,
 		 RADEONPLLPtr pll,
 		 unsigned long freq,
 		 uint32_t *chosen_dot_clock_freq,
@@ -457,28 +457,21 @@ RADEONComputePLL(ScrnInfoPtr pScrn,
 		 uint32_t *chosen_post_div,
 		 int flags)
 {
-    RADEONInfoPtr info = RADEONPTR(pScrn);
+    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
 
-    if (IS_AVIVO_VARIANT) {
-	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, TRUE)) {
-	    /* disable frac fb dividers */
-	    flags &= ~RADEON_PLL_USE_FRAC_FB_DIV;
-	    RADEONComputePLL_new(pll, freq, chosen_dot_clock_freq,
-				 chosen_feedback_div, chosen_frac_feedback_div,
-				 chosen_reference_div, chosen_post_div, flags);
-	} else
-	    RADEONComputePLL_old(pll, freq, chosen_dot_clock_freq,
-				 chosen_feedback_div, chosen_frac_feedback_div,
-				 chosen_reference_div, chosen_post_div, flags);
-    } else {
-	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
-	    RADEONComputePLL_new(pll, freq, chosen_dot_clock_freq,
-				 chosen_feedback_div, chosen_frac_feedback_div,
-				 chosen_reference_div, chosen_post_div, flags);
-	else
-	    RADEONComputePLL_old(pll, freq, chosen_dot_clock_freq,
-				 chosen_feedback_div, chosen_frac_feedback_div,
-				 chosen_reference_div, chosen_post_div, flags);
+    switch (radeon_crtc->pll_algo) {
+    case RADEON_PLL_OLD:
+	RADEONComputePLL_old(pll, freq, chosen_dot_clock_freq,
+			     chosen_feedback_div, chosen_frac_feedback_div,
+			     chosen_reference_div, chosen_post_div, flags);
+	break;
+    case RADEON_PLL_NEW:
+	/* disable frac fb dividers */
+	flags &= ~RADEON_PLL_USE_FRAC_FB_DIV;
+	RADEONComputePLL_new(pll, freq, chosen_dot_clock_freq,
+			     chosen_feedback_div, chosen_frac_feedback_div,
+			     chosen_reference_div, chosen_post_div, flags);
+	break;
     }
 }
 
@@ -571,28 +564,12 @@ radeon_crtc_gamma_set(xf86CrtcPtr crtc, uint16_t *red, uint16_t *green,
 		      uint16_t *blue, int size)
 {
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
-    ScrnInfoPtr		pScrn = crtc->scrn;
-    int i, j;
-
-    if (pScrn->depth == 16) {
-	for (i = 0; i < 64; i++) {
-	    if (i <= 31) {
-		for (j = 0; j < 8; j++) {
-		    radeon_crtc->lut_r[i * 8 + j] = red[i] >> 6;
-		    radeon_crtc->lut_b[i * 8 + j] = blue[i] >> 6;
-		}
-	    }
+    int i;
 
-	    for (j = 0; j < 4; j++) {
-		radeon_crtc->lut_g[i * 4 + j] = green[i] >> 6;
-	    }
-	}
-    } else {
-	for (i = 0; i < 256; i++) {
-	    radeon_crtc->lut_r[i] = red[i] >> 6;
-	    radeon_crtc->lut_g[i] = green[i] >> 6;
-	    radeon_crtc->lut_b[i] = blue[i] >> 6;
-	}
+    for (i = 0; i < 256; i++) {
+	radeon_crtc->lut_r[i] = red[i] >> 6;
+	radeon_crtc->lut_g[i] = green[i] >> 6;
+	radeon_crtc->lut_b[i] = blue[i] >> 6;
     }
 
     radeon_crtc_load_lut(crtc);
@@ -889,7 +866,7 @@ Bool RADEONAllocateControllers(ScrnInfoPtr pScrn, int mask)
 	pRADEONEnt->Controller[1] = xnfcalloc(sizeof(RADEONCrtcPrivateRec), 1);
 	if (!pRADEONEnt->Controller[1])
 	    {
-		xfree(pRADEONEnt->Controller[0]);
+		free(pRADEONEnt->Controller[0]);
 		return FALSE;
 	    }
 
@@ -917,7 +894,7 @@ Bool RADEONAllocateControllers(ScrnInfoPtr pScrn, int mask)
 	    pRADEONEnt->Controller[i] = xnfcalloc(sizeof(RADEONCrtcPrivateRec), 1);
 	    if (!pRADEONEnt->Controller[i])
 	    {
-		xfree(pRADEONEnt->Controller[i]);
+		free(pRADEONEnt->Controller[i]);
 		return FALSE;
 	    }
 
diff --git a/src/radeon_cursor.c b/src/radeon_cursor.c
index 4a171ff..538c8b2 100644
--- a/src/radeon_cursor.c
+++ b/src/radeon_cursor.c
@@ -343,7 +343,7 @@ radeon_crtc_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg)
     ScrnInfoPtr pScrn = crtc->scrn;
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
     RADEONInfoPtr info = RADEONPTR(pScrn);
-    uint32_t *pixels = (uint32_t *)(pointer)(info->FB + radeon_crtc->cursor_offset);
+    uint32_t *pixels = (uint32_t *)(pointer)(info->FB + pScrn->fbOffset + radeon_crtc->cursor_offset);
     int            pixel, i;
     CURSOR_SWAPPING_DECL_MMIO
 
@@ -386,7 +386,7 @@ radeon_crtc_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image)
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     CURSOR_SWAPPING_DECL_MMIO
-    uint32_t *d = (uint32_t *)(pointer)(info->FB + radeon_crtc->cursor_offset);
+    uint32_t *d = (uint32_t *)(pointer)(info->FB + pScrn->fbOffset + radeon_crtc->cursor_offset);
 
     RADEONCTRACE(("RADEONLoadCursorARGB\n"));
 
diff --git a/src/radeon_dri.c b/src/radeon_dri.c
index ee62e95..ed167ed 100644
--- a/src/radeon_dri.c
+++ b/src/radeon_dri.c
@@ -122,21 +122,21 @@ static Bool RADEONInitVisualConfigs(ScreenPtr pScreen)
 	if (use_db)             numConfigs *= 2;
 
 	if (!(pConfigs
-	      = (__GLXvisualConfig *)xcalloc(sizeof(__GLXvisualConfig),
-					     numConfigs))) {
+	      = (__GLXvisualConfig *)calloc(sizeof(__GLXvisualConfig),
+					    numConfigs))) {
 	    return FALSE;
 	}
 	if (!(pRADEONConfigs
-	      = (RADEONConfigPrivPtr)xcalloc(sizeof(RADEONConfigPrivRec),
-					     numConfigs))) {
-	    xfree(pConfigs);
+	      = (RADEONConfigPrivPtr)calloc(sizeof(RADEONConfigPrivRec),
+					    numConfigs))) {
+	    free(pConfigs);
 	    return FALSE;
 	}
 	if (!(pRADEONConfigPtrs
-	      = (RADEONConfigPrivPtr *)xcalloc(sizeof(RADEONConfigPrivPtr),
-					       numConfigs))) {
-	    xfree(pConfigs);
-	    xfree(pRADEONConfigs);
+	      = (RADEONConfigPrivPtr *)calloc(sizeof(RADEONConfigPrivPtr),
+					      numConfigs))) {
+	    free(pConfigs);
+	    free(pRADEONConfigs);
 	    return FALSE;
 	}
 
@@ -208,21 +208,21 @@ static Bool RADEONInitVisualConfigs(ScreenPtr pScreen)
 	if (use_db)             numConfigs *= 2;
 
 	if (!(pConfigs
-	      = (__GLXvisualConfig *)xcalloc(sizeof(__GLXvisualConfig),
-					     numConfigs))) {
+	      = (__GLXvisualConfig *)calloc(sizeof(__GLXvisualConfig),
+					    numConfigs))) {
 	    return FALSE;
 	}
 	if (!(pRADEONConfigs
-	      = (RADEONConfigPrivPtr)xcalloc(sizeof(RADEONConfigPrivRec),
-					     numConfigs))) {
-	    xfree(pConfigs);
+	      = (RADEONConfigPrivPtr)calloc(sizeof(RADEONConfigPrivRec),
+					    numConfigs))) {
+	    free(pConfigs);
 	    return FALSE;
 	}
 	if (!(pRADEONConfigPtrs
-	      = (RADEONConfigPrivPtr *)xcalloc(sizeof(RADEONConfigPrivPtr),
-					       numConfigs))) {
-	    xfree(pConfigs);
-	    xfree(pRADEONConfigs);
+	      = (RADEONConfigPrivPtr *)calloc(sizeof(RADEONConfigPrivPtr),
+					      numConfigs))) {
+	    free(pConfigs);
+	    free(pRADEONConfigs);
 	    return FALSE;
 	}
 
@@ -300,36 +300,6 @@ static Bool RADEONCreateContext(ScreenPtr pScreen, VisualPtr visual,
 				drm_context_t hwContext, void *pVisualConfigPriv,
 				DRIContextType contextStore)
 {
-#ifdef PER_CONTEXT_SAREA
-    ScrnInfoPtr          pScrn = xf86Screens[pScreen->myNum];
-    RADEONInfoPtr        info  = RADEONPTR(pScrn);
-    RADEONDRIContextPtr  ctx_info;
-
-    ctx_info = (RADEONDRIContextPtr)contextStore;
-    if (!ctx_info) return FALSE;
-
-    if (drmAddMap(info->dri->drmFD, 0,
-		  info->dri->perctx_sarea_size,
-		  DRM_SHM,
-		  DRM_REMOVABLE,
-		  &ctx_info->sarea_handle) < 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "[dri] could not create private sarea for ctx id (%d)\n",
-		   (int)hwContext);
-	return FALSE;
-    }
-
-    if (drmAddContextPrivateMapping(info->dri->drmFD, hwContext,
-				    ctx_info->sarea_handle) < 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "[dri] could not associate private sarea to ctx id (%d)\n",
-		   (int)hwContext);
-	drmRmMap(info->dri->drmFD, ctx_info->sarea_handle);
-	return FALSE;
-    }
-
-    ctx_info->ctx_id = hwContext;
-#endif
     return TRUE;
 }
 
@@ -337,20 +307,6 @@ static Bool RADEONCreateContext(ScreenPtr pScreen, VisualPtr visual,
 static void RADEONDestroyContext(ScreenPtr pScreen, drm_context_t hwContext,
 				 DRIContextType contextStore)
 {
-#ifdef PER_CONTEXT_SAREA
-    ScrnInfoPtr          pScrn = xf86Screens[pScreen->myNum];
-    RADEONInfoPtr        info = RADEONPTR(pScrn);
-    RADEONDRIContextPtr  ctx_info;
-
-    ctx_info = (RADEONDRIContextPtr)contextStore;
-    if (!ctx_info) return;
-
-    if (drmRmMap(info->dri->drmFD, ctx_info->sarea_handle) < 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "[dri] could not remove private sarea for ctx id (%d)\n",
-		   (int)hwContext);
-    }
-#endif
 }
 
 /* Called when the X server is woken up to allow the last client's
@@ -567,12 +523,12 @@ static void RADEONDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
 
 	if (nbox > 1) {
 	    /* Keep ordering in each band, reverse order of bands */
-	    pboxNew1 = (BoxPtr)xalloc(sizeof(BoxRec)*nbox);
+	    pboxNew1 = (BoxPtr)malloc(sizeof(BoxRec)*nbox);
 	    if (!pboxNew1) return;
 
-	    pptNew1 = (DDXPointPtr)xalloc(sizeof(DDXPointRec)*nbox);
+	    pptNew1 = (DDXPointPtr)malloc(sizeof(DDXPointRec)*nbox);
 	    if (!pptNew1) {
-		xfree(pboxNew1);
+		free(pboxNew1);
 		return;
 	    }
 
@@ -609,14 +565,14 @@ static void RADEONDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
 
 	if (nbox > 1) {
 	    /* reverse order of rects in each band */
-	    pboxNew2 = (BoxPtr)xalloc(sizeof(BoxRec)*nbox);
-	    pptNew2  = (DDXPointPtr)xalloc(sizeof(DDXPointRec)*nbox);
+	    pboxNew2 = (BoxPtr)malloc(sizeof(BoxRec)*nbox);
+	    pptNew2  = (DDXPointPtr)malloc(sizeof(DDXPointRec)*nbox);
 
 	    if (!pboxNew2 || !pptNew2) {
-		xfree(pptNew2);
-		xfree(pboxNew2);
-		xfree(pptNew1);
-		xfree(pboxNew1);
+		free(pptNew2);
+		free(pboxNew2);
+		free(pptNew1);
+		free(pboxNew1);
 		return;
 	    }
 
@@ -687,10 +643,10 @@ static void RADEONDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
 
     info->accel_state->dst_pitch_offset = info->dri->frontPitchOffset;;
 
-    xfree(pptNew2);
-    xfree(pboxNew2);
-    xfree(pptNew1);
-    xfree(pboxNew1);
+    free(pptNew2);
+    free(pboxNew2);
+    free(pptNew1);
+    free(pboxNew1);
 
     info->accel_state->accel->NeedToSync = TRUE;
 #endif /* USE_XAA */
@@ -1454,7 +1410,7 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
     if (xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
 	busId = DRICreatePCIBusID(info->PciInfo);
     } else {
-	busId = xalloc(64);
+	busId = malloc(64);
 	sprintf(busId,
 		"PCI:%d:%d:%d",
 		PCI_DEV_BUS(info->PciInfo),
@@ -1464,7 +1420,7 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
 
     /* Low level DRM open */
     fd = drmOpen(RADEON_DRIVER_NAME, busId);
-    xfree(busId);
+    free(busId);
     if (fd < 0) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[dri] RADEONDRIGetVersion failed to open the DRM\n"
@@ -1601,7 +1557,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
     if (xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
 	pDRIInfo->busIdString = DRICreatePCIBusID(info->PciInfo);
     } else {
-	pDRIInfo->busIdString            = xalloc(64);
+	pDRIInfo->busIdString            = malloc(64);
 	sprintf(pDRIInfo->busIdString,
 		"PCI:%d:%d:%d",
 		PCI_DEV_BUS(info->PciInfo),
@@ -1624,12 +1580,6 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
        correctly with pageflip + mergedfb/color tiling */
     pDRIInfo->wrap.AdjustFrame = NULL;
 
-#ifdef PER_CONTEXT_SAREA
-    /* This is only here for testing per-context SAREAs.  When used, the
-       magic number below would be properly defined in a header file. */
-    info->perctx_sarea_size = 64 * 1024;
-#endif
-
 #ifdef NOT_DONE
     /* FIXME: Need to extend DRI protocol to pass this size back to
      * client for SAREA mapping that includes a device private record
@@ -1648,7 +1598,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
     pDRIInfo->SAREASize = SAREA_MAX;
 #endif
 
-    if (!(pRADEONDRI = (RADEONDRIPtr)xcalloc(sizeof(RADEONDRIRec),1))) {
+    if (!(pRADEONDRI = (RADEONDRIPtr)calloc(sizeof(RADEONDRIRec),1))) {
 	DRIDestroyInfoRec(info->dri->pDRIInfo);
 	info->dri->pDRIInfo = NULL;
 	return FALSE;
@@ -1695,7 +1645,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
     if (!DRIScreenInit(pScreen, pDRIInfo, &info->dri->drmFD)) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[dri] DRIScreenInit failed.  Disabling DRI.\n");
-	xfree(pDRIInfo->devPrivate);
+	free(pDRIInfo->devPrivate);
 	pDRIInfo->devPrivate = NULL;
 	DRIDestroyInfoRec(pDRIInfo);
 	pDRIInfo = NULL;
@@ -1846,11 +1796,6 @@ Bool RADEONDRIFinishScreenInit(ScreenPtr pScreen)
 
     pRADEONDRI->sarea_priv_offset = sizeof(XF86DRISAREARec);
 
-#ifdef PER_CONTEXT_SAREA
-    /* Set per-context SAREA size */
-    pRADEONDRI->perctx_sarea_size = info->dri->perctx_sarea_size;
-#endif
-
     info->directRenderingInited = TRUE;
 
     /* Wrap CloseScreen */
@@ -1989,7 +1934,7 @@ void RADEONDRICloseScreen(ScreenPtr pScreen)
     }
 
     if (info->dri->pciGartBackup) {
-	xfree(info->dri->pciGartBackup);
+	free(info->dri->pciGartBackup);
 	info->dri->pciGartBackup = NULL;
     }
 
@@ -1999,18 +1944,18 @@ void RADEONDRICloseScreen(ScreenPtr pScreen)
     /* De-allocate all DRI data structures */
     if (info->dri->pDRIInfo) {
 	if (info->dri->pDRIInfo->devPrivate) {
-	    xfree(info->dri->pDRIInfo->devPrivate);
+	    free(info->dri->pDRIInfo->devPrivate);
 	    info->dri->pDRIInfo->devPrivate = NULL;
 	}
 	DRIDestroyInfoRec(info->dri->pDRIInfo);
 	info->dri->pDRIInfo = NULL;
     }
     if (info->dri->pVisualConfigs) {
-	xfree(info->dri->pVisualConfigs);
+	free(info->dri->pVisualConfigs);
 	info->dri->pVisualConfigs = NULL;
     }
     if (info->dri->pVisualConfigsPriv) {
-	xfree(info->dri->pVisualConfigsPriv);
+	free(info->dri->pVisualConfigsPriv);
 	info->dri->pVisualConfigsPriv = NULL;
     }
 }
diff --git a/src/radeon_dri.h b/src/radeon_dri.h
index 6e3ad62..15beb52 100644
--- a/src/radeon_dri.h
+++ b/src/radeon_dri.h
@@ -86,10 +86,6 @@ typedef struct {
     int           log2GARTTexGran;
     int           gartTexOffset;
     unsigned int  sarea_priv_offset;
-
-#ifdef PER_CONTEXT_SAREA
-    drmSize      perctx_sarea_size;
-#endif
 } RADEONDRIRec, *RADEONDRIPtr;
 
 #endif
diff --git a/src/radeon_dri2.c b/src/radeon_dri2.c
index 103972f..a0ed085 100644
--- a/src/radeon_dri2.c
+++ b/src/radeon_dri2.c
@@ -74,13 +74,13 @@ radeon_dri2_create_buffers(DrawablePtr drawable,
     int i, r;
     int flags = 0;
 
-    buffers = xcalloc(count, sizeof *buffers);
+    buffers = calloc(count, sizeof *buffers);
     if (buffers == NULL) {
         return NULL;
     }
-    privates = xcalloc(count, sizeof(struct dri2_buffer_priv));
+    privates = calloc(count, sizeof(struct dri2_buffer_priv));
     if (privates == NULL) {
-        xfree(buffers);
+        free(buffers);
         return NULL;
     }
 
@@ -156,13 +156,13 @@ radeon_dri2_create_buffer(DrawablePtr drawable,
     int r;
     int flags;
 
-    buffers = xcalloc(1, sizeof *buffers);
+    buffers = calloc(1, sizeof *buffers);
     if (buffers == NULL) {
         return NULL;
     }
-    privates = xcalloc(1, sizeof(struct dri2_buffer_priv));
+    privates = calloc(1, sizeof(struct dri2_buffer_priv));
     if (privates == NULL) {
-        xfree(buffers);
+        free(buffers);
         return NULL;
     }
 
@@ -240,8 +240,8 @@ radeon_dri2_destroy_buffers(DrawablePtr drawable,
         (*pScreen->DestroyPixmap)(private->pixmap);
     }
     if (buffers) {
-        xfree(buffers[0].driverPrivate);
-        xfree(buffers);
+        free(buffers[0].driverPrivate);
+        free(buffers);
     }
 }
 #else
@@ -256,8 +256,8 @@ radeon_dri2_destroy_buffer(DrawablePtr drawable, BufferPtr buffers)
         private = buffers->driverPrivate;
         (*pScreen->DestroyPixmap)(private->pixmap);
 
-        xfree(buffers->driverPrivate);
-        xfree(buffers);
+        free(buffers->driverPrivate);
+        free(buffers);
     }
 }
 #endif
@@ -272,26 +272,28 @@ radeon_dri2_copy_region(DrawablePtr drawable,
     struct dri2_buffer_priv *dst_private = dest_buffer->driverPrivate;
     ScreenPtr pScreen = drawable->pScreen;
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    PixmapPtr src_pixmap;
-    PixmapPtr dst_pixmap;
+    DrawablePtr src_drawable;
+    DrawablePtr dst_drawable;
     RegionPtr copy_clip;
     GCPtr gc;
     RADEONInfoPtr info = RADEONPTR(pScrn);
     Bool vsync;
 
-    src_pixmap = src_private->pixmap;
-    dst_pixmap = dst_private->pixmap;
     if (src_private->attachment == DRI2BufferFrontLeft) {
-        src_pixmap = (PixmapPtr)drawable;
+        src_drawable = drawable;
+    } else {
+        src_drawable = &src_private->pixmap->drawable;
     }
     if (dst_private->attachment == DRI2BufferFrontLeft) {
-        dst_pixmap = (PixmapPtr)drawable;
+        dst_drawable = drawable;
+    } else {
+        dst_drawable = &dst_private->pixmap->drawable;
     }
-    gc = GetScratchGC(drawable->depth, pScreen);
+    gc = GetScratchGC(dst_drawable->depth, pScreen);
     copy_clip = REGION_CREATE(pScreen, NULL, 0);
     REGION_COPY(pScreen, copy_clip, region);
     (*gc->funcs->ChangeClip) (gc, CT_REGION, copy_clip, 0);
-    ValidateGC(&dst_pixmap->drawable, gc);
+    ValidateGC(dst_drawable, gc);
 
     /* If this is a full buffer swap or frontbuffer flush, throttle on the
      * previous one
@@ -304,7 +306,7 @@ radeon_dri2_copy_region(DrawablePtr drawable,
 		extents->x2 == drawable->width &&
 		extents->y2 == drawable->height) {
 		struct radeon_exa_pixmap_priv *exa_priv =
-		    exaGetPixmapDriverPrivate(dst_pixmap);
+		    exaGetPixmapDriverPrivate(dst_private->pixmap);
 
 		if (exa_priv && exa_priv->bo)
 		    radeon_bo_wait(exa_priv->bo);
@@ -315,7 +317,7 @@ radeon_dri2_copy_region(DrawablePtr drawable,
     vsync = info->accel_state->vsync;
     info->accel_state->vsync = TRUE;
 
-    (*gc->ops->CopyArea)(&src_pixmap->drawable, &dst_pixmap->drawable, gc,
+    (*gc->ops->CopyArea)(src_drawable, dst_drawable, gc,
                          0, 0, drawable->width, drawable->height, 0, 0);
 
     info->accel_state->vsync = vsync;
@@ -324,12 +326,448 @@ radeon_dri2_copy_region(DrawablePtr drawable,
     radeon_cs_flush_indirect(pScrn);
 }
 
+
+#if DRI2INFOREC_VERSION >= 4
+
+enum DRI2FrameEventType {
+    DRI2_SWAP,
+    DRI2_FLIP,
+    DRI2_WAITMSC,
+};
+
+typedef struct _DRI2FrameEvent {
+    XID drawable_id;
+    ClientPtr client;
+    enum DRI2FrameEventType type;
+    int frame;
+
+    /* for swaps & flips only */
+    DRI2SwapEventPtr event_complete;
+    void *event_data;
+    DRI2BufferPtr front;
+    DRI2BufferPtr back;
+} DRI2FrameEventRec, *DRI2FrameEventPtr;
+
+void radeon_dri2_frame_event_handler(unsigned int frame, unsigned int tv_sec,
+                                     unsigned int tv_usec, void *event_data)
+{
+    DRI2FrameEventPtr event = event_data;
+    DrawablePtr drawable;
+    ScreenPtr screen;
+    ScrnInfoPtr scrn;
+    int status;
+    int swap_type;
+    BoxRec box;
+    RegionRec region;
+
+    status = dixLookupDrawable(&drawable, event->drawable_id, serverClient,
+                               M_ANY, DixWriteAccess);
+    if (status != Success) {
+        free(event);
+        return;
+    }
+
+    screen = drawable->pScreen;
+    scrn = xf86Screens[screen->myNum];
+
+    switch (event->type) {
+    case DRI2_FLIP:
+    case DRI2_SWAP:
+        box.x1 = 0;
+        box.y1 = 0;
+        box.x2 = drawable->width;
+        box.y2 = drawable->height;
+        REGION_INIT(pScreen, &region, &box, 0);
+        radeon_dri2_copy_region(drawable, &region, event->front, event->back);
+        swap_type = DRI2_BLIT_COMPLETE;
+
+        DRI2SwapComplete(event->client, drawable, frame, tv_sec, tv_usec,
+                swap_type, event->event_complete, event->event_data);
+        break;
+    case DRI2_WAITMSC:
+        DRI2WaitMSCComplete(event->client, drawable, frame, tv_sec, tv_usec);
+        break;
+    default:
+        /* Unknown type */
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                "%s: unknown vblank event received\n", __func__);
+        break;
+    }
+
+    free(event);
+}
+
+static int radeon_dri2_drawable_crtc(DrawablePtr pDraw)
+{
+    ScreenPtr pScreen = pDraw->pScreen;
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    xf86CrtcPtr crtc;
+    int crtc_id = -1;
+
+    crtc = radeon_pick_best_crtc(pScrn,
+				 pDraw->x,
+				 pDraw->x + pDraw->width,
+				 pDraw->y,
+				 pDraw->y + pDraw->height);
+
+    /* Make sure the CRTC is valid and this is the real front buffer */
+    if (crtc != NULL && !crtc->rotatedData) {
+        crtc_id = drmmode_get_crtc_id(crtc);
+    }
+    return crtc_id;
+}
+
+/*
+ * Get current frame count and frame count timestamp, based on drawable's
+ * crtc.
+ */
+static int radeon_dri2_get_msc(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
+{
+    ScreenPtr screen = draw->pScreen;
+    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
+    RADEONInfoPtr info = RADEONPTR(scrn);
+    drmVBlank vbl;
+    int ret;
+    int crtc= radeon_dri2_drawable_crtc(draw);
+
+    /* Drawable not displayed, make up a value */
+    if (crtc == -1) {
+        *ust = 0;
+        *msc = 0;
+        return TRUE;
+    }
+    vbl.request.type = DRM_VBLANK_RELATIVE;
+    if (crtc > 0)
+        vbl.request.type |= DRM_VBLANK_SECONDARY;
+    vbl.request.sequence = 0;
+
+    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+    if (ret) {
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                "get vblank counter failed: %s\n", strerror(errno));
+        return FALSE;
+    }
+
+    *ust = ((CARD64)vbl.reply.tval_sec * 1000000) + vbl.reply.tval_usec;
+    *msc = vbl.reply.sequence;
+
+    return TRUE;
+}
+
+/*
+ * Request a DRM event when the requested conditions will be satisfied.
+ *
+ * We need to handle the event and ask the server to wake up the client when
+ * we receive it.
+ */
+static int radeon_dri2_schedule_wait_msc(ClientPtr client, DrawablePtr draw,
+                                         CARD64 target_msc, CARD64 divisor,
+                                         CARD64 remainder)
+{
+    ScreenPtr screen = draw->pScreen;
+    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
+    RADEONInfoPtr info = RADEONPTR(scrn);
+    DRI2FrameEventPtr wait_info;
+    drmVBlank vbl;
+    int ret, crtc = radeon_dri2_drawable_crtc(draw);
+    CARD64 current_msc;
+
+    /* Truncate to match kernel interfaces; means occasional overflow
+     * misses, but that's generally not a big deal */
+    target_msc &= 0xffffffff;
+    divisor &= 0xffffffff;
+    remainder &= 0xffffffff;
+
+    /* Drawable not visible, return immediately */
+    if (crtc == -1)
+        goto out_complete;
+
+    wait_info = calloc(1, sizeof(DRI2FrameEventRec));
+    if (!wait_info)
+        goto out_complete;
+
+    wait_info->drawable_id = draw->id;
+    wait_info->client = client;
+    wait_info->type = DRI2_WAITMSC;
+
+    /* Get current count */
+    vbl.request.type = DRM_VBLANK_RELATIVE;
+    if (crtc > 0)
+        vbl.request.type |= DRM_VBLANK_SECONDARY;
+    vbl.request.sequence = 0;
+    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+    if (ret) {
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                "get vblank counter failed: %s\n", strerror(errno));
+        goto out_complete;
+    }
+
+    current_msc = vbl.reply.sequence;
+
+    /*
+     * If divisor is zero, or current_msc is smaller than target_msc,
+     * we just need to make sure target_msc passes  before waking up the
+     * client.
+     */
+    if (divisor == 0 || current_msc < target_msc) {
+        /* If target_msc already reached or passed, set it to
+         * current_msc to ensure we return a reasonable value back
+         * to the caller. This keeps the client from continually
+         * sending us MSC targets from the past by forcibly updating
+         * their count on this call.
+         */
+        if (current_msc >= target_msc)
+            target_msc = current_msc;
+        vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
+        if (crtc > 0)
+            vbl.request.type |= DRM_VBLANK_SECONDARY;
+        vbl.request.sequence = target_msc;
+        vbl.request.signal = (unsigned long)wait_info;
+        ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+        if (ret) {
+            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                    "get vblank counter failed: %s\n", strerror(errno));
+            goto out_complete;
+        }
+
+        wait_info->frame = vbl.reply.sequence;
+        DRI2BlockClient(client, draw);
+        return TRUE;
+    }
+
+    /*
+     * If we get here, target_msc has already passed or we don't have one,
+     * so we queue an event that will satisfy the divisor/remainder equation.
+     */
+    vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
+    if (crtc > 0)
+        vbl.request.type |= DRM_VBLANK_SECONDARY;
+
+    vbl.request.sequence = current_msc - (current_msc % divisor) +
+        remainder;
+
+    /*
+     * If calculated remainder is larger than requested remainder,
+     * it means we've passed the last point where
+     * seq % divisor == remainder, so we need to wait for the next time
+     * that will happen.
+     */
+    if ((current_msc % divisor) >= remainder)
+        vbl.request.sequence += divisor;
+
+    vbl.request.signal = (unsigned long)wait_info;
+    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+    if (ret) {
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                "get vblank counter failed: %s\n", strerror(errno));
+        goto out_complete;
+    }
+
+    wait_info->frame = vbl.reply.sequence;
+    DRI2BlockClient(client, draw);
+
+    return TRUE;
+
+out_complete:
+    DRI2WaitMSCComplete(client, draw, target_msc, 0, 0);
+    return TRUE;
+}
+
+/*
+ * ScheduleSwap is responsible for requesting a DRM vblank event for the
+ * appropriate frame.
+ *
+ * In the case of a blit (e.g. for a windowed swap) or buffer exchange,
+ * the vblank requested can simply be the last queued swap frame + the swap
+ * interval for the drawable.
+ *
+ * In the case of a page flip, we request an event for the last queued swap
+ * frame + swap interval - 1, since we'll need to queue the flip for the frame
+ * immediately following the received event.
+ *
+ * The client will be blocked if it tries to perform further GL commands
+ * after queueing a swap, though in the Intel case after queueing a flip, the
+ * client is free to queue more commands; they'll block in the kernel if
+ * they access buffers busy with the flip.
+ *
+ * When the swap is complete, the driver should call into the server so it
+ * can send any swap complete events that have been requested.
+ */
+static int radeon_dri2_schedule_swap(ClientPtr client, DrawablePtr draw,
+                                     DRI2BufferPtr front, DRI2BufferPtr back,
+                                     CARD64 *target_msc, CARD64 divisor,
+                                     CARD64 remainder, DRI2SwapEventPtr func,
+                                     void *data)
+{
+    ScreenPtr screen = draw->pScreen;
+    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
+    RADEONInfoPtr info = RADEONPTR(scrn);
+    drmVBlank vbl;
+    int ret, crtc= radeon_dri2_drawable_crtc(draw), flip = 0;
+    DRI2FrameEventPtr swap_info;
+    enum DRI2FrameEventType swap_type = DRI2_SWAP;
+    CARD64 current_msc;
+    BoxRec box;
+    RegionRec region;
+
+    /* Truncate to match kernel interfaces; means occasional overflow
+     * misses, but that's generally not a big deal */
+    *target_msc &= 0xffffffff;
+    divisor &= 0xffffffff;
+    remainder &= 0xffffffff;
+
+    swap_info = calloc(1, sizeof(DRI2FrameEventRec));
+
+    /* Drawable not displayed... just complete the swap */
+    if (crtc == -1 || !swap_info)
+        goto blit_fallback;
+
+    swap_info->drawable_id = draw->id;
+    swap_info->client = client;
+    swap_info->event_complete = func;
+    swap_info->event_data = data;
+    swap_info->front = front;
+    swap_info->back = back;
+
+    /* Get current count */
+    vbl.request.type = DRM_VBLANK_RELATIVE;
+    if (crtc > 0)
+        vbl.request.type |= DRM_VBLANK_SECONDARY;
+    vbl.request.sequence = 0;
+    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+    if (ret) {
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                "first get vblank counter failed: %s\n",
+                strerror(errno));
+        goto blit_fallback;
+    }
+
+    current_msc = vbl.reply.sequence;
+    swap_info->type = swap_type;
+
+    /* Correct target_msc by 'flip' if swap_type == DRI2_FLIP.
+     * Do it early, so handling of different timing constraints
+     * for divisor, remainder and msc vs. target_msc works.
+     */
+    if (*target_msc > 0)
+        *target_msc -= flip;
+
+    /*
+     * If divisor is zero, or current_msc is smaller than target_msc
+     * we just need to make sure target_msc passes before initiating
+     * the swap.
+     */
+    if (divisor == 0 || current_msc < *target_msc) {
+        vbl.request.type =  DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
+        if (crtc > 0)
+            vbl.request.type |= DRM_VBLANK_SECONDARY;
+
+        /* If non-pageflipping, but blitting/exchanging, we need to use
+         * DRM_VBLANK_NEXTONMISS to avoid unreliable timestamping later
+         * on.
+         */
+        if (flip == 0)
+            vbl.request.type |= DRM_VBLANK_NEXTONMISS;
+        if (crtc > 0)
+            vbl.request.type |= DRM_VBLANK_SECONDARY;
+
+        /* If target_msc already reached or passed, set it to
+         * current_msc to ensure we return a reasonable value back
+         * to the caller. This makes swap_interval logic more robust.
+         */
+        if (current_msc >= *target_msc)
+            *target_msc = current_msc;
+
+        vbl.request.sequence = *target_msc;
+        vbl.request.signal = (unsigned long)swap_info;
+        ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+        if (ret) {
+            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                    "divisor 0 get vblank counter failed: %s\n",
+                    strerror(errno));
+            goto blit_fallback;
+        }
+
+        *target_msc = vbl.reply.sequence + flip;
+        swap_info->frame = *target_msc;
+
+        return TRUE;
+    }
+
+    /*
+     * If we get here, target_msc has already passed or we don't have one,
+     * and we need to queue an event that will satisfy the divisor/remainder
+     * equation.
+     */
+    vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
+    if (flip == 0)
+        vbl.request.type |= DRM_VBLANK_NEXTONMISS;
+    if (crtc > 0)
+        vbl.request.type |= DRM_VBLANK_SECONDARY;
+
+    vbl.request.sequence = current_msc - (current_msc % divisor) +
+        remainder;
+
+    /*
+     * If the calculated deadline vbl.request.sequence is smaller than
+     * or equal to current_msc, it means we've passed the last point
+     * when effective onset frame seq could satisfy
+     * seq % divisor == remainder, so we need to wait for the next time
+     * this will happen.
+
+     * This comparison takes the 1 frame swap delay in pageflipping mode
+     * into account, as well as a potential DRM_VBLANK_NEXTONMISS delay
+     * if we are blitting/exchanging instead of flipping.
+     */
+    if (vbl.request.sequence <= current_msc)
+        vbl.request.sequence += divisor;
+
+    /* Account for 1 frame extra pageflip delay if flip > 0 */
+    vbl.request.sequence -= flip;
+
+    vbl.request.signal = (unsigned long)swap_info;
+    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
+    if (ret) {
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                "final get vblank counter failed: %s\n",
+                strerror(errno));
+        goto blit_fallback;
+    }
+
+    /* Adjust returned value for 1 fame pageflip offset of flip > 0 */
+    *target_msc = vbl.reply.sequence + flip;
+    swap_info->frame = *target_msc;
+
+    return TRUE;
+
+blit_fallback:
+    box.x1 = 0;
+    box.y1 = 0;
+    box.x2 = draw->width;
+    box.y2 = draw->height;
+    REGION_INIT(pScreen, &region, &box, 0);
+
+    radeon_dri2_copy_region(draw, &region, front, back);
+
+    DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
+    if (swap_info)
+        free(swap_info);
+    *target_msc = 0; /* offscreen, so zero out target vblank count */
+    return TRUE;
+}
+
+#endif /* DRI2INFOREC_VERSION >= 4 */
+
+
 Bool
 radeon_dri2_screen_init(ScreenPtr pScreen)
 {
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr info = RADEONPTR(pScrn);
     DRI2InfoRec dri2_info = { 0 };
+#if DRI2INFOREC_VERSION >= 4
+    const char *driverNames[1];
+#endif
 
     if (!info->useEXA) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DRI2 requires EXA\n");
@@ -359,6 +797,21 @@ radeon_dri2_screen_init(ScreenPtr pScreen)
     dri2_info.DestroyBuffer = radeon_dri2_destroy_buffer;
 #endif
     dri2_info.CopyRegion = radeon_dri2_copy_region;
+
+#if DRI2INFOREC_VERSION >= 4
+    if (info->dri->pKernelDRMVersion->version_minor >= 4) {
+        dri2_info.version = 4;
+        dri2_info.ScheduleSwap = radeon_dri2_schedule_swap;
+        dri2_info.GetMSC = radeon_dri2_get_msc;
+        dri2_info.ScheduleWaitMSC = radeon_dri2_schedule_wait_msc;
+        dri2_info.numDrivers = 1;
+        dri2_info.driverNames = driverNames;
+        driverNames[0] = dri2_info.driverName;
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "You need a newer kernel for sync extension\n");
+    }
+#endif
+
     info->dri2.enabled = DRI2ScreenInit(pScreen, &dri2_info);
     return info->dri2.enabled;
 }
diff --git a/src/radeon_dri2.h b/src/radeon_dri2.h
index c391e73..688530f 100644
--- a/src/radeon_dri2.h
+++ b/src/radeon_dri2.h
@@ -39,4 +39,10 @@ Bool radeon_dri2_screen_init(ScreenPtr pScreen);
 void radeon_dri2_close_screen(ScreenPtr pScreen);
 #endif
 
+int drmmode_get_crtc_id(xf86CrtcPtr crtc);
+xf86CrtcPtr radeon_covering_crtc(ScrnInfoPtr pScrn, BoxPtr box,
+                                 xf86CrtcPtr desired, BoxPtr crtc_box_ret);
+void radeon_dri2_frame_event_handler(unsigned int frame, unsigned int tv_sec,
+                                     unsigned int tv_usec, void *event_data);
+
 #endif
diff --git a/src/radeon_driver.c b/src/radeon_driver.c
index b627637..2b7be55 100644
--- a/src/radeon_driver.c
+++ b/src/radeon_driver.c
@@ -181,7 +181,6 @@ static const OptionInfoRec RADEONOptions[] = {
     { OPTION_RENDER_ACCEL,   "RenderAccel",      OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_SUBPIXEL_ORDER, "SubPixelOrder",    OPTV_ANYSTR,  {0}, FALSE },
 #endif
-    { OPTION_SHOWCACHE,      "ShowCache",        OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_CLOCK_GATING,   "ClockGating",      OPTV_BOOLEAN, {0}, FALSE },
     { OPTION_VGA_ACCESS,     "VGAAccess",        OPTV_BOOLEAN, {0}, TRUE  },
     { OPTION_REVERSE_DDC,    "ReverseDDC",       OPTV_BOOLEAN, {0}, FALSE },
@@ -239,7 +238,7 @@ radeonShadowWindow(ScreenPtr screen, CARD32 row, CARD32 offset, int mode,
     stride = (pScrn->displayWidth * pScrn->bitsPerPixel) / 8;
     *size = stride;
 
-    return ((uint8_t *)info->FB + row * stride + offset);
+    return ((uint8_t *)info->FB + pScrn->fbOffset + row * stride + offset);
 }
 static Bool
 RADEONCreateScreenResources (ScreenPtr pScreen)
@@ -369,32 +368,32 @@ void RADEONFreeRec(ScrnInfoPtr pScrn)
     info = RADEONPTR(pScrn);
 
     if (info->cp) {
-	xfree(info->cp);
+	free(info->cp);
 	info->cp = NULL;
     }
 
     if (info->dri) {
-	xfree(info->dri);
+	free(info->dri);
 	info->dri = NULL;
     }
 
     if (info->accel_state) {
-	xfree(info->accel_state);
+	free(info->accel_state);
 	info->accel_state = NULL;
     }
 
     for (i = 0; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
 	if (info->encoders[i]) {
 	    if (info->encoders[i]->dev_priv) {
-		xfree(info->encoders[i]->dev_priv);
+		free(info->encoders[i]->dev_priv);
 		info->encoders[i]->dev_priv = NULL;
 	    }
-	    xfree(info->encoders[i]);
+	    free(info->encoders[i]);
 	    info->encoders[i]= NULL;
 	}
     }
 
-    xfree(pScrn->driverPrivate);
+    free(pScrn->driverPrivate);
     pScrn->driverPrivate = NULL;
 }
 
@@ -403,10 +402,14 @@ void RADEONFreeRec(ScrnInfoPtr pScrn)
  */
 static Bool RADEONMapMMIO(ScrnInfoPtr pScrn)
 {
+#ifdef XSERVER_LIBPCIACCESS
+    int err;
+#endif
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
 
     if (pRADEONEnt->MMIO) {
+        pRADEONEnt->MMIO_cnt++;
         info->MMIO = pRADEONEnt->MMIO;
         return TRUE;
     }
@@ -419,15 +422,15 @@ static Bool RADEONMapMMIO(ScrnInfoPtr pScrn)
 			       info->MMIOAddr,
 			       info->MMIOSize);
 
-    if (!info->MMIO) return FALSE;
+    if (!info->MMIO)
+        return FALSE;
 #else
 
-    void** result = (void**)&info->MMIO;
-    int err = pci_device_map_range(info->PciInfo,
+    err = pci_device_map_range(info->PciInfo,
 				   info->MMIOAddr,
 				   info->MMIOSize,
 				   PCI_DEV_MAP_FLAG_WRITABLE,
-				   result);
+				   &info->MMIO);
 
     if (err) {
 	xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
@@ -439,6 +442,7 @@ static Bool RADEONMapMMIO(ScrnInfoPtr pScrn)
 #endif
 
     pRADEONEnt->MMIO = info->MMIO;
+    pRADEONEnt->MMIO_cnt = 1;
     return TRUE;
 }
 
@@ -450,8 +454,8 @@ static Bool RADEONUnmapMMIO(ScrnInfoPtr pScrn)
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
 
-    if (info->IsPrimary || info->IsSecondary) {
-      /* never unmap on zaphod */
+    /* refcount for zaphod */
+    if (--pRADEONEnt->MMIO_cnt != 0) {
       info->MMIO = NULL;
       return TRUE;
     }
@@ -474,6 +478,13 @@ static Bool RADEONMapFB(ScrnInfoPtr pScrn)
     int err;
 #endif
     RADEONInfoPtr  info = RADEONPTR(pScrn);
+    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
+
+    if (pRADEONEnt->FB) {
+        pRADEONEnt->FB_cnt++;
+        info->FB = pRADEONEnt->FB;
+        return TRUE;
+    }
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "Map: 0x%016llx, 0x%08lx\n", info->LinearAddr, info->FbMapSize);
@@ -506,6 +517,8 @@ static Bool RADEONMapFB(ScrnInfoPtr pScrn)
 
 #endif
 
+    pRADEONEnt->FB = info->FB;
+    pRADEONEnt->FB_cnt = 1;
     return TRUE;
 }
 
@@ -513,6 +526,13 @@ static Bool RADEONMapFB(ScrnInfoPtr pScrn)
 static Bool RADEONUnmapFB(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
+    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
+
+    /* refcount for zaphod */
+    if (--pRADEONEnt->FB_cnt != 0) {
+      info->FB = NULL;
+      return TRUE;
+    }
 
 #ifndef XSERVER_LIBPCIACCESS
     xf86UnMapVidMem(pScrn->scrnIndex, info->FB, info->FbMapSize);
@@ -520,6 +540,7 @@ static Bool RADEONUnmapFB(ScrnInfoPtr pScrn)
     pci_device_unmap_range(info->PciInfo, info->FB, info->FbMapSize);
 #endif
 
+    pRADEONEnt->FB = NULL;
     info->FB = NULL;
     return TRUE;
 }
@@ -1767,23 +1788,21 @@ static Bool RADEONPreInitVRAM(ScrnInfoPtr pScrn)
     xf86DrvMsg(pScrn->scrnIndex, from,
 	       "Mapped VideoRAM: %d kByte (%d bit %s SDRAM)\n", pScrn->videoRam, info->RamWidth, info->IsDDR?"DDR":"SDR");
 
+    /* Do this before we truncate since we only map fb once */
+    info->FbMapSize  = (pScrn->videoRam & ~1023) * 1024;
+
     if (info->IsPrimary) {
 	pScrn->videoRam /= 2;
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Using %dk of videoram for primary head\n",
 		   pScrn->videoRam);
-    }
-    
-    if (info->IsSecondary) {
+    } else if (info->IsSecondary) {
 	pScrn->videoRam /= 2;
-	info->LinearAddr += pScrn->videoRam * 1024;
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Using %dk of videoram for secondary head\n",
 		   pScrn->videoRam);
     }
-
     pScrn->videoRam  &= ~1023;
-    info->FbMapSize  = pScrn->videoRam * 1024;
 
     /* if the card is PCI Express reserve the last 32k for the gart table */
 #ifdef XF86DRI
@@ -2070,11 +2089,6 @@ static Bool RADEONPreInitChipType(ScrnInfoPtr pScrn)
 	}
     }
 #endif
-    xf86GetOptValBool(info->Options, OPTION_SHOWCACHE, &info->showCache);
-    if (info->showCache)
-	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-		   "Option ShowCache enabled\n");
-
 #ifdef RENDER
     info->RenderAccel = xf86ReturnOptValBool(info->Options, OPTION_RENDER_ACCEL,
 					     info->Chipset != PCI_CHIP_RN50_515E &&
@@ -2140,9 +2154,11 @@ static Bool RADEONPreInitAccel(ScrnInfoPtr pScrn)
 #if defined(USE_EXA) && defined(USE_XAA)
     char *optstr;
 #endif
+#ifdef XF86DRI /* zaphod FbMapSize is wrong, but no dri then */
     int maxy = info->FbMapSize / (pScrn->displayWidth * info->CurrentLayout.pixel_bytes);
+#endif
 
-    if (!(info->accel_state = xcalloc(1, sizeof(struct radeon_accel_state)))) {
+    if (!(info->accel_state = calloc(1, sizeof(struct radeon_accel_state)))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to allocate accel_state rec!\n");
 	return FALSE;
     }
@@ -2313,12 +2329,12 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
     info->directRenderingEnabled = FALSE;
     info->directRenderingInited = FALSE;
 
-    if (!(info->dri = xcalloc(1, sizeof(struct radeon_dri)))) {
+    if (!(info->dri = calloc(1, sizeof(struct radeon_dri)))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unable to allocate dri rec!\n");
 	return FALSE;
     }
 
-    if (!(info->cp = xcalloc(1, sizeof(struct radeon_cp)))) {
+    if (!(info->cp = calloc(1, sizeof(struct radeon_cp)))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unable to allocate cp rec!\n");
 	return FALSE;
     }
@@ -2701,7 +2717,11 @@ static Bool RADEONPreInitXv(ScrnInfoPtr pScrn)
 	switch(info->ChipFamily){
 	case CHIP_FAMILY_R200:
 	case CHIP_FAMILY_R300:
+	case CHIP_FAMILY_R350:
 	case CHIP_FAMILY_RV350:
+	case CHIP_FAMILY_RV380:
+	case CHIP_FAMILY_R420:
+	case CHIP_FAMILY_RV410:
 		info->overlay_scaler_buffer_width = 1920;
 		break;
 	default:
@@ -3065,7 +3085,7 @@ Bool RADEONPreInit(ScrnInfoPtr pScrn, int flags)
 				/* We can't do this until we have a
 				   pScrn->display. */
     xf86CollectOptions(pScrn, NULL);
-    if (!(info->Options = xalloc(sizeof(RADEONOptions))))
+    if (!(info->Options = malloc(sizeof(RADEONOptions))))
 	goto fail;
 
     memcpy(info->Options, RADEONOptions, sizeof(RADEONOptions));
@@ -3229,7 +3249,7 @@ fail:
 				/* Pre-init failed. */
 				/* Free the video bios (if applicable) */
     if (info->VBIOS) {
-	xfree(info->VBIOS);
+	free(info->VBIOS);
 	info->VBIOS = NULL;
     }
 
@@ -3426,7 +3446,8 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
     pScrn->fbOffset    = info->dri->frontOffset;
 #endif
 
-    if (info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
+    if (info->IsSecondary)
+        pScrn->fbOffset = pScrn->videoRam * 1024;
 #ifdef XF86DRI
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
 		   "RADEONScreenInit %lx %ld %d\n",
@@ -3649,9 +3670,9 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 		   "Initializing fb layer\n");
 
     if (info->r600_shadow_fb) {
-	info->fb_shadow = xcalloc(1,
-				  pScrn->displayWidth * pScrn->virtualY *
-				  ((pScrn->bitsPerPixel + 7) >> 3));
+	info->fb_shadow = calloc(1,
+				 pScrn->displayWidth * pScrn->virtualY *
+				 ((pScrn->bitsPerPixel + 7) >> 3));
 	if (info->fb_shadow == NULL) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                        "Failed to allocate shadow framebuffer\n");
@@ -3667,7 +3688,7 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 
     if (info->r600_shadow_fb == FALSE) {
 	/* Init fb layer */
-	if (!fbScreenInit(pScreen, info->FB,
+	if (!fbScreenInit(pScreen, info->FB + pScrn->fbOffset,
 			  pScrn->virtualX, pScrn->virtualY,
 			  pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
 			  pScrn->bitsPerPixel))
@@ -5626,15 +5647,6 @@ void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, Bool crtc2)
 		   "RADEONDoAdjustFrame(%d,%d,%d)\n", x, y, clone);
 #endif
 
-    if (info->showCache && y) {
-	        int lastline = info->FbMapSize /
-		    ((pScrn->displayWidth * pScrn->bitsPerPixel) / 8);
-
-		lastline -= pScrn->currentMode->VDisplay;
-		y += (pScrn->virtualY - 1) * (y / 3 + 1);
-		if (y > lastline) y = lastline;
-    }
-
     Base = pScrn->fbOffset;
 
   /* note we cannot really simply use the info->ModeReg.crtc_offset_cntl value, since the
@@ -6006,7 +6018,7 @@ static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
 #ifdef USE_EXA
     if (info->accel_state->exa) {
 	exaDriverFini(pScreen);
-	xfree(info->accel_state->exa);
+	free(info->accel_state->exa);
 	info->accel_state->exa = NULL;
     }
 #endif /* USE_EXA */
@@ -6017,7 +6029,7 @@ static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
 	info->accel_state->accel = NULL;
 
 	if (info->accel_state->scratch_save)
-	    xfree(info->accel_state->scratch_save);
+	    free(info->accel_state->scratch_save);
 	info->accel_state->scratch_save = NULL;
     }
 #endif /* USE_XAA */
diff --git a/src/radeon_exa.c b/src/radeon_exa.c
index 217a0fe..d7fba65 100644
--- a/src/radeon_exa.c
+++ b/src/radeon_exa.c
@@ -372,7 +372,7 @@ void *RADEONEXACreatePixmap(ScreenPtr pScreen, int size, int align)
     }
 #endif
 	    
-    new_priv = xcalloc(1, sizeof(struct radeon_exa_pixmap_priv));
+    new_priv = calloc(1, sizeof(struct radeon_exa_pixmap_priv));
     if (!new_priv)
 	return NULL;
 
@@ -382,7 +382,7 @@ void *RADEONEXACreatePixmap(ScreenPtr pScreen, int size, int align)
     new_priv->bo = radeon_bo_open(info->bufmgr, 0, size, align,
 				  RADEON_GEM_DOMAIN_VRAM, 0);
     if (!new_priv->bo) {
-	xfree(new_priv);
+	free(new_priv);
 	ErrorF("Failed to alloc memory\n");
 	return NULL;
     }
@@ -391,6 +391,37 @@ void *RADEONEXACreatePixmap(ScreenPtr pScreen, int size, int align)
 
 }
 
+static const unsigned MicroBlockTable[5][3][2] = {
+    /*linear  tiled   square-tiled */
+    {{32, 1}, {8, 4}, {0, 0}}, /*   8 bits per pixel */
+    {{16, 1}, {8, 2}, {4, 4}}, /*  16 bits per pixel */
+    {{ 8, 1}, {4, 2}, {0, 0}}, /*  32 bits per pixel */
+    {{ 4, 1}, {0, 0}, {2, 2}}, /*  64 bits per pixel */
+    {{ 2, 1}, {0, 0}, {0, 0}}  /* 128 bits per pixel */
+};
+
+/* Return true if macrotiling can be enabled */
+static Bool RADEONMacroSwitch(int width, int height, int bpp,
+                              uint32_t flags, Bool rv350_mode)
+{
+    unsigned tilew, tileh, microtiled, logbpp;
+
+    logbpp = RADEONLog2(bpp / 8);
+    if (logbpp > 4)
+        return 0;
+
+    microtiled = !!(flags & RADEON_TILING_MICRO);
+    tilew = MicroBlockTable[logbpp][microtiled][0] * 8;
+    tileh = MicroBlockTable[logbpp][microtiled][1] * 8;
+
+    /* See TX_FILTER1_n.MACRO_SWITCH. */
+    if (rv350_mode) {
+        return width >= tilew && height >= tileh;
+    } else {
+        return width > tilew && height > tileh;
+    }
+}
+
 void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
 			     int depth, int usage_hint, int bitsPerPixel,
 			     int *new_pitch)
@@ -420,6 +451,16 @@ void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
 	}
     }
 
+    /* Small pixmaps must not be macrotiled on R300, hw cannot sample them
+     * correctly because samplers automatically switch to macrolinear. */
+    if (info->ChipFamily >= CHIP_FAMILY_R300 &&
+        info->ChipFamily <= CHIP_FAMILY_RS740 &&
+        (tiling & RADEON_TILING_MACRO) &&
+        !RADEONMacroSwitch(width, height, bitsPerPixel, tiling,
+                           info->ChipFamily >= CHIP_FAMILY_RV350)) {
+        tiling &= ~RADEON_TILING_MACRO;
+    }
+
     if (tiling) {
 	height = RADEON_ALIGN(height, 16);
 	pixmap_align = 256;
@@ -430,7 +471,7 @@ void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
     padded_width = RADEON_ALIGN(padded_width, pixmap_align);
     size = height * padded_width;
 
-    new_priv = xcalloc(1, sizeof(struct radeon_exa_pixmap_priv));
+    new_priv = calloc(1, sizeof(struct radeon_exa_pixmap_priv));
     if (!new_priv)
 	return NULL;
 
@@ -442,7 +483,7 @@ void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
     new_priv->bo = radeon_bo_open(info->bufmgr, 0, size, 0,
 				  RADEON_GEM_DOMAIN_VRAM, 0);
     if (!new_priv->bo) {
-	xfree(new_priv);
+	free(new_priv);
 	ErrorF("Failed to alloc memory\n");
 	return NULL;
     }
@@ -462,7 +503,7 @@ void RADEONEXADestroyPixmap(ScreenPtr pScreen, void *driverPriv)
 
     if (driver_priv->bo)
 	radeon_bo_unref(driver_priv->bo);
-    xfree(driverPriv);
+    free(driverPriv);
 }
 
 struct radeon_bo *radeon_get_pixmap_bo(PixmapPtr pPix)
diff --git a/src/radeon_exa_funcs.c b/src/radeon_exa_funcs.c
index cdc0edb..2df6ccb 100644
--- a/src/radeon_exa_funcs.c
+++ b/src/radeon_exa_funcs.c
@@ -904,7 +904,7 @@ Bool FUNC_NAME(RADEONDrawInit)(ScreenPtr pScreen)
     RADEONEngineInit(pScrn);
 
     if (!exaDriverInit(pScreen, info->accel_state->exa)) {
-	xfree(info->accel_state->exa);
+	free(info->accel_state->exa);
 	return FALSE;
     }
     exaMarkSync(pScreen);
diff --git a/src/radeon_exa_render.c b/src/radeon_exa_render.c
index e68faff..cf773b0 100644
--- a/src/radeon_exa_render.c
+++ b/src/radeon_exa_render.c
@@ -332,8 +332,12 @@ static Bool RADEONSetupSourceTile(PicturePtr pPict,
 
 /* R100-specific code */
 
-static Bool R100CheckCompositeTexture(PicturePtr pPict, int unit)
+static Bool R100CheckCompositeTexture(PicturePtr pPict,
+				      PicturePtr pDstPict,
+				      int op,
+				      int unit)
 {
+    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
     int w = pPict->pDrawable->width;
     int h = pPict->pDrawable->height;
     int i;
@@ -362,6 +366,19 @@ static Bool R100CheckCompositeTexture(PicturePtr pPict, int unit)
 	RADEON_FALLBACK(("Unsupported filter 0x%x\n", pPict->filter));
     }
 
+    /* for REPEAT_NONE, Render semantics are that sampling outside the source
+     * picture results in alpha=0 pixels. We can implement this with a border color
+     * *if* our source texture has an alpha channel, otherwise we need to fall
+     * back. If we're not transformed then we hope that upper layers have clipped
+     * rendering to the bounds of the source drawable, in which case it doesn't
+     * matter. I have not, however, verified that the X server always does such
+     * clipping.
+     */
+    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
+	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
+	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
+    }
+
     return TRUE;
 }
 
@@ -551,11 +568,11 @@ static Bool R100CheckComposite(int op, PicturePtr pSrcPicture,
 	    }
 	}
 
-	if (!R100CheckCompositeTexture(pMaskPicture, 1))
+	if (!R100CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1))
 	    return FALSE;
     }
 
-    if (!R100CheckCompositeTexture(pSrcPicture, 0))
+    if (!R100CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0))
 	return FALSE;
 
     if (!RADEONGetDestFormat(pDstPicture, &tmp1))
@@ -723,8 +740,12 @@ static Bool FUNC_NAME(R100PrepareComposite)(int op,
 
 #ifdef ONLY_ONCE
 
-static Bool R200CheckCompositeTexture(PicturePtr pPict, int unit)
+static Bool R200CheckCompositeTexture(PicturePtr pPict,
+				      PicturePtr pDstPict,
+				      int op,
+				      int unit)
 {
+    unsigned int repeatType = pPict->repeat ? pPict->repeatType : RepeatNone;
     int w = pPict->pDrawable->width;
     int h = pPict->pDrawable->height;
     int i;
@@ -752,6 +773,19 @@ static Bool R200CheckCompositeTexture(PicturePtr pPict, int unit)
 	pPict->filter != PictFilterBilinear)
 	RADEON_FALLBACK(("Unsupported filter 0x%x\n", pPict->filter));
 
+    /* for REPEAT_NONE, Render semantics are that sampling outside the source
+     * picture results in alpha=0 pixels. We can implement this with a border color
+     * *if* our source texture has an alpha channel, otherwise we need to fall
+     * back. If we're not transformed then we hope that upper layers have clipped
+     * rendering to the bounds of the source drawable, in which case it doesn't
+     * matter. I have not, however, verified that the X server always does such
+     * clipping.
+     */
+    if (pPict->transform != 0 && repeatType == RepeatNone && PICT_FORMAT_A(pPict->format) == 0) {
+	if (!(((op == PictOpSrc) || (op == PictOpClear)) && (PICT_FORMAT_A(pDstPict->format) == 0)))
+	    RADEON_FALLBACK(("REPEAT_NONE unsupported for transformed xRGB source\n"));
+    }
+
     return TRUE;
 }
 
@@ -932,11 +966,11 @@ static Bool R200CheckComposite(int op, PicturePtr pSrcPicture, PicturePtr pMaskP
 	    }
 	}
 
-	if (!R200CheckCompositeTexture(pMaskPicture, 1))
+	if (!R200CheckCompositeTexture(pMaskPicture, pDstPicture, op, 1))
 	    return FALSE;
     }
 
-    if (!R200CheckCompositeTexture(pSrcPicture, 0))
+    if (!R200CheckCompositeTexture(pSrcPicture, pDstPicture, op, 0))
 	return FALSE;
 
     if (!RADEONGetDestFormat(pDstPicture, &tmp1))
diff --git a/src/radeon_kms.c b/src/radeon_kms.c
index 15e5e3f..c0d2ae6 100644
--- a/src/radeon_kms.c
+++ b/src/radeon_kms.c
@@ -159,6 +159,11 @@ static Bool RADEONCreateScreenResources_KMS(ScreenPtr pScreen)
 	return FALSE;
     pScreen->CreateScreenResources = RADEONCreateScreenResources_KMS;
 
+    if (!drmmode_set_desired_modes(pScrn, &info->drmmode))
+	return FALSE;
+
+    drmmode_uevent_init(pScrn, &info->drmmode);
+
     if (info->r600_shadow_fb) {
 	pixmap = pScreen->GetScreenPixmap(pScreen);
 
@@ -222,12 +227,13 @@ static Bool RADEONPreInitAccel_KMS(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
-    if (!(info->accel_state = xcalloc(1, sizeof(struct radeon_accel_state)))) {
+    if (!(info->accel_state = calloc(1, sizeof(struct radeon_accel_state)))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to allocate accel_state rec!\n");
 	return FALSE;
     }
 
     if (xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE) ||
+	(info->ChipFamily >= CHIP_FAMILY_CEDAR) ||
 	(!RADEONIsAccelWorking(pScrn))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "GPU accel disabled or not working, using shadowfb for KMS\n");
@@ -350,12 +356,12 @@ static Bool RADEONPreInitChipType_KMS(ScrnInfoPtr pScrn)
 static Bool radeon_alloc_dri(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info   = RADEONPTR(pScrn);
-    if (!(info->dri = xcalloc(1, sizeof(struct radeon_dri)))) {
+    if (!(info->dri = calloc(1, sizeof(struct radeon_dri)))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unable to allocate dri rec!\n");
 	return FALSE;
     }
 
-    if (!(info->cp = xcalloc(1, sizeof(struct radeon_cp)))) {
+    if (!(info->cp = calloc(1, sizeof(struct radeon_cp)))) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unable to allocate cp rec!\n");
 	return FALSE;
     }
@@ -388,10 +394,10 @@ static Bool radeon_open_drm_master(ScrnInfoPtr pScrn)
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[drm] Failed to open DRM device for %s: %s\n",
 		   busid, strerror(errno));
-	xfree(busid);
+	free(busid);
 	return FALSE;
     }
-    xfree(busid);
+    free(busid);
 
     /* Check that what we opened was a master or a master-capable FD,
      * by setting the version of the interface we'll use to talk to it.
@@ -424,6 +430,7 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
     RADEONEntPtr pRADEONEnt;
     DevUnion* pPriv;
     Gamma  zeros = { 0.0, 0.0, 0.0 };
+    Bool colorTilingDefault;
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "RADEONPreInit_KMS\n");
@@ -465,7 +472,7 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
 	goto fail;
 
     xf86CollectOptions(pScrn, NULL);
-    if (!(info->Options = xalloc(sizeof(RADEONOptions_KMS))))
+    if (!(info->Options = malloc(sizeof(RADEONOptions_KMS))))
 	goto fail;
 
     memcpy(info->Options, RADEONOptions_KMS, sizeof(RADEONOptions_KMS));
@@ -480,8 +487,11 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
     if (!radeon_alloc_dri(pScrn))
 	return FALSE;
 
+    colorTilingDefault = info->ChipFamily >= CHIP_FAMILY_R300 &&
+                         info->ChipFamily <= CHIP_FAMILY_RS740;
+
     info->allowColorTiling = xf86ReturnOptValBool(info->Options,
-                                        OPTION_COLOR_TILING, FALSE);
+                                        OPTION_COLOR_TILING, colorTilingDefault);
     if (info->ChipFamily >= CHIP_FAMILY_R600) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Color tiling is not yet supported on R600/R700\n");
 	    info->allowColorTiling = FALSE;
@@ -493,10 +503,6 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Kernel modesetting setup failed\n");
 	goto fail;
     }
-    if (drmmode_pre_init(pScrn, &info->drmmode, pScrn->bitsPerPixel / 8) == FALSE) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Kernel modesetting setup failed\n");
-	goto fail;
-    }
 
     info->dri2.enabled = FALSE;
     info->dri->pKernelDRMVersion = drmGetVersion(info->dri->drmFD);
@@ -506,6 +512,36 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
 	goto fail;
     }
 
+    if (drmmode_pre_init(pScrn, &info->drmmode, pScrn->bitsPerPixel / 8) == FALSE) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Kernel modesetting setup failed\n");
+	goto fail;
+    }
+
+    if (info->drmmode.mode_res->count_crtcs == 1)
+        pRADEONEnt->HasCRTC2 = FALSE;
+    else
+        pRADEONEnt->HasCRTC2 = TRUE;
+
+
+    /* fix up cloning on rn50 cards
+     * since they only have one crtc sometimes the xserver doesn't assign
+     * a crtc to one of the outputs even though both outputs have common modes
+     * which results in only one monitor being enabled.  Assign a crtc here so
+     * that both outputs light up.
+     */
+    if (info->ChipFamily == CHIP_FAMILY_RV100 && !pRADEONEnt->HasCRTC2) {
+	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
+	int i;
+
+	for (i = 0; i < xf86_config->num_output; i++) {
+	    xf86OutputPtr output = xf86_config->output[i];
+
+	    /* XXX: double check crtc mode */
+	    if ((output->probed_modes != NULL) && (output->crtc == NULL))
+		output->crtc = xf86_config->crtc[0];
+	}
+    }
+
     {
 	struct drm_radeon_gem_info mminfo;
 
@@ -601,12 +637,13 @@ static Bool RADEONCloseScreen_KMS(int scrnIndex, ScreenPtr pScreen)
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "RADEONCloseScreen\n");
 
+    drmmode_uevent_fini(pScrn, &info->drmmode);
     if (info->cs)
       radeon_cs_flush_indirect(pScrn);
 
     if (info->accel_state->exa) {
 	exaDriverFini(pScreen);
-	xfree(info->accel_state->exa);
+	free(info->accel_state->exa);
 	info->accel_state->exa = NULL;
     }
 
@@ -704,9 +741,9 @@ Bool RADEONScreenInit_KMS(int scrnIndex, ScreenPtr pScreen,
     front_ptr = info->front_bo->ptr;
 
     if (info->r600_shadow_fb) {
-	info->fb_shadow = xcalloc(1,
-				  pScrn->displayWidth * pScrn->virtualY *
-				  ((pScrn->bitsPerPixel + 7) >> 3));
+	info->fb_shadow = calloc(1,
+				 pScrn->displayWidth * pScrn->virtualY *
+				 ((pScrn->bitsPerPixel + 7) >> 3));
 	if (info->fb_shadow == NULL) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                        "Failed to allocate shadow framebuffer\n");
@@ -833,9 +870,6 @@ Bool RADEONScreenInit_KMS(int scrnIndex, ScreenPtr pScreen,
     }
     pScrn->pScreen = pScreen;
 
-    if (!drmmode_set_desired_modes(pScrn, &info->drmmode))
-	return FALSE;
-
     /* Provide SaveScreen & wrap BlockHandler and CloseScreen */
     /* Wrap CloseScreen */
     info->CloseScreen    = pScreen->CloseScreen;
@@ -975,7 +1009,7 @@ static Bool radeon_setup_kernel_mem(ScreenPtr pScreen)
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
 		radeon_bo_set_tiling(info->cursor_bo[c], RADEON_TILING_SWAP_32BIT |
-				     RADEON_TILING_SURFACE, stride);
+				     RADEON_TILING_SURFACE, CURSOR_WIDTH);
 #endif
 
                 if (radeon_bo_map(info->cursor_bo[c], 1)) {
diff --git a/src/radeon_output.c b/src/radeon_output.c
index 3a0d1e9..172b871 100644
--- a/src/radeon_output.c
+++ b/src/radeon_output.c
@@ -418,7 +418,7 @@ radeon_ddc_connected(xf86OutputPtr output)
 	    if (!xf86ReturnOptValBool(info->Options, OPTION_IGNORE_EDID, FALSE))
 		xf86OutputSetEDID(output, MonInfo);
 	} else
-	    xfree(MonInfo);
+	    free(MonInfo);
     } else
 	MonType = MT_NONE;
 
@@ -1295,7 +1295,7 @@ static void
 radeon_destroy (xf86OutputPtr output)
 {
     if (output->driver_private)
-        xfree(output->driver_private);
+        free(output->driver_private);
 }
 
 static void
diff --git a/src/radeon_pci_chipset_gen.h b/src/radeon_pci_chipset_gen.h
index 8afa10d..c1ead9c 100644
--- a/src/radeon_pci_chipset_gen.h
+++ b/src/radeon_pci_chipset_gen.h
@@ -4,6 +4,7 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV380_3151, PCI_CHIP_RV380_3151, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3152, PCI_CHIP_RV380_3152, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3154, PCI_CHIP_RV380_3154, RES_SHARED_VGA },
+ { PCI_CHIP_RV380_3155, PCI_CHIP_RV380_3155, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3E50, PCI_CHIP_RV380_3E50, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3E54, PCI_CHIP_RV380_3E54, RES_SHARED_VGA },
  { PCI_CHIP_RS100_4136, PCI_CHIP_RS100_4136, RES_SHARED_VGA },
@@ -268,6 +269,7 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV770_9456, PCI_CHIP_RV770_9456, RES_SHARED_VGA },
  { PCI_CHIP_RV770_945A, PCI_CHIP_RV770_945A, RES_SHARED_VGA },
  { PCI_CHIP_RV770_945B, PCI_CHIP_RV770_945B, RES_SHARED_VGA },
+ { PCI_CHIP_RV770_945E, PCI_CHIP_RV770_945E, RES_SHARED_VGA },
  { PCI_CHIP_RV790_9460, PCI_CHIP_RV790_9460, RES_SHARED_VGA },
  { PCI_CHIP_RV790_9462, PCI_CHIP_RV790_9462, RES_SHARED_VGA },
  { PCI_CHIP_RV770_946A, PCI_CHIP_RV770_946A, RES_SHARED_VGA },
@@ -278,6 +280,7 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV730_9487, PCI_CHIP_RV730_9487, RES_SHARED_VGA },
  { PCI_CHIP_RV730_9488, PCI_CHIP_RV730_9488, RES_SHARED_VGA },
  { PCI_CHIP_RV730_9489, PCI_CHIP_RV730_9489, RES_SHARED_VGA },
+ { PCI_CHIP_RV730_948A, PCI_CHIP_RV730_948A, RES_SHARED_VGA },
  { PCI_CHIP_RV730_948F, PCI_CHIP_RV730_948F, RES_SHARED_VGA },
  { PCI_CHIP_RV730_9490, PCI_CHIP_RV730_9490, RES_SHARED_VGA },
  { PCI_CHIP_RV730_9491, PCI_CHIP_RV730_9491, RES_SHARED_VGA },
@@ -321,12 +324,14 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV670_9519, PCI_CHIP_RV670_9519, RES_SHARED_VGA },
  { PCI_CHIP_RV710_9540, PCI_CHIP_RV710_9540, RES_SHARED_VGA },
  { PCI_CHIP_RV710_9541, PCI_CHIP_RV710_9541, RES_SHARED_VGA },
+ { PCI_CHIP_RV710_9542, PCI_CHIP_RV710_9542, RES_SHARED_VGA },
  { PCI_CHIP_RV710_954E, PCI_CHIP_RV710_954E, RES_SHARED_VGA },
  { PCI_CHIP_RV710_954F, PCI_CHIP_RV710_954F, RES_SHARED_VGA },
  { PCI_CHIP_RV710_9552, PCI_CHIP_RV710_9552, RES_SHARED_VGA },
  { PCI_CHIP_RV710_9553, PCI_CHIP_RV710_9553, RES_SHARED_VGA },
  { PCI_CHIP_RV710_9555, PCI_CHIP_RV710_9555, RES_SHARED_VGA },
  { PCI_CHIP_RV710_9557, PCI_CHIP_RV710_9557, RES_SHARED_VGA },
+ { PCI_CHIP_RV710_955F, PCI_CHIP_RV710_955F, RES_SHARED_VGA },
  { PCI_CHIP_RV630_9580, PCI_CHIP_RV630_9580, RES_SHARED_VGA },
  { PCI_CHIP_RV630_9581, PCI_CHIP_RV630_9581, RES_SHARED_VGA },
  { PCI_CHIP_RV630_9583, PCI_CHIP_RV630_9583, RES_SHARED_VGA },
@@ -340,7 +345,6 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV630_958D, PCI_CHIP_RV630_958D, RES_SHARED_VGA },
  { PCI_CHIP_RV630_958E, PCI_CHIP_RV630_958E, RES_SHARED_VGA },
  { PCI_CHIP_RV630_958F, PCI_CHIP_RV630_958F, RES_SHARED_VGA },
- { PCI_CHIP_RV710_9542, PCI_CHIP_RV710_9542, RES_SHARED_VGA },
  { PCI_CHIP_RV620_95C0, PCI_CHIP_RV620_95C0, RES_SHARED_VGA },
  { PCI_CHIP_RV620_95C2, PCI_CHIP_RV620_95C2, RES_SHARED_VGA },
  { PCI_CHIP_RV620_95C4, PCI_CHIP_RV620_95C4, RES_SHARED_VGA },
@@ -393,6 +397,7 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_JUNIPER_68BE, PCI_CHIP_JUNIPER_68BE, RES_SHARED_VGA },
  { PCI_CHIP_REDWOOD_68C0, PCI_CHIP_REDWOOD_68C0, RES_SHARED_VGA },
  { PCI_CHIP_REDWOOD_68C1, PCI_CHIP_REDWOOD_68C1, RES_SHARED_VGA },
+ { PCI_CHIP_REDWOOD_68C7, PCI_CHIP_REDWOOD_68C7, RES_SHARED_VGA },
  { PCI_CHIP_REDWOOD_68C8, PCI_CHIP_REDWOOD_68C8, RES_SHARED_VGA },
  { PCI_CHIP_REDWOOD_68C9, PCI_CHIP_REDWOOD_68C9, RES_SHARED_VGA },
  { PCI_CHIP_REDWOOD_68D8, PCI_CHIP_REDWOOD_68D8, RES_SHARED_VGA },
diff --git a/src/radeon_pci_device_match_gen.h b/src/radeon_pci_device_match_gen.h
index a09c969..709d8cc 100644
--- a/src/radeon_pci_device_match_gen.h
+++ b/src/radeon_pci_device_match_gen.h
@@ -4,6 +4,7 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3151, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3152, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3154, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV380_3155, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3E50, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3E54, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RS100_4136, 0 ),
@@ -268,6 +269,7 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV770_9456, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV770_945A, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV770_945B, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV770_945E, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV790_9460, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV790_9462, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV770_946A, 0 ),
@@ -278,6 +280,7 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV730_9487, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV730_9488, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV730_9489, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV730_948A, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV730_948F, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV730_9490, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV730_9491, 0 ),
@@ -321,12 +324,14 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV670_9519, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_9540, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_9541, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV710_9542, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_954E, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_954F, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_9552, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_9553, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_9555, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV710_9557, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV710_955F, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_9580, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_9581, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_9583, 0 ),
@@ -340,7 +345,6 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_958D, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_958E, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_958F, 0 ),
- ATI_DEVICE_MATCH( PCI_CHIP_RV710_9542, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV620_95C0, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV620_95C2, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV620_95C4, 0 ),
@@ -393,6 +397,7 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_JUNIPER_68BE, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_REDWOOD_68C0, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_REDWOOD_68C1, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_REDWOOD_68C7, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_REDWOOD_68C8, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_REDWOOD_68C9, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_REDWOOD_68D8, 0 ),
diff --git a/src/radeon_probe.c b/src/radeon_probe.c
index 1429835..4405d40 100644
--- a/src/radeon_probe.c
+++ b/src/radeon_probe.c
@@ -100,7 +100,7 @@ static Bool radeon_kernel_mode_enabled(ScrnInfoPtr pScrn, struct pci_device *pci
 
     busIdString = DRICreatePCIBusID(pci_dev);
     ret = drmCheckModesettingSupported(busIdString);
-    xfree(busIdString);
+    free(busIdString);
     if (ret) {
       xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
 		   "[KMS] drm report modesetting isn't supported.\n");
@@ -195,7 +195,7 @@ radeon_get_scrninfo(int entity_num, void *pci_dev)
         }
     }
 
-    xfree(pEnt);
+    free(pEnt);
 
     return TRUE;
 }
@@ -239,8 +239,8 @@ RADEONProbe(DriverPtr drv, int flags)
 	}
     }
 
-    xfree(usedChips);
-    xfree(devSections);
+    free(usedChips);
+    free(devSections);
 
     return foundScreen;
 }
diff --git a/src/radeon_probe.h b/src/radeon_probe.h
index dc02bdf..36c91b2 100644
--- a/src/radeon_probe.h
+++ b/src/radeon_probe.h
@@ -147,6 +147,11 @@ typedef struct
     Bool hw_capable;
 } RADEONI2CBusRec, *RADEONI2CBusPtr;
 
+enum radeon_pll_algo {
+    RADEON_PLL_OLD,
+    RADEON_PLL_NEW
+};
+
 typedef struct _RADEONCrtcPrivateRec {
     void *crtc_rotate_mem;
     void *cursor_mem;
@@ -164,6 +169,7 @@ typedef struct _RADEONCrtcPrivateRec {
     float vsc;
     float hsc;
     int pll_id;
+    enum radeon_pll_algo     pll_algo;
 } RADEONCrtcPrivateRec, *RADEONCrtcPrivatePtr;
 
 typedef struct _radeon_encoder {
@@ -638,6 +644,9 @@ typedef struct
     RADEONSaveRec     SavedReg;         /* Original (text) mode              */
 
     void              *MMIO;            /* Map of MMIO region                */
+    int               MMIO_cnt;         /* Map of FB region refcount         */
+    void              *FB;              /* Map of FB region                  */
+    int               FB_cnt;           /* Map of FB region refcount         */
     int fd;                             /* for sharing across zaphod heads   */
 } RADEONEntRec, *RADEONEntPtr;
 
diff --git a/src/radeon_textured_video.c b/src/radeon_textured_video.c
index 1490ccb..c19066b 100644
--- a/src/radeon_textured_video.c
+++ b/src/radeon_textured_video.c
@@ -769,8 +769,8 @@ RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
     int i;
     int num_texture_ports = 16;
 
-    adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
-		    (sizeof(RADEONPortPrivRec) + sizeof(DevUnion)));
+    adapt = calloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
+		   (sizeof(RADEONPortPrivRec) + sizeof(DevUnion)));
     if (adapt == NULL)
 	return NULL;
 
@@ -843,7 +843,7 @@ RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
 	pPriv->videoStatus = 0;
 	pPriv->currentBuffer = 0;
 	pPriv->doubleBuffer = 0;
-	pPriv->bicubic_state = BICUBIC_AUTO;
+	pPriv->bicubic_state = BICUBIC_OFF;
 	pPriv->vsync = TRUE;
 	pPriv->brightness = 0;
 	pPriv->contrast = 0;
diff --git a/src/radeon_textured_videofuncs.c b/src/radeon_textured_videofuncs.c
index f967331..138dfa3 100644
--- a/src/radeon_textured_videofuncs.c
+++ b/src/radeon_textured_videofuncs.c
@@ -87,8 +87,8 @@ do {								\
 
 #endif /* !ACCEL_CP */
 
-static void
-FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+static Bool
+FUNC_NAME(RADEONPrepareTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     PixmapPtr pPixmap = pPriv->pPixmap;
@@ -97,10 +97,9 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
     uint32_t txformat, txsize, txpitch, txoffset;
     uint32_t dst_pitch, dst_format;
     uint32_t colorpitch;
-    Bool isplanar = FALSE;
-    int dstxoff, dstyoff, pixel_shift, vtx_count;
-    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
-    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    int pixel_shift;
+    int scissor_w = MIN(pPixmap->drawable.width, 2047);
+    int scissor_h = MIN(pPixmap->drawable.height, 2047);
     ACCEL_PREAMBLE();
 
 #ifdef XF86DRM_MODE
@@ -119,14 +118,14 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	ret = radeon_cs_space_check(info->cs);
 	if (ret) {
 	    ErrorF("Not enough RAM to hw accel xv operation\n");
-	    return;
+	    return FALSE;
 	}
     }
 #endif
 
     pixel_shift = pPixmap->drawable.bitsPerPixel >> 4;
 
-    
+
 #ifdef USE_EXA
     if (info->useEXA) {
 	dst_pitch = exaGetPixmapPitch(pPixmap);
@@ -136,14 +135,6 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
         dst_pitch = pPixmap->devKind;
     }
 
-#ifdef COMPOSITE
-    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
-    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
-#else
-    dstxoff = 0;
-    dstyoff = 0;
-#endif
-
 #ifdef USE_EXA
     if (info->useEXA) {
 	RADEON_SWITCH_TO_3D();
@@ -176,13 +167,14 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	dst_format = RADEON_COLOR_FORMAT_ARGB8888;
 	break;
     default:
-	return;
+	return FALSE;
     }
 
     if (pPriv->id == FOURCC_I420 || pPriv->id == FOURCC_YV12) {
-	isplanar = TRUE;
+	pPriv->is_planar = TRUE;
 	txformat = RADEON_TXFORMAT_Y8;
     } else {
+	pPriv->is_planar = FALSE;
 	if (pPriv->id == FOURCC_UYVY)
 	    txformat = RADEON_TXFORMAT_YVYU422;
 	else
@@ -208,11 +200,11 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 
     FINISH_ACCEL();
 
-    if (isplanar) {
+    if (pPriv->is_planar) {
 	/* need 2 texcoord sets (even though they are identical) due
 	   to denormalization! hw apparently can't premultiply
 	   same coord set by different texture size */
-	vtx_count = 6;
+	pPriv->vtx_count = 6;
 
 	txsize = (((((pPriv->w + 1 ) >> 1) - 1) & 0x7ff) |
 		  (((((pPriv->h + 1 ) >> 1) - 1) & 0x7ff) << RADEON_TEX_VSIZE_SHIFT));
@@ -307,7 +299,7 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	OUT_ACCEL_REG(RADEON_PP_TEX_PITCH_2, txpitch);
 	FINISH_ACCEL();
     } else {
-	vtx_count = 4;
+	pPriv->vtx_count = 4;
 	BEGIN_ACCEL_RELOC(9, 1);
 
 	OUT_ACCEL_REG(RADEON_SE_VTX_FMT, (RADEON_SE_VTX_FMT_XY |
@@ -344,17 +336,12 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	FINISH_ACCEL();
     }
 
-    {
-      int scissor_w, scissor_h;
-      scissor_w = MIN(pPixmap->drawable.width, 2047);
-      scissor_h = MIN(pPixmap->drawable.height, 2047);
-
-      BEGIN_ACCEL(2);
-      OUT_ACCEL_REG(RADEON_RE_TOP_LEFT, 0);
-      OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, ((scissor_w << RADEON_RE_WIDTH_SHIFT) |
-					     (scissor_h << RADEON_RE_HEIGHT_SHIFT)));
-      FINISH_ACCEL();
-    }
+    BEGIN_ACCEL(2);
+    OUT_ACCEL_REG(RADEON_RE_TOP_LEFT, 0);
+    OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, ((scissor_w << RADEON_RE_WIDTH_SHIFT) |
+					   (scissor_h << RADEON_RE_HEIGHT_SHIFT)));
+    FINISH_ACCEL();
+
     if (pPriv->vsync) {
 	xf86CrtcPtr crtc;
 	if (pPriv->desired_crtc)
@@ -371,6 +358,31 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 					  pPriv->drw_y - crtc->y,
 					  (pPriv->drw_y - crtc->y) + pPriv->dst_h);
     }
+
+    return TRUE;
+}
+
+static void
+FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    PixmapPtr pPixmap = pPriv->pPixmap;
+    int dstxoff, dstyoff;
+    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
+    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    ACCEL_PREAMBLE();
+
+#ifdef COMPOSITE
+    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
+    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
+#else
+    dstxoff = 0;
+    dstyoff = 0;
+#endif
+
+    if (!FUNC_NAME(RADEONPrepareTexturedVideo)(pScrn, pPriv))
+	return;
+
     /*
      * Rendering of the actual polygon is done in two different
      * ways depending on chip generation:
@@ -390,12 +402,26 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
      *     the single triangle up to 2560/4021 pixels; above that we
      *     render as a quad.
      */
-
 #ifdef ACCEL_CP
-	BEGIN_RING(nBox * 3 * vtx_count + 5);
+    while (nBox) {
+	int draw_size = 3 * pPriv->vtx_count + 5;
+	int loop_boxes;
+
+	if (draw_size > radeon_cs_space_remaining(pScrn)) {
+	    if (info->cs)
+		radeon_cs_flush_indirect(pScrn);
+	    else
+		RADEONCPFlushIndirect(pScrn, 1);
+	    if (!FUNC_NAME(RADEONPrepareTexturedVideo)(pScrn, pPriv))
+		return;
+	}
+	loop_boxes = MIN(radeon_cs_space_remaining(pScrn) / draw_size, nBox);
+	nBox -= loop_boxes;
+
+	BEGIN_RING(loop_boxes * 3 * pPriv->vtx_count + 5);
 	OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
-			    nBox * 3 * vtx_count + 1));
-	if (isplanar)
+			    loop_boxes * 3 * pPriv->vtx_count + 1));
+	if (pPriv->is_planar)
 	    OUT_RING(RADEON_CP_VC_FRMT_XY |
 		     RADEON_CP_VC_FRMT_ST0 |
 		     RADEON_CP_VC_FRMT_ST1);
@@ -406,15 +432,64 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		 RADEON_CP_VC_CNTL_MAOS_ENABLE |
 		 RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
-		 ((nBox * 3) << RADEON_CP_VC_CNTL_NUM_SHIFT));
-#else /* ACCEL_CP */
-	BEGIN_ACCEL(nBox * vtx_count * 3 + 2);
-	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
-					  RADEON_VF_PRIM_WALK_DATA |
-					  RADEON_VF_RADEON_MODE |
-					  ((nBox * 3) << RADEON_VF_NUM_VERTICES_SHIFT)));
-#endif
+		 ((loop_boxes * 3) << RADEON_CP_VC_CNTL_NUM_SHIFT));
+
+	while (loop_boxes--) {
+	    int srcX, srcY, srcw, srch;
+	    int dstX, dstY, dstw, dsth;
+	    dstX = pBox->x1 + dstxoff;
+	    dstY = pBox->y1 + dstyoff;
+	    dstw = pBox->x2 - pBox->x1;
+	    dsth = pBox->y2 - pBox->y1;
+
+	    srcX = pPriv->src_x;
+	    srcX += ((pBox->x1 - pPriv->drw_x) *
+		     pPriv->src_w) / pPriv->dst_w;
+	    srcY = pPriv->src_y;
+	    srcY += ((pBox->y1 - pPriv->drw_y) *
+		     pPriv->src_h) / pPriv->dst_h;
+
+	    srcw = (pPriv->src_w * dstw) / pPriv->dst_w;
+	    srch = (pPriv->src_h * dsth) / pPriv->dst_h;
 
+
+	    if (pPriv->is_planar) {
+		/*
+		 * Just render a rect (using three coords).
+		 */
+		VTX_OUT_6((float)dstX,                     (float)(dstY + dsth),
+			  (float)srcX / pPriv->w,          (float)(srcY + srch) / pPriv->h,
+			  (float)srcX / pPriv->w,          (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_6((float)(dstX + dstw),            (float)(dstY + dsth),
+			  (float)(srcX + srcw) / pPriv->w, (float)(srcY + srch) / pPriv->h,
+			  (float)(srcX + srcw) / pPriv->w, (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_6((float)(dstX + dstw),            (float)dstY,
+			  (float)(srcX + srcw) / pPriv->w, (float)srcY / pPriv->h,
+			  (float)(srcX + srcw) / pPriv->w, (float)srcY / pPriv->h);
+	    } else {
+		/*
+		 * Just render a rect (using three coords).
+		 */
+		VTX_OUT_4((float)dstX,                     (float)(dstY + dsth),
+			  (float)srcX / pPriv->w,          (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_4((float)(dstX + dstw),            (float)(dstY + dsth),
+			  (float)(srcX + srcw) / pPriv->w, (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_4((float)(dstX + dstw),            (float)dstY,
+			  (float)(srcX + srcw) / pPriv->w, (float)srcY / pPriv->h);
+	    }
+
+	    pBox++;
+	}
+
+	OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
+	ADVANCE_RING();
+    }
+#else /* ACCEL_CP */
+    BEGIN_ACCEL(nBox * pPriv->vtx_count * 3 + 2);
+    OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
+				      RADEON_VF_PRIM_WALK_DATA |
+				      RADEON_VF_RADEON_MODE |
+				      ((nBox * 3) << RADEON_VF_NUM_VERTICES_SHIFT)));
     while (nBox--) {
 	int srcX, srcY, srcw, srch;
 	int dstX, dstY, dstw, dsth;
@@ -434,7 +509,7 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	srch = (pPriv->src_h * dsth) / pPriv->dst_h;
 
 
-	if (isplanar) {
+	if (pPriv->is_planar) {
 	    /*
 	     * Just render a rect (using three coords).
 	     */
@@ -463,17 +538,14 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
     }
 
     OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
-#ifdef ACCEL_CP
-	ADVANCE_RING();
-#else
-	FINISH_ACCEL();
+    FINISH_ACCEL();
 #endif /* !ACCEL_CP */
 
     DamageDamageRegion(pPriv->pDraw, &pPriv->clip);
 }
 
-static void
-FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+static Bool
+FUNC_NAME(R200PrepareTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     PixmapPtr pPixmap = pPriv->pPixmap;
@@ -483,11 +555,9 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     uint32_t txfilter, txsize, txpitch, txoffset;
     uint32_t dst_pitch, dst_format;
     uint32_t colorpitch;
-    Bool isplanar = FALSE;
-    int dstxoff, dstyoff, pixel_shift, vtx_count;
-    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
-    int nBox = REGION_NUM_RECTS(&pPriv->clip);
-
+    int pixel_shift;
+    int scissor_w = MIN(pPixmap->drawable.width, 2047);
+    int scissor_h = MIN(pPixmap->drawable.height, 2047);
     /* note: in contrast to r300, use input biasing on uv components */
     const float Loff = -0.0627;
     float uvcosf, uvsinf;
@@ -515,7 +585,7 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	ret = radeon_cs_space_check(info->cs);
 	if (ret) {
 	    ErrorF("Not enough RAM to hw accel xv operation\n");
-	    return;
+	    return FALSE;
 	}
     }
 #endif
@@ -531,14 +601,6 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	dst_pitch = pPixmap->devKind;
     }
 
-#ifdef COMPOSITE
-    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
-    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
-#else
-    dstxoff = 0;
-    dstyoff = 0;
-#endif
-
 #ifdef USE_EXA
     if (info->useEXA) {
 	RADEON_SWITCH_TO_3D();
@@ -571,13 +633,14 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	dst_format = RADEON_COLOR_FORMAT_ARGB8888;
 	break;
     default:
-	return;
+	return FALSE;
     }
 
     if (pPriv->id == FOURCC_I420 || pPriv->id == FOURCC_YV12) {
-	isplanar = TRUE;
+	pPriv->is_planar = TRUE;
 	txformat = RADEON_TXFORMAT_I8;
     } else {
+	pPriv->is_planar = FALSE;
 	if (pPriv->id == FOURCC_UYVY)
 	    txformat = RADEON_TXFORMAT_YVYU422;
 	else
@@ -640,11 +703,11 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
     txoffset = info->cs ? 0 : pPriv->src_offset;
 
-    if (isplanar) {
+    if (pPriv->is_planar) {
 	/* need 2 texcoord sets (even though they are identical) due
 	   to denormalization! hw apparently can't premultiply
 	   same coord set by different texture size */
-	vtx_count = 6;
+	pPriv->vtx_count = 6;
 
 	txsize = (((((pPriv->w + 1 ) >> 1) - 1) & 0x7ff) |
 		  (((((pPriv->h + 1 ) >> 1) - 1) & 0x7ff) << RADEON_TEX_VSIZE_SHIFT));
@@ -807,7 +870,7 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
 	FINISH_ACCEL();
     } else {
-	vtx_count = 4;
+	pPriv->vtx_count = 4;
 
 	BEGIN_ACCEL_RELOC(24, 1);
 
@@ -912,15 +975,10 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	FINISH_ACCEL();
     }
 
-    {
-      int scissor_w, scissor_h;
-      scissor_w = MIN(pPixmap->drawable.width, 2047);
-      scissor_h = MIN(pPixmap->drawable.height, 2047);
-      BEGIN_ACCEL(2);
-      OUT_ACCEL_REG(RADEON_RE_TOP_LEFT, 0);
-      OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, ((scissor_w << RADEON_RE_WIDTH_SHIFT) |
-					     (scissor_h << RADEON_RE_HEIGHT_SHIFT)));
-    }
+    BEGIN_ACCEL(2);
+    OUT_ACCEL_REG(RADEON_RE_TOP_LEFT, 0);
+    OUT_ACCEL_REG(RADEON_RE_WIDTH_HEIGHT, ((scissor_w << RADEON_RE_WIDTH_SHIFT) |
+					   (scissor_h << RADEON_RE_HEIGHT_SHIFT)));
     FINISH_ACCEL();
 
     if (pPriv->vsync) {
@@ -939,6 +997,31 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 					  pPriv->drw_y - crtc->y,
 					  (pPriv->drw_y - crtc->y) + pPriv->dst_h);
     }
+
+    return TRUE;
+}
+
+static void
+FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    PixmapPtr pPixmap = pPriv->pPixmap;
+    int dstxoff, dstyoff;
+    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
+    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    ACCEL_PREAMBLE();
+
+#ifdef COMPOSITE
+    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
+    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
+#else
+    dstxoff = 0;
+    dstyoff = 0;
+#endif
+
+    if (!FUNC_NAME(R200PrepareTexturedVideo)(pScrn, pPriv))
+	return;
+
     /*
      * Rendering of the actual polygon is done in two different
      * ways depending on chip generation:
@@ -960,20 +1043,82 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
      */
 
 #ifdef ACCEL_CP
-	BEGIN_RING(nBox * 3 * vtx_count + 4);
+    while (nBox) {
+	int draw_size = 3 * pPriv->vtx_count + 4;
+	int loop_boxes;
+
+	if (draw_size > radeon_cs_space_remaining(pScrn)) {
+	    if (info->cs)
+		radeon_cs_flush_indirect(pScrn);
+	    else
+		RADEONCPFlushIndirect(pScrn, 1);
+	    if (!FUNC_NAME(R200PrepareTexturedVideo)(pScrn, pPriv))
+		return;
+	}
+	loop_boxes = MIN(radeon_cs_space_remaining(pScrn) / draw_size, nBox);
+	nBox -= loop_boxes;
+
+	BEGIN_RING(loop_boxes * 3 * pPriv->vtx_count + 4);
 	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
-			    nBox * 3 * vtx_count));
+			    loop_boxes * 3 * pPriv->vtx_count));
 	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
 		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
-		 ((nBox * 3) << RADEON_CP_VC_CNTL_NUM_SHIFT));
-#else /* ACCEL_CP */
-	BEGIN_ACCEL(nBox * 3 * vtx_count + 2);
-	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
-					  RADEON_VF_PRIM_WALK_DATA |
-					  ((nBox * 3) << RADEON_VF_NUM_VERTICES_SHIFT)));
+		 ((loop_boxes * 3) << RADEON_CP_VC_CNTL_NUM_SHIFT));
+
+	while (loop_boxes--) {
+	    int srcX, srcY, srcw, srch;
+	    int dstX, dstY, dstw, dsth;
+	    dstX = pBox->x1 + dstxoff;
+	    dstY = pBox->y1 + dstyoff;
+	    dstw = pBox->x2 - pBox->x1;
+	    dsth = pBox->y2 - pBox->y1;
+
+	    srcX = pPriv->src_x;
+	    srcX += ((pBox->x1 - pPriv->drw_x) *
+		     pPriv->src_w) / pPriv->dst_w;
+	    srcY = pPriv->src_y;
+	    srcY += ((pBox->y1 - pPriv->drw_y) *
+		     pPriv->src_h) / pPriv->dst_h;
+
+	    srcw = (pPriv->src_w * dstw) / pPriv->dst_w;
+	    srch = (pPriv->src_h * dsth) / pPriv->dst_h;
+
+	    if (pPriv->is_planar) {
+		/*
+		 * Just render a rect (using three coords).
+		 */
+		VTX_OUT_6((float)dstX,                     (float)(dstY + dsth),
+			  (float)srcX / pPriv->w,          (float)(srcY + srch) / pPriv->h,
+			  (float)srcX / pPriv->w,          (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_6((float)(dstX + dstw),            (float)(dstY + dsth),
+			  (float)(srcX + srcw) / pPriv->w, (float)(srcY + srch) / pPriv->h,
+			  (float)(srcX + srcw) / pPriv->w, (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_6((float)(dstX + dstw),            (float)dstY,
+			  (float)(srcX + srcw) / pPriv->w, (float)srcY / pPriv->h,
+			  (float)(srcX + srcw) / pPriv->w, (float)srcY / pPriv->h);
+	    } else {
+		/*
+		 * Just render a rect (using three coords).
+		 */
+		VTX_OUT_4((float)dstX,                     (float)(dstY + dsth),
+			  (float)srcX / pPriv->w,          (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_4((float)(dstX + dstw),            (float)(dstY + dsth),
+			  (float)(srcX + srcw) / pPriv->w, (float)(srcY + srch) / pPriv->h);
+		VTX_OUT_4((float)(dstX + dstw),            (float)dstY,
+			  (float)(srcX + srcw) / pPriv->w, (float)srcY / pPriv->h);
+	    }
 
-#endif
+	    pBox++;
+	}
 
+	OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
+	ADVANCE_RING();
+    }
+#else /* ACCEL_CP */
+    BEGIN_ACCEL(nBox * 3 * pPriv->vtx_count + 2);
+    OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
+				      RADEON_VF_PRIM_WALK_DATA |
+				      ((nBox * 3) << RADEON_VF_NUM_VERTICES_SHIFT)));
     while (nBox--) {
 	int srcX, srcY, srcw, srch;
 	int dstX, dstY, dstw, dsth;
@@ -992,7 +1137,7 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	srcw = (pPriv->src_w * dstw) / pPriv->dst_w;
 	srch = (pPriv->src_h * dsth) / pPriv->dst_h;
 
-	if (isplanar) {
+	if (pPriv->is_planar) {
 	    /*
 	     * Just render a rect (using three coords).
 	     */
@@ -1021,18 +1166,14 @@ FUNC_NAME(R200DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     }
 
     OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
-
-#ifdef ACCEL_CP
-	ADVANCE_RING();
-#else
-	FINISH_ACCEL();
+    FINISH_ACCEL();
 #endif /* !ACCEL_CP */
 
     DamageDamageRegion(pPriv->pDraw, &pPriv->clip);
 }
 
-static void
-FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+static Bool
+FUNC_NAME(R300PrepareTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     PixmapPtr pPixmap = pPriv->pPixmap;
@@ -1042,10 +1183,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     uint32_t dst_pitch, dst_format;
     uint32_t txenable, colorpitch, bicubic_offset;
     uint32_t output_fmt;
-    Bool isplanar = FALSE;
-    int dstxoff, dstyoff, pixel_shift, vtx_count;
-    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
-    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    int pixel_shift;
     ACCEL_PREAMBLE();
 
 #ifdef XF86DRM_MODE
@@ -1064,7 +1202,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	ret = radeon_cs_space_check(info->cs);
 	if (ret) {
 	    ErrorF("Not enough RAM to hw accel xv operation\n");
-	    return;
+	    return FALSE;
 	}
     }
 #endif
@@ -1080,14 +1218,6 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	dst_pitch = pPixmap->devKind;
     }
 
-#ifdef COMPOSITE
-    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
-    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
-#else
-    dstxoff = 0;
-    dstyoff = 0;
-#endif
-
 #ifdef USE_EXA
     if (info->useEXA) {
 	RADEON_SWITCH_TO_3D();
@@ -1109,9 +1239,9 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     }
 
     if (pPriv->bicubic_enabled)
-	vtx_count = 6;
+	pPriv->vtx_count = 6;
     else
-	vtx_count = 4;
+	pPriv->vtx_count = 4;
 
     switch (pPixmap->drawable.bitsPerPixel) {
     case 16:
@@ -1124,7 +1254,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	dst_format = R300_COLORFORMAT_ARGB8888;
 	break;
     default:
-	return;
+	return FALSE;
     }
 
     output_fmt = (R300_OUT_FMT_C4_8 |
@@ -1142,9 +1272,11 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
     if (((pPriv->bicubic_state == BICUBIC_OFF)) &&
 	(pPriv->id == FOURCC_I420 || pPriv->id == FOURCC_YV12))
-	isplanar = TRUE;
+	pPriv->is_planar = TRUE;
+    else
+	pPriv->is_planar = FALSE;
 
-    if (isplanar) {
+    if (pPriv->is_planar) {
 	txformat1 = R300_TX_FORMAT_X8 | R300_TX_FORMAT_CACHE_HALF_REGION_0;
 	txpitch = pPriv->src_pitch;
     } else {
@@ -1177,7 +1309,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     OUT_ACCEL_REG(R300_TX_FILTER0_0, txfilter);
     OUT_ACCEL_REG(R300_TX_FILTER1_0, 0);
     OUT_ACCEL_REG(R300_TX_FORMAT0_0, txformat0);
-    if (isplanar)
+    if (pPriv->is_planar)
 	OUT_ACCEL_REG(R300_TX_FORMAT1_0, txformat1 | R300_TX_FORMAT_CACHE_HALF_REGION_0);
     else
 	OUT_ACCEL_REG(R300_TX_FORMAT1_0, txformat1);
@@ -1187,7 +1319,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
     txenable = R300_TEX_0_ENABLE;
 
-    if (isplanar) {
+    if (pPriv->is_planar) {
 	txformat0 = ((((((pPriv->w + 1 ) >> 1) - 1) & 0x7ff) << R300_TXWIDTH_SHIFT) |
 		     (((((pPriv->h + 1 ) >> 1 ) - 1) & 0x7ff) << R300_TXHEIGHT_SHIFT) |
 		     R300_TXPITCH_EN);
@@ -1824,7 +1956,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	       if that's of any use. */
 	}
 
-	if (isplanar) {
+	if (pPriv->is_planar) {
 	    BEGIN_ACCEL(needgamma ? 28 + 33 : 33);
 	    /* 2 components: same 2 for tex0/1/2 */
 	    OUT_ACCEL_REG(R300_RS_COUNT,
@@ -2296,7 +2428,7 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     /* no need to enable blending */
     OUT_ACCEL_REG(R300_RB3D_BLENDCNTL, RADEON_SRC_BLEND_GL_ONE | RADEON_DST_BLEND_GL_ZERO);
 
-    OUT_ACCEL_REG(R300_VAP_VTX_SIZE, vtx_count);
+    OUT_ACCEL_REG(R300_VAP_VTX_SIZE, pPriv->vtx_count);
     FINISH_ACCEL();
 
     if (pPriv->vsync) {
@@ -2315,6 +2447,31 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 					  pPriv->drw_y - crtc->y,
 					  (pPriv->drw_y - crtc->y) + pPriv->dst_h);
     }
+
+    return TRUE;
+}
+
+static void
+FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    PixmapPtr pPixmap = pPriv->pPixmap;
+    int dstxoff, dstyoff;
+    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
+    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    ACCEL_PREAMBLE();
+
+#ifdef COMPOSITE
+    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
+    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
+#else
+    dstxoff = 0;
+    dstyoff = 0;
+#endif
+
+    if (!FUNC_NAME(R300PrepareTexturedVideo)(pScrn, pPriv))
+	return;
+
     /*
      * Rendering of the actual polygon is done in two different
      * ways depending on chip generation:
@@ -2339,6 +2496,19 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	int srcX, srcY, srcw, srch;
 	int dstX, dstY, dstw, dsth;
 	Bool use_quad = FALSE;
+#ifdef ACCEL_CP
+	int draw_size = 4 * pPriv->vtx_count + 4 + 2 + 3;
+
+	if (draw_size > radeon_cs_space_remaining(pScrn)) {
+	    if (info->cs)
+		radeon_cs_flush_indirect(pScrn);
+	    else
+		RADEONCPFlushIndirect(pScrn, 1);
+	    if (!FUNC_NAME(R300PrepareTexturedVideo)(pScrn, pPriv))
+		return;
+	}
+#endif
+
 	dstX = pBox->x1 + dstxoff;
 	dstY = pBox->y1 + dstyoff;
 	dstw = pBox->x2 - pBox->x1;
@@ -2354,11 +2524,6 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	srcw = (pPriv->src_w * dstw) / pPriv->dst_w;
 	srch = (pPriv->src_h * dsth) / pPriv->dst_h;
 
-#if 0
-	ErrorF("dst: %d, %d, %d, %d\n", dstX, dstY, dstw, dsth);
-	ErrorF("src: %d, %d, %d, %d\n", srcX, srcY, srcw, srch);
-#endif
-
 	if (IS_R400_3D) {
 	    if ((dstw+dsth) > 4021)
 		use_quad = TRUE;
@@ -2379,25 +2544,25 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
 #ifdef ACCEL_CP
 	if (use_quad) {
-	    BEGIN_RING(4 * vtx_count + 4);
+	    BEGIN_RING(4 * pPriv->vtx_count + 4);
 	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
-				4 * vtx_count));
+				4 * pPriv->vtx_count));
 	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
 		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		     (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
 	} else {
-	    BEGIN_RING(3 * vtx_count + 4);
+	    BEGIN_RING(3 * pPriv->vtx_count + 4);
 	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
-				3 * vtx_count));
+				3 * pPriv->vtx_count));
 	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_LIST |
 		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		     (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
 	}
 #else /* ACCEL_CP */
 	if (use_quad)
-	    BEGIN_ACCEL(2 + vtx_count * 4);
+	    BEGIN_ACCEL(2 + pPriv->vtx_count * 4);
 	else
-	    BEGIN_ACCEL(2 + vtx_count * 3);
+	    BEGIN_ACCEL(2 + pPriv->vtx_count * 3);
 
 	if (use_quad)
 	    OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_QUAD_LIST |
@@ -2489,8 +2654,8 @@ FUNC_NAME(R300DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     DamageDamageRegion(pPriv->pDraw, &pPriv->clip);
 }
 
-static void
-FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+static Bool
+FUNC_NAME(R500PrepareTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     PixmapPtr pPixmap = pPriv->pPixmap;
@@ -2500,10 +2665,7 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     uint32_t dst_pitch, dst_format;
     uint32_t txenable, colorpitch, bicubic_offset;
     uint32_t output_fmt;
-    Bool isplanar = FALSE;
-    int dstxoff, dstyoff, pixel_shift, vtx_count;
-    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
-    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    int pixel_shift;
     ACCEL_PREAMBLE();
 
 #ifdef XF86DRM_MODE
@@ -2522,7 +2684,7 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	ret = radeon_cs_space_check(info->cs);
 	if (ret) {
 	    ErrorF("Not enough RAM to hw accel xv operation\n");
-	    return;
+	    return FALSE;
 	}
     }
 #endif
@@ -2538,14 +2700,6 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	dst_pitch = pPixmap->devKind;
     }
 
-#ifdef COMPOSITE
-    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
-    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
-#else
-    dstxoff = 0;
-    dstyoff = 0;
-#endif
-
 #ifdef USE_EXA
     if (info->useEXA) {
 	RADEON_SWITCH_TO_3D();
@@ -2567,9 +2721,9 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     }
 
     if (pPriv->bicubic_enabled)
-	vtx_count = 6;
+	pPriv->vtx_count = 6;
     else
-	vtx_count = 4;
+	pPriv->vtx_count = 4;
 
     switch (pPixmap->drawable.bitsPerPixel) {
     case 16:
@@ -2582,7 +2736,7 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	dst_format = R300_COLORFORMAT_ARGB8888;
 	break;
     default:
-	return;
+	return FALSE;
     }
 
     output_fmt = (R300_OUT_FMT_C4_8 |
@@ -2599,9 +2753,11 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
     if (((pPriv->bicubic_state == BICUBIC_OFF)) &&
         (pPriv->id == FOURCC_I420 || pPriv->id == FOURCC_YV12))
-	isplanar = TRUE;
+	pPriv->is_planar = TRUE;
+    else
+	pPriv->is_planar = FALSE;
 
-    if (isplanar) {
+    if (pPriv->is_planar) {
 	txformat1 = R300_TX_FORMAT_X8;
 	txpitch = pPriv->src_pitch;
     } else {
@@ -2648,7 +2804,7 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
     txenable = R300_TEX_0_ENABLE;
 
-    if (isplanar) {
+    if (pPriv->is_planar) {
 	txformat0 = ((((((pPriv->w + 1 ) >> 1) - 1) & 0x7ff) << R300_TXWIDTH_SHIFT) |
 		     (((((pPriv->h + 1 ) >> 1 ) - 1) & 0x7ff) << R300_TXHEIGHT_SHIFT) |
 		     R300_TXPITCH_EN);
@@ -3439,7 +3595,7 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	       if that's of any use. */
 	}
 
-	if (isplanar) {
+	if (pPriv->is_planar) {
 	    BEGIN_ACCEL(56);
 	    /* 2 components: 2 for tex0 */
 	    OUT_ACCEL_REG(R300_RS_COUNT,
@@ -3880,7 +4036,7 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     /* no need to enable blending */
     OUT_ACCEL_REG(R300_RB3D_BLENDCNTL, RADEON_SRC_BLEND_GL_ONE | RADEON_DST_BLEND_GL_ZERO);
 
-    OUT_ACCEL_REG(R300_VAP_VTX_SIZE, vtx_count);
+    OUT_ACCEL_REG(R300_VAP_VTX_SIZE, pPriv->vtx_count);
     FINISH_ACCEL();
 
     if (pPriv->vsync) {
@@ -3899,6 +4055,31 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 					  pPriv->drw_y - crtc->y,
 					  (pPriv->drw_y - crtc->y) + pPriv->dst_h);
     }
+
+    return TRUE;
+}
+
+static void
+FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    PixmapPtr pPixmap = pPriv->pPixmap;
+    int dstxoff, dstyoff;
+    BoxPtr pBox = REGION_RECTS(&pPriv->clip);
+    int nBox = REGION_NUM_RECTS(&pPriv->clip);
+    ACCEL_PREAMBLE();
+
+#ifdef COMPOSITE
+    dstxoff = -pPixmap->screen_x + pPixmap->drawable.x;
+    dstyoff = -pPixmap->screen_y + pPixmap->drawable.y;
+#else
+    dstxoff = 0;
+    dstyoff = 0;
+#endif
+
+    if (!FUNC_NAME(R500PrepareTexturedVideo)(pScrn, pPriv))
+	return;
+
     /*
      * Rendering of the actual polygon is done in two different
      * ways depending on chip generation:
@@ -3922,6 +4103,19 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     while (nBox--) {
 	int srcX, srcY, srcw, srch;
 	int dstX, dstY, dstw, dsth;
+#ifdef ACCEL_CP
+	int draw_size = 3 * pPriv->vtx_count + 4 + 2 + 3;
+
+	if (draw_size > radeon_cs_space_remaining(pScrn)) {
+	    if (info->cs)
+		radeon_cs_flush_indirect(pScrn);
+	    else
+		RADEONCPFlushIndirect(pScrn, 1);
+	    if (!FUNC_NAME(R500PrepareTexturedVideo)(pScrn, pPriv))
+		return;
+	}
+#endif
+
 	dstX = pBox->x1 + dstxoff;
 	dstY = pBox->y1 + dstyoff;
 	dstw = pBox->x2 - pBox->x1;
@@ -3945,14 +4139,14 @@ FUNC_NAME(R500DisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	FINISH_ACCEL();
 
 #ifdef ACCEL_CP
-	BEGIN_RING(3 * vtx_count + 4);
+	BEGIN_RING(3 * pPriv->vtx_count + 4);
 	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
-			    3 * vtx_count));
+			    3 * pPriv->vtx_count));
 	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_LIST |
 		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		 (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
 #else /* ACCEL_CP */
-	BEGIN_ACCEL(2 + vtx_count * 3);
+	BEGIN_ACCEL(2 + pPriv->vtx_count * 3);
 	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_TRIANGLE_LIST |
 					  RADEON_VF_PRIM_WALK_DATA |
 					  (3 << RADEON_VF_NUM_VERTICES_SHIFT)));
diff --git a/src/radeon_vbo.c b/src/radeon_vbo.c
index ad650b2..0735540 100644
--- a/src/radeon_vbo.c
+++ b/src/radeon_vbo.c
@@ -97,19 +97,19 @@ void radeon_vbo_free_lists(ScrnInfoPtr pScrn)
     foreach_s(dma_bo, temp, &accel_state->bo_free) {
 	remove_from_list(dma_bo);
 	radeon_bo_unref(dma_bo->bo);
-	xfree(dma_bo);
+	free(dma_bo);
     }
 
     foreach_s(dma_bo, temp, &accel_state->bo_wait) {
 	remove_from_list(dma_bo);
 	radeon_bo_unref(dma_bo->bo);
-	xfree(dma_bo);
+	free(dma_bo);
     }
 
     foreach_s(dma_bo, temp, &accel_state->bo_reserved) {
 	remove_from_list(dma_bo);
 	radeon_bo_unref(dma_bo->bo);
-	xfree(dma_bo);
+	free(dma_bo);
     }
 }
 
@@ -126,7 +126,7 @@ void radeon_vbo_flush_bos(ScrnInfoPtr pScrn)
 	    ErrorF("leaking dma buffer\n");
 	    while ((dma_bo->bo = radeon_bo_unref(dma_bo->bo))) {}
 	    remove_from_list(dma_bo);
-	    xfree(dma_bo);
+	    free(dma_bo);
 	    continue;
 	}
 
@@ -157,7 +157,7 @@ void radeon_vbo_flush_bos(ScrnInfoPtr pScrn)
 
 	remove_from_list(dma_bo);
 	radeon_bo_unref(dma_bo->bo);
-	xfree(dma_bo);
+	free(dma_bo);
     }
 }
 
@@ -169,7 +169,7 @@ static struct radeon_bo *radeon_vbo_get_bo(ScrnInfoPtr pScrn)
     struct radeon_bo *bo;
 
     if (is_empty_list(&accel_state->bo_free)) {
-	dma_bo = xcalloc(1, sizeof(struct radeon_dma_bo));
+	dma_bo = calloc(1, sizeof(struct radeon_dma_bo));
 	if (!dma_bo)
 	    return NULL;
 
diff --git a/src/radeon_video.c b/src/radeon_video.c
index 8f0917f..dc75279 100644
--- a/src/radeon_video.c
+++ b/src/radeon_video.c
@@ -271,13 +271,17 @@ void RADEONInitVideo(ScreenPtr pScreen)
 {
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr    info = RADEONPTR(pScrn);
+    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
     XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
     XF86VideoAdaptorPtr overlayAdaptor = NULL, texturedAdaptor = NULL;
     int num_adaptors;
 
+    /* no overlay or 3D on RN50 */
+    if (info->ChipFamily == CHIP_FAMILY_RV100 && !pRADEONEnt->HasCRTC2)
+	    return;
 
     num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
-    newAdaptors = xalloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
+    newAdaptors = malloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
     if (newAdaptors == NULL)
 	return;
 
@@ -312,7 +316,7 @@ void RADEONInitVideo(ScreenPtr pScreen)
 	xf86XVScreenInit(pScreen, adaptors, num_adaptors);
 
     if(newAdaptors)
-	xfree(newAdaptors);
+	free(newAdaptors);
 
 }
 
@@ -1400,7 +1404,7 @@ static void RADEONSetupTheatre(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
                         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                                 "Unsupported reference clock frequency, Rage Theatre disabled\n");
                         t->theatre_num=-1;
-			xfree(pPriv->theatre);
+			free(pPriv->theatre);
 			pPriv->theatre = NULL;
 			return;
                 }
@@ -1419,9 +1423,9 @@ RADEONAllocAdaptor(ScrnInfoPtr pScrn)
     if(!(adapt = xf86XVAllocateVideoAdaptorRec(pScrn)))
 	return NULL;
 
-    if(!(pPriv = xcalloc(1, sizeof(RADEONPortPrivRec) + sizeof(DevUnion))))
+    if(!(pPriv = calloc(1, sizeof(RADEONPortPrivRec) + sizeof(DevUnion))))
     {
-	xfree(adapt);
+	free(adapt);
 	return NULL;
     }
 
@@ -1534,7 +1538,7 @@ RADEONAllocAdaptor(ScrnInfoPtr pScrn)
 				if(!xf86LoadSubModule(pScrn,"theatre")) 
 				{
 					xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Unable to load Rage Theatre module\n");
-					xfree(pPriv->theatre);
+					free(pPriv->theatre);
 					goto skip_theatre;
 				}
 				break;
@@ -1544,7 +1548,7 @@ RADEONAllocAdaptor(ScrnInfoPtr pScrn)
 				if(!xf86LoadSubModule(pScrn,"theatre200")) 
 				{
 					xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Unable to load Rage Theatre module\n");
-					xfree(pPriv->theatre);
+					free(pPriv->theatre);
 					goto skip_theatre;
 				}
 				pPriv->theatre->microc_path = info->RageTheatreMicrocPath;
@@ -1554,7 +1558,7 @@ RADEONAllocAdaptor(ScrnInfoPtr pScrn)
 			default:
 			{
 				xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Unknown Theatre chip\n");
-				xfree(pPriv->theatre);
+				free(pPriv->theatre);
 				goto skip_theatre;
 			}
 		}
@@ -1565,7 +1569,7 @@ RADEONAllocAdaptor(ScrnInfoPtr pScrn)
 		xf86_InitTheatre(pPriv->theatre);
 		if(pPriv->theatre->mode == MODE_UNINITIALIZED)
 		{
-			Xfree(pPriv->theatre);
+			free(pPriv->theatre);
 			pPriv->theatre = NULL;
 			xf86DrvMsg(pScrn->scrnIndex,X_INFO,"Rage Theatre disabled\n");
 			/* Here the modules must be unloaded */
@@ -3188,18 +3192,18 @@ RADEONAllocateSurface(
     surface->width = w;
     surface->height = h;
 
-    if(!(surface->pitches = xalloc(sizeof(int)))) {
+    if(!(surface->pitches = malloc(sizeof(int)))) {
 	radeon_legacy_free_memory(pScrn, surface_memory);
 	return BadAlloc;
     }
-    if(!(surface->offsets = xalloc(sizeof(int)))) {
-	xfree(surface->pitches);
+    if(!(surface->offsets = malloc(sizeof(int)))) {
+	free(surface->pitches);
 	radeon_legacy_free_memory(pScrn, surface_memory);
 	return BadAlloc;
     }
-    if(!(pPriv = xalloc(sizeof(OffscreenPrivRec)))) {
-	xfree(surface->pitches);
-	xfree(surface->offsets);
+    if(!(pPriv = malloc(sizeof(OffscreenPrivRec)))) {
+	free(surface->pitches);
+	free(surface->offsets);
 	radeon_legacy_free_memory(pScrn, surface_memory);
 	return BadAlloc;
     }
@@ -3243,9 +3247,9 @@ RADEONFreeSurface(
 	RADEONStopSurface(surface);
     radeon_legacy_free_memory(pScrn, pPriv->surface_memory);
     pPriv->surface_memory = NULL;
-    xfree(surface->pitches);
-    xfree(surface->offsets);
-    xfree(surface->devPrivate.ptr);
+    free(surface->pitches);
+    free(surface->offsets);
+    free(surface->devPrivate.ptr);
 
     return Success;
 }
@@ -3360,7 +3364,7 @@ RADEONInitOffscreenImages(ScreenPtr pScreen)
     XF86OffscreenImagePtr offscreenImages;
     /* need to free this someplace */
 
-    if (!(offscreenImages = xalloc(sizeof(XF86OffscreenImageRec))))
+    if (!(offscreenImages = malloc(sizeof(XF86OffscreenImageRec))))
 	return;
 
     offscreenImages[0].image = &Images[0];
diff --git a/src/radeon_video.h b/src/radeon_video.h
index be3df69..ab0c433 100644
--- a/src/radeon_video.h
+++ b/src/radeon_video.h
@@ -118,6 +118,8 @@ typedef struct {
     int drw_x, drw_y;
     int src_x, src_y;
     int vsync;
+    Bool is_planar;
+    int vtx_count;
 
     struct radeon_bo *src_bo[2];
 } RADEONPortPrivRec, *RADEONPortPrivPtr;
diff --git a/src/radeon_vip.c b/src/radeon_vip.c
index 05b90f1..8457078 100644
--- a/src/radeon_vip.c
+++ b/src/radeon_vip.c
@@ -349,7 +349,7 @@ void RADEONVIP_reset(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
 void RADEONVIP_init(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 {
-    pPriv->VIP=xcalloc(1,sizeof(GENERIC_BUS_Rec));
+    pPriv->VIP=calloc(1,sizeof(GENERIC_BUS_Rec));
     pPriv->VIP->scrnIndex=pScrn->scrnIndex;
     pPriv->VIP->DriverPrivate.ptr=pPriv;
     pPriv->VIP->ioctl=RADEONVIP_ioctl;
diff --git a/src/theatre200.c b/src/theatre200.c
index c150ed4..16b1840 100644
--- a/src/theatre200.c
+++ b/src/theatre200.c
@@ -318,10 +318,10 @@ fail_exit:
 	curr_seg = seg_list;
 	while(curr_seg)
 	{
-		Xfree(curr_seg->data);
+		free(curr_seg->data);
 		prev_seg = curr_seg;
 		curr_seg = curr_seg->next;
-		Xfree(prev_seg);
+		free(prev_seg);
 	}
 	fclose(file);
 
@@ -335,10 +335,10 @@ static void microc_clean(struct rt200_microc_data* microc_datap, int screen)
 
 	while(seg_list)
 	{
-		Xfree(seg_list->data);
+		free(seg_list->data);
 		prev_seg = seg_list;
 		seg_list = seg_list->next;
-		Xfree(prev_seg);
+		free(prev_seg);
 	}
 }
 
