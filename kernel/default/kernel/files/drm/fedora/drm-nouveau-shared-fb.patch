From 42670e54412d2b72248bca3fe8c9bd76aa98ebfa Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Sun, 28 Jun 2009 20:24:26 +1000
Subject: [PATCH 2/6] drm/nouveau: support needed for multiple xservers

---
 drivers/gpu/drm/nouveau/nouveau_drv.h   |    2 +
 drivers/gpu/drm/nouveau/nouveau_state.c |   66 +++++++++++++++++++++++++++++++
 2 files changed, 68 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index 5f8cbb7..bf9acc6 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -593,6 +593,8 @@ struct drm_nouveau_private {
 	struct {
 		struct dentry *channel_root;
 	} debugfs;
+
+	struct drm_gem_object *sfb_gem;
 };
 
 static inline struct drm_nouveau_private *
diff --git a/drivers/gpu/drm/nouveau/nouveau_state.c b/drivers/gpu/drm/nouveau/nouveau_state.c
index e76ec2d..36f8268 100644
--- a/drivers/gpu/drm/nouveau/nouveau_state.c
+++ b/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -37,6 +37,50 @@
 static int nouveau_stub_init(struct drm_device *dev) { return 0; }
 static void nouveau_stub_takedown(struct drm_device *dev) {}
 
+static int
+sfbhack_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_bo *nvbo = NULL;
+	uint32_t tile_flags = dev_priv->card_type == NV_50 ? 0x7000 : 0x0000;
+	int ret, size;
+
+	if (dev_priv->sfb_gem)
+		return 0;
+
+	size = nouveau_mem_fb_amount(dev);
+	if (size > drm_get_resource_len(dev, 1))
+		size = drm_get_resource_len(dev, 1);
+	size >>= 1;
+
+	ret = nouveau_gem_new(dev, dev_priv->channel, size, 0, TTM_PL_FLAG_VRAM,
+			      0, tile_flags, false, true, &nvbo);
+	if (ret)
+		return ret;
+
+	ret = nouveau_bo_pin(nvbo, TTM_PL_FLAG_VRAM);
+	if (ret) {
+		nouveau_bo_ref(NULL, &nvbo);
+		return ret;
+	}
+
+	dev_priv->sfb_gem = nvbo->gem;
+	return 0;
+}
+
+static void
+sfbhack_takedown(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	if (dev_priv->sfb_gem) {
+		mutex_lock(&dev->struct_mutex);
+		drm_gem_object_unreference(dev_priv->sfb_gem);
+		mutex_unlock(&dev->struct_mutex);
+		dev_priv->sfb_gem = NULL;
+	}
+}
+
 static int nouveau_init_engine_ptrs(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -712,6 +756,8 @@ static void nouveau_close(struct drm_device *dev)
 /* KMS: we need mmio at load time, not when the first drm client opens. */
 void nouveau_lastclose(struct drm_device *dev)
 {
+	sfbhack_takedown(dev);
+
 	if (drm_core_check_feature(dev, DRIVER_MODESET))
 		return;
 
@@ -750,6 +796,8 @@ int nouveau_ioctl_getparam(struct drm_device *dev, void *data,
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct drm_nouveau_getparam *getparam = data;
+	uint32_t sfb_handle;
+	int ret;
 
 	NOUVEAU_CHECK_INITIALISED_WITH_RETURN;
 
@@ -795,6 +843,24 @@ int nouveau_ioctl_getparam(struct drm_device *dev, void *data,
 	case NOUVEAU_GETPARAM_VM_VRAM_BASE:
 		getparam->value = dev_priv->vm_vram_base;
 		break;
+	case 0xdeadcafe00000001: /* NOUVEAU_GETPARAM_SHAREDFB_HANDLE */
+		ret = sfbhack_init(dev);
+		if (ret)
+			return ret;
+
+		ret = drm_gem_handle_create(file_priv, dev_priv->sfb_gem,
+					    &sfb_handle);
+		if (ret)
+			return ret;
+		getparam->value = sfb_handle;
+		break;
+	case 0xdeadcafe00000002: /* NOUVEAU_GETPARAM_SHAREDFB_SIZE */
+		ret = sfbhack_init(dev);
+		if (ret)
+			return ret;
+
+		getparam->value = dev_priv->sfb_gem->size;
+		break;
 	default:
 		NV_ERROR(dev, "unknown parameter %lld\n", getparam->param);
 		return -EINVAL;
-- 
1.6.5.2

