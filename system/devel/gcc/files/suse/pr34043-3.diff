2008-02-29  Richard Guenther  <rguenther@suse.de>

	* fold-const.c (fold_unary): Fold VIEW_CONVERT_EXPR of
	integral and pointer arguments which do not change the
	precision to NOP_EXPRs.
	[* tree-ssa-loop-ivopts.c (may_be_nonaddressable_p): Adjust
	VIEW_CONVERT_EXPR case.
	-- obsoleted by later 4.3 commit ]

Index: gcc/fold-const.c
===================================================================
--- gcc/fold-const.c.orig	2009-07-07 11:19:07.000000000 +0200
+++ gcc/fold-const.c	2009-11-20 13:51:03.000000000 +0100
@@ -8299,13 +8299,33 @@ fold_unary (enum tree_code code, tree ty
     case VIEW_CONVERT_EXPR:
       if (TREE_TYPE (op0) == type)
 	return op0;
-      if (TREE_CODE (op0) == VIEW_CONVERT_EXPR
-	  || (TREE_CODE (op0) == NOP_EXPR
-	      && INTEGRAL_TYPE_P (TREE_TYPE (op0))
-	      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))
-	      && TYPE_PRECISION (TREE_TYPE (op0))
-		 == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))))
+      if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)
 	return fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
+
+      /* For integral conversions with the same precision or pointer
+	 conversions use a NOP_EXPR instead.  */
+      if ((INTEGRAL_TYPE_P (type)
+	   || POINTER_TYPE_P (type))
+	  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))
+	      || POINTER_TYPE_P (TREE_TYPE (op0)))
+	  && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op0))
+	  /* Do not muck with VIEW_CONVERT_EXPRs that convert from
+	     a sub-type to its base type as generated by the Ada FE.  */
+	  && !(INTEGRAL_TYPE_P (TREE_TYPE (op0))
+	       && TREE_TYPE (TREE_TYPE (op0))))
+	return fold_convert (type, op0);
+
+      /* Strip inner integral conversions that do not change the precision.  */
+      if ((TREE_CODE (op0) == NOP_EXPR
+	   || TREE_CODE (op0) == CONVERT_EXPR)
+	  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))
+	      || POINTER_TYPE_P (TREE_TYPE (op0)))
+	  && (INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))
+	      || POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0))))
+	  && (TYPE_PRECISION (TREE_TYPE (op0))
+	      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))))
+	return fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));
+
       return fold_view_convert_expr (type, op0);
 
     case NEGATE_EXPR:
Index: gcc/tree-ssa-loop-im.c
===================================================================
--- gcc/tree-ssa-loop-im.c.orig	2009-06-24 16:52:45.000000000 +0200
+++ gcc/tree-ssa-loop-im.c	2009-11-20 13:51:03.000000000 +0100
@@ -208,6 +208,10 @@ for_each_index (tree *addr_p, bool (*cbc
 	case CONSTRUCTOR:
 	  return true;
 
+	case ADDR_EXPR:
+	  gcc_assert (is_gimple_min_invariant (*addr_p));
+	  return true;
+
 	case TARGET_MEM_REF:
 	  idx = &TMR_BASE (*addr_p);
 	  if (*idx
